begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  * Authors: Doug Rabson<dfr@rabson.org>  * Developed with Red Inc: Alfred Perlstein<alfred@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsmount.h>
end_include

begin_include
include|#
directive|include
file|<nlm/nlm_prot.h>
end_include

begin_include
include|#
directive|include
file|<nlm/nlm.h>
end_include

begin_comment
comment|/*  * We need to keep track of the svid values used for F_FLOCK locks.  */
end_comment

begin_struct
struct|struct
name|nlm_file_svid
block|{
name|int
name|ns_refs
decl_stmt|;
comment|/* thread count + 1 if active */
name|int
name|ns_svid
decl_stmt|;
comment|/* on-the-wire SVID for this file */
name|struct
name|ucred
modifier|*
name|ns_ucred
decl_stmt|;
comment|/* creds to use for lock recovery */
name|void
modifier|*
name|ns_id
decl_stmt|;
comment|/* local struct file pointer */
name|bool_t
name|ns_active
decl_stmt|;
comment|/* TRUE if we own a lock */
name|LIST_ENTRY
argument_list|(
argument|nlm_file_svid
argument_list|)
name|ns_link
expr_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|nlm_file_svid_list
argument_list|,
name|nlm_file_svid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NLM_SVID_HASH_SIZE
value|256
end_define

begin_decl_stmt
name|struct
name|nlm_file_svid_list
name|nlm_file_svids
index|[
name|NLM_SVID_HASH_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|mtx
name|nlm_svid_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|unrhdr
modifier|*
name|nlm_svid_allocator
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|volatile
name|u_int
name|nlm_xid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|nlm_setlock
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|struct
name|timeval
modifier|*
name|timo
parameter_list|,
name|int
name|retries
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|,
name|bool_t
name|reclaim
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlm_clearlock
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|struct
name|timeval
modifier|*
name|timo
parameter_list|,
name|int
name|retries
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlm_getlock
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|struct
name|timeval
modifier|*
name|timo
parameter_list|,
name|int
name|retries
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlm_map_status
parameter_list|(
name|nlm4_stats
name|stat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|nlm_file_svid
modifier|*
name|nlm_find_svid
parameter_list|(
name|void
modifier|*
name|id
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nlm_free_svid
parameter_list|(
name|struct
name|nlm_file_svid
modifier|*
name|nf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|nlm_init_lock
parameter_list|(
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|,
name|struct
name|nlm4_lock
modifier|*
name|lock
parameter_list|,
name|char
name|oh_space
index|[
literal|32
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|nlm_client_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|,
literal|"NLM svid lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* pid_max cannot be greater than PID_MAX */
name|nlm_svid_allocator
operator|=
name|new_unrhdr
argument_list|(
name|PID_MAX
operator|+
literal|2
argument_list|,
name|INT_MAX
argument_list|,
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLM_SVID_HASH_SIZE
condition|;
name|i
operator|++
control|)
name|LIST_INIT
argument_list|(
operator|&
name|nlm_file_svids
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|nlm_client_init
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|nlm_client_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|nlm_msg
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|server
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|td
condition|?
name|td
operator|->
name|td_proc
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s, error %d\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tprintf
argument_list|(
name|p
argument_list|,
name|LOG_INFO
argument_list|,
literal|"nfs server %s: %s\n"
argument_list|,
name|server
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|nlm_feedback_arg
block|{
name|bool_t
name|nf_printed
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nf_nmp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|nlm_down
parameter_list|(
name|struct
name|nlm_feedback_arg
modifier|*
name|nf
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|nf
operator|->
name|nf_nmp
decl_stmt|;
if|if
condition|(
name|nmp
operator|==
name|NULL
condition|)
return|return;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
operator|)
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator||=
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
name|nf
operator|->
name|nf_printed
operator|=
name|TRUE
expr_stmt|;
name|nlm_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_up
parameter_list|(
name|struct
name|nlm_feedback_arg
modifier|*
name|nf
parameter_list|,
name|struct
name|thread
modifier|*
name|td
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|struct
name|nfsmount
modifier|*
name|nmp
init|=
name|nf
operator|->
name|nf_nmp
decl_stmt|;
if|if
condition|(
operator|!
name|nf
operator|->
name|nf_printed
condition|)
return|return;
name|nlm_msg
argument_list|(
name|td
argument_list|,
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_mntfromname
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_state
operator|&
name|NFSSTA_LOCKTIMEO
condition|)
block|{
name|nmp
operator|->
name|nm_state
operator|&=
operator|~
name|NFSSTA_LOCKTIMEO
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
name|vfs_event_signal
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mountp
operator|->
name|mnt_stat
operator|.
name|f_fsid
argument_list|,
name|VQ_NOTRESPLOCK
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nmp
operator|->
name|nm_mtx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_feedback
parameter_list|(
name|int
name|type
parameter_list|,
name|int
name|proc
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|nlm_feedback_arg
modifier|*
name|nf
init|=
operator|(
expr|struct
name|nlm_feedback_arg
operator|*
operator|)
name|arg
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FEEDBACK_REXMIT2
case|:
case|case
name|FEEDBACK_RECONNECT
case|:
name|nlm_down
argument_list|(
name|nf
argument_list|,
name|td
argument_list|,
literal|"lockd not responding"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|FEEDBACK_OK
case|:
name|nlm_up
argument_list|(
name|nf
argument_list|,
name|td
argument_list|,
literal|"lockd is alive again"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * nlm_advlock --  *      NFS advisory byte-level locks.  */
end_comment

begin_function
specifier|static
name|int
name|nlm_advlock_internal
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|id
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|bool_t
name|reclaim
parameter_list|,
name|bool_t
name|unlock_vp
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|nfsmount
modifier|*
name|nmp
decl_stmt|;
name|off_t
name|size
decl_stmt|;
name|size_t
name|fhlen
decl_stmt|;
name|union
name|nfsfh
name|fh
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|char
modifier|*
name|servername
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
name|int
name|retries
decl_stmt|;
name|rpcvers_t
name|vers
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|struct
name|rpc_callextra
name|ext
decl_stmt|;
name|struct
name|nlm_feedback_arg
name|nf
decl_stmt|;
name|AUTH
modifier|*
name|auth
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|,
modifier|*
name|cred1
decl_stmt|;
name|struct
name|nlm_file_svid
modifier|*
name|ns
decl_stmt|;
name|int
name|svid
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|is_v3
decl_stmt|;
name|ASSERT_VOP_LOCKED
argument_list|(
name|vp
argument_list|,
literal|"nlm_advlock_1"
argument_list|)
expr_stmt|;
name|servername
operator|=
name|malloc
argument_list|(
name|MNAMELEN
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* XXXKIB vp locked */
name|nmp
operator|=
name|VFSTONFS
argument_list|(
name|vp
operator|->
name|v_mount
argument_list|)
expr_stmt|;
comment|/* 	 * Push any pending writes to the server and flush our cache 	 * so that if we are contending with another machine for a 	 * file, we get whatever they wrote and vice-versa. 	 */
if|if
condition|(
name|op
operator|==
name|F_SETLK
operator|||
name|op
operator|==
name|F_UNLCK
condition|)
name|nmp
operator|->
name|nm_vinvalbuf
argument_list|(
name|vp
argument_list|,
name|V_SAVE
argument_list|,
name|td
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|servername
argument_list|,
name|nmp
operator|->
name|nm_hostname
argument_list|)
expr_stmt|;
name|nmp
operator|->
name|nm_getinfo
argument_list|(
name|vp
argument_list|,
name|fh
operator|.
name|fh_bytes
argument_list|,
operator|&
name|fhlen
argument_list|,
operator|&
name|ss
argument_list|,
operator|&
name|is_v3
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|timo
argument_list|)
expr_stmt|;
name|sa
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
if|if
condition|(
name|is_v3
operator|!=
literal|0
condition|)
name|vers
operator|=
name|NLM_VERS4
expr_stmt|;
else|else
name|vers
operator|=
name|NLM_VERS
expr_stmt|;
if|if
condition|(
name|nmp
operator|->
name|nm_flag
operator|&
name|NFSMNT_SOFT
condition|)
name|retries
operator|=
name|nmp
operator|->
name|nm_retry
expr_stmt|;
else|else
name|retries
operator|=
name|INT_MAX
expr_stmt|;
comment|/* 	 * We need to switch to mount-point creds so that we can send 	 * packets from a privileged port.  Reference mnt_cred and 	 * switch to them before unlocking the vnode, since mount 	 * point could be unmounted right after unlock. 	 */
name|cred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|vp
operator|->
name|v_mount
operator|->
name|mnt_cred
expr_stmt|;
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlock_vp
condition|)
name|VOP_UNLOCK
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_name
argument_list|(
name|servername
argument_list|,
name|sa
argument_list|,
name|vers
argument_list|)
expr_stmt|;
name|auth
operator|=
name|authunix_create
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|nf
operator|.
name|nf_printed
operator|=
name|FALSE
expr_stmt|;
name|nf
operator|.
name|nf_nmp
operator|=
name|nmp
expr_stmt|;
name|ext
operator|.
name|rc_auth
operator|=
name|auth
expr_stmt|;
name|ext
operator|.
name|rc_feedback
operator|=
name|nlm_feedback
expr_stmt|;
name|ext
operator|.
name|rc_feedback_arg
operator|=
operator|&
name|nf
expr_stmt|;
name|ext
operator|.
name|rc_timers
operator|=
name|NULL
expr_stmt|;
name|ns
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|F_FLOCK
condition|)
block|{
name|ns
operator|=
name|nlm_find_svid
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|fl
operator|->
name|l_start
operator|==
literal|0
operator|&&
name|fl
operator|->
name|l_len
operator|==
literal|0
argument_list|,
operator|(
literal|"F_FLOCK lock requests must be whole-file locks"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
operator|->
name|ns_ucred
condition|)
block|{
comment|/* 			 * Remember the creds used for locking in case 			 * we need to recover the lock later. 			 */
name|ns
operator|->
name|ns_ucred
operator|=
name|crdup
argument_list|(
name|cred
argument_list|)
expr_stmt|;
block|}
name|svid
operator|=
name|ns
operator|->
name|ns_svid
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|F_REMOTE
condition|)
block|{
comment|/* 		 * If we are recovering after a server restart or 		 * trashing locks on a force unmount, use the same 		 * svid as last time. 		 */
name|svid
operator|=
name|fl
operator|->
name|l_pid
expr_stmt|;
block|}
else|else
block|{
name|svid
operator|=
operator|(
operator|(
expr|struct
name|proc
operator|*
operator|)
name|id
operator|)
operator|->
name|p_pid
expr_stmt|;
block|}
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|F_SETLK
case|:
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|F_FLOCK
operator||
name|F_WAIT
operator|)
operator|)
operator|==
operator|(
name|F_FLOCK
operator||
name|F_WAIT
operator|)
operator|&&
name|fl
operator|->
name|l_type
operator|==
name|F_WRLCK
condition|)
block|{
comment|/* 			 * The semantics for flock(2) require that any 			 * shared lock on the file must be released 			 * before an exclusive lock is granted. The 			 * local locking code interprets this by 			 * unlocking the file before sleeping on a 			 * blocked exclusive lock request. We 			 * approximate this by first attempting 			 * non-blocking and if that fails, we unlock 			 * the file and block. 			 */
name|error
operator|=
name|nlm_setlock
argument_list|(
name|host
argument_list|,
operator|&
name|ext
argument_list|,
name|vers
argument_list|,
operator|&
name|timo
argument_list|,
name|retries
argument_list|,
name|vp
argument_list|,
name|F_SETLK
argument_list|,
name|fl
argument_list|,
name|flags
operator|&
operator|~
name|F_WAIT
argument_list|,
name|svid
argument_list|,
name|fhlen
argument_list|,
operator|&
name|fh
operator|.
name|fh_bytes
argument_list|,
name|size
argument_list|,
name|reclaim
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|error
operator|=
name|nlm_clearlock
argument_list|(
name|host
argument_list|,
operator|&
name|ext
argument_list|,
name|vers
argument_list|,
operator|&
name|timo
argument_list|,
name|retries
argument_list|,
name|vp
argument_list|,
name|F_UNLCK
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|fhlen
argument_list|,
operator|&
name|fh
operator|.
name|fh_bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fl
operator|->
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|ns_active
condition|)
block|{
name|ns
operator|->
name|ns_refs
operator|--
expr_stmt|;
name|ns
operator|->
name|ns_active
operator|=
name|FALSE
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
name|flags
operator||=
name|F_WAIT
expr_stmt|;
name|error
operator|=
name|nlm_setlock
argument_list|(
name|host
argument_list|,
operator|&
name|ext
argument_list|,
name|vers
argument_list|,
operator|&
name|timo
argument_list|,
name|retries
argument_list|,
name|vp
argument_list|,
name|F_SETLK
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|fhlen
argument_list|,
operator|&
name|fh
operator|.
name|fh_bytes
argument_list|,
name|size
argument_list|,
name|reclaim
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
name|nlm_setlock
argument_list|(
name|host
argument_list|,
operator|&
name|ext
argument_list|,
name|vers
argument_list|,
operator|&
name|timo
argument_list|,
name|retries
argument_list|,
name|vp
argument_list|,
name|op
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|fhlen
argument_list|,
operator|&
name|fh
operator|.
name|fh_bytes
argument_list|,
name|size
argument_list|,
name|reclaim
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|ns
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
operator|->
name|ns_active
condition|)
block|{
comment|/* 				 * Add one to the reference count to 				 * hold onto the SVID for the lifetime 				 * of the lock. Note that since 				 * F_FLOCK only supports whole-file 				 * locks, there can only be one active 				 * lock for this SVID. 				 */
name|ns
operator|->
name|ns_refs
operator|++
expr_stmt|;
name|ns
operator|->
name|ns_active
operator|=
name|TRUE
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|F_UNLCK
case|:
name|error
operator|=
name|nlm_clearlock
argument_list|(
name|host
argument_list|,
operator|&
name|ext
argument_list|,
name|vers
argument_list|,
operator|&
name|timo
argument_list|,
name|retries
argument_list|,
name|vp
argument_list|,
name|op
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|fhlen
argument_list|,
operator|&
name|fh
operator|.
name|fh_bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|ns
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|ns_active
condition|)
block|{
name|ns
operator|->
name|ns_refs
operator|--
expr_stmt|;
name|ns
operator|->
name|ns_active
operator|=
name|FALSE
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|F_GETLK
case|:
name|error
operator|=
name|nlm_getlock
argument_list|(
name|host
argument_list|,
operator|&
name|ext
argument_list|,
name|vers
argument_list|,
operator|&
name|timo
argument_list|,
name|retries
argument_list|,
name|vp
argument_list|,
name|op
argument_list|,
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|fhlen
argument_list|,
operator|&
name|fh
operator|.
name|fh_bytes
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ns
condition|)
name|nlm_free_svid
argument_list|(
name|ns
argument_list|)
expr_stmt|;
name|cred1
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|cred
expr_stmt|;
name|crfree
argument_list|(
name|cred1
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|auth
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|servername
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_advlock
parameter_list|(
name|struct
name|vop_advlock_args
modifier|*
name|ap
parameter_list|)
block|{
return|return
operator|(
name|nlm_advlock_internal
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|ap
operator|->
name|a_id
argument_list|,
name|ap
operator|->
name|a_op
argument_list|,
name|ap
operator|->
name|a_fl
argument_list|,
name|ap
operator|->
name|a_flags
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the creds of td to the creds of the given lock's owner. The new  * creds reference count will be incremented via crhold. The caller is  * responsible for calling crfree and restoring td's original creds.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_set_creds_for_lock
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|nlm_file_svid
modifier|*
name|ns
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
decl_stmt|;
name|cred
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fl
operator|->
name|l_pid
operator|>
name|PID_MAX
condition|)
block|{
comment|/* 		 * If this was originally a F_FLOCK-style lock, we 		 * recorded the creds used when it was originally 		 * locked in the nlm_file_svid structure. 		 */
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NLM_SVID_HASH_SIZE
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|ns
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|nlm_file_svids
index|[
name|i
index|]
argument_list|)
init|;
name|ns
condition|;
name|ns
operator|=
name|LIST_NEXT
argument_list|(
name|ns
argument_list|,
name|ns_link
argument_list|)
control|)
block|{
if|if
condition|(
name|ns
operator|->
name|ns_svid
operator|==
name|fl
operator|->
name|l_pid
condition|)
block|{
name|cred
operator|=
name|crhold
argument_list|(
name|ns
operator|->
name|ns_ucred
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This lock is owned by a process. Get a reference to 		 * the process creds. 		 */
name|p
operator|=
name|pfind
argument_list|(
name|fl
operator|->
name|l_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|cred
operator|=
name|crhold
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we can't find a cred, fall back on the recovery 	 * thread's cred. 	 */
if|if
condition|(
operator|!
name|cred
condition|)
block|{
name|cred
operator|=
name|crhold
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
block|}
name|td
operator|->
name|td_ucred
operator|=
name|cred
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlm_reclaim_free_lock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|flock
name|newfl
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|oldcred
decl_stmt|;
name|int
name|error
decl_stmt|;
name|newfl
operator|=
operator|*
name|fl
expr_stmt|;
name|newfl
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|oldcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|nlm_set_creds_for_lock
argument_list|(
name|td
argument_list|,
operator|&
name|newfl
argument_list|)
expr_stmt|;
name|error
operator|=
name|nlm_advlock_internal
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|F_UNLCK
argument_list|,
operator|&
name|newfl
argument_list|,
name|F_REMOTE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|oldcred
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_reclaim
parameter_list|(
name|struct
name|vop_reclaim_args
modifier|*
name|ap
parameter_list|)
block|{
name|nlm_cancel_wait
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|)
expr_stmt|;
name|lf_iteratelocks_vnode
argument_list|(
name|ap
operator|->
name|a_vp
argument_list|,
name|nlm_reclaim_free_lock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|nlm_recovery_context
block|{
name|struct
name|nlm_host
modifier|*
name|nr_host
decl_stmt|;
comment|/* host we are recovering */
name|int
name|nr_state
decl_stmt|;
comment|/* remote NSM state for recovery */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|nlm_client_recover_lock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlm_recovery_context
modifier|*
name|nr
init|=
operator|(
expr|struct
name|nlm_recovery_context
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|struct
name|ucred
modifier|*
name|oldcred
decl_stmt|;
name|int
name|state
decl_stmt|,
name|error
decl_stmt|;
comment|/* 	 * If the remote NSM state changes during recovery, the host 	 * must have rebooted a second time. In that case, we must 	 * restart the recovery. 	 */
name|state
operator|=
name|nlm_host_get_state
argument_list|(
name|nr
operator|->
name|nr_host
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|nr_state
operator|!=
name|state
condition|)
return|return
operator|(
name|ERESTART
operator|)
return|;
name|error
operator|=
name|vn_lock
argument_list|(
name|vp
argument_list|,
name|LK_SHARED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|oldcred
operator|=
name|td
operator|->
name|td_ucred
expr_stmt|;
name|nlm_set_creds_for_lock
argument_list|(
name|td
argument_list|,
name|fl
argument_list|)
expr_stmt|;
name|error
operator|=
name|nlm_advlock_internal
argument_list|(
name|vp
argument_list|,
name|NULL
argument_list|,
name|F_SETLK
argument_list|,
name|fl
argument_list|,
name|F_REMOTE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
name|td
operator|->
name|td_ucred
operator|=
name|oldcred
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nlm_client_recovery
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
name|struct
name|nlm_recovery_context
name|nr
decl_stmt|;
name|int
name|sysid
decl_stmt|,
name|error
decl_stmt|;
name|sysid
operator|=
name|NLM_SYSID_CLIENT
operator||
name|nlm_host_get_sysid
argument_list|(
name|host
argument_list|)
expr_stmt|;
do|do
block|{
name|nr
operator|.
name|nr_host
operator|=
name|host
expr_stmt|;
name|nr
operator|.
name|nr_state
operator|=
name|nlm_host_get_state
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|error
operator|=
name|lf_iteratelocks_sysid
argument_list|(
name|sysid
argument_list|,
name|nlm_client_recover_lock
argument_list|,
operator|&
name|nr
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|error
operator|==
name|ERESTART
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_convert_to_nlm_lock
parameter_list|(
name|struct
name|nlm_lock
modifier|*
name|dst
parameter_list|,
name|struct
name|nlm4_lock
modifier|*
name|src
parameter_list|)
block|{
name|dst
operator|->
name|caller_name
operator|=
name|src
operator|->
name|caller_name
expr_stmt|;
name|dst
operator|->
name|fh
operator|=
name|src
operator|->
name|fh
expr_stmt|;
name|dst
operator|->
name|oh
operator|=
name|src
operator|->
name|oh
expr_stmt|;
name|dst
operator|->
name|svid
operator|=
name|src
operator|->
name|svid
expr_stmt|;
name|dst
operator|->
name|l_offset
operator|=
name|src
operator|->
name|l_offset
expr_stmt|;
name|dst
operator|->
name|l_len
operator|=
name|src
operator|->
name|l_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_convert_to_nlm4_holder
parameter_list|(
name|struct
name|nlm4_holder
modifier|*
name|dst
parameter_list|,
name|struct
name|nlm_holder
modifier|*
name|src
parameter_list|)
block|{
name|dst
operator|->
name|exclusive
operator|=
name|src
operator|->
name|exclusive
expr_stmt|;
name|dst
operator|->
name|svid
operator|=
name|src
operator|->
name|svid
expr_stmt|;
name|dst
operator|->
name|oh
operator|=
name|src
operator|->
name|oh
expr_stmt|;
name|dst
operator|->
name|l_offset
operator|=
name|src
operator|->
name|l_offset
expr_stmt|;
name|dst
operator|->
name|l_len
operator|=
name|src
operator|->
name|l_len
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_convert_to_nlm4_res
parameter_list|(
name|struct
name|nlm4_res
modifier|*
name|dst
parameter_list|,
name|struct
name|nlm_res
modifier|*
name|src
parameter_list|)
block|{
name|dst
operator|->
name|cookie
operator|=
name|src
operator|->
name|cookie
expr_stmt|;
name|dst
operator|->
name|stat
operator|.
name|stat
operator|=
operator|(
expr|enum
name|nlm4_stats
operator|)
name|src
operator|->
name|stat
operator|.
name|stat
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|enum
name|clnt_stat
name|nlm_test_rpc
parameter_list|(
name|rpcvers_t
name|vers
parameter_list|,
name|nlm4_testargs
modifier|*
name|args
parameter_list|,
name|nlm4_testres
modifier|*
name|res
parameter_list|,
name|CLIENT
modifier|*
name|client
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|struct
name|timeval
name|timo
parameter_list|)
block|{
if|if
condition|(
name|vers
operator|==
name|NLM_VERS4
condition|)
block|{
return|return
name|nlm4_test_4
argument_list|(
name|args
argument_list|,
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
return|;
block|}
else|else
block|{
name|nlm_testargs
name|args1
decl_stmt|;
name|nlm_testres
name|res1
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|args1
operator|.
name|cookie
operator|=
name|args
operator|->
name|cookie
expr_stmt|;
name|args1
operator|.
name|exclusive
operator|=
name|args
operator|->
name|exclusive
expr_stmt|;
name|nlm_convert_to_nlm_lock
argument_list|(
operator|&
name|args1
operator|.
name|alock
argument_list|,
operator|&
name|args
operator|->
name|alock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|nlm_test_1
argument_list|(
operator|&
name|args1
argument_list|,
operator|&
name|res1
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
name|res
operator|->
name|cookie
operator|=
name|res1
operator|.
name|cookie
expr_stmt|;
name|res
operator|->
name|stat
operator|.
name|stat
operator|=
operator|(
expr|enum
name|nlm4_stats
operator|)
name|res1
operator|.
name|stat
operator|.
name|stat
expr_stmt|;
if|if
condition|(
name|res1
operator|.
name|stat
operator|.
name|stat
operator|==
name|nlm_denied
condition|)
name|nlm_convert_to_nlm4_holder
argument_list|(
operator|&
name|res
operator|->
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
argument_list|,
operator|&
name|res1
operator|.
name|stat
operator|.
name|nlm_testrply_u
operator|.
name|holder
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stat
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|clnt_stat
name|nlm_lock_rpc
parameter_list|(
name|rpcvers_t
name|vers
parameter_list|,
name|nlm4_lockargs
modifier|*
name|args
parameter_list|,
name|nlm4_res
modifier|*
name|res
parameter_list|,
name|CLIENT
modifier|*
name|client
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|struct
name|timeval
name|timo
parameter_list|)
block|{
if|if
condition|(
name|vers
operator|==
name|NLM_VERS4
condition|)
block|{
return|return
name|nlm4_lock_4
argument_list|(
name|args
argument_list|,
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
return|;
block|}
else|else
block|{
name|nlm_lockargs
name|args1
decl_stmt|;
name|nlm_res
name|res1
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|args1
operator|.
name|cookie
operator|=
name|args
operator|->
name|cookie
expr_stmt|;
name|args1
operator|.
name|block
operator|=
name|args
operator|->
name|block
expr_stmt|;
name|args1
operator|.
name|exclusive
operator|=
name|args
operator|->
name|exclusive
expr_stmt|;
name|nlm_convert_to_nlm_lock
argument_list|(
operator|&
name|args1
operator|.
name|alock
argument_list|,
operator|&
name|args
operator|->
name|alock
argument_list|)
expr_stmt|;
name|args1
operator|.
name|reclaim
operator|=
name|args
operator|->
name|reclaim
expr_stmt|;
name|args1
operator|.
name|state
operator|=
name|args
operator|->
name|state
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|nlm_lock_1
argument_list|(
operator|&
name|args1
argument_list|,
operator|&
name|res1
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
name|nlm_convert_to_nlm4_res
argument_list|(
name|res
argument_list|,
operator|&
name|res1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stat
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|clnt_stat
name|nlm_cancel_rpc
parameter_list|(
name|rpcvers_t
name|vers
parameter_list|,
name|nlm4_cancargs
modifier|*
name|args
parameter_list|,
name|nlm4_res
modifier|*
name|res
parameter_list|,
name|CLIENT
modifier|*
name|client
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|struct
name|timeval
name|timo
parameter_list|)
block|{
if|if
condition|(
name|vers
operator|==
name|NLM_VERS4
condition|)
block|{
return|return
name|nlm4_cancel_4
argument_list|(
name|args
argument_list|,
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
return|;
block|}
else|else
block|{
name|nlm_cancargs
name|args1
decl_stmt|;
name|nlm_res
name|res1
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|args1
operator|.
name|cookie
operator|=
name|args
operator|->
name|cookie
expr_stmt|;
name|args1
operator|.
name|block
operator|=
name|args
operator|->
name|block
expr_stmt|;
name|args1
operator|.
name|exclusive
operator|=
name|args
operator|->
name|exclusive
expr_stmt|;
name|nlm_convert_to_nlm_lock
argument_list|(
operator|&
name|args1
operator|.
name|alock
argument_list|,
operator|&
name|args
operator|->
name|alock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|nlm_cancel_1
argument_list|(
operator|&
name|args1
argument_list|,
operator|&
name|res1
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
name|nlm_convert_to_nlm4_res
argument_list|(
name|res
argument_list|,
operator|&
name|res1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stat
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|enum
name|clnt_stat
name|nlm_unlock_rpc
parameter_list|(
name|rpcvers_t
name|vers
parameter_list|,
name|nlm4_unlockargs
modifier|*
name|args
parameter_list|,
name|nlm4_res
modifier|*
name|res
parameter_list|,
name|CLIENT
modifier|*
name|client
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|struct
name|timeval
name|timo
parameter_list|)
block|{
if|if
condition|(
name|vers
operator|==
name|NLM_VERS4
condition|)
block|{
return|return
name|nlm4_unlock_4
argument_list|(
name|args
argument_list|,
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
return|;
block|}
else|else
block|{
name|nlm_unlockargs
name|args1
decl_stmt|;
name|nlm_res
name|res1
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|args1
operator|.
name|cookie
operator|=
name|args
operator|->
name|cookie
expr_stmt|;
name|nlm_convert_to_nlm_lock
argument_list|(
operator|&
name|args1
operator|.
name|alock
argument_list|,
operator|&
name|args
operator|->
name|alock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res1
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res1
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|=
name|nlm_unlock_1
argument_list|(
operator|&
name|args1
argument_list|,
operator|&
name|res1
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
name|nlm_convert_to_nlm4_res
argument_list|(
name|res
argument_list|,
operator|&
name|res1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|stat
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Called after a lock request (set or clear) succeeded. We record the  * details in the local lock manager. Note that since the remote  * server has granted the lock, we can be sure that it doesn't  * conflict with any other locks we have in the local lock manager.  *  * Since it is possible that host may also make NLM client requests to  * our NLM server, we use a different sysid value to record our own  * client locks.  *  * Note that since it is possible for us to receive replies from the  * server in a different order than the locks were granted (e.g. if  * many local threads are contending for the same lock), we must use a  * blocking operation when registering with the local lock manager.  * We expect that any actual wait will be rare and short hence we  * ignore signals for this.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_record_lock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|svid
parameter_list|,
name|int
name|sysid
parameter_list|,
name|off_t
name|size
parameter_list|)
block|{
name|struct
name|vop_advlockasync_args
name|a
decl_stmt|;
name|struct
name|flock
name|newfl
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|,
name|stops_deferred
decl_stmt|;
name|a
operator|.
name|a_vp
operator|=
name|vp
expr_stmt|;
name|a
operator|.
name|a_id
operator|=
name|NULL
expr_stmt|;
name|a
operator|.
name|a_op
operator|=
name|op
expr_stmt|;
name|a
operator|.
name|a_fl
operator|=
operator|&
name|newfl
expr_stmt|;
name|a
operator|.
name|a_flags
operator|=
name|F_REMOTE
operator||
name|F_WAIT
operator||
name|F_NOINTR
expr_stmt|;
name|a
operator|.
name|a_task
operator|=
name|NULL
expr_stmt|;
name|a
operator|.
name|a_cookiep
operator|=
name|NULL
expr_stmt|;
name|newfl
operator|.
name|l_start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
name|newfl
operator|.
name|l_len
operator|=
name|fl
operator|->
name|l_len
expr_stmt|;
name|newfl
operator|.
name|l_type
operator|=
name|fl
operator|->
name|l_type
expr_stmt|;
name|newfl
operator|.
name|l_whence
operator|=
name|fl
operator|->
name|l_whence
expr_stmt|;
name|newfl
operator|.
name|l_pid
operator|=
name|svid
expr_stmt|;
name|newfl
operator|.
name|l_sysid
operator|=
name|NLM_SYSID_CLIENT
operator||
name|sysid
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|error
operator|=
name|lf_advlockasync
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|vp
operator|->
name|v_lockf
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EDEADLK
condition|)
block|{
comment|/* 			 * Locks are associated with the processes and 			 * not with threads.  Suppose we have two 			 * threads A1 A2 in one process, A1 locked 			 * file f1, A2 is locking file f2, and A1 is 			 * unlocking f1. Then remote server may 			 * already unlocked f1, while local still not 			 * yet scheduled A1 to make the call to local 			 * advlock manager. The process B owns lock on 			 * f2 and issued the lock on f1.  Remote would 			 * grant B the request on f1, but local would 			 * return EDEADLK. 			*/
name|pause
argument_list|(
literal|"nlmdlk"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|curproc
expr_stmt|;
name|stops_deferred
operator|=
name|sigdeferstop
argument_list|(
name|SIGDEFERSTOP_OFF
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|thread_suspend_check
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|sigallowstop
argument_list|(
name|stops_deferred
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EINTR
condition|)
block|{
comment|/* 			 * lf_purgelocks() might wake up the lock 			 * waiter and removed our lock graph edges. 			 * There is no sense in re-trying recording 			 * the lock to the local manager after 			 * reclaim. 			 */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
break|break;
block|}
name|KASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|,
operator|(
literal|"Failed to register NFS lock locally - error=%d"
operator|,
name|error
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|nlm_setlock
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|struct
name|timeval
modifier|*
name|timo
parameter_list|,
name|int
name|retries
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|,
name|bool_t
name|reclaim
parameter_list|)
block|{
name|struct
name|nlm4_lockargs
name|args
decl_stmt|;
name|char
name|oh_space
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|nlm4_res
name|res
decl_stmt|;
name|u_int
name|xid
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|int
name|retry
decl_stmt|,
name|block
decl_stmt|,
name|exclusive
decl_stmt|;
name|void
modifier|*
name|wait_handle
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|block
operator|=
operator|(
name|flags
operator|&
name|F_WAIT
operator|)
condition|?
name|TRUE
else|:
name|FALSE
expr_stmt|;
name|exclusive
operator|=
operator|(
name|fl
operator|->
name|l_type
operator|==
name|F_WRLCK
operator|)
expr_stmt|;
name|error
operator|=
name|nlm_init_lock
argument_list|(
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|vers
argument_list|,
name|fhlen
argument_list|,
name|fh
argument_list|,
name|size
argument_list|,
operator|&
name|args
operator|.
name|alock
argument_list|,
name|oh_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|args
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|args
operator|.
name|exclusive
operator|=
name|exclusive
expr_stmt|;
name|args
operator|.
name|reclaim
operator|=
name|reclaim
expr_stmt|;
name|args
operator|.
name|state
operator|=
name|nlm_nsm_state
expr_stmt|;
name|retry
operator|=
literal|5
operator|*
name|hz
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|client
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
return|return
operator|(
name|ENOLCK
operator|)
return|;
comment|/* XXX retry? */
if|if
condition|(
name|block
condition|)
name|wait_handle
operator|=
name|nlm_register_wait_lock
argument_list|(
operator|&
name|args
operator|.
name|alock
argument_list|,
name|vp
argument_list|)
expr_stmt|;
name|xid
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|nlm_xid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|.
name|cookie
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|xid
argument_list|)
expr_stmt|;
name|args
operator|.
name|cookie
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xid
expr_stmt|;
name|stat
operator|=
name|nlm_lock_rpc
argument_list|(
name|vers
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
operator|*
name|timo
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
name|block
condition|)
name|nlm_deregister_wait_lock
argument_list|(
name|wait_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|retries
condition|)
block|{
name|retries
operator|--
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Free res.cookie. 		 */
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_res
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|block
operator|&&
name|res
operator|.
name|stat
operator|.
name|stat
operator|!=
name|nlm4_blocked
condition|)
name|nlm_deregister_wait_lock
argument_list|(
name|wait_handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|stat
operator|.
name|stat
operator|==
name|nlm4_denied_grace_period
condition|)
block|{
comment|/* 			 * The server has recently rebooted and is 			 * giving old clients a change to reclaim 			 * their locks. Wait for a few seconds and try 			 * again. 			 */
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|args
argument_list|,
name|PCATCH
argument_list|,
literal|"nlmgrace"
argument_list|,
name|retry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|retry
operator|=
literal|2
operator|*
name|retry
expr_stmt|;
if|if
condition|(
name|retry
operator|>
literal|30
operator|*
name|hz
condition|)
name|retry
operator|=
literal|30
operator|*
name|hz
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|block
operator|&&
name|res
operator|.
name|stat
operator|.
name|stat
operator|==
name|nlm4_blocked
condition|)
block|{
comment|/* 			 * The server should call us back with a 			 * granted message when the lock succeeds. In 			 * order to deal with broken servers, lost 			 * granted messages and server reboots, we 			 * will also re-try every few seconds. 			 */
name|error
operator|=
name|nlm_wait_lock
argument_list|(
name|wait_handle
argument_list|,
name|retry
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|retry
operator|=
literal|2
operator|*
name|retry
expr_stmt|;
if|if
condition|(
name|retry
operator|>
literal|30
operator|*
name|hz
condition|)
name|retry
operator|=
literal|30
operator|*
name|hz
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 				 * We need to call the server to 				 * cancel our lock request. 				 */
name|nlm4_cancargs
name|cancel
decl_stmt|;
name|memset
argument_list|(
operator|&
name|cancel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cancel
argument_list|)
argument_list|)
expr_stmt|;
name|xid
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|nlm_xid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cancel
operator|.
name|cookie
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|xid
argument_list|)
expr_stmt|;
name|cancel
operator|.
name|cookie
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xid
expr_stmt|;
name|cancel
operator|.
name|block
operator|=
name|block
expr_stmt|;
name|cancel
operator|.
name|exclusive
operator|=
name|exclusive
expr_stmt|;
name|cancel
operator|.
name|alock
operator|=
name|args
operator|.
name|alock
expr_stmt|;
do|do
block|{
name|client
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
comment|/* XXX retry? */
return|return
operator|(
name|ENOLCK
operator|)
return|;
name|stat
operator|=
name|nlm_cancel_rpc
argument_list|(
name|vers
argument_list|,
operator|&
name|cancel
argument_list|,
operator|&
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
operator|*
name|timo
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
comment|/* 						 * We need to cope 						 * with temporary 						 * network partitions 						 * as well as server 						 * reboots. This means 						 * we have to keep 						 * trying to cancel 						 * until the server 						 * wakes up again. 						 */
name|pause
argument_list|(
literal|"nlmcancel"
argument_list|,
literal|10
operator|*
name|hz
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
do|;
comment|/* 				 * Free res.cookie. 				 */
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_res
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|res
operator|.
name|stat
operator|.
name|stat
condition|)
block|{
case|case
name|nlm_denied
case|:
comment|/* 					 * There was nothing 					 * to cancel. We are 					 * going to go ahead 					 * and assume we got 					 * the lock. 					 */
name|error
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|nlm4_denied_grace_period
case|:
comment|/* 					 * The server has 					 * recently rebooted - 					 * treat this as a 					 * successful 					 * cancellation. 					 */
break|break;
case|case
name|nlm4_granted
case|:
comment|/* 					 * We managed to 					 * cancel. 					 */
break|break;
default|default:
comment|/* 					 * Broken server 					 * implementation - 					 * can't really do 					 * anything here. 					 */
break|break;
block|}
block|}
block|}
else|else
block|{
name|error
operator|=
name|nlm_map_status
argument_list|(
name|res
operator|.
name|stat
operator|.
name|stat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
name|reclaim
condition|)
block|{
name|nlm_record_lock
argument_list|(
name|vp
argument_list|,
name|op
argument_list|,
name|fl
argument_list|,
name|args
operator|.
name|alock
operator|.
name|svid
argument_list|,
name|nlm_host_get_sysid
argument_list|(
name|host
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|nlm_host_monitor
argument_list|(
name|host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nlm_clearlock
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|struct
name|timeval
modifier|*
name|timo
parameter_list|,
name|int
name|retries
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|)
block|{
name|struct
name|nlm4_unlockargs
name|args
decl_stmt|;
name|char
name|oh_space
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|nlm4_res
name|res
decl_stmt|;
name|u_int
name|xid
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|int
name|error
decl_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|nlm_init_lock
argument_list|(
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|vers
argument_list|,
name|fhlen
argument_list|,
name|fh
argument_list|,
name|size
argument_list|,
operator|&
name|args
operator|.
name|alock
argument_list|,
name|oh_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|client
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
return|return
operator|(
name|ENOLCK
operator|)
return|;
comment|/* XXX retry? */
name|xid
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|nlm_xid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|.
name|cookie
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|xid
argument_list|)
expr_stmt|;
name|args
operator|.
name|cookie
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xid
expr_stmt|;
name|stat
operator|=
name|nlm_unlock_rpc
argument_list|(
name|vers
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
operator|*
name|timo
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
name|retries
condition|)
block|{
name|retries
operator|--
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 		 * Free res.cookie. 		 */
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_res
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|stat
operator|.
name|stat
operator|==
name|nlm4_denied_grace_period
condition|)
block|{
comment|/* 			 * The server has recently rebooted and is 			 * giving old clients a change to reclaim 			 * their locks. Wait for a few seconds and try 			 * again. 			 */
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|args
argument_list|,
name|PCATCH
argument_list|,
literal|"nlmgrace"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
continue|continue;
block|}
comment|/* 		 * If we are being called via nlm_reclaim (which will 		 * use the F_REMOTE flag), don't record the lock 		 * operation in the local lock manager since the vnode 		 * is going away. 		 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|F_REMOTE
operator|)
condition|)
name|nlm_record_lock
argument_list|(
name|vp
argument_list|,
name|op
argument_list|,
name|fl
argument_list|,
name|args
operator|.
name|alock
operator|.
name|svid
argument_list|,
name|nlm_host_get_sysid
argument_list|(
name|host
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nlm_getlock
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|rpc_callextra
modifier|*
name|ext
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|struct
name|timeval
modifier|*
name|timo
parameter_list|,
name|int
name|retries
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|int
name|op
parameter_list|,
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|)
block|{
name|struct
name|nlm4_testargs
name|args
decl_stmt|;
name|char
name|oh_space
index|[
literal|32
index|]
decl_stmt|;
name|struct
name|nlm4_testres
name|res
decl_stmt|;
name|u_int
name|xid
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|int
name|exclusive
decl_stmt|;
name|int
name|error
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
operator|(
name|flags
operator|&
name|F_FLOCK
operator|)
argument_list|,
operator|(
literal|"unexpected F_FLOCK for F_GETLK"
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|args
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|args
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|exclusive
operator|=
operator|(
name|fl
operator|->
name|l_type
operator|==
name|F_WRLCK
operator|)
expr_stmt|;
name|error
operator|=
name|nlm_init_lock
argument_list|(
name|fl
argument_list|,
name|flags
argument_list|,
name|svid
argument_list|,
name|vers
argument_list|,
name|fhlen
argument_list|,
name|fh
argument_list|,
name|size
argument_list|,
operator|&
name|args
operator|.
name|alock
argument_list|,
name|oh_space
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|args
operator|.
name|exclusive
operator|=
name|exclusive
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|client
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
return|return
operator|(
name|ENOLCK
operator|)
return|;
comment|/* XXX retry? */
name|xid
operator|=
name|atomic_fetchadd_int
argument_list|(
operator|&
name|nlm_xid
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|args
operator|.
name|cookie
operator|.
name|n_len
operator|=
sizeof|sizeof
argument_list|(
name|xid
argument_list|)
expr_stmt|;
name|args
operator|.
name|cookie
operator|.
name|n_bytes
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|xid
expr_stmt|;
name|stat
operator|=
name|nlm_test_rpc
argument_list|(
name|vers
argument_list|,
operator|&
name|args
argument_list|,
operator|&
name|res
argument_list|,
name|client
argument_list|,
name|ext
argument_list|,
operator|*
name|timo
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
name|retries
condition|)
block|{
name|retries
operator|--
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|res
operator|.
name|stat
operator|.
name|stat
operator|==
name|nlm4_denied_grace_period
condition|)
block|{
comment|/* 			 * The server has recently rebooted and is 			 * giving old clients a change to reclaim 			 * their locks. Wait for a few seconds and try 			 * again. 			 */
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_testres
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
name|error
operator|=
name|tsleep
argument_list|(
operator|&
name|args
argument_list|,
name|PCATCH
argument_list|,
literal|"nlmgrace"
argument_list|,
literal|5
operator|*
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EWOULDBLOCK
condition|)
return|return
operator|(
name|error
operator|)
return|;
continue|continue;
block|}
if|if
condition|(
name|res
operator|.
name|stat
operator|.
name|stat
operator|==
name|nlm4_denied
condition|)
block|{
name|struct
name|nlm4_holder
modifier|*
name|h
init|=
operator|&
name|res
operator|.
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
decl_stmt|;
name|fl
operator|->
name|l_start
operator|=
name|h
operator|->
name|l_offset
expr_stmt|;
name|fl
operator|->
name|l_len
operator|=
name|h
operator|->
name|l_len
expr_stmt|;
name|fl
operator|->
name|l_pid
operator|=
name|h
operator|->
name|svid
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|exclusive
condition|)
name|fl
operator|->
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
else|else
name|fl
operator|->
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
name|fl
operator|->
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|fl
operator|->
name|l_sysid
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fl
operator|->
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
block|}
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_testres
argument_list|,
operator|&
name|res
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nlm_map_status
parameter_list|(
name|nlm4_stats
name|stat
parameter_list|)
block|{
switch|switch
condition|(
name|stat
condition|)
block|{
case|case
name|nlm4_granted
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|nlm4_denied
case|:
return|return
operator|(
name|EAGAIN
operator|)
return|;
case|case
name|nlm4_denied_nolocks
case|:
return|return
operator|(
name|ENOLCK
operator|)
return|;
case|case
name|nlm4_deadlck
case|:
return|return
operator|(
name|EDEADLK
operator|)
return|;
case|case
name|nlm4_rofs
case|:
return|return
operator|(
name|EROFS
operator|)
return|;
case|case
name|nlm4_stale_fh
case|:
return|return
operator|(
name|ESTALE
operator|)
return|;
case|case
name|nlm4_fbig
case|:
return|return
operator|(
name|EFBIG
operator|)
return|;
case|case
name|nlm4_failed
case|:
return|return
operator|(
name|EACCES
operator|)
return|;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|nlm_file_svid
modifier|*
name|nlm_find_svid
parameter_list|(
name|void
modifier|*
name|id
parameter_list|)
block|{
name|struct
name|nlm_file_svid
modifier|*
name|ns
decl_stmt|,
modifier|*
name|newns
decl_stmt|;
name|int
name|h
decl_stmt|;
name|h
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|id
operator|)
operator|>>
literal|7
operator|)
operator|%
name|NLM_SVID_HASH_SIZE
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ns
argument_list|,
argument|&nlm_file_svids[h]
argument_list|,
argument|ns_link
argument_list|)
block|{
if|if
condition|(
name|ns
operator|->
name|ns_id
operator|==
name|id
condition|)
block|{
name|ns
operator|->
name|ns_refs
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
block|{
name|int
name|svid
init|=
name|alloc_unr
argument_list|(
name|nlm_svid_allocator
argument_list|)
decl_stmt|;
name|newns
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_file_svid
argument_list|)
argument_list|,
name|M_NLM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|newns
operator|->
name|ns_refs
operator|=
literal|1
expr_stmt|;
name|newns
operator|->
name|ns_id
operator|=
name|id
expr_stmt|;
name|newns
operator|->
name|ns_svid
operator|=
name|svid
expr_stmt|;
name|newns
operator|->
name|ns_ucred
operator|=
name|NULL
expr_stmt|;
name|newns
operator|->
name|ns_active
operator|=
name|FALSE
expr_stmt|;
comment|/* 		 * We need to check for a race with some other 		 * thread allocating a svid for this file. 		 */
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ns
argument_list|,
argument|&nlm_file_svids[h]
argument_list|,
argument|ns_link
argument_list|)
block|{
if|if
condition|(
name|ns
operator|->
name|ns_id
operator|==
name|id
condition|)
block|{
name|ns
operator|->
name|ns_refs
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ns
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
name|free_unr
argument_list|(
name|nlm_svid_allocator
argument_list|,
name|newns
operator|->
name|ns_svid
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newns
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nlm_file_svids
index|[
name|h
index|]
argument_list|,
name|newns
argument_list|,
name|ns_link
argument_list|)
expr_stmt|;
name|ns
operator|=
name|newns
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ns
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_free_svid
parameter_list|(
name|struct
name|nlm_file_svid
modifier|*
name|ns
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
name|ns
operator|->
name|ns_refs
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|ns
operator|->
name|ns_refs
condition|)
block|{
name|KASSERT
argument_list|(
operator|!
name|ns
operator|->
name|ns_active
argument_list|,
operator|(
literal|"Freeing active SVID"
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ns
argument_list|,
name|ns_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
name|free_unr
argument_list|(
name|nlm_svid_allocator
argument_list|,
name|ns
operator|->
name|ns_svid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns
operator|->
name|ns_ucred
condition|)
name|crfree
argument_list|(
name|ns
operator|->
name|ns_ucred
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ns
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nlm_svid_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|nlm_init_lock
parameter_list|(
name|struct
name|flock
modifier|*
name|fl
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|svid
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|,
name|size_t
name|fhlen
parameter_list|,
name|void
modifier|*
name|fh
parameter_list|,
name|off_t
name|size
parameter_list|,
name|struct
name|nlm4_lock
modifier|*
name|lock
parameter_list|,
name|char
name|oh_space
index|[
literal|32
index|]
parameter_list|)
block|{
name|size_t
name|oh_len
decl_stmt|;
name|off_t
name|start
decl_stmt|,
name|len
decl_stmt|;
if|if
condition|(
name|fl
operator|->
name|l_whence
operator|==
name|SEEK_END
condition|)
block|{
if|if
condition|(
name|size
operator|>
name|OFF_MAX
operator|||
operator|(
name|fl
operator|->
name|l_start
operator|>
literal|0
operator|&&
name|size
operator|>
name|OFF_MAX
operator|-
name|fl
operator|->
name|l_start
operator|)
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
name|start
operator|=
name|size
operator|+
name|fl
operator|->
name|l_start
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fl
operator|->
name|l_whence
operator|==
name|SEEK_SET
operator|||
name|fl
operator|->
name|l_whence
operator|==
name|SEEK_CUR
condition|)
block|{
name|start
operator|=
name|fl
operator|->
name|l_start
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|fl
operator|->
name|l_len
operator|<
literal|0
condition|)
block|{
name|len
operator|=
operator|-
name|fl
operator|->
name|l_len
expr_stmt|;
name|start
operator|-=
name|len
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
else|else
block|{
name|len
operator|=
name|fl
operator|->
name|l_len
expr_stmt|;
block|}
if|if
condition|(
name|vers
operator|==
name|NLM_VERS
condition|)
block|{
comment|/* 		 * Enforce range limits on V1 locks 		 */
if|if
condition|(
name|start
operator|>
literal|0xffffffffLL
operator|||
name|len
operator|>
literal|0xffffffffLL
condition|)
return|return
operator|(
name|EOVERFLOW
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|oh_space
argument_list|,
literal|32
argument_list|,
literal|"%d@"
argument_list|,
name|svid
argument_list|)
expr_stmt|;
name|oh_len
operator|=
name|strlen
argument_list|(
name|oh_space
argument_list|)
expr_stmt|;
name|getcredhostname
argument_list|(
name|NULL
argument_list|,
name|oh_space
operator|+
name|oh_len
argument_list|,
literal|32
operator|-
name|oh_len
argument_list|)
expr_stmt|;
name|oh_len
operator|=
name|strlen
argument_list|(
name|oh_space
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|caller_name
operator|=
name|prison0
operator|.
name|pr_hostname
expr_stmt|;
name|lock
operator|->
name|fh
operator|.
name|n_len
operator|=
name|fhlen
expr_stmt|;
name|lock
operator|->
name|fh
operator|.
name|n_bytes
operator|=
name|fh
expr_stmt|;
name|lock
operator|->
name|oh
operator|.
name|n_len
operator|=
name|oh_len
expr_stmt|;
name|lock
operator|->
name|oh
operator|.
name|n_bytes
operator|=
name|oh_space
expr_stmt|;
name|lock
operator|->
name|svid
operator|=
name|svid
expr_stmt|;
name|lock
operator|->
name|l_offset
operator|=
name|start
expr_stmt|;
name|lock
operator|->
name|l_len
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

