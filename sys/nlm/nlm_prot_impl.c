begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  * Authors: Doug Rabson<dfr@rabson.org>  * Developed with Red Inc: Alfred Perlstein<alfred@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/fail.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kthread.h>
end_include

begin_include
include|#
directive|include
file|<sys/lockf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
end_if

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysproto.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<nfs/nfsproto.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfs.h>
end_include

begin_include
include|#
directive|include
file|<nfsclient/nfsnode.h>
end_include

begin_include
include|#
directive|include
file|<nlm/nlm_prot.h>
end_include

begin_include
include|#
directive|include
file|<nlm/sm_inter.h>
end_include

begin_include
include|#
directive|include
file|<nlm/nlm.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc_com.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcb_prot.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_NLM
argument_list|,
literal|"NLM"
argument_list|,
literal|"Network Lock Manager"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * If a host is inactive (and holds no locks) for this amount of  * seconds, we consider it idle and stop tracking it.  */
end_comment

begin_define
define|#
directive|define
name|NLM_IDLE_TIMEOUT
value|30
end_define

begin_comment
comment|/*  * We check the host list for idle every few seconds.  */
end_comment

begin_define
define|#
directive|define
name|NLM_IDLE_PERIOD
value|5
end_define

begin_comment
comment|/*  * We only look for GRANTED_RES messages for a little while.  */
end_comment

begin_define
define|#
directive|define
name|NLM_EXPIRE_TIMEOUT
value|10
end_define

begin_comment
comment|/*  * Support for sysctl vfs.nlm.sysid  */
end_comment

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs
argument_list|,
name|OID_AUTO
argument_list|,
name|nlm
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"Network Lock Manager"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_vfs_nlm
argument_list|,
name|OID_AUTO
argument_list|,
name|sysid
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Syscall hooks  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nlm_syscall_offset
init|=
name|SYS_nlm_syscall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sysent
name|nlm_syscall_prev_sysent
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|700000
end_if

begin_decl_stmt
specifier|static
name|struct
name|sysent
name|nlm_syscall_sysent
init|=
block|{
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_syscall_args
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|register_t
argument_list|)
operator|)
operator||
name|SYF_MPSAFE
block|,
operator|(
name|sy_call_t
operator|*
operator|)
name|nlm_syscall
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|MAKE_SYSENT
argument_list|(
name|nlm_syscall
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool_t
name|nlm_syscall_registered
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Debug level passed in from userland. We also support a sysctl hook  * so that it can be changed on a live system.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nlm_debug_level
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug
argument_list|,
name|OID_AUTO
argument_list|,
name|nlm_debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|nlm_debug_level
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NLM_DEBUG
parameter_list|(
name|_level
parameter_list|,
name|args
modifier|...
parameter_list|)
define|\
value|do {						\ 		if (nlm_debug_level>= (_level))	\ 			log(LOG_DEBUG, args);		\ 	} while(0)
end_define

begin_define
define|#
directive|define
name|NLM_ERR
parameter_list|(
name|args
modifier|...
parameter_list|)
define|\
value|do {					\ 		log(LOG_ERR, args);		\ 	} while(0)
end_define

begin_comment
comment|/*  * Grace period handling. The value of nlm_grace_threshold is the  * value of time_uptime after which we are serving requests normally.  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|nlm_grace_threshold
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We check for idle hosts if time_uptime is greater than  * nlm_next_idle_check,  */
end_comment

begin_decl_stmt
specifier|static
name|time_t
name|nlm_next_idle_check
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A socket to use for RPC - shared by all IPv4 RPC clients.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|socket
modifier|*
name|nlm_socket
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/*  * A socket to use for RPC - shared by all IPv6 RPC clients.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|socket
modifier|*
name|nlm_socket6
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * An RPC client handle that can be used to communicate with the local  * NSM.  */
end_comment

begin_decl_stmt
specifier|static
name|CLIENT
modifier|*
name|nlm_nsm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * An AUTH handle for the server's creds.  */
end_comment

begin_decl_stmt
specifier|static
name|AUTH
modifier|*
name|nlm_auth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A zero timeval for sending async RPC messages.  */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|nlm_zero_tv
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The local NSM state number  */
end_comment

begin_decl_stmt
name|int
name|nlm_nsm_state
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A lock to protect the host list and waiting lock list.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|nlm_global_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Locks:  * (l)		locked by nh_lock  * (s)		only accessed via server RPC which is single threaded  * (g)		locked by nlm_global_lock  * (c)		const until freeing  * (a)		modified using atomic ops  */
end_comment

begin_comment
comment|/*  * A pending client-side lock request, stored on the nlm_waiting_locks  * list.  */
end_comment

begin_struct
struct|struct
name|nlm_waiting_lock
block|{
name|TAILQ_ENTRY
argument_list|(
argument|nlm_waiting_lock
argument_list|)
name|nw_link
expr_stmt|;
comment|/* (g) */
name|bool_t
name|nw_waiting
decl_stmt|;
comment|/* (g) */
name|nlm4_lock
name|nw_lock
decl_stmt|;
comment|/* (c) */
name|union
name|nfsfh
name|nw_fh
decl_stmt|;
comment|/* (c) */
name|struct
name|vnode
modifier|*
name|nw_vp
decl_stmt|;
comment|/* (c) */
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|nlm_waiting_lock_list
argument_list|,
name|nlm_waiting_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|nlm_waiting_lock_list
name|nlm_waiting_locks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (g) */
end_comment

begin_comment
comment|/*  * A pending server-side asynchronous lock request, stored on the  * nh_pending list of the NLM host.  */
end_comment

begin_struct
struct|struct
name|nlm_async_lock
block|{
name|TAILQ_ENTRY
argument_list|(
argument|nlm_async_lock
argument_list|)
name|af_link
expr_stmt|;
comment|/* (l) host's list of locks */
name|struct
name|task
name|af_task
decl_stmt|;
comment|/* (c) async callback details */
name|void
modifier|*
name|af_cookie
decl_stmt|;
comment|/* (l) lock manager cancel token */
name|struct
name|vnode
modifier|*
name|af_vp
decl_stmt|;
comment|/* (l) vnode to lock */
name|struct
name|flock
name|af_fl
decl_stmt|;
comment|/* (c) lock details */
name|struct
name|nlm_host
modifier|*
name|af_host
decl_stmt|;
comment|/* (c) host which is locking */
name|CLIENT
modifier|*
name|af_rpc
decl_stmt|;
comment|/* (c) rpc client to send message */
name|nlm4_testargs
name|af_granted
decl_stmt|;
comment|/* (c) notification details */
name|time_t
name|af_expiretime
decl_stmt|;
comment|/* (c) notification time */
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|nlm_async_lock_list
argument_list|,
name|nlm_async_lock
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * NLM host.  */
end_comment

begin_enum
enum|enum
name|nlm_host_state
block|{
name|NLM_UNMONITORED
block|,
name|NLM_MONITORED
block|,
name|NLM_MONITOR_FAILED
block|,
name|NLM_RECOVERING
block|}
enum|;
end_enum

begin_struct
struct|struct
name|nlm_rpc
block|{
name|CLIENT
modifier|*
name|nr_client
decl_stmt|;
comment|/* (l) RPC client handle */
name|time_t
name|nr_create_time
decl_stmt|;
comment|/* (l) when client was created */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|nlm_host
block|{
name|struct
name|mtx
name|nh_lock
decl_stmt|;
specifier|volatile
name|u_int
name|nh_refs
decl_stmt|;
comment|/* (a) reference count */
name|TAILQ_ENTRY
argument_list|(
argument|nlm_host
argument_list|)
name|nh_link
expr_stmt|;
comment|/* (g) global list of hosts */
name|char
name|nh_caller_name
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
comment|/* (c) printable name of host */
name|uint32_t
name|nh_sysid
decl_stmt|;
comment|/* (c) our allocaed system ID */
name|char
name|nh_sysid_string
index|[
literal|10
index|]
decl_stmt|;
comment|/* (c) string rep. of sysid */
name|struct
name|sockaddr_storage
name|nh_addr
decl_stmt|;
comment|/* (s) remote address of host */
name|struct
name|nlm_rpc
name|nh_srvrpc
decl_stmt|;
comment|/* (l) RPC for server replies */
name|struct
name|nlm_rpc
name|nh_clntrpc
decl_stmt|;
comment|/* (l) RPC for client requests */
name|rpcvers_t
name|nh_vers
decl_stmt|;
comment|/* (s) NLM version of host */
name|int
name|nh_state
decl_stmt|;
comment|/* (s) last seen NSM state of host */
name|enum
name|nlm_host_state
name|nh_monstate
decl_stmt|;
comment|/* (l) local NSM monitoring state */
name|time_t
name|nh_idle_timeout
decl_stmt|;
comment|/* (s) Time at which host is idle */
name|struct
name|sysctl_ctx_list
name|nh_sysctl
decl_stmt|;
comment|/* (c) vfs.nlm.sysid nodes */
name|uint32_t
name|nh_grantcookie
decl_stmt|;
comment|/* (l) grant cookie counter */
name|struct
name|nlm_async_lock_list
name|nh_pending
decl_stmt|;
comment|/* (l) pending async locks */
name|struct
name|nlm_async_lock_list
name|nh_granted
decl_stmt|;
comment|/* (l) granted locks */
name|struct
name|nlm_async_lock_list
name|nh_finished
decl_stmt|;
comment|/* (l) finished async locks */
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|nlm_host_list
argument_list|,
name|nlm_host
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|nlm_host_list
name|nlm_hosts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (g) */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|nlm_next_sysid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (g) */
end_comment

begin_function_decl
specifier|static
name|void
name|nlm_host_unmonitor
parameter_list|(
name|struct
name|nlm_host
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|nlm_grantcookie
block|{
name|uint32_t
name|ng_sysid
decl_stmt|;
name|uint32_t
name|ng_cookie
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ng_sysid
parameter_list|(
name|struct
name|netobj
modifier|*
name|src
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|nlm_grantcookie
operator|*
operator|)
name|src
operator|->
name|n_bytes
operator|)
operator|->
name|ng_sysid
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint32_t
name|ng_cookie
parameter_list|(
name|struct
name|netobj
modifier|*
name|src
parameter_list|)
block|{
return|return
operator|(
operator|(
expr|struct
name|nlm_grantcookie
operator|*
operator|)
name|src
operator|->
name|n_bytes
operator|)
operator|->
name|ng_cookie
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/*  * Initialise NLM globals.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_init
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|nlm_global_lock
argument_list|,
literal|"nlm_global_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nlm_waiting_locks
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nlm_hosts
argument_list|)
expr_stmt|;
name|error
operator|=
name|syscall_register
argument_list|(
operator|&
name|nlm_syscall_offset
argument_list|,
operator|&
name|nlm_syscall_sysent
argument_list|,
operator|&
name|nlm_syscall_prev_sysent
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|NLM_ERR
argument_list|(
literal|"Can't register NLM syscall\n"
argument_list|)
expr_stmt|;
else|else
name|nlm_syscall_registered
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|nlm_init
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|nlm_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|nlm_uninit
parameter_list|(
name|void
modifier|*
name|dummy
parameter_list|)
block|{
if|if
condition|(
name|nlm_syscall_registered
condition|)
name|syscall_deregister
argument_list|(
operator|&
name|nlm_syscall_offset
argument_list|,
operator|&
name|nlm_syscall_prev_sysent
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSUNINIT
argument_list|(
name|nlm_uninit
argument_list|,
name|SI_SUB_LOCK
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|nlm_uninit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Create a netobj from an arbitrary source.  */
end_comment

begin_function
name|void
name|nlm_make_netobj
parameter_list|(
name|struct
name|netobj
modifier|*
name|dst
parameter_list|,
name|caddr_t
name|src
parameter_list|,
name|size_t
name|srcsize
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
block|{
name|dst
operator|->
name|n_len
operator|=
name|srcsize
expr_stmt|;
name|dst
operator|->
name|n_bytes
operator|=
name|malloc
argument_list|(
name|srcsize
argument_list|,
name|type
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dst
operator|->
name|n_bytes
argument_list|,
name|src
argument_list|,
name|srcsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy a struct netobj.  */
end_comment

begin_function
name|void
name|nlm_copy_netobj
parameter_list|(
name|struct
name|netobj
modifier|*
name|dst
parameter_list|,
name|struct
name|netobj
modifier|*
name|src
parameter_list|,
name|struct
name|malloc_type
modifier|*
name|type
parameter_list|)
block|{
name|nlm_make_netobj
argument_list|(
name|dst
argument_list|,
name|src
operator|->
name|n_bytes
argument_list|,
name|src
operator|->
name|n_len
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create an RPC client handle for the given (address,prog,vers)  * triple using UDP.  */
end_comment

begin_function
specifier|static
name|CLIENT
modifier|*
name|nlm_get_rpc
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|rpcprog_t
name|prog
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|)
block|{
name|char
modifier|*
name|wchan
init|=
literal|"nlmrcv"
decl_stmt|;
specifier|const
name|char
modifier|*
name|protofmly
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|CLIENT
modifier|*
name|rpcb
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
name|RPCB
name|parms
decl_stmt|;
name|char
modifier|*
name|uaddr
decl_stmt|;
name|enum
name|clnt_stat
name|stat
init|=
name|RPC_SUCCESS
decl_stmt|;
name|int
name|rpcvers
init|=
name|RPCBVERS4
decl_stmt|;
name|bool_t
name|do_tcp
init|=
name|FALSE
decl_stmt|;
name|bool_t
name|tryagain
init|=
name|FALSE
decl_stmt|;
name|struct
name|portmap
name|mapping
decl_stmt|;
name|u_short
name|port
init|=
literal|0
decl_stmt|;
comment|/* 	 * First we need to contact the remote RPCBIND service to find 	 * the right port. 	 */
name|memcpy
argument_list|(
operator|&
name|ss
argument_list|,
name|sa
argument_list|,
name|sa
operator|->
name|sa_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|111
argument_list|)
expr_stmt|;
name|protofmly
operator|=
literal|"inet"
expr_stmt|;
name|so
operator|=
name|nlm_socket
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
literal|111
argument_list|)
expr_stmt|;
name|protofmly
operator|=
literal|"inet6"
expr_stmt|;
name|so
operator|=
name|nlm_socket6
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* 		 * Unsupported address family - fail. 		 */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|rpcb
operator|=
name|clnt_dg_create
argument_list|(
name|so
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|RPCBPROG
argument_list|,
name|rpcvers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rpcb
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|try_tcp
label|:
name|parms
operator|.
name|r_prog
operator|=
name|prog
expr_stmt|;
name|parms
operator|.
name|r_vers
operator|=
name|vers
expr_stmt|;
if|if
condition|(
name|do_tcp
condition|)
name|parms
operator|.
name|r_netid
operator|=
literal|"tcp"
expr_stmt|;
else|else
name|parms
operator|.
name|r_netid
operator|=
literal|"udp"
expr_stmt|;
name|parms
operator|.
name|r_addr
operator|=
literal|""
expr_stmt|;
name|parms
operator|.
name|r_owner
operator|=
literal|""
expr_stmt|;
comment|/* 	 * Use the default timeout. 	 */
name|timo
operator|.
name|tv_sec
operator|=
literal|25
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|again
label|:
switch|switch
condition|(
name|rpcvers
condition|)
block|{
case|case
name|RPCBVERS4
case|:
case|case
name|RPCBVERS
case|:
comment|/* 		 * Try RPCBIND 4 then 3. 		 */
name|uaddr
operator|=
name|NULL
expr_stmt|;
name|stat
operator|=
name|CLNT_CALL
argument_list|(
name|rpcb
argument_list|,
operator|(
name|rpcprog_t
operator|)
name|RPCBPROC_GETADDR
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_rpcb
argument_list|,
operator|&
name|parms
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_wrapstring
argument_list|,
operator|&
name|uaddr
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
comment|/* 			 * We have a reply from the remote RPCBIND - turn it 			 * into an appropriate address and make a new client 			 * that can talk to the remote NLM. 			 * 			 * XXX fixup IPv6 scope ID. 			 */
name|struct
name|netbuf
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|__rpc_uaddr2taddr_af
argument_list|(
name|ss
operator|.
name|ss_family
argument_list|,
name|uaddr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
block|{
name|tryagain
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|tryagain
operator|=
name|FALSE
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ss
argument_list|,
name|a
operator|->
name|buf
argument_list|,
name|a
operator|->
name|len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|buf
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_wrapstring
argument_list|,
operator|&
name|uaddr
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tryagain
operator|||
name|stat
operator|==
name|RPC_PROGVERSMISMATCH
condition|)
block|{
if|if
condition|(
name|rpcvers
operator|==
name|RPCBVERS4
condition|)
name|rpcvers
operator|=
name|RPCBVERS
expr_stmt|;
elseif|else
if|if
condition|(
name|rpcvers
operator|==
name|RPCBVERS
condition|)
name|rpcvers
operator|=
name|PMAPVERS
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|rpcb
argument_list|,
name|CLSET_VERS
argument_list|,
operator|&
name|rpcvers
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
break|break;
case|case
name|PMAPVERS
case|:
comment|/* 		 * Try portmap. 		 */
name|mapping
operator|.
name|pm_prog
operator|=
name|parms
operator|.
name|r_prog
expr_stmt|;
name|mapping
operator|.
name|pm_vers
operator|=
name|parms
operator|.
name|r_vers
expr_stmt|;
name|mapping
operator|.
name|pm_prot
operator|=
name|do_tcp
condition|?
name|IPPROTO_TCP
else|:
name|IPPROTO_UDP
expr_stmt|;
name|mapping
operator|.
name|pm_port
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
name|CLNT_CALL
argument_list|(
name|rpcb
argument_list|,
operator|(
name|rpcprog_t
operator|)
name|PMAPPROC_GETPORT
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_portmap
argument_list|,
operator|&
name|mapping
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_u_short
argument_list|,
operator|&
name|port
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
block|{
switch|switch
condition|(
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
break|break;
default|default:
name|panic
argument_list|(
literal|"invalid rpcvers %d"
argument_list|,
name|rpcvers
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We may have a positive response from the portmapper, but the NLM 	 * service was not found. Make sure we received a valid port. 	 */
switch|switch
condition|(
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_port
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_port
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
operator|||
operator|!
name|port
condition|)
block|{
comment|/* 		 * If we were able to talk to rpcbind or portmap, but the udp 		 * variant wasn't available, ask about tcp. 		 * 		 * XXX - We could also check for a TCP portmapper, but 		 * if the host is running a portmapper at all, we should be able 		 * to hail it over UDP. 		 */
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
operator|&&
operator|!
name|do_tcp
condition|)
block|{
name|do_tcp
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|try_tcp
goto|;
block|}
comment|/* Otherwise, bad news. */
name|NLM_ERR
argument_list|(
literal|"NLM: failed to contact remote rpcbind, "
literal|"stat = %d, port = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|stat
argument_list|,
name|port
argument_list|)
expr_stmt|;
name|CLNT_DESTROY
argument_list|(
name|rpcb
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|do_tcp
condition|)
block|{
comment|/* 		 * Destroy the UDP client we used to speak to rpcbind and 		 * recreate as a TCP client. 		 */
name|struct
name|netconfig
modifier|*
name|nconf
init|=
name|NULL
decl_stmt|;
name|CLNT_DESTROY
argument_list|(
name|rpcb
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"tcp"
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|nconf
operator|=
name|getnetconfigent
argument_list|(
literal|"tcp6"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|rpcb
operator|=
name|clnt_reconnect_create
argument_list|(
name|nconf
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|prog
argument_list|,
name|vers
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|rpcb
argument_list|,
name|CLSET_WAITCHAN
argument_list|,
name|wchan
argument_list|)
expr_stmt|;
name|rpcb
operator|->
name|cl_auth
operator|=
name|nlm_auth
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Re-use the client we used to speak to rpcbind. 		 */
name|CLNT_CONTROL
argument_list|(
name|rpcb
argument_list|,
name|CLSET_SVC_ADDR
argument_list|,
operator|&
name|ss
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|rpcb
argument_list|,
name|CLSET_PROG
argument_list|,
operator|&
name|prog
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|rpcb
argument_list|,
name|CLSET_VERS
argument_list|,
operator|&
name|vers
argument_list|)
expr_stmt|;
name|CLNT_CONTROL
argument_list|(
name|rpcb
argument_list|,
name|CLSET_WAITCHAN
argument_list|,
name|wchan
argument_list|)
expr_stmt|;
name|rpcb
operator|->
name|cl_auth
operator|=
name|nlm_auth
expr_stmt|;
block|}
return|return
operator|(
name|rpcb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This async callback after when an async lock request has been  * granted. We notify the host which initiated the request.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_lock_callback
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|pending
parameter_list|)
block|{
name|struct
name|nlm_async_lock
modifier|*
name|af
init|=
operator|(
expr|struct
name|nlm_async_lock
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|rpc_callextra
name|ext
decl_stmt|;
name|NLM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"NLM: async lock %p for %s (sysid %d) granted,"
literal|" cookie %d:%d\n"
argument_list|,
name|af
argument_list|,
name|af
operator|->
name|af_host
operator|->
name|nh_caller_name
argument_list|,
name|af
operator|->
name|af_host
operator|->
name|nh_sysid
argument_list|,
name|ng_sysid
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|cookie
argument_list|)
argument_list|,
name|ng_cookie
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Send the results back to the host. 	 * 	 * Note: there is a possible race here with nlm_host_notify 	 * destroying the RPC client. To avoid problems, the first 	 * thing nlm_host_notify does is to cancel pending async lock 	 * requests. 	 */
name|memset
argument_list|(
operator|&
name|ext
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ext
argument_list|)
argument_list|)
expr_stmt|;
name|ext
operator|.
name|rc_auth
operator|=
name|nlm_auth
expr_stmt|;
if|if
condition|(
name|af
operator|->
name|af_host
operator|->
name|nh_vers
operator|==
name|NLM_VERS4
condition|)
block|{
name|nlm4_granted_msg_4
argument_list|(
operator|&
name|af
operator|->
name|af_granted
argument_list|,
name|NULL
argument_list|,
name|af
operator|->
name|af_rpc
argument_list|,
operator|&
name|ext
argument_list|,
name|nlm_zero_tv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Back-convert to legacy protocol 		 */
name|nlm_testargs
name|granted
decl_stmt|;
name|granted
operator|.
name|cookie
operator|=
name|af
operator|->
name|af_granted
operator|.
name|cookie
expr_stmt|;
name|granted
operator|.
name|exclusive
operator|=
name|af
operator|->
name|af_granted
operator|.
name|exclusive
expr_stmt|;
name|granted
operator|.
name|alock
operator|.
name|caller_name
operator|=
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|caller_name
expr_stmt|;
name|granted
operator|.
name|alock
operator|.
name|fh
operator|=
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|fh
expr_stmt|;
name|granted
operator|.
name|alock
operator|.
name|oh
operator|=
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|oh
expr_stmt|;
name|granted
operator|.
name|alock
operator|.
name|svid
operator|=
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|svid
expr_stmt|;
name|granted
operator|.
name|alock
operator|.
name|l_offset
operator|=
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|l_offset
expr_stmt|;
name|granted
operator|.
name|alock
operator|.
name|l_len
operator|=
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|l_len
expr_stmt|;
name|nlm_granted_msg_1
argument_list|(
operator|&
name|granted
argument_list|,
name|NULL
argument_list|,
name|af
operator|->
name|af_rpc
argument_list|,
operator|&
name|ext
argument_list|,
name|nlm_zero_tv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Move this entry to the nh_granted list. 	 */
name|af
operator|->
name|af_expiretime
operator|=
name|time_uptime
operator|+
name|NLM_EXPIRE_TIMEOUT
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|af
operator|->
name|af_host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|af
operator|->
name|af_host
operator|->
name|nh_pending
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|af
operator|->
name|af_host
operator|->
name|nh_granted
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|af
operator|->
name|af_host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free an async lock request. The request must have been removed from  * any list.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_free_async_lock
parameter_list|(
name|struct
name|nlm_async_lock
modifier|*
name|af
parameter_list|)
block|{
comment|/* 	 * Free an async lock. 	 */
if|if
condition|(
name|af
operator|->
name|af_rpc
condition|)
name|CLNT_RELEASE
argument_list|(
name|af
operator|->
name|af_rpc
argument_list|)
expr_stmt|;
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_testargs
argument_list|,
operator|&
name|af
operator|->
name|af_granted
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|->
name|af_vp
condition|)
name|vrele
argument_list|(
name|af
operator|->
name|af_vp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|af
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel our async request - this must be called with  * af->nh_host->nh_lock held. This is slightly complicated by a  * potential race with our own callback. If we fail to cancel the  * lock, it must already have been granted - we make sure our async  * task has completed by calling taskqueue_drain in this case.  */
end_comment

begin_function
specifier|static
name|int
name|nlm_cancel_async_lock
parameter_list|(
name|struct
name|nlm_async_lock
modifier|*
name|af
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
init|=
name|af
operator|->
name|af_host
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ADVLOCKASYNC
argument_list|(
name|af
operator|->
name|af_vp
argument_list|,
name|NULL
argument_list|,
name|F_CANCEL
argument_list|,
operator|&
name|af
operator|->
name|af_fl
argument_list|,
name|F_REMOTE
argument_list|,
name|NULL
argument_list|,
operator|&
name|af
operator|->
name|af_cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * We failed to cancel - make sure our callback has 		 * completed before we continue. 		 */
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|af
operator|->
name|af_task
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"NLM: async lock %p for %s (sysid %d) "
literal|"cancelled\n"
argument_list|,
name|af
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
comment|/* 		 * Remove from the nh_pending list and free now that 		 * we are safe from the callback. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|host
operator|->
name|nh_pending
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|nlm_free_async_lock
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_check_expired_locks
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
name|struct
name|nlm_async_lock
modifier|*
name|af
decl_stmt|;
name|time_t
name|uptime
init|=
name|time_uptime
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|af
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|host
operator|->
name|nh_granted
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|uptime
operator|>=
name|af
operator|->
name|af_expiretime
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"NLM: async lock %p for %s (sysid %d) expired,"
literal|" cookie %d:%d\n"
argument_list|,
name|af
argument_list|,
name|af
operator|->
name|af_host
operator|->
name|nh_caller_name
argument_list|,
name|af
operator|->
name|af_host
operator|->
name|nh_sysid
argument_list|,
name|ng_sysid
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|cookie
argument_list|)
argument_list|,
name|ng_cookie
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|host
operator|->
name|nh_granted
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|nlm_free_async_lock
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|af
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|host
operator|->
name|nh_finished
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|host
operator|->
name|nh_finished
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|nlm_free_async_lock
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free resources used by a host. This is called after the reference  * count has reached zero so it doesn't need to worry about locks.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_host_destroy
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nlm_hosts
argument_list|,
name|host
argument_list|,
name|nh_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
condition|)
name|CLNT_RELEASE
argument_list|(
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|nh_clntrpc
operator|.
name|nr_client
condition|)
name|CLNT_RELEASE
argument_list|(
name|host
operator|->
name|nh_clntrpc
operator|.
name|nr_client
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|sysctl_ctx_free
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|host
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Thread start callback for client lock recovery  */
end_comment

begin_function
specifier|static
name|void
name|nlm_client_recovery_start
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
init|=
operator|(
expr|struct
name|nlm_host
operator|*
operator|)
name|arg
decl_stmt|;
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: client lock recovery for %s started\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|)
expr_stmt|;
name|nlm_client_recovery
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: client lock recovery for %s completed\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_MONITORED
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|kthread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called when we receive a host state change notification. We  * unlock any active locks owned by the host. When rpc.lockd is  * shutting down, this function is called with newstate set to zero  * which allows us to cancel any pending async locks and clear the  * locking state.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_host_notify
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|int
name|newstate
parameter_list|)
block|{
name|struct
name|nlm_async_lock
modifier|*
name|af
decl_stmt|;
if|if
condition|(
name|newstate
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: host %s (sysid %d) rebooted, new "
literal|"state is %d\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|,
name|newstate
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Cancel any pending async locks for this host. 	 */
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|af
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|host
operator|->
name|nh_pending
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * nlm_cancel_async_lock will remove the entry from 		 * nh_pending and free it. 		 */
name|nlm_cancel_async_lock
argument_list|(
name|af
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|nlm_check_expired_locks
argument_list|(
name|host
argument_list|)
expr_stmt|;
comment|/* 	 * The host just rebooted - trash its locks. 	 */
name|lf_clearremotesys
argument_list|(
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_state
operator|=
name|newstate
expr_stmt|;
comment|/* 	 * If we have any remote locks for this host (i.e. it 	 * represents a remote NFS server that our local NFS client 	 * has locks for), start a recovery thread. 	 */
if|if
condition|(
name|newstate
operator|!=
literal|0
operator|&&
name|host
operator|->
name|nh_monstate
operator|!=
name|NLM_RECOVERING
operator|&&
name|lf_countlocks
argument_list|(
name|NLM_SYSID_CLIENT
operator||
name|host
operator|->
name|nh_sysid
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_RECOVERING
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|host
operator|->
name|nh_refs
argument_list|)
expr_stmt|;
name|kthread_add
argument_list|(
name|nlm_client_recovery_start
argument_list|,
name|host
argument_list|,
name|curproc
argument_list|,
operator|&
name|td
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"NFS lock recovery for %s"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sysctl handler to count the number of locks for a sysid.  */
end_comment

begin_function
specifier|static
name|int
name|nlm_host_lock_count_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|int
name|count
decl_stmt|;
name|host
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|count
operator|=
name|lf_countlocks
argument_list|(
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sysctl handler to count the number of client locks for a sysid.  */
end_comment

begin_function
specifier|static
name|int
name|nlm_host_client_lock_count_sysctl
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|int
name|count
decl_stmt|;
name|host
operator|=
name|oidp
operator|->
name|oid_arg1
expr_stmt|;
name|count
operator|=
name|lf_countlocks
argument_list|(
name|NLM_SYSID_CLIENT
operator||
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
return|return
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new NLM host.  */
end_comment

begin_function
specifier|static
name|struct
name|nlm_host
modifier|*
name|nlm_create_host
parameter_list|(
specifier|const
name|char
modifier|*
name|caller_name
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|nlm_global_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: new host %s (sysid %d)\n"
argument_list|,
name|caller_name
argument_list|,
name|nlm_next_sysid
argument_list|)
expr_stmt|;
name|host
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_host
argument_list|)
argument_list|,
name|M_NLM
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mtx_init
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|,
literal|"nh_lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_refs
operator|=
literal|1
expr_stmt|;
name|strlcpy
argument_list|(
name|host
operator|->
name|nh_caller_name
argument_list|,
name|caller_name
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_sysid
operator|=
name|nlm_next_sysid
operator|++
expr_stmt|;
name|snprintf
argument_list|(
name|host
operator|->
name|nh_sysid_string
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|nh_sysid_string
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_vers
operator|=
literal|0
expr_stmt|;
name|host
operator|->
name|nh_state
operator|=
literal|0
expr_stmt|;
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_UNMONITORED
expr_stmt|;
name|host
operator|->
name|nh_grantcookie
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|host
operator|->
name|nh_pending
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|host
operator|->
name|nh_granted
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|host
operator|->
name|nh_finished
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nlm_hosts
argument_list|,
name|host
argument_list|,
name|nh_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|sysctl_ctx_init
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|,
name|SYSCTL_STATIC_CHILDREN
argument_list|(
name|_vfs_nlm_sysid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|host
operator|->
name|nh_sysid_string
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_STRING
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"hostname"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"version"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|host
operator|->
name|nh_vers
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"monitored"
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|host
operator|->
name|nh_monstate
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"lock_count"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|host
argument_list|,
literal|0
argument_list|,
name|nlm_host_lock_count_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
operator|&
name|host
operator|->
name|nh_sysctl
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"client_lock_count"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RD
argument_list|,
name|host
argument_list|,
literal|0
argument_list|,
name|nlm_host_client_lock_count_sysctl
argument_list|,
literal|"I"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|host
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Acquire the next sysid for remote locks not handled by the NLM.  */
end_comment

begin_function
name|uint32_t
name|nlm_acquire_next_sysid
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|next_sysid
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|next_sysid
operator|=
name|nlm_next_sysid
operator|++
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|next_sysid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return non-zero if the address parts of the two sockaddrs are the  * same.  */
end_comment

begin_function
specifier|static
name|int
name|nlm_compare_addr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|a4
decl_stmt|,
modifier|*
name|b4
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
specifier|const
name|struct
name|sockaddr_in6
modifier|*
name|a6
decl_stmt|,
modifier|*
name|b6
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|sa_family
operator|!=
name|b
operator|->
name|sa_family
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
switch|switch
condition|(
name|a
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|a4
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|a
expr_stmt|;
name|b4
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|b
expr_stmt|;
return|return
operator|!
name|memcmp
argument_list|(
operator|&
name|a4
operator|->
name|sin_addr
argument_list|,
operator|&
name|b4
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|a4
operator|->
name|sin_addr
argument_list|)
argument_list|)
return|;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|a6
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|a
expr_stmt|;
name|b6
operator|=
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|b
expr_stmt|;
return|return
operator|!
name|memcmp
argument_list|(
operator|&
name|a6
operator|->
name|sin6_addr
argument_list|,
operator|&
name|b6
operator|->
name|sin6_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|a6
operator|->
name|sin6_addr
argument_list|)
argument_list|)
return|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for idle hosts and stop monitoring them. We could also free  * the host structure here, possibly after a larger timeout but that  * would require some care to avoid races with  * e.g. nlm_host_lock_count_sysctl.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_check_idle
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|mtx_assert
argument_list|(
operator|&
name|nlm_global_lock
argument_list|,
name|MA_OWNED
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|<=
name|nlm_next_idle_check
condition|)
return|return;
name|nlm_next_idle_check
operator|=
name|time_uptime
operator|+
name|NLM_IDLE_PERIOD
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|)
block|{
if|if
condition|(
name|host
operator|->
name|nh_monstate
operator|==
name|NLM_MONITORED
operator|&&
name|time_uptime
operator|>
name|host
operator|->
name|nh_idle_timeout
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|lf_countlocks
argument_list|(
name|host
operator|->
name|nh_sysid
argument_list|)
operator|>
literal|0
operator|||
name|lf_countlocks
argument_list|(
name|NLM_SYSID_CLIENT
operator|+
name|host
operator|->
name|nh_sysid
argument_list|)
condition|)
block|{
name|host
operator|->
name|nh_idle_timeout
operator|=
name|time_uptime
operator|+
name|NLM_IDLE_TIMEOUT
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|nlm_host_unmonitor
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search for an existing NLM host that matches the given name  * (typically the caller_name element of an nlm4_lock).  If none is  * found, create a new host. If 'addr' is non-NULL, record the remote  * address of the host so that we can call it back for async  * responses. If 'vers' is greater than zero then record the NLM  * program version to use to communicate with this client.  */
end_comment

begin_function
name|struct
name|nlm_host
modifier|*
name|nlm_find_host_by_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|rpcvers_t
name|vers
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The remote host is determined by caller_name. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|host
operator|->
name|nh_caller_name
argument_list|,
name|name
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|host
operator|=
name|nlm_create_host
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|refcount_acquire
argument_list|(
operator|&
name|host
operator|->
name|nh_refs
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_idle_timeout
operator|=
name|time_uptime
operator|+
name|NLM_IDLE_TIMEOUT
expr_stmt|;
comment|/* 	 * If we have an address for the host, record it so that we 	 * can send async replies etc. 	 */
if|if
condition|(
name|addr
condition|)
block|{
name|KASSERT
argument_list|(
name|addr
operator|->
name|sa_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_storage
argument_list|)
argument_list|,
operator|(
literal|"Strange remote transport address length"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If we have seen an address before and we currently 		 * have an RPC client handle, make sure the address is 		 * the same, otherwise discard the client handle. 		 */
if|if
condition|(
name|host
operator|->
name|nh_addr
operator|.
name|ss_len
operator|&&
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
condition|)
block|{
if|if
condition|(
operator|!
name|nlm_compare_addr
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
operator|->
name|nh_addr
argument_list|,
name|addr
argument_list|)
operator|||
name|host
operator|->
name|nh_vers
operator|!=
name|vers
condition|)
block|{
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|client
operator|=
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
expr_stmt|;
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
condition|)
block|{
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|memcpy
argument_list|(
operator|&
name|host
operator|->
name|nh_addr
argument_list|,
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_vers
operator|=
name|vers
expr_stmt|;
block|}
name|nlm_check_idle
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|host
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for an existing NLM host that matches the given remote  * address. If none is found, create a new host with the requested  * address and remember 'vers' as the NLM protocol version to use for  * that host.  */
end_comment

begin_function
name|struct
name|nlm_host
modifier|*
name|nlm_find_host_by_addr
parameter_list|(
specifier|const
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|int
name|vers
parameter_list|)
block|{
comment|/* 	 * Fake up a name using inet_ntop. This buffer is 	 * large enough for an IPv6 address. 	 */
name|char
name|tmp
index|[
sizeof|sizeof
expr|"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"]
expr_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
name|__rpc_inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|__rpc_inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
operator|(
specifier|const
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin6_addr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|strcmp
argument_list|(
name|tmp
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
comment|/* 	 * The remote host is determined by caller_name. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|)
block|{
if|if
condition|(
name|nlm_compare_addr
argument_list|(
name|addr
argument_list|,
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
operator|->
name|nh_addr
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|host
operator|=
name|nlm_create_host
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|host
operator|->
name|nh_addr
argument_list|,
name|addr
argument_list|,
name|addr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_vers
operator|=
name|vers
expr_stmt|;
block|}
name|refcount_acquire
argument_list|(
operator|&
name|host
operator|->
name|nh_refs
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_idle_timeout
operator|=
name|time_uptime
operator|+
name|NLM_IDLE_TIMEOUT
expr_stmt|;
name|nlm_check_idle
argument_list|()
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|host
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the NLM host that matches the value of 'sysid'. If none  * exists, return NULL.  */
end_comment

begin_function
specifier|static
name|struct
name|nlm_host
modifier|*
name|nlm_find_host_by_sysid
parameter_list|(
name|int
name|sysid
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|)
block|{
if|if
condition|(
name|host
operator|->
name|nh_sysid
operator|==
name|sysid
condition|)
block|{
name|refcount_acquire
argument_list|(
operator|&
name|host
operator|->
name|nh_refs
argument_list|)
expr_stmt|;
return|return
operator|(
name|host
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nlm_host_release
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
if|if
condition|(
name|refcount_release
argument_list|(
operator|&
name|host
operator|->
name|nh_refs
argument_list|)
condition|)
block|{
comment|/* 		 * Free the host 		 */
name|nlm_host_destroy
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Unregister this NLM host with the local NSM due to idleness.  */
end_comment

begin_function
specifier|static
name|void
name|nlm_host_unmonitor
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
name|mon_id
name|smmonid
decl_stmt|;
name|sm_stat_res
name|smstat
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: unmonitoring %s (sysid %d)\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
comment|/* 	 * We put our assigned system ID value in the priv field to 	 * make it simpler to find the host if we are notified of a 	 * host restart. 	 */
name|smmonid
operator|.
name|mon_name
operator|=
name|host
operator|->
name|nh_caller_name
expr_stmt|;
name|smmonid
operator|.
name|my_id
operator|.
name|my_name
operator|=
literal|"localhost"
expr_stmt|;
name|smmonid
operator|.
name|my_id
operator|.
name|my_prog
operator|=
name|NLM_PROG
expr_stmt|;
name|smmonid
operator|.
name|my_id
operator|.
name|my_vers
operator|=
name|NLM_SM
expr_stmt|;
name|smmonid
operator|.
name|my_id
operator|.
name|my_proc
operator|=
name|NLM_SM_NOTIFY
expr_stmt|;
name|timo
operator|.
name|tv_sec
operator|=
literal|25
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
name|CLNT_CALL
argument_list|(
name|nlm_nsm
argument_list|,
name|SM_UNMON
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_mon
argument_list|,
operator|&
name|smmonid
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_sm_stat
argument_list|,
operator|&
name|smstat
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"Failed to contact local NSM - rpc error %d\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|smstat
operator|.
name|res_stat
operator|==
name|stat_fail
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"Local NSM refuses to unmonitor %s\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_UNMONITORED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register this NLM host with the local NSM so that we can be  * notified if it reboots.  */
end_comment

begin_function
name|void
name|nlm_host_monitor
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|mon
name|smmon
decl_stmt|;
name|sm_stat_res
name|smstat
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
if|if
condition|(
name|state
operator|&&
operator|!
name|host
operator|->
name|nh_state
condition|)
block|{
comment|/* 		 * This is the first time we have seen an NSM state 		 * value for this host. We record it here to help 		 * detect host reboots. 		 */
name|host
operator|->
name|nh_state
operator|=
name|state
expr_stmt|;
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: host %s (sysid %d) has NSM state %d\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|,
name|state
argument_list|)
expr_stmt|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|nh_monstate
operator|!=
name|NLM_UNMONITORED
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_MONITORED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: monitoring %s (sysid %d)\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
comment|/* 	 * We put our assigned system ID value in the priv field to 	 * make it simpler to find the host if we are notified of a 	 * host restart. 	 */
name|smmon
operator|.
name|mon_id
operator|.
name|mon_name
operator|=
name|host
operator|->
name|nh_caller_name
expr_stmt|;
name|smmon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_name
operator|=
literal|"localhost"
expr_stmt|;
name|smmon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_prog
operator|=
name|NLM_PROG
expr_stmt|;
name|smmon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_vers
operator|=
name|NLM_SM
expr_stmt|;
name|smmon
operator|.
name|mon_id
operator|.
name|my_id
operator|.
name|my_proc
operator|=
name|NLM_SM_NOTIFY
expr_stmt|;
name|memcpy
argument_list|(
name|smmon
operator|.
name|priv
argument_list|,
operator|&
name|host
operator|->
name|nh_sysid
argument_list|,
sizeof|sizeof
argument_list|(
name|host
operator|->
name|nh_sysid
argument_list|)
argument_list|)
expr_stmt|;
name|timo
operator|.
name|tv_sec
operator|=
literal|25
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
name|CLNT_CALL
argument_list|(
name|nlm_nsm
argument_list|,
name|SM_MON
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_mon
argument_list|,
operator|&
name|smmon
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_sm_stat
argument_list|,
operator|&
name|smstat
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"Failed to contact local NSM - rpc error %d\n"
argument_list|,
name|stat
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|smstat
operator|.
name|res_stat
operator|==
name|stat_fail
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"Local NSM refuses to monitor %s\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_MONITOR_FAILED
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|host
operator|->
name|nh_monstate
operator|=
name|NLM_MONITORED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return an RPC client handle that can be used to talk to the NLM  * running on the given host.  */
end_comment

begin_function
name|CLIENT
modifier|*
name|nlm_host_get_rpc
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|bool_t
name|isserver
parameter_list|)
block|{
name|struct
name|nlm_rpc
modifier|*
name|rpc
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|isserver
condition|)
name|rpc
operator|=
operator|&
name|host
operator|->
name|nh_srvrpc
expr_stmt|;
else|else
name|rpc
operator|=
operator|&
name|host
operator|->
name|nh_clntrpc
expr_stmt|;
comment|/* 	 * We can't hold onto RPC handles for too long - the async 	 * call/reply protocol used by some NLM clients makes it hard 	 * to tell when they change port numbers (e.g. after a 	 * reboot). Note that if a client reboots while it isn't 	 * holding any locks, it won't bother to notify us. We 	 * expire the RPC handles after two minutes. 	 */
if|if
condition|(
name|rpc
operator|->
name|nr_client
operator|&&
name|time_uptime
operator|>
name|rpc
operator|->
name|nr_create_time
operator|+
literal|2
operator|*
literal|60
condition|)
block|{
name|client
operator|=
name|rpc
operator|->
name|nr_client
expr_stmt|;
name|rpc
operator|->
name|nr_client
operator|=
name|NULL
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rpc
operator|->
name|nr_client
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|client
operator|=
name|nlm_get_rpc
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
operator|->
name|nh_addr
argument_list|,
name|NLM_PROG
argument_list|,
name|host
operator|->
name|nh_vers
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|client
condition|)
block|{
if|if
condition|(
name|rpc
operator|->
name|nr_client
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|CLNT_DESTROY
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rpc
operator|->
name|nr_client
operator|=
name|client
expr_stmt|;
name|rpc
operator|->
name|nr_create_time
operator|=
name|time_uptime
expr_stmt|;
block|}
block|}
block|}
name|client
operator|=
name|rpc
operator|->
name|nr_client
expr_stmt|;
if|if
condition|(
name|client
condition|)
name|CLNT_ACQUIRE
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|client
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_host_get_sysid
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
return|return
operator|(
name|host
operator|->
name|nh_sysid
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_host_get_state
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|)
block|{
return|return
operator|(
name|host
operator|->
name|nh_state
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nlm_register_wait_lock
parameter_list|(
name|struct
name|nlm4_lock
modifier|*
name|lock
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|nlm_waiting_lock
modifier|*
name|nw
decl_stmt|;
name|nw
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_waiting_lock
argument_list|)
argument_list|,
name|M_NLM
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|nw
operator|->
name|nw_lock
operator|=
operator|*
name|lock
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|nw
operator|->
name|nw_fh
operator|.
name|fh_bytes
argument_list|,
name|nw
operator|->
name|nw_lock
operator|.
name|fh
operator|.
name|n_bytes
argument_list|,
name|nw
operator|->
name|nw_lock
operator|.
name|fh
operator|.
name|n_len
argument_list|)
expr_stmt|;
name|nw
operator|->
name|nw_lock
operator|.
name|fh
operator|.
name|n_bytes
operator|=
name|nw
operator|->
name|nw_fh
operator|.
name|fh_bytes
expr_stmt|;
name|nw
operator|->
name|nw_waiting
operator|=
name|TRUE
expr_stmt|;
name|nw
operator|->
name|nw_vp
operator|=
name|vp
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nlm_waiting_locks
argument_list|,
name|nw
argument_list|,
name|nw_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
return|return
name|nw
return|;
block|}
end_function

begin_function
name|void
name|nlm_deregister_wait_lock
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|nlm_waiting_lock
modifier|*
name|nw
init|=
name|handle
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nlm_waiting_locks
argument_list|,
name|nw
argument_list|,
name|nw_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nw
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nlm_wait_lock
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|int
name|timo
parameter_list|)
block|{
name|struct
name|nlm_waiting_lock
modifier|*
name|nw
init|=
name|handle
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * If the granted message arrived before we got here, 	 * nw->nw_waiting will be FALSE - in that case, don't sleep. 	 */
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nw
operator|->
name|nw_waiting
condition|)
name|error
operator|=
name|msleep
argument_list|(
name|nw
argument_list|,
operator|&
name|nlm_global_lock
argument_list|,
name|PCATCH
argument_list|,
literal|"nlmlock"
argument_list|,
name|timo
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nlm_waiting_locks
argument_list|,
name|nw
argument_list|,
name|nw_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* 		 * The granted message may arrive after the 		 * interrupt/timeout but before we manage to lock the 		 * mutex. Detect this by examining nw_lock. 		 */
if|if
condition|(
operator|!
name|nw
operator|->
name|nw_waiting
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If nlm_cancel_wait is called, then error will be 		 * zero but nw_waiting will still be TRUE. We 		 * translate this into EINTR. 		 */
if|if
condition|(
name|nw
operator|->
name|nw_waiting
condition|)
name|error
operator|=
name|EINTR
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nw
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nlm_cancel_wait
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|nlm_waiting_lock
modifier|*
name|nw
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|nw
argument_list|,
argument|&nlm_waiting_locks
argument_list|,
argument|nw_link
argument_list|)
block|{
if|if
condition|(
name|nw
operator|->
name|nw_vp
operator|==
name|vp
condition|)
block|{
name|wakeup
argument_list|(
name|nw
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/*  * Syscall interface with userland.  */
end_comment

begin_function_decl
specifier|extern
name|void
name|nlm_prog_0
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|nlm_prog_1
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|nlm_prog_3
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|nlm_prog_4
parameter_list|(
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|SVCXPRT
modifier|*
name|transp
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|nlm_register_services
parameter_list|(
name|SVCPOOL
modifier|*
name|pool
parameter_list|,
name|int
name|addr_count
parameter_list|,
name|char
modifier|*
modifier|*
name|addrs
parameter_list|)
block|{
specifier|static
name|rpcvers_t
name|versions
index|[]
init|=
block|{
name|NLM_SM
block|,
name|NLM_VERS
block|,
name|NLM_VERSX
block|,
name|NLM_VERS4
block|}
decl_stmt|;
specifier|static
name|void
function_decl|(
modifier|*
name|dispatchers
index|[]
function_decl|)
parameter_list|(
name|struct
name|svc_req
modifier|*
parameter_list|,
name|SVCXPRT
modifier|*
parameter_list|)
init|=
block|{
name|nlm_prog_0
operator|,
function_decl|nlm_prog_1
operator|,
function_decl|nlm_prog_3
operator|,
function_decl|nlm_prog_4
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|version_count
init|=
sizeof|sizeof
argument_list|(
name|versions
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|versions
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SVCXPRT
modifier|*
modifier|*
name|xprts
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|netid
index|[
literal|16
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|uaddr
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|addr_count
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"NLM: no service addresses given - can't start server"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_if

begin_expr_stmt
name|xprts
operator|=
name|malloc
argument_list|(
name|addr_count
operator|*
sizeof|sizeof
argument_list|(
name|SVCXPRT
operator|*
argument_list|)
argument_list|,
name|M_NLM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|version_count
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|addr_count
condition|;
name|j
operator|++
control|)
block|{
comment|/* 			 * Create transports for the first version and 			 * then just register everything else to the 			 * same transports. 			 */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|up
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|addrs
index|[
literal|2
operator|*
name|j
index|]
argument_list|,
operator|&
name|up
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyinstr
argument_list|(
name|up
argument_list|,
name|netid
argument_list|,
sizeof|sizeof
argument_list|(
name|netid
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|addrs
index|[
literal|2
operator|*
name|j
operator|+
literal|1
index|]
argument_list|,
operator|&
name|up
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|copyinstr
argument_list|(
name|up
argument_list|,
name|uaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|uaddr
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|nconf
operator|=
name|getnetconfigent
argument_list|(
name|netid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nconf
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"Can't lookup netid %s\n"
argument_list|,
name|netid
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|xprts
index|[
name|j
index|]
operator|=
name|svc_tp_create
argument_list|(
name|pool
argument_list|,
name|dispatchers
index|[
name|i
index|]
argument_list|,
name|NLM_PROG
argument_list|,
name|versions
index|[
name|i
index|]
argument_list|,
name|uaddr
argument_list|,
name|nconf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xprts
index|[
name|j
index|]
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"NLM: unable to create "
literal|"(NLM_PROG, %d).\n"
argument_list|,
name|versions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|freenetconfigent
argument_list|(
name|nconf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nconf
operator|=
name|getnetconfigent
argument_list|(
name|xprts
index|[
name|j
index|]
operator|->
name|xp_netid
argument_list|)
expr_stmt|;
name|rpcb_unset
argument_list|(
name|NLM_PROG
argument_list|,
name|versions
index|[
name|i
index|]
argument_list|,
name|nconf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svc_reg
argument_list|(
name|xprts
index|[
name|j
index|]
argument_list|,
name|NLM_PROG
argument_list|,
name|versions
index|[
name|i
index|]
argument_list|,
name|dispatchers
index|[
name|i
index|]
argument_list|,
name|nconf
argument_list|)
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"NLM: can't register "
literal|"(NLM_PROG, %d)\n"
argument_list|,
name|versions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
block|}
end_for

begin_expr_stmt
name|error
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_label
name|out
label|:
end_label

begin_for
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|addr_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|xprts
index|[
name|j
index|]
condition|)
name|SVC_RELEASE
argument_list|(
name|xprts
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|free
argument_list|(
name|xprts
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|error
operator|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Main server entry point. Contacts the local NSM to get its current  * state and send SM_UNMON_ALL. Registers the NLM services and then  * services requests. Does not return until the server is interrupted  * by a signal.  */
end_comment

begin_function
unit|static
name|int
name|nlm_server_main
parameter_list|(
name|int
name|addr_count
parameter_list|,
name|char
modifier|*
modifier|*
name|addrs
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
init|=
name|curthread
decl_stmt|;
name|int
name|error
decl_stmt|;
name|SVCPOOL
modifier|*
name|pool
init|=
name|NULL
decl_stmt|;
name|struct
name|sockopt
name|opt
decl_stmt|;
name|int
name|portlow
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|my_id
name|id
decl_stmt|;
name|sm_stat
name|smstat
decl_stmt|;
name|struct
name|timeval
name|timo
decl_stmt|;
name|enum
name|clnt_stat
name|stat
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|,
modifier|*
name|nhost
decl_stmt|;
name|struct
name|nlm_waiting_lock
modifier|*
name|nw
decl_stmt|;
name|vop_advlock_t
modifier|*
name|old_nfs_advlock
decl_stmt|;
name|vop_reclaim_t
modifier|*
name|old_nfs_reclaim
decl_stmt|;
name|int
name|v4_used
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|int
name|v6_used
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nlm_socket
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"NLM: can't start server - "
literal|"it appears to be running already\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|EPERM
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|opt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt
argument_list|)
argument_list|)
expr_stmt|;
name|nlm_socket
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|AF_INET
argument_list|,
operator|&
name|nlm_socket
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"NLM: can't create IPv4 socket - error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|opt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|opt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IP
expr_stmt|;
name|opt
operator|.
name|sopt_name
operator|=
name|IP_PORTRANGE
expr_stmt|;
name|portlow
operator|=
name|IP_PORTRANGE_LOW
expr_stmt|;
name|opt
operator|.
name|sopt_val
operator|=
operator|&
name|portlow
expr_stmt|;
name|opt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|portlow
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|nlm_socket
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|nlm_socket6
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|socreate
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|nlm_socket6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|,
name|td
operator|->
name|td_ucred
argument_list|,
name|td
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"NLM: can't create IPv6 socket - error %d\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|opt
operator|.
name|sopt_dir
operator|=
name|SOPT_SET
expr_stmt|;
name|opt
operator|.
name|sopt_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|opt
operator|.
name|sopt_name
operator|=
name|IPV6_PORTRANGE
expr_stmt|;
name|portlow
operator|=
name|IPV6_PORTRANGE_LOW
expr_stmt|;
name|opt
operator|.
name|sopt_val
operator|=
operator|&
name|portlow
expr_stmt|;
name|opt
operator|.
name|sopt_valsize
operator|=
sizeof|sizeof
argument_list|(
name|portlow
argument_list|)
expr_stmt|;
name|sosetopt
argument_list|(
name|nlm_socket6
argument_list|,
operator|&
name|opt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|nlm_auth
operator|=
name|authunix_create
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
name|in6addr_loopback
expr_stmt|;
name|nlm_nsm
operator|=
name|nlm_get_rpc
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
name|SM_PROG
argument_list|,
name|SM_VERS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nlm_nsm
condition|)
block|{
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|nlm_nsm
operator|=
name|nlm_get_rpc
argument_list|(
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
name|SM_PROG
argument_list|,
name|SM_VERS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|nlm_nsm
condition|)
block|{
name|NLM_ERR
argument_list|(
literal|"Can't start NLM - unable to contact NSM\n"
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|pool
operator|=
name|svcpool_create
argument_list|(
literal|"NLM"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|nlm_register_services
argument_list|(
name|pool
argument_list|,
name|addr_count
argument_list|,
name|addrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|.
name|my_name
operator|=
literal|"NFS NLM"
expr_stmt|;
name|timo
operator|.
name|tv_sec
operator|=
literal|25
expr_stmt|;
name|timo
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|stat
operator|=
name|CLNT_CALL
argument_list|(
name|nlm_nsm
argument_list|,
name|SM_UNMON_ALL
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_my_id
argument_list|,
operator|&
name|id
argument_list|,
operator|(
name|xdrproc_t
operator|)
name|xdr_sm_stat
argument_list|,
operator|&
name|smstat
argument_list|,
name|timo
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|!=
name|RPC_SUCCESS
condition|)
block|{
name|struct
name|rpc_err
name|err
decl_stmt|;
name|CLNT_GETERR
argument_list|(
name|nlm_nsm
argument_list|,
operator|&
name|err
argument_list|)
expr_stmt|;
name|NLM_ERR
argument_list|(
literal|"NLM: unexpected error contacting NSM, "
literal|"stat=%d, errno=%d\n"
argument_list|,
name|stat
argument_list|,
name|err
operator|.
name|re_errno
argument_list|)
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: local NSM state is %d\n"
argument_list|,
name|smstat
operator|.
name|state
argument_list|)
expr_stmt|;
name|nlm_nsm_state
operator|=
name|smstat
operator|.
name|state
expr_stmt|;
name|old_nfs_advlock
operator|=
name|nfs_advlock_p
expr_stmt|;
name|nfs_advlock_p
operator|=
name|nlm_advlock
expr_stmt|;
name|old_nfs_reclaim
operator|=
name|nfs_reclaim_p
expr_stmt|;
name|nfs_reclaim_p
operator|=
name|nlm_reclaim
expr_stmt|;
name|svc_run
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|nfs_advlock_p
operator|=
name|old_nfs_advlock
expr_stmt|;
name|nfs_reclaim_p
operator|=
name|old_nfs_reclaim
expr_stmt|;
name|out
label|:
if|if
condition|(
name|pool
condition|)
name|svcpool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* 	 * We are finished communicating with the NSM. 	 */
if|if
condition|(
name|nlm_nsm
condition|)
block|{
name|CLNT_RELEASE
argument_list|(
name|nlm_nsm
argument_list|)
expr_stmt|;
name|nlm_nsm
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Trash all the existing state so that if the server 	 * restarts, it gets a clean slate. This is complicated by the 	 * possibility that there may be other threads trying to make 	 * client locking requests. 	 * 	 * First we fake a client reboot notification which will 	 * cancel any pending async locks and purge remote lock state 	 * from the local lock manager. We release the reference from 	 * nlm_hosts to the host (which may remove it from the list 	 * and free it). After this phase, the only entries in the 	 * nlm_host list should be from other threads performing 	 * client lock requests. We arrange to defer closing the 	 * sockets until the last RPC client handle is released. 	 */
name|v4_used
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|v6_used
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|nw
argument_list|,
argument|&nlm_waiting_locks
argument_list|,
argument|nw_link
argument_list|)
block|{
name|wakeup
argument_list|(
name|nw
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|,
argument|nhost
argument_list|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|nlm_host_notify
argument_list|(
name|host
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|,
argument|nhost
argument_list|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
operator|||
name|host
operator|->
name|nh_clntrpc
operator|.
name|nr_client
condition|)
block|{
if|if
condition|(
name|host
operator|->
name|nh_addr
operator|.
name|ss_family
operator|==
name|AF_INET
condition|)
name|v4_used
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|host
operator|->
name|nh_addr
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
name|v6_used
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 			 * Note that the rpc over udp code copes 			 * correctly with the fact that a socket may 			 * be used by many rpc handles. 			 */
if|if
condition|(
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
condition|)
name|CLNT_CONTROL
argument_list|(
name|host
operator|->
name|nh_srvrpc
operator|.
name|nr_client
argument_list|,
name|CLSET_FD_CLOSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|->
name|nh_clntrpc
operator|.
name|nr_client
condition|)
name|CLNT_CONTROL
argument_list|(
name|host
operator|->
name|nh_clntrpc
operator|.
name|nr_client
argument_list|,
name|CLSET_FD_CLOSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|AUTH_DESTROY
argument_list|(
name|nlm_auth
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v4_used
condition|)
name|soclose
argument_list|(
name|nlm_socket
argument_list|)
expr_stmt|;
name|nlm_socket
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
operator|!
name|v6_used
condition|)
name|soclose
argument_list|(
name|nlm_socket6
argument_list|)
expr_stmt|;
name|nlm_socket6
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_syscall
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|struct
name|nlm_syscall_args
modifier|*
name|uap
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|700000
name|error
operator|=
name|priv_check
argument_list|(
name|td
argument_list|,
name|PRIV_NFS_LOCKD
argument_list|)
expr_stmt|;
else|#
directive|else
name|error
operator|=
name|suser
argument_list|(
name|td
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nlm_debug_level
operator|=
name|uap
operator|->
name|debug_level
expr_stmt|;
name|nlm_grace_threshold
operator|=
name|time_uptime
operator|+
name|uap
operator|->
name|grace_period
expr_stmt|;
name|nlm_next_idle_check
operator|=
name|time_uptime
operator|+
name|NLM_IDLE_PERIOD
expr_stmt|;
return|return
name|nlm_server_main
argument_list|(
name|uap
operator|->
name|addr_count
argument_list|,
name|uap
operator|->
name|addrs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**********************************************************************/
end_comment

begin_comment
comment|/*  * NLM implementation details, called from the RPC stubs.  */
end_comment

begin_function
name|void
name|nlm_sm_notify
parameter_list|(
name|struct
name|nlm_sm_status
modifier|*
name|argp
parameter_list|)
block|{
name|uint32_t
name|sysid
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|NLM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"nlm_sm_notify(): mon_name = %s\n"
argument_list|,
name|argp
operator|->
name|mon_name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|sysid
argument_list|,
operator|&
name|argp
operator|->
name|priv
argument_list|,
sizeof|sizeof
argument_list|(
name|sysid
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_sysid
argument_list|(
name|sysid
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
block|{
name|nlm_host_notify
argument_list|(
name|host
argument_list|,
name|argp
operator|->
name|state
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_convert_to_fhandle_t
parameter_list|(
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|struct
name|netobj
modifier|*
name|p
parameter_list|)
block|{
name|memcpy
argument_list|(
name|fhp
argument_list|,
name|p
operator|->
name|n_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|fhandle_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|vfs_state
block|{
name|struct
name|mount
modifier|*
name|vs_mp
decl_stmt|;
name|struct
name|vnode
modifier|*
name|vs_vp
decl_stmt|;
name|int
name|vs_vfslocked
decl_stmt|;
name|int
name|vs_vnlocked
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|nlm_get_vfs_state
parameter_list|(
name|struct
name|nlm_host
modifier|*
name|host
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|fhandle_t
modifier|*
name|fhp
parameter_list|,
name|struct
name|vfs_state
modifier|*
name|vs
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|exflags
decl_stmt|;
name|struct
name|ucred
modifier|*
name|cred
init|=
name|NULL
decl_stmt|,
modifier|*
name|credanon
decl_stmt|;
name|memset
argument_list|(
name|vs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_mp
operator|=
name|vfs_getvfs
argument_list|(
operator|&
name|fhp
operator|->
name|fh_fsid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vs
operator|->
name|vs_mp
condition|)
block|{
return|return
operator|(
name|ESTALE
operator|)
return|;
block|}
name|vs
operator|->
name|vs_vfslocked
operator|=
name|VFS_LOCK_GIANT
argument_list|(
name|vs
operator|->
name|vs_mp
argument_list|)
expr_stmt|;
name|error
operator|=
name|VFS_CHECKEXP
argument_list|(
name|vs
operator|->
name|vs_mp
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
operator|->
name|nh_addr
argument_list|,
operator|&
name|exflags
argument_list|,
operator|&
name|credanon
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|exflags
operator|&
name|MNT_EXRDONLY
operator|||
operator|(
name|vs
operator|->
name|vs_mp
operator|->
name|mnt_flag
operator|&
name|MNT_RDONLY
operator|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|VFS_FHTOVP
argument_list|(
name|vs
operator|->
name|vs_mp
argument_list|,
operator|&
name|fhp
operator|->
name|fh_fid
argument_list|,
operator|&
name|vs
operator|->
name|vs_vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|vs
operator|->
name|vs_vnlocked
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|svc_getcred
argument_list|(
name|rqstp
argument_list|,
operator|&
name|cred
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|cred
operator|->
name|cr_uid
operator|==
literal|0
operator|||
operator|(
name|exflags
operator|&
name|MNT_EXPORTANON
operator|)
condition|)
block|{
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
name|cred
operator|=
name|credanon
expr_stmt|;
name|credanon
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Check cred. 	 */
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vs
operator|->
name|vs_vp
argument_list|,
name|VWRITE
argument_list|,
name|cred
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
if|#
directive|if
name|__FreeBSD_version
operator|<
literal|800011
name|VOP_UNLOCK
argument_list|(
name|vs
operator|->
name|vs_vp
argument_list|,
literal|0
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
else|#
directive|else
name|VOP_UNLOCK
argument_list|(
name|vs
operator|->
name|vs_vp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vs
operator|->
name|vs_vnlocked
operator|=
name|FALSE
expr_stmt|;
name|out
label|:
if|if
condition|(
name|cred
condition|)
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
if|if
condition|(
name|credanon
condition|)
name|crfree
argument_list|(
name|credanon
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nlm_release_vfs_state
parameter_list|(
name|struct
name|vfs_state
modifier|*
name|vs
parameter_list|)
block|{
if|if
condition|(
name|vs
operator|->
name|vs_vp
condition|)
block|{
if|if
condition|(
name|vs
operator|->
name|vs_vnlocked
condition|)
name|vput
argument_list|(
name|vs
operator|->
name|vs_vp
argument_list|)
expr_stmt|;
else|else
name|vrele
argument_list|(
name|vs
operator|->
name|vs_vp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vs
operator|->
name|vs_mp
condition|)
name|vfs_rel
argument_list|(
name|vs
operator|->
name|vs_mp
argument_list|)
expr_stmt|;
name|VFS_UNLOCK_GIANT
argument_list|(
name|vs
operator|->
name|vs_vfslocked
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|nlm4_stats
name|nlm_convert_error
parameter_list|(
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|error
operator|==
name|ESTALE
condition|)
return|return
name|nlm4_stale_fh
return|;
elseif|else
if|if
condition|(
name|error
operator|==
name|EROFS
condition|)
return|return
name|nlm4_rofs
return|;
else|else
return|return
name|nlm4_failed
return|;
block|}
end_function

begin_function
name|int
name|nlm_do_test
parameter_list|(
name|nlm4_testargs
modifier|*
name|argp
parameter_list|,
name|nlm4_testres
modifier|*
name|result
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|CLIENT
modifier|*
modifier|*
name|rpcp
parameter_list|)
block|{
name|fhandle_t
name|fh
decl_stmt|;
name|struct
name|vfs_state
name|vs
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|,
modifier|*
name|bhost
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sysid
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|vs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_name
argument_list|(
name|argp
operator|->
name|alock
operator|.
name|caller_name
argument_list|,
name|svc_getrpccaller
argument_list|(
name|rqstp
argument_list|)
argument_list|,
name|rqstp
operator|->
name|rq_vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_nolocks
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|NLM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"nlm_do_test(): caller_name = %s (sysid = %d)\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
name|nlm_check_expired_locks
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|sysid
operator|=
name|host
operator|->
name|nh_sysid
expr_stmt|;
name|nlm_convert_to_fhandle_t
argument_list|(
operator|&
name|fh
argument_list|,
operator|&
name|argp
operator|->
name|alock
operator|.
name|fh
argument_list|)
expr_stmt|;
name|nlm_copy_netobj
argument_list|(
operator|&
name|result
operator|->
name|cookie
argument_list|,
operator|&
name|argp
operator|->
name|cookie
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|<
name|nlm_grace_threshold
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_grace_period
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|nlm_get_vfs_state
argument_list|(
name|host
argument_list|,
name|rqstp
argument_list|,
operator|&
name|fh
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fl
operator|.
name|l_start
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_offset
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_len
expr_stmt|;
name|fl
operator|.
name|l_pid
operator|=
name|argp
operator|->
name|alock
operator|.
name|svid
expr_stmt|;
name|fl
operator|.
name|l_sysid
operator|=
name|sysid
expr_stmt|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|exclusive
condition|)
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
else|else
name|fl
operator|.
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|vs
operator|.
name|vs_vp
argument_list|,
name|NULL
argument_list|,
name|F_GETLK
argument_list|,
operator|&
name|fl
argument_list|,
name|F_REMOTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_failed
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|fl
operator|.
name|l_type
operator|==
name|F_UNLCK
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
operator|.
name|exclusive
operator|=
operator|(
name|fl
operator|.
name|l_type
operator|==
name|F_WRLCK
operator|)
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
operator|.
name|svid
operator|=
name|fl
operator|.
name|l_pid
expr_stmt|;
name|bhost
operator|=
name|nlm_find_host_by_sysid
argument_list|(
name|fl
operator|.
name|l_sysid
argument_list|)
expr_stmt|;
if|if
condition|(
name|bhost
condition|)
block|{
comment|/* 			 * We don't have any useful way of recording 			 * the value of oh used in the original lock 			 * request. Ideally, the test reply would have 			 * a space for the owning host's name allowing 			 * our caller's NLM to keep track. 			 * 			 * As far as I can see, Solaris uses an eight 			 * byte structure for oh which contains a four 			 * byte pid encoded in local byte order and 			 * the first four bytes of the host 			 * name. Linux uses a variable length string 			 * 'pid@hostname' in ascii but doesn't even 			 * return that in test replies. 			 * 			 * For the moment, return nothing in oh 			 * (already zero'ed above). 			 */
name|nlm_host_release
argument_list|(
name|bhost
argument_list|)
expr_stmt|;
block|}
name|result
operator|->
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
operator|.
name|l_offset
operator|=
name|fl
operator|.
name|l_start
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|nlm4_testrply_u
operator|.
name|holder
operator|.
name|l_len
operator|=
name|fl
operator|.
name|l_len
expr_stmt|;
block|}
name|out
label|:
name|nlm_release_vfs_state
argument_list|(
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcp
condition|)
operator|*
name|rpcp
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_do_lock
parameter_list|(
name|nlm4_lockargs
modifier|*
name|argp
parameter_list|,
name|nlm4_res
modifier|*
name|result
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|bool_t
name|monitor
parameter_list|,
name|CLIENT
modifier|*
modifier|*
name|rpcp
parameter_list|)
block|{
name|fhandle_t
name|fh
decl_stmt|;
name|struct
name|vfs_state
name|vs
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sysid
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|vs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_name
argument_list|(
name|argp
operator|->
name|alock
operator|.
name|caller_name
argument_list|,
name|svc_getrpccaller
argument_list|(
name|rqstp
argument_list|)
argument_list|,
name|rqstp
operator|->
name|rq_vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_nolocks
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|NLM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"nlm_do_lock(): caller_name = %s (sysid = %d)\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
if|if
condition|(
name|monitor
operator|&&
name|host
operator|->
name|nh_state
operator|&&
name|argp
operator|->
name|state
operator|&&
name|host
operator|->
name|nh_state
operator|!=
name|argp
operator|->
name|state
condition|)
block|{
comment|/* 		 * The host rebooted without telling us. Trash its 		 * locks. 		 */
name|nlm_host_notify
argument_list|(
name|host
argument_list|,
name|argp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
name|nlm_check_expired_locks
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|sysid
operator|=
name|host
operator|->
name|nh_sysid
expr_stmt|;
name|nlm_convert_to_fhandle_t
argument_list|(
operator|&
name|fh
argument_list|,
operator|&
name|argp
operator|->
name|alock
operator|.
name|fh
argument_list|)
expr_stmt|;
name|nlm_copy_netobj
argument_list|(
operator|&
name|result
operator|->
name|cookie
argument_list|,
operator|&
name|argp
operator|->
name|cookie
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|<
name|nlm_grace_threshold
operator|&&
operator|!
name|argp
operator|->
name|reclaim
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_grace_period
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|nlm_get_vfs_state
argument_list|(
name|host
argument_list|,
name|rqstp
argument_list|,
operator|&
name|fh
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fl
operator|.
name|l_start
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_offset
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_len
expr_stmt|;
name|fl
operator|.
name|l_pid
operator|=
name|argp
operator|->
name|alock
operator|.
name|svid
expr_stmt|;
name|fl
operator|.
name|l_sysid
operator|=
name|sysid
expr_stmt|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|exclusive
condition|)
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
else|else
name|fl
operator|.
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|block
condition|)
block|{
name|struct
name|nlm_async_lock
modifier|*
name|af
decl_stmt|;
name|CLIENT
modifier|*
name|client
decl_stmt|;
name|struct
name|nlm_grantcookie
name|cookie
decl_stmt|;
comment|/* 		 * First, make sure we can contact the host's NLM. 		 */
name|client
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|client
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_failed
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * First we need to check and see if there is an 		 * existing blocked lock that matches. This could be a 		 * badly behaved client or an RPC re-send. If we find 		 * one, just return nlm4_blocked. 		 */
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|af
argument_list|,
argument|&host->nh_pending
argument_list|,
argument|af_link
argument_list|)
block|{
if|if
condition|(
name|af
operator|->
name|af_fl
operator|.
name|l_start
operator|==
name|fl
operator|.
name|l_start
operator|&&
name|af
operator|->
name|af_fl
operator|.
name|l_len
operator|==
name|fl
operator|.
name|l_len
operator|&&
name|af
operator|->
name|af_fl
operator|.
name|l_pid
operator|==
name|fl
operator|.
name|l_pid
operator|&&
name|af
operator|->
name|af_fl
operator|.
name|l_type
operator|==
name|fl
operator|.
name|l_type
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|af
condition|)
block|{
name|cookie
operator|.
name|ng_sysid
operator|=
name|host
operator|->
name|nh_sysid
expr_stmt|;
name|cookie
operator|.
name|ng_cookie
operator|=
name|host
operator|->
name|nh_grantcookie
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
condition|)
block|{
name|CLNT_RELEASE
argument_list|(
name|client
argument_list|)
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_blocked
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|af
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_async_lock
argument_list|)
argument_list|,
name|M_NLM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|af
operator|->
name|af_task
argument_list|,
literal|0
argument_list|,
name|nlm_lock_callback
argument_list|,
name|af
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_vp
operator|=
name|vs
operator|.
name|vs_vp
expr_stmt|;
name|af
operator|->
name|af_fl
operator|=
name|fl
expr_stmt|;
name|af
operator|->
name|af_host
operator|=
name|host
expr_stmt|;
name|af
operator|->
name|af_rpc
operator|=
name|client
expr_stmt|;
comment|/* 		 * We use M_RPC here so that we can xdr_free the thing 		 * later. 		 */
name|nlm_make_netobj
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|cookie
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|cookie
argument_list|,
sizeof|sizeof
argument_list|(
name|cookie
argument_list|)
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_granted
operator|.
name|exclusive
operator|=
name|argp
operator|->
name|exclusive
expr_stmt|;
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|caller_name
operator|=
name|strdup
argument_list|(
name|argp
operator|->
name|alock
operator|.
name|caller_name
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|nlm_copy_netobj
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|fh
argument_list|,
operator|&
name|argp
operator|->
name|alock
operator|.
name|fh
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|nlm_copy_netobj
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|oh
argument_list|,
operator|&
name|argp
operator|->
name|alock
operator|.
name|oh
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|svid
operator|=
name|argp
operator|->
name|alock
operator|.
name|svid
expr_stmt|;
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|l_offset
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_offset
expr_stmt|;
name|af
operator|->
name|af_granted
operator|.
name|alock
operator|.
name|l_len
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_len
expr_stmt|;
comment|/* 		 * Put the entry on the pending list before calling 		 * VOP_ADVLOCKASYNC. We do this in case the lock 		 * request was blocked (returning EINPROGRESS) but 		 * then granted before we manage to run again. The 		 * client may receive the granted message before we 		 * send our blocked reply but thats their problem. 		 */
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|host
operator|->
name|nh_pending
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_ADVLOCKASYNC
argument_list|(
name|vs
operator|.
name|vs_vp
argument_list|,
name|NULL
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|fl
argument_list|,
name|F_REMOTE
argument_list|,
operator|&
name|af
operator|->
name|af_task
argument_list|,
operator|&
name|af
operator|->
name|af_cookie
argument_list|)
expr_stmt|;
comment|/* 		 * If the lock completed synchronously, just free the 		 * tracking structure now. 		 */
if|if
condition|(
name|error
operator|!=
name|EINPROGRESS
condition|)
block|{
name|CLNT_RELEASE
argument_list|(
name|af
operator|->
name|af_rpc
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|host
operator|->
name|nh_pending
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|xdr_free
argument_list|(
operator|(
name|xdrproc_t
operator|)
name|xdr_nlm4_testargs
argument_list|,
operator|&
name|af
operator|->
name|af_granted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|af
argument_list|,
name|M_NLM
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NLM_DEBUG
argument_list|(
literal|2
argument_list|,
literal|"NLM: pending async lock %p for %s "
literal|"(sysid %d)\n"
argument_list|,
name|af
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|sysid
argument_list|)
expr_stmt|;
comment|/* 			 * Don't vrele the vnode just yet - this must 			 * wait until either the async callback 			 * happens or the lock is cancelled. 			 */
name|vs
operator|.
name|vs_vp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|vs
operator|.
name|vs_vp
argument_list|,
name|NULL
argument_list|,
name|F_SETLK
argument_list|,
operator|&
name|fl
argument_list|,
name|F_REMOTE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|==
name|EINPROGRESS
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_blocked
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EDEADLK
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_deadlck
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_failed
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|monitor
condition|)
name|nlm_host_monitor
argument_list|(
name|host
argument_list|,
name|argp
operator|->
name|state
argument_list|)
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
block|}
name|out
label|:
name|nlm_release_vfs_state
argument_list|(
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcp
condition|)
operator|*
name|rpcp
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_do_cancel
parameter_list|(
name|nlm4_cancargs
modifier|*
name|argp
parameter_list|,
name|nlm4_res
modifier|*
name|result
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|CLIENT
modifier|*
modifier|*
name|rpcp
parameter_list|)
block|{
name|fhandle_t
name|fh
decl_stmt|;
name|struct
name|vfs_state
name|vs
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sysid
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|struct
name|nlm_async_lock
modifier|*
name|af
decl_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|vs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_name
argument_list|(
name|argp
operator|->
name|alock
operator|.
name|caller_name
argument_list|,
name|svc_getrpccaller
argument_list|(
name|rqstp
argument_list|)
argument_list|,
name|rqstp
operator|->
name|rq_vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_nolocks
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|NLM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"nlm_do_cancel(): caller_name = %s (sysid = %d)\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
name|nlm_check_expired_locks
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|sysid
operator|=
name|host
operator|->
name|nh_sysid
expr_stmt|;
name|nlm_convert_to_fhandle_t
argument_list|(
operator|&
name|fh
argument_list|,
operator|&
name|argp
operator|->
name|alock
operator|.
name|fh
argument_list|)
expr_stmt|;
name|nlm_copy_netobj
argument_list|(
operator|&
name|result
operator|->
name|cookie
argument_list|,
operator|&
name|argp
operator|->
name|cookie
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|<
name|nlm_grace_threshold
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_grace_period
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|nlm_get_vfs_state
argument_list|(
name|host
argument_list|,
name|rqstp
argument_list|,
operator|&
name|fh
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fl
operator|.
name|l_start
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_offset
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_len
expr_stmt|;
name|fl
operator|.
name|l_pid
operator|=
name|argp
operator|->
name|alock
operator|.
name|svid
expr_stmt|;
name|fl
operator|.
name|l_sysid
operator|=
name|sysid
expr_stmt|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
if|if
condition|(
name|argp
operator|->
name|exclusive
condition|)
name|fl
operator|.
name|l_type
operator|=
name|F_WRLCK
expr_stmt|;
else|else
name|fl
operator|.
name|l_type
operator|=
name|F_RDLCK
expr_stmt|;
comment|/* 	 * First we need to try and find the async lock request - if 	 * there isn't one, we give up and return nlm4_denied. 	 */
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|af
argument_list|,
argument|&host->nh_pending
argument_list|,
argument|af_link
argument_list|)
block|{
if|if
condition|(
name|af
operator|->
name|af_fl
operator|.
name|l_start
operator|==
name|fl
operator|.
name|l_start
operator|&&
name|af
operator|->
name|af_fl
operator|.
name|l_len
operator|==
name|fl
operator|.
name|l_len
operator|&&
name|af
operator|->
name|af_fl
operator|.
name|l_pid
operator|==
name|fl
operator|.
name|l_pid
operator|&&
name|af
operator|->
name|af_fl
operator|.
name|l_type
operator|==
name|fl
operator|.
name|l_type
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|af
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|nlm_cancel_async_lock
argument_list|(
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|nlm_release_vfs_state
argument_list|(
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcp
condition|)
operator|*
name|rpcp
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_do_unlock
parameter_list|(
name|nlm4_unlockargs
modifier|*
name|argp
parameter_list|,
name|nlm4_res
modifier|*
name|result
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|CLIENT
modifier|*
modifier|*
name|rpcp
parameter_list|)
block|{
name|fhandle_t
name|fh
decl_stmt|;
name|struct
name|vfs_state
name|vs
decl_stmt|;
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|int
name|error
decl_stmt|,
name|sysid
decl_stmt|;
name|struct
name|flock
name|fl
decl_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|vs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_name
argument_list|(
name|argp
operator|->
name|alock
operator|.
name|caller_name
argument_list|,
name|svc_getrpccaller
argument_list|(
name|rqstp
argument_list|)
argument_list|,
name|rqstp
operator|->
name|rq_vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_nolocks
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|NLM_DEBUG
argument_list|(
literal|3
argument_list|,
literal|"nlm_do_unlock(): caller_name = %s (sysid = %d)\n"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
name|nlm_check_expired_locks
argument_list|(
name|host
argument_list|)
expr_stmt|;
name|sysid
operator|=
name|host
operator|->
name|nh_sysid
expr_stmt|;
name|nlm_convert_to_fhandle_t
argument_list|(
operator|&
name|fh
argument_list|,
operator|&
name|argp
operator|->
name|alock
operator|.
name|fh
argument_list|)
expr_stmt|;
name|nlm_copy_netobj
argument_list|(
operator|&
name|result
operator|->
name|cookie
argument_list|,
operator|&
name|argp
operator|->
name|cookie
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|<
name|nlm_grace_threshold
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_grace_period
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|nlm_get_vfs_state
argument_list|(
name|host
argument_list|,
name|rqstp
argument_list|,
operator|&
name|fh
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm_convert_error
argument_list|(
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|fl
operator|.
name|l_start
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_offset
expr_stmt|;
name|fl
operator|.
name|l_len
operator|=
name|argp
operator|->
name|alock
operator|.
name|l_len
expr_stmt|;
name|fl
operator|.
name|l_pid
operator|=
name|argp
operator|->
name|alock
operator|.
name|svid
expr_stmt|;
name|fl
operator|.
name|l_sysid
operator|=
name|sysid
expr_stmt|;
name|fl
operator|.
name|l_whence
operator|=
name|SEEK_SET
expr_stmt|;
name|fl
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|vs
operator|.
name|vs_vp
argument_list|,
name|NULL
argument_list|,
name|F_UNLCK
argument_list|,
operator|&
name|fl
argument_list|,
name|F_REMOTE
argument_list|)
expr_stmt|;
comment|/* 	 * Ignore the error - there is no result code for failure, 	 * only for grace period. 	 */
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
name|out
label|:
name|nlm_release_vfs_state
argument_list|(
operator|&
name|vs
argument_list|)
expr_stmt|;
if|if
condition|(
name|rpcp
condition|)
operator|*
name|rpcp
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nlm_do_granted
parameter_list|(
name|nlm4_testargs
modifier|*
name|argp
parameter_list|,
name|nlm4_res
modifier|*
name|result
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|,
name|CLIENT
modifier|*
modifier|*
name|rpcp
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|;
name|struct
name|nlm_waiting_lock
modifier|*
name|nw
decl_stmt|;
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|host
operator|=
name|nlm_find_host_by_addr
argument_list|(
name|svc_getrpccaller
argument_list|(
name|rqstp
argument_list|)
argument_list|,
name|rqstp
operator|->
name|rq_vers
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied_nolocks
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|nlm_copy_netobj
argument_list|(
operator|&
name|result
operator|->
name|cookie
argument_list|,
operator|&
name|argp
operator|->
name|cookie
argument_list|,
name|M_RPC
argument_list|)
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_denied
expr_stmt|;
name|KFAIL_POINT_CODE
argument_list|(
argument|DEBUG_FP
argument_list|,
argument|nlm_deny_grant
argument_list|,
argument|goto out
argument_list|)
empty_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|nw
argument_list|,
argument|&nlm_waiting_locks
argument_list|,
argument|nw_link
argument_list|)
block|{
if|if
condition|(
operator|!
name|nw
operator|->
name|nw_waiting
condition|)
continue|continue;
if|if
condition|(
name|argp
operator|->
name|alock
operator|.
name|svid
operator|==
name|nw
operator|->
name|nw_lock
operator|.
name|svid
operator|&&
name|argp
operator|->
name|alock
operator|.
name|l_offset
operator|==
name|nw
operator|->
name|nw_lock
operator|.
name|l_offset
operator|&&
name|argp
operator|->
name|alock
operator|.
name|l_len
operator|==
name|nw
operator|->
name|nw_lock
operator|.
name|l_len
operator|&&
name|argp
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_len
operator|==
name|nw
operator|->
name|nw_lock
operator|.
name|fh
operator|.
name|n_len
operator|&&
operator|!
name|memcmp
argument_list|(
name|argp
operator|->
name|alock
operator|.
name|fh
operator|.
name|n_bytes
argument_list|,
name|nw
operator|->
name|nw_lock
operator|.
name|fh
operator|.
name|n_bytes
argument_list|,
name|nw
operator|->
name|nw_lock
operator|.
name|fh
operator|.
name|n_len
argument_list|)
condition|)
block|{
name|nw
operator|->
name|nw_waiting
operator|=
name|FALSE
expr_stmt|;
name|wakeup
argument_list|(
name|nw
argument_list|)
expr_stmt|;
name|result
operator|->
name|stat
operator|.
name|stat
operator|=
name|nlm4_granted
expr_stmt|;
break|break;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|nlm_global_lock
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|rpcp
condition|)
operator|*
name|rpcp
operator|=
name|nlm_host_get_rpc
argument_list|(
name|host
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nlm_do_granted_res
parameter_list|(
name|nlm4_res
modifier|*
name|argp
parameter_list|,
name|struct
name|svc_req
modifier|*
name|rqstp
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
name|struct
name|nlm_async_lock
modifier|*
name|af
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|argp
operator|->
name|cookie
operator|.
name|n_len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|nlm_grantcookie
argument_list|)
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: bogus grant cookie"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|host
operator|=
name|nlm_find_host_by_sysid
argument_list|(
name|ng_sysid
argument_list|(
operator|&
name|argp
operator|->
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|host
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: Unknown host rejected our grant"
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|mtx_lock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|af
argument_list|,
argument|&host->nh_granted
argument_list|,
argument|af_link
argument_list|)
if|if
condition|(
name|ng_cookie
argument_list|(
operator|&
name|argp
operator|->
name|cookie
argument_list|)
operator|==
name|ng_cookie
argument_list|(
operator|&
name|af
operator|->
name|af_granted
operator|.
name|cookie
argument_list|)
condition|)
break|break;
if|if
condition|(
name|af
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|host
operator|->
name|nh_granted
argument_list|,
name|af
argument_list|,
name|af_link
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|host
operator|->
name|nh_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|af
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: host %s (sysid %d) replied to our grant "
literal|"with unrecognized cookie %d:%d"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|,
name|ng_sysid
argument_list|(
operator|&
name|argp
operator|->
name|cookie
argument_list|)
argument_list|,
name|ng_cookie
argument_list|(
operator|&
name|argp
operator|->
name|cookie
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|argp
operator|->
name|stat
operator|.
name|stat
operator|!=
name|nlm4_granted
condition|)
block|{
name|af
operator|->
name|af_fl
operator|.
name|l_type
operator|=
name|F_UNLCK
expr_stmt|;
name|error
operator|=
name|VOP_ADVLOCK
argument_list|(
name|af
operator|->
name|af_vp
argument_list|,
name|NULL
argument_list|,
name|F_UNLCK
argument_list|,
operator|&
name|af
operator|->
name|af_fl
argument_list|,
name|F_REMOTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|NLM_DEBUG
argument_list|(
literal|1
argument_list|,
literal|"NLM: host %s (sysid %d) rejected our grant "
literal|"and we failed to unlock (%d)"
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|NLM_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"NLM: async lock %p rejected by host %s (sysid %d)"
argument_list|,
name|af
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|NLM_DEBUG
argument_list|(
literal|5
argument_list|,
literal|"NLM: async lock %p accepted by host %s (sysid %d)"
argument_list|,
name|af
argument_list|,
name|host
operator|->
name|nh_caller_name
argument_list|,
name|host
operator|->
name|nh_sysid
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|af
condition|)
name|nlm_free_async_lock
argument_list|(
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
condition|)
name|nlm_host_release
argument_list|(
name|host
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nlm_do_free_all
parameter_list|(
name|nlm4_notify
modifier|*
name|argp
parameter_list|)
block|{
name|struct
name|nlm_host
modifier|*
name|host
decl_stmt|,
modifier|*
name|thost
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|host
argument_list|,
argument|&nlm_hosts
argument_list|,
argument|nh_link
argument_list|,
argument|thost
argument_list|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|host
operator|->
name|nh_caller_name
argument_list|,
name|argp
operator|->
name|name
argument_list|)
condition|)
name|nlm_host_notify
argument_list|(
name|host
argument_list|,
name|argp
operator|->
name|state
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Kernel module glue  */
end_comment

begin_function
specifier|static
name|int
name|nfslockd_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|nfslockd_mod
init|=
block|{
literal|"nfslockd"
block|,
name|nfslockd_modevent
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|nfslockd
argument_list|,
name|nfslockd_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* So that loader and kldload(2) can find us, wherever we are.. */
end_comment

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfslockd
argument_list|,
name|krpc
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|nfslockd
argument_list|,
name|nfs
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|nfslockd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

