begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003, 2005 Ryuichiro Imura  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/iconv.h>
end_include

begin_include
include|#
directive|include
file|"iconv_converter_if.h"
end_include

begin_comment
comment|/*  * "UCS" converter  */
end_comment

begin_define
define|#
directive|define
name|KICONV_UCS_COMBINE
value|0x1
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_FROM_UTF8
value|0x2
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_TO_UTF8
value|0x4
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_FROM_LE
value|0x8
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_TO_LE
value|0x10
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_FROM_UTF16
value|0x20
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_TO_UTF16
value|0x40
end_define

begin_define
define|#
directive|define
name|KICONV_UCS_UCS4
value|0x80
end_define

begin_define
define|#
directive|define
name|ENCODING_UTF16
value|"UTF-16BE"
end_define

begin_define
define|#
directive|define
name|ENCODING_UTF8
value|"UTF-8"
end_define

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|from_flag
decl_stmt|,
name|to_flag
decl_stmt|;
block|}
name|unicode_family
index|[]
init|=
block|{
block|{
literal|"UTF-8"
block|,
name|KICONV_UCS_FROM_UTF8
block|,
name|KICONV_UCS_TO_UTF8
block|}
block|,
block|{
literal|"UCS-2LE"
block|,
name|KICONV_UCS_FROM_LE
block|,
name|KICONV_UCS_TO_LE
block|}
block|,
block|{
literal|"UTF-16BE"
block|,
name|KICONV_UCS_FROM_UTF16
block|,
name|KICONV_UCS_TO_UTF16
block|}
block|,
block|{
literal|"UTF-16LE"
block|,
name|KICONV_UCS_FROM_UTF16
operator||
name|KICONV_UCS_FROM_LE
block|,
name|KICONV_UCS_TO_UTF16
operator||
name|KICONV_UCS_TO_LE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|uint32_t
name|utf8_to_ucs4
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
modifier|*
name|utf8width
parameter_list|,
name|size_t
name|srclen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_char
modifier|*
name|ucs4_to_utf8
parameter_list|(
name|uint32_t
name|ucs4
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|utf8width
parameter_list|,
name|size_t
name|dstlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|encode_surrogate
parameter_list|(
name|uint32_t
name|code
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|decode_surrogate
parameter_list|(
specifier|const
name|u_char
modifier|*
name|ucs
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MODULE_DEPEND
end_ifdef

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|iconv_ucs
argument_list|,
name|libiconv
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * UCS converter instance  */
end_comment

begin_struct
struct|struct
name|iconv_ucs
block|{
name|KOBJ_FIELDS
expr_stmt|;
name|int
name|convtype
decl_stmt|;
name|struct
name|iconv_cspair
modifier|*
name|d_csp
decl_stmt|;
name|struct
name|iconv_cspair
modifier|*
name|d_cspf
decl_stmt|;
name|void
modifier|*
name|f_ctp
decl_stmt|;
name|void
modifier|*
name|t_ctp
decl_stmt|;
name|void
modifier|*
name|ctype
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|iconv_ucs_open
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|,
name|struct
name|iconv_cspair
modifier|*
name|csp
parameter_list|,
name|struct
name|iconv_cspair
modifier|*
name|cspf
parameter_list|,
name|void
modifier|*
modifier|*
name|dpp
parameter_list|)
block|{
name|struct
name|iconv_ucs
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|from
decl_stmt|,
modifier|*
name|to
decl_stmt|;
name|dp
operator|=
operator|(
expr|struct
name|iconv_ucs
operator|*
operator|)
name|kobj_create
argument_list|(
operator|(
expr|struct
name|kobj_class
operator|*
operator|)
name|dcp
argument_list|,
name|M_ICONV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|to
operator|=
name|csp
operator|->
name|cp_to
expr_stmt|;
name|from
operator|=
name|cspf
condition|?
name|cspf
operator|->
name|cp_from
else|:
name|csp
operator|->
name|cp_from
expr_stmt|;
name|dp
operator|->
name|convtype
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cspf
condition|)
name|dp
operator|->
name|convtype
operator||=
name|KICONV_UCS_COMBINE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|unicode_family
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|from
argument_list|,
name|unicode_family
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|convtype
operator||=
name|unicode_family
index|[
name|i
index|]
operator|.
name|from_flag
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|to
argument_list|,
name|unicode_family
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|convtype
operator||=
name|unicode_family
index|[
name|i
index|]
operator|.
name|to_flag
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|ENCODING_UNICODE
argument_list|,
name|ENCODING_UTF16
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|convtype
operator||=
name|KICONV_UCS_UCS4
expr_stmt|;
else|else
name|dp
operator|->
name|convtype
operator|&=
operator|~
name|KICONV_UCS_UCS4
expr_stmt|;
name|dp
operator|->
name|f_ctp
operator|=
name|dp
operator|->
name|t_ctp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_COMBINE
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_FROM_UTF8
operator|)
operator|==
literal|0
operator|&&
operator|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_FROM_LE
operator|)
operator|==
literal|0
condition|)
block|{
name|iconv_open
argument_list|(
name|ENCODING_UNICODE
argument_list|,
name|from
argument_list|,
operator|&
name|dp
operator|->
name|f_ctp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_TO_UTF8
operator|)
operator|==
literal|0
operator|&&
operator|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_TO_LE
operator|)
operator|==
literal|0
condition|)
block|{
name|iconv_open
argument_list|(
name|to
argument_list|,
name|ENCODING_UNICODE
argument_list|,
operator|&
name|dp
operator|->
name|t_ctp
argument_list|)
expr_stmt|;
block|}
block|}
name|dp
operator|->
name|ctype
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
operator|(
name|KICONV_UCS_FROM_UTF8
operator||
name|KICONV_UCS_TO_UTF8
operator|)
condition|)
name|iconv_open
argument_list|(
name|KICONV_WCTYPE_NAME
argument_list|,
name|ENCODING_UTF8
argument_list|,
operator|&
name|dp
operator|->
name|ctype
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_csp
operator|=
name|csp
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
operator|(
name|KICONV_UCS_FROM_UTF8
operator||
name|KICONV_UCS_FROM_LE
operator|)
condition|)
block|{
if|if
condition|(
name|cspf
condition|)
block|{
name|dp
operator|->
name|d_cspf
operator|=
name|cspf
expr_stmt|;
name|cspf
operator|->
name|cp_refcount
operator|++
expr_stmt|;
block|}
else|else
name|csp
operator|->
name|cp_refcount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
operator|(
name|KICONV_UCS_TO_UTF8
operator||
name|KICONV_UCS_TO_LE
operator|)
condition|)
name|csp
operator|->
name|cp_refcount
operator|++
expr_stmt|;
operator|*
name|dpp
operator|=
operator|(
name|void
operator|*
operator|)
name|dp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_ucs_close
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iconv_ucs
modifier|*
name|dp
init|=
name|data
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|f_ctp
condition|)
name|iconv_close
argument_list|(
name|dp
operator|->
name|f_ctp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|t_ctp
condition|)
name|iconv_close
argument_list|(
name|dp
operator|->
name|t_ctp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|ctype
condition|)
name|iconv_close
argument_list|(
name|dp
operator|->
name|ctype
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_cspf
condition|)
name|dp
operator|->
name|d_cspf
operator|->
name|cp_refcount
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
operator|(
name|KICONV_UCS_FROM_UTF8
operator||
name|KICONV_UCS_FROM_LE
operator|)
condition|)
name|dp
operator|->
name|d_csp
operator|->
name|cp_refcount
operator|--
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
operator|(
name|KICONV_UCS_TO_UTF8
operator||
name|KICONV_UCS_TO_LE
operator|)
condition|)
name|dp
operator|->
name|d_csp
operator|->
name|cp_refcount
operator|--
expr_stmt|;
name|kobj_delete
argument_list|(
operator|(
expr|struct
name|kobj
operator|*
operator|)
name|data
argument_list|,
name|M_ICONV
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_ucs_conv
parameter_list|(
name|void
modifier|*
name|d2p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|inbuf
parameter_list|,
name|size_t
modifier|*
name|inbytesleft
parameter_list|,
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|size_t
modifier|*
name|outbytesleft
parameter_list|,
name|int
name|convchar
parameter_list|,
name|int
name|casetype
parameter_list|)
block|{
name|struct
name|iconv_ucs
modifier|*
name|dp
init|=
operator|(
expr|struct
name|iconv_ucs
operator|*
operator|)
name|d2p
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|in
decl_stmt|,
name|on
decl_stmt|,
name|ir
decl_stmt|,
name|or
decl_stmt|,
name|inlen
decl_stmt|,
name|outlen
decl_stmt|,
name|ucslen
decl_stmt|;
specifier|const
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|u_char
name|ucs
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|uint32_t
name|code
decl_stmt|;
if|if
condition|(
name|inbuf
operator|==
name|NULL
operator|||
operator|*
name|inbuf
operator|==
name|NULL
operator|||
name|outbuf
operator|==
name|NULL
operator|||
operator|*
name|outbuf
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ir
operator|=
name|in
operator|=
operator|*
name|inbytesleft
expr_stmt|;
name|or
operator|=
name|on
operator|=
operator|*
name|outbytesleft
expr_stmt|;
name|src
operator|=
operator|*
name|inbuf
expr_stmt|;
name|dst
operator|=
operator|*
name|outbuf
expr_stmt|;
while|while
condition|(
name|ir
operator|>
literal|0
operator|&&
name|or
operator|>
literal|0
condition|)
block|{
comment|/* 		 * The first half of conversion. 		 * (convert any code into ENCODING_UNICODE) 		 */
name|code
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_FROM_UTF8
condition|)
block|{
comment|/* convert UTF-8 to ENCODING_UNICODE */
name|inlen
operator|=
literal|0
expr_stmt|;
name|code
operator|=
name|utf8_to_ucs4
argument_list|(
name|p
argument_list|,
operator|&
name|inlen
argument_list|,
name|ir
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|casetype
operator|==
name|KICONV_FROM_LOWER
operator|&&
name|dp
operator|->
name|ctype
condition|)
block|{
name|code
operator|=
name|towlower
argument_list|(
name|code
argument_list|,
name|dp
operator|->
name|ctype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|casetype
operator|==
name|KICONV_FROM_UPPER
operator|&&
name|dp
operator|->
name|ctype
condition|)
block|{
name|code
operator|=
name|towupper
argument_list|(
name|code
argument_list|,
name|dp
operator|->
name|ctype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|code
operator|>=
literal|0xd800
operator|&&
name|code
operator|<
literal|0xe000
operator|)
operator|||
name|code
operator|>=
literal|0x110000
condition|)
block|{
comment|/* reserved for utf-16 surrogate pair */
comment|/* invalid unicode */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|inlen
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_UCS4
condition|)
block|{
name|ucslen
operator|=
literal|4
expr_stmt|;
name|code
operator|=
name|encode_surrogate
argument_list|(
name|code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* can't handle with ucs-2 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ucslen
operator|=
literal|2
expr_stmt|;
block|}
comment|/* save UCS-4 into ucs[] */
for|for
control|(
name|q
operator|=
name|ucs
operator|,
name|i
operator|=
name|ucslen
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
operator|*
name|q
operator|++
operator|=
operator|(
name|code
operator|>>
operator|(
name|i
operator|<<
literal|3
operator|)
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_COMBINE
operator|&&
name|dp
operator|->
name|f_ctp
condition|)
block|{
comment|/* convert local code to ENCODING_UNICODE */
name|ucslen
operator|=
literal|4
expr_stmt|;
name|inlen
operator|=
name|ir
expr_stmt|;
name|q
operator|=
name|ucs
expr_stmt|;
name|ret
operator|=
name|iconv_convchr_case
argument_list|(
name|dp
operator|->
name|f_ctp
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|inlen
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|q
argument_list|,
operator|&
name|ucslen
argument_list|,
name|casetype
operator|&
operator|(
name|KICONV_FROM_LOWER
operator||
name|KICONV_FROM_UPPER
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|inlen
operator|=
name|ir
operator|-
name|inlen
expr_stmt|;
name|ucslen
operator|=
literal|4
operator|-
name|ucslen
expr_stmt|;
block|}
else|else
block|{
comment|/* src code is a proper subset of ENCODING_UNICODE */
name|q
operator|=
name|ucs
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_FROM_LE
condition|)
block|{
operator|*
name|q
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|q
operator|&
literal|0xfc
operator|)
operator|==
literal|0xd8
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_UCS4
operator|&&
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_FROM_UTF16
condition|)
block|{
name|inlen
operator|=
name|ucslen
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* invalid unicode */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|inlen
operator|=
name|ucslen
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ir
operator|<
name|inlen
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ucslen
operator|==
literal|4
condition|)
block|{
name|q
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_FROM_LE
condition|)
block|{
operator|*
name|q
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
operator|*
name|q
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
operator|(
name|q
operator|+
literal|1
operator|)
operator|=
operator|*
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|q
operator|&
literal|0xfc
operator|)
operator|!=
literal|0xdc
condition|)
block|{
comment|/* invalid unicode */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 		 * The second half of conversion. 		 * (convert ENCODING_UNICODE into any code) 		 */
name|p
operator|=
name|ucs
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_TO_UTF8
condition|)
block|{
name|q
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dst
expr_stmt|;
if|if
condition|(
name|ucslen
operator|==
literal|4
operator|&&
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_UCS4
condition|)
block|{
comment|/* decode surrogate pair */
name|code
operator|=
name|decode_surrogate
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|code
operator|=
operator|(
name|ucs
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|ucs
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|casetype
operator|==
name|KICONV_LOWER
operator|&&
name|dp
operator|->
name|ctype
condition|)
block|{
name|code
operator|=
name|towlower
argument_list|(
name|code
argument_list|,
name|dp
operator|->
name|ctype
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|casetype
operator|==
name|KICONV_UPPER
operator|&&
name|dp
operator|->
name|ctype
condition|)
block|{
name|code
operator|=
name|towupper
argument_list|(
name|code
argument_list|,
name|dp
operator|->
name|ctype
argument_list|)
expr_stmt|;
block|}
name|outlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ucs4_to_utf8
argument_list|(
name|code
argument_list|,
name|q
argument_list|,
operator|&
name|outlen
argument_list|,
name|or
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|src
operator|+=
name|inlen
expr_stmt|;
name|ir
operator|-=
name|inlen
expr_stmt|;
name|dst
operator|+=
name|outlen
expr_stmt|;
name|or
operator|-=
name|outlen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_COMBINE
operator|&&
name|dp
operator|->
name|t_ctp
condition|)
block|{
name|ret
operator|=
name|iconv_convchr_case
argument_list|(
name|dp
operator|->
name|t_ctp
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|ucslen
argument_list|,
operator|&
name|dst
argument_list|,
operator|&
name|or
argument_list|,
name|casetype
operator|&
operator|(
name|KICONV_LOWER
operator||
name|KICONV_UPPER
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
break|break;
name|src
operator|+=
name|inlen
expr_stmt|;
name|ir
operator|-=
name|inlen
expr_stmt|;
block|}
else|else
block|{
comment|/* dst code is a proper subset of ENCODING_UNICODE */
if|if
condition|(
name|or
operator|<
name|ucslen
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|src
operator|+=
name|inlen
expr_stmt|;
name|ir
operator|-=
name|inlen
expr_stmt|;
name|or
operator|-=
name|ucslen
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_TO_LE
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ucslen
operator|==
literal|4
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_UCS4
operator|)
operator|==
literal|0
operator|||
operator|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_TO_UTF16
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dp
operator|->
name|convtype
operator|&
name|KICONV_UCS_TO_LE
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
operator|*
name|dst
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|convchar
operator|==
literal|1
condition|)
break|break;
block|}
operator|*
name|inbuf
operator|+=
name|in
operator|-
name|ir
expr_stmt|;
operator|*
name|outbuf
operator|+=
name|on
operator|-
name|or
expr_stmt|;
operator|*
name|inbytesleft
operator|-=
name|in
operator|-
name|ir
expr_stmt|;
operator|*
name|outbytesleft
operator|-=
name|on
operator|-
name|or
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_ucs_init
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|iconv_add
argument_list|(
name|ENCODING_UNICODE
argument_list|,
name|ENCODING_UNICODE
argument_list|,
name|ENCODING_UTF8
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|iconv_add
argument_list|(
name|ENCODING_UNICODE
argument_list|,
name|ENCODING_UTF8
argument_list|,
name|ENCODING_UNICODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_ucs_done
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|iconv_ucs_name
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|)
block|{
return|return
operator|(
name|ENCODING_UNICODE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|iconv_ucs_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|iconv_converter_open
argument_list|,
name|iconv_ucs_open
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|iconv_converter_close
argument_list|,
name|iconv_ucs_close
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|iconv_converter_conv
argument_list|,
name|iconv_ucs_conv
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|iconv_converter_init
argument_list|,
name|iconv_ucs_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|iconv_converter_done
argument_list|,
name|iconv_ucs_done
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|iconv_converter_name
argument_list|,
name|iconv_ucs_name
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|KICONV_CONVERTER
argument_list|(
name|ucs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|iconv_ucs
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|uint32_t
name|utf8_to_ucs4
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
modifier|*
name|utf8width
parameter_list|,
name|size_t
name|srclen
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|w
init|=
literal|0
decl_stmt|;
name|uint32_t
name|ucs4
init|=
literal|0
decl_stmt|;
comment|/* 	 * get leading 1 byte from utf-8 	 */
if|if
condition|(
operator|(
operator|*
name|src
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * leading 1 bit is "0" 		 *  utf-8: 0xxxxxxx 		 *  ucs-4: 00000000 00000000 00000000 0xxxxxxx 		 */
name|w
operator|=
literal|1
expr_stmt|;
comment|/* get trailing 7 bits */
name|ucs4
operator|=
operator|*
name|src
operator|&
literal|0x7f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|src
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
comment|/* 		 * leading 3 bits are "110" 		 *  utf-8: 110xxxxx 10yyyyyy 		 *  ucs-4: 00000000 00000000 00000xxx xxyyyyyy 		 */
name|w
operator|=
literal|2
expr_stmt|;
comment|/* get trailing 5 bits */
name|ucs4
operator|=
operator|*
name|src
operator|&
literal|0x1f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|src
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
comment|/* 		 * leading 4 bits are "1110" 		 *  utf-8: 1110xxxx 10yyyyyy 10zzzzzz 		 *  ucs-4: 00000000 00000000 xxxxyyyy yyzzzzzz 		 */
name|w
operator|=
literal|3
expr_stmt|;
comment|/* get trailing 4 bits */
name|ucs4
operator|=
operator|*
name|src
operator|&
literal|0x0f
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|src
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
comment|/* 		 * leading 5 bits are "11110" 		 *  utf-8: 11110www 10xxxxxx 10yyyyyy 10zzzzzz 		 *  ucs-4: 00000000 000wwwxx xxxxyyyy yyzzzzzz 		 */
name|w
operator|=
literal|4
expr_stmt|;
comment|/* get trailing 3 bits */
name|ucs4
operator|=
operator|*
name|src
operator|&
literal|0x07
expr_stmt|;
block|}
else|else
block|{
comment|/* out of utf-16 range or having illegal bits */
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|srclen
operator|<
name|w
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * get left parts from utf-8 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|w
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|src
operator|+
name|i
operator|)
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
comment|/* invalid: leading 2 bits are not "10" */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* concatenate trailing 6 bits into ucs4 */
name|ucs4
operator|<<=
literal|6
expr_stmt|;
name|ucs4
operator||=
operator|*
operator|(
name|src
operator|+
name|i
operator|)
operator|&
literal|0x3f
expr_stmt|;
block|}
operator|*
name|utf8width
operator|=
name|w
expr_stmt|;
return|return
operator|(
name|ucs4
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_char
modifier|*
name|ucs4_to_utf8
parameter_list|(
name|uint32_t
name|ucs4
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
name|size_t
modifier|*
name|utf8width
parameter_list|,
name|size_t
name|dstlen
parameter_list|)
block|{
name|u_char
name|lead
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|w
decl_stmt|;
comment|/* 	 * determine utf-8 width and leading bits 	 */
if|if
condition|(
name|ucs4
operator|<
literal|0x80
condition|)
block|{
name|w
operator|=
literal|1
expr_stmt|;
name|lead
operator|=
literal|0
expr_stmt|;
comment|/* "0" */
block|}
elseif|else
if|if
condition|(
name|ucs4
operator|<
literal|0x800
condition|)
block|{
name|w
operator|=
literal|2
expr_stmt|;
name|lead
operator|=
literal|0xc0
expr_stmt|;
comment|/* "11" */
block|}
elseif|else
if|if
condition|(
name|ucs4
operator|<
literal|0x10000
condition|)
block|{
name|w
operator|=
literal|3
expr_stmt|;
name|lead
operator|=
literal|0xe0
expr_stmt|;
comment|/* "111" */
block|}
elseif|else
if|if
condition|(
name|ucs4
operator|<
literal|0x200000
condition|)
block|{
name|w
operator|=
literal|4
expr_stmt|;
name|lead
operator|=
literal|0xf0
expr_stmt|;
comment|/* "1111" */
block|}
else|else
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|dstlen
operator|<
name|w
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * construct utf-8 	 */
name|p
operator|=
name|dst
expr_stmt|;
for|for
control|(
name|i
operator|=
name|w
operator|-
literal|1
init|;
name|i
operator|>=
literal|1
condition|;
name|i
operator|--
control|)
block|{
comment|/* get trailing 6 bits and put it with leading bit as "1" */
operator|*
operator|(
name|p
operator|+
name|i
operator|)
operator|=
operator|(
name|ucs4
operator|&
literal|0x3f
operator|)
operator||
literal|0x80
expr_stmt|;
name|ucs4
operator|>>=
literal|6
expr_stmt|;
block|}
operator|*
name|p
operator|=
name|ucs4
operator||
name|lead
expr_stmt|;
operator|*
name|utf8width
operator|=
name|w
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|encode_surrogate
parameter_list|(
specifier|register
name|uint32_t
name|code
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|code
operator|-
literal|0x10000
operator|)
operator|<<
literal|6
operator|)
operator|&
literal|0x3ff0000
operator|)
operator||
operator|(
operator|(
name|code
operator|-
literal|0x10000
operator|)
operator|&
literal|0x3ff
operator|)
operator||
literal|0xd800dc00
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|decode_surrogate
parameter_list|(
specifier|register
specifier|const
name|u_char
modifier|*
name|ucs
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
operator|(
name|ucs
index|[
literal|0
index|]
operator|&
literal|0x3
operator|)
operator|<<
literal|18
operator|)
operator||
operator|(
name|ucs
index|[
literal|1
index|]
operator|<<
literal|10
operator|)
operator||
operator|(
operator|(
name|ucs
index|[
literal|2
index|]
operator|&
literal|0x3
operator|)
operator|<<
literal|8
operator|)
operator||
name|ucs
index|[
literal|3
index|]
operator|)
operator|+
literal|0x10000
operator|)
return|;
block|}
end_function

end_unit

