begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000-2001, Boris Popov  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *    This product includes software developed by Boris Popov.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/iconv.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|"iconv_converter_if.h"
end_include

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_kern_iconv
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|iconv
argument_list|,
name|CTLFLAG_RW
argument_list|,
name|NULL
argument_list|,
literal|"kernel iconv interface"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ICONV
argument_list|,
literal|"iconv"
argument_list|,
literal|"ICONV structures"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_ICONVDATA
argument_list|,
literal|"iconv_data"
argument_list|,
literal|"ICONV data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|libiconv
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|sx
name|iconv_lock
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notnow
end_ifdef

begin_comment
comment|/*  * iconv converter instance  */
end_comment

begin_struct
struct|struct
name|iconv_converter
block|{
name|KOBJ_FIELDS
expr_stmt|;
name|void
modifier|*
name|c_data
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|sysctl_oid
modifier|*
name|iconv_oid_hook
init|=
operator|&
name|sysctl___kern_iconv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of loaded converters  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument|iconv_converter_list
argument_list|,
argument|iconv_converter_class
argument_list|)
name|iconv_converters
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|iconv_converters
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * List of supported/loaded charsets pairs  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|iconv_cspair
argument_list|)
name|iconv_cslist
operator|=
name|TAILQ_HEAD_INITIALIZER
argument_list|(
name|iconv_cslist
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|iconv_csid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|iconv_unicode_string
index|[]
init|=
literal|"unicode"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* save eight bytes when possible */
end_comment

begin_function_decl
specifier|static
name|void
name|iconv_unregister_cspair
parameter_list|(
name|struct
name|iconv_cspair
modifier|*
name|csp
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|iconv_mod_unload
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|;
name|sx_xlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|csp
argument_list|,
argument|&iconv_cslist
argument_list|,
argument|cp_link
argument_list|)
block|{
if|if
condition|(
name|csp
operator|->
name|cp_refcount
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
block|}
while|while
condition|(
operator|(
name|csp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|iconv_cslist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|iconv_unregister_cspair
argument_list|(
name|csp
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|sx_destroy
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_mod_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|error
operator|=
literal|0
expr_stmt|;
name|sx_init
argument_list|(
operator|&
name|iconv_lock
argument_list|,
literal|"iconv"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|error
operator|=
name|iconv_mod_unload
argument_list|()
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|iconv_mod
init|=
block|{
literal|"iconv"
block|,
name|iconv_mod_handler
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|iconv
argument_list|,
name|iconv_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_SECOND
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|iconv_register_converter
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|)
block|{
name|kobj_class_compile
argument_list|(
operator|(
expr|struct
name|kobj_class
operator|*
operator|)
name|dcp
argument_list|)
expr_stmt|;
name|dcp
operator|->
name|refs
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iconv_converters
argument_list|,
name|dcp
argument_list|,
name|cc_link
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_unregister_converter
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|)
block|{
if|if
condition|(
name|dcp
operator|->
name|refs
operator|>
literal|1
condition|)
block|{
name|ICDEBUG
argument_list|(
literal|"converter have %d referenses left\n"
argument_list|,
name|dcp
operator|->
name|refs
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|iconv_converters
argument_list|,
name|dcp
argument_list|,
name|cc_link
argument_list|)
expr_stmt|;
name|kobj_class_free
argument_list|(
operator|(
expr|struct
name|kobj_class
operator|*
operator|)
name|dcp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_lookupconv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|iconv_converter_class
modifier|*
modifier|*
name|dcpp
parameter_list|)
block|{
name|struct
name|iconv_converter_class
modifier|*
name|dcp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dcp
argument_list|,
argument|&iconv_converters
argument_list|,
argument|cc_link
argument_list|)
block|{
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|ICONV_CONVERTER_NAME
argument_list|(
name|dcp
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dcpp
condition|)
operator|*
name|dcpp
operator|=
name|dcp
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_lookupcs
parameter_list|(
specifier|const
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|struct
name|iconv_cspair
modifier|*
modifier|*
name|cspp
parameter_list|)
block|{
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|csp
argument_list|,
argument|&iconv_cslist
argument_list|,
argument|cp_link
argument_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|csp
operator|->
name|cp_to
argument_list|,
name|to
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|csp
operator|->
name|cp_from
argument_list|,
name|from
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cspp
condition|)
operator|*
name|cspp
operator|=
name|csp
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|iconv_register_cspair
parameter_list|(
specifier|const
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|struct
name|iconv_converter_class
modifier|*
name|dcp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|struct
name|iconv_cspair
modifier|*
modifier|*
name|cspp
parameter_list|)
block|{
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|csize
decl_stmt|,
name|ucsto
decl_stmt|,
name|ucsfrom
decl_stmt|;
if|if
condition|(
name|iconv_lookupcs
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EEXIST
return|;
name|csize
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|csp
argument_list|)
expr_stmt|;
name|ucsto
operator|=
name|strcmp
argument_list|(
name|to
argument_list|,
name|iconv_unicode_string
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ucsto
condition|)
name|csize
operator|+=
name|strlen
argument_list|(
name|to
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ucsfrom
operator|=
name|strcmp
argument_list|(
name|from
argument_list|,
name|iconv_unicode_string
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ucsfrom
condition|)
name|csize
operator|+=
name|strlen
argument_list|(
name|from
argument_list|)
operator|+
literal|1
expr_stmt|;
name|csp
operator|=
name|malloc
argument_list|(
name|csize
argument_list|,
name|M_ICONV
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|csp
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|csp
operator|->
name|cp_id
operator|=
name|iconv_csid
operator|++
expr_stmt|;
name|csp
operator|->
name|cp_dcp
operator|=
name|dcp
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|csp
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ucsto
condition|)
block|{
name|strcpy
argument_list|(
name|cp
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|csp
operator|->
name|cp_to
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|csp
operator|->
name|cp_to
operator|=
name|iconv_unicode_string
expr_stmt|;
if|if
condition|(
operator|!
name|ucsfrom
condition|)
block|{
name|strcpy
argument_list|(
name|cp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|csp
operator|->
name|cp_from
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|csp
operator|->
name|cp_from
operator|=
name|iconv_unicode_string
expr_stmt|;
name|csp
operator|->
name|cp_data
operator|=
name|data
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|iconv_cslist
argument_list|,
name|csp
argument_list|,
name|cp_link
argument_list|)
expr_stmt|;
operator|*
name|cspp
operator|=
name|csp
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|iconv_unregister_cspair
parameter_list|(
name|struct
name|iconv_cspair
modifier|*
name|csp
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|iconv_cslist
argument_list|,
name|csp
argument_list|,
name|cp_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|csp
operator|->
name|cp_data
condition|)
name|free
argument_list|(
name|csp
operator|->
name|cp_data
argument_list|,
name|M_ICONVDATA
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|csp
argument_list|,
name|M_ICONV
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup and create an instance of converter.  * Currently this layer didn't have associated 'instance' structure  * to avoid unnesessary memory allocation.  */
end_comment

begin_function
name|int
name|iconv_open
parameter_list|(
specifier|const
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|,
name|void
modifier|*
modifier|*
name|handle
parameter_list|)
block|{
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|,
modifier|*
name|cspfrom
decl_stmt|,
modifier|*
name|cspto
decl_stmt|;
name|struct
name|iconv_converter_class
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|cnvname
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * First, lookup fully qualified cspairs 	 */
name|error
operator|=
name|iconv_lookupcs
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
operator|&
name|csp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
name|ICONV_CONVERTER_OPEN
argument_list|(
name|csp
operator|->
name|cp_dcp
argument_list|,
name|csp
argument_list|,
name|NULL
argument_list|,
name|handle
argument_list|)
return|;
comment|/* 	 * Well, nothing found. Now try to construct a composite conversion 	 * ToDo: add a 'capability' field to converter 	 */
name|TAILQ_FOREACH
argument_list|(
argument|dcp
argument_list|,
argument|&iconv_converters
argument_list|,
argument|cc_link
argument_list|)
block|{
name|cnvname
operator|=
name|ICONV_CONVERTER_NAME
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnvname
operator|==
name|NULL
condition|)
continue|continue;
name|error
operator|=
name|iconv_lookupcs
argument_list|(
name|cnvname
argument_list|,
name|from
argument_list|,
operator|&
name|cspfrom
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
name|error
operator|=
name|iconv_lookupcs
argument_list|(
name|to
argument_list|,
name|cnvname
argument_list|,
operator|&
name|cspto
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
continue|continue;
comment|/* 		 * Fine, we're found a pair which can be combined together 		 */
return|return
name|ICONV_CONVERTER_OPEN
argument_list|(
name|dcp
argument_list|,
name|cspto
argument_list|,
name|cspfrom
argument_list|,
name|handle
argument_list|)
return|;
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
name|int
name|iconv_close
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_CLOSE
argument_list|(
name|handle
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iconv_conv
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|inbuf
parameter_list|,
name|size_t
modifier|*
name|inbytesleft
parameter_list|,
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|size_t
modifier|*
name|outbytesleft
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_CONV
argument_list|(
name|handle
argument_list|,
name|inbuf
argument_list|,
name|inbytesleft
argument_list|,
name|outbuf
argument_list|,
name|outbytesleft
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iconv_conv_case
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|inbuf
parameter_list|,
name|size_t
modifier|*
name|inbytesleft
parameter_list|,
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|size_t
modifier|*
name|outbytesleft
parameter_list|,
name|int
name|casetype
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_CONV
argument_list|(
name|handle
argument_list|,
name|inbuf
argument_list|,
name|inbytesleft
argument_list|,
name|outbuf
argument_list|,
name|outbytesleft
argument_list|,
literal|0
argument_list|,
name|casetype
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iconv_convchr
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|inbuf
parameter_list|,
name|size_t
modifier|*
name|inbytesleft
parameter_list|,
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|size_t
modifier|*
name|outbytesleft
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_CONV
argument_list|(
name|handle
argument_list|,
name|inbuf
argument_list|,
name|inbytesleft
argument_list|,
name|outbuf
argument_list|,
name|outbytesleft
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|iconv_convchr_case
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|inbuf
parameter_list|,
name|size_t
modifier|*
name|inbytesleft
parameter_list|,
name|char
modifier|*
modifier|*
name|outbuf
parameter_list|,
name|size_t
modifier|*
name|outbytesleft
parameter_list|,
name|int
name|casetype
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_CONV
argument_list|(
name|handle
argument_list|,
name|inbuf
argument_list|,
name|inbytesleft
argument_list|,
name|outbuf
argument_list|,
name|outbytesleft
argument_list|,
literal|1
argument_list|,
name|casetype
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|towlower
parameter_list|(
name|int
name|c
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_TOLOWER
argument_list|(
name|handle
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|towupper
parameter_list|(
name|int
name|c
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
return|return
name|ICONV_CONVERTER_TOUPPER
argument_list|(
name|handle
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Give a list of loaded converters. Each name terminated with 0.  * An empty string terminates the list.  */
end_comment

begin_function
specifier|static
name|int
name|iconv_sysctl_drvlist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|iconv_converter_class
modifier|*
name|dcp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|spc
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|dcp
argument_list|,
argument|&iconv_converters
argument_list|,
argument|cc_link
argument_list|)
block|{
name|name
operator|=
name|ICONV_CONVERTER_NAME
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
continue|continue;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|spc
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|spc
argument_list|,
sizeof|sizeof
argument_list|(
name|spc
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_iconv
argument_list|,
name|OID_AUTO
argument_list|,
name|drvlist
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|iconv_sysctl_drvlist
argument_list|,
literal|"S,xlat"
argument_list|,
literal|"registered converters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * List all available charset pairs.  */
end_comment

begin_function
specifier|static
name|int
name|iconv_sysctl_cslist
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|;
name|struct
name|iconv_cspair_info
name|csi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|csi
argument_list|,
sizeof|sizeof
argument_list|(
name|csi
argument_list|)
argument_list|)
expr_stmt|;
name|csi
operator|.
name|cs_version
operator|=
name|ICONV_CSPAIR_INFO_VER
expr_stmt|;
name|sx_slock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|csp
argument_list|,
argument|&iconv_cslist
argument_list|,
argument|cp_link
argument_list|)
block|{
name|csi
operator|.
name|cs_id
operator|=
name|csp
operator|->
name|cp_id
expr_stmt|;
name|csi
operator|.
name|cs_refcount
operator|=
name|csp
operator|->
name|cp_refcount
expr_stmt|;
name|csi
operator|.
name|cs_base
operator|=
name|csp
operator|->
name|cp_base
condition|?
name|csp
operator|->
name|cp_base
operator|->
name|cp_id
else|:
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|csi
operator|.
name|cs_to
argument_list|,
name|csp
operator|->
name|cp_to
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|csi
operator|.
name|cs_from
argument_list|,
name|csp
operator|->
name|cp_from
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|csi
argument_list|,
sizeof|sizeof
argument_list|(
name|csi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|sx_sunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_iconv
argument_list|,
name|OID_AUTO
argument_list|,
name|cslist
argument_list|,
name|CTLFLAG_RD
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|iconv_sysctl_cslist
argument_list|,
literal|"S,xlat"
argument_list|,
literal|"registered charset pairs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|iconv_add
parameter_list|(
specifier|const
name|char
modifier|*
name|converter
parameter_list|,
specifier|const
name|char
modifier|*
name|to
parameter_list|,
specifier|const
name|char
modifier|*
name|from
parameter_list|)
block|{
name|struct
name|iconv_converter_class
modifier|*
name|dcp
decl_stmt|;
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|;
if|if
condition|(
name|iconv_lookupconv
argument_list|(
name|converter
argument_list|,
operator|&
name|dcp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
return|return
name|iconv_register_cspair
argument_list|(
name|to
argument_list|,
name|from
argument_list|,
name|dcp
argument_list|,
name|NULL
argument_list|,
operator|&
name|csp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add new charset pair  */
end_comment

begin_function
specifier|static
name|int
name|iconv_sysctl_add
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|iconv_converter_class
modifier|*
name|dcp
decl_stmt|;
name|struct
name|iconv_cspair
modifier|*
name|csp
decl_stmt|;
name|struct
name|iconv_add_in
name|din
decl_stmt|;
name|struct
name|iconv_add_out
name|dout
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|SYSCTL_IN
argument_list|(
name|req
argument_list|,
operator|&
name|din
argument_list|,
sizeof|sizeof
argument_list|(
name|din
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
if|if
condition|(
name|din
operator|.
name|ia_version
operator|!=
name|ICONV_ADD_VER
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|din
operator|.
name|ia_datalen
operator|>
name|ICONV_CSMAXDATALEN
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|strlen
argument_list|(
name|din
operator|.
name|ia_from
argument_list|)
operator|>=
name|ICONV_CSNMAXLEN
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|strlen
argument_list|(
name|din
operator|.
name|ia_to
argument_list|)
operator|>=
name|ICONV_CSNMAXLEN
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|strlen
argument_list|(
name|din
operator|.
name|ia_converter
argument_list|)
operator|>=
name|ICONV_CNVNMAXLEN
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|iconv_lookupconv
argument_list|(
name|din
operator|.
name|ia_converter
argument_list|,
operator|&
name|dcp
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|EINVAL
return|;
name|sx_xlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|iconv_register_cspair
argument_list|(
name|din
operator|.
name|ia_to
argument_list|,
name|din
operator|.
name|ia_from
argument_list|,
name|dcp
argument_list|,
name|NULL
argument_list|,
operator|&
name|csp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
if|if
condition|(
name|din
operator|.
name|ia_datalen
condition|)
block|{
name|csp
operator|->
name|cp_data
operator|=
name|malloc
argument_list|(
name|din
operator|.
name|ia_datalen
argument_list|,
name|M_ICONVDATA
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|din
operator|.
name|ia_data
argument_list|,
name|csp
operator|->
name|cp_data
argument_list|,
name|din
operator|.
name|ia_datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
block|}
name|dout
operator|.
name|ia_csid
operator|=
name|csp
operator|->
name|cp_id
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|dout
argument_list|,
sizeof|sizeof
argument_list|(
name|dout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|ICDEBUG
argument_list|(
literal|"%s => %s, %d bytes\n"
argument_list|,
name|din
operator|.
name|ia_from
argument_list|,
name|din
operator|.
name|ia_to
argument_list|,
name|din
operator|.
name|ia_datalen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|iconv_unregister_cspair
argument_list|(
name|csp
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_iconv
argument_list|,
name|OID_AUTO
argument_list|,
name|add
argument_list|,
name|CTLFLAG_RW
operator||
name|CTLTYPE_OPAQUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|iconv_sysctl_add
argument_list|,
literal|"S,xlat"
argument_list|,
literal|"register charset pair"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Default stubs for converters  */
end_comment

begin_function
name|int
name|iconv_converter_initstub
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dp
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iconv_converter_donestub
parameter_list|(
name|struct
name|iconv_converter_class
modifier|*
name|dp
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|iconv_converter_tolowerstub
parameter_list|(
name|int
name|c
parameter_list|,
name|void
modifier|*
name|handle
parameter_list|)
block|{
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|int
name|iconv_converter_handler
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|iconv_converter_class
modifier|*
name|dcp
init|=
name|data
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|sx_xlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|iconv_register_converter
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|ICONV_CONVERTER_INIT
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|iconv_unregister_converter
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|sx_xlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
name|ICONV_CONVERTER_DONE
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
name|error
operator|=
name|iconv_unregister_converter
argument_list|(
name|dcp
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|iconv_lock
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Common used functions (don't use with unicode)  */
end_comment

begin_function
name|char
modifier|*
name|iconv_convstr
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|dst
decl_stmt|;
name|size_t
name|inlen
decl_stmt|,
name|outlen
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
block|}
name|inlen
operator|=
name|outlen
operator|=
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
name|error
operator|=
name|iconv_conv
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|NULL
return|;
name|error
operator|=
name|iconv_conv
argument_list|(
name|handle
argument_list|,
operator|&
name|src
argument_list|,
operator|&
name|inlen
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|NULL
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
name|dst
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|iconv_convmem
parameter_list|(
name|void
modifier|*
name|handle
parameter_list|,
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|int
name|size
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|src
decl_stmt|;
name|char
modifier|*
name|d
init|=
name|dst
decl_stmt|;
name|size_t
name|inlen
decl_stmt|,
name|outlen
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return
name|dst
return|;
if|if
condition|(
name|handle
operator|==
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|dst
return|;
block|}
name|inlen
operator|=
name|outlen
operator|=
name|size
expr_stmt|;
name|error
operator|=
name|iconv_conv
argument_list|(
name|handle
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|NULL
return|;
name|error
operator|=
name|iconv_conv
argument_list|(
name|handle
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|inlen
argument_list|,
operator|&
name|d
argument_list|,
operator|&
name|outlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|NULL
return|;
return|return
name|dst
return|;
block|}
end_function

begin_function
name|int
name|iconv_lookupcp
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|cpp
operator|==
name|NULL
condition|)
block|{
name|ICDEBUG
argument_list|(
literal|"warning a NULL list passed\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* XXX ISO variadic								macros cannot 								leave out the 								variadic args */
return|return
name|ENOENT
return|;
block|}
for|for
control|(
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|cpp
argument_list|,
name|s
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|ENOENT
return|;
block|}
end_function

begin_comment
comment|/*  * Return if fsname is in use of not  */
end_comment

begin_function
name|int
name|iconv_vfs_refcount
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|)
block|{
name|struct
name|vfsconf
modifier|*
name|vfsp
decl_stmt|;
name|vfsp
operator|=
name|vfs_byname
argument_list|(
name|fsname
argument_list|)
expr_stmt|;
if|if
condition|(
name|vfsp
operator|!=
name|NULL
operator|&&
name|vfsp
operator|->
name|vfc_refcount
operator|>
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

