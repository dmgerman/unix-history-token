begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@dialix.oz.au)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * Ported to run under 386BSD by Julian Elischer (julian@dialix.oz.au) Sept 1992  *  *      $Id: sd.c,v 1.113 1997/11/07 08:53:32 phk Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_bounce.h"
end_include

begin_include
include|#
directive|include
file|"opt_scsi.h"
end_include

begin_define
define|#
directive|define
name|SPLSD
value|splbio
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_driver.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_prot.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<i386/i386/cons.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_comment
comment|/* for aborting dump */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<pc98/pc98/pc98_machdep.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int32_t
name|sdstrats
decl_stmt|,
name|sdqueues
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SECSIZE
value|512
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_define
define|#
directive|define
name|SDOUTSTANDING
value|2
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SDOUTSTANDING
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SD_RETRIES
value|4
end_define

begin_define
define|#
directive|define
name|MAXTRANSFER
value|8
end_define

begin_comment
comment|/* 1 page at a time */
end_comment

begin_define
define|#
directive|define
name|PARTITION
parameter_list|(
name|dev
parameter_list|)
value|dkpart(dev)
end_define

begin_define
define|#
directive|define
name|SDUNIT
parameter_list|(
name|dev
parameter_list|)
value|dkunit(dev)
end_define

begin_comment
comment|/* XXX introduce a dkmodunit() macro for this. */
end_comment

begin_define
define|#
directive|define
name|SDSETUNIT
parameter_list|(
name|DEV
parameter_list|,
name|U
parameter_list|)
define|\
value|makedev(major(DEV), dkmakeminor((U), dkslice(DEV), dkpart(DEV)))
end_define

begin_decl_stmt
specifier|static
name|errval
name|sd_get_parms
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static errval	sd_reassign_blocks __P((int unit, int block));
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int32_t
name|sd_size
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sdstrategy1
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sd_sense_handler
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|sdstart
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|scsi_data
block|{
name|u_int32_t
name|flags
decl_stmt|;
define|#
directive|define
name|SDINIT
value|0x04
comment|/* device has been init'd */
struct|struct
name|disk_parms
block|{
name|u_char
name|heads
decl_stmt|;
comment|/* Number of heads */
name|u_int16_t
name|cyls
decl_stmt|;
comment|/* Number of cylinders */
name|u_char
name|sectors
decl_stmt|;
comment|/*dubious */
comment|/* Number of sectors/track */
name|u_int16_t
name|secsiz
decl_stmt|;
comment|/* Number of bytes/sector */
name|u_int32_t
name|disksize
decl_stmt|;
comment|/* total number sectors */
block|}
name|params
struct|;
name|struct
name|diskslices
modifier|*
name|dk_slices
decl_stmt|;
comment|/* virtual drives */
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
name|int
name|dkunit
decl_stmt|;
comment|/* disk stats unit number */
ifdef|#
directive|ifdef
name|DEVFS
name|void
modifier|*
name|b_devfs_token
decl_stmt|;
name|void
modifier|*
name|c_devfs_token
decl_stmt|;
name|void
modifier|*
name|ctl_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|sdunit
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
return|return
name|SDUNIT
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|dev_t
name|sdsetunit
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
return|return
name|SDSETUNIT
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|errval
name|sd_open
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|mode
operator|,
name|int
name|fmt
operator|,
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|scsi_link
operator|*
name|sc_link
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|errval
name|sd_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|errval
name|sd_close
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|fflag
operator|,
name|int
name|fmt
operator|,
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|scsi_link
operator|*
name|sc_link
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|sd_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|sdopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|sdclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|sdioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_dump_t
name|sddump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_psize_t
name|sdsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|sdstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|13
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|4
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|sd_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|sd_bdevsw
init|=
block|{
name|sdopen
block|,
name|sdclose
block|,
name|sdstrategy
block|,
name|sdioctl
block|,
comment|/*4*/
name|sddump
block|,
name|sdsize
block|,
name|D_DISK
block|,
literal|"sd"
block|,
operator|&
name|sd_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|SCSI_DEVICE_ENTRIES
argument_list|(
argument|sd
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|sd_switch
init|=
block|{
name|sd_sense_handler
block|,
name|sdstart
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"sd"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
comment|/* Link flags */
name|sdattach
block|,
literal|"Direct-Access"
block|,
name|sdopen
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_data
argument_list|)
block|,
name|T_DIRECT
block|,
name|sdunit
block|,
name|sdsetunit
block|,
name|sd_open
block|,
name|sd_ioctl
block|,
name|sd_close
block|,
name|sd_strategy
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsi_xfer
name|sx
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|sd_registerdev
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|dk_ndrive
operator|<
name|DK_NDRIVE
condition|)
block|{
name|sprintf
argument_list|(
name|dk_names
index|[
name|dk_ndrive
index|]
argument_list|,
literal|"sd%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dk_wpms
index|[
name|dk_ndrive
index|]
operator|=
operator|(
literal|8
operator|*
literal|1024
operator|*
literal|1024
operator|/
literal|2
operator|)
expr_stmt|;
name|SCSI_DATA
argument_list|(
operator|&
name|sd_switch
argument_list|,
name|unit
argument_list|)
operator|->
name|dkunit
operator|=
name|dk_ndrive
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SCSI_DATA
argument_list|(
operator|&
name|sd_switch
argument_list|,
name|unit
argument_list|)
operator|->
name|dkunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The routine called by the low level scsi routine when it discovers  * a device suitable for this driver.  */
end_comment

begin_function
specifier|static
name|errval
name|sdattach
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|disk_parms
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|mynor
decl_stmt|;
endif|#
directive|endif
name|struct
name|scsi_data
modifier|*
name|sd
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|unit
operator|=
name|sc_link
operator|->
name|dev_unit
expr_stmt|;
name|dp
operator|=
operator|&
operator|(
name|sd
operator|->
name|params
operator|)
expr_stmt|;
if|if
condition|(
name|sc_link
operator|->
name|opennings
operator|>
name|SDOUTSTANDING
condition|)
name|sc_link
operator|->
name|opennings
operator|=
name|SDOUTSTANDING
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|sd
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
comment|/* 	 * In case it is a funny one, tell it to start 	 * not needed for  most hard drives (ignore failure) 	 */
name|scsi_start_unit
argument_list|(
name|sc_link
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
operator||
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
argument_list|)
expr_stmt|;
comment|/* 	 * Use the subdriver to request information regarding 	 * the drive. We cannot use interrupts yet, so the 	 * request must specify this. 	 */
name|sd_get_parms
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
argument_list|)
expr_stmt|;
comment|/* 	 * if we don't have actual parameters, assume 512 bytes/sec 	 * (could happen on removable media - MOD) 	 * -- this avoids the division below from falling over 	 */
if|if
condition|(
name|dp
operator|->
name|secsiz
operator|==
literal|0
condition|)
name|dp
operator|->
name|secsiz
operator|=
name|SECSIZE
expr_stmt|;
name|printf
argument_list|(
literal|"%ldMB (%ld %d byte sectors)"
argument_list|,
name|dp
operator|->
name|disksize
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|dp
operator|->
name|secsiz
operator|)
argument_list|,
name|dp
operator|->
name|disksize
argument_list|,
name|dp
operator|->
name|secsiz
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SCSI_REPORT_GEOMETRY
if|if
condition|(
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_BOOTVERBOSE
operator|)
condition|)
endif|#
directive|endif
block|{
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"with %d cyls, %d heads, and an average %d sectors/track"
argument_list|,
name|dp
operator|->
name|cyls
argument_list|,
name|dp
operator|->
name|heads
argument_list|,
name|dp
operator|->
name|sectors
argument_list|)
expr_stmt|;
block|}
name|sd
operator|->
name|flags
operator||=
name|SDINIT
expr_stmt|;
name|sd_registerdev
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|mynor
operator|=
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|sd
operator|->
name|b_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sd_bdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"sd%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|sd
operator|->
name|c_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sd_cdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rsd%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|mynor
operator|=
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|sd
operator|->
name|ctl_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|sd_cdevsw
argument_list|,
name|mynor
operator||
name|SCSI_CONTROL_MASK
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"rsd%d.ctl"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * open the device. Make sure the partition info is a up-to-date as can be.  */
end_comment

begin_function
specifier|static
name|errval
name|sd_open
parameter_list|(
name|dev
parameter_list|,
name|mode
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|,
name|sc_link
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|errval
name|errcode
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|disklabel
name|label
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
name|unit
operator|=
name|SDUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sd
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* 	 * Make sure the disk has been initialised 	 * At some point in the future, get the scsi driver 	 * to look for a new device if we are not initted 	 */
if|if
condition|(
operator|(
operator|!
name|sd
operator|)
operator|||
operator|(
operator|!
operator|(
name|sd
operator|->
name|flags
operator|&
name|SDINIT
operator|)
operator|)
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"sd_open: dev=0x%lx (unit %ld, partition %d)\n"
operator|,
name|dev
operator|,
name|unit
operator|,
name|PARTITION
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * "unit attention" errors should occur here if the 	 * drive has been restarted or the pack changed. 	 * just ingnore the result, it's a decoy instruction 	 * The error handlers will act on the error though 	 * and invalidate any media information we had. 	 */
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|scsi_device_lock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
return|return
name|errcode
return|;
comment|/* 	 * If it's been invalidated, then forget the label 	 */
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_OPEN
expr_stmt|;
comment|/* unit attn becomes an err now */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
operator|&&
name|sd
operator|->
name|dk_slices
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If somebody still has it open, then forbid re-entry. 		 */
if|if
condition|(
name|dsisopen
argument_list|(
name|sd
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|dsgone
argument_list|(
operator|&
name|sd
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check that it is still responding and ok. 	 */
if|if
condition|(
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"device not reponding\n"
operator|)
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"device ok\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load the physical device parameters 	 */
if|if
condition|(
name|errcode
operator|=
name|sd_get_parms
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* sets SDEV_MEDIA_LOADED */
goto|goto
name|bad
goto|;
switch|switch
condition|(
name|sd
operator|->
name|params
operator|.
name|secsiz
condition|)
block|{
case|case
literal|512
case|:
case|case
literal|1024
case|:
case|case
literal|2048
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"sd%ld: Can't deal with %d bytes logical blocks\n"
argument_list|,
name|unit
argument_list|,
name|sd
operator|->
name|params
operator|.
name|secsiz
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"sd"
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Params loaded "
operator|)
argument_list|)
expr_stmt|;
comment|/* Lock the pack in. */
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_PREVENT
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
comment|/* Build label for whole disk. */
name|bzero
argument_list|(
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_secsize
operator|=
name|sd
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
name|label
operator|.
name|d_nsectors
operator|=
name|sd
operator|->
name|params
operator|.
name|sectors
expr_stmt|;
name|label
operator|.
name|d_ntracks
operator|=
name|sd
operator|->
name|params
operator|.
name|heads
expr_stmt|;
name|label
operator|.
name|d_ncylinders
operator|=
name|sd
operator|->
name|params
operator|.
name|cyls
expr_stmt|;
name|label
operator|.
name|d_secpercyl
operator|=
name|sd
operator|->
name|params
operator|.
name|heads
operator|*
name|sd
operator|->
name|params
operator|.
name|sectors
expr_stmt|;
if|if
condition|(
name|label
operator|.
name|d_secpercyl
operator|==
literal|0
condition|)
name|label
operator|.
name|d_secpercyl
operator|=
literal|100
expr_stmt|;
comment|/* XXX as long as it's not 0 - readdisklabel divides by it (?) */
name|label
operator|.
name|d_secperunit
operator|=
name|sd
operator|->
name|params
operator|.
name|disksize
expr_stmt|;
comment|/* Initialize slice tables. */
name|errcode
operator|=
name|dsopen
argument_list|(
literal|"sd"
argument_list|,
name|dev
argument_list|,
name|fmt
argument_list|,
operator|&
name|sd
operator|->
name|dk_slices
argument_list|,
operator|&
name|label
argument_list|,
name|sdstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|sd_bdevsw
argument_list|,
operator|&
name|sd_cdevsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Slice tables initialized "
operator|)
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"open %ld %ld\n"
operator|,
name|sdstrats
operator|,
name|sdqueues
operator|)
argument_list|)
expr_stmt|;
name|scsi_device_unlock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|sd
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_OPEN
expr_stmt|;
block|}
name|scsi_device_unlock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
return|return
name|errcode
return|;
block|}
end_function

begin_comment
comment|/*  * close the device.. only called if we are the LAST occurence of an open  * device.  Convenient now but usually a pain.  */
end_comment

begin_function
specifier|static
name|errval
name|sd_close
parameter_list|(
name|dev
parameter_list|,
name|fflag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|,
name|sc_link
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|fflag
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
name|errval
name|errcode
decl_stmt|;
name|sd
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
name|errcode
operator|=
name|scsi_device_lock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
condition|)
return|return
name|errcode
return|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|sd
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|sd
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
operator||
name|SCSI_ERR_OK
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_OPEN
expr_stmt|;
block|}
name|scsi_device_unlock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|sd_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|opri
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
name|u_int32_t
name|unit
decl_stmt|,
name|secsize
decl_stmt|;
name|sdstrats
operator|++
expr_stmt|;
name|unit
operator|=
name|SDUNIT
argument_list|(
operator|(
name|bp
operator|->
name|b_dev
operator|)
argument_list|)
expr_stmt|;
name|sd
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* 	 * If the device has been made invalid, error out 	 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * check it's not too big a transfer for our adapter 	 */
name|scsi_minphys
argument_list|(
name|bp
argument_list|,
operator|&
name|sd_switch
argument_list|)
expr_stmt|;
comment|/* 	 * Odd number of bytes or negative offset 	 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"sd_strategy: Negative block number: 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|secsize
operator|=
name|sd
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
comment|/* make sure the blkno is scalable */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_blkno
operator|%
operator|(
name|secsize
operator|/
name|DEV_BSIZE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"sd_strategy: Block number is not multiple of sector size (2): 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* make sure that the transfer size is a multiple of the sector size */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|secsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"sd_strategy: Invalid b_bcount %d at block number: 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Do bounds checking, adjust transfer, set b_cylin and b_pbklno. 	 */
block|{
name|int
name|status
decl_stmt|;
name|int
name|sec_blk_ratio
init|=
name|secsize
operator|/
name|DEV_BSIZE
decl_stmt|;
name|int
name|b_blkno
init|=
name|bp
operator|->
name|b_blkno
decl_stmt|;
comment|/* Replace blkno and count with scaled values. */
name|bp
operator|->
name|b_blkno
operator|/=
name|sec_blk_ratio
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|/=
name|sec_blk_ratio
expr_stmt|;
comment|/* enforce limits and map to physical block number */
name|status
operator|=
name|dscheck
argument_list|(
name|bp
argument_list|,
name|sd
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
comment|/* 		 * Restore blkno and unscale the values set by dscheck(), 		 * except for b_pblkno. 		 */
name|bp
operator|->
name|b_blkno
operator|=
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|*=
name|sec_blk_ratio
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|*=
name|sec_blk_ratio
expr_stmt|;
comment|/* see if the mapping failed */
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* XXX check b_resid */
block|}
name|opri
operator|=
name|SPLSD
argument_list|()
expr_stmt|;
comment|/* 	 * Use a bounce buffer if necessary 	 */
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_BOUNCE
condition|)
name|vm_bounce_alloc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Place it in the queue of disk activities for this disk 	 */
ifdef|#
directive|ifdef
name|SDDISKSORT
name|bufq_disksort
argument_list|(
operator|&
name|sd
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|#
directive|else
name|bufq_insert_tail
argument_list|(
operator|&
name|sd
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Tell the device to get going on the transfer if it's 	 * not doing anything, otherwise just wait for completion 	 */
name|sdstart
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
comment|/*0*/
return|;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
comment|/*0*/
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sdstrategy1
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * XXX - do something to make sdstrategy() but not this block while 	 * we're doing dsinit() and dsioctl(). 	 */
name|sdstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sdstart looks to see if there is a buf waiting for the device  * and that the device is not already busy. If both are true,  * It dequeues the buf and creates a scsi command to perform the  * transfer in the buf. The transfer request will call scsi_done  * on completion, which will in turn call this routine again  * so that the next queued transfer is performed.  * The bufs are queued by the strategy routine (sdstrategy)  *  * This routine is also called after other non-queued requests  * have been made of the scsi driver, to ensure that the queue  * continues to be drained.  *  * must be called at the correct (highish) spl level  * sdstart() is called at SPLSD  from sdstrategy and scsi_done  */
end_comment

begin_function
specifier|static
name|void
name|sdstart
parameter_list|(
name|u_int32_t
name|unit
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
specifier|register
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|sd_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|scsi_data
modifier|*
name|sd
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_rw_big
name|cmd
decl_stmt|;
name|u_int32_t
name|blkno
decl_stmt|,
name|nblk
decl_stmt|,
name|secsize
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"sdstart "
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device has room for another command 	 */
while|while
condition|(
name|sc_link
operator|->
name|opennings
condition|)
block|{
comment|/* 		 * there is excess capacity, but a special waits 		 * It'll need the adapter as soon as we clear out of the 		 * way and let it run (user level wait). 		 */
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_WAITING
condition|)
block|{
return|return;
block|}
comment|/* 		 * See if there is a buf with work for us to do.. 		 */
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|sd
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* yes, an assign */
return|return;
block|}
name|bufq_remove
argument_list|(
operator|&
name|sd
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 *  If the device has become invalid, abort all the 		 * reads and writes until all files have been closed and 		 * re-openned 		 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * We have a buf, now we know we are going to go through 		 * With this thing.. 		 */
name|secsize
operator|=
name|sd
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
name|blkno
operator|=
name|bp
operator|->
name|b_pblkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|&
operator|(
name|secsize
operator|-
literal|1
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|nblk
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|secsize
expr_stmt|;
comment|/* 		 *  Fill out the scsi command 		 */
name|cmd
operator|.
name|op_code
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|READ_BIG
else|:
name|WRITE_BIG
expr_stmt|;
name|cmd
operator|.
name|addr_3
operator|=
operator|(
name|blkno
operator|&
literal|0xff000000UL
operator|)
operator|>>
literal|24
expr_stmt|;
name|cmd
operator|.
name|addr_2
operator|=
operator|(
name|blkno
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|cmd
operator|.
name|addr_1
operator|=
operator|(
name|blkno
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cmd
operator|.
name|addr_0
operator|=
name|blkno
operator|&
literal|0xff
expr_stmt|;
name|cmd
operator|.
name|length2
operator|=
operator|(
name|nblk
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cmd
operator|.
name|length1
operator|=
operator|(
name|nblk
operator|&
literal|0xff
operator|)
expr_stmt|;
name|cmd
operator|.
name|byte2
operator|=
name|cmd
operator|.
name|reserved
operator|=
name|cmd
operator|.
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Call the routine that chats with the adapter. 		 * Note: we cannot sleep as we may be an interrupt 		 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|SD_RETRIES
argument_list|,
literal|10000
argument_list|,
name|bp
argument_list|,
name|flags
operator||
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|SCSI_DATA_IN
else|:
name|SCSI_DATA_OUT
operator|)
argument_list|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
name|sdqueues
operator|++
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_xfer
index|[
name|sd
operator|->
name|dkunit
index|]
operator|++
expr_stmt|;
name|dk_seek
index|[
name|sd
operator|->
name|dkunit
index|]
operator|++
expr_stmt|;
comment|/* don't know */
name|dk_wds
index|[
name|sd
operator|->
name|dkunit
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
block|}
else|else
block|{
name|bad
label|:
name|printf
argument_list|(
literal|"sd%ld: oops not queued\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Perform special action on behalf of the user  * Knows about the internals of this device  */
end_comment

begin_function
specifier|static
name|errval
name|sd_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
comment|/* struct sd_cmd_buf *args; */
name|errval
name|error
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
comment|/* 	 * Find the device that the user is talking about 	 */
name|sd
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"sdioctl (0x%x)"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Wait until we have exclusive access to the device. */
comment|/* XXX this is how wd does it.  How did we work without this? */
block|wdsleep(du->dk_ctrlr, "wdioct");
endif|#
directive|endif
comment|/* 	 * If the device is not valid.. abandon ship 	 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|DIOCSBAD
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* XXX */
name|error
operator|=
name|scsi_device_lock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|error
operator|=
name|dsioctl
argument_list|(
literal|"sd"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
operator|&
name|sd
operator|->
name|dk_slices
argument_list|,
name|sdstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|scsi_device_unlock
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|PARTITION
argument_list|(
name|dev
argument_list|)
operator|!=
name|RAW_PART
condition|)
return|return
operator|(
name|ENOTTY
operator|)
return|;
return|return
operator|(
name|scsi_do_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|p
argument_list|,
name|sc_link
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find out from the device what it's capacity is  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|sd_size
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_read_cap_data
name|rdcap
decl_stmt|;
name|struct
name|scsi_read_capacity
name|scsi_cmd
decl_stmt|;
name|u_int32_t
name|size
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|sd_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
comment|/* 	 * make up a scsi command and ask the scsi driver to do 	 * it for you. 	 */
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_CAPACITY
expr_stmt|;
comment|/* 	 * If the command works, interpret the result as a 4 byte 	 * number of blocks 	 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rdcap
argument_list|,
sizeof|sizeof
argument_list|(
name|rdcap
argument_list|)
argument_list|,
name|SD_RETRIES
argument_list|,
literal|2000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d: could not get size\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|size
operator|=
name|rdcap
operator|.
name|addr_0
operator|+
literal|1
expr_stmt|;
name|size
operator|+=
name|rdcap
operator|.
name|addr_1
operator|<<
literal|8
expr_stmt|;
name|size
operator|+=
name|rdcap
operator|.
name|addr_2
operator|<<
literal|16
expr_stmt|;
name|size
operator|+=
name|rdcap
operator|.
name|addr_3
operator|<<
literal|24
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/*  * Tell the device to map out a defective block  */
end_comment

begin_endif
unit|static errval sd_reassign_blocks(unit, block) 	int	unit, block; { 	struct scsi_reassign_blocks scsi_cmd; 	struct scsi_reassign_blocks_data rbdata; 	struct scsi_link *sc_link = SCSI_LINK(&sd_switch, unit);  	bzero(&scsi_cmd, sizeof(scsi_cmd)); 	bzero(&rbdata, sizeof(rbdata)); 	scsi_cmd.op_code = REASSIGN_BLOCKS;  	rbdata.length_msb = 0; 	rbdata.length_lsb = sizeof(rbdata.defect_descriptor[0]); 	rbdata.defect_descriptor[0].dlbaddr_3 = ((block>> 24)& 0xff); 	rbdata.defect_descriptor[0].dlbaddr_2 = ((block>> 16)& 0xff); 	rbdata.defect_descriptor[0].dlbaddr_1 = ((block>> 8)& 0xff); 	rbdata.defect_descriptor[0].dlbaddr_0 = ((block)& 0xff);  	return (scsi_scsi_cmd(sc_link, 		(struct scsi_generic *)&scsi_cmd, 		sizeof(scsi_cmd), 		(u_char *)& rbdata, 		sizeof(rbdata), 		SD_RETRIES, 		5000, 		NULL, 		SCSI_DATA_OUT)); }
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a##_1)<< 8) + (unsigned)a##_0 )
end_define

begin_comment
comment|/*  * Get the scsi driver to send a full inquiry to the  * device and use the results to fill out the disk  * parameter structure.  */
end_comment

begin_function
specifier|static
name|errval
name|sd_get_parms
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|sd_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|sd
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|disk_parms
modifier|*
name|disk_parms
init|=
operator|&
name|sd
operator|->
name|params
decl_stmt|;
name|struct
name|scsi_mode_sense
name|scsi_cmd
decl_stmt|;
struct|struct
name|scsi_mode_sense_data
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|union
name|disk_pages
name|pages
decl_stmt|;
block|}
name|scsi_sense
struct|;
name|u_int32_t
name|sectors
decl_stmt|;
comment|/* 	 * First check if we have it all loaded 	 */
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
condition|)
return|return
literal|0
return|;
comment|/* 	 * do a "mode sense page 4" 	 */
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|page
operator|=
literal|4
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
literal|0x20
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
name|sd_bios_parms
argument_list|(
name|disk_parms
argument_list|,
name|sc_link
argument_list|)
condition|)
block|{ 	}
elseif|else
endif|#
directive|endif
comment|/* 	 * If the command worked, use the results to fill out 	 * the parameter structure 	 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scsi_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
argument_list|,
name|SD_RETRIES
argument_list|,
literal|4000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"sd%d could not mode sense (4)."
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" Using ficticious geometry\n"
argument_list|)
expr_stmt|;
comment|/* 		 * use adaptec standard ficticious geometry 		 * this depends on which controller (e.g. 1542C is 		 * different. but we have to put SOMETHING here..) 		 */
name|sectors
operator|=
name|sd_size
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|disk_parms
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|disk_parms
operator|->
name|sectors
operator|=
literal|32
expr_stmt|;
name|disk_parms
operator|->
name|cyls
operator|=
name|sectors
operator|/
operator|(
literal|64
operator|*
literal|32
operator|)
expr_stmt|;
name|disk_parms
operator|->
name|secsiz
operator|=
name|SECSIZE
expr_stmt|;
name|disk_parms
operator|->
name|disksize
operator|=
name|sectors
expr_stmt|;
block|}
else|else
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"%ld cyls, %d heads, %d precomp, %d red_write, %d land_zone\n"
operator|,
name|scsi_3btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|ncyl_2
argument_list|)
operator|,
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|nheads
operator|,
name|b2tol
argument_list|(
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|st_cyl_wp
argument_list|)
operator|,
name|b2tol
argument_list|(
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|st_cyl_rwc
argument_list|)
operator|,
name|b2tol
argument_list|(
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|land_zone
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * KLUDGE!!(for zone recorded disks) 		 * give a number of sectors so that sec * trks * cyls 		 * is<= disk_size 		 * can lead to wasted space! THINK ABOUT THIS ! 		 */
name|disk_parms
operator|->
name|heads
operator|=
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|nheads
expr_stmt|;
name|disk_parms
operator|->
name|cyls
operator|=
name|scsi_3btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|ncyl_2
argument_list|)
expr_stmt|;
name|disk_parms
operator|->
name|secsiz
operator|=
name|scsi_3btou
argument_list|(
name|scsi_sense
operator|.
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
name|sectors
operator|=
name|sd_size
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|disk_parms
operator|->
name|disksize
operator|=
name|sectors
expr_stmt|;
comment|/* Check if none of these values are zero */
if|if
condition|(
name|disk_parms
operator|->
name|heads
operator|&&
name|disk_parms
operator|->
name|cyls
condition|)
block|{
name|sectors
operator|/=
operator|(
name|disk_parms
operator|->
name|heads
operator|*
name|disk_parms
operator|->
name|cyls
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* set it to something reasonable */
name|disk_parms
operator|->
name|heads
operator|=
literal|64
expr_stmt|;
name|disk_parms
operator|->
name|cyls
operator|=
name|sectors
operator|/
operator|(
literal|64
operator|*
literal|32
operator|)
expr_stmt|;
name|sectors
operator|=
literal|32
expr_stmt|;
block|}
comment|/* keep secsiz sane too - we may divide by it later */
if|if
condition|(
name|disk_parms
operator|->
name|secsiz
operator|==
literal|0
condition|)
name|disk_parms
operator|->
name|secsiz
operator|=
name|SECSIZE
expr_stmt|;
name|disk_parms
operator|->
name|sectors
operator|=
name|sectors
expr_stmt|;
comment|/* dubious on SCSI */
comment|/*XXX */
block|}
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_MEDIA_LOADED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sdsize
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
name|sd
operator|=
name|SCSI_DATA
argument_list|(
operator|&
name|sd_switch
argument_list|,
operator|(
name|u_int32_t
operator|)
name|SDUNIT
argument_list|(
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sd
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|dssize
argument_list|(
name|dev
argument_list|,
operator|&
name|sd
operator|->
name|dk_slices
argument_list|,
name|sdopen
argument_list|,
name|sdclose
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * sense handler: Called to determine what to do when the  * device returns a CHECK CONDITION.  *  * This will issue a retry when the device returns a  * non-media hardware failure.  The CDC-WREN IV does this  * when you access it during thermal calibrarion, so the drive  * is pretty useless without this.  *  * In general, you probably almost always would like to issue a retry  * for your disk I/O.  It can't hurt too much (the caller only retries  * so many times) and it may save your butt.  */
end_comment

begin_function
specifier|static
name|int
name|sd_sense_handler
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inqbuf
decl_stmt|;
name|sense
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
comment|/* I don't know what the heck to do with a deferred error, 	 * so I'll just kick it back to the caller. 	 */
if|if
condition|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
literal|0x71
condition|)
return|return
name|SCSIRET_CONTINUE
return|;
if|if
condition|(
operator|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
literal|0x70
operator|)
operator|&&
operator|(
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
operator|)
operator|==
literal|0x05
operator|)
condition|)
comment|/* No point in retrying Illegal Requests */
return|return
name|SCSIRET_CONTINUE
return|;
name|inqbuf
operator|=
operator|&
operator|(
name|xs
operator|->
name|sc_link
operator|->
name|inqbuf
operator|)
expr_stmt|;
comment|/* It is dangerous to retry on removable drives without 	 * looking carefully at the additional sense code 	 * and sense code qualifier and ensuring the disk hasn't changed: 	 */
if|if
condition|(
name|inqbuf
operator|->
name|dev_qual2
operator|&
name|SID_REMOVABLE
condition|)
return|return
name|SCSIRET_CONTINUE
return|;
comment|/* Retry all disk errors. 	 */
name|scsi_sense_print
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|retries
condition|)
name|printf
argument_list|(
literal|", retries:%d\n"
argument_list|,
name|xs
operator|->
name|retries
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", FAILURE\n"
argument_list|)
expr_stmt|;
return|return
name|SCSIRET_DO_RETRY
return|;
block|}
end_function

begin_comment
comment|/*  * dump all of physical memory into the partition specified, starting  * at offset 'dumplo' into the partition.  */
end_comment

begin_function
specifier|static
name|errval
name|sddump
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
comment|/* dump core after a system crash */
name|struct
name|disklabel
modifier|*
name|lp
decl_stmt|;
specifier|register
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
comment|/* disk unit to do the IO */
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|int32_t
name|num
decl_stmt|;
comment|/* number of sectors to write */
name|u_int32_t
name|unit
decl_stmt|,
name|part
decl_stmt|;
name|int32_t
name|blkoff
decl_stmt|,
name|blknum
decl_stmt|,
name|blkcnt
init|=
name|MAXTRANSFER
decl_stmt|;
name|int32_t
name|nblocks
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|struct
name|scsi_rw_big
name|cmd
decl_stmt|;
specifier|static
name|int
name|sddoingadump
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
init|=
operator|&
name|sx
decl_stmt|;
name|errval
name|retval
decl_stmt|;
name|addr
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* starting address */
comment|/* toss any characters present prior to dump */
while|while
condition|(
name|cncheckc
argument_list|()
operator|!=
operator|-
literal|1
condition|)
empty_stmt|;
comment|/* size of memory to dump */
name|num
operator|=
name|Maxmem
expr_stmt|;
name|unit
operator|=
name|SDUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* eventually support floppies? */
name|part
operator|=
name|PARTITION
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/* file system */
name|sc_link
operator|=
name|SCSI_LINK
argument_list|(
operator|&
name|sd_switch
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sc_link
condition|)
return|return
name|ENXIO
return|;
name|sd
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* was it ever initialized etc. ? */
if|if
condition|(
operator|!
operator|(
name|sd
operator|->
name|flags
operator|&
name|SDINIT
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
operator|!=
name|SDEV_MEDIA_LOADED
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
name|sd
operator|->
name|dk_slices
operator|==
name|NULL
condition|)
name|Debugger
argument_list|(
literal|"sddump: no slices"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lp
operator|=
name|dsgetlabel
argument_list|(
name|dev
argument_list|,
name|sd
operator|->
name|dk_slices
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* Convert to disk sectors */
name|num
operator|=
operator|(
name|u_int32_t
operator|)
name|num
operator|*
name|PAGE_SIZE
operator|/
name|sd
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
comment|/* XXX it must be 512 */
comment|/* check if controller active */
if|if
condition|(
name|sddoingadump
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|nblocks
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_size
expr_stmt|;
name|blkoff
operator|=
name|lp
operator|->
name|d_partitions
index|[
name|part
index|]
operator|.
name|p_offset
expr_stmt|;
comment|/* XXX */
name|blkoff
operator|+=
name|sd
operator|->
name|dk_slices
operator|->
name|dss_slices
index|[
name|dkslice
argument_list|(
name|dev
argument_list|)
index|]
operator|.
name|ds_offset
expr_stmt|;
comment|/* check transfer bounds against partition size */
if|if
condition|(
operator|(
name|dumplo
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|dumplo
operator|+
name|num
operator|)
operator|>
name|nblocks
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sddoingadump
operator|=
literal|1
expr_stmt|;
name|blknum
operator|=
name|dumplo
operator|+
name|blkoff
expr_stmt|;
while|while
condition|(
name|num
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|is_physical_memory
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|addr
argument_list|)
condition|)
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
name|addr
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|pmap_enter
argument_list|(
name|kernel_pmap
argument_list|,
operator|(
name|vm_offset_t
operator|)
name|CADDR1
argument_list|,
name|trunc_page
argument_list|(
literal|0
argument_list|)
argument_list|,
name|VM_PROT_READ
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* 		 *  Fill out the scsi command 		 */
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|op_code
operator|=
name|WRITE_BIG
expr_stmt|;
name|cmd
operator|.
name|addr_3
operator|=
operator|(
name|blknum
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
name|cmd
operator|.
name|addr_2
operator|=
operator|(
name|blknum
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
name|cmd
operator|.
name|addr_1
operator|=
operator|(
name|blknum
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cmd
operator|.
name|addr_0
operator|=
name|blknum
operator|&
literal|0xff
expr_stmt|;
name|cmd
operator|.
name|length2
operator|=
operator|(
name|blkcnt
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
name|cmd
operator|.
name|length1
operator|=
operator|(
name|blkcnt
operator|&
literal|0xff
operator|)
expr_stmt|;
comment|/* 		 * Fill out the scsi_xfer structure 		 *    Note: we cannot sleep as we may be an interrupt 		 * don't use scsi_scsi_cmd() as it may want 		 * to wait for an xs. 		 */
name|bzero
argument_list|(
name|xs
argument_list|,
sizeof|sizeof
argument_list|(
name|sx
argument_list|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_NOMASK
operator||
name|SCSI_NOSLEEP
operator||
name|INUSE
operator||
name|SCSI_DATA_OUT
expr_stmt|;
name|xs
operator|->
name|sc_link
operator|=
name|sc_link
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
name|SD_RETRIES
expr_stmt|;
name|xs
operator|->
name|timeout
operator|=
literal|10000
expr_stmt|;
comment|/* 10000 millisecs for a disk ! */
name|xs
operator|->
name|cmd
operator|=
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|CADDR1
expr_stmt|;
comment|/* XXX use pmap_enter() */
name|xs
operator|->
name|datalen
operator|=
name|blkcnt
operator|*
name|sd
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
comment|/* 		 * Pass all this info to the scsi driver. 		 */
name|retval
operator|=
operator|(
operator|*
operator|(
name|sc_link
operator|->
name|adapter
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|SUCCESSFULLY_QUEUED
case|:
case|case
name|HAD_ERROR
case|:
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* we said not to sleep! */
case|case
name|COMPLETE
case|:
break|break;
default|default:
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* we said not to sleep! */
block|}
comment|/* 		 * If we are dumping core, it may take a while. 		 * So reassure the user and hold off any watchdogs. 		 */
if|if
condition|(
operator|(
name|unsigned
operator|)
name|addr
operator|%
operator|(
literal|1024
operator|*
literal|1024
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|HW_WDOG
if|if
condition|(
name|wdog_tickler
condition|)
call|(
modifier|*
name|wdog_tickler
call|)
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* HW_WDOG */
name|printf
argument_list|(
literal|"%ld "
argument_list|,
name|num
operator|/
literal|2048
argument_list|)
expr_stmt|;
block|}
comment|/* update block count */
name|num
operator|-=
name|blkcnt
expr_stmt|;
name|blknum
operator|+=
name|blkcnt
expr_stmt|;
operator|(
name|int
operator|)
name|addr
operator|+=
name|blkcnt
operator|*
name|sd
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
comment|/* operator aborting dump? */
if|if
condition|(
name|cncheckc
argument_list|()
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|sd_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|sd_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sd_devsw_installed
condition|)
block|{
name|bdevsw_add_generic
argument_list|(
name|BDEV_MAJOR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|sd_bdevsw
argument_list|)
expr_stmt|;
name|sd_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|sddev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|sd_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

