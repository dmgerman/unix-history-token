begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)(now julian@DIALix.oz.au)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * $Id: st.c,v 1.64 1996/03/27 18:50:10 bde Exp $  */
end_comment

begin_comment
comment|/*  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  * major changes by Julian Elischer (julian@jules.dialix.oz.au) May 1993  */
end_comment

begin_comment
comment|/*  * To do:  * work out some better way of guessing what a good timeout is going  * to be depending on whether we expect to retension or not.  *  */
end_comment

begin_include
include|#
directive|include
file|"opt_bounce.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_tape.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/devconf.h>
end_include

begin_comment
comment|/* Defines for device specific stuff */
end_comment

begin_define
define|#
directive|define
name|PAGE_0_SENSE_DATA_SIZE
value|12
end_define

begin_define
define|#
directive|define
name|DEF_FIXED_BSIZE
value|512
end_define

begin_define
define|#
directive|define
name|ST_RETRIES
value|4
end_define

begin_comment
comment|/* only on non IO commands */
end_comment

begin_define
define|#
directive|define
name|STUNIT
parameter_list|(
name|DEV
parameter_list|)
value|((minor(DEV)&0xF0)>> 4)
end_define

begin_comment
comment|/* 4 bit unit.  */
end_comment

begin_define
define|#
directive|define
name|STSETUNIT
parameter_list|(
name|DEV
parameter_list|,
name|U
parameter_list|)
value|makedev(major(DEV), ((U)<< 4))
end_define

begin_define
define|#
directive|define
name|MODE
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)& 0x03) )
end_define

begin_define
define|#
directive|define
name|DSTY
parameter_list|(
name|z
parameter_list|)
value|( ((minor(z)>> 2)& 0x03) )
end_define

begin_define
define|#
directive|define
name|CTLMODE
value|3
end_define

begin_define
define|#
directive|define
name|IS_CTLMODE
parameter_list|(
name|DEV
parameter_list|)
value|(MODE(DEV) == CTLMODE)
end_define

begin_define
define|#
directive|define
name|SCSI_2_MAX_DENSITY_CODE
value|0x17
end_define

begin_comment
comment|/* maximum density code specified 					 * in SCSI II spec. */
end_comment

begin_decl_stmt
specifier|static
name|errval
name|st_space
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|int32_t
name|number
operator|,
name|u_int32_t
name|what
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_rewind
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|boolean
name|immed
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_erase
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|boolean
name|immed
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_mode_sense
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|u_int32_t
name|flags
operator|,
expr|\ 	struct
name|tape_pages
operator|*
name|page
operator|,
name|u_int32_t
name|pagelen
operator|,
name|u_int32_t
name|pagecode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_decide_mode
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|boolean
name|first_read
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_read
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|char
operator|*
name|buf
operator|,
name|u_int32_t
name|size
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_rd_blk_lim
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_touch_tape
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_write_filemarks
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|int32_t
name|number
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_load
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|u_int32_t
name|type
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_mode_select
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|u_int32_t
name|flags
operator|,
expr|\ 	struct
name|tape_pages
operator|*
name|page
operator|,
name|u_int32_t
name|pagelen
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_comp
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|u_int32_t
name|mode
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|st_chkeod
name|__P
argument_list|(
operator|(
name|u_int32_t
name|unit
operator|,
name|boolean
name|position
operator|,
name|int32_t
operator|*
name|nmarks
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ststart
parameter_list|(
name|u_int32_t
name|unit
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|st_unmount
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|boolean
name|eject
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_mount_tape
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|u_int32_t
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|st_loadquirks
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_link
operator|*
name|sc_link
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|errval
name|st_interpret_sense
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
name|xs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ESUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|NOEJECT
value|0
end_define

begin_define
define|#
directive|define
name|EJECT
value|1
end_define

begin_struct
struct|struct
name|scsi_data
block|{
comment|/*--------------------present operating parameters, flags etc.----------------*/
name|u_int32_t
name|flags
decl_stmt|;
comment|/* see below                          */
name|u_int32_t
name|blksiz
decl_stmt|;
comment|/* blksiz we are using                */
name|u_int32_t
name|density
decl_stmt|;
comment|/* present density                    */
name|u_int32_t
name|comp
decl_stmt|;
comment|/* present compression mode           */
name|u_int32_t
name|quirks
decl_stmt|;
comment|/* quirks for the open mode           */
name|u_int32_t
name|last_dsty
decl_stmt|;
comment|/* last density openned               */
comment|/*--------------------parameters reported by the device ----------------------*/
name|u_int32_t
name|blkmin
decl_stmt|;
comment|/* min blk size                       */
name|u_int32_t
name|blkmax
decl_stmt|;
comment|/* max blk size                       */
comment|/*--------------------parameters reported by the device for this media--------*/
name|u_int32_t
name|numblks
decl_stmt|;
comment|/* nominal blocks capacity            */
name|u_int32_t
name|media_blksiz
decl_stmt|;
comment|/* 0 if not ST_FIXEDBLOCKS            */
name|u_int32_t
name|media_density
decl_stmt|;
comment|/* this is what it said when asked    */
comment|/*--------------------quirks for the whole drive------------------------------*/
name|u_int32_t
name|drive_quirks
decl_stmt|;
comment|/* quirks of this drive               */
comment|/*--------------------How we should set up when openning each minor device----*/
name|st_modes
name|modes
decl_stmt|;
comment|/* plus more for each mode            */
name|u_int8_t
name|modeflags
index|[
literal|4
index|]
decl_stmt|;
comment|/* flags for the modes                */
define|#
directive|define
name|DENSITY_SET_BY_USER
value|0x01
define|#
directive|define
name|DENSITY_SET_BY_QUIRK
value|0x02
define|#
directive|define
name|BLKSIZE_SET_BY_USER
value|0x04
define|#
directive|define
name|BLKSIZE_SET_BY_QUIRK
value|0x08
define|#
directive|define
name|COMPRES_SET_BY_USER
value|0x10
define|#
directive|define
name|COMPRES_SET_BY_QUIRK
value|0x20
comment|/*--------------------storage for sense data returned by the drive------------*/
name|unsigned
name|char
name|saved_page0
index|[
name|PAGE_0_SENSE_DATA_SIZE
index|]
decl_stmt|;
comment|/* 					 * additional sense data needed 					 * for mode sense/select. 					 */
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
name|struct
name|scsi_xfer
name|scsi_xfer
decl_stmt|;
comment|/* scsi xfer struct for this drive */
name|u_int32_t
name|xfer_block_wait
decl_stmt|;
comment|/* is a process waiting? */
ifdef|#
directive|ifdef
name|DEVFS
struct|struct
block|{
name|void
modifier|*
name|rst
decl_stmt|;
name|void
modifier|*
name|nrst
decl_stmt|;
name|void
modifier|*
name|erst
decl_stmt|;
comment|/* end of aliases */
name|void
modifier|*
name|rst_0
decl_stmt|;
name|void
modifier|*
name|nrst_0
decl_stmt|;
name|void
modifier|*
name|erst_0
decl_stmt|;
name|void
modifier|*
name|ctl_0
decl_stmt|;
name|void
modifier|*
name|rst_1
decl_stmt|;
name|void
modifier|*
name|nrst_1
decl_stmt|;
name|void
modifier|*
name|erst_1
decl_stmt|;
name|void
modifier|*
name|ctl_1
decl_stmt|;
name|void
modifier|*
name|rst_2
decl_stmt|;
name|void
modifier|*
name|nrst_2
decl_stmt|;
name|void
modifier|*
name|erst_2
decl_stmt|;
name|void
modifier|*
name|ctl_2
decl_stmt|;
name|void
modifier|*
name|rst_3
decl_stmt|;
name|void
modifier|*
name|nrst_3
decl_stmt|;
name|void
modifier|*
name|erst_3
decl_stmt|;
name|void
modifier|*
name|ctl_3
decl_stmt|;
name|void
modifier|*
name|ctl
decl_stmt|;
block|}
name|devfs_token
struct|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|stunit
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
return|return
name|STUNIT
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|dev_t
name|stsetunit
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
return|return
name|STSETUNIT
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|errval
name|st_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|errval
name|st_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|errval
name|st_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|st_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|stopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|stclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|stioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|ststrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|14
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|5
end_define

begin_decl_stmt
specifier|extern
name|struct
name|cdevsw
name|st_cdevsw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hold off the complaints for a second */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|st_bdevsw
init|=
block|{
name|stopen
block|,
name|stclose
block|,
name|ststrategy
block|,
name|stioctl
block|,
comment|/*5*/
name|nodump
block|,
name|nopsize
block|,
literal|0
block|,
literal|"st"
block|,
operator|&
name|st_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|st_cdevsw
init|=
block|{
name|stopen
block|,
name|stclose
block|,
name|rawread
block|,
name|rawwrite
block|,
comment|/*14*/
name|stioctl
block|,
name|nostop
block|,
name|nullreset
block|,
name|nodevtotty
block|,
comment|/* st */
name|seltrue
block|,
name|nommap
block|,
name|ststrategy
block|,
literal|"st"
block|,
operator|&
name|st_bdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|SCSI_DEVICE_ENTRIES
argument_list|(
argument|st
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|st_switch
init|=
block|{
name|st_interpret_sense
block|,
comment|/* check errors with us first */
name|ststart
block|,
comment|/* we have a queue, and this is how we service it */
name|NULL
block|,
name|NULL
block|,
comment|/* use the default 'done' routine */
literal|"st"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
comment|/* Link flags */
name|stattach
block|,
literal|"Sequential-Access"
block|,
name|stopen
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_data
argument_list|)
block|,
name|T_SEQUENTIAL
block|,
name|stunit
block|,
name|stsetunit
block|,
name|st_open
block|,
name|st_ioctl
block|,
name|st_close
block|,
name|st_strategy
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ST_INITIALIZED
value|0x01
end_define

begin_define
define|#
directive|define
name|ST_INFO_VALID
value|0x02
end_define

begin_define
define|#
directive|define
name|ST_OPEN
value|0x04
end_define

begin_define
define|#
directive|define
name|ST_BLOCK_SET
value|0x08
end_define

begin_comment
comment|/* block size, mode set by ioctl      */
end_comment

begin_define
define|#
directive|define
name|ST_WRITTEN
value|0x10
end_define

begin_comment
comment|/* data have been written, EOD needed */
end_comment

begin_define
define|#
directive|define
name|ST_FIXEDBLOCKS
value|0x20
end_define

begin_define
define|#
directive|define
name|ST_AT_FILEMARK
value|0x40
end_define

begin_define
define|#
directive|define
name|ST_EIO_PENDING
value|0x80
end_define

begin_comment
comment|/* we couldn't report it then (had data) */
end_comment

begin_define
define|#
directive|define
name|ST_NEW_MOUNT
value|0x100
end_define

begin_comment
comment|/* still need to decide mode              */
end_comment

begin_define
define|#
directive|define
name|ST_READONLY
value|0x200
end_define

begin_comment
comment|/* st_mode_sense says write protected */
end_comment

begin_define
define|#
directive|define
name|ST_FM_WRITTEN
value|0x400
end_define

begin_comment
comment|/* 				 * EOF file mark written  -- used with 				 * ~ST_WRITTEN to indicate that multiple file 				 * marks have been written 				 */
end_comment

begin_define
define|#
directive|define
name|ST_BLANK_READ
value|0x800
end_define

begin_comment
comment|/* BLANK CHECK encountered already */
end_comment

begin_define
define|#
directive|define
name|ST_2FM_AT_EOD
value|0x1000
end_define

begin_comment
comment|/* write 2 file marks at EOD */
end_comment

begin_define
define|#
directive|define
name|ST_MOUNTED
value|0x2000
end_define

begin_comment
comment|/* Device is presently mounted */
end_comment

begin_define
define|#
directive|define
name|ST_SENSE_READ
value|0x4000
end_define

begin_comment
comment|/* mode sense read from drive */
end_comment

begin_define
define|#
directive|define
name|ST_PER_ACTION
value|(ST_AT_FILEMARK | ST_EIO_PENDING | ST_BLANK_READ)
end_define

begin_define
define|#
directive|define
name|ST_PER_MOUNT
value|(ST_INFO_VALID | ST_BLOCK_SET | ST_WRITTEN | \ 			ST_FIXEDBLOCKS | ST_READONLY | \ 			ST_FM_WRITTEN | ST_2FM_AT_EOD | ST_PER_ACTION)
end_define

begin_function
specifier|static
name|int
name|st_externalize
parameter_list|(
name|struct
name|kern_devconf
modifier|*
name|kdc
parameter_list|,
name|struct
name|sysctl_req
modifier|*
name|req
parameter_list|)
block|{
return|return
name|scsi_externalize
argument_list|(
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|kdc
operator|->
name|kdc_unit
argument_list|)
argument_list|,
name|req
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|kern_devconf
name|kdc_st_template
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* filled in by dev_attach */
literal|"st"
block|,
literal|0
block|,
name|MDDC_SCSI
block|,
name|st_externalize
block|,
literal|0
block|,
name|scsi_goaway
block|,
name|SCSI_EXTERNALLEN
block|,
operator|&
name|kdc_scbus0
block|,
comment|/* XXX parent */
literal|0
block|,
comment|/* parentdata */
name|DC_UNKNOWN
block|,
comment|/* not supported */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|st_registerdev
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
name|struct
name|kern_devconf
modifier|*
name|kdc
decl_stmt|;
name|MALLOC
argument_list|(
name|kdc
argument_list|,
expr|struct
name|kern_devconf
operator|*
argument_list|,
sizeof|sizeof
expr|*
name|kdc
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|kdc
condition|)
return|return;
operator|*
name|kdc
operator|=
name|kdc_st_template
expr_stmt|;
name|kdc
operator|->
name|kdc_unit
operator|=
name|unit
expr_stmt|;
name|kdc
operator|->
name|kdc_description
operator|=
name|st_switch
operator|.
name|desc
expr_stmt|;
name|dev_attach
argument_list|(
name|kdc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The routine called by the low level scsi routine when it discovers  * a device suitable for this driver  */
end_comment

begin_function
specifier|static
name|errval
name|stattach
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|unit
operator|=
name|sc_link
operator|->
name|dev_unit
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|st
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the drive is a known criminal and take 	 * Any steps needed to bring it into line 	 */
name|st_loadquirks
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
comment|/* 	 * Use the subdriver to request information regarding 	 * the drive. We cannot use interrupts yet, so the 	 * request must specify this. 	 */
if|if
condition|(
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"drive offline"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"density code 0x%lx, "
argument_list|,
name|st
operator|->
name|media_density
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|media_blksiz
condition|)
block|{
name|printf
argument_list|(
literal|"%ld-byte"
argument_list|,
name|st
operator|->
name|media_blksiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"variable"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" blocks, write-%s"
argument_list|,
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_READONLY
operator|)
condition|?
literal|"protected"
else|:
literal|"enabled"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" drive empty"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set up the buf queue for this device 	 */
name|st
operator|->
name|flags
operator||=
name|ST_INITIALIZED
expr_stmt|;
name|st_registerdev
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
comment|/* XXX use these directly and change to devsw_add_devswf(). */
define|#
directive|define
name|ST_GID
value|GID_OPERATOR
define|#
directive|define
name|ST_UID
value|UID_ROOT
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rst%ld.0"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|rst_0
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|0
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"nrst%ld.0"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|nrst_0
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|1
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"erst%ld.0"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|erst_0
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|2
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"st%ldctl.0"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|ctl_0
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|3
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rst%ld.1"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|rst_1
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|4
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"nrst%ld.1"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|nrst_1
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|5
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"erst%ld.1"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|erst_1
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|6
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"st%ldctl.1"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|ctl_1
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|7
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rst%ld.2"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|rst_2
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|8
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"nrst%ld.2"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|nrst_2
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|9
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"erst%ld.2"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|erst_2
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|10
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"st%ldctl.2"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|ctl_2
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|11
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rst%ld.3"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|rst_3
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|12
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"nrst%ld.3"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|nrst_3
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|13
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"erst%ld.3"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|erst_3
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|14
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0660
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"st%ldctl.3"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|ctl_3
operator|=
name|devfs_add_devsw
argument_list|(
literal|"/tape"
argument_list|,
name|name
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator|+
literal|15
argument_list|,
name|DV_CHR
argument_list|,
name|ST_UID
argument_list|,
name|ST_GID
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|ctl
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|st_cdevsw
argument_list|,
operator|(
name|unit
operator|<<
literal|4
operator|)
operator||
name|SCSI_CONTROL_MASK
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"rst%d.ctl"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/** add links **/
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"rst%ld"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|rst
operator|=
name|dev_link
argument_list|(
literal|"/"
argument_list|,
name|name
argument_list|,
name|st
operator|->
name|devfs_token
operator|.
name|rst_0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"nrst%ld"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|nrst
operator|=
name|dev_link
argument_list|(
literal|"/"
argument_list|,
name|name
argument_list|,
name|st
operator|->
name|devfs_token
operator|.
name|nrst_0
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"erst%ld"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|devfs_token
operator|.
name|erst
operator|=
name|dev_link
argument_list|(
literal|"/"
argument_list|,
name|name
argument_list|,
name|st
operator|->
name|devfs_token
operator|.
name|erst_0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * initialise the subdevices to the default (QUIRK) state.  * this will remove any setting made by the system operator or previous  * operations.  */
end_comment

begin_function
specifier|static
name|void
name|st_loadquirks
parameter_list|(
name|sc_link
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|st_mode
modifier|*
name|mode
decl_stmt|;
name|struct
name|st_mode
modifier|*
name|mode2
decl_stmt|;
name|mode
operator|=
operator|(
expr|struct
name|st_mode
operator|*
operator|)
name|sc_link
operator|->
name|devmodes
expr_stmt|;
if|if
condition|(
operator|!
name|mode
condition|)
return|return;
name|st
operator|->
name|quirks
operator|=
name|st
operator|->
name|drive_quirks
operator|=
name|sc_link
operator|->
name|quirks
expr_stmt|;
name|mode2
operator|=
name|st
operator|->
name|modes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|bzero
argument_list|(
name|mode2
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mode2
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|modeflags
index|[
name|i
index|]
operator|&=
operator|~
operator|(
name|BLKSIZE_SET_BY_QUIRK
operator||
name|DENSITY_SET_BY_QUIRK
operator||
name|BLKSIZE_SET_BY_USER
operator||
name|DENSITY_SET_BY_USER
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|->
name|blksiz
operator|&&
operator|(
operator|(
name|mode
operator|->
name|quirks
operator||
name|st
operator|->
name|drive_quirks
operator|)
operator|&
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator|)
operator|)
condition|)
block|{
name|mode2
operator|->
name|blksiz
operator|=
name|mode
operator|->
name|blksiz
expr_stmt|;
name|st
operator|->
name|modeflags
index|[
name|i
index|]
operator||=
name|BLKSIZE_SET_BY_QUIRK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mode
operator|->
name|quirks
operator||
name|st
operator|->
name|drive_quirks
operator|)
operator|&
name|ST_Q_FORCE_VAR_MODE
condition|)
block|{
name|mode2
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|modeflags
index|[
name|i
index|]
operator||=
name|BLKSIZE_SET_BY_QUIRK
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mode
operator|->
name|density
condition|)
block|{
name|mode2
operator|->
name|density
operator|=
name|mode
operator|->
name|density
expr_stmt|;
name|st
operator|->
name|modeflags
index|[
name|i
index|]
operator||=
name|DENSITY_SET_BY_QUIRK
expr_stmt|;
block|}
name|mode
operator|++
expr_stmt|;
name|mode2
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * open the device.  */
end_comment

begin_function
specifier|static
name|errval
name|st_open
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|dsty
decl_stmt|;
name|errval
name|errno
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|STUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* 	 * Make sure the device has been initialised 	 */
if|if
condition|(
operator|(
name|st
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INITIALIZED
operator|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/* 	 * Only allow one at a time 	 */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_OPEN
condition|)
block|{
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
comment|/* 	 * Throw out a dummy instruction to catch 'Unit attention 	 * errors (the error handling will invalidate all our 	 * device info if we get one, but otherwise, ignore it) 	 */
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_OPEN
expr_stmt|;
comment|/* unit attn are now errors */
comment|/* 	 * If the mode is 3 (e.g. minor = 3,7,11,15) 	 * then the device has been openned to set defaults 	 * This mode does NOT ALLOW I/O, only ioctls. 	 * XXX: Where do we lock out I/O? 	 */
if|if
condition|(
name|IS_CTLMODE
argument_list|(
name|dev
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Check that the device is ready to use (media loaded?) 	 * This time take notice of the return result 	 */
if|if
condition|(
operator|(
name|errno
operator|=
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"st%d: not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_unmount
argument_list|(
name|unit
argument_list|,
name|NOEJECT
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
comment|/* 	 * if it's a different mode, or if the media has been 	 * invalidated, unmount the tape from the previous 	 * session but continue with open processing 	 */
if|if
condition|(
operator|(
name|st
operator|->
name|last_dsty
operator|!=
name|dsty
operator|)
operator|||
operator|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
operator|)
condition|)
block|{
name|st_unmount
argument_list|(
name|unit
argument_list|,
name|NOEJECT
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we are not mounted, then we should start a new 	 * mount session. 	 */
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_MOUNTED
operator|)
condition|)
block|{
name|st_mount_tape
argument_list|(
name|dev
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|st
operator|->
name|last_dsty
operator|=
name|dsty
expr_stmt|;
block|}
comment|/* 	 * Make sure that a tape opened in write-only mode will have 	 * file marks written on it when closed, even if not written to. 	 * This is for SUN compatibility 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|O_ACCMODE
operator|)
operator|==
name|FWRITE
condition|)
name|st
operator|->
name|flags
operator||=
name|ST_WRITTEN
expr_stmt|;
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_PREVENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* who cares if it fails? */
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"Open complete\n"
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_OPEN
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * close the device.. only called if we are the LAST  * occurence of an open device  */
end_comment

begin_function
specifier|static
name|errval
name|st_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|fmt
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|STUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
operator|(
name|ST_WRITTEN
operator||
name|ST_FM_WRITTEN
operator|)
operator|)
operator|==
name|ST_WRITTEN
condition|)
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
literal|0x3
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|3
case|:
comment|/* for now */
name|st_unmount
argument_list|(
name|unit
argument_list|,
name|NOEJECT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*leave mounted unless media seems to have been removed */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
block|{
name|st_unmount
argument_list|(
name|unit
argument_list|,
name|NOEJECT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
name|st_unmount
argument_list|(
name|unit
argument_list|,
name|EJECT
argument_list|)
expr_stmt|;
break|break;
block|}
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_OPEN
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start a new mount session.  * Copy in all the default parameters from the selected device mode.  * and try guess any that seem to be defaulted.  */
end_comment

begin_function
specifier|static
name|errval
name|st_mount_tape
parameter_list|(
name|dev
parameter_list|,
name|flags
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|u_int32_t
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|dsty
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|errval
name|errno
init|=
literal|0
decl_stmt|;
name|unit
operator|=
name|STUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|sc_link
operator|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_MOUNTED
condition|)
return|return
literal|0
return|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"mounting\n "
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_NEW_MOUNT
expr_stmt|;
name|st
operator|->
name|quirks
operator|=
name|st
operator|->
name|drive_quirks
operator||
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|quirks
expr_stmt|;
comment|/* 	 * If the media is new, then make sure we give it a chance to 	 * to do a 'load' instruction. ( We assume it is new) 	 */
if|if
condition|(
operator|(
name|errno
operator|=
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_LOAD
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|errno
operator|)
return|;
block|}
comment|/* 	 * Throw another dummy instruction to catch 	 * 'Unit attention' errors. Some drives appear to give 	 * these after doing a Load instruction. 	 * (noteably some DAT drives) 	 */
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
comment|/* 	 * Some devices can't tell you much until they have been 	 * asked to look at the media. This quirk does this. 	 */
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_SNS_HLP
condition|)
block|{
if|if
condition|(
operator|(
name|errno
operator|=
name|st_touch_tape
argument_list|(
name|unit
argument_list|)
operator|)
condition|)
return|return
name|errno
return|;
block|}
comment|/* 	 * Load the physical device parameters 	 * loads: blkmin, blkmax 	 */
if|if
condition|(
operator|(
name|errno
operator|=
name|st_rd_blk_lim
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|errno
return|;
block|}
comment|/* 	 * Load the media dependent parameters 	 * includes: media_blksiz,media_density,numblks 	 * As we have a tape in, it should be reflected here. 	 * If not you may need the "quirk" above. 	 */
if|if
condition|(
operator|(
name|errno
operator|=
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
return|return
name|errno
return|;
block|}
comment|/* 	 * If we have gained a permanent density from somewhere, 	 * then use it in preference to the one supplied by 	 * default by the driver. 	 */
if|if
condition|(
name|st
operator|->
name|modeflags
index|[
name|dsty
index|]
operator|&
operator|(
name|DENSITY_SET_BY_QUIRK
operator||
name|DENSITY_SET_BY_USER
operator|)
condition|)
block|{
name|st
operator|->
name|density
operator|=
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|density
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|density
operator|=
name|st
operator|->
name|media_density
expr_stmt|;
block|}
comment|/* 	 * If we have gained a permanent blocksize 	 * then use it in preference to the one supplied by 	 * default by the driver. 	 */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|modeflags
index|[
name|dsty
index|]
operator|&
operator|(
name|BLKSIZE_SET_BY_QUIRK
operator||
name|BLKSIZE_SET_BY_USER
operator|)
condition|)
block|{
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|blksiz
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|blksiz
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|(
name|errno
operator|=
name|st_decide_mode
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
block|{
return|return
name|errno
return|;
block|}
block|}
if|if
condition|(
operator|(
name|errno
operator|=
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%ld: Cannot set selected mode"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|errno
return|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_NEW_MOUNT
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_MOUNTED
expr_stmt|;
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_MEDIA_LOADED
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * End the present mount session.  * Rewind, and optionally eject the tape.  * Reset various flags to indicate that all new  * operations require another mount operation  */
end_comment

begin_function
name|void
name|st_unmount
parameter_list|(
name|int
name|unit
parameter_list|,
name|boolean
name|eject
parameter_list|)
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|int32_t
name|nmarks
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_MOUNTED
operator|)
condition|)
return|return;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"unmounting\n"
operator|)
argument_list|)
expr_stmt|;
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|eject
condition|)
block|{
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ST_MOUNTED
operator||
name|ST_NEW_MOUNT
operator|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_MEDIA_LOADED
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given all we know about the device, media, mode, 'quirks' and  * initial operation, make a decision as to how we should be set  * to run (regarding blocking and EOD marks)  */
end_comment

begin_function
specifier|static
name|errval
name|st_decide_mode
parameter_list|(
name|unit
parameter_list|,
name|first_read
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|;
name|boolean
name|first_read
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"starting block mode decision\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the user hasn't already specified fixed or variable-length 	 * blocks and the block size (zero if variable-length), we'll 	 * have to try to figure them out ourselves. 	 * 	 * Our first shot at a method is, "The quirks made me do it!" 	 */
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|st
operator|->
name|quirks
operator|&
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator||
name|ST_Q_FORCE_VAR_MODE
operator|)
argument_list|)
condition|)
block|{
case|case
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator||
name|ST_Q_FORCE_VAR_MODE
operator|)
case|:
name|printf
argument_list|(
literal|"st%ld: bad quirks\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|ST_Q_FORCE_FIXED_MODE
case|:
comment|/*specified fixed, but not what size */
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|blkmin
operator|&&
operator|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
operator|)
condition|)
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|blkmin
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|->
name|media_blksiz
operator|>
literal|0
condition|)
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
else|else
name|st
operator|->
name|blksiz
operator|=
name|DEF_FIXED_BSIZE
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Quirks force fixed mode(%ld)\n"
operator|,
name|st
operator|->
name|blksiz
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|ST_Q_FORCE_VAR_MODE
case|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Quirks force variable mode\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * If the drive can only handle fixed-length blocks and only at 		 * one size, perhaps we should just do that. 		 */
if|if
condition|(
name|st
operator|->
name|blkmin
operator|&&
operator|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
operator|)
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|blkmin
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"blkmin == blkmax of %ld\n"
operator|,
name|st
operator|->
name|blkmin
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * If the tape density mandates (or even suggests) use of fixed 	 * or variable-length blocks, comply. 	 */
switch|switch
condition|(
operator|(
name|int
operator|)
name|st
operator|->
name|density
condition|)
block|{
case|case
name|HALFINCH_800
case|:
case|case
name|HALFINCH_1600
case|:
case|case
name|HALFINCH_6250
case|:
case|case
name|DDS
case|:
case|case
name|QIC_525
case|:
case|case
name|QIC_1320
case|:
case|case
name|QIC_3080
case|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"density specified variable\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
case|case
name|QIC_11
case|:
case|case
name|QIC_24
case|:
case|case
name|QIC_120
case|:
case|case
name|QIC_150
case|:
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|media_blksiz
operator|>
literal|0
condition|)
block|{
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|blksiz
operator|=
name|DEF_FIXED_BSIZE
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"density specified fixed\n"
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * If we're about to read the tape, perhaps we should choose 	 * fixed or variable-length blocks and block size according to 	 * what the drive found on the tape. 	 */
if|if
condition|(
name|first_read
operator|&&
operator|(
operator|!
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_BLKSIZ
operator|)
operator|||
operator|(
name|st
operator|->
name|media_blksiz
operator|==
literal|0
operator|)
operator|||
operator|(
name|st
operator|->
name|media_blksiz
operator|==
name|DEF_FIXED_BSIZE
operator|)
operator|||
operator|(
name|st
operator|->
name|media_blksiz
operator|==
literal|1024
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|media_blksiz
operator|==
literal|0
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Used media_blksiz of %ld\n"
operator|,
name|st
operator|->
name|media_blksiz
operator|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * We're getting no hints from any direction.  Choose variable- 	 * length blocks arbitrarily. 	 */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Give up and default to variable mode\n"
operator|)
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Decide whether or not to write two file marks to signify end- 	 * of-data.  Make the decision as a function of density.  If 	 * the decision is not to use a second file mark, the SCSI BLANK 	 * CHECK condition code will be recognized as end-of-data when 	 * first read. 	 * (I think this should be a by-product of fixed/variable..julian) 	 */
switch|switch
condition|(
operator|(
name|int
operator|)
name|st
operator|->
name|density
condition|)
block|{
comment|/*      case    8 mm:   What is the SCSI density code for 8 mm, anyway? */
case|case
name|QIC_11
case|:
case|case
name|QIC_24
case|:
case|case
name|QIC_120
case|:
case|case
name|QIC_150
case|:
case|case
name|QIC_525
case|:
case|case
name|QIC_1320
case|:
case|case
name|QIC_3080
case|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_2FM_AT_EOD
expr_stmt|;
break|break;
default|default:
name|st
operator|->
name|flags
operator||=
name|ST_2FM_AT_EOD
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into  * one the physical driver can understand  * The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|st_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|;
name|u_int32_t
name|opri
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
decl_stmt|;
name|int
name|len
decl_stmt|;
name|unit
operator|=
name|STUNIT
argument_list|(
operator|(
name|bp
operator|->
name|b_dev
operator|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* 	 * If it's a null transfer, return immediatly 	 */
if|if
condition|(
operator|(
name|len
operator|=
name|bp
operator|->
name|b_bcount
operator|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Check the adapter can do it 	 */
name|scsi_minphys
argument_list|(
name|bp
argument_list|,
operator|&
name|st_switch
argument_list|)
expr_stmt|;
comment|/* 	 * Odd sized request on fixed drives are verboten 	 */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|%
name|st
operator|->
name|blksiz
condition|)
block|{
name|printf
argument_list|(
literal|"st%ld: bad request, must be multiple of %ld\n"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|blksiz
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/* 	 * as are out-of-range requests on variable drives. 	 * (or if we got chopped by minphys) 	 */
else|else
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|<
name|st
operator|->
name|blkmin
operator|||
name|bp
operator|->
name|b_bcount
operator|>
name|st
operator|->
name|blkmax
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%ld: bad request, must be between %ld and %ld\n"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|blkmin
argument_list|,
name|st
operator|->
name|blkmax
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|len
operator|!=
name|bp
operator|->
name|b_bcount
condition|)
block|{
name|printf
argument_list|(
literal|"st%ld: bad request, must be less than %ld bytes\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_bcount
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/* 	 * Use a bounce buffer if necessary 	 */
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_BOUNCE
condition|)
name|vm_bounce_alloc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Place it in the queue of activities for this tape 	 * at the end (a bit silly because we only have on user.. 	 * (but it could fork() )) 	 */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|st
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|,
name|b_act
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the device to get going on the transfer if it's 	 * not doing anything, otherwise just wait for completion 	 * (All a bit silly if we're only allowing 1 open but..) 	 */
name|ststart
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * ststart looks to see if there is a buf waiting for the device  * and that the device is not already busy. If both are true,  * It dequeues the buf and creates a scsi command to perform the  * transfer required. The transfer request will call scsi_done  * on completion, which will in turn call this routine again  * so that the next queued transfer is performed.  * The bufs are queued by the strategy routine (ststrategy)  *  * This routine is also called after other non-queued requests  * have been made of the scsi driver, to ensure that the queue  * continues to be drained.  * ststart() is called at splbio  */
end_comment

begin_function
specifier|static
name|void
name|ststart
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_rw_tape
name|cmd
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"ststart "
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * See if there is a buf to do and we are not already 	 * doing one 	 */
while|while
condition|(
name|sc_link
operator|->
name|opennings
operator|!=
literal|0
condition|)
block|{
comment|/* if a special awaits, let it proceed first */
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_WAITING
condition|)
block|{
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_WAITING
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc_link
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|=
name|st
operator|->
name|buf_queue
operator|.
name|tqh_first
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* yes, an assign */
return|return;
block|}
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|,
name|b_act
argument_list|)
expr_stmt|;
comment|/* 		 * if the device has been unmounted by the user 		 * then throw away all requests until done 		 */
if|if
condition|(
operator|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_MOUNTED
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
operator|)
condition|)
block|{
comment|/* make sure that one implies the other.. */
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_MEDIA_LOADED
expr_stmt|;
goto|goto
name|badnews
goto|;
block|}
comment|/* 		 * only FIXEDBLOCK devices have pending operations 		 */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
comment|/* 			 * If we are at a filemark but have not reported it yet 			 * then we should report it now 			 */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
name|B_WRITE
condition|)
block|{
comment|/* 					 * Handling of ST_AT_FILEMARK in 					 * st_space will fill in the right file 					 * mark count. 					 * Back up over filemark 					 */
if|if
condition|(
name|st_space
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|SP_FILEMARKS
argument_list|,
literal|0
argument_list|)
operator|!=
name|ESUCCESS
condition|)
goto|goto
name|badnews
goto|;
block|}
else|else
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
comment|/* seek more work */
block|}
block|}
comment|/* 			 * If we are at EIO (e.g. EOM) but have not reported it 			 * yet then we should report it now 			 */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_EIO_PENDING
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
continue|continue;
comment|/* seek more work */
block|}
block|}
comment|/* 		 *  Fill out the scsi command 		 */
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
name|B_WRITE
condition|)
block|{
name|cmd
operator|.
name|op_code
operator|=
name|WRITE_COMMAND_TAPE
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FM_WRITTEN
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_WRITTEN
expr_stmt|;
name|flags
operator||=
name|SCSI_DATA_OUT
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|op_code
operator|=
name|READ_COMMAND_TAPE
expr_stmt|;
name|flags
operator||=
name|SCSI_DATA_IN
expr_stmt|;
block|}
comment|/* 		 * Handle "fixed-block-mode" tape drives by using the 		 * block count instead of the length. 		 */
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|cmd
operator|.
name|byte2
operator||=
name|SRWT_FIXED
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|bp
operator|->
name|b_bcount
operator|/
name|st
operator|->
name|blksiz
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsi_uto3b
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * go ask the adapter to do all this for us 		 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
literal|0
argument_list|,
comment|/* can't retry a read on a tape really */
literal|100000
argument_list|,
name|bp
argument_list|,
name|flags
argument_list|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{ 		}
else|else
block|{
name|badnews
label|:
name|printf
argument_list|(
literal|"st%ld: oops not queued\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* go back and see if we can cram more work in.. */
block|}
end_function

begin_comment
comment|/*  * Perform special action on behalf of the user;  * knows about the internals of this device  */
end_comment

begin_function
specifier|static
name|errval
name|st_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|errval
name|errcode
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|unit
decl_stmt|;
name|u_int32_t
name|number
decl_stmt|,
name|flags
decl_stmt|,
name|dsty
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
decl_stmt|;
name|u_int32_t
name|hold_blksiz
decl_stmt|;
name|u_int32_t
name|hold_density
decl_stmt|;
name|int32_t
name|nmarks
decl_stmt|;
name|struct
name|mtop
modifier|*
name|mt
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Find the device that the user is talking about 	 */
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* give error messages, act on errors etc. */
name|unit
operator|=
name|STUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
name|hold_blksiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
name|hold_density
operator|=
name|st
operator|->
name|density
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"[ioctl: get status]\n"
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
literal|0x7
expr_stmt|;
comment|/* Ultrix compat */
comment|/*? */
name|g
operator|->
name|mt_density
operator|=
name|st
operator|->
name|density
expr_stmt|;
name|g
operator|->
name|mt_blksiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
name|g
operator|->
name|mt_comp
operator|=
name|st
operator|->
name|comp
expr_stmt|;
name|g
operator|->
name|mt_density0
operator|=
name|st
operator|->
name|modes
index|[
literal|0
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_density1
operator|=
name|st
operator|->
name|modes
index|[
literal|1
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_density2
operator|=
name|st
operator|->
name|modes
index|[
literal|2
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_density3
operator|=
name|st
operator|->
name|modes
index|[
literal|3
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_blksiz0
operator|=
name|st
operator|->
name|modes
index|[
literal|0
index|]
operator|.
name|blksiz
expr_stmt|;
name|g
operator|->
name|mt_blksiz1
operator|=
name|st
operator|->
name|modes
index|[
literal|1
index|]
operator|.
name|blksiz
expr_stmt|;
name|g
operator|->
name|mt_blksiz2
operator|=
name|st
operator|->
name|modes
index|[
literal|2
index|]
operator|.
name|blksiz
expr_stmt|;
name|g
operator|->
name|mt_blksiz3
operator|=
name|st
operator|->
name|modes
index|[
literal|3
index|]
operator|.
name|blksiz
expr_stmt|;
name|g
operator|->
name|mt_comp0
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|mt_comp1
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|mt_comp2
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|mt_comp3
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"[ioctl: op=0x%x count=0x%lx]\n"
operator|,
name|mt
operator|->
name|mt_op
operator|,
name|mt
operator|->
name|mt_count
operator|)
argument_list|)
expr_stmt|;
comment|/* compat: in U*x it is a short */
name|number
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
name|mt
operator|->
name|mt_op
argument_list|)
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
name|errcode
operator|=
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
comment|/* backward space file */
name|number
operator|=
operator|-
name|number
expr_stmt|;
case|case
name|MTFSF
case|:
comment|/* forward space file */
name|errcode
operator|=
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
name|ESUCCESS
condition|)
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
operator|-
name|nmarks
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
name|number
operator|=
operator|-
name|number
expr_stmt|;
case|case
name|MTFSR
case|:
comment|/* forward space record */
name|errcode
operator|=
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
name|ESUCCESS
condition|)
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTEOD
case|:
comment|/* space to end of recorded medium */
name|errcode
operator|=
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|==
name|ESUCCESS
condition|)
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|SP_EOM
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
comment|/* rewind */
name|errcode
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTERASE
case|:
comment|/* erase */
name|errcode
operator|=
name|st_erase
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTRETENS
case|:
comment|/* re-tension tape */
name|errcode
operator|=
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_LOAD
operator||
name|LD_RETEN
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
name|st_unmount
argument_list|(
name|unit
argument_list|,
name|EJECT
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
break|break;
case|case
name|MTSETBSIZ
case|:
comment|/* Set block size for device */
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_NEW_MOUNT
operator|)
condition|)
block|{
name|uprintf
argument_list|(
literal|"re-mount tape before changing blocksize"
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|st
operator|->
name|blkmin
operator|||
name|st
operator|->
name|blkmax
operator|)
comment|/* they exist */
operator|&&
operator|(
operator|(
name|number
operator|<
name|st
operator|->
name|blkmin
operator|||
name|number
operator|>
name|st
operator|->
name|blkmax
operator|)
operator|)
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
name|st
operator|->
name|blksiz
operator|=
name|number
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_BLOCK_SET
expr_stmt|;
comment|/*XXX */
goto|goto
name|try_new_value
goto|;
case|case
name|MTSETDNSTY
case|:
comment|/* Set density for device and mode */
if|if
condition|(
name|number
operator|>
name|SCSI_2_MAX_DENSITY_CODE
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|density
operator|=
name|number
expr_stmt|;
block|}
goto|goto
name|try_new_value
goto|;
case|case
name|MTCOMP
case|:
comment|/* enable default compression */
name|errcode
operator|=
name|st_comp
argument_list|(
name|unit
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
break|break;
default|default:
if|if
condition|(
name|IS_CTLMODE
argument_list|(
name|dev
argument_list|)
condition|)
name|errcode
operator|=
name|scsi_do_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|flag
argument_list|,
name|p
argument_list|,
name|sc_link
argument_list|)
expr_stmt|;
else|else
name|errcode
operator|=
name|ENOTTY
expr_stmt|;
break|break;
block|}
return|return
name|errcode
return|;
comment|/*-----------------------------*/
name|try_new_value
label|:
comment|/* 	 * Check that the mode being asked for is aggreeable to the 	 * drive. If not, put it back the way it was. 	 */
if|if
condition|(
operator|(
name|errcode
operator|=
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
comment|/* put back as it was */
name|printf
argument_list|(
literal|"st%ld: Cannot set selected mode"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|density
operator|=
name|hold_density
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
name|hold_blksiz
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|blksiz
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
return|return
operator|(
name|errcode
operator|)
return|;
block|}
comment|/* 	 * As the drive liked it, if we are setting a new default, 	 * set it into the structures as such. 	 * 	 * The means for deciding this are not finalised yet 	 */
if|if
condition|(
name|IS_CTLMODE
argument_list|(
name|dev
argument_list|)
condition|)
block|{
comment|/* special mode */
comment|/* XXX */
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
name|mt
operator|->
name|mt_op
argument_list|)
condition|)
block|{
case|case
name|MTSETBSIZ
case|:
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|blksiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
name|st
operator|->
name|modeflags
index|[
name|dsty
index|]
operator||=
name|BLKSIZE_SET_BY_USER
expr_stmt|;
break|break;
case|case
name|MTSETDNSTY
case|:
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|density
operator|=
name|st
operator|->
name|density
expr_stmt|;
name|st
operator|->
name|modeflags
index|[
name|dsty
index|]
operator||=
name|DENSITY_SET_BY_USER
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Do a synchronous read.  */
end_comment

begin_function
specifier|static
name|errval
name|st_read
parameter_list|(
name|unit
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|size
decl_stmt|,
name|flags
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|scsi_rw_tape
name|scsi_cmd
decl_stmt|;
comment|/* 	 * If it's a null transfer, return immediatly 	 */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ESUCCESS
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_COMMAND_TAPE
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|scsi_cmd
operator|.
name|byte2
operator||=
name|SRWT_FIXED
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|size
operator|/
operator|(
name|st
operator|->
name|blksiz
condition|?
name|st
operator|->
name|blksiz
else|:
name|DEF_FIXED_BSIZE
operator|)
argument_list|,
name|scsi_cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|scsi_uto3b
argument_list|(
name|size
argument_list|,
name|scsi_cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|buf
argument_list|,
name|size
argument_list|,
literal|0
argument_list|,
comment|/* not on io commands */
literal|100000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a##_1)<< 8) + (unsigned)a##_0 )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a
comment|/**/
value|_1)<< 8) + (unsigned)a
comment|/**/
value|_0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Ask the drive what it's min and max blk sizes are.  */
end_comment

begin_function
specifier|static
name|errval
name|st_rd_blk_lim
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|scsi_blk_limits
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_blk_limits_data
name|scsi_blkl
decl_stmt|;
name|errval
name|errno
decl_stmt|;
comment|/* 	 * First check if we have it all loaded 	 */
if|if
condition|(
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * do a 'Read Block Limits' 	 */
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_BLK_LIMITS
expr_stmt|;
comment|/* 	 * do the command, update the global values 	 */
if|if
condition|(
operator|(
name|errno
operator|=
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scsi_blkl
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_blkl
argument_list|)
argument_list|,
name|ST_RETRIES
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|)
condition|)
block|{
return|return
name|errno
return|;
block|}
name|st
operator|->
name|blkmin
operator|=
name|b2tol
argument_list|(
name|scsi_blkl
operator|.
name|min_length
argument_list|)
expr_stmt|;
name|st
operator|->
name|blkmax
operator|=
name|scsi_3btou
argument_list|(
operator|&
name|scsi_blkl
operator|.
name|max_length_2
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"(%ld<= blksiz<= %ld)\n"
operator|,
name|st
operator|->
name|blkmin
operator|,
name|st
operator|->
name|blkmax
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Get the scsi driver to send a full inquiry to the  * device and use the results to fill out the global  * parameter structure.  *  * called from:  * attach  * open  * ioctl (to reset original blksize)  */
end_comment

begin_function
specifier|static
name|errval
name|st_mode_sense
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|,
name|page
parameter_list|,
name|pagelen
parameter_list|,
name|pagecode
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|tape_pages
modifier|*
name|page
decl_stmt|;
name|u_int32_t
name|pagelen
decl_stmt|,
name|pagecode
decl_stmt|;
block|{
name|u_int32_t
name|dat_len
decl_stmt|;
name|errval
name|errno
decl_stmt|;
name|struct
name|scsi_mode_sense
name|scsi_cmd
decl_stmt|;
struct|struct
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|struct
name|tape_pages
name|page
decl_stmt|;
block|}
name|dat
struct|;
comment|/* Tandberg tape drives returns page 00 	 * with the sense data, whether or not 	 * you want it( ie the don't like you 	 * saying you want anything less!!!!! 	 * They also expect page 00 	 * back when you issue a mode select 	 */
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_SENSE_READ
expr_stmt|;
comment|/* 	 * Check if we need to use a default page.. 	 */
if|if
condition|(
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
operator|)
operator|&&
operator|(
operator|!
name|page
operator|)
condition|)
block|{
name|pagelen
operator|=
name|PAGE_0_SENSE_DATA_SIZE
expr_stmt|;
name|page
operator|=
operator|(
expr|struct
name|tape_pages
operator|*
operator|)
name|st
operator|->
name|saved_page0
expr_stmt|;
name|pagecode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Now work out the total dat size etc. 	 */
name|dat_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|blk_desc
argument_list|)
operator|+
operator|(
name|page
condition|?
name|pagelen
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Set up a mode sense 	 */
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|page
operator|=
operator|(
name|u_char
operator|)
name|pagecode
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
name|dat_len
expr_stmt|;
comment|/* 	 * do the command, 	 * use the results to set blksiz, numblks and density 	 * or if we need it as a template for the mode select 	 * store it away. 	 */
if|if
condition|(
operator|(
name|errno
operator|=
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|dat
argument_list|,
name|dat_len
argument_list|,
name|ST_RETRIES
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|)
condition|)
block|{
return|return
name|errno
return|;
block|}
name|st
operator|->
name|numblks
operator|=
name|scsi_3btou
argument_list|(
name|dat
operator|.
name|blk_desc
operator|.
name|nblocks
argument_list|)
expr_stmt|;
name|st
operator|->
name|media_blksiz
operator|=
name|scsi_3btou
argument_list|(
name|dat
operator|.
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
name|st
operator|->
name|media_density
operator|=
name|dat
operator|.
name|blk_desc
operator|.
name|density
expr_stmt|;
if|if
condition|(
name|dat
operator|.
name|header
operator|.
name|dev_spec
operator|&
name|SMH_DSP_WRITE_PROT
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_READONLY
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"density code 0x%lx, %ld-byte blocks, write-%s, "
operator|,
name|st
operator|->
name|media_density
operator|,
name|st
operator|->
name|media_blksiz
operator|,
name|st
operator|->
name|flags
operator|&
name|ST_READONLY
condition|?
literal|"protected"
else|:
literal|"enabled"
operator|)
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"%sbuffered\n"
operator|,
operator|(
operator|(
name|dat
operator|.
name|header
operator|.
name|dev_spec
operator|&
name|SMH_DSP_BUFF_MODE
operator|)
condition|?
literal|""
else|:
literal|"un"
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|page
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|dat
operator|.
name|page
argument_list|,
name|page
argument_list|,
name|pagelen
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|flags
operator||=
name|ST_SENSE_READ
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a filled out parameter structure to the drive to  * set it into the desire modes etc.  */
end_comment

begin_function
specifier|static
name|errval
name|st_mode_select
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|,
name|page
parameter_list|,
name|pagelen
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|tape_pages
modifier|*
name|page
decl_stmt|;
name|u_int32_t
name|pagelen
decl_stmt|;
block|{
name|u_int32_t
name|dat_len
decl_stmt|;
name|struct
name|scsi_mode_select
name|scsi_cmd
decl_stmt|;
struct|struct
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|struct
name|tape_pages
name|page
decl_stmt|;
block|}
name|dat
struct|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
comment|/* 	 * Check if we need to use a default page.. 	 * Gee, hope we saved one before now........ 	 */
if|if
condition|(
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
operator|)
operator|&&
operator|(
operator|!
name|page
operator|)
condition|)
block|{
name|pagelen
operator|=
name|PAGE_0_SENSE_DATA_SIZE
expr_stmt|;
name|page
operator|=
operator|(
expr|struct
name|tape_pages
operator|*
operator|)
name|st
operator|->
name|saved_page0
expr_stmt|;
block|}
comment|/* 	 * Now work out the total dat size etc. 	 */
name|dat_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_mode_header
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|blk_desc
argument_list|)
operator|+
operator|(
name|page
condition|?
name|pagelen
else|:
literal|0
operator|)
expr_stmt|;
comment|/* 	 * Set up for a mode select 	 */
name|bzero
argument_list|(
operator|&
name|dat
argument_list|,
name|dat_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SELECT
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
name|dat_len
expr_stmt|;
name|dat
operator|.
name|header
operator|.
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|blk_desc
argument_list|)
expr_stmt|;
name|dat
operator|.
name|header
operator|.
name|dev_spec
operator||=
name|SMH_DSP_BUFF_MODE_ON
expr_stmt|;
name|dat
operator|.
name|blk_desc
operator|.
name|density
operator|=
name|st
operator|->
name|density
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|scsi_uto3b
argument_list|(
name|st
operator|->
name|blksiz
argument_list|,
name|dat
operator|.
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|page
condition|)
block|{
name|bcopy
argument_list|(
name|page
argument_list|,
operator|&
name|dat
operator|.
name|page
argument_list|,
name|pagelen
argument_list|)
expr_stmt|;
comment|/* the Tandberg tapes need the block size to */
comment|/* be set on each mode sense/select. */
block|}
comment|/* 	 * do the command 	 */
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|dat
argument_list|,
name|dat_len
argument_list|,
name|ST_RETRIES
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_OUT
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|noisy_st
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***************************************************************\ * Set the compression mode of the drive to on (1) or off (0)	* 	still doesn't work! grrr! \***************************************************************/
end_comment

begin_function
specifier|static
name|errval
name|st_comp
parameter_list|(
name|unit
parameter_list|,
name|mode
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|mode
decl_stmt|;
block|{
name|struct
name|tape_pages
name|page
decl_stmt|;
name|int
name|pagesize
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|page
argument_list|,
sizeof|sizeof
argument_list|(
name|page
argument_list|)
argument_list|)
expr_stmt|;
name|pagesize
operator|=
sizeof|sizeof
argument_list|(
name|page
operator|.
name|pages
operator|.
name|configuration
argument_list|)
operator|+
name|PAGE_HEADERLEN
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
operator|&
name|page
argument_list|,
name|pagesize
argument_list|,
name|ST_PAGE_CONFIGURATION
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"sense returned an error of %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
if|if
condition|(
name|noisy_st
condition|)
name|printf
argument_list|(
literal|"drive reports value of %d, setting %ld\n"
argument_list|,
name|page
operator|.
name|pages
operator|.
name|configuration
operator|.
name|data_compress_alg
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|page
operator|.
name|pg_code
operator|&=
name|ST_P_CODE
expr_stmt|;
name|page
operator|.
name|pg_length
operator|=
sizeof|sizeof
argument_list|(
name|page
operator|.
name|pages
operator|.
name|configuration
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
name|page
operator|.
name|pages
operator|.
name|configuration
operator|.
name|data_compress_alg
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|page
operator|.
name|pages
operator|.
name|configuration
operator|.
name|data_compress_alg
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%ld: bad value for compression mode\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
operator|(
name|retval
operator|=
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
operator|&
name|page
argument_list|,
name|pagesize
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"select returned an error of %d\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
name|st
operator|->
name|comp
operator|=
name|mode
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * skip N blocks/filemarks/seq filemarks/eom  */
end_comment

begin_function
specifier|static
name|errval
name|st_space
parameter_list|(
name|unit
parameter_list|,
name|number
parameter_list|,
name|what
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|what
decl_stmt|,
name|flags
decl_stmt|;
name|int32_t
name|number
decl_stmt|;
block|{
name|errval
name|error
decl_stmt|;
name|struct
name|scsi_space
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|what
condition|)
block|{
case|case
name|SP_BLKS
case|:
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_PER_ACTION
condition|)
block|{
if|if
condition|(
name|number
operator|>
literal|0
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
comment|/* 					 * Handling of ST_AT_FILEMARK 					 * in st_space will fill in the 					 * right file mark count. 					 */
name|error
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_BLANK_READ
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_BLANK_READ
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SP_FILEMARKS
case|:
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_EIO_PENDING
condition|)
block|{
if|if
condition|(
name|number
operator|>
literal|0
condition|)
block|{
comment|/* pretend we just discover the error */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
comment|/* back away from the error */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
block|}
block|}
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|number
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_BLANK_READ
operator|)
operator|&&
operator|(
name|number
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* back away from unwritten tape */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_BLANK_READ
expr_stmt|;
name|number
operator|++
expr_stmt|;
comment|/* dubious */
block|}
break|break;
case|case
name|SP_EOM
case|:
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_EIO_PENDING
condition|)
block|{
comment|/* we are already at EOM */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
return|return
operator|(
name|ESUCCESS
operator|)
return|;
block|}
name|number
operator|=
literal|1
expr_stmt|;
comment|/* we have only one end-of-medium */
break|break;
block|}
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ESUCCESS
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|what
operator|&
name|SS_CODE
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* no retries please , just fail */
literal|3600000
argument_list|,
comment|/* wait up to an hour for completion */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * write N filemarks  */
end_comment

begin_function
specifier|static
name|errval
name|st_write_filemarks
parameter_list|(
name|unit
parameter_list|,
name|number
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|int32_t
name|number
decl_stmt|;
block|{
name|struct
name|scsi_write_filemarks
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
comment|/* 	 * It's hard to write a negative number of file marks. 	 * Don't try. 	 */
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
return|return
name|EINVAL
return|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|number
condition|)
block|{
case|case
literal|0
case|:
comment|/* really a command to sync the drive's buffers */
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FM_WRITTEN
condition|)
block|{
comment|/* already have one down */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_WRITTEN
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FM_WRITTEN
expr_stmt|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
break|break;
default|default:
name|st
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ST_PER_ACTION
operator||
name|ST_WRITTEN
operator|)
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
name|scsi_uto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
return|return
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* no retries, just fail */
literal|100000
argument_list|,
comment|/* 10 secs.. (may need to repos head ) */
name|NULL
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure the right number of file marks is on tape if the  * tape has been written.  If the position argument is true,  * leave the tape positioned where it was originally.  *  * nmarks returns the number of marks to skip (or, if position  * true, which were skipped) to get back original position.  */
end_comment

begin_function
specifier|static
name|int32_t
name|st_chkeod
parameter_list|(
name|unit
parameter_list|,
name|position
parameter_list|,
name|nmarks
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|;
name|boolean
name|position
decl_stmt|;
name|int32_t
modifier|*
name|nmarks
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|errval
name|error
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|SCSI_DATA
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|st
operator|->
name|flags
operator|&
operator|(
name|ST_WRITTEN
operator||
name|ST_FM_WRITTEN
operator||
name|ST_2FM_AT_EOD
operator|)
argument_list|)
condition|)
block|{
default|default:
operator|*
name|nmarks
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
name|ST_WRITTEN
case|:
case|case
name|ST_WRITTEN
operator||
name|ST_FM_WRITTEN
operator||
name|ST_2FM_AT_EOD
case|:
operator|*
name|nmarks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ST_WRITTEN
operator||
name|ST_2FM_AT_EOD
case|:
operator|*
name|nmarks
operator|=
literal|2
expr_stmt|;
block|}
name|error
operator|=
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
operator|*
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|position
operator|&&
operator|(
name|error
operator|==
name|ESUCCESS
operator|)
condition|)
name|error
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
operator|*
name|nmarks
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * load/unload (with retension if true)  */
end_comment

begin_function
specifier|static
name|errval
name|st_load
parameter_list|(
name|unit
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_load
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|LD_LOAD
condition|)
block|{
name|errval
name|error
decl_stmt|;
name|int32_t
name|nmarks
decl_stmt|;
name|error
operator|=
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESUCCESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_MEDIA_LOADED
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_IGNORE_LOADS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|LOAD_UNLOAD
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator||=
name|type
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ST_RETRIES
argument_list|,
literal|900000
argument_list|,
comment|/* 15 min */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Rewind the device  */
end_comment

begin_function
specifier|static
name|errval
name|st_rewind
parameter_list|(
name|unit
parameter_list|,
name|immed
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|boolean
name|immed
decl_stmt|;
block|{
name|struct
name|scsi_rewind
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|errval
name|error
decl_stmt|;
name|int32_t
name|nmarks
decl_stmt|;
name|error
operator|=
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESUCCESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REWIND
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|immed
condition|?
name|SR_IMMED
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ST_RETRIES
argument_list|,
name|immed
condition|?
literal|5000
else|:
literal|300000
argument_list|,
comment|/* 5 sec or 5 min */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **  Erase the device */
end_comment

begin_function
specifier|static
name|errval
name|st_erase
parameter_list|(
name|unit
parameter_list|,
name|immed
parameter_list|,
name|flags
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|boolean
name|immed
decl_stmt|;
block|{
name|struct
name|scsi_erase
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|errval
name|error
decl_stmt|;
name|int32_t
name|nmarks
decl_stmt|;
name|error
operator|=
name|st_chkeod
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
operator|&
name|nmarks
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESUCCESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	**      Archive Viper 2525 technical manual 5.7 (ERASE 19h): 	**	tape has to be positioned to BOT first before erase command 	**	is issued or command is rejected. So we rewind the tape first 	**	and exit with an error, if the tape can't be rewinded. 	*/
name|error
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
name|ESUCCESS
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|ERASE
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|SE_LONG
expr_stmt|;
comment|/* LONG_ERASE */
name|scsi_cmd
operator|.
name|byte2
operator|+=
name|immed
condition|?
name|SE_IMMED
else|:
literal|0
expr_stmt|;
comment|/* immed bit is here the 2nd! */
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ST_RETRIES
argument_list|,
name|immed
condition|?
literal|5000
else|:
literal|300000
argument_list|,
comment|/* 5 sec or 5 min */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look at the returned sense and act on the error and detirmine  * The unix error number to pass back... (0 = report no error)  *                            (SCSIRET_CONTINUE = continue processing)  */
end_comment

begin_function
specifier|static
name|errval
name|st_interpret_sense
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|scsi_sense_data
modifier|*
name|sense
init|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
decl_stmt|;
name|boolean
name|silent
init|=
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
decl_stmt|;
name|u_int32_t
name|unit
init|=
name|sc_link
operator|->
name|dev_unit
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|SCSI_DATA
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|u_int32_t
name|key
decl_stmt|;
name|int32_t
name|info
decl_stmt|;
comment|/* 	 * Get the sense fields and work out what code 	 */
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|info
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|int32_t
operator|*
operator|)
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|info
operator|=
name|xs
operator|->
name|datalen
operator|/
name|st
operator|->
name|blksiz
expr_stmt|;
block|}
else|else
block|{
name|info
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|!=
literal|0x70
condition|)
block|{
return|return
name|SCSIRET_CONTINUE
return|;
comment|/* let the generic code handle it */
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
operator|(
name|SSD_EOM
operator||
name|SSD_FILEMARK
operator||
name|SSD_ILI
operator|)
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|xs
operator|->
name|resid
operator|=
name|info
operator|*
name|st
operator|->
name|blksiz
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_EIO_PENDING
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_AT_FILEMARK
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_EIO_PENDING
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
operator|&&
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%ld: block wrong size"
literal|", %ld blocks residual\n"
argument_list|,
name|unit
argument_list|,
name|info
argument_list|)
expr_stmt|;
comment|/*XXX*/
comment|/* is this how it works ? */
comment|/* check def of ILI for fixed blk tapes */
comment|/* 			 	 * This quirk code helps the drive read 			 	 * the first tape block, regardless of 			 	 * format.  That is required for these 			 	 * drives to return proper MODE SENSE 			 	 * information. 			 	 */
if|if
condition|(
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_SNS_HLP
operator|)
operator|&&
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_SENSE_READ
operator|)
condition|)
block|{
name|st
operator|->
name|blksiz
operator|-=
literal|512
expr_stmt|;
block|}
block|}
comment|/* 			 * If no data was tranfered, do it immediatly 			 */
if|if
condition|(
name|xs
operator|->
name|resid
operator|>=
name|xs
operator|->
name|datalen
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|SCSI_RESID_VALID
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|xs
operator|->
name|flags
operator||=
name|SCSI_EOF
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_EIO_PENDING
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
return|return
name|EIO
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* must be variable mode */
name|xs
operator|->
name|resid
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
comment|/* to be sure */
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|)
block|{
name|xs
operator|->
name|flags
operator||=
name|SCSI_EOF
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
if|if
condition|(
name|info
operator|<
literal|0
condition|)
block|{
comment|/* 					 * the record was bigger than the read 					 */
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%ld: %ld-byte record "
literal|"too big\n"
argument_list|,
name|unit
argument_list|,
name|xs
operator|->
name|datalen
operator|-
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|xs
operator|->
name|resid
operator|=
name|info
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
name|key
operator|=
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|0x8
condition|)
block|{
name|xs
operator|->
name|flags
operator||=
name|SCSI_EOF
expr_stmt|;
comment|/* some drives need this */
comment|/* 		 * This quirk code helps the drive read the 		 * first tape block, regardless of format.  That 		 * is required for these drives to return proper 		 * MODE SENSE information. 		 */
if|if
condition|(
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_SNS_HLP
operator|)
operator|&&
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_SENSE_READ
operator|)
condition|)
block|{
comment|/* still starting */
name|st
operator|->
name|blksiz
operator|-=
literal|512
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
operator|(
name|ST_2FM_AT_EOD
operator||
name|ST_BLANK_READ
operator|)
operator|)
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_BLANK_READ
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_EOF
expr_stmt|;
return|return
operator|(
name|ESUCCESS
operator|)
return|;
block|}
block|}
return|return
name|SCSIRET_CONTINUE
return|;
comment|/* Use the the generic handler */
block|}
end_function

begin_comment
comment|/*  * The quirk here is that the drive returns some value to st_mode_sense  * incorrectly until the tape has actually passed by the head.  *  * The method is to set the drive to large fixed-block state (user-specified  * density and 1024-byte blocks), then read and rewind to get it to sense the  * tape.  If that doesn't work, try 512-byte fixed blocks.  If that doesn't  * work, as a last resort, try variable- length blocks.  The result will be  * the ability to do an accurate st_mode_sense.  *  * We know we can do a rewind because we just did a load, which implies rewind.  * Rewind seems preferable to space backward if we have a virgin tape.  *  * The rest of the code for this quirk is in ILI processing and BLANK CHECK  * error processing, both part of st_interpret_sense.  */
end_comment

begin_function
specifier|static
name|errval
name|st_touch_tape
parameter_list|(
name|unit
parameter_list|)
name|u_int32_t
name|unit
decl_stmt|;
block|{
name|struct
name|scsi_data
modifier|*
name|st
init|=
name|SCSI_DATA
argument_list|(
operator|&
name|st_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|u_int32_t
name|readsiz
decl_stmt|;
name|errval
name|errno
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
operator|(
name|errno
operator|=
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|st
operator|->
name|blksiz
operator|=
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NO_1024
operator|)
condition|?
literal|512
else|:
literal|1024
expr_stmt|;
do|do
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|st
operator|->
name|blksiz
condition|)
block|{
case|case
literal|512
case|:
case|case
literal|1024
case|:
name|readsiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
break|break;
default|default:
name|readsiz
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|errno
operator|=
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|st_read
argument_list|(
name|unit
argument_list|,
name|buf
argument_list|,
name|readsiz
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errno
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|bad
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
block|}
do|while
condition|(
name|readsiz
operator|!=
literal|1
operator|&&
name|readsiz
operator|>
name|st
operator|->
name|blksiz
condition|)
do|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|st_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|st_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
name|dev_t
name|dev
decl_stmt|;
if|if
condition|(
operator|!
name|st_devsw_installed
condition|)
block|{
name|dev
operator|=
name|makedev
argument_list|(
name|CDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|st_cdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|=
name|makedev
argument_list|(
name|BDEV_MAJOR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bdevsw_add
argument_list|(
operator|&
name|dev
argument_list|,
operator|&
name|st_bdevsw
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|st_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|stdev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|st_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

