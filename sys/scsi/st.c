begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)(now julian@DIALix.oz.au)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  * major changes by Julian Elischer (julian@jules.dialix.oz.au) May 1993  *  *	$Id$  */
end_comment

begin_comment
comment|/*  * To do:  * work out some better way of guessing what a good timeout is going  * to be depending on whether we expect to retension or not.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<st.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
end_if

begin_define
define|#
directive|define
name|SECSIZE
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OSF) */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_tape.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_decl_stmt
name|long
name|int
name|ststrats
decl_stmt|,
name|stqueues
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defines for device specific stuff */
end_comment

begin_define
define|#
directive|define
name|PAGE_0_SENSE_DATA_SIZE
value|12
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|DEF_FIXED_BSIZE
value|512
end_define

begin_define
define|#
directive|define
name|STQSIZE
value|4
end_define

begin_define
define|#
directive|define
name|ST_RETRIES
value|4
end_define

begin_define
define|#
directive|define
name|MODE
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)& 0x03) )
end_define

begin_define
define|#
directive|define
name|DSTY
parameter_list|(
name|z
parameter_list|)
value|( ((minor(z)>> 2)& 0x03) )
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)>> 4) )
end_define

begin_define
define|#
directive|define
name|LOW_DSTY
value|3
end_define

begin_define
define|#
directive|define
name|MED_DSTY
value|2
end_define

begin_define
define|#
directive|define
name|HIGH_DSTY
value|1
end_define

begin_define
define|#
directive|define
name|SCSI_2_MAX_DENSITY_CODE
value|0x17
end_define

begin_comment
comment|/* maximum density code specified 					   in SCSI II spec. */
end_comment

begin_comment
comment|/***************************************************************\ * Define various devices that we know mis-behave in some way,	* * and note how they are bad, so we can correct for them		* \***************************************************************/
end_comment

begin_struct
struct|struct
name|modes
block|{
name|int
name|quirks
decl_stmt|;
comment|/* same definitions as in rogues */
name|char
name|density
decl_stmt|;
name|char
name|spare
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rogues
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|manu
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|quirks
decl_stmt|;
comment|/* valid for all modes */
name|struct
name|modes
name|modes
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* define behaviour codes (quirks) */
end_comment

begin_define
define|#
directive|define
name|ST_Q_NEEDS_PAGE_0
value|0x00001
end_define

begin_define
define|#
directive|define
name|ST_Q_FORCE_FIXED_MODE
value|0x00002
end_define

begin_define
define|#
directive|define
name|ST_Q_FORCE_VAR_MODE
value|0x00004
end_define

begin_decl_stmt
specifier|static
name|struct
name|rogues
name|gallery
index|[]
init|=
comment|/* ends with an all null entry */
block|{
block|{
literal|"Such an old device "
block|,
literal|"pre-scsi"
block|,
literal|" unknown model  "
block|,
literal|"????"
block|,
literal|0
block|,
block|{
block|{
name|ST_Q_FORCE_FIXED_MODE
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3 */
block|{
name|ST_Q_FORCE_FIXED_MODE
block|,
name|QIC_24
block|}
block|,
comment|/* minor  4,5,6,7 */
block|{
name|ST_Q_FORCE_VAR_MODE
block|,
name|HALFINCH_1600
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
name|ST_Q_FORCE_VAR_MODE
block|,
name|HALFINCH_6250
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
literal|"Tandberg tdc3600"
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3600"
block|,
literal|"????"
block|,
name|ST_Q_NEEDS_PAGE_0
block|,
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3*/
block|{
name|ST_Q_FORCE_VAR_MODE
block|,
name|QIC_525
block|}
block|,
comment|/* minor  4,5,6,7*/
block|{
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
literal|0
block|,
name|QIC_120
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
literal|"Archive  Viper 150"
block|,
literal|"ARCHIVE "
block|,
literal|"VIPER 150"
block|,
literal|"????"
block|,
name|ST_Q_NEEDS_PAGE_0
block|,
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3*/
block|{
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor  4,5,6,7*/
block|{
literal|0
block|,
name|QIC_120
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
literal|0
block|,
name|QIC_24
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|__386BSD__
end_ifndef

begin_decl_stmt
name|struct
name|buf
name|stbuf
index|[
name|NST
index|]
index|[
name|STQSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for raw io (one per device) */
end_comment

begin_decl_stmt
name|struct
name|buf
modifier|*
name|stbuf_free
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of free buffers for raw io */
end_comment

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_decl_stmt
name|struct
name|buf
name|st_buf_queue
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ststrategy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stminphys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|scsi_xfer
name|st_scsi_xfer
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|st_xfer_block_wait
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
end_if

begin_decl_stmt
name|caddr_t
name|st_window
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OSF) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MACH
end_ifndef

begin_define
define|#
directive|define
name|ESUCCESS
value|0
end_define

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_decl_stmt
name|int
name|st_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|stattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|st_done
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|st_data
block|{
comment|/*--------------------present operating parameters, flags etc.----------------*/
name|int
name|flags
decl_stmt|;
comment|/* see below 			      */
name|int
name|blksiz
decl_stmt|;
comment|/* blksiz we are using		      */
name|int
name|density
decl_stmt|;
comment|/* present density 		      */
name|int
name|quirks
decl_stmt|;
comment|/* quirks for the open mode	      */
name|int
name|last_dsty
decl_stmt|;
comment|/* last density used		      */
comment|/*--------------------device/scsi parameters----------------------------------*/
name|struct
name|scsi_switch
modifier|*
name|sc_sw
decl_stmt|;
comment|/* address of scsi low level switch   */
name|int
name|ctlr
decl_stmt|;
comment|/* so they know which one we want     */
name|int
name|targ
decl_stmt|;
comment|/* our scsi target ID 		      */
name|int
name|lu
decl_stmt|;
comment|/* our scsi lu 			      */
comment|/*--------------------parameters reported by the device ----------------------*/
name|int
name|blkmin
decl_stmt|;
comment|/* min blk size 		      */
name|int
name|blkmax
decl_stmt|;
comment|/* max blk size 		      */
comment|/*--------------------parameters reported by the device for this media--------*/
name|int
name|numblks
decl_stmt|;
comment|/* nominal blocks capacity 	      */
name|int
name|media_blksiz
decl_stmt|;
comment|/* 0 if not ST_FIXEDBLOCKS 	      */
name|int
name|media_density
decl_stmt|;
comment|/* this is what it said when asked    */
comment|/*--------------------quirks for the whole drive------------------------------*/
name|int
name|drive_quirks
decl_stmt|;
comment|/* quirks of this drive		      */
comment|/*--------------------How we should set up when openning each minor device----*/
name|struct
name|modes
name|modes
index|[
literal|4
index|]
decl_stmt|;
comment|/* plus more for each mode 	      */
comment|/*--------------------storage for sense data returned by the drive------------*/
name|unsigned
name|char
name|sense_data
index|[
literal|12
index|]
decl_stmt|;
comment|/* additional sense data needed       */
comment|/* for mode sense/select. 	      */
block|}
name|st_data
index|[
name|NST
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|ST_INITIALIZED
value|0x01
end_define

begin_define
define|#
directive|define
name|ST_INFO_VALID
value|0x02
end_define

begin_define
define|#
directive|define
name|ST_OPEN
value|0x04
end_define

begin_define
define|#
directive|define
name|ST_WRITTEN
value|0x10
end_define

begin_define
define|#
directive|define
name|ST_FIXEDBLOCKS
value|0x20
end_define

begin_define
define|#
directive|define
name|ST_AT_FILEMARK
value|0x40
end_define

begin_define
define|#
directive|define
name|ST_AT_EOM
value|0x80
end_define

begin_define
define|#
directive|define
name|ST_PER_ACTION
value|(ST_AT_FILEMARK | ST_AT_EOM)
end_define

begin_define
define|#
directive|define
name|ST_PER_OPEN
value|(ST_OPEN | ST_WRITTEN | ST_PER_ACTION)
end_define

begin_define
define|#
directive|define
name|ST_PER_MEDIA
value|ST_FIXEDBLOCKS
end_define

begin_decl_stmt
specifier|static
name|int
name|next_st_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************\ * The routine called by the low level scsi routine when it discovers	* * A device suitable for this driver					* \***********************************************************************/
end_comment

begin_function
name|int
name|stattach
parameter_list|(
name|ctlr
parameter_list|,
name|targ
parameter_list|,
name|lu
parameter_list|,
name|scsi_switch
parameter_list|)
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"stattach: "
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Check we have the resources for another drive		* 	\*******************************************************/
name|unit
operator|=
name|next_st_unit
operator|++
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NST
condition|)
block|{
name|printf
argument_list|(
literal|"Too many scsi tapes..(%d> %d) reconfigure kernel\n"
argument_list|,
operator|(
name|unit
operator|+
literal|1
operator|)
argument_list|,
name|NST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
comment|/*******************************************************\ 	* Store information needed to contact our base driver	* 	\*******************************************************/
name|st
operator|->
name|sc_sw
operator|=
name|scsi_switch
expr_stmt|;
name|st
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|st
operator|->
name|targ
operator|=
name|targ
expr_stmt|;
name|st
operator|->
name|lu
operator|=
name|lu
expr_stmt|;
comment|/*******************************************************\ 	* Store information about default densities 		* 	\*******************************************************/
name|st
operator|->
name|modes
index|[
name|HIGH_DSTY
index|]
operator|.
name|density
operator|=
name|QIC_525
expr_stmt|;
name|st
operator|->
name|modes
index|[
name|MED_DSTY
index|]
operator|.
name|density
operator|=
name|QIC_150
expr_stmt|;
name|st
operator|->
name|modes
index|[
name|LOW_DSTY
index|]
operator|.
name|density
operator|=
name|QIC_120
expr_stmt|;
comment|/*******************************************************\ 	* Check if the drive is a known criminal and take	* 	* Any steps needed to bring it into line		* 	\*******************************************************/
name|st_identify_drive
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Use the subdriver to request information regarding	* 	* the drive. We cannot use interrupts yet, so the	* 	* request must specify this.				* 	\*******************************************************/
if|if
condition|(
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
if|if
condition|(
name|st_test_ready
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: tape present: %d blocks of %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|numblks
argument_list|,
name|st
operator|->
name|media_blksiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"st%d: drive empty\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|"st%d: drive offline\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Set up the bufs for this device			* 	\*******************************************************/
ifndef|#
directive|ifndef
name|__386BSD__
name|stbuf_free
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|STQSIZE
condition|;
name|i
operator|++
control|)
block|{
name|stbuf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|.
name|b_forw
operator|=
name|stbuf_free
index|[
name|unit
index|]
expr_stmt|;
name|stbuf_free
index|[
name|unit
index|]
operator|=
operator|&
name|stbuf
index|[
name|unit
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
endif|__386BSD__
name|st_buf_queue
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|st_buf_queue
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|st_buf_queue
index|[
name|unit
index|]
operator|.
name|b_actl
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
name|st_window
index|[
name|unit
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|alloc_kva
argument_list|(
name|SECSIZE
operator|*
literal|256
operator|+
name|PAGESIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(OSF) */
name|st
operator|->
name|flags
operator||=
name|ST_INITIALIZED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***********************************************************************\ * Use the identify routine in 'scsiconf' to get drive info so we can	* * Further tailor our behaviour.						* \***********************************************************************/
end_comment

begin_macro
name|st_identify_drive
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|struct
name|scsi_inquiry_data
name|inqbuf
decl_stmt|;
name|struct
name|rogues
modifier|*
name|finger
decl_stmt|;
name|char
name|manu
index|[
literal|32
index|]
decl_stmt|;
name|char
name|model
index|[
literal|32
index|]
decl_stmt|;
name|char
name|model2
index|[
literal|32
index|]
decl_stmt|;
name|char
name|version
index|[
literal|32
index|]
decl_stmt|;
name|int
name|model_len
decl_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
comment|/*******************************************************\ 	* Get the device type information                       * 	\*******************************************************/
if|if
condition|(
name|scsi_inquire
argument_list|(
name|st
operator|->
name|ctlr
argument_list|,
name|st
operator|->
name|targ
argument_list|,
name|st
operator|->
name|lu
argument_list|,
name|st
operator|->
name|sc_sw
argument_list|,
operator|&
name|inqbuf
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
operator|!=
name|COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: couldn't get device type, using default\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inqbuf
operator|.
name|version
operator|&
name|SID_ANSII
operator|)
operator|==
literal|0
condition|)
block|{
comment|/***********************************************\ 		* If not advanced enough, use default values    * 		\***********************************************/
name|strncpy
argument_list|(
name|manu
argument_list|,
literal|"pre-scsi"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|manu
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
literal|" unknown model  "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|model
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
literal|"????"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|version
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|manu
argument_list|,
name|inqbuf
operator|.
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|manu
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
name|inqbuf
operator|.
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|model
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
name|inqbuf
operator|.
name|revision
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|version
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Load the parameters for this kind of device, so we	* 	* treat it as appropriate for each operating mode 	* 	* Only check the number of characters in the array's	* 	* model entry, not the entire model string returned.	* 	\*******************************************************/
name|finger
operator|=
name|gallery
expr_stmt|;
while|while
condition|(
name|finger
operator|->
name|name
condition|)
block|{
name|model_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|finger
operator|->
name|model
index|[
name|model_len
index|]
operator|&&
operator|(
name|model_len
operator|<
literal|32
operator|)
condition|)
block|{
name|model2
index|[
name|model_len
index|]
operator|=
name|model
index|[
name|model_len
index|]
expr_stmt|;
name|model_len
operator|++
expr_stmt|;
block|}
name|model2
index|[
name|model_len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|manu
argument_list|,
name|finger
operator|->
name|manu
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|model2
argument_list|,
name|finger
operator|->
name|model
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: %s is a known rogue\n"
argument_list|,
name|unit
argument_list|,
name|finger
operator|->
name|name
argument_list|)
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|0
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|1
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|1
index|]
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|2
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|2
index|]
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|3
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|3
index|]
expr_stmt|;
name|st
operator|->
name|drive_quirks
operator|=
name|finger
operator|->
name|quirks
expr_stmt|;
name|st
operator|->
name|quirks
operator|=
name|finger
operator|->
name|quirks
expr_stmt|;
comment|/*start value*/
break|break;
block|}
else|else
block|{
name|finger
operator|++
expr_stmt|;
comment|/* go to next suspect */
block|}
block|}
block|}
end_block

begin_comment
comment|/*******************************************************\ *	open the device.				* \*******************************************************/
end_comment

begin_macro
name|stopen
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|dsty
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
comment|/*******************************************************\ 	* Check the unit is legal                               * 	\*******************************************************/
if|if
condition|(
name|unit
operator|>=
name|NST
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Only allow one at a time				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_OPEN
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Set up the mode flags according to the minor number	* 	* ensure all open flags are in a known state		* 	* if it's a different mode, dump all cached parameters	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|last_dsty
operator|!=
name|dsty
condition|)
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
name|st
operator|->
name|last_dsty
operator|=
name|dsty
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_OPEN
expr_stmt|;
name|st
operator|->
name|quirks
operator|=
name|st
operator|->
name|drive_quirks
operator||
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|quirks
expr_stmt|;
name|st
operator|->
name|density
operator|=
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|density
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
operator|(
name|PRINTROUTINES
operator||
name|TRACEOPENS
operator|)
condition|)
name|printf
argument_list|(
literal|"stopen: dev=0x%x (unit %d (of %d))\n"
argument_list|,
name|dev
argument_list|,
name|unit
argument_list|,
name|NST
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Make sure the device has been initialised		* 	\*******************************************************/
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INITIALIZED
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*******************************************************\ 	* Check that it is still responding and ok.		* 	\*******************************************************/
ifdef|#
directive|ifdef
name|removing_this
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"device is "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|st_req_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
comment|/* may get a 'unit attention' if new */
block|{
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"not responding\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|st_test_ready
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|st_test_ready
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
comment|/* first may get 'unit attn' */
block|{
name|printf
argument_list|(
literal|"st%d: not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/***************************************************************\ 	* If the media is new, then make sure we give it a chance to	* 	* to do a 'load' instruction. Possibly the test ready 		* 	* may not read true until this is done.. check this! XXX	* 	\***************************************************************/
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
comment|/* is media new? */
block|{
if|if
condition|(
operator|!
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_LOAD
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
comment|/*******************************************************\ 	* Load the physical device parameters			* 	* loads: blkmin, blkmax					* 	\*******************************************************/
if|if
condition|(
operator|!
name|st_rd_blk_lim
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Load the media dependent parameters			* 	* includes: media_blksiz,media_density,numblks		* 	\*******************************************************/
if|if
condition|(
operator|!
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/*******************************************************\ 	* From media parameters, device parameters and quirks,	* 	* work out how we should be setting outselves up	* 	\*******************************************************/
if|if
condition|(
operator|!
name|st_decide_mode
argument_list|(
name|unit
argument_list|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|!
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|st
operator|->
name|density
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|st
operator|->
name|flags
operator||=
name|ST_INFO_VALID
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_PREVENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* who cares if it fails? */
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"Params loaded "
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * close the device.. only called if we are the LAST	* * occurence of an open device				* \*******************************************************/
end_comment

begin_macro
name|stclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|unit
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"Closing device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_WRITTEN
condition|)
block|{
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_WRITTEN
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d:close: Bad mode (minor number)%d how's it open?\n"
argument_list|,
name|unit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***************************************************************\ * Given all we know about the device, media, mode and 'quirks',	* * make a decision as to how we should be set up.		* \***************************************************************/
end_comment

begin_macro
name|st_decide_mode
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|st
operator|->
name|quirks
operator|&
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator||
name|ST_Q_FORCE_VAR_MODE
operator|)
condition|)
block|{
case|case
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator||
name|ST_Q_FORCE_VAR_MODE
operator|)
case|:
name|printf
argument_list|(
literal|"st%d: bad quirks\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
case|case
literal|0
case|:
switch|switch
condition|(
name|st
operator|->
name|density
condition|)
block|{
case|case
name|QIC_120
case|:
case|case
name|QIC_150
case|:
goto|goto
name|fixed
goto|;
case|case
name|HALFINCH_800
case|:
case|case
name|HALFINCH_1600
case|:
case|case
name|HALFINCH_6250
case|:
case|case
name|QIC_525
case|:
goto|goto
name|var
goto|;
default|default:
break|break;
block|}
comment|/*******************************************************\ 		* There was once a reason that the tests below were	* 		* deemed insufficient, but I can't remember why..	* 		* If your drive needs these added to, let me know	* 		* and/or add a rogue entry.				* 		\*******************************************************/
if|if
condition|(
name|st
operator|->
name|blkmin
operator|&&
operator|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
operator|)
condition|)
goto|goto
name|fixed
goto|;
if|if
condition|(
name|st
operator|->
name|blkmin
operator|!=
name|st
operator|->
name|blkmax
condition|)
goto|goto
name|var
goto|;
case|case
name|ST_Q_FORCE_FIXED_MODE
case|:
name|fixed
label|:
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|media_blksiz
condition|)
block|{
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|st
operator|->
name|blkmin
condition|)
block|{
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|blkmin
expr_stmt|;
comment|/* just to make sure */
block|}
else|else
block|{
name|st
operator|->
name|blksiz
operator|=
name|DEF_FIXED_BSIZE
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ST_Q_FORCE_VAR_MODE
case|:
name|var
label|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|__386BSD__
end_ifndef

begin_comment
comment|/*******************************************************\ * Get ownership of this unit's buf			* * If need be, sleep on it, until it comes free		* \*******************************************************/
end_comment

begin_function
name|struct
name|buf
modifier|*
name|st_get_buf
parameter_list|(
name|unit
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|rc
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|rc
operator|=
name|stbuf_free
index|[
name|unit
index|]
operator|)
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stbuf_free
index|[
name|unit
index|]
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stbuf_free
index|[
name|unit
index|]
operator|=
name|stbuf_free
index|[
name|unit
index|]
operator|->
name|b_forw
expr_stmt|;
name|rc
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Free this unit's buf, wake processes waiting for it	* \*******************************************************/
end_comment

begin_macro
name|st_free_buf
argument_list|(
argument|unit
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|stbuf_free
index|[
name|unit
index|]
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stbuf_free
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_forw
operator|=
name|stbuf_free
index|[
name|unit
index|]
expr_stmt|;
name|stbuf_free
index|[
name|unit
index|]
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the buf for this unit and use physio to do it	* \*******************************************************/
end_comment

begin_expr_stmt
name|stread
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|)
specifier|register
name|short
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|st_get_buf
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|physio
argument_list|(
name|ststrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|stminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|st_free_buf
argument_list|(
name|unit
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the buf for this unit and use physio to do it	* \*******************************************************/
end_comment

begin_macro
name|stwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|st_get_buf
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|physio
argument_list|(
name|ststrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|stminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|st_free_buf
argument_list|(
name|unit
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_comment
comment|/*******************************************************\ * trim the size of the transfer if needed,		* * called by physio					* * basically the smaller of our min and the scsi driver's* * minphys						* \*******************************************************/
end_comment

begin_function
name|void
name|stminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
operator|(
operator|*
operator|(
name|st_data
index|[
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sc_sw
operator|->
name|scsi_minphys
operator|)
operator|)
operator|(
name|bp
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Actually translate the requested transfer into	* * one the physical driver can understand		* * The transfer is described by a buf and will include	* * only one physical transfer.				* \*******************************************************/
end_comment

begin_function
name|int
name|ststrategy
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|ststrats
operator|++
expr_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
operator|(
name|bp
operator|->
name|b_dev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"\nststrategy "
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWREQUESTS
condition|)
name|printf
argument_list|(
literal|"st%d: %d bytes @ blk%d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* If it's a null transfer, return immediatly		* 	\*******************************************************/
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*******************************************************\ 	* Odd sized request on fixed drives are verboten	* 	\*******************************************************/
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|%
name|st_data
index|[
name|unit
index|]
operator|.
name|blksiz
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: bad request, must be multiple of %d\n"
argument_list|,
name|unit
argument_list|,
name|st_data
index|[
name|unit
index|]
operator|.
name|blksiz
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/*******************************************************\ 	* as are too-short requests on variable length drives.	* 	\*******************************************************/
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|<
name|st_data
index|[
name|unit
index|]
operator|.
name|blkmin
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: bad request, must not be less than %d\n"
argument_list|,
name|unit
argument_list|,
name|st_data
index|[
name|unit
index|]
operator|.
name|blkmin
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|__386BSD__
name|stminphys
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|dp
operator|=
operator|&
name|st_buf_queue
index|[
name|unit
index|]
expr_stmt|;
comment|/*******************************************************\ 	* Place it in the queue of disk activities for this tape* 	* at the end						* 	\*******************************************************/
while|while
condition|(
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
block|}
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/*******************************************************\ 	* Tell the device to get going on the transfer if it's	* 	* not doing anything, otherwise just wait for completion* 	* (All a bit silly if we're only allowing 1 open but..) * 	\*******************************************************/
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/*******************************************************\ 	* Correctly set the buf to indicate a completed xfer	* 	\*******************************************************/
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************\ * ststart looks to see if there is a buf waiting for the device	* * and that the device is not already busy. If both are true,	* * It deques the buf and creates a scsi command to perform the	* * transfer in the buf. The transfer request will call st_done	* * on completion, which will in turn call this routine again	* * so that the next queued transfer is performed.		* * The bufs are queued by the strategy routine (ststrategy)	* *								* * This routine is also called after other non-queued requests	* * have been made of the scsi driver, to ensure that the queue	* * continues to be drained.					* \***************************************************************/
end_comment

begin_comment
comment|/* ststart() is called at splbio */
end_comment

begin_macro
name|ststart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|int
name|drivecount
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|scsi_rw_tape
name|cmd
decl_stmt|;
name|int
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"ststart%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* See if there is a buf to do and we are not already	* 	* doing one						* 	\*******************************************************/
name|xs
operator|=
operator|&
name|st_scsi_xfer
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
condition|)
block|{
return|return;
comment|/* unit already underway */
block|}
name|trynext
label|:
if|if
condition|(
name|st_xfer_block_wait
index|[
name|unit
index|]
condition|)
comment|/* a special awaits, let it proceed first */
block|{
name|wakeup
argument_list|(
operator|&
name|st_xfer_block_wait
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|dp
operator|=
operator|&
name|st_buf_queue
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
block|}
else|else
comment|/* no work to do */
block|{
return|return;
block|}
name|xs
operator|->
name|flags
operator|=
name|INUSE
expr_stmt|;
comment|/* Now ours */
comment|/*******************************************************\ 	* We have a buf, now we should move the data into	* 	* a scsi_xfer definition and try start it		* 	\*******************************************************/
comment|/*******************************************************\ 	*  If we are at a filemark but have not reported it yet	* 	* then we should report it now				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* EOF*/
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* won't need it now */
goto|goto
name|trynext
goto|;
block|}
comment|/*******************************************************\ 	*  If we are at EOM but have not reported it yet	* 	* then we should report it now				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_EOM
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_EOM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* won't need it now */
goto|goto
name|trynext
goto|;
block|}
comment|/*******************************************************\ 	*  Fill out the scsi command				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
name|B_WRITE
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_WRITTEN
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_DATA_OUT
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|flags
operator||=
name|SCSI_DATA_IN
expr_stmt|;
block|}
name|cmd
operator|.
name|op_code
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|READ_COMMAND_TAPE
else|:
name|WRITE_COMMAND_TAPE
expr_stmt|;
comment|/*******************************************************\ 	* Handle "fixed-block-mode" tape drives by using the    * 	* block count instead of the length.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|cmd
operator|.
name|byte2
operator||=
name|SRWT_FIXED
expr_stmt|;
name|lto3b
argument_list|(
name|bp
operator|->
name|b_bcount
operator|/
name|st
operator|->
name|blksiz
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lto3b
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Fill out the scsi_xfer structure			* 	*	Note: we cannot sleep as we may be an interrupt	* 	\*******************************************************/
name|xs
operator|->
name|flags
operator||=
name|SCSI_NOSLEEP
expr_stmt|;
name|xs
operator|->
name|adapter
operator|=
name|st
operator|->
name|ctlr
expr_stmt|;
name|xs
operator|->
name|targ
operator|=
name|st
operator|->
name|targ
expr_stmt|;
name|xs
operator|->
name|lu
operator|=
name|st
operator|->
name|lu
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
literal|1
expr_stmt|;
comment|/* can't retry on tape*/
name|xs
operator|->
name|timeout
operator|=
literal|100000
expr_stmt|;
comment|/* allow 100 secs for retension */
name|xs
operator|->
name|cmd
operator|=
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|xs
operator|->
name|when_done
operator|=
name|st_done
expr_stmt|;
name|xs
operator|->
name|done_arg
operator|=
name|unit
expr_stmt|;
name|xs
operator|->
name|done_arg2
operator|=
operator|(
name|int
operator|)
name|xs
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
comment|/*******************************************************\ 	* Pass all this info to the scsi driver.		* 	\*******************************************************/
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
operator|||
name|defined
argument_list|(
name|FIX_ME
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
condition|)
block|{
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|map_pva_kva
argument_list|(
name|bp
operator|->
name|b_proc
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|st_window
index|[
name|unit
index|]
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|B_WRITE
else|:
name|B_READ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(OSF) */
if|if
condition|(
operator|(
operator|*
operator|(
name|st
operator|->
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
operator|!=
name|SUCCESSFULLY_QUEUED
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: oops not queued"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|st_done
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
expr_stmt|;
block|}
name|stqueues
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * This routine is called by the scsi interrupt when	* * the transfer is complete. \*******************************************************/
end_comment

begin_function
name|int
name|st_done
parameter_list|(
name|unit
parameter_list|,
name|xs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"st_done%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
operator|)
condition|)
name|panic
argument_list|(
literal|"scsi_xfer not in use!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|=
name|xs
operator|->
name|bp
condition|)
block|{
switch|switch
condition|(
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XS_SENSE
case|:
name|retval
operator|=
operator|(
name|st_interpret_sense
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
comment|/***************************************\ 				* We have a real error, the bit should	* 				* be set to indicate this. The return	* 				* value will contain the unix error code* 				* that the error interpretation routine	* 				* thought was suitable, so pass this	* 				* value back in the buf structure.	* 				* Furthermore we return information	* 				* saying that no data was transferred	* 				\***************************************/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|retval
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/***********************************************\ 			* The error interpretation code has declared	* 			* that it wasn't a real error, or at least that	* 			* we should be ignoring it if it was.		* 			\***********************************************/
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|resid
operator|)
condition|)
block|{
comment|/***************************************\ 				* we apparently had a corrected error	* 				* or something.				* 				* pretend the error never happenned	* 				\***************************************/
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xs
operator|->
name|resid
operator|!=
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/***************************************\ 				* Here we have the tricky part..	* 				* We successfully read less data than	* 				* we requested. (but not 0)		* 				*------for variable blocksize tapes:----* 				* UNDER 386BSD:				* 				* We should legitimatly have the error	* 				* bit set, with the error value set to 	* 				* zero.. This is to indicate to the	* 				* physio code that while we didn't get	* 				* as much information as was requested,	* 				* we did reach the end of the record	* 				* and so physio should not call us	* 				* again for more data... we have it all	* 				* SO SET THE ERROR BIT!			* 				*					* 				* UNDER MACH (CMU) and NetBSD:		* 				* To indicate the same as above, we	* 				* need only have a non 0 resid that is	* 				* less than the b_bcount, but the	* 				* ERROR BIT MUST BE CLEAR! (sigh) 	* 				*					* 				* UNDER OSF1:				* 				* To indicate the same as above, we	* 				* need to have a non 0 resid that is	* 				* less than the b_bcount, but the	* 				* ERROR BIT MUST BE SET! (gasp)(sigh) 	* 				*					* 				*-------for fixed blocksize device------* 				* We could have read some successful	* 				* records before hitting		* 				* the EOF or EOT. These must be passed	* 				* to the user, before we report the 	* 				* EOx. Only if there is no data for the	* 				* user do we report it now. (via an EIO	* 				* for EOM and resid == count for EOF).	* 				* We will report the EOx NEXT time..	* 				\***************************************/
comment|/* how do I distinguish NetBSD? at present it's wrong for NetBsd */
ifdef|#
directive|ifdef
name|MACH
comment|/*osf and cmu varieties */
ifdef|#
directive|ifdef
name|OSF
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
else|#
directive|else
else|OSF
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
endif|#
directive|endif
endif|OSF
endif|#
directive|endif
endif|MACH
ifdef|#
directive|ifdef
name|__386BSD__
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|xs
operator|->
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_FIXEDBLOCKS
operator|)
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|*=
name|st_data
index|[
name|unit
index|]
operator|.
name|blksiz
expr_stmt|;
if|if
condition|(
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_AT_EOM
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_resid
operator|==
name|bp
operator|->
name|b_bcount
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_AT_EOM
expr_stmt|;
block|}
block|}
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/***************************************\ 				* We have come out of the error handler	* 				* with no error code.. we have also 	* 				* not had an ili (would have gone to	* 				* the previous clause). Now we need to	* 				* distiguish between succesful read of	* 				* no data (EOF or EOM) and successfull	* 				* read of all requested data.		* 				* At least all o/s agree that:		* 				* 0 bytes read with no error is EOF	* 				* 0 bytes read with an EIO is EOM	* 				\***************************************/
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_AT_EOM
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_AT_EOM
expr_stmt|;
break|break;
block|}
block|}
block|}
break|break;
case|case
name|XS_TIMEOUT
case|:
name|printf
argument_list|(
literal|"st%d timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XS_BUSY
case|:
comment|/* should retry */
comment|/* how? */
comment|/************************************************/
comment|/* SHOULD put buf back at head of queue         */
comment|/* and decrement retry count in (*xs)           */
comment|/* HOWEVER, this should work as a kludge        */
comment|/************************************************/
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
comment|/* don't wake the job, ok? */
return|return;
block|}
name|printf
argument_list|(
literal|"st%d: device busy\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
block|}
case|case
name|XS_DRIVER_STUFFUP
case|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: unknown error category from scsi driver\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* no longer in use */
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* If there's another waiting.. do it */
block|}
else|else
block|{
name|wakeup
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************\ * Perform special action on behalf of the user		* * Knows about the internals of this device		* \*******************************************************/
end_comment

begin_macro
name|stioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|arg
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|int
name|number
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
comment|/*******************************************************\ 	* Find the device that the user is talking about	* 	\*******************************************************/
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* give error messages, act on errors etc. */
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
literal|0x7
expr_stmt|;
comment|/* Ultrix compat */
comment|/*?*/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|g
operator|->
name|mt_bsiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
block|}
else|else
block|{
name|g
operator|->
name|mt_bsiz
operator|=
literal|0
expr_stmt|;
block|}
name|g
operator|->
name|mt_dns_high
operator|=
name|st
operator|->
name|modes
index|[
name|HIGH_DSTY
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_dns_medium
operator|=
name|st
operator|->
name|modes
index|[
name|MED_DSTY
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_dns_low
operator|=
name|st
operator|->
name|modes
index|[
name|LOW_DSTY
index|]
operator|.
name|density
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"[sctape_sstatus: %x %x]\n"
argument_list|,
name|mt
operator|->
name|mt_op
argument_list|,
name|mt
operator|->
name|mt_count
argument_list|)
expr_stmt|;
comment|/* compat: in U*x it is a short */
name|number
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
name|mt
operator|->
name|mt_op
argument_list|)
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
if|if
condition|(
operator|!
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|flags
argument_list|)
condition|)
name|errcode
operator|=
name|EIO
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_WRITTEN
expr_stmt|;
break|break;
case|case
name|MTFSF
case|:
comment|/* forward space file */
if|if
condition|(
operator|!
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
condition|)
name|errcode
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
comment|/* backward space file */
if|if
condition|(
operator|!
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
name|number
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
condition|)
name|errcode
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|MTFSR
case|:
comment|/* forward space record */
if|if
condition|(
operator|!
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
condition|)
name|errcode
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
if|if
condition|(
operator|!
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
condition|)
name|errcode
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
comment|/* rewind */
if|if
condition|(
operator|!
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
condition|)
name|errcode
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
if|if
condition|(
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"st%d: rewind failed, unit still loaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
break|break;
case|case
name|MTSETBSIZ
case|:
comment|/* Set block size for device */
if|if
condition|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
condition|)
block|{
comment|/* This doesn't make sense for a */
comment|/* real fixed block device */
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
comment|/* Restoring original block size */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
comment|/*XXX*/
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|number
operator|<
name|st
operator|->
name|blkmin
operator|||
name|number
operator|>
name|st
operator|->
name|blkmax
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|blksiz
operator|=
name|number
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
block|}
block|}
break|break;
comment|/* How do we check that the drive can handle 			   the requested density ? */
case|case
name|MTSETHDNSTY
case|:
comment|/* Set high density defaults for device */
if|if
condition|(
name|number
operator|<
literal|0
operator|||
name|number
operator|>
name|SCSI_2_MAX_DENSITY_CODE
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|modes
index|[
name|HIGH_DSTY
index|]
operator|.
name|density
operator|=
name|number
expr_stmt|;
block|}
break|break;
case|case
name|MTSETMDNSTY
case|:
comment|/* Set medium density defaults for device */
if|if
condition|(
name|number
operator|<
literal|0
operator|||
name|number
operator|>
name|SCSI_2_MAX_DENSITY_CODE
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|modes
index|[
name|MED_DSTY
index|]
operator|.
name|density
operator|=
name|number
expr_stmt|;
block|}
break|break;
case|case
name|MTSETLDNSTY
case|:
comment|/* Set low density defaults for device */
if|if
condition|(
name|number
operator|<
literal|0
operator|||
name|number
operator|>
name|SCSI_2_MAX_DENSITY_CODE
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|modes
index|[
name|LOW_DSTY
index|]
operator|.
name|density
operator|=
name|number
expr_stmt|;
block|}
break|break;
default|default:
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
break|break;
default|default:
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|errcode
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|removing_this
end_ifdef

begin_comment
comment|/*******************************************************\ * Check with the device that it is ok, (via scsi driver)* \*******************************************************/
end_comment

begin_macro
name|st_req_sense
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_sense_data
name|sense
decl_stmt|;
name|struct
name|scsi_sense
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|sense
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
name|sense
argument_list|)
argument_list|,
literal|100000
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************\ * Get scsi driver to send a "are you ready" command	* \*******************************************************/
end_comment

begin_macro
name|st_test_ready
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_test_unit_ready
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|TEST_UNIT_READY
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a##_1)<< 8) + (unsigned)a##_0 )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a
comment|/**/
value|_1)<< 8) + (unsigned)a
comment|/**/
value|_0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************\ * Ask the drive what it's min and max blk sizes are.	* \*******************************************************/
end_comment

begin_macro
name|st_rd_blk_lim
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_blk_limits
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_blk_limits_data
name|scsi_blkl
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
comment|/*******************************************************\ 	* First check if we have it all loaded			* 	\*******************************************************/
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/*******************************************************\ 	* do a 'Read Block Limits'				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_BLK_LIMITS
expr_stmt|;
comment|/*******************************************************\ 	* do the command,	update the global values	* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|scsi_blkl
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_blkl
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: could not get blk limits\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|st
operator|->
name|blkmin
operator|=
name|b2tol
argument_list|(
name|scsi_blkl
operator|.
name|min_length
argument_list|)
expr_stmt|;
name|st
operator|->
name|blkmax
operator|=
name|_3btol
argument_list|(
operator|&
name|scsi_blkl
operator|.
name|max_length_2
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_debug
condition|)
block|{
name|printf
argument_list|(
literal|" (%d<= blksiz<= %d\n) "
argument_list|,
name|st
operator|->
name|blkmin
argument_list|,
name|st
operator|->
name|blkmax
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the scsi driver to send a full inquiry to the	* * device and use the results to fill out the global 	* * parameter structure.					* *							* * called from:						* * attach						* * open							* * ioctl (to reset original blksize)			* \*******************************************************/
end_comment

begin_macro
name|st_mode_sense
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|scsi_sense_len
decl_stmt|;
name|char
modifier|*
name|scsi_sense_ptr
decl_stmt|;
name|struct
name|scsi_mode_sense
name|scsi_cmd
decl_stmt|;
struct|struct
name|scsi_sense
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
block|}
name|scsi_sense
struct|;
struct|struct
name|scsi_sense_page_0
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|unsigned
name|char
name|sense_data
index|[
name|PAGE_0_SENSE_DATA_SIZE
index|]
decl_stmt|;
comment|/* Tandberg tape drives returns page 00 */
comment|/* with the sense data, whether or not */
comment|/* you want it( ie the don't like you  */
comment|/* saying you want anything less!!!!!  */
comment|/* They also expect page 00 */
comment|/* back when you issue a mode select */
block|}
name|scsi_sense_page_0
struct|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
comment|/*******************************************************\ 	* First check if we have it all loaded			* 	\*******************************************************/
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/*******************************************************\ 	* Define what sort of structure we're working with	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|scsi_sense_len
operator|=
sizeof|sizeof
argument_list|(
name|scsi_sense_page_0
argument_list|)
expr_stmt|;
name|scsi_sense_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|scsi_sense_page_0
expr_stmt|;
block|}
else|else
block|{
name|scsi_sense_len
operator|=
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
expr_stmt|;
name|scsi_sense_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|scsi_sense
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Set up a mode sense 					* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
name|scsi_sense_len
expr_stmt|;
comment|/*******************************************************\ 	* do the command, but we don't need the results		* 	* just print them for our interest's sake, if asked,	* 	* or if we need it as a template for the mode select	* 	* store it away.					* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
name|scsi_sense_ptr
argument_list|,
name|scsi_sense_len
argument_list|,
literal|5000
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: could not mode sense\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|st
operator|->
name|numblks
operator|=
name|_3btol
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|nblocks
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|media_blksiz
operator|=
name|_3btol
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|blklen
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|media_density
operator|=
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|density
expr_stmt|;
if|if
condition|(
name|st_debug
condition|)
block|{
name|printf
argument_list|(
literal|"unit %d: %d blocks of %d bytes, write %s, %sbuffered"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|numblks
argument_list|,
name|st
operator|->
name|media_blksiz
argument_list|,
operator|(
operator|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|header
operator|.
name|dev_spec
operator|&
name|SMH_DSP_WRITE_PROT
operator|)
condition|?
literal|"protected"
else|:
literal|"enabled"
operator|)
argument_list|,
operator|(
operator|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|header
operator|.
name|dev_spec
operator|&
name|SMH_DSP_BUFF_MODE
operator|)
condition|?
literal|""
else|:
literal|"un"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
operator|(
expr|struct
name|scsi_sense_page_0
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|sense_data
argument_list|,
name|st
operator|->
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|scsi_sense_page_0
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Send a filled out parameter structure to the drive to	* * set it into the desire modes etc.			* \*******************************************************/
end_comment

begin_macro
name|st_mode_select
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|,
argument|dsty_code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|,
name|dsty_code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dat_len
decl_stmt|;
name|char
modifier|*
name|dat_ptr
decl_stmt|;
name|struct
name|scsi_mode_select
name|scsi_cmd
decl_stmt|;
struct|struct
name|dat
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
block|}
name|dat
struct|;
struct|struct
name|dat_page_0
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|unsigned
name|char
name|sense_data
index|[
name|PAGE_0_SENSE_DATA_SIZE
index|]
decl_stmt|;
block|}
name|dat_page_0
struct|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
comment|/*******************************************************\ 	* Define what sort of structure we're working with	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|dat_len
operator|=
sizeof|sizeof
argument_list|(
name|dat_page_0
argument_list|)
expr_stmt|;
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dat_page_0
expr_stmt|;
block|}
else|else
block|{
name|dat_len
operator|=
sizeof|sizeof
argument_list|(
name|dat
argument_list|)
expr_stmt|;
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Set up for a mode select				* 	\*******************************************************/
name|bzero
argument_list|(
name|dat_ptr
argument_list|,
name|dat_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SELECT
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
name|dat_len
expr_stmt|;
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|header
operator|.
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|blk_desc
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|header
operator|.
name|dev_spec
operator||=
name|SMH_DSP_BUFF_MODE_ON
expr_stmt|;
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|density
operator|=
name|dsty_code
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|lto3b
argument_list|(
name|st
operator|->
name|blksiz
argument_list|,
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|bcopy
argument_list|(
name|st
operator|->
name|sense_data
argument_list|,
operator|(
operator|(
expr|struct
name|dat_page_0
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|dat_page_0
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the Tandberg tapes need the block size to */
comment|/* be set on each mode sense/select. */
block|}
comment|/*******************************************************\ 	* do the command					* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
name|dat_ptr
argument_list|,
name|dat_len
argument_list|,
literal|5000
argument_list|,
name|flags
operator||
name|SCSI_DATA_OUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: could not mode select\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * skip N blocks/filemarks/seq filemarks/eom		* \*******************************************************/
end_comment

begin_macro
name|st_space
argument_list|(
argument|unit
argument_list|,
argument|number
argument_list|,
argument|what
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|number
decl_stmt|,
name|what
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_space
name|scsi_cmd
decl_stmt|;
comment|/* if we are at a filemark now, we soon won't be*/
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|what
operator|&
name|SS_CODE
expr_stmt|;
name|lto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|600000
argument_list|,
comment|/* 10 mins enough? */
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: could not space\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * write N filemarks					* \*******************************************************/
end_comment

begin_macro
name|st_write_filemarks
argument_list|(
argument|unit
argument_list|,
argument|number
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|number
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_write_filemarks
name|scsi_cmd
decl_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
name|lto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|,
comment|/* 10 secs.. (may need to repos head )*/
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: could not write_filemarks\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * load /unload (with retension if true)			* \*******************************************************/
end_comment

begin_macro
name|st_load
argument_list|(
argument|unit
argument_list|,
argument|type
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_load
name|scsi_cmd
decl_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|LOAD_UNLOAD
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LD_LOAD
condition|)
block|{
comment|/*scsi_cmd.how |= LD_RETEN;*/
block|}
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|30000
argument_list|,
comment|/* 30 secs */
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cannot load/unload  st%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Prevent or allow the user to remove the tape		* \*******************************************************/
end_comment

begin_macro
name|st_prevent
argument_list|(
argument|unit
argument_list|,
argument|type
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_prevent
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|PREVENT_ALLOW
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|5000
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: cannot prevent/allow\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ *  Rewind the device					* \*******************************************************/
end_comment

begin_macro
name|st_rewind
argument_list|(
argument|unit
argument_list|,
argument|immed
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|immed
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_rewind
name|scsi_cmd
decl_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REWIND
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|immed
condition|?
name|SR_IMMED
else|:
literal|0
condition|?
name|SR_IMMED
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|immed
condition|?
literal|5000
else|:
literal|300000
argument_list|,
comment|/* 5 sec or 5 min */
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"st%d: could not rewind\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * ask the scsi driver to perform a command for us.	* * Call it through the switch table, and tell it which	* * sub-unit we want, and what target and lu we wish to	* * talk to. Also tell it where to find the command	* * how long int is.					* * Also tell it where to read/write the data, and how	* * long the data is supposed to be			* \*******************************************************/
end_comment

begin_function
name|int
name|st_scsi_cmd
parameter_list|(
name|unit
parameter_list|,
name|scsi_cmd
parameter_list|,
name|cmdlen
parameter_list|,
name|data_addr
parameter_list|,
name|datalen
parameter_list|,
name|timeout
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|scsi_generic
modifier|*
name|scsi_cmd
decl_stmt|;
name|int
name|cmdlen
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|u_char
modifier|*
name|data_addr
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"\nst_scsi_cmd%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|sc_sw
condition|)
comment|/* If we have a scsi driver */
block|{
name|xs
operator|=
operator|&
operator|(
name|st_scsi_xfer
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|st_xfer_block_wait
index|[
name|unit
index|]
operator|++
expr_stmt|;
comment|/* there is someone waiting */
while|while
condition|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
condition|)
block|{
name|sleep
argument_list|(
operator|&
name|st_xfer_block_wait
index|[
name|unit
index|]
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|st_xfer_block_wait
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
name|INUSE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 		* Fill out the scsi_xfer structure			* 		\*******************************************************/
name|xs
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|xs
operator|->
name|adapter
operator|=
name|st
operator|->
name|ctlr
expr_stmt|;
name|xs
operator|->
name|targ
operator|=
name|st
operator|->
name|targ
expr_stmt|;
name|xs
operator|->
name|lu
operator|=
name|st
operator|->
name|lu
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
name|ST_RETRIES
expr_stmt|;
name|xs
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|xs
operator|->
name|cmd
operator|=
name|scsi_cmd
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|xs
operator|->
name|data
operator|=
name|data_addr
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|when_done
operator|=
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|?
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
else|:
name|st_done
expr_stmt|;
name|xs
operator|->
name|done_arg
operator|=
name|unit
expr_stmt|;
name|xs
operator|->
name|done_arg2
operator|=
operator|(
name|int
operator|)
name|xs
expr_stmt|;
name|retry
label|:
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|st
operator|->
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|SUCCESSFULLY_QUEUED
case|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
name|sleep
argument_list|(
name|xs
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
case|case
name|HAD_ERROR
case|:
case|case
name|COMPLETE
case|:
switch|switch
condition|(
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
name|retval
operator|=
name|ESUCCESS
expr_stmt|;
break|break;
case|case
name|XS_SENSE
case|:
name|retval
operator|=
operator|(
name|st_interpret_sense
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
operator|)
expr_stmt|;
comment|/* only useful for reads */
if|if
condition|(
name|retval
condition|)
block|{
comment|/* error... don't care about filemarks */
name|st
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|retval
operator|=
name|ESUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|XS_DRIVER_STUFFUP
case|:
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|XS_TIMEOUT
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|XS_BUSY
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
name|printf
argument_list|(
literal|"st%d: unknown error category from scsi driver\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TRY_AGAIN_LATER
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* it's free! */
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"st%d: not set up\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Look at the returned sense and act on the error and detirmine	* * The unix error number to pass back... (0 = report no error)	* \***************************************************************/
end_comment

begin_function
name|int
name|st_interpret_sense
parameter_list|(
name|unit
parameter_list|,
name|xs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|key
decl_stmt|;
name|int
name|silent
init|=
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
decl_stmt|;
comment|/***************************************************************\ 	* If errors are ok, report a success				* 	\***************************************************************/
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
condition|)
return|return
operator|(
name|ESUCCESS
operator|)
return|;
comment|/***************************************************************\ 	* Get the sense fields and work out what CLASS			* 	\***************************************************************/
name|sense
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|st_debug
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"code%x valid%x\n"
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"seg%x key%x ili%x eom%x fmark%x\n"
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|segment
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info: %x %x %x %x followed by %d extra bytes\n"
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extra: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_len
condition|)
block|{
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_bytes
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
condition|)
block|{
comment|/***************************************************************\ 	* If it's class 7, use the extended stuff and interpret the key	* 	\***************************************************************/
case|case
literal|0x70
case|:
block|{
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|)
block|{
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator||=
name|ST_AT_EOM
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|)
block|{
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator||=
name|ST_AT_FILEMARK
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
comment|/*******************************\ 				* In all ili cases, note that	* 				* the resid is non-0 AND not 	* 				* unchanged.			* 				\*******************************/
name|xs
operator|->
name|resid
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|resid
operator|<
literal|0
condition|)
block|{
comment|/* never on block devices */
comment|/***********************\ 						* it's only really bad	* 						* if we have lost data	* 						* (the record was 	* 						* bigger than the read)	* 						\***********************/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* makes no sense.. complain */
name|printf
argument_list|(
literal|"st%d: BAD length error?\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* there may be some other error. check the rest */
name|key
operator|=
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|0x0
case|:
if|if
condition|(
operator|!
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
operator|)
condition|)
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* XXX check this */
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x1
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: soft error(corrected) "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
operator|)
condition|)
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
comment|/* XXX check this */
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x2
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
literal|0x3
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: medium error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0x4
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: non-media hardware failure\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0x5
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: illegal request\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0x6
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: Unit attention.\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_OPEN
condition|)
comment|/* TEMP!!!! */
return|return
operator|(
name|EIO
operator|)
return|;
else|else
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x7
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: attempted protection violation"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
literal|0x8
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: fixed block wrong size"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" requested size: %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0x9
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: vendor unique\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xa
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: copy aborted\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xb
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: command aborted\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xc
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: search returned"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0xd
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: volume overflow\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
case|case
literal|0xe
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: verify miscompare"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xf
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: unknown error key\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
break|break;
block|}
comment|/***************************************************************\ 	* If it's NOT class 7, just report it.				* 	\***************************************************************/
default|default:
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: error code %d"
argument_list|,
name|unit
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|" block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockhi
operator|<<
literal|16
operator|)
argument_list|,
operator|+
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockmed
operator|<<
literal|8
operator|)
argument_list|,
operator|+
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blocklow
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
end_if

begin_macro
name|stsize
argument_list|(
argument|dev_t dev
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"stsize()        -- not implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|stdump
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"stdump()        -- not implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OSF) */
end_comment

end_unit

