begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00098  * --------------------         -----   ----------------------  *  * 16 Feb 93	Julian Elischer		ADDED for SCSI system  */
end_comment

begin_comment
comment|/*  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  */
end_comment

begin_comment
comment|/*  * To do:  * work out some better way of guessing what a good timeout is going  * to be depending on whether we expect to retension or not.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<st.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
end_if

begin_define
define|#
directive|define
name|SECSIZE
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OSF) */
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_tape.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_decl_stmt
name|long
name|int
name|ststrats
decl_stmt|,
name|stqueues
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|STQSIZE
value|4
end_define

begin_define
define|#
directive|define
name|ST_RETRIES
value|4
end_define

begin_define
define|#
directive|define
name|MODE
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)& 0x03) )
end_define

begin_define
define|#
directive|define
name|DSTY
parameter_list|(
name|z
parameter_list|)
value|( ((minor(z)>> 2)& 0x03) )
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)>> 4) )
end_define

begin_define
define|#
directive|define
name|DSTY_QIC120
value|3
end_define

begin_define
define|#
directive|define
name|DSTY_QIC150
value|2
end_define

begin_define
define|#
directive|define
name|DSTY_QIC525
value|1
end_define

begin_define
define|#
directive|define
name|QIC120
value|0x0f
end_define

begin_define
define|#
directive|define
name|QIC150
value|0x10
end_define

begin_define
define|#
directive|define
name|QIC525
value|0x11
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|__386BSD__
end_ifndef

begin_decl_stmt
name|struct
name|buf
name|stbuf
index|[
name|NST
index|]
index|[
name|STQSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for raw io (one per device) */
end_comment

begin_decl_stmt
name|struct
name|buf
modifier|*
name|stbuf_free
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* queue of free buffers for raw io */
end_comment

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_decl_stmt
name|struct
name|buf
name|st_buf_queue
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ststrategy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stminphys
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|scsi_xfer
name|st_scsi_xfer
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|st_xfer_block_wait
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
end_if

begin_decl_stmt
name|caddr_t
name|st_window
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OSF) */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MACH
end_ifndef

begin_define
define|#
directive|define
name|ESUCCESS
value|0
end_define

begin_endif
endif|#
directive|endif
endif|MACH
end_endif

begin_decl_stmt
name|int
name|st_info_valid
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the info about the device is valid */
end_comment

begin_decl_stmt
name|int
name|st_initialized
index|[
name|NST
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|st_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|stattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|st_done
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|st_data
block|{
name|int
name|flags
decl_stmt|;
name|struct
name|scsi_switch
modifier|*
name|sc_sw
decl_stmt|;
comment|/* address of scsi low level switch */
name|int
name|ctlr
decl_stmt|;
comment|/* so they know which one we want */
name|int
name|targ
decl_stmt|;
comment|/* our scsi target ID */
name|int
name|lu
decl_stmt|;
comment|/* out scsi lu */
name|int
name|blkmin
decl_stmt|;
comment|/* min blk size */
name|int
name|blkmax
decl_stmt|;
comment|/* max blk size */
name|int
name|numblks
decl_stmt|;
comment|/* nominal blocks capacity */
name|int
name|blksiz
decl_stmt|;
comment|/* nominal block size */
block|}
name|st_data
index|[
name|NST
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|ST_OPEN
value|0x01
end_define

begin_define
define|#
directive|define
name|ST_NOREWIND
value|0x02
end_define

begin_define
define|#
directive|define
name|ST_WRITTEN
value|0x04
end_define

begin_define
define|#
directive|define
name|ST_FIXEDBLOCKS
value|0x10
end_define

begin_define
define|#
directive|define
name|ST_AT_FILEMARK
value|0x20
end_define

begin_define
define|#
directive|define
name|ST_AT_EOM
value|0x40
end_define

begin_define
define|#
directive|define
name|ST_PER_ACTION
value|(ST_AT_FILEMARK | ST_AT_EOM)
end_define

begin_define
define|#
directive|define
name|ST_PER_OPEN
value|(ST_OPEN | ST_NOREWIND | ST_WRITTEN | ST_PER_ACTION)
end_define

begin_define
define|#
directive|define
name|ST_PER_MEDIA
value|ST_FIXEDBLOCKS
end_define

begin_decl_stmt
specifier|static
name|int
name|next_st_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************\ * The routine called by the low level scsi routine when it discovers	* * A device suitable for this driver					* \***********************************************************************/
end_comment

begin_function
name|int
name|stattach
parameter_list|(
name|ctlr
parameter_list|,
name|targ
parameter_list|,
name|lu
parameter_list|,
name|scsi_switch
parameter_list|)
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|unsigned
name|char
modifier|*
name|tbl
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"stattach: "
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Check we have the resources for another drive		* 	\*******************************************************/
name|unit
operator|=
name|next_st_unit
operator|++
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NST
condition|)
block|{
name|printf
argument_list|(
literal|"Too many scsi tapes..(%d> %d) reconfigure kernel"
argument_list|,
operator|(
name|unit
operator|+
literal|1
operator|)
argument_list|,
name|NST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
comment|/*******************************************************\ 	* Store information needed to contact our base driver	* 	\*******************************************************/
name|st
operator|->
name|sc_sw
operator|=
name|scsi_switch
expr_stmt|;
name|st
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|st
operator|->
name|targ
operator|=
name|targ
expr_stmt|;
name|st
operator|->
name|lu
operator|=
name|lu
expr_stmt|;
comment|/*******************************************************\ 	* Use the subdriver to request information regarding	* 	* the drive. We cannot use interrupts yet, so the	* 	* request must specify this.				* 	\*******************************************************/
if|if
condition|(
operator|(
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"	st%d: scsi tape drive, %d blocks of %d bytes\n"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|numblks
argument_list|,
name|st
operator|->
name|blksiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"	st%d: scsi tape drive :- offline\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Set up the bufs for this device			* 	\*******************************************************/
ifndef|#
directive|ifndef
name|__386BSD__
name|stbuf_free
index|[
name|unit
index|]
operator|=
operator|(
expr|struct
name|buf
operator|*
operator|)
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|STQSIZE
condition|;
name|i
operator|++
control|)
block|{
name|stbuf
index|[
name|unit
index|]
index|[
name|i
index|]
operator|.
name|b_forw
operator|=
name|stbuf_free
index|[
name|unit
index|]
expr_stmt|;
name|stbuf_free
index|[
name|unit
index|]
operator|=
operator|&
name|stbuf
index|[
name|unit
index|]
index|[
name|i
index|]
expr_stmt|;
block|}
endif|#
directive|endif
endif|__386BSD__
name|st_buf_queue
index|[
name|unit
index|]
operator|.
name|b_active
operator|=
literal|0
expr_stmt|;
name|st_buf_queue
index|[
name|unit
index|]
operator|.
name|b_actf
operator|=
name|st_buf_queue
index|[
name|unit
index|]
operator|.
name|b_actl
operator|=
literal|0
expr_stmt|;
name|st_initialized
index|[
name|unit
index|]
operator|=
literal|1
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
name|st_window
index|[
name|unit
index|]
operator|=
operator|(
name|caddr_t
operator|)
name|alloc_kva
argument_list|(
name|SECSIZE
operator|*
literal|256
operator|+
name|PAGESIZ
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* defined(OSF) */
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************\ *	open the device.				* \*******************************************************/
end_comment

begin_macro
name|stopen
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|dsty
decl_stmt|;
name|int
name|dsty_code
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
comment|/*******************************************************\ 	* Check the unit is legal                               * 	\*******************************************************/
if|if
condition|(
name|unit
operator|>=
name|NST
condition|)
block|{
name|errcode
operator|=
name|ENXIO
expr_stmt|;
return|return
operator|(
name|errcode
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Only allow one at a time				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_OPEN
condition|)
block|{
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/*******************************************************\ 	* Set up the mode flags according to the minor number	* 	* ensure all open flags are in a known state		* 	\*******************************************************/
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_OPEN
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|2
case|:
case|case
literal|0
case|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_NOREWIND
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|1
case|:
name|st
operator|->
name|flags
operator||=
name|ST_NOREWIND
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: Bad mode (minor number)%d\n"
argument_list|,
name|unit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/*******************************************************\         * Check density code: 0 is drive default		*         \*******************************************************/
switch|switch
condition|(
name|dsty
condition|)
block|{
case|case
literal|0
case|:
name|dsty_code
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|DSTY_QIC120
case|:
name|dsty_code
operator|=
name|QIC120
expr_stmt|;
break|break;
case|case
name|DSTY_QIC150
case|:
name|dsty_code
operator|=
name|QIC150
expr_stmt|;
break|break;
case|case
name|DSTY_QIC525
case|:
name|dsty_code
operator|=
name|QIC525
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: Bad density (minor number)%d\n"
argument_list|,
name|unit
argument_list|,
name|dsty
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
name|scsi_debug
operator|&
operator|(
name|PRINTROUTINES
operator||
name|TRACEOPENS
operator|)
condition|)
name|printf
argument_list|(
literal|"stopen: dev=0x%x (unit %d (of %d))\n"
argument_list|,
name|dev
argument_list|,
name|unit
argument_list|,
name|NST
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Make sure the device has been initialised		* 	\*******************************************************/
if|if
condition|(
operator|!
name|st_initialized
index|[
name|unit
index|]
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*******************************************************\ 	* Check that it is still responding and ok.		* 	\*******************************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"device is "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|st_req_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|errcode
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"not responding\n"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"ok\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|st_test_ready
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|st_info_valid
index|[
name|unit
index|]
condition|)
comment|/* is media new? */
if|if
condition|(
operator|!
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_LOAD
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|st_rd_blk_lim
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
name|dsty_code
argument_list|)
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|TRUE
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_PREVENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* who cares if it fails? */
comment|/*******************************************************\ 	* Load the physical device parameters			* 	\*******************************************************/
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"Params loaded "
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_OPEN
expr_stmt|;
name|bad
label|:
return|return
operator|(
name|errcode
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * close the device.. only called if we are the LAST	* * occurence of an open device				* \*******************************************************/
end_comment

begin_macro
name|stclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|unit
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"Closing device"
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_WRITTEN
condition|)
block|{
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_WRITTEN
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d:close: Bad mode (minor number)%d how's it open?\n"
argument_list|,
name|unit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|__386BSD__
end_ifndef

begin_comment
comment|/*******************************************************\ * Get ownership of this unit's buf			* * If need be, sleep on it, until it comes free		* \*******************************************************/
end_comment

begin_function
name|struct
name|buf
modifier|*
name|st_get_buf
parameter_list|(
name|unit
parameter_list|)
block|{
name|struct
name|buf
modifier|*
name|rc
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|rc
operator|=
name|stbuf_free
index|[
name|unit
index|]
operator|)
condition|)
name|sleep
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stbuf_free
index|[
name|unit
index|]
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|stbuf_free
index|[
name|unit
index|]
operator|=
name|stbuf_free
index|[
name|unit
index|]
operator|->
name|b_forw
expr_stmt|;
name|rc
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
name|rc
operator|->
name|b_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Free this unit's buf, wake processes waiting for it	* \*******************************************************/
end_comment

begin_macro
name|st_free_buf
argument_list|(
argument|unit
argument_list|,
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
operator|!
name|stbuf_free
index|[
name|unit
index|]
condition|)
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stbuf_free
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_forw
operator|=
name|stbuf_free
index|[
name|unit
index|]
expr_stmt|;
name|stbuf_free
index|[
name|unit
index|]
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the buf for this unit and use physio to do it	* \*******************************************************/
end_comment

begin_expr_stmt
name|stread
argument_list|(
name|dev
argument_list|,
name|uio
argument_list|)
specifier|register
name|short
name|dev
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|st_get_buf
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|physio
argument_list|(
name|ststrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|stminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|st_free_buf
argument_list|(
name|unit
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the buf for this unit and use physio to do it	* \*******************************************************/
end_comment

begin_macro
name|stwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|unit
init|=
name|UNIT
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|st_get_buf
argument_list|(
name|unit
argument_list|)
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|rc
operator|=
name|physio
argument_list|(
name|ststrategy
argument_list|,
name|bp
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|stminphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|st_free_buf
argument_list|(
name|unit
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|__386BSD__
end_endif

begin_comment
comment|/*******************************************************\ * trim the size of the transfer if needed,		* * called by physio					* * basically the smaller of our min and the scsi driver's* * minphys						* \*******************************************************/
end_comment

begin_function
name|void
name|stminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
operator|(
operator|*
operator|(
name|st_data
index|[
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|.
name|sc_sw
operator|->
name|scsi_minphys
operator|)
operator|)
operator|(
name|bp
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Actually translate the requested transfer into	* * one the physical driver can understand		* * The transfer is described by a buf and will include	* * only one physical transfer.				* \*******************************************************/
end_comment

begin_function
name|int
name|ststrategy
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|ststrats
operator|++
expr_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
operator|(
name|bp
operator|->
name|b_dev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"\nststrategy "
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWREQUESTS
condition|)
name|printf
argument_list|(
literal|"st%d: %d bytes @ blk%d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* If it's a null transfer, return immediatly		* 	\*******************************************************/
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*******************************************************\ 	* Odd sized request on fixed drives are verboten	* 	\*******************************************************/
if|if
condition|(
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_FIXEDBLOCKS
operator|)
operator|&&
name|bp
operator|->
name|b_bcount
operator|%
name|st_data
index|[
name|unit
index|]
operator|.
name|blkmin
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: bad request, must be multiple of %d\n"
argument_list|,
name|unit
argument_list|,
name|st_data
index|[
name|unit
index|]
operator|.
name|blkmin
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|__386BSD__
name|stminphys
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|dp
operator|=
operator|&
name|st_buf_queue
index|[
name|unit
index|]
expr_stmt|;
comment|/*******************************************************\ 	* Place it in the queue of disk activities for this tape* 	* at the end						* 	\*******************************************************/
while|while
condition|(
name|dp
operator|->
name|b_actf
condition|)
block|{
name|dp
operator|=
name|dp
operator|->
name|b_actf
expr_stmt|;
block|}
name|dp
operator|->
name|b_actf
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
expr_stmt|;
comment|/*******************************************************\ 	* Tell the device to get going on the transfer if it's	* 	* not doing anything, otherwise just wait for completion* 	\*******************************************************/
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/*******************************************************\ 	* Correctly set the buf to indicate a completed xfer	* 	\*******************************************************/
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***************************************************************\ * ststart looks to see if there is a buf waiting for the device	* * and that the device is not already busy. If both are true,	* * It deques the buf and creates a scsi command to perform the	* * transfer in the buf. The transfer request will call st_done	* * on completion, which will in turn call this routine again	* * so that the next queued transfer is performed.		* * The bufs are queued by the strategy routine (ststrategy)	* *								* * This routine is also called after other non-queued requests	* * have been made of the scsi driver, to ensure that the queue	* * continues to be drained.					* \***************************************************************/
end_comment

begin_comment
comment|/* ststart() is called at splbio */
end_comment

begin_macro
name|ststart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|int
name|drivecount
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|scsi_rw_tape
name|cmd
decl_stmt|;
name|int
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|st
operator|=
name|st_data
operator|+
name|unit
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"ststart%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* See if there is a buf to do and we are not already	* 	* doing one						* 	\*******************************************************/
name|xs
operator|=
operator|&
name|st_scsi_xfer
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
condition|)
block|{
return|return;
comment|/* unit already underway */
block|}
name|trynext
label|:
if|if
condition|(
name|st_xfer_block_wait
index|[
name|unit
index|]
condition|)
comment|/* a special awaits, let it proceed first */
block|{
name|wakeup
argument_list|(
operator|&
name|st_xfer_block_wait
index|[
name|unit
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|dp
operator|=
operator|&
name|st_buf_queue
index|[
name|unit
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dp
operator|->
name|b_actf
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dp
operator|->
name|b_actf
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
block|}
else|else
comment|/* no work to do */
block|{
return|return;
block|}
name|xs
operator|->
name|flags
operator|=
name|INUSE
expr_stmt|;
comment|/* Now ours */
comment|/*******************************************************\ 	* We have a buf, now we should move the data into	* 	* a scsi_xfer definition and try start it		* 	\*******************************************************/
comment|/*******************************************************\ 	*  If we are at a filemark but have not reported it yet	* 	* then we should report it now				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
comment|/* EOF*/
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* won't need it now */
goto|goto
name|trynext
goto|;
block|}
comment|/*******************************************************\ 	*  If we are at EOM but have not reported it yet	* 	* then we should report it now				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_EOM
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_EOM
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* won't need it now */
goto|goto
name|trynext
goto|;
block|}
comment|/*******************************************************\ 	*  Fill out the scsi command				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
name|B_WRITE
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_WRITTEN
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_DATA_OUT
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|flags
operator||=
name|SCSI_DATA_IN
expr_stmt|;
block|}
name|cmd
operator|.
name|op_code
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|READ_COMMAND_TAPE
else|:
name|WRITE_COMMAND_TAPE
expr_stmt|;
comment|/*******************************************************\ 	* Handle "fixed-block-mode" tape drives by using the    * 	* block count instead of the length.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|cmd
operator|.
name|fixed
operator|=
literal|1
expr_stmt|;
name|lto3b
argument_list|(
name|bp
operator|->
name|b_bcount
operator|/
name|st
operator|->
name|blkmin
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lto3b
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Fill out the scsi_xfer structure			* 	*	Note: we cannot sleep as we may be an interrupt	* 	\*******************************************************/
name|xs
operator|->
name|flags
operator||=
name|SCSI_NOSLEEP
expr_stmt|;
name|xs
operator|->
name|adapter
operator|=
name|st
operator|->
name|ctlr
expr_stmt|;
name|xs
operator|->
name|targ
operator|=
name|st
operator|->
name|targ
expr_stmt|;
name|xs
operator|->
name|lu
operator|=
name|st
operator|->
name|lu
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
literal|1
expr_stmt|;
comment|/* can't retry on tape*/
name|xs
operator|->
name|timeout
operator|=
literal|100000
expr_stmt|;
comment|/* allow 100 secs for retension */
name|xs
operator|->
name|cmd
operator|=
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|cmd
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|xs
operator|->
name|when_done
operator|=
name|st_done
expr_stmt|;
name|xs
operator|->
name|done_arg
operator|=
name|unit
expr_stmt|;
name|xs
operator|->
name|done_arg2
operator|=
operator|(
name|int
operator|)
name|xs
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
comment|/*******************************************************\ 	* Pass all this info to the scsi driver.		* 	\*******************************************************/
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
operator|||
name|defined
argument_list|(
name|FIX_ME
argument_list|)
if|if
condition|(
name|bp
operator|->
name|b_flags
operator|&
name|B_PHYS
condition|)
block|{
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|map_pva_kva
argument_list|(
name|bp
operator|->
name|b_proc
argument_list|,
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|st_window
index|[
name|unit
index|]
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|B_WRITE
else|:
name|B_READ
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* defined(OSF) */
if|if
condition|(
operator|(
operator|*
operator|(
name|st
operator|->
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
operator|!=
name|SUCCESSFULLY_QUEUED
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: oops not queued"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_DRIVER_STUFFUP
expr_stmt|;
name|st_done
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
expr_stmt|;
block|}
name|stqueues
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * This routine is called by the scsi interrupt when	* * the transfer is complete. \*******************************************************/
end_comment

begin_function
name|int
name|st_done
parameter_list|(
name|unit
parameter_list|,
name|xs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"st_done%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
operator|)
condition|)
name|panic
argument_list|(
literal|"scsi_xfer not in use!"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|=
name|xs
operator|->
name|bp
condition|)
block|{
switch|switch
condition|(
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XS_SENSE
case|:
name|retval
operator|=
operator|(
name|st_interpret_sense
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
comment|/***************************************\ 				* We have a real error, the bit should	* 				* be set to indicate this. The return	* 				* value will contain the unix error code* 				* that the error interpretation routine	* 				* thought was suitable, so pass this	* 				* value back in the buf structure.	* 				* Furthermore we return information	* 				* saying that no data was transferred	* 				\***************************************/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|retval
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/***********************************************\ 			* The error interpretation code has declared	* 			* that it wasn't a real error, or at least that	* 			* we should be ignoring it if it was.		* 			\***********************************************/
if|if
condition|(
name|xs
operator|->
name|resid
operator|&&
operator|(
name|xs
operator|->
name|resid
operator|!=
name|xs
operator|->
name|datalen
operator|)
condition|)
block|{
comment|/***************************************\ 				* Here we have the tricky part..	* 				* We successfully read less data than	* 				* we requested. (but not 0)		* 				*------for variable blocksize tapes:----* 				* UNDER 386BSD:				* 				* We should legitimatly have the error	* 				* bit set, with the error value set to 	* 				* zero.. This is to indicate to the	* 				* physio code that while we didn't get	* 				* as much information as was requested,	* 				* we did reach the end of the record	* 				* and so physio should not call us	* 				* again for more data... we have it all	* 				* SO SET THE ERROR BIT!			* 				*					* 				* UNDER MACH:(CMU)			* 				* To indicate the same as above, we	* 				* need only have a non 0 resid that is	* 				* less than the b_bcount, but the	* 				* ERROR BIT MUST BE CLEAR! (sigh) 	* 				*					* 				* UNDER OSF1:				* 				* To indicate the same as above, we	* 				* need to have a non 0 resid that is	* 				* less than the b_bcount, but the	* 				* ERROR BIT MUST BE SET! (gasp)(sigh) 	* 				*					* 				*-------for fixed blocksize device------* 				* We could have read some successful	* 				* records before hitting		* 				* the EOF or EOT. These must be passed	* 				* to the user, before we report the 	* 				* EOx. Only if there is no data for the	* 				* user do we report it now. (via an EIO	* 				* for EOM and resid == count for EOF).	* 				* We will report the EOx NEXT time..	* 				\***************************************/
ifdef|#
directive|ifdef
name|MACH
comment|/*osf and cmu varieties */
ifdef|#
directive|ifdef
name|OSF
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
else|#
directive|else
else|OSF
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
endif|#
directive|endif
endif|OSF
endif|#
directive|endif
endif|MACH
ifdef|#
directive|ifdef
name|__386BSD__
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
endif|#
directive|endif
endif|__386BSD__
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|xs
operator|->
name|resid
expr_stmt|;
if|if
condition|(
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_FIXEDBLOCKS
operator|)
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|*=
name|st_data
index|[
name|unit
index|]
operator|.
name|blkmin
expr_stmt|;
if|if
condition|(
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_AT_EOM
operator|)
operator|&&
operator|(
name|bp
operator|->
name|b_resid
operator|==
name|bp
operator|->
name|b_bcount
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_AT_EOM
expr_stmt|;
block|}
block|}
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/***************************************\ 				* We have come out of the error handler	* 				* with no error code.. we have also 	* 				* not had an ili (would have gone to	* 				* the previous clause). Now we need to	* 				* distiguish between succesful read of	* 				* no data (EOF or EOM) and successfull	* 				* read of all requested data.		* 				* At least all o/s agree that:		* 				* 0 bytes read with no error is EOF	* 				* 0 bytes read with an EIO is EOM	* 				\***************************************/
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_AT_EOM
condition|)
block|{
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_AT_EOM
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"st%d:error ignored\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|XS_TIMEOUT
case|:
name|printf
argument_list|(
literal|"st%d timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XS_BUSY
case|:
comment|/* should retry */
comment|/* how? */
comment|/************************************************/
comment|/* SHOULD put buf back at head of queue         */
comment|/* and decrement retry count in (*xs)           */
comment|/* HOWEVER, this should work as a kludge        */
comment|/************************************************/
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|st_data
index|[
name|unit
index|]
operator|.
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
comment|/* don't wake the job, ok? */
return|return;
block|}
name|printf
argument_list|(
literal|"device busy"
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
block|}
case|case
name|XS_DRIVER_STUFFUP
case|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: unknown error category from scsi driver\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* no longer in use */
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* If there's another waiting.. do it */
block|}
else|else
block|{
name|wakeup
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*******************************************************\ * Perform special action on behalf of the user		* * Knows about the internals of this device		* \*******************************************************/
end_comment

begin_macro
name|stioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|arg
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|int
name|number
decl_stmt|,
name|flags
decl_stmt|,
name|ret
decl_stmt|;
comment|/*******************************************************\ 	* Find the device that the user is talking about	* 	\*******************************************************/
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* give error messages, act on errors etc. */
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
literal|0x7
expr_stmt|;
comment|/* Ultrix compat */
comment|/*?*/
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"[sctape_sstatus: %x %x]\n"
argument_list|,
name|mt
operator|->
name|mt_op
argument_list|,
name|mt
operator|->
name|mt_count
argument_list|)
expr_stmt|;
comment|/* compat: in U*x it is a short */
name|number
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
name|mt
operator|->
name|mt_op
argument_list|)
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
name|ret
operator|=
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
name|ST_WRITTEN
expr_stmt|;
break|break;
case|case
name|MTFSF
case|:
comment|/* forward space file */
name|ret
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
comment|/* backward space file */
name|ret
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
name|number
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTFSR
case|:
comment|/* forward space record */
name|ret
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
name|ret
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
comment|/* rewind */
name|ret
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
if|if
condition|(
operator|(
name|ret
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
operator|)
condition|)
block|{
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"rewind failed, unit still loaded\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
name|ret
operator|=
name|TRUE
expr_stmt|;
empty_stmt|;
break|break;
default|default:
return|return
name|EINVAL
return|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
name|ret
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|ret
condition|?
name|ESUCCESS
else|:
name|EIO
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Check with the device that it is ok, (via scsi driver)* \*******************************************************/
end_comment

begin_macro
name|st_req_sense
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_sense_data
name|sense
decl_stmt|;
name|struct
name|scsi_sense
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REQUEST_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|sense
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|sense
argument_list|,
sizeof|sizeof
argument_list|(
name|sense
argument_list|)
argument_list|,
literal|100000
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get scsi driver to send a "are you ready" command	* \*******************************************************/
end_comment

begin_macro
name|st_test_ready
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_test_unit_ready
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|TEST_UNIT_READY
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
else|else
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a##_1)<< 8) + (unsigned)a##_0 )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a
comment|/**/
value|_1)<< 8) + (unsigned)a
comment|/**/
value|_0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************\ * Ask the drive what it's min and max blk sizes are.	* \*******************************************************/
end_comment

begin_macro
name|st_rd_blk_lim
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_blk_limits
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_blk_limits_data
name|scsi_blkl
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
comment|/*******************************************************\ 	* First check if we have it all loaded			* 	\*******************************************************/
if|if
condition|(
name|st_info_valid
index|[
name|unit
index|]
condition|)
goto|goto
name|done
goto|;
comment|/*******************************************************\ 	* do a 'Read Block Limits'				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_BLK_LIMITS
expr_stmt|;
comment|/*******************************************************\ 	* do the command,	update the global values	* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|scsi_blkl
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_blkl
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"could not get blk limits for unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|st_debug
condition|)
block|{
name|printf
argument_list|(
literal|" (%d<= blksiz<= %d\n) "
argument_list|,
name|b2tol
argument_list|(
name|scsi_blkl
operator|.
name|min_length
argument_list|)
argument_list|,
name|_3btol
argument_list|(
operator|&
name|scsi_blkl
operator|.
name|max_length_2
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|blkmin
operator|=
name|b2tol
argument_list|(
name|scsi_blkl
operator|.
name|min_length
argument_list|)
expr_stmt|;
name|st
operator|->
name|blkmax
operator|=
name|_3btol
argument_list|(
operator|&
name|scsi_blkl
operator|.
name|max_length_2
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|st
operator|->
name|blkmin
operator|&&
operator|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
operator|)
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the scsi driver to send a full inquiry to the	* * device and use the results to fill out the global 	* * parameter structure.					* \*******************************************************/
end_comment

begin_macro
name|st_mode_sense
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_mode_sense
name|scsi_cmd
decl_stmt|;
struct|struct
block|{
name|struct
name|scsi_mode_header_tape
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
block|}
name|scsi_sense
struct|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
comment|/*******************************************************\ 	* First check if we have it all loaded			* 	\*******************************************************/
if|if
condition|(
name|st_info_valid
index|[
name|unit
index|]
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/*******************************************************\ 	* First do a mode sense 				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* do the command, but we don't need the results		* 	* just print them for our interest's sake		* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|scsi_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"could not mode sense for unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
if|if
condition|(
name|st_debug
condition|)
block|{
name|printf
argument_list|(
literal|"unit %d: %d blocks of %d bytes, write %s, %sbuffered"
argument_list|,
name|unit
argument_list|,
name|_3btol
argument_list|(
operator|&
name|scsi_sense
operator|.
name|blk_desc
operator|.
name|nblocks
argument_list|)
argument_list|,
name|_3btol
argument_list|(
operator|&
name|scsi_sense
operator|.
name|blk_desc
operator|.
name|blklen
argument_list|)
argument_list|,
operator|(
name|scsi_sense
operator|.
name|header
operator|.
name|write_protected
condition|?
literal|"protected"
else|:
literal|"enabled"
operator|)
argument_list|,
operator|(
name|scsi_sense
operator|.
name|header
operator|.
name|buf_mode
condition|?
literal|""
else|:
literal|"un"
operator|)
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|numblks
operator|=
name|_3btol
argument_list|(
operator|&
name|scsi_sense
operator|.
name|blk_desc
operator|.
name|nblocks
argument_list|)
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
name|_3btol
argument_list|(
operator|&
name|scsi_sense
operator|.
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the scsi driver to send a full inquiry to the	* * device and use the results to fill out the global 	* * parameter structure.					* \*******************************************************/
end_comment

begin_macro
name|st_mode_select
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|,
argument|dsty_code
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|,
name|dsty_code
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_mode_select
name|scsi_cmd
decl_stmt|;
struct|struct
block|{
name|struct
name|scsi_mode_header_tape
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
block|}
name|dat
struct|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
comment|/*******************************************************\ 	* Set up for a mode select				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
name|dat
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SELECT
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
name|dat
argument_list|)
expr_stmt|;
name|dat
operator|.
name|header
operator|.
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|blk_desc
argument_list|)
expr_stmt|;
name|dat
operator|.
name|header
operator|.
name|buf_mode
operator|=
literal|1
expr_stmt|;
name|dat
operator|.
name|blk_desc
operator|.
name|density
operator|=
name|dsty_code
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|lto3b
argument_list|(
name|st
operator|->
name|blkmin
argument_list|,
name|dat
operator|.
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
block|}
comment|/*	lto3b( st->numblks , dat.blk_desc.nblocks); use defaults!!!! 	lto3b( st->blksiz , dat.blk_desc.blklen); */
comment|/*******************************************************\ 	* do the command					* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|dat
argument_list|,
sizeof|sizeof
argument_list|(
name|dat
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|flags
operator||
name|SCSI_DATA_OUT
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"could not mode select for unit %d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * skip N blocks/filemarks/seq filemarks/eom		* \*******************************************************/
end_comment

begin_macro
name|st_space
argument_list|(
argument|unit
argument_list|,
argument|number
argument_list|,
argument|what
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|number
decl_stmt|,
name|what
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_space
name|scsi_cmd
decl_stmt|;
comment|/* if we are at a filemark now, we soon won't be*/
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|.
name|code
operator|=
name|what
expr_stmt|;
name|lto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|600000
argument_list|,
comment|/* 10 mins enough? */
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"could not space st%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * write N filemarks					* \*******************************************************/
end_comment

begin_macro
name|st_write_filemarks
argument_list|(
argument|unit
argument_list|,
argument|number
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|number
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_write_filemarks
name|scsi_cmd
decl_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
name|lto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|,
comment|/* 10 secs.. (may need to repos head )*/
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"could not write_filemarks st%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * load /unload (with retension if true)			* \*******************************************************/
end_comment

begin_macro
name|st_load
argument_list|(
argument|unit
argument_list|,
argument|type
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_load
name|scsi_cmd
decl_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|LOAD_UNLOAD
expr_stmt|;
name|scsi_cmd
operator|.
name|load
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LD_LOAD
condition|)
block|{
comment|/*scsi_cmd.reten=TRUE;*/
name|scsi_cmd
operator|.
name|reten
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|scsi_cmd
operator|.
name|reten
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|30000
argument_list|,
comment|/* 30 secs */
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cannot load/unload  st%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Prevent or allow the user to remove the tape		* \*******************************************************/
end_comment

begin_macro
name|st_prevent
argument_list|(
argument|unit
argument_list|,
argument|type
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_prevent
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|PREVENT_ALLOW
expr_stmt|;
name|scsi_cmd
operator|.
name|prevent
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|5000
argument_list|,
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"cannot prevent/allow on st%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ *  Rewind the device					* \*******************************************************/
end_comment

begin_macro
name|st_rewind
argument_list|(
argument|unit
argument_list|,
argument|immed
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|immed
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_rewind
name|scsi_cmd
decl_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REWIND
expr_stmt|;
name|scsi_cmd
operator|.
name|immed
operator|=
name|immed
expr_stmt|;
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|immed
condition|?
literal|5000
else|:
literal|300000
argument_list|,
comment|/* 5 sec or 5 min */
name|flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_SILENT
operator|)
condition|)
name|printf
argument_list|(
literal|"could not rewind st%d\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * ask the scsi driver to perform a command for us.	* * Call it through the switch table, and tell it which	* * sub-unit we want, and what target and lu we wish to	* * talk to. Also tell it where to find the command	* * how long int is.					* * Also tell it where to read/write the data, and how	* * long the data is supposed to be			* \*******************************************************/
end_comment

begin_function
name|int
name|st_scsi_cmd
parameter_list|(
name|unit
parameter_list|,
name|scsi_cmd
parameter_list|,
name|cmdlen
parameter_list|,
name|data_addr
parameter_list|,
name|datalen
parameter_list|,
name|timeout
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|scsi_generic
modifier|*
name|scsi_cmd
decl_stmt|;
name|int
name|cmdlen
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|u_char
modifier|*
name|data_addr
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
operator|+
name|unit
decl_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"\nst_scsi_cmd%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|sc_sw
condition|)
comment|/* If we have a scsi driver */
block|{
name|xs
operator|=
operator|&
operator|(
name|st_scsi_xfer
index|[
name|unit
index|]
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|st_xfer_block_wait
index|[
name|unit
index|]
operator|++
expr_stmt|;
comment|/* there is someone waiting */
while|while
condition|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
condition|)
block|{
name|sleep
argument_list|(
operator|&
name|st_xfer_block_wait
index|[
name|unit
index|]
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|st_xfer_block_wait
index|[
name|unit
index|]
operator|--
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
name|INUSE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 		* Fill out the scsi_xfer structure			* 		\*******************************************************/
name|xs
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|xs
operator|->
name|adapter
operator|=
name|st
operator|->
name|ctlr
expr_stmt|;
name|xs
operator|->
name|targ
operator|=
name|st
operator|->
name|targ
expr_stmt|;
name|xs
operator|->
name|lu
operator|=
name|st
operator|->
name|lu
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
name|ST_RETRIES
expr_stmt|;
name|xs
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|xs
operator|->
name|cmd
operator|=
name|scsi_cmd
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|xs
operator|->
name|data
operator|=
name|data_addr
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|when_done
operator|=
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|?
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
literal|0
else|:
name|st_done
expr_stmt|;
name|xs
operator|->
name|done_arg
operator|=
name|unit
expr_stmt|;
name|xs
operator|->
name|done_arg2
operator|=
operator|(
name|int
operator|)
name|xs
expr_stmt|;
name|retry
label|:
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
literal|0
expr_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|st
operator|->
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|SUCCESSFULLY_QUEUED
case|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
name|sleep
argument_list|(
name|xs
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
case|case
name|HAD_ERROR
case|:
case|case
name|COMPLETE
case|:
switch|switch
condition|(
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
name|retval
operator|=
name|ESUCCESS
expr_stmt|;
break|break;
case|case
name|XS_SENSE
case|:
name|retval
operator|=
operator|(
name|st_interpret_sense
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
operator|)
expr_stmt|;
comment|/* only useful for reads */
if|if
condition|(
name|retval
condition|)
block|{
comment|/* error... don't care about filemarks */
name|st
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|retval
operator|=
name|ESUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|XS_DRIVER_STUFFUP
case|:
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|XS_TIMEOUT
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|XS_BUSY
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
name|printf
argument_list|(
literal|"st%d: unknown error category from scsi driver\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TRY_AGAIN_LATER
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* it's free! */
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"st%d: not set up\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Look at the returned sense and act on the error and detirmine	* * The unix error number to pass back... (0 = report no error)	* \***************************************************************/
end_comment

begin_function
name|int
name|st_interpret_sense
parameter_list|(
name|unit
parameter_list|,
name|xs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|key
decl_stmt|;
name|int
name|silent
init|=
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
decl_stmt|;
comment|/***************************************************************\ 	* If errors are ok, report a success				* 	\***************************************************************/
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
condition|)
return|return
operator|(
name|ESUCCESS
operator|)
return|;
comment|/***************************************************************\ 	* Get the sense fields and work out what CLASS			* 	\***************************************************************/
name|sense
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
if|if
condition|(
name|st_debug
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"code%x class%x valid%x\n"
argument_list|,
name|sense
operator|->
name|error_code
argument_list|,
name|sense
operator|->
name|error_class
argument_list|,
name|sense
operator|->
name|valid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"seg%x key%x ili%x eom%x fmark%x\n"
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|segment
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|sense_key
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|ili
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|eom
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|filemark
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info: %x %x %x %x followed by %d extra bytes\n"
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extra: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_len
condition|)
block|{
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_bytes
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|sense
operator|->
name|error_class
condition|)
block|{
comment|/***************************************************************\ 	* If it's class 7, use the extended stuff and interpret the key	* 	\***************************************************************/
case|case
literal|7
case|:
block|{
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|eom
condition|)
block|{
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator||=
name|ST_AT_EOM
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|filemark
condition|)
block|{
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator||=
name|ST_AT_FILEMARK
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|ili
condition|)
block|{
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
comment|/*******************************\ 				* In all ili cases, note that	* 				* the resid is non-0 AND not 	* 				* unchanged.			* 				\*******************************/
name|xs
operator|->
name|resid
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|bp
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|resid
operator|<
literal|0
condition|)
block|{
comment|/* never on block devices */
comment|/***********************\ 						* it's only really bad	* 						* if we have lost data	* 						* (the record was 	* 						* bigger than the read)	* 						\***********************/
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* makes no sense.. complain */
name|printf
argument_list|(
literal|"BAD length error?"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* there may be some other error. check the rest */
name|key
operator|=
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|sense_key
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|0x0
case|:
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x1
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: soft error(corrected) "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x2
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: not ready\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
literal|0x3
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: medium error "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0x4
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: non-media hardware failure\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0x5
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: illegal request\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0x6
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: Unit attention.\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_AT_EOM
operator|)
expr_stmt|;
name|st_info_valid
index|[
name|unit
index|]
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|st_data
index|[
name|unit
index|]
operator|.
name|flags
operator|&
name|ST_OPEN
condition|)
comment|/* TEMP!!!! */
return|return
operator|(
name|EIO
operator|)
return|;
else|else
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x7
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: attempted protection violation "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
literal|0x8
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: block wrong state (worm)\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0x9
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: vendor unique\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xa
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: copy aborted\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xb
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: command aborted\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xc
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: search returned\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0xd
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: volume overflow\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
case|case
literal|0xe
case|:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: verify miscompare\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
block|{
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|EIO
operator|)
return|;
case|case
literal|0xf
case|:
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: unknown error key\n "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
break|break;
block|}
comment|/***************************************************************\ 	* If it's NOT class 7, just report it.				* 	\***************************************************************/
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: error class %d code %d\n"
argument_list|,
name|unit
argument_list|,
name|sense
operator|->
name|error_class
argument_list|,
name|sense
operator|->
name|error_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|valid
condition|)
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"block no. %d (decimal)\n"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockhi
operator|<<
literal|16
operator|)
argument_list|,
operator|+
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockmed
operator|<<
literal|8
operator|)
argument_list|,
operator|+
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blocklow
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OSF
argument_list|)
end_if

begin_macro
name|stsize
argument_list|(
argument|dev_t dev
argument_list|)
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"stsize()        -- not implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|stdump
argument_list|()
end_macro

begin_block
block|{
name|printf
argument_list|(
literal|"stdump()        -- not implemented\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(OSF) */
end_comment

end_unit

