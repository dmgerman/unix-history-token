begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)(now julian@DIALix.oz.au)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  *  * PATCHES MAGIC                LEVEL   PATCH THAT GOT US HERE  * --------------------         -----   ----------------------  * CURRENT PATCH LEVEL:         1       00098  * --------------------         -----   ----------------------  *  * 16 Feb 93	Julian Elischer		ADDED for SCSI system  * 1.15 is the last verion to support MACH and OSF/1  */
end_comment

begin_comment
comment|/* $Revision: 1.25 $ */
end_comment

begin_comment
comment|/*  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  * major changes by Julian Elischer (julian@jules.dialix.oz.au) May 1993  *  *	$Id: st.c,v 1.25 93/08/31 21:29:41 julian Exp Locker: julian $  */
end_comment

begin_comment
comment|/*  * To do:  * work out some better way of guessing what a good timeout is going  * to be depending on whether we expect to retension or not.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<st.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/mtio.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_tape.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_decl_stmt
name|long
name|int
name|ststrats
decl_stmt|,
name|stqueues
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Defines for device specific stuff */
end_comment

begin_define
define|#
directive|define
name|PAGE_0_SENSE_DATA_SIZE
value|12
end_define

begin_define
define|#
directive|define
name|PAGESIZ
value|4096
end_define

begin_define
define|#
directive|define
name|DEF_FIXED_BSIZE
value|512
end_define

begin_define
define|#
directive|define
name|STQSIZE
value|4
end_define

begin_define
define|#
directive|define
name|ST_RETRIES
value|4
end_define

begin_define
define|#
directive|define
name|MODE
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)& 0x03) )
end_define

begin_define
define|#
directive|define
name|DSTY
parameter_list|(
name|z
parameter_list|)
value|( ((minor(z)>> 2)& 0x03) )
end_define

begin_define
define|#
directive|define
name|UNIT
parameter_list|(
name|z
parameter_list|)
value|(  (minor(z)>> 4) )
end_define

begin_define
define|#
directive|define
name|DSTY3
value|3
end_define

begin_define
define|#
directive|define
name|DSTY2
value|2
end_define

begin_define
define|#
directive|define
name|DSTY1
value|1
end_define

begin_define
define|#
directive|define
name|SCSI_2_MAX_DENSITY_CODE
value|0x17
end_define

begin_comment
comment|/* maximum density code specified 					   in SCSI II spec. */
end_comment

begin_comment
comment|/***************************************************************\ * Define various devices that we know mis-behave in some way,	* * and note how they are bad, so we can correct for them		* \***************************************************************/
end_comment

begin_struct
struct|struct
name|modes
block|{
name|int
name|quirks
decl_stmt|;
comment|/* same definitions as in rogues */
name|char
name|density
decl_stmt|;
name|char
name|spare
index|[
literal|3
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|rogues
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|manu
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|int
name|quirks
decl_stmt|;
comment|/* valid for all modes */
name|struct
name|modes
name|modes
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* define behaviour codes (quirks) */
end_comment

begin_define
define|#
directive|define
name|ST_Q_NEEDS_PAGE_0
value|0x00001
end_define

begin_define
define|#
directive|define
name|ST_Q_FORCE_FIXED_MODE
value|0x00002
end_define

begin_define
define|#
directive|define
name|ST_Q_FORCE_VAR_MODE
value|0x00004
end_define

begin_define
define|#
directive|define
name|ST_Q_SNS_HLP
value|0x00008
end_define

begin_define
define|#
directive|define
name|ST_Q_IGNORE_LOADS
value|0x00010
end_define

begin_decl_stmt
specifier|static
name|struct
name|rogues
name|gallery
index|[]
init|=
comment|/* ends with an all null entry */
block|{
block|{
literal|"Such an old device "
block|,
literal|"pre-scsi"
block|,
literal|" unknown model  "
block|,
literal|"????"
block|,
literal|0
block|,
block|{
block|{
name|ST_Q_FORCE_FIXED_MODE
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3 */
block|{
name|ST_Q_FORCE_FIXED_MODE
block|,
name|QIC_24
block|}
block|,
comment|/* minor  4,5,6,7 */
block|{
name|ST_Q_FORCE_VAR_MODE
block|,
name|HALFINCH_1600
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
name|ST_Q_FORCE_VAR_MODE
block|,
name|HALFINCH_6250
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
literal|"Tandberg tdc3600"
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3600"
block|,
literal|"????"
block|,
name|ST_Q_NEEDS_PAGE_0
block|,
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3*/
block|{
name|ST_Q_FORCE_VAR_MODE
block|,
name|QIC_525
block|}
block|,
comment|/* minor  4,5,6,7*/
block|{
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
literal|0
block|,
name|QIC_120
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
literal|"Rev 5 of the Archive 2525"
block|,
literal|"ARCHIVE "
block|,
literal|"VIPER 2525 25462"
block|,
literal|"-005"
block|,
literal|0
block|,
block|{
block|{
name|ST_Q_SNS_HLP
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3*/
block|{
name|ST_Q_SNS_HLP
block|,
name|QIC_525
block|}
block|,
comment|/* minor  4,5,6,7*/
block|{
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
literal|0
block|,
name|QIC_120
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
literal|"Archive  Viper 150"
block|,
literal|"ARCHIVE "
block|,
literal|"VIPER 150"
block|,
literal|"????"
block|,
name|ST_Q_NEEDS_PAGE_0
block|,
block|{
block|{
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor  0,1,2,3*/
block|{
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor  4,5,6,7*/
block|{
literal|0
block|,
name|QIC_120
block|}
block|,
comment|/* minor  8,9,10,11*/
block|{
literal|0
block|,
name|QIC_24
block|}
comment|/* minor  12,13,14,15*/
block|}
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|ststrategy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|stminphys
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ESUCCESS
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|STDEBUG
end_ifdef

begin_decl_stmt
name|int
name|st_debug
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*STDEBUG*/
end_comment

begin_function_decl
name|int
name|stattach
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|st_done
parameter_list|()
function_decl|;
end_function_decl

begin_struct
struct|struct
name|st_data
block|{
comment|/*--------------------present operating parameters, flags etc.----------------*/
name|int
name|flags
decl_stmt|;
comment|/* see below 			      */
name|int
name|blksiz
decl_stmt|;
comment|/* blksiz we are using		      */
name|int
name|density
decl_stmt|;
comment|/* present density 		      */
name|int
name|quirks
decl_stmt|;
comment|/* quirks for the open mode	      */
name|int
name|last_dsty
decl_stmt|;
comment|/* last density used		      */
comment|/*--------------------device/scsi parameters----------------------------------*/
name|struct
name|scsi_switch
modifier|*
name|sc_sw
decl_stmt|;
comment|/* address of scsi low level switch   */
name|int
name|ctlr
decl_stmt|;
comment|/* so they know which one we want     */
name|int
name|targ
decl_stmt|;
comment|/* our scsi target ID 		      */
name|int
name|lu
decl_stmt|;
comment|/* our scsi lu 			      */
comment|/*--------------------parameters reported by the device ----------------------*/
name|int
name|blkmin
decl_stmt|;
comment|/* min blk size 		      */
name|int
name|blkmax
decl_stmt|;
comment|/* max blk size 		      */
comment|/*--------------------parameters reported by the device for this media--------*/
name|int
name|numblks
decl_stmt|;
comment|/* nominal blocks capacity 	      */
name|int
name|media_blksiz
decl_stmt|;
comment|/* 0 if not ST_FIXEDBLOCKS 	      */
name|int
name|media_density
decl_stmt|;
comment|/* this is what it said when asked    */
comment|/*--------------------quirks for the whole drive------------------------------*/
name|int
name|drive_quirks
decl_stmt|;
comment|/* quirks of this drive		      */
comment|/*--------------------How we should set up when openning each minor device----*/
name|struct
name|modes
name|modes
index|[
literal|4
index|]
decl_stmt|;
comment|/* plus more for each mode 	      */
comment|/*--------------------storage for sense data returned by the drive------------*/
name|unsigned
name|char
name|sense_data
index|[
literal|12
index|]
decl_stmt|;
comment|/* additional sense data needed       */
comment|/* for mode sense/select. 	      */
name|struct
name|buf
modifier|*
name|buf_queue
decl_stmt|;
comment|/* the queue of pending IO operations */
name|struct
name|scsi_xfer
name|scsi_xfer
decl_stmt|;
comment|/* The scsi xfer struct for this drive*/
name|int
name|xfer_block_wait
decl_stmt|;
comment|/* whether there is a process waiting */
block|}
modifier|*
name|st_data
index|[
name|NST
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|ST_INITIALIZED
value|0x01
end_define

begin_define
define|#
directive|define
name|ST_INFO_VALID
value|0x02
end_define

begin_define
define|#
directive|define
name|ST_OPEN
value|0x04
end_define

begin_define
define|#
directive|define
name|ST_BLOCK_SET
value|0x08
end_define

begin_comment
comment|/* block size, mode set by ioctl      */
end_comment

begin_define
define|#
directive|define
name|ST_WRITTEN
value|0x10
end_define

begin_define
define|#
directive|define
name|ST_FIXEDBLOCKS
value|0x20
end_define

begin_define
define|#
directive|define
name|ST_AT_FILEMARK
value|0x40
end_define

begin_define
define|#
directive|define
name|ST_EIO_PENDING
value|0x80
end_define

begin_comment
comment|/* we couldn't report it then (had data)*/
end_comment

begin_define
define|#
directive|define
name|ST_AT_BOM
value|0x100
end_define

begin_comment
comment|/* ops history suggests Beg of Medium */
end_comment

begin_define
define|#
directive|define
name|ST_READONLY
value|0x200
end_define

begin_comment
comment|/* st_mode_sense says write protected */
end_comment

begin_define
define|#
directive|define
name|ST_PER_ACTION
value|(ST_AT_FILEMARK | ST_EIO_PENDING)
end_define

begin_define
define|#
directive|define
name|ST_PER_OPEN
value|(ST_OPEN | ST_PER_ACTION)
end_define

begin_define
define|#
directive|define
name|ST_PER_MEDIA
value|(ST_INFO_VALID | ST_BLOCK_SET | ST_WRITTEN | \ 			ST_FIXEDBLOCKS | ST_AT_BOM | ST_READONLY | \ 			ST_PER_ACTION)
end_define

begin_decl_stmt
specifier|static
name|int
name|next_st_unit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************\ * The routine called by the low level scsi routine when it discovers	* * A device suitable for this driver					* \***********************************************************************/
end_comment

begin_function
name|int
name|stattach
parameter_list|(
name|ctlr
parameter_list|,
name|targ
parameter_list|,
name|lu
parameter_list|,
name|scsi_switch
parameter_list|)
name|struct
name|scsi_switch
modifier|*
name|scsi_switch
decl_stmt|;
block|{
name|int
name|unit
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"stattach: "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
comment|/*******************************************************\ 	* Check we have the resources for another drive		* 	\*******************************************************/
name|unit
operator|=
name|next_st_unit
operator|++
expr_stmt|;
if|if
condition|(
name|unit
operator|>=
name|NST
condition|)
block|{
name|printf
argument_list|(
literal|"Too many scsi tapes..(%d> %d) reconfigure kernel\n"
argument_list|,
operator|(
name|unit
operator|+
literal|1
operator|)
argument_list|,
name|NST
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|st_data
index|[
name|unit
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: Already has storage!\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|st
operator|=
name|st_data
index|[
name|unit
index|]
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|st_data
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|st
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: malloc failed in st.c\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Store information needed to contact our base driver	* 	\*******************************************************/
name|st
operator|->
name|sc_sw
operator|=
name|scsi_switch
expr_stmt|;
name|st
operator|->
name|ctlr
operator|=
name|ctlr
expr_stmt|;
name|st
operator|->
name|targ
operator|=
name|targ
expr_stmt|;
name|st
operator|->
name|lu
operator|=
name|lu
expr_stmt|;
comment|/*******************************************************\ 	* Store information about default densities 		* 	\*******************************************************/
name|st
operator|->
name|modes
index|[
name|DSTY1
index|]
operator|.
name|density
operator|=
name|QIC_525
expr_stmt|;
name|st
operator|->
name|modes
index|[
name|DSTY2
index|]
operator|.
name|density
operator|=
name|QIC_150
expr_stmt|;
name|st
operator|->
name|modes
index|[
name|DSTY3
index|]
operator|.
name|density
operator|=
name|QIC_120
expr_stmt|;
comment|/*******************************************************\ 	* Check if the drive is a known criminal and take	* 	* Any steps needed to bring it into line		* 	\*******************************************************/
name|st_identify_drive
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Use the subdriver to request information regarding	* 	* the drive. We cannot use interrupts yet, so the	* 	* request must specify this.				* 	\*******************************************************/
if|if
condition|(
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: drive offline\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|st_test_ready
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: density code 0x%x, "
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|media_density
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|media_blksiz
condition|)
block|{
name|printf
argument_list|(
literal|"%d-byte"
argument_list|,
name|st
operator|->
name|media_blksiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"variable"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" blocks, write-%s\n"
argument_list|,
name|st
operator|->
name|flags
operator|&
name|ST_READONLY
condition|?
literal|"protected"
else|:
literal|"enabled"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"st%d: drive empty\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*******************************************************\ 	* Set up the bufs for this device			* 	\*******************************************************/
name|st
operator|->
name|buf_queue
operator|=
literal|0
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_INITIALIZED
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/***********************************************************************\ * Use the identify routine in 'scsiconf' to get drive info so we can	* * Further tailor our behaviour.						* \***********************************************************************/
end_comment

begin_macro
name|st_identify_drive
argument_list|(
argument|unit
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
name|struct
name|scsi_inquiry_data
name|inqbuf
decl_stmt|;
name|struct
name|rogues
modifier|*
name|finger
decl_stmt|;
name|char
name|manu
index|[
literal|32
index|]
decl_stmt|;
name|char
name|model
index|[
literal|32
index|]
decl_stmt|;
name|char
name|model2
index|[
literal|32
index|]
decl_stmt|;
name|char
name|version
index|[
literal|32
index|]
decl_stmt|;
name|int
name|model_len
decl_stmt|;
comment|/*******************************************************\ 	* Get the device type information                       * 	\*******************************************************/
if|if
condition|(
name|scsi_inquire
argument_list|(
name|st
operator|->
name|ctlr
argument_list|,
name|st
operator|->
name|targ
argument_list|,
name|st
operator|->
name|lu
argument_list|,
name|st
operator|->
name|sc_sw
argument_list|,
operator|&
name|inqbuf
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
operator|!=
name|COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: couldn't get device type, using default\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|inqbuf
operator|.
name|version
operator|&
name|SID_ANSII
operator|)
operator|==
literal|0
condition|)
block|{
comment|/***********************************************\ 		* If not advanced enough, use default values    * 		\***********************************************/
name|strncpy
argument_list|(
name|manu
argument_list|,
literal|"pre-scsi"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|manu
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
literal|" unknown model  "
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|model
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
literal|"????"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|version
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|manu
argument_list|,
name|inqbuf
operator|.
name|vendor
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|manu
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|model
argument_list|,
name|inqbuf
operator|.
name|product
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|model
index|[
literal|16
index|]
operator|=
literal|0
expr_stmt|;
name|strncpy
argument_list|(
name|version
argument_list|,
name|inqbuf
operator|.
name|revision
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|version
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Load the parameters for this kind of device, so we	* 	* treat it as appropriate for each operating mode 	* 	* Only check the number of characters in the array's	* 	* model entry, not the entire model string returned.	* 	\*******************************************************/
name|finger
operator|=
name|gallery
expr_stmt|;
while|while
condition|(
name|finger
operator|->
name|name
condition|)
block|{
name|model_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|finger
operator|->
name|model
index|[
name|model_len
index|]
operator|&&
operator|(
name|model_len
operator|<
literal|32
operator|)
condition|)
block|{
name|model2
index|[
name|model_len
index|]
operator|=
name|model
index|[
name|model_len
index|]
expr_stmt|;
name|model_len
operator|++
expr_stmt|;
block|}
name|model2
index|[
name|model_len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|manu
argument_list|,
name|finger
operator|->
name|manu
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|model2
argument_list|,
name|finger
operator|->
name|model
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"????????????????"
argument_list|,
name|finger
operator|->
name|model
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|version
argument_list|,
name|finger
operator|->
name|version
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"????"
argument_list|,
name|finger
operator|->
name|version
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: %s is a known rogue\n"
argument_list|,
name|unit
argument_list|,
name|finger
operator|->
name|name
argument_list|)
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|0
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|0
index|]
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|1
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|1
index|]
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|2
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|2
index|]
expr_stmt|;
name|st
operator|->
name|modes
index|[
literal|3
index|]
operator|=
name|finger
operator|->
name|modes
index|[
literal|3
index|]
expr_stmt|;
name|st
operator|->
name|drive_quirks
operator|=
name|finger
operator|->
name|quirks
expr_stmt|;
name|st
operator|->
name|quirks
operator|=
name|finger
operator|->
name|quirks
expr_stmt|;
comment|/*start value*/
break|break;
block|}
else|else
block|{
name|finger
operator|++
expr_stmt|;
comment|/* go to next suspect */
block|}
block|}
block|}
end_block

begin_comment
comment|/*******************************************************\ *	open the device.				* \*******************************************************/
end_comment

begin_macro
name|stopen
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|int
name|unit
decl_stmt|,
name|mode
decl_stmt|,
name|dsty
decl_stmt|;
name|int
name|errno
init|=
literal|0
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Check the unit is legal                               * 	\*******************************************************/
if|if
condition|(
name|unit
operator|>=
name|NST
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
name|st
operator|=
name|st_data
index|[
name|unit
index|]
expr_stmt|;
comment|/*******************************************************\ 	* Make sure the device has been initialised		* 	\*******************************************************/
if|if
condition|(
operator|(
name|st
operator|==
name|NULL
operator|)
operator|||
operator|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INITIALIZED
operator|)
operator|)
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
comment|/*******************************************************\ 	* Only allow one at a time				* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_OPEN
condition|)
block|{
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Throw out a dummy instruction to catch 'Unit attention* 	* errors (the error handling will invalidate all our	* 	* device info if we get one, but otherwise, ignore it	* 	\*******************************************************/
name|st_test_ready
argument_list|(
name|unit
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
comment|/***************************************************************\ 	* Check that the device is ready to use	 (media loaded?)	* 	* This time take notice of the return result			* 	\***************************************************************/
if|if
condition|(
name|errno
operator|=
operator|(
name|st_test_ready
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: not ready\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Set up the mode flags according to the minor number	* 	* ensure all open flags are in a known state		* 	* if it's a different mode, dump all cached parameters	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|last_dsty
operator|!=
name|dsty
operator|||
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
name|st
operator|->
name|last_dsty
operator|=
name|dsty
expr_stmt|;
name|st
operator|->
name|quirks
operator|=
name|st
operator|->
name|drive_quirks
operator||
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|quirks
expr_stmt|;
name|st
operator|->
name|density
operator|=
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|density
expr_stmt|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_OPEN
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
operator|(
name|PRINTROUTINES
operator||
name|TRACEOPENS
operator|)
condition|)
name|printf
argument_list|(
literal|"stopen: dev=0x%x (unit %d (of %d))\n"
argument_list|,
name|dev
argument_list|,
name|unit
argument_list|,
name|NST
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
comment|/***************************************************************\ 	* If the media is new, then make sure we give it a chance to	* 	* to do a 'load' instruction.					* 	\***************************************************************/
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
comment|/* is media new? */
block|{
if|if
condition|(
name|errno
operator|=
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_LOAD
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_SNS_HLP
condition|)
block|{
comment|/***********************************************\ 			* The quirk here is that the drive returns some	* 			* value to st_mode_sense incorrectly until the	* 			* tape has actually passed by the head.		* 			*						* 			* The method is to set the drive to large	* 			* fixed-block state (user-specified density and	* 			* 1024-byte blocks), then read and rewind to	* 			* get it to sense the tape.  If that doesn't	* 			* work, try 512-byte fixed blocks.  If that	* 			* doesn't work, as a last resort, try variable-	* 			* length blocks.  The result will be the	* 			* ability to do an accurate st_mode_sense.	* 			*						* 			* We pretend not to be at beginning of medium	* 			* to keep st_read from calling st_decide_mode.	* 			*						* 			* We know we can do a rewind because we just	* 			* did a load, which implies rewind.  Rewind	* 			* seems preferable to space backward if	we have	* 			* a virgin tape.				* 			*						* 			* The rest of the code for this quirk is in ILI	* 			* processing and BLANK CHECK error processing,	* 			* both part of st_interpret_sense.		* 			\***********************************************/
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|readsiz
decl_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
literal|1024
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
if|if
condition|(
name|errno
operator|=
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|st
operator|->
name|blksiz
operator|=
literal|1024
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|st
operator|->
name|blksiz
condition|)
block|{
case|case
literal|512
case|:
case|case
literal|1024
case|:
name|readsiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
break|break;
default|default:
name|readsiz
operator|=
literal|1
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
if|if
condition|(
name|errno
operator|=
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_BOM
expr_stmt|;
name|st_read
argument_list|(
name|unit
argument_list|,
name|buf
argument_list|,
name|readsiz
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bad
label|:
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
return|return
operator|(
name|errno
operator|)
return|;
block|}
block|}
do|while
condition|(
name|readsiz
operator|!=
literal|1
operator|&&
name|readsiz
operator|>
name|st
operator|->
name|blksiz
condition|)
do|;
name|free
argument_list|(
name|buf
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*******************************************************\ 	* Load the physical device parameters			* 	* loads: blkmin, blkmax					* 	\*******************************************************/
if|if
condition|(
name|errno
operator|=
name|st_rd_blk_lim
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|errno
operator|)
return|;
block|}
comment|/*******************************************************\ 	* Load the media dependent parameters			* 	* includes: media_blksiz,media_density,numblks		* 	\*******************************************************/
if|if
condition|(
name|errno
operator|=
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
block|{
return|return
operator|(
name|errno
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
operator|&&
name|dsty
operator|==
literal|0
condition|)
block|{
comment|/*******************************************************\ 		* If the user defaulted the density, use the drive's	* 		* opinion of it.					* 		\*******************************************************/
name|st
operator|->
name|quirks
operator|=
name|st
operator|->
name|drive_quirks
expr_stmt|;
name|st
operator|->
name|density
operator|=
name|st
operator|->
name|media_density
expr_stmt|;
do|do
block|{
if|if
condition|(
name|st
operator|->
name|density
operator|==
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|density
condition|)
block|{
name|st
operator|->
name|quirks
operator||=
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|quirks
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"selected density %d\n"
argument_list|,
name|dsty
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
break|break;
comment|/* only out of the loop*/
block|}
block|}
do|while
condition|(
operator|++
name|dsty
operator|<
literal|4
condition|)
do|;
comment|/*******************************************************\ 		* If dsty got to 4, the drive must have reported a	* 		* density which isn't in our density list (e.g. QIC-24	* 		* for a default drive).  We can handle that, except	* 		* there'd better be no density-specific quirks in the	* 		* drive's behavior.					* 		\*******************************************************/
block|}
name|st
operator|->
name|flags
operator||=
name|ST_INFO_VALID
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_PREVENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* who cares if it fails? */
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"Params loaded "
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
name|st
operator|->
name|flags
operator||=
name|ST_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * close the device.. only called if we are the LAST	* * occurence of an open device				* \*******************************************************/
end_comment

begin_macro
name|stclose
argument_list|(
argument|dev
argument_list|)
end_macro

begin_block
block|{
name|unsigned
name|char
name|unit
decl_stmt|,
name|mode
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|TRACEOPENS
condition|)
name|printf
argument_list|(
literal|"Closing device"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_WRITTEN
condition|)
block|{
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_MEDIA
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/*non rewind*/
comment|/* possibly space forward if not already at EOF? */
comment|/* (fixed block mode only) */
break|break;
case|case
literal|2
case|:
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_MEDIA
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* a bit silly really */
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_MEDIA
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: close: Bad mode (minor number)%d how's it open?\n"
argument_list|,
name|unit
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_OPEN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/***************************************************************\ * Given all we know about the device, media, mode, 'quirks' and	* * initial operation, make a decision as to how we should be set	* * up.  First, choose the density, then variable/fixed blocks.	* \***************************************************************/
end_comment

begin_macro
name|st_decide_mode
argument_list|(
argument|unit
argument_list|,
argument|first_read
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|first_read
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dsty
decl_stmt|,
name|error
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
comment|/***************************************************************\ 	* First, if our information about the tape is out of date, get	* 	* new information.						* 	\***************************************************************/
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|st_mode_sense
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|st
operator|->
name|flags
operator||=
name|ST_INFO_VALID
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"starting mode decision\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
comment|/***************************************************************\ 	* If the user has already specified fixed or variable-length	* 	* blocks using an ioctl, just believe him. OVERRIDE ALL		* 	\***************************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_BLOCK_SET
condition|)
block|{
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"user has specified %s mode\n"
argument_list|,
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|?
literal|"fixed"
else|:
literal|"variable"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
block|}
comment|/***************************************************************\ 	* If the user hasn't already specified fixed or variable-length	* 	* blocks and the block size (zero if variable-length), we'll	* 	* have to try to figure them out ourselves.			* 	*								* 	* Our first shot at a method is, "The quirks made me do it!"	* 	\***************************************************************/
switch|switch
condition|(
name|st
operator|->
name|quirks
operator|&
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator||
name|ST_Q_FORCE_VAR_MODE
operator|)
condition|)
block|{
case|case
operator|(
name|ST_Q_FORCE_FIXED_MODE
operator||
name|ST_Q_FORCE_VAR_MODE
operator|)
case|:
name|printf
argument_list|(
literal|"st%d: bad quirks\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
name|ST_Q_FORCE_FIXED_MODE
case|:
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|blkmin
operator|&&
operator|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
operator|)
condition|)
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|blkmin
expr_stmt|;
elseif|else
if|if
condition|(
name|st
operator|->
name|media_blksiz
operator|>
literal|0
condition|)
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
else|else
name|st
operator|->
name|blksiz
operator|=
name|DEF_FIXED_BSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"Quirks force fixed mode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
case|case
name|ST_Q_FORCE_VAR_MODE
case|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"Quirks force variable mode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
block|}
comment|/***************************************************************\ 	* If the drive can only handle fixed-length blocks and only at	* 	* one size, perhaps we should just do that.			* 	\***************************************************************/
if|if
condition|(
name|st
operator|->
name|blkmin
operator|&&
operator|(
name|st
operator|->
name|blkmin
operator|==
name|st
operator|->
name|blkmax
operator|)
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|blkmin
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"blkmin == blkmax of %d\n"
argument_list|,
name|st
operator|->
name|blkmin
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
block|}
comment|/***************************************************************\ 	* If the tape density mandates use of fixed or variable-length	* 	* blocks, comply.						* 	\***************************************************************/
switch|switch
condition|(
name|st
operator|->
name|density
condition|)
block|{
case|case
name|HALFINCH_800
case|:
case|case
name|HALFINCH_1600
case|:
case|case
name|HALFINCH_6250
case|:
case|case
name|DDS
case|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"density specified variable\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
case|case
name|QIC_11
case|:
case|case
name|QIC_24
case|:
case|case
name|QIC_120
case|:
case|case
name|QIC_150
case|:
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|media_blksiz
operator|>
literal|0
condition|)
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
else|else
name|st
operator|->
name|blksiz
operator|=
name|DEF_FIXED_BSIZE
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"density specified fixed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
block|}
comment|/***************************************************************\ 	* If we're about to read the tape, perhaps we should choose	* 	* fixed or variable-length blocks and block size according to	* 	* what the drive found on the tape.				* 	\***************************************************************/
if|if
condition|(
name|first_read
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|media_blksiz
operator|==
literal|0
condition|)
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
else|else
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
name|st
operator|->
name|media_blksiz
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"Used media_blksiz of %d\n"
argument_list|,
name|st
operator|->
name|media_blksiz
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
goto|goto
name|done
goto|;
block|}
comment|/***************************************************************\ 	* We're getting no hints from any direction.  Choose variable-	* 	* length blocks arbitrarily.					* 	\***************************************************************/
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
name|st
operator|->
name|blksiz
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"Give up and default to variable mode\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
name|done
label|:
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_BOM
expr_stmt|;
return|return
operator|(
name|st_mode_select
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * trim the size of the transfer if needed,		* * called by physio					* * basically the smaller of our min and the scsi driver's* * minphys						* \*******************************************************/
end_comment

begin_function
name|void
name|stminphys
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
operator|(
operator|*
operator|(
name|st_data
index|[
name|UNIT
argument_list|(
name|bp
operator|->
name|b_dev
argument_list|)
index|]
operator|->
name|sc_sw
operator|->
name|scsi_minphys
operator|)
operator|)
operator|(
name|bp
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Actually translate the requested transfer into	* * one the physical driver can understand		* * The transfer is described by a buf and will include	* * only one physical transfer.				* \*******************************************************/
end_comment

begin_function
name|int
name|ststrategy
parameter_list|(
name|bp
parameter_list|)
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
modifier|*
name|dp
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
name|ststrats
operator|++
expr_stmt|;
name|unit
operator|=
name|UNIT
argument_list|(
operator|(
name|bp
operator|->
name|b_dev
operator|)
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
index|[
name|unit
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"\nststrategy "
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_debug
operator|&
name|SHOWREQUESTS
condition|)
name|printf
argument_list|(
literal|"st%d: %d bytes @ blk%d\n"
argument_list|,
name|unit
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
comment|/*******************************************************\ 	* If it's a null transfer, return immediatly		* 	\*******************************************************/
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|==
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
block|}
comment|/*******************************************************\ 	* If we're at beginning of medium, now is the time to	* 	* set medium access density, fixed or variable-blocks	* 	* and, if fixed, the block size.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_BOM
operator|&&
operator|(
name|bp
operator|->
name|b_error
operator|=
name|st_decide_mode
argument_list|(
name|unit
argument_list|,
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|!=
literal|0
argument_list|)
operator|)
condition|)
goto|goto
name|bad
goto|;
comment|/*******************************************************\ 	* Odd sized request on fixed drives are verboten	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|%
name|st
operator|->
name|blksiz
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: bad request, must be multiple of %d\n"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|blksiz
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
comment|/*******************************************************\ 	* as are out-of-range requests on variable drives.	* 	\*******************************************************/
elseif|else
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|<
name|st
operator|->
name|blkmin
operator|||
name|bp
operator|->
name|b_bcount
operator|>
name|st
operator|->
name|blkmax
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: bad request, must be between %d and %d\n"
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|blkmin
argument_list|,
name|st
operator|->
name|blkmax
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|stminphys
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|opri
operator|=
name|splbio
argument_list|()
expr_stmt|;
comment|/*******************************************************\ 	* Place it in the queue of activities for this tape	* 	* at the end (a bit silly because we only have on user..* 	* (but it could fork() ))				* 	\*******************************************************/
name|dp
operator|=
operator|&
operator|(
name|st
operator|->
name|buf_queue
operator|)
expr_stmt|;
while|while
condition|(
operator|*
name|dp
condition|)
block|{
name|dp
operator|=
operator|&
operator|(
operator|(
operator|*
name|dp
operator|)
operator|->
name|b_actf
operator|)
expr_stmt|;
block|}
operator|*
name|dp
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_actf
operator|=
name|NULL
operator|,
comment|/*******************************************************\ 	* Tell the device to get going on the transfer if it's	* 	* not doing anything, otherwise just wait for completion* 	* (All a bit silly if we're only allowing 1 open but..) * 	\*******************************************************/
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/*******************************************************\ 	* Correctly set the buf to indicate a completed xfer	* 	\*******************************************************/
name|iodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Perform special action on behalf of the user		* * Knows about the internals of this device		* \*******************************************************/
end_comment

begin_macro
name|stioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|arg
argument_list|,
argument|mode
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cmd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|i
operator|,
name|j
expr_stmt|;
name|unsigned
name|int
name|opri
decl_stmt|;
name|int
name|errcode
init|=
literal|0
decl_stmt|;
name|unsigned
name|char
name|unit
decl_stmt|;
name|int
name|number
decl_stmt|,
name|flags
decl_stmt|,
name|dsty
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
decl_stmt|;
comment|/*******************************************************\ 	* Find the device that the user is talking about	* 	\*******************************************************/
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* give error messages, act on errors etc. */
name|unit
operator|=
name|UNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dsty
operator|=
name|DSTY
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|st
operator|=
name|st_data
index|[
name|unit
index|]
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MTIOCGET
case|:
block|{
name|struct
name|mtget
modifier|*
name|g
init|=
operator|(
expr|struct
name|mtget
operator|*
operator|)
name|arg
decl_stmt|;
name|bzero
argument_list|(
name|g
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mtget
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|mt_type
operator|=
literal|0x7
expr_stmt|;
comment|/* Ultrix compat */
comment|/*?*/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|g
operator|->
name|mt_bsiz
operator|=
name|st
operator|->
name|blksiz
expr_stmt|;
block|}
else|else
block|{
name|g
operator|->
name|mt_bsiz
operator|=
literal|0
expr_stmt|;
block|}
name|g
operator|->
name|mt_dns_dflt
operator|=
name|st
operator|->
name|modes
index|[
literal|0
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_dns_dsty1
operator|=
name|st
operator|->
name|modes
index|[
name|DSTY1
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_dns_dsty2
operator|=
name|st
operator|->
name|modes
index|[
name|DSTY2
index|]
operator|.
name|density
expr_stmt|;
name|g
operator|->
name|mt_dns_dsty3
operator|=
name|st
operator|->
name|modes
index|[
name|DSTY3
index|]
operator|.
name|density
expr_stmt|;
break|break;
block|}
case|case
name|MTIOCTOP
case|:
block|{
name|struct
name|mtop
modifier|*
name|mt
init|=
operator|(
expr|struct
name|mtop
operator|*
operator|)
name|arg
decl_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
name|printf
argument_list|(
literal|"[sctape_sstatus: %x %x]\n"
argument_list|,
name|mt
operator|->
name|mt_op
argument_list|,
name|mt
operator|->
name|mt_count
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
comment|/* compat: in U*x it is a short */
name|number
operator|=
name|mt
operator|->
name|mt_count
expr_stmt|;
switch|switch
condition|(
call|(
name|short
call|)
argument_list|(
name|mt
operator|->
name|mt_op
argument_list|)
condition|)
block|{
case|case
name|MTWEOF
case|:
comment|/* write an end-of-file record */
name|errcode
operator|=
name|st_write_filemarks
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTFSF
case|:
comment|/* forward space file */
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSF
case|:
comment|/* backward space file */
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
name|number
argument_list|,
name|SP_FILEMARKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTFSR
case|:
comment|/* forward space record */
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTBSR
case|:
comment|/* backward space record */
name|errcode
operator|=
name|st_space
argument_list|(
name|unit
argument_list|,
operator|-
name|number
argument_list|,
name|SP_BLKS
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTREW
case|:
comment|/* rewind */
name|errcode
operator|=
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|MTOFFL
case|:
comment|/* rewind and put the drive offline */
if|if
condition|(
name|st_rewind
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: rewind failed, unit still loaded\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|st_prevent
argument_list|(
name|unit
argument_list|,
name|PR_ALLOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|st_load
argument_list|(
name|unit
argument_list|,
name|LD_UNLOAD
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|MTNOP
case|:
comment|/* no operation, sets status only */
case|case
name|MTCACHE
case|:
comment|/* enable controller cache */
case|case
name|MTNOCACHE
case|:
comment|/* disable controller cache */
break|break;
case|case
name|MTSETBSIZ
case|:
comment|/* Set block size for device */
if|if
condition|(
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_BOM
operator|)
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|number
operator|==
literal|0
condition|)
block|{
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|st
operator|->
name|blkmin
operator|||
name|st
operator|->
name|blkmax
operator|)
comment|/* they exist */
operator|&&
operator|(
operator|(
name|number
operator|<
name|st
operator|->
name|blkmin
operator|||
name|number
operator|>
name|st
operator|->
name|blkmax
operator|)
operator|)
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|st
operator|->
name|flags
operator||=
name|ST_FIXEDBLOCKS
expr_stmt|;
block|}
name|st
operator|->
name|blksiz
operator|=
name|number
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_BLOCK_SET
expr_stmt|;
break|break;
comment|/* How do we check that the drive can handle 			   the requested density ? */
case|case
name|MTSETDNSTY
case|:
comment|/* Set density for device and mode */
if|if
condition|(
name|number
operator|<
literal|0
operator|||
name|number
operator|>
name|SCSI_2_MAX_DENSITY_CODE
condition|)
block|{
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
else|else
block|{
name|st
operator|->
name|modes
index|[
name|dsty
index|]
operator|.
name|density
operator|=
name|number
expr_stmt|;
block|}
break|break;
default|default:
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
break|break;
block|}
case|case
name|MTIOCIEOT
case|:
case|case
name|MTIOCEEOT
case|:
break|break;
default|default:
name|errcode
operator|=
name|EINVAL
expr_stmt|;
block|}
return|return
name|errcode
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Do a synchronous read.				* \*******************************************************/
end_comment

begin_function
name|int
name|st_read
parameter_list|(
name|unit
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|size
decl_stmt|,
name|flags
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|error
decl_stmt|;
name|struct
name|scsi_rw_tape
name|scsi_cmd
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
comment|/*******************************************************\ 	* If it's a null transfer, return immediatly		* 	\*******************************************************/
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|ESUCCESS
operator|)
return|;
block|}
comment|/*******************************************************\ 	* If we're at beginning of medium, now is the time to	* 	* set medium access density, fixed or variable-blocks	* 	* and, if fixed, the block size.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_BOM
operator|&&
operator|(
name|error
operator|=
name|st_decide_mode
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_COMMAND_TAPE
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator||=
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|?
name|SRWT_FIXED
else|:
literal|0
expr_stmt|;
name|lto3b
argument_list|(
name|scsi_cmd
operator|.
name|byte2
operator|&
name|SRWT_FIXED
condition|?
name|size
operator|/
operator|(
name|st
operator|->
name|blksiz
condition|?
name|st
operator|->
name|blksiz
else|:
name|DEF_FIXED_BSIZE
operator|)
else|:
name|size
argument_list|,
name|scsi_cmd
operator|.
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
name|buf
argument_list|,
name|size
argument_list|,
literal|100000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************************************\ * Get scsi driver to send a "are you ready" command	* \*******************************************************/
end_comment

begin_macro
name|st_test_ready
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_test_unit_ready
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|TEST_UNIT_READY
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a##_1)<< 8) + (unsigned)a##_0 )
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|b2tol
parameter_list|(
name|a
parameter_list|)
value|(((unsigned)(a
comment|/**/
value|_1)<< 8) + (unsigned)a
comment|/**/
value|_0 )
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************************************\ * Ask the drive what it's min and max blk sizes are.	* \*******************************************************/
end_comment

begin_macro
name|st_rd_blk_lim
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_blk_limits
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_blk_limits_data
name|scsi_blkl
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
name|int
name|errno
decl_stmt|;
comment|/*******************************************************\ 	* First check if we have it all loaded			* 	\*******************************************************/
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
return|return
literal|0
return|;
comment|/*******************************************************\ 	* do a 'Read Block Limits'				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_BLK_LIMITS
expr_stmt|;
comment|/*******************************************************\ 	* do the command,	update the global values	* 	\*******************************************************/
if|if
condition|(
name|errno
operator|=
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|&
name|scsi_blkl
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_blkl
argument_list|)
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
condition|)
block|{
return|return
name|errno
return|;
block|}
name|st
operator|->
name|blkmin
operator|=
name|b2tol
argument_list|(
name|scsi_blkl
operator|.
name|min_length
argument_list|)
expr_stmt|;
name|st
operator|->
name|blkmax
operator|=
name|_3btol
argument_list|(
operator|&
name|scsi_blkl
operator|.
name|max_length_2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
block|{
name|printf
argument_list|(
literal|"(%d<= blksiz<= %d)\n"
argument_list|,
name|st
operator|->
name|blkmin
argument_list|,
name|st
operator|->
name|blkmax
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*STDEBUG*/
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Get the scsi driver to send a full inquiry to the	* * device and use the results to fill out the global 	* * parameter structure.					* *							* * called from:						* * attach						* * open							* * ioctl (to reset original blksize)			* \*******************************************************/
end_comment

begin_macro
name|st_mode_sense
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|scsi_sense_len
decl_stmt|;
name|int
name|errno
decl_stmt|;
name|char
modifier|*
name|scsi_sense_ptr
decl_stmt|;
name|struct
name|scsi_mode_sense
name|scsi_cmd
decl_stmt|;
struct|struct
name|scsi_sense
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
block|}
name|scsi_sense
struct|;
struct|struct
name|scsi_sense_page_0
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|unsigned
name|char
name|sense_data
index|[
name|PAGE_0_SENSE_DATA_SIZE
index|]
decl_stmt|;
comment|/* Tandberg tape drives returns page 00 */
comment|/* with the sense data, whether or not */
comment|/* you want it( ie the don't like you  */
comment|/* saying you want anything less!!!!!  */
comment|/* They also expect page 00 */
comment|/* back when you issue a mode select */
block|}
name|scsi_sense_page_0
struct|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
comment|/*******************************************************\ 	* First check if we have it all loaded			* 	\*******************************************************/
if|if
condition|(
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
return|return
literal|0
return|;
comment|/*******************************************************\ 	* Define what sort of structure we're working with	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|scsi_sense_len
operator|=
sizeof|sizeof
argument_list|(
name|scsi_sense_page_0
argument_list|)
expr_stmt|;
name|scsi_sense_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|scsi_sense_page_0
expr_stmt|;
block|}
else|else
block|{
name|scsi_sense_len
operator|=
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
expr_stmt|;
name|scsi_sense_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|scsi_sense
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Set up a mode sense 					* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
name|scsi_sense_len
expr_stmt|;
comment|/*******************************************************\ 	* do the command, but we don't need the results		* 	* just print them for our interest's sake, if asked,	* 	* or if we need it as a template for the mode select	* 	* store it away.					* 	\*******************************************************/
if|if
condition|(
name|errno
operator|=
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
name|scsi_sense_ptr
argument_list|,
name|scsi_sense_len
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
condition|)
block|{
return|return
name|errno
return|;
block|}
name|st
operator|->
name|numblks
operator|=
name|_3btol
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|nblocks
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|media_blksiz
operator|=
name|_3btol
argument_list|(
operator|&
operator|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|blklen
operator|)
argument_list|)
expr_stmt|;
name|st
operator|->
name|media_density
operator|=
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|density
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|header
operator|.
name|dev_spec
operator|&
name|SMH_DSP_WRITE_PROT
condition|)
name|st
operator|->
name|flags
operator||=
name|ST_READONLY
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: density code 0x%x, %d-byte blocks, write-%s, "
argument_list|,
name|unit
argument_list|,
name|st
operator|->
name|media_density
argument_list|,
name|st
operator|->
name|media_blksiz
argument_list|,
name|st
operator|->
name|flags
operator|&
name|ST_READONLY
condition|?
literal|"protected"
else|:
literal|"enabled"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%sbuffered\n"
argument_list|,
operator|(
operator|(
expr|struct
name|scsi_sense
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|header
operator|.
name|dev_spec
operator|&
name|SMH_DSP_BUFF_MODE
condition|?
literal|""
else|:
literal|"un"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*STDEBUG*/
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|bcopy
argument_list|(
operator|(
operator|(
expr|struct
name|scsi_sense_page_0
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|sense_data
argument_list|,
name|st
operator|->
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|scsi_sense_page_0
operator|*
operator|)
name|scsi_sense_ptr
operator|)
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Send a filled out parameter structure to the drive to	* * set it into the desire modes etc.			* \*******************************************************/
end_comment

begin_macro
name|st_mode_select
argument_list|(
argument|unit
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|dat_len
decl_stmt|;
name|char
modifier|*
name|dat_ptr
decl_stmt|;
name|struct
name|scsi_mode_select
name|scsi_cmd
decl_stmt|;
struct|struct
name|dat
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
block|}
name|dat
struct|;
struct|struct
name|dat_page_0
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|unsigned
name|char
name|sense_data
index|[
name|PAGE_0_SENSE_DATA_SIZE
index|]
decl_stmt|;
block|}
name|dat_page_0
struct|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
comment|/*******************************************************\ 	* Define what sort of structure we're working with	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|dat_len
operator|=
sizeof|sizeof
argument_list|(
name|dat_page_0
argument_list|)
expr_stmt|;
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dat_page_0
expr_stmt|;
block|}
else|else
block|{
name|dat_len
operator|=
sizeof|sizeof
argument_list|(
name|dat
argument_list|)
expr_stmt|;
name|dat_ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|dat
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Set up for a mode select				* 	\*******************************************************/
name|bzero
argument_list|(
name|dat_ptr
argument_list|,
name|dat_len
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|MODE_SELECT
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
name|dat_len
expr_stmt|;
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|header
operator|.
name|blk_desc_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|blk_desc
argument_list|)
expr_stmt|;
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|header
operator|.
name|dev_spec
operator||=
name|SMH_DSP_BUFF_MODE_ON
expr_stmt|;
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|density
operator|=
name|st
operator|->
name|density
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|lto3b
argument_list|(
name|st
operator|->
name|blksiz
argument_list|,
operator|(
operator|(
expr|struct
name|dat
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|blk_desc
operator|.
name|blklen
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_NEEDS_PAGE_0
condition|)
block|{
name|bcopy
argument_list|(
name|st
operator|->
name|sense_data
argument_list|,
operator|(
operator|(
expr|struct
name|dat_page_0
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|sense_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|(
operator|(
expr|struct
name|dat_page_0
operator|*
operator|)
name|dat_ptr
operator|)
operator|->
name|sense_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the Tandberg tapes need the block size to */
comment|/* be set on each mode sense/select. */
block|}
comment|/*******************************************************\ 	* do the command					* 	\*******************************************************/
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
name|dat_ptr
argument_list|,
name|dat_len
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_OUT
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * skip N blocks/filemarks/seq filemarks/eom		* \*******************************************************/
end_comment

begin_macro
name|st_space
argument_list|(
argument|unit
argument_list|,
argument|number
argument_list|,
argument|what
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|number
decl_stmt|,
name|what
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|struct
name|scsi_space
name|scsi_cmd
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
comment|/*******************************************************\ 	* If we're at beginning of medium, now is the time to	* 	* set medium access density, fixed or variable-blocks	* 	* and, if fixed, the block size.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_BOM
operator|&&
operator|(
name|error
operator|=
name|st_decide_mode
argument_list|(
name|unit
argument_list|,
name|TRUE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* if we are at a filemark now, we soon won't be*/
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|SPACE
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|what
operator|&
name|SS_CODE
expr_stmt|;
name|lto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|600000
argument_list|,
comment|/* 10 mins enough? */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * write N filemarks					* \*******************************************************/
end_comment

begin_macro
name|st_write_filemarks
argument_list|(
argument|unit
argument_list|,
argument|number
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|number
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|error
decl_stmt|;
name|struct
name|scsi_write_filemarks
name|scsi_cmd
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
comment|/*******************************************************\ 	* It's hard to write a negative number of file marks.	* 	* Don't try.						* 	\*******************************************************/
if|if
condition|(
name|number
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/*******************************************************\ 	* If we're at beginning of medium, now is the time to	* 	* set medium access density, fixed or variable-blocks	* 	* and, if fixed, the block size.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_BOM
operator|&&
operator|(
name|error
operator|=
name|st_decide_mode
argument_list|(
name|unit
argument_list|,
name|FALSE
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|st
operator|->
name|flags
operator|&=
operator|~
operator|(
name|ST_AT_FILEMARK
operator||
name|ST_WRITTEN
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|WRITE_FILEMARKS
expr_stmt|;
name|lto3b
argument_list|(
name|number
argument_list|,
name|scsi_cmd
operator|.
name|number
argument_list|)
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|100000
argument_list|,
comment|/* 10 secs.. (may need to repos head )*/
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * load/unload (with retension if true)			* \*******************************************************/
end_comment

begin_macro
name|st_load
argument_list|(
argument|unit
argument_list|,
argument|type
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_load
name|scsi_cmd
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_IGNORE_LOADS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|LOAD_UNLOAD
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|LD_LOAD
condition|)
block|{
comment|/*scsi_cmd.how |= LD_RETEN;*/
name|st
operator|->
name|flags
operator||=
name|ST_AT_BOM
expr_stmt|;
block|}
else|else
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|300000
argument_list|,
comment|/* 5 min */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * Prevent or allow the user to remove the tape		* \*******************************************************/
end_comment

begin_macro
name|st_prevent
argument_list|(
argument|unit
argument_list|,
argument|type
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|type
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_prevent
name|scsi_cmd
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|PR_ALLOW
condition|)
name|st_data
index|[
name|unit
index|]
operator|->
name|flags
operator|&=
operator|~
name|ST_INFO_VALID
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|PREVENT_ALLOW
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*******************************************************\ *  Rewind the device					* \*******************************************************/
end_comment

begin_macro
name|st_rewind
argument_list|(
argument|unit
argument_list|,
argument|immed
argument_list|,
argument|flags
argument_list|)
end_macro

begin_decl_stmt
name|int
name|unit
decl_stmt|,
name|immed
decl_stmt|,
name|flags
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|scsi_rewind
name|scsi_cmd
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_AT_BOM
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REWIND
expr_stmt|;
name|scsi_cmd
operator|.
name|byte2
operator|=
name|immed
condition|?
name|SR_IMMED
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|immed
condition|?
literal|5000
else|:
literal|300000
argument_list|,
comment|/* 5 sec or 5 min */
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/***************************************************************\ * ststart looks to see if there is a buf waiting for the device	* * and that the device is not already busy. If both are true,	* * It deques the buf and creates a scsi command to perform the	* * transfer in the buf. The transfer request will call st_done	* * on completion, which will in turn call this routine again	* * so that the next queued transfer is performed.		* * The bufs are queued by the strategy routine (ststrategy)	* *								* * This routine is also called after other non-queued requests	* * have been made of the scsi driver, to ensure that the queue	* * continues to be drained.					* \***************************************************************/
end_comment

begin_comment
comment|/* ststart() is called at splbio */
end_comment

begin_macro
name|ststart
argument_list|(
argument|unit
argument_list|)
end_macro

begin_block
block|{
name|int
name|drivecount
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
specifier|register
name|struct
name|buf
modifier|*
name|dp
decl_stmt|;
name|struct
name|scsi_rw_tape
name|cmd
decl_stmt|;
name|int
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
name|int
name|flags
decl_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"ststart%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
comment|/*******************************************************\ 	* See if there is a buf to do and we are not already	* 	* doing one						* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|scsi_xfer
operator|.
name|flags
operator|&
name|INUSE
condition|)
block|{
return|return;
comment|/* unit already underway */
block|}
name|trynext
label|:
if|if
condition|(
name|st
operator|->
name|xfer_block_wait
condition|)
comment|/* a special awaits, let it proceed first */
block|{
name|wakeup
argument_list|(
operator|&
operator|(
name|st
operator|->
name|xfer_block_wait
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|st
operator|->
name|buf_queue
operator|)
operator|==
name|NULL
condition|)
block|{
return|return;
comment|/* no work to bother with */
block|}
name|st
operator|->
name|buf_queue
operator|=
name|bp
operator|->
name|b_actf
expr_stmt|;
comment|/*******************************************************\ 	* only FIXEDBLOCK devices have pending operations	* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
comment|/*******************************************************\ 		*  If we are at a filemark but have not reported it yet	* 		* then we should report it now				* 		\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trynext
goto|;
block|}
comment|/*******************************************************\ 		*  If we are at EIO (e.g. EOM) but have not reported it	* 		* yet then we should report it now			* 		\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_EIO_PENDING
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_EIO_PENDING
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
goto|goto
name|trynext
goto|;
block|}
block|}
comment|/*******************************************************\ 	*  Fill out the scsi command				* 	\*******************************************************/
name|bzero
argument_list|(
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|==
name|B_WRITE
condition|)
block|{
name|cmd
operator|.
name|op_code
operator|=
name|WRITE_COMMAND_TAPE
expr_stmt|;
name|st
operator|->
name|flags
operator||=
name|ST_WRITTEN
expr_stmt|;
name|flags
operator|=
name|SCSI_DATA_OUT
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|.
name|op_code
operator|=
name|READ_COMMAND_TAPE
expr_stmt|;
name|flags
operator|=
name|SCSI_DATA_IN
expr_stmt|;
block|}
comment|/*******************************************************\ 	* Handle "fixed-block-mode" tape drives by using the    * 	* block count instead of the length.			* 	\*******************************************************/
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|cmd
operator|.
name|byte2
operator||=
name|SRWT_FIXED
expr_stmt|;
name|lto3b
argument_list|(
name|bp
operator|->
name|b_bcount
operator|/
name|st
operator|->
name|blksiz
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lto3b
argument_list|(
name|bp
operator|->
name|b_bcount
argument_list|,
name|cmd
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
comment|/*******************************************************\ 	* go ask the adapter to do all this for us		* 	\*******************************************************/
if|if
condition|(
name|st_scsi_cmd
argument_list|(
name|unit
argument_list|,
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_un
operator|.
name|b_addr
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
literal|100000
argument_list|,
name|bp
argument_list|,
name|flags
operator||
name|SCSI_NOSLEEP
argument_list|)
operator|!=
name|SUCCESSFULLY_QUEUED
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: oops not queued\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|stqueues
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/*******************************************************\ * This routine is called by the scsi interrupt when	* * the transfer is complete. \*******************************************************/
end_comment

begin_function
name|int
name|st_done
parameter_list|(
name|unit
parameter_list|,
name|xs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"st_done%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
operator|)
condition|)
name|panic
argument_list|(
literal|"scsi_xfer not in use!"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*PARANOID*/
if|if
condition|(
operator|(
name|bp
operator|=
name|xs
operator|->
name|bp
operator|)
operator|==
name|NULL
condition|)
block|{
name|wakeup
argument_list|(
name|xs
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|XS_SENSE
case|:
name|retval
operator|=
operator|(
name|st_interpret_sense
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
operator|)
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|xs
operator|->
name|resid
expr_stmt|;
comment|/* already multiplied by blksiz */
if|if
condition|(
name|retval
condition|)
block|{
comment|/***************************************\ 			* We have a real error, the bit should	* 			* be set to indicate this. The return	* 			* value will contain the unix error code* 			* that the error interpretation routine	* 			* thought was suitable, so pass this	* 			* value back in the buf structure.	* 			* Furthermore we return information	* 			* saying that no data was transferred	* 			* All status is now suspect		* 			\***************************************/
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|retval
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
block|}
else|else
block|{
comment|/***********************************************\ 		* The error interpretation code has declared	* 		* that it wasn't a real error, or at least that	* 		* we should be ignoring it if it was.		* 		\***********************************************/
if|if
condition|(
name|xs
operator|->
name|resid
operator|==
literal|0
condition|)
block|{
comment|/***************************************\ 			* we apparently had a corrected error	* 			* or something.				* 			* pretend the error never happenned	* 			\***************************************/
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xs
operator|->
name|resid
operator|!=
name|xs
operator|->
name|datalen
condition|)
block|{
comment|/***************************************\ 			* Here we have the tricky part..	* 			* We successfully read less data than	* 			* we requested. (but not 0)		* 			*------for variable blocksize tapes:----* 			* UNDER 386BSD:				* 			* We should legitimatly have the error	* 			* bit set, with the error value set to 	* 			* zero.. This is to indicate to the	* 			* physio code that while we didn't get	* 			* as much information as was requested,	* 			* we did reach the end of the record	* 			* and so physio should not call us	* 			* again for more data... we have it all	* 			* SO SET THE ERROR BIT!			* 			*					* 			* UNDER NetBSD:				* 			* To indicate the same as above, we	* 			* need only have a non 0 resid that is	* 			* less than the b_bcount, but the	* 			* ERROR BIT MUST BE CLEAR! (sigh) 	* 			*					* 			*-------for fixed blocksize device------* 			* We read some successful records	* 			* before hitting the EOF or EOT. These	* 			* must be passed to the user, before we	* 			* report the EOx.  We will report the	* 			* EOx NEXT time.			* 			\***************************************/
ifdef|#
directive|ifdef
name|NETBSD
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
else|#
directive|else
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/***************************************\ 			* We have come out of the error handler	* 			* with no error code.  We have also not	* 			* transferred any data (would have gone	* 			* to the previous clause).		* 			* This must be an EOF			* 			*  Any caller request to read no	* 			* data would have been short-circuited	* 			* at st_read or ststrategy.		* 			*					* 			* At least all o/s agree that:		* 			* 0 bytes read with no error is EOF	* 			\***************************************/
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator|&=
operator|~
name|B_ERROR
expr_stmt|;
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_AT_FILEMARK
expr_stmt|;
break|break;
block|}
block|}
break|break;
case|case
name|XS_TIMEOUT
case|:
name|printf
argument_list|(
literal|"st%d: timeout\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
case|case
name|XS_BUSY
case|:
comment|/* should retry */
comment|/* how? */
comment|/************************************************/
comment|/* SHOULD put buf back at head of queue         */
comment|/* and decrement retry count in (*xs)           */
comment|/* HOWEVER, this should work as a kludge        */
comment|/************************************************/
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|st
operator|->
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
comment|/* don't wake the job, ok? */
return|return;
block|}
name|printf
argument_list|(
literal|"st%d: device busy\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
block|}
case|case
name|XS_DRIVER_STUFFUP
case|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"st%d: unknown error category from scsi driver\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* no longer in use */
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
comment|/* If there's another waiting.. do it */
block|}
end_function

begin_comment
comment|/*******************************************************\ * ask the scsi driver to perform a command for us.	* * Call it through the switch table, and tell it which	* * sub-unit we want, and what target and lu we wish to	* * talk to. Also tell it where to find the command	* * how long int is.					* * Also tell it where to read/write the data, and how	* * long the data is supposed to be			* \*******************************************************/
end_comment

begin_function
name|int
name|st_scsi_cmd
parameter_list|(
name|unit
parameter_list|,
name|scsi_cmd
parameter_list|,
name|cmdlen
parameter_list|,
name|data_addr
parameter_list|,
name|datalen
parameter_list|,
name|timeout
parameter_list|,
name|bp
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
name|struct
name|scsi_generic
modifier|*
name|scsi_cmd
decl_stmt|;
name|int
name|cmdlen
decl_stmt|;
name|int
name|timeout
decl_stmt|;
name|u_char
modifier|*
name|data_addr
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|int
name|datalen
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|int
name|s
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|scsi_debug
operator|&
name|PRINTROUTINES
condition|)
name|printf
argument_list|(
literal|"\nst_scsi_cmd%d "
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*STDEBUG*/
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|st
operator|->
name|sc_sw
operator|==
name|NULL
condition|)
comment|/* If we have no scsi driver */
block|{
name|printf
argument_list|(
literal|"st%d: not set up\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
endif|#
directive|endif
comment|/*PARANOID*/
name|xs
operator|=
operator|&
operator|(
name|st
operator|->
name|scsi_xfer
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|st
operator|->
name|xfer_block_wait
operator|++
expr_stmt|;
comment|/* there is someone waiting */
while|while
condition|(
name|xs
operator|->
name|flags
operator|&
name|INUSE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|SCSI_NOSLEEP
condition|)
return|return
name|EBUSY
return|;
name|sleep
argument_list|(
operator|&
operator|(
name|st
operator|->
name|xfer_block_wait
operator|)
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|st
operator|->
name|xfer_block_wait
operator|--
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
name|INUSE
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SCSI_NOMASK
operator|)
condition|)
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*******************************************************\ 	* Fill out the scsi_xfer structure			* 	\*******************************************************/
name|xs
operator|->
name|flags
operator||=
name|flags
expr_stmt|;
name|xs
operator|->
name|adapter
operator|=
name|st
operator|->
name|ctlr
expr_stmt|;
name|xs
operator|->
name|targ
operator|=
name|st
operator|->
name|targ
expr_stmt|;
name|xs
operator|->
name|lu
operator|=
name|st
operator|->
name|lu
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
name|bp
condition|?
literal|0
else|:
name|ST_RETRIES
expr_stmt|;
comment|/*can't retry on IO*/
name|xs
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|xs
operator|->
name|cmd
operator|=
name|scsi_cmd
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|xs
operator|->
name|data
operator|=
name|data_addr
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|when_done
operator|=
name|st_done
expr_stmt|;
name|xs
operator|->
name|done_arg
operator|=
name|unit
expr_stmt|;
name|xs
operator|->
name|done_arg2
operator|=
operator|(
name|int
operator|)
name|xs
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
name|retry
label|:
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
comment|/***********************************************\ 	* Ask the adapter to do the command for us	* 	\***********************************************/
name|retval
operator|=
operator|(
operator|*
operator|(
name|st
operator|->
name|sc_sw
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
expr_stmt|;
comment|/***********************************************\ 	* IO operations are handled differently..	* 	* Physio does the sleep, and error handling is	* 	* Done in st_done at interrupt time		* 	\***********************************************/
if|if
condition|(
name|bp
condition|)
return|return
name|retval
return|;
comment|/***********************************************\ 	* Wait for the result if queued, or handle the	* 	* error if it was rejected..			* 	\***********************************************/
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|SUCCESSFULLY_QUEUED
case|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
name|sleep
argument_list|(
name|xs
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/*******************************\ 		* finished.. check for failure	* 		* Fall through......		* 		\*******************************/
case|case
name|HAD_ERROR
case|:
case|case
name|COMPLETE
case|:
switch|switch
condition|(
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_NOERROR
case|:
name|retval
operator|=
name|ESUCCESS
expr_stmt|;
break|break;
case|case
name|XS_SENSE
case|:
name|retval
operator|=
operator|(
name|st_interpret_sense
argument_list|(
name|unit
argument_list|,
name|xs
argument_list|)
operator|)
expr_stmt|;
comment|/* only useful for reads */
comment|/* why did I say that?*/
if|if
condition|(
name|retval
condition|)
block|{
comment|/* error... don't care about filemarks */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_ACTION
expr_stmt|;
block|}
else|else
block|{
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|retval
operator|=
name|ESUCCESS
expr_stmt|;
block|}
break|break;
case|case
name|XS_DRIVER_STUFFUP
case|:
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
case|case
name|XS_BUSY
case|:
comment|/* should sleep 1 sec here */
case|case
name|XS_TIMEOUT
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
name|printf
argument_list|(
literal|"st%d: unknown error category from scsi driver\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|TRY_AGAIN_LATER
case|:
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
comment|/* should delay here */
goto|goto
name|retry
goto|;
block|}
name|retval
operator|=
name|EIO
expr_stmt|;
break|break;
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
block|}
name|xs
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* it's free! */
name|ststart
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/***************************************************************\ * Look at the returned sense and act on the error and detirmine	* * The unix error number to pass back... (0 = report no error)	* \***************************************************************/
end_comment

begin_function
name|int
name|st_interpret_sense
parameter_list|(
name|unit
parameter_list|,
name|xs
parameter_list|)
name|int
name|unit
decl_stmt|;
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|int
name|key
decl_stmt|;
name|int
name|silent
init|=
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
decl_stmt|;
name|struct
name|st_data
modifier|*
name|st
init|=
name|st_data
index|[
name|unit
index|]
decl_stmt|;
name|int
name|info
decl_stmt|;
specifier|static
name|char
modifier|*
name|error_mes
index|[]
init|=
block|{
literal|"soft error (corrected)"
block|,
literal|"not ready"
block|,
literal|"medium error"
block|,
literal|"non-media hardware failure"
block|,
literal|"illegal request"
block|,
literal|"unit attention"
block|,
literal|"tape is write-protected"
block|,
literal|"no data found"
block|,
literal|"vendor unique"
block|,
literal|"copy aborted"
block|,
literal|"command aborted"
block|,
literal|"search returned equal"
block|,
literal|"volume overflow"
block|,
literal|"verify miscompare"
block|,
literal|"unknown error key"
block|}
decl_stmt|;
comment|/***************************************************************\ 	* If errors are ok, report a success				* 	\***************************************************************/
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
condition|)
return|return
operator|(
name|ESUCCESS
operator|)
return|;
comment|/***************************************************************\ 	* Get the sense fields and work out what code			* 	\***************************************************************/
name|sense
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STDEBUG
if|if
condition|(
name|st_debug
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"code%x valid%x\n"
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"seg%x key%x ili%x eom%x fmark%x\n"
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|segment
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|?
literal|1
else|:
literal|0
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info: %x %x %x %x followed by %d extra bytes\n"
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|0
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|1
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|2
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
index|[
literal|3
index|]
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extra: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_len
condition|)
block|{
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|extra_bytes
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*STDEBUG*/
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|info
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|info
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|info
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
comment|/* bad choice if fixed blocks */
block|}
switch|switch
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
condition|)
block|{
comment|/***************************************************************\ 	* If it's code 70, use the extended stuff and interpret the key	* 	\***************************************************************/
case|case
literal|0x70
case|:
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_FIXEDBLOCKS
condition|)
block|{
name|xs
operator|->
name|resid
operator|=
name|info
operator|*
name|st
operator|->
name|blksiz
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_EIO_PENDING
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_AT_FILEMARK
expr_stmt|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
name|st
operator|->
name|flags
operator||=
name|ST_EIO_PENDING
expr_stmt|;
comment|/***************************************\ 				* This quirk code helps the drive read	* 				* the first tape block, regardless of	* 				* format.  That is required for these	* 				* drives to return proper MODE SENSE	* 				* information.				* 				\***************************************/
if|if
condition|(
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_SNS_HLP
operator|)
operator|&&
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
block|{
name|st
operator|->
name|blksiz
operator|-=
literal|512
expr_stmt|;
block|}
block|}
comment|/***********************************************\ 			* If no data was tranfered, do it immediatly	* 			\***********************************************/
if|if
condition|(
name|xs
operator|->
name|resid
operator|>=
name|xs
operator|->
name|datalen
condition|)
block|{
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_EIO_PENDING
condition|)
block|{
return|return
name|EIO
return|;
block|}
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_AT_FILEMARK
condition|)
block|{
return|return
literal|0
return|;
block|}
block|}
block|}
else|else
block|{
name|xs
operator|->
name|resid
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
comment|/* to be sure */
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_EOM
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_FILEMARK
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
if|if
condition|(
name|info
operator|<
literal|0
condition|)
comment|/***************************************\ 				* the record was bigger than the read	* 				\***************************************/
block|{
if|if
condition|(
operator|!
name|silent
condition|)
name|printf
argument_list|(
literal|"st%d: %d-byte record "
literal|"too big\n"
argument_list|,
name|unit
argument_list|,
name|xs
operator|->
name|datalen
operator|-
name|info
argument_list|)
expr_stmt|;
return|return
operator|(
name|EIO
operator|)
return|;
block|}
name|xs
operator|->
name|resid
operator|=
name|info
expr_stmt|;
block|}
block|}
comment|/* there may be some other error. check the rest */
name|key
operator|=
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
if|if
condition|(
operator|!
name|silent
operator|&&
name|key
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: %s"
argument_list|,
name|unit
argument_list|,
name|error_mes
index|[
name|key
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|0x2
case|:
comment|/* NOT READY */
case|case
literal|0x5
case|:
comment|/* ILLEGAL REQUEST */
case|case
literal|0x6
case|:
comment|/* UNIT ATTENTION */
case|case
literal|0x7
case|:
comment|/* DATA PROTECT */
break|break;
case|case
literal|0x8
case|:
comment|/* BLANK CHECK */
name|printf
argument_list|(
literal|", requested size: %d (decimal)"
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|", info = %d (decimal)"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* NO SENSE */
case|case
literal|0x1
case|:
comment|/* RECOVERED ERROR */
if|if
condition|(
name|xs
operator|->
name|resid
operator|==
name|xs
operator|->
name|datalen
condition|)
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
case|case
literal|0xc
case|:
comment|/* EQUAL */
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x2
case|:
comment|/* NOT READY */
return|return
operator|(
name|ENODEV
operator|)
return|;
case|case
literal|0x5
case|:
comment|/* ILLEGAL REQUEST */
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0x6
case|:
comment|/* UNIT ATTENTION */
name|st
operator|->
name|flags
operator|&=
operator|~
name|ST_PER_MEDIA
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|flags
operator|&
name|ST_OPEN
condition|)
comment|/* TEMP!!!! */
return|return
operator|(
name|EIO
operator|)
return|;
else|else
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x7
case|:
comment|/* DATA PROTECT */
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
literal|0xd
case|:
comment|/* VOLUME OVERFLOW */
return|return
operator|(
name|ENOSPC
operator|)
return|;
case|case
literal|0x8
case|:
comment|/* BLANK CHECK */
comment|/***********************************************\ 			* This quirk code helps the drive read the	* 			* first tape block, regardless of format.  That	* 			* is required for these drives to return proper	* 			* MODE SENSE information.			* 			\***********************************************/
if|if
condition|(
operator|(
name|st
operator|->
name|quirks
operator|&
name|ST_Q_SNS_HLP
operator|)
operator|&&
operator|!
operator|(
name|st
operator|->
name|flags
operator|&
name|ST_INFO_VALID
operator|)
condition|)
block|{
name|st
operator|->
name|blksiz
operator|-=
literal|512
expr_stmt|;
block|}
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/***************************************************************\ 	* If it's NOT code 70, just report it.				* 	\***************************************************************/
default|default:
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|printf
argument_list|(
literal|"st%d: error code %d"
argument_list|,
name|unit
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" at block no. %d (decimal)"
argument_list|,
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockhi
operator|<<
literal|16
operator|)
operator|+
operator|(
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockmed
operator|<<
literal|8
operator|)
operator|+
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blocklow
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

end_unit

