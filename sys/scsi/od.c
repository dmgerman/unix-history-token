begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995,1996 Shunsuke Akiyama.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Shunsuke Akiyama.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY Shunsuke Akiyama AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL Shunsuke Akiyama OR CONTRIBUTORS BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  *  *	$Id: od.c,v 1.33 1997/12/02 21:06:59 phk Exp $  */
end_comment

begin_comment
comment|/*  * Compile option defines:  */
end_comment

begin_comment
comment|/*  * If drive returns sense key as 0x02 with vendor specific additional  * sense code (ASC) and additional sense code qualifier (ASCQ), or  * illegal ASC and ASCQ. This cause an error (NOT READY) and retrying.  * To suppress this, uncomment following.  * Or put "options OD_BOGUS_NOT_READY" entry into your kernel  * configuration file.  * #define OD_BOGUS_NOT_READY  */
end_comment

begin_comment
comment|/*  * For an automatic spindown, try this.  Again, preferrably as an  * option in your config file.  * WARNING!  Use at your own risk.  Joerg's ancient SONY SMO drive  * groks it fine, while Shunsuke's Fujitsu chokes on it and times  * out. #define OD_AUTO_TURNOFF  */
end_comment

begin_include
include|#
directive|include
file|"opt_bounce.h"
end_include

begin_include
include|#
directive|include
file|"opt_scsi.h"
end_include

begin_include
include|#
directive|include
file|"opt_od.h"
end_include

begin_define
define|#
directive|define
name|SPLOD
value|splbio
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkbad.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/disklabel.h>
end_include

begin_include
include|#
directive|include
file|<sys/diskslice.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEVFS
end_ifdef

begin_include
include|#
directive|include
file|<sys/devfsext.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*DEVFS*/
end_comment

begin_include
include|#
directive|include
file|<scsi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_driver.h>
end_include

begin_decl_stmt
specifier|static
name|u_int32_t
name|odstrats
decl_stmt|,
name|odqueues
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SECSIZE
value|512
end_define

begin_comment
comment|/* default sector size */
end_comment

begin_define
define|#
directive|define
name|ODOUTSTANDING
value|4
end_define

begin_define
define|#
directive|define
name|OD_RETRIES
value|4
end_define

begin_define
define|#
directive|define
name|PARTITION
parameter_list|(
name|dev
parameter_list|)
value|dkpart(dev)
end_define

begin_define
define|#
directive|define
name|ODUNIT
parameter_list|(
name|dev
parameter_list|)
value|dkunit(dev)
end_define

begin_comment
comment|/* XXX introduce a dkmodunit() macro for this. */
end_comment

begin_define
define|#
directive|define
name|ODSETUNIT
parameter_list|(
name|DEV
parameter_list|,
name|U
parameter_list|)
define|\
value|makedev(major(DEV), dkmakeminor((U), dkslice(DEV), dkpart(DEV)))
end_define

begin_struct
struct|struct
name|scsi_data
block|{
name|u_int32_t
name|flags
decl_stmt|;
define|#
directive|define
name|ODINIT
value|0x04
comment|/* device has been init'd */
struct|struct
name|disk_parms
block|{
name|u_char
name|heads
decl_stmt|;
comment|/* Number of heads */
name|u_int16_t
name|cyls
decl_stmt|;
comment|/* Number of cylinders (ficticous) */
name|u_int16_t
name|sectors
decl_stmt|;
comment|/* Number of sectors/track */
name|u_int16_t
name|secsiz
decl_stmt|;
comment|/* Number of bytes/sector */
name|u_int32_t
name|disksize
decl_stmt|;
comment|/* total number sectors */
name|u_int16_t
name|rpm
decl_stmt|;
comment|/* medium rotation rate */
block|}
name|params
struct|;
name|struct
name|diskslices
modifier|*
name|dk_slices
decl_stmt|;
comment|/* virtual drives */
name|struct
name|buf_queue_head
name|buf_queue
decl_stmt|;
name|int
name|dkunit
decl_stmt|;
comment|/* disk stats unit number */
ifdef|#
directive|ifdef
name|DEVFS
comment|/* Eventually move all these to common disk struct. */
name|void
modifier|*
name|b_devfs_token
decl_stmt|;
name|void
modifier|*
name|c_devfs_token
decl_stmt|;
name|void
modifier|*
name|ctl_devfs_token
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|errval
name|od_get_parms
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_decl_stmt
specifier|static
name|errval
name|od_reassign_blocks
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|block
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|u_int32_t
name|od_size
name|__P
argument_list|(
operator|(
name|int
name|unit
operator|,
name|int
name|flags
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|od_sense_handler
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_xfer
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|odstart
name|__P
argument_list|(
operator|(
name|u_int32_t
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|odstrategy1
name|__P
argument_list|(
operator|(
expr|struct
name|buf
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|dev_t
name|odsetunit
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|unit
parameter_list|)
block|{
return|return
name|ODSETUNIT
argument_list|(
name|dev
argument_list|,
name|unit
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|odunit
parameter_list|(
name|dev_t
name|dev
parameter_list|)
block|{
return|return
name|ODUNIT
argument_list|(
name|dev
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|errval
name|od_open
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|mode
operator|,
name|int
name|fmt
operator|,
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|scsi_link
operator|*
name|sc_link
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|errval
name|od_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|errval
name|od_close
name|__P
argument_list|(
operator|(
name|dev_t
name|dev
operator|,
name|int
name|fflag
operator|,
name|int
name|fmt
operator|,
expr|struct
name|proc
operator|*
name|p
operator|,
expr|struct
name|scsi_link
operator|*
name|sc_link
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|od_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|d_open_t
name|odopen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_close_t
name|odclose
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_ioctl_t
name|odioctl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|d_strategy_t
name|odstrategy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CDEV_MAJOR
value|70
end_define

begin_define
define|#
directive|define
name|BDEV_MAJOR
value|20
end_define

begin_decl_stmt
specifier|static
name|struct
name|cdevsw
name|od_cdevsw
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|bdevsw
name|od_bdevsw
init|=
block|{
name|odopen
block|,
name|odclose
block|,
name|odstrategy
block|,
name|odioctl
block|,
comment|/*20*/
name|nodump
block|,
name|nopsize
block|,
name|D_DISK
block|,
literal|"od"
block|,
operator|&
name|od_cdevsw
block|,
operator|-
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Actually include the interface routines  */
end_comment

begin_macro
name|SCSI_DEVICE_ENTRIES
argument_list|(
argument|od
argument_list|)
end_macro

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|od_switch
init|=
block|{
name|od_sense_handler
block|,
name|odstart
block|,
comment|/* have a queue, served by this */
name|NULL
block|,
comment|/* have no async handler */
name|NULL
block|,
comment|/* Use default 'done' routine */
literal|"od"
block|,
literal|0
block|,
block|{
literal|0
block|,
literal|0
block|}
block|,
literal|0
block|,
comment|/* Link flags */
name|odattach
block|,
literal|"Optical"
block|,
name|odopen
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_data
argument_list|)
block|,
name|T_OPTICAL
block|,
name|odunit
block|,
name|odsetunit
block|,
name|od_open
block|,
name|od_ioctl
block|,
name|od_close
block|,
name|od_strategy
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|od_registerdev
parameter_list|(
name|int
name|unit
parameter_list|)
block|{
if|if
condition|(
name|dk_ndrive
operator|<
name|DK_NDRIVE
condition|)
block|{
name|sprintf
argument_list|(
name|dk_names
index|[
name|dk_ndrive
index|]
argument_list|,
literal|"od%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|dk_wpms
index|[
name|dk_ndrive
index|]
operator|=
operator|(
literal|4
operator|*
literal|1024
operator|*
literal|1024
operator|/
literal|2
operator|)
expr_stmt|;
comment|/* 4MB/sec */
name|SCSI_DATA
argument_list|(
operator|&
name|od_switch
argument_list|,
name|unit
argument_list|)
operator|->
name|dkunit
operator|=
name|dk_ndrive
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SCSI_DATA
argument_list|(
operator|&
name|od_switch
argument_list|,
name|unit
argument_list|)
operator|->
name|dkunit
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The routine called by the low level scsi routine when it discovers  * a device suitable for this driver.  */
end_comment

begin_function
specifier|static
name|errval
name|odattach
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|disk_parms
modifier|*
name|dp
decl_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|int
name|mynor
decl_stmt|;
endif|#
directive|endif
name|struct
name|scsi_data
modifier|*
name|od
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|unit
operator|=
name|sc_link
operator|->
name|dev_unit
expr_stmt|;
name|dp
operator|=
operator|&
operator|(
name|od
operator|->
name|params
operator|)
expr_stmt|;
if|if
condition|(
name|sc_link
operator|->
name|opennings
operator|>
name|ODOUTSTANDING
condition|)
name|sc_link
operator|->
name|opennings
operator|=
name|ODOUTSTANDING
expr_stmt|;
name|bufq_init
argument_list|(
operator|&
name|od
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
comment|/* 	 * Use the subdriver to request information regarding 	 * the drive. We cannot use interrupts yet, so the 	 * request must specify this. 	 */
name|scsi_start_unit
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|od_get_parms
argument_list|(
name|unit
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
comment|/* 	 * if we don't have actual parameters, assume 512 bytes/sec 	 * (could happen on removable media - MOD) 	 * -- this avoids the division below from falling over 	 */
if|if
condition|(
name|dp
operator|->
name|secsiz
operator|==
literal|0
condition|)
name|dp
operator|->
name|secsiz
operator|=
name|SECSIZE
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|disksize
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%ldMB (%ld %d byte sectors)"
argument_list|,
name|dp
operator|->
name|disksize
operator|/
operator|(
operator|(
literal|1024L
operator|*
literal|1024L
operator|)
operator|/
name|dp
operator|->
name|secsiz
operator|)
argument_list|,
name|dp
operator|->
name|disksize
argument_list|,
name|dp
operator|->
name|secsiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"od not present"
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|SCSI_REPORT_GEOMETRY
if|if
condition|(
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_BOOTVERBOSE
operator|)
condition|)
endif|#
directive|endif
block|{
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"with approximate %d cyls, %d heads, and %d sectors/track"
argument_list|,
name|dp
operator|->
name|cyls
argument_list|,
name|dp
operator|->
name|heads
argument_list|,
name|dp
operator|->
name|sectors
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|OD_AUTO_TURNOFF
name|scsi_stop_unit
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OD_AUTO_TURNOFF */
name|od
operator|->
name|flags
operator||=
name|ODINIT
expr_stmt|;
name|od_registerdev
argument_list|(
name|unit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEVFS
name|mynor
operator|=
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
name|WHOLE_DISK_SLICE
argument_list|,
name|RAW_PART
argument_list|)
expr_stmt|;
name|od
operator|->
name|b_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|od_bdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_BLK
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"od%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|od
operator|->
name|c_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|od_cdevsw
argument_list|,
name|mynor
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_OPERATOR
argument_list|,
literal|0640
argument_list|,
literal|"rod%d"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|mynor
operator|=
name|dkmakeminor
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|od
operator|->
name|ctl_devfs_token
operator|=
name|devfs_add_devswf
argument_list|(
operator|&
name|od_cdevsw
argument_list|,
name|mynor
operator||
name|SCSI_CONTROL_MASK
argument_list|,
name|DV_CHR
argument_list|,
name|UID_ROOT
argument_list|,
name|GID_WHEEL
argument_list|,
literal|0600
argument_list|,
literal|"rod%d.ctl"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * open the device. Make sure the partition info is a up-to-date as can be.  */
end_comment

begin_function
specifier|static
name|errval
name|od_open
parameter_list|(
name|dev
parameter_list|,
name|mode
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|,
name|sc_link
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|errval
name|errcode
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|disklabel
name|label
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|od
decl_stmt|;
name|unit
operator|=
name|ODUNIT
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|od
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* 	 * Make sure the disk has been initialized 	 * At some point in the future, get the scsi driver 	 * to look for a new device if we are not initted 	 */
if|if
condition|(
operator|(
operator|!
name|od
operator|)
operator|||
operator|(
operator|!
operator|(
name|od
operator|->
name|flags
operator|&
name|ODINIT
operator|)
operator|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"od_open: dev=0x%lx (unit %ld, partition %d)\n"
operator|,
name|dev
operator|,
name|unit
operator|,
name|PARTITION
argument_list|(
name|dev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Try to start the drive, and try to clear "Unit Attention" 	 * condition, when media had been changed before. 	 * This operation also clears the SDEV_MEDIA_LOADED flag in its 	 * error handling routine. 	 */
name|scsi_start_unit
argument_list|(
name|sc_link
argument_list|,
name|SCSI_SILENT
argument_list|)
expr_stmt|;
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_PREVENT
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the drive is ready. 	 */
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"'start' attempted "
operator|)
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_OPEN
expr_stmt|;
comment|/* unit attn becomes an err now */
comment|/* 	 * If it's been invalidated, then forget the label. 	 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
block|{
comment|/* 		 * If somebody still has it open, then forbid re-entry. 		 */
if|if
condition|(
name|dsisopen
argument_list|(
name|od
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|od
operator|->
name|dk_slices
operator|!=
name|NULL
condition|)
name|dsgone
argument_list|(
operator|&
name|od
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * This time actually take notice of error returns 	 */
if|if
condition|(
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_SILENT
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"not ready\n"
operator|)
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"device present\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Load the physical device parameters 	 */
name|errcode
operator|=
name|od_get_parms
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* sets SDEV_MEDIA_LOADED */
if|if
condition|(
name|errcode
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
switch|switch
condition|(
name|od
operator|->
name|params
operator|.
name|secsiz
condition|)
block|{
case|case
name|SECSIZE
case|:
case|case
literal|1024
case|:
case|case
literal|2048
case|:
break|break;
default|default :
name|printf
argument_list|(
literal|"od%ld: Can't deal with %d bytes logical blocks\n"
argument_list|,
name|unit
argument_list|,
name|od
operator|->
name|params
operator|.
name|secsiz
argument_list|)
expr_stmt|;
name|Debugger
argument_list|(
literal|"od"
argument_list|)
expr_stmt|;
name|errcode
operator|=
name|ENXIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"params loaded "
operator|)
argument_list|)
expr_stmt|;
comment|/* Build label for whole disk. */
name|bzero
argument_list|(
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
name|label
operator|.
name|d_secsize
operator|=
name|od
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
name|label
operator|.
name|d_nsectors
operator|=
name|od
operator|->
name|params
operator|.
name|sectors
expr_stmt|;
name|label
operator|.
name|d_ntracks
operator|=
name|od
operator|->
name|params
operator|.
name|heads
expr_stmt|;
name|label
operator|.
name|d_ncylinders
operator|=
name|od
operator|->
name|params
operator|.
name|cyls
expr_stmt|;
name|label
operator|.
name|d_secpercyl
operator|=
name|od
operator|->
name|params
operator|.
name|heads
operator|*
name|od
operator|->
name|params
operator|.
name|sectors
expr_stmt|;
name|label
operator|.
name|d_rpm
operator|=
name|od
operator|->
name|params
operator|.
name|rpm
expr_stmt|;
comment|/* maybe wrong */
if|if
condition|(
name|label
operator|.
name|d_secpercyl
operator|==
literal|0
condition|)
name|label
operator|.
name|d_secpercyl
operator|=
literal|64
operator|*
literal|32
expr_stmt|;
comment|/* XXX as long as it's not 0 		 *  - readdisklabel divides by it (?) 		 */
name|label
operator|.
name|d_secperunit
operator|=
name|od
operator|->
name|params
operator|.
name|disksize
expr_stmt|;
comment|/* Initialize slice tables. */
name|errcode
operator|=
name|dsopen
argument_list|(
literal|"od"
argument_list|,
name|dev
argument_list|,
name|fmt
argument_list|,
operator|&
name|od
operator|->
name|dk_slices
argument_list|,
operator|&
name|label
argument_list|,
name|odstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|od_bdevsw
argument_list|,
operator|&
name|od_cdevsw
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"Slice tables initialized "
operator|)
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"open %ld %ld\n"
operator|,
name|odstrats
operator|,
name|odqueues
operator|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|od
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OD_AUTO_TURNOFF
name|scsi_stop_unit
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OD_AUTO_TURNOFF */
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_OPEN
expr_stmt|;
block|}
return|return
name|errcode
return|;
block|}
end_function

begin_comment
comment|/*  * close the device.. only called if we are the LAST occurence of an open  * device.  Convenient now but usually a pain.  */
end_comment

begin_function
specifier|static
name|errval
name|od_close
parameter_list|(
name|dev
parameter_list|,
name|fflag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|,
name|sc_link
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|fflag
decl_stmt|;
name|int
name|fmt
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|struct
name|scsi_data
modifier|*
name|od
decl_stmt|;
name|od
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
name|dsclose
argument_list|(
name|dev
argument_list|,
name|fmt
argument_list|,
name|od
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsisopen
argument_list|(
name|od
operator|->
name|dk_slices
argument_list|)
condition|)
block|{
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_ALLOW
argument_list|,
name|SCSI_SILENT
operator||
name|SCSI_ERR_OK
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|OD_AUTO_TURNOFF
name|scsi_stop_unit
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|,
name|SCSI_ERR_OK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* OD_AUTO_TURNOFF */
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_OPEN
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Actually translate the requested transfer into one the physical driver  * can understand.  The transfer is described by a buf and will include  * only one physical transfer.  */
end_comment

begin_function
specifier|static
name|void
name|od_strategy
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|opri
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|od
decl_stmt|;
name|u_int32_t
name|unit
decl_stmt|;
name|int
name|secsize
decl_stmt|;
name|odstrats
operator|++
expr_stmt|;
name|unit
operator|=
name|ODUNIT
argument_list|(
operator|(
name|bp
operator|->
name|b_dev
operator|)
argument_list|)
expr_stmt|;
name|od
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
comment|/* 	 * If the device has been made invalid, error out 	 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Odd number of bytes or negative offset 	 */
if|if
condition|(
name|bp
operator|->
name|b_blkno
operator|<
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"od_strategy: Negative block number: 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|secsize
operator|=
name|od
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
comment|/* make sure the blkno is scalable */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_blkno
operator|%
operator|(
name|secsize
operator|/
name|DEV_BSIZE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"od_strategy: Block number is not multiple of sector size (2): 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* make sure that the transfer size is a multiple of the sector size */
if|if
condition|(
operator|(
name|bp
operator|->
name|b_bcount
operator|%
name|secsize
operator|)
operator|!=
literal|0
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|EINVAL
expr_stmt|;
name|printf
argument_list|(
literal|"od_strategy: Invalid b_bcount %d at block number: 0x%x\n"
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Do bounds checking, adjust transfer, and set b_pblkno. 	 */
block|{
name|int
name|status
decl_stmt|;
name|int
name|sec_blk_ratio
init|=
name|secsize
operator|/
name|DEV_BSIZE
decl_stmt|;
comment|/* save original block number and size */
name|int
name|b_blkno
init|=
name|bp
operator|->
name|b_blkno
decl_stmt|;
name|int
name|b_bcount
init|=
name|bp
operator|->
name|b_bcount
decl_stmt|;
comment|/* replace with scaled values */
name|bp
operator|->
name|b_blkno
operator|/=
name|sec_blk_ratio
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|/=
name|sec_blk_ratio
expr_stmt|;
comment|/* have dscheck enforce limits and map to physical block number */
name|status
operator|=
name|dscheck
argument_list|(
name|bp
argument_list|,
name|od
operator|->
name|dk_slices
argument_list|)
expr_stmt|;
comment|/* restore original values to prevent bad side effects in block system */
name|bp
operator|->
name|b_blkno
operator|=
name|b_blkno
expr_stmt|;
name|bp
operator|->
name|b_bcount
operator|=
name|b_bcount
expr_stmt|;
comment|/* scale resid */
name|bp
operator|->
name|b_resid
operator|*=
name|sec_blk_ratio
expr_stmt|;
comment|/* see if the mapping failed */
if|if
condition|(
name|status
operator|<=
literal|0
condition|)
block|{
goto|goto
name|done
goto|;
comment|/* XXX check b_resid */
block|}
block|}
name|opri
operator|=
name|SPLOD
argument_list|()
expr_stmt|;
comment|/* 	 * Use a bounce buffer if necessary 	 */
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_BOUNCE
condition|)
name|vm_bounce_alloc
argument_list|(
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Place it in the queue of disk activities for this disk 	 */
name|bufq_insert_tail
argument_list|(
operator|&
name|od
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the device to get going on the transfer if it's 	 * not doing anything, otherwise just wait for completion 	 */
name|odstart
argument_list|(
name|unit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|opri
argument_list|)
expr_stmt|;
return|return
comment|/*0*/
return|;
name|bad
label|:
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|done
label|:
comment|/* 	 * Correctly set the buf to indicate a completed xfer 	 */
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
comment|/*0*/
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|odstrategy1
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * XXX - do something to make odstrategy() but not this block while 	 * we're doing dsinit() and dsioctl(). 	 */
name|odstrategy
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * odstart looks to see if there is a buf waiting for the device  * and that the device is not already busy. If both are true,  * It dequeues the buf and creates a scsi command to perform the  * transfer in the buf. The transfer request will call scsi_done  * on completion, which will in turn call this routine again  * so that the next queued transfer is performed.  * The bufs are queued by the strategy routine (odstrategy)  *  * This routine is also called after other non-queued requests  * have been made of the scsi driver, to ensure that the queue  * continues to be drained.  *  * must be called at the correct (highish) spl level  * odstart() is called at SPLOD  from odstrategy and scsi_done  */
end_comment

begin_function
specifier|static
name|void
name|odstart
parameter_list|(
name|u_int32_t
name|unit
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
block|{
specifier|register
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|od_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
specifier|register
name|struct
name|scsi_data
modifier|*
name|od
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
literal|0
decl_stmt|;
name|struct
name|scsi_rw_big
name|cmd
decl_stmt|;
name|u_int32_t
name|blkno
decl_stmt|,
name|nblk
decl_stmt|;
name|u_int32_t
name|secsize
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"odstart "
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device has room for another command 	 */
while|while
condition|(
name|sc_link
operator|->
name|opennings
condition|)
block|{
comment|/* 		 * there is excess capacity, but a special waits 		 * It'll need the adapter as soon as we clear out of the 		 * way and let it run (user level wait). 		 */
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_WAITING
condition|)
block|{
return|return;
block|}
comment|/* 		 * See if there is a buf with work for us to do.. 		 */
name|bp
operator|=
name|bufq_first
argument_list|(
operator|&
name|od
operator|->
name|buf_queue
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* yes, an assign */
return|return;
block|}
name|bufq_remove
argument_list|(
operator|&
name|od
operator|->
name|buf_queue
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 		 *  If the device has become invalid, abort all the 		 * reads and writes until all files have been closed and 		 * re-openned 		 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * We have a buf, now we know we are going to go through 		 * With this thing.. 		 */
name|secsize
operator|=
name|od
operator|->
name|params
operator|.
name|secsiz
expr_stmt|;
name|blkno
operator|=
name|bp
operator|->
name|b_pblkno
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|&
operator|(
name|secsize
operator|-
literal|1
operator|)
condition|)
block|{
goto|goto
name|bad
goto|;
block|}
name|nblk
operator|=
name|bp
operator|->
name|b_bcount
operator|/
name|secsize
expr_stmt|;
comment|/* 		 *  Fill out the scsi command 		 */
name|cmd
operator|.
name|op_code
operator|=
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|READ_BIG
else|:
name|WRITE_BIG
expr_stmt|;
name|scsi_uto4b
argument_list|(
name|blkno
argument_list|,
operator|&
name|cmd
operator|.
name|addr_3
argument_list|)
expr_stmt|;
name|scsi_uto2b
argument_list|(
name|nblk
argument_list|,
operator|&
name|cmd
operator|.
name|length2
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|byte2
operator|=
name|cmd
operator|.
name|reserved
operator|=
name|cmd
operator|.
name|control
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Call the routine that chats with the adapter. 		 * Note: we cannot sleep as we may be an interrupt 		 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|b_data
argument_list|,
name|bp
operator|->
name|b_bcount
argument_list|,
name|OD_RETRIES
argument_list|,
literal|100000
argument_list|,
name|bp
argument_list|,
name|flags
operator||
operator|(
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
condition|?
name|SCSI_DATA_IN
else|:
name|SCSI_DATA_OUT
operator|)
argument_list|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
name|odqueues
operator|++
expr_stmt|;
if|if
condition|(
name|od
operator|->
name|dkunit
operator|>=
literal|0
condition|)
block|{
name|dk_xfer
index|[
name|od
operator|->
name|dkunit
index|]
operator|++
expr_stmt|;
name|dk_seek
index|[
name|od
operator|->
name|dkunit
index|]
operator|++
expr_stmt|;
comment|/* don't know */
name|dk_wds
index|[
name|od
operator|->
name|dkunit
index|]
operator|+=
name|bp
operator|->
name|b_bcount
operator|>>
literal|6
expr_stmt|;
block|}
block|}
else|else
block|{
name|bad
label|:
name|printf
argument_list|(
literal|"od%ld: oops not queued\n"
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|EIO
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Perform special action on behalf of the user  * Knows about the internals of this device  */
end_comment

begin_function
specifier|static
name|errval
name|od_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|flag
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
comment|/* struct od_cmd_buf *args; */
name|errval
name|error
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|od
decl_stmt|;
comment|/* 	 * Find the device that the user is talking about 	 */
name|od
operator|=
name|sc_link
operator|->
name|sd
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB1
argument_list|,
operator|(
literal|"odioctl (0x%x)"
operator|,
name|cmd
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the device is not valid.. abandon ship 	 */
if|if
condition|(
operator|!
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
operator|)
condition|)
return|return
name|EIO
return|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DIOCSBAD
case|:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
case|case
name|CDIOCEJECT
case|:
name|error
operator|=
name|scsi_stop_unit
argument_list|(
name|sc_link
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_MEDIA_LOADED
expr_stmt|;
break|break;
case|case
name|CDIOCALLOW
case|:
name|error
operator|=
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_ALLOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CDIOCPREVENT
case|:
name|error
operator|=
name|scsi_prevent
argument_list|(
name|sc_link
argument_list|,
name|PR_PREVENT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|dsioctl
argument_list|(
literal|"od"
argument_list|,
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
operator|&
name|od
operator|->
name|dk_slices
argument_list|,
name|odstrategy1
argument_list|,
operator|(
name|ds_setgeom_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOIOCTL
condition|)
block|{
if|if
condition|(
name|PARTITION
argument_list|(
name|dev
argument_list|)
operator|!=
name|RAW_PART
condition|)
block|{
name|error
operator|=
name|ENOTTY
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|scsi_do_ioctl
argument_list|(
name|dev
argument_list|,
name|cmd
argument_list|,
name|addr
argument_list|,
name|flag
argument_list|,
name|p
argument_list|,
name|sc_link
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Find out from the device what it's capacity is  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|od_size
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_read_cap_data
name|rdcap
decl_stmt|;
name|struct
name|scsi_read_capacity
name|rdcap_cmd
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|od_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|od
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|scsi_mode_sense
name|mdsense_cmd
decl_stmt|;
struct|struct
name|scsi_mode_sense_data
block|{
name|struct
name|scsi_mode_header
name|header
decl_stmt|;
name|struct
name|blk_desc
name|blk_desc
decl_stmt|;
name|union
name|disk_pages
name|pages
decl_stmt|;
block|}
name|scsi_sense
struct|;
comment|/* 	 * make up a scsi command and ask the scsi driver to do 	 * it for you. 	 */
name|bzero
argument_list|(
operator|&
name|rdcap_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|rdcap_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|rdcap_cmd
operator|.
name|op_code
operator|=
name|READ_CAPACITY
expr_stmt|;
comment|/* 	 * If the command works, interpret the result as a 4 byte 	 * number of blocks 	 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|rdcap_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|rdcap_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rdcap
argument_list|,
sizeof|sizeof
argument_list|(
name|rdcap
argument_list|)
argument_list|,
name|OD_RETRIES
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
else|else
block|{
name|od
operator|->
name|params
operator|.
name|disksize
operator|=
name|scsi_4btou
argument_list|(
operator|&
name|rdcap
operator|.
name|addr_3
argument_list|)
operator|+
literal|1
expr_stmt|;
name|od
operator|->
name|params
operator|.
name|secsiz
operator|=
name|scsi_4btou
argument_list|(
operator|&
name|rdcap
operator|.
name|length_3
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * do a "mode sense page 4" (rigid disk drive geometry) 	 */
name|bzero
argument_list|(
operator|&
name|mdsense_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|mdsense_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|mdsense_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|mdsense_cmd
operator|.
name|page
operator|=
literal|4
expr_stmt|;
name|mdsense_cmd
operator|.
name|length
operator|=
literal|0x20
expr_stmt|;
comment|/* 	 * If the command worked, use the results to fill out 	 * the parameter structure 	 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|mdsense_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|mdsense_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scsi_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
argument_list|,
name|OD_RETRIES
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_SILENT
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* default to a ficticous geometry */
name|od
operator|->
name|params
operator|.
name|heads
operator|=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"%ld cyls, %d heads, %d rpm\n"
operator|,
name|scsi_3btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|ncyl_2
argument_list|)
operator|,
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|nheads
operator|,
name|scsi_2btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|medium_rot_rate_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|od
operator|->
name|params
operator|.
name|heads
operator|=
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|nheads
expr_stmt|;
if|if
condition|(
name|od
operator|->
name|params
operator|.
name|heads
operator|==
literal|0
condition|)
name|od
operator|->
name|params
operator|.
name|heads
operator|=
literal|64
expr_stmt|;
comment|/* ficticous */
name|od
operator|->
name|params
operator|.
name|rpm
operator|=
name|scsi_2btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|rigid_geometry
operator|.
name|medium_rot_rate_1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * do a "mode sense page 3" (format device) 	 */
name|bzero
argument_list|(
operator|&
name|mdsense_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|mdsense_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|mdsense_cmd
operator|.
name|op_code
operator|=
name|MODE_SENSE
expr_stmt|;
name|mdsense_cmd
operator|.
name|page
operator|=
literal|3
expr_stmt|;
name|mdsense_cmd
operator|.
name|length
operator|=
literal|0x20
expr_stmt|;
comment|/* 	 * If the command worked, use the results to fill out 	 * the parameter structure 	 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|mdsense_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|mdsense_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|scsi_sense
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_sense
argument_list|)
argument_list|,
name|OD_RETRIES
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_SILENT
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* default to a ficticous geometry */
name|od
operator|->
name|params
operator|.
name|sectors
operator|=
literal|32
expr_stmt|;
block|}
else|else
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"%d secs\n"
operator|,
name|scsi_2btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|disk_format
operator|.
name|ph_sec_t_1
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|od
operator|->
name|params
operator|.
name|sectors
operator|=
name|scsi_2btou
argument_list|(
operator|&
name|scsi_sense
operator|.
name|pages
operator|.
name|disk_format
operator|.
name|ph_sec_t_1
argument_list|)
expr_stmt|;
if|if
condition|(
name|od
operator|->
name|params
operator|.
name|sectors
operator|==
literal|0
condition|)
name|od
operator|->
name|params
operator|.
name|sectors
operator|=
literal|32
expr_stmt|;
comment|/* ficticous */
block|}
return|return
name|od
operator|->
name|params
operator|.
name|disksize
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_comment
comment|/*  * Tell the device to map out a defective block  */
end_comment

begin_function
specifier|static
name|errval
name|od_reassign_blocks
parameter_list|(
name|unit
parameter_list|,
name|block
parameter_list|)
name|int
name|unit
decl_stmt|,
name|block
decl_stmt|;
block|{
name|struct
name|scsi_reassign_blocks
name|scsi_cmd
decl_stmt|;
name|struct
name|scsi_reassign_blocks_data
name|rbdata
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|od_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|rbdata
argument_list|,
sizeof|sizeof
argument_list|(
name|rbdata
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|REASSIGN_BLOCKS
expr_stmt|;
name|rbdata
operator|.
name|length_msb
operator|=
literal|0
expr_stmt|;
name|rbdata
operator|.
name|length_lsb
operator|=
sizeof|sizeof
argument_list|(
name|rbdata
operator|.
name|defect_descriptor
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|scsi_uto4b
argument_list|(
name|block
argument_list|,
operator|&
name|rbdata
operator|.
name|defect_descriptor
index|[
literal|0
index|]
operator|.
name|dlbaddr_3
argument_list|)
expr_stmt|;
return|return
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rbdata
argument_list|,
sizeof|sizeof
argument_list|(
name|rbdata
argument_list|)
argument_list|,
name|OD_RETRIES
argument_list|,
literal|20000
argument_list|,
name|NULL
argument_list|,
name|SCSI_DATA_OUT
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get the scsi driver to send a full inquiry to the  * device and use the results to fill out the disk  * parameter structure.  */
end_comment

begin_function
specifier|static
name|errval
name|od_get_parms
parameter_list|(
name|unit
parameter_list|,
name|flags
parameter_list|)
name|int
name|unit
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|SCSI_LINK
argument_list|(
operator|&
name|od_switch
argument_list|,
name|unit
argument_list|)
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|od
init|=
name|sc_link
operator|->
name|sd
decl_stmt|;
name|struct
name|disk_parms
modifier|*
name|disk_parms
init|=
operator|&
name|od
operator|->
name|params
decl_stmt|;
name|u_int32_t
name|sectors
decl_stmt|;
name|errval
name|retval
decl_stmt|;
comment|/* 	 * First check if we have it all loaded 	 */
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_MEDIA_LOADED
condition|)
return|return
literal|0
return|;
comment|/* 	 * Use ficticious geometry, this depends on the size of medium. 	 */
name|sectors
operator|=
name|od_size
argument_list|(
name|unit
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* od_size() sets secsiz, disksize, sectors, and heads */
comment|/* ficticous number of cylinders, so that C*H*S<= total */
if|if
condition|(
name|disk_parms
operator|->
name|sectors
operator|!=
literal|0
operator|&&
name|disk_parms
operator|->
name|heads
operator|!=
literal|0
condition|)
block|{
name|disk_parms
operator|->
name|cyls
operator|=
name|sectors
operator|/
operator|(
name|disk_parms
operator|->
name|sectors
operator|*
name|disk_parms
operator|->
name|heads
operator|)
expr_stmt|;
block|}
else|else
block|{
name|disk_parms
operator|->
name|cyls
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|sectors
operator|!=
literal|0
condition|)
block|{
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_MEDIA_LOADED
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
name|ENXIO
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * sense handler: Called to determine what to do when the  * device returns a CHECK CONDITION.  */
end_comment

begin_function
specifier|static
name|int
name|od_sense_handler
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|struct
name|scsi_sense_data
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_extended
modifier|*
name|ext
decl_stmt|;
name|int
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
name|sense
operator|=
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
name|ext
operator|=
operator|(
expr|struct
name|scsi_sense_extended
operator|*
operator|)
operator|&
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|)
expr_stmt|;
comment|/* I don't know what the heck to do with a deferred error, 	 * so I'll just kick it back to the caller. 	 */
if|if
condition|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
literal|0x71
condition|)
return|return
name|SCSIRET_CONTINUE
return|;
ifdef|#
directive|ifdef
name|OD_BOGUS_NOT_READY
if|if
condition|(
operator|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
literal|0x70
operator|)
operator|&&
operator|(
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
operator|)
operator|==
literal|0x02
operator|)
condition|)
comment|/* No point in retrying Not Ready */
return|return
name|SCSIRET_CONTINUE
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
literal|0x70
operator|)
operator|&&
operator|(
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
operator|)
operator|==
literal|0x04
operator|)
condition|)
comment|/* No point in retrying Hardware Failure */
return|return
name|SCSIRET_CONTINUE
return|;
if|if
condition|(
operator|(
operator|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
operator|)
operator|==
literal|0x70
operator|)
operator|&&
operator|(
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_KEY
operator|)
operator|==
literal|0x05
operator|)
condition|)
comment|/* No point in retrying Illegal Requests */
return|return
name|SCSIRET_CONTINUE
return|;
name|asc
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|5
operator|)
condition|?
name|ext
operator|->
name|add_sense_code
else|:
literal|0
expr_stmt|;
name|ascq
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|6
operator|)
condition|?
name|ext
operator|->
name|add_sense_code_qual
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|asc
operator|==
literal|0x11
operator|||
name|asc
operator|==
literal|0x30
operator|||
name|asc
operator|==
literal|0x31
operator|||
name|asc
operator|==
literal|0x53
operator|||
name|asc
operator|==
literal|0x5a
condition|)
block|{
comment|/* Unrecovered errors */
return|return
name|SCSIRET_CONTINUE
return|;
block|}
if|if
condition|(
name|asc
operator|==
literal|0x21
operator|&&
name|ascq
operator|==
literal|0
condition|)
block|{
comment|/* Logical block address out of range */
return|return
name|SCSIRET_CONTINUE
return|;
block|}
if|if
condition|(
name|asc
operator|==
literal|0x27
operator|&&
name|ascq
operator|==
literal|0
condition|)
block|{
comment|/* Write protected */
return|return
name|SCSIRET_CONTINUE
return|;
block|}
if|if
condition|(
name|asc
operator|==
literal|0x28
operator|&&
name|ascq
operator|==
literal|0
condition|)
block|{
comment|/* Not ready to ready transition */
comment|/* (medium may have changed) */
return|return
name|SCSIRET_CONTINUE
return|;
block|}
if|if
condition|(
name|asc
operator|==
literal|0x3a
operator|&&
name|ascq
operator|==
literal|0
condition|)
block|{
comment|/* Medium not present */
return|return
name|SCSIRET_CONTINUE
return|;
block|}
comment|/* Retry all disk errors. 	 */
name|scsi_sense_print
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|retries
condition|)
name|printf
argument_list|(
literal|", retries:%d\n"
argument_list|,
name|xs
operator|->
name|retries
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|", FAILURE\n"
argument_list|)
expr_stmt|;
return|return
name|SCSIRET_DO_RETRY
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|od_devsw_installed
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
name|od_drvinit
parameter_list|(
name|void
modifier|*
name|unused
parameter_list|)
block|{
if|if
condition|(
operator|!
name|od_devsw_installed
condition|)
block|{
name|bdevsw_add_generic
argument_list|(
name|BDEV_MAJOR
argument_list|,
name|CDEV_MAJOR
argument_list|,
operator|&
name|od_bdevsw
argument_list|)
expr_stmt|;
name|od_devsw_installed
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|SYSINIT
argument_list|(
argument|oddev
argument_list|,
argument|SI_SUB_DRIVERS
argument_list|,
argument|SI_ORDER_MIDDLE+CDEV_MAJOR
argument_list|,
argument|od_drvinit
argument_list|,
argument|NULL
argument_list|)
end_macro

end_unit

