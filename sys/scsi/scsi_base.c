begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written By Julian ELischer  * Copyright julian Elischer 1993.  * Permission is granted to use or redistribute this file in any way as long  * as this notice remains. Julian Elischer does not guarantee that this file  * is totally correct for any given task and users of this file must  * accept responsibility for any damage that occurs from the application of this  * file.  *  * Written by Julian Elischer (julian@dialix.oz.au)  *      $Id: scsi_base.c,v 1.50 1997/09/02 20:06:33 bde Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_bounce.h"
end_include

begin_include
include|#
directive|include
file|"opt_scsi.h"
end_include

begin_define
define|#
directive|define
name|SPLSD
value|splbio
end_define

begin_define
define|#
directive|define
name|ESUCCESS
value|0
end_define

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<vm/pmap.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_disk.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_debug.h>
end_include

begin_function_decl
specifier|static
name|errval
name|sc_err1
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|errval
name|scsi_interpret_sense
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|scsi_xfer
modifier|*
name|get_xs
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_xs
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|,
name|u_int32_t
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_mem
parameter_list|(
name|unsigned
name|char
modifier|*
name|address
parameter_list|,
name|u_int32_t
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|show_scsi_xs
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function_decl
specifier|static
name|int
name|scsi_sense_qualifiers
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|scsi_xfer
modifier|*
name|next_free_xs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Get a scsi transfer structure for the caller. Charge the structure  * to the device that is referenced by the sc_link structure. If the  * sc_link structure has no 'credits' then the device already has the  * maximum number or outstanding operations under way. In this stage,  * wait on the structure so that when one is freed, we are awoken again  * If the SCSI_NOSLEEP flag is set, then do not wait, but rather, return  * a NULL pointer, signifying that no slots were available  * Note in the link structure, that we are waiting on it.  */
end_comment

begin_function
specifier|static
name|struct
name|scsi_xfer
modifier|*
name|get_xs
parameter_list|(
name|sc_link
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
comment|/* who to charge the xs to */
name|u_int32_t
name|flags
decl_stmt|;
comment|/* if this call can sleep */
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"get_xs\n"
operator|)
argument_list|)
expr_stmt|;
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|sc_link
operator|->
name|opennings
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"sleeping\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SCSI_NOSLEEP
condition|)
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|sc_link
operator|->
name|flags
operator||=
name|SDEV_WAITING
expr_stmt|;
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc_link
argument_list|,
name|PRIBIO
argument_list|,
literal|"scsiget"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|sc_link
operator|->
name|active
operator|++
expr_stmt|;
name|sc_link
operator|->
name|opennings
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|xs
operator|=
name|next_free_xs
operator|)
condition|)
block|{
name|next_free_xs
operator|=
name|xs
operator|->
name|next
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"making\n"
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|xs
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
operator|(
operator|(
name|flags
operator|&
name|SCSI_NOSLEEP
operator|)
condition|?
name|M_NOWAIT
else|:
name|M_WAITOK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|==
name|NULL
condition|)
block|{
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cannot allocate scsi xs\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|callout_handle_init
argument_list|(
operator|&
name|xs
operator|->
name|timeout_ch
argument_list|)
expr_stmt|;
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"returning\n"
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|->
name|sc_link
operator|=
name|sc_link
expr_stmt|;
return|return
operator|(
name|xs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a scsi_xfer struct, and a device (referenced through sc_link)  * return the struct to the free pool and credit the device with it  * If another process is waiting for an xs, do a wakeup, let it proceed  */
end_comment

begin_function
specifier|static
name|void
name|free_xs
parameter_list|(
name|xs
parameter_list|,
name|sc_link
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
comment|/* who to credit for returning it */
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|xs
operator|->
name|next
operator|=
name|next_free_xs
expr_stmt|;
name|next_free_xs
operator|=
name|xs
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"free_xs\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* if was 0 and someone waits, wake them up */
name|sc_link
operator|->
name|active
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|sc_link
operator|->
name|opennings
operator|++
operator|)
operator|&&
operator|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_WAITING
operator|)
condition|)
block|{
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_WAITING
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|sc_link
argument_list|)
expr_stmt|;
comment|/* remember, it wakes them ALL up */
block|}
else|else
block|{
if|if
condition|(
name|sc_link
operator|->
name|device
operator|->
name|start
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"calling private start()\n"
operator|)
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|sc_link
operator|->
name|device
operator|->
name|start
operator|)
operator|)
operator|(
name|sc_link
operator|->
name|dev_unit
operator|,
name|flags
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* XXX dufault: Replace "sd_size" with "scsi_read_capacity"  * when bde is done with sd.c  */
end_comment

begin_comment
comment|/*  * Find out from the device what its capacity is.  */
end_comment

begin_function
name|u_int32_t
name|scsi_read_capacity
parameter_list|(
name|sc_link
parameter_list|,
name|blk_size
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|u_int32_t
modifier|*
name|blk_size
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_read_cap_data
name|rdcap
decl_stmt|;
name|struct
name|scsi_read_capacity
name|scsi_cmd
decl_stmt|;
name|u_int32_t
name|size
decl_stmt|;
comment|/* 	 * make up a scsi command and ask the scsi driver to do 	 * it for you. 	 */
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|READ_CAPACITY
expr_stmt|;
comment|/* 	 * If the command works, interpret the result as a 4 byte 	 * number of blocks 	 */
if|if
condition|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|rdcap
argument_list|,
sizeof|sizeof
argument_list|(
name|rdcap
argument_list|)
argument_list|,
literal|4
argument_list|,
literal|5000000
argument_list|,
comment|/* WORMs tend to take a HUGE amount of time */
name|NULL
argument_list|,
name|flags
operator||
name|SCSI_DATA_IN
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"could not get size\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|size
operator|=
name|scsi_4btou
argument_list|(
operator|&
name|rdcap
operator|.
name|addr_3
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|blk_size
condition|)
operator|*
name|blk_size
operator|=
name|scsi_4btou
argument_list|(
operator|&
name|rdcap
operator|.
name|length_3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|errval
name|scsi_reset_target
parameter_list|(
name|sc_link
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2000
argument_list|,
name|NULL
argument_list|,
name|SCSI_RESET
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|errval
name|scsi_target_mode
parameter_list|(
name|sc_link
parameter_list|,
name|on_off
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|int
name|on_off
decl_stmt|;
block|{
name|struct
name|scsi_generic
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|opcode
operator|=
name|SCSI_OP_TARGET
expr_stmt|;
name|scsi_cmd
operator|.
name|bytes
index|[
literal|0
index|]
operator|=
operator|(
name|on_off
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|2000
argument_list|,
name|NULL
argument_list|,
name|SCSI_ESCAPE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get scsi driver to send a "are you ready?" command  */
end_comment

begin_function
name|errval
name|scsi_test_unit_ready
parameter_list|(
name|sc_link
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_test_unit_ready
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|TEST_UNIT_READY
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|100000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCSI_2_DEF
end_ifdef

begin_comment
comment|/*  * Do a scsi operation, asking a device to run as SCSI-II if it can.  */
end_comment

begin_function
name|errval
name|scsi_change_def
parameter_list|(
name|sc_link
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_changedef
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|CHANGE_DEFINITION
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|SC_SCSI_2
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|100000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SCSI_2_DEF */
end_comment

begin_comment
comment|/*  * Do a scsi operation asking a device what it is  * Use the scsi_cmd routine in the switch table.  */
end_comment

begin_function
name|errval
name|scsi_inquire
parameter_list|(
name|sc_link
parameter_list|,
name|inqbuf
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inqbuf
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_inquiry
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|INQUIRY
expr_stmt|;
name|scsi_cmd
operator|.
name|length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|,
literal|2
argument_list|,
literal|100000
argument_list|,
name|NULL
argument_list|,
name|SCSI_DATA_IN
operator||
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prevent or allow the user to remove the media  */
end_comment

begin_function
name|errval
name|scsi_prevent
parameter_list|(
name|sc_link
parameter_list|,
name|type
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|u_int32_t
name|type
decl_stmt|,
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_prevent
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|PREVENT_ALLOW
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|type
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|5000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get scsi driver to send a "start up" command  */
end_comment

begin_function
name|errval
name|scsi_start_unit
parameter_list|(
name|sc_link
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_start_stop
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|START_STOP
expr_stmt|;
name|scsi_cmd
operator|.
name|how
operator|=
name|SSS_START
expr_stmt|;
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get scsi driver to send a "stop" command  */
end_comment

begin_function
name|errval
name|scsi_stop_unit
parameter_list|(
name|sc_link
parameter_list|,
name|eject
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|u_int32_t
name|eject
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_start_stop
name|scsi_cmd
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|)
expr_stmt|;
name|scsi_cmd
operator|.
name|op_code
operator|=
name|START_STOP
expr_stmt|;
if|if
condition|(
name|eject
condition|)
block|{
name|scsi_cmd
operator|.
name|how
operator|=
name|SSS_LOEJ
expr_stmt|;
block|}
return|return
operator|(
name|scsi_scsi_cmd
argument_list|(
name|sc_link
argument_list|,
operator|(
expr|struct
name|scsi_generic
operator|*
operator|)
operator|&
name|scsi_cmd
argument_list|,
sizeof|sizeof
argument_list|(
name|scsi_cmd
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|2
argument_list|,
literal|10000
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine is called by the scsi interrupt when the transfer is complete.  */
end_comment

begin_function
name|void
name|scsi_done
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
init|=
name|xs
operator|->
name|bp
decl_stmt|;
name|errval
name|retval
decl_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"scsi_done\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSIDEBUG
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_DB1
condition|)
block|{
name|show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*SCSIDEBUG */
comment|/*  	 * If it's a user level request, bypass all usual completion processing,  	 * let the user work it out.. We take reponsibility for freeing the  	 * xs when the user returns. (and restarting the device's queue).  	 */
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_USER
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"calling user done()\n"
operator|)
argument_list|)
expr_stmt|;
name|scsi_user_done
argument_list|(
name|xs
argument_list|)
expr_stmt|;
comment|/* to take a copy of the sense etc. */
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"returned from user done()\n "
operator|)
argument_list|)
expr_stmt|;
name|free_xs
argument_list|(
name|xs
argument_list|,
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
argument_list|)
expr_stmt|;
comment|/* restarts queue too */
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"returning to adapter\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If the device has it's own done routine, call it first. 	 * If it returns a legit error value, return that, otherwise 	 * it wants us to continue with normal processing. 	 */
if|if
condition|(
name|sc_link
operator|->
name|device
operator|->
name|done
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"calling private done()\n"
operator|)
argument_list|)
expr_stmt|;
name|retval
operator|=
call|(
modifier|*
name|sc_link
operator|->
name|device
operator|->
name|done
call|)
argument_list|(
name|xs
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
operator|-
literal|1
condition|)
block|{
name|free_xs
argument_list|(
name|xs
argument_list|,
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
argument_list|)
expr_stmt|;
comment|/*XXX */
return|return;
comment|/* it did it all, finish up */
block|}
comment|/* XXX: This isn't used anywhere. Do you have plans for it, 		 * Julian? (dufault@hda.com). 		 * This allows a private 'done' handler to 		 * resubmit the command if it wants to retry, 		 * In this case the xs must NOT be freed. (julian) 		 */
if|if
condition|(
name|retval
operator|==
operator|-
literal|2
condition|)
block|{
return|return;
comment|/* it did it all, finish up */
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"continuing with generic done()\n"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|xs
operator|->
name|bp
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * if it's a normal upper level request, then ask 		 * the upper level code to handle error checking 		 * rather than doing it here at interrupt time 		 */
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
name|xs
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Go and handle errors now. 	 * If it returns SCSIRET_DO_RETRY then we should RETRY 	 */
if|if
condition|(
operator|(
name|retval
operator|=
name|sc_err1
argument_list|(
name|xs
argument_list|)
operator|)
operator|==
name|SCSIRET_DO_RETRY
condition|)
block|{
if|if
condition|(
operator|(
operator|*
operator|(
name|sc_link
operator|->
name|adapter
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
operator|==
name|SUCCESSFULLY_QUEUED
condition|)
block|{
comment|/* don't wake the job, ok? */
return|return;
block|}
name|xs
operator|->
name|flags
operator||=
name|ITSDONE
expr_stmt|;
block|}
name|free_xs
argument_list|(
name|xs
argument_list|,
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
argument_list|)
expr_stmt|;
comment|/* does a start if needed */
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ask the scsi driver to perform a command for us.  * tell it where to read/write the data, and how  * long the data is supposed to be. If we have  a buf  * to associate with the transfer, we need that too.  */
end_comment

begin_function
name|errval
name|scsi_scsi_cmd
parameter_list|(
name|sc_link
parameter_list|,
name|scsi_cmd
parameter_list|,
name|cmdlen
parameter_list|,
name|data_addr
parameter_list|,
name|datalen
parameter_list|,
name|retries
parameter_list|,
name|timeout
parameter_list|,
name|bp
parameter_list|,
name|flags
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|struct
name|scsi_generic
modifier|*
name|scsi_cmd
decl_stmt|;
name|u_int32_t
name|cmdlen
decl_stmt|;
name|u_char
modifier|*
name|data_addr
decl_stmt|;
name|u_int32_t
name|datalen
decl_stmt|;
name|u_int32_t
name|retries
decl_stmt|;
name|u_int32_t
name|timeout
decl_stmt|;
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|errval
name|retval
decl_stmt|;
name|u_int32_t
name|s
decl_stmt|;
comment|/* 	 * Illegal command lengths will wedge host adapter software. 	 * Reject zero length commands and assert all defined commands 	 * are the correct length. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|SCSI_RESET
operator||
name|SCSI_ESCAPE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmdlen
operator|==
literal|0
condition|)
return|return
name|EFAULT
return|;
else|else
block|{
specifier|static
name|u_int8_t
name|sizes
index|[]
init|=
block|{
literal|6
block|,
literal|10
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|u_int8_t
name|size
init|=
name|sizes
index|[
operator|(
operator|(
name|scsi_cmd
operator|->
name|opcode
operator|)
operator|>>
literal|5
operator|)
index|]
decl_stmt|;
if|if
condition|(
name|size
operator|&&
operator|(
name|size
operator|!=
name|cmdlen
operator|)
condition|)
return|return
name|EIO
return|;
block|}
block|}
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"scsi_cmd\n"
operator|)
argument_list|)
expr_stmt|;
name|xs
operator|=
name|get_xs
argument_list|(
name|sc_link
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xs
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * Fill out the scsi_xfer structure.  We don't know whose context 	 * the cmd is in, so copy it. 	 */
name|bcopy
argument_list|(
name|scsi_cmd
argument_list|,
operator|&
operator|(
name|xs
operator|->
name|cmdstore
operator|)
argument_list|,
name|cmdlen
argument_list|)
expr_stmt|;
name|xs
operator|->
name|flags
operator|=
name|INUSE
operator||
name|flags
expr_stmt|;
name|xs
operator|->
name|sc_link
operator|=
name|sc_link
expr_stmt|;
name|xs
operator|->
name|retries
operator|=
name|retries
expr_stmt|;
name|xs
operator|->
name|timeout
operator|=
name|timeout
expr_stmt|;
name|xs
operator|->
name|cmd
operator|=
operator|&
name|xs
operator|->
name|cmdstore
expr_stmt|;
name|xs
operator|->
name|cmdlen
operator|=
name|cmdlen
expr_stmt|;
name|xs
operator|->
name|data
operator|=
name|data_addr
expr_stmt|;
name|xs
operator|->
name|datalen
operator|=
name|datalen
expr_stmt|;
name|xs
operator|->
name|resid
operator|=
literal|0
expr_stmt|;
name|xs
operator|->
name|bp
operator|=
name|bp
expr_stmt|;
comment|/*XXX*/
comment|/*use constant not magic number */
if|if
condition|(
name|datalen
operator|&&
operator|(
operator|(
name|caddr_t
operator|)
name|data_addr
operator|<
operator|(
name|caddr_t
operator|)
name|KERNBASE
operator|)
condition|)
block|{
if|if
condition|(
name|bp
condition|)
block|{
name|printf
argument_list|(
literal|"Data buffered space not in kernel context\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSIDEBUG
name|show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCSIDEBUG */
name|retval
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
name|xs
operator|->
name|data
operator|=
operator|(
name|caddr_t
operator|)
name|vm_bounce_kva_alloc
argument_list|(
name|btoc
argument_list|(
name|datalen
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|xs
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|datalen
argument_list|,
name|M_TEMP
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* I think waiting is ok */
comment|/*XXX */
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|flags
operator|&
operator|(
name|SCSI_DATA_IN
operator||
name|SCSI_DATA_OUT
operator|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"No direction flags, assuming both\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSIDEBUG
name|show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCSIDEBUG */
case|case
name|SCSI_DATA_IN
operator||
name|SCSI_DATA_OUT
case|:
comment|/* weird */
case|case
name|SCSI_DATA_OUT
case|:
name|bcopy
argument_list|(
name|data_addr
argument_list|,
name|xs
operator|->
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCSI_DATA_IN
case|:
name|bzero
argument_list|(
name|xs
operator|->
name|data
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
block|}
block|}
name|retry
label|:
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|PARANOID
if|if
condition|(
name|datalen
operator|&&
operator|(
operator|(
name|caddr_t
operator|)
name|xs
operator|->
name|data
operator|<
operator|(
name|caddr_t
operator|)
name|KERNBASE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"It's still wrong!\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*PARANOID*/
ifdef|#
directive|ifdef
name|SCSIDEBUG
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_DB3
condition|)
name|show_scsi_xs
argument_list|(
name|xs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCSIDEBUG */
comment|/* 	 * Do the transfer. If we are polling we will return: 	 * COMPLETE,  Was poll, and scsi_done has been called 	 * TRY_AGAIN_LATER, Adapter short resources, try again 	 * 	 * if under full steam (interrupts) it will return: 	 * SUCCESSFULLY_QUEUED, will do a wakeup when complete 	 * TRY_AGAIN_LATER, (as for polling) 	 * After the wakeup, we must still check if it succeeded 	 * 	 * If we have a bp however, all the error proccessing 	 * and the buffer code both expect us to return straight 	 * to them, so as soon as the command is queued, return 	 */
name|retval
operator|=
operator|(
operator|*
operator|(
name|sc_link
operator|->
name|adapter
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
expr_stmt|;
switch|switch
condition|(
name|retval
condition|)
block|{
case|case
name|SUCCESSFULLY_QUEUED
case|:
if|if
condition|(
name|bp
condition|)
block|{
return|return
literal|0
return|;
comment|/* will sleep (or not) elsewhere */
block|}
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|ITSDONE
operator|)
condition|)
block|{
name|tsleep
argument_list|(
operator|(
name|caddr_t
operator|)
name|xs
argument_list|,
name|PRIBIO
operator|+
literal|1
argument_list|,
literal|"scsicmd"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* fall through to check success of completed command */
case|case
name|COMPLETE
case|:
comment|/* Polling command completed ok */
comment|/*XXX*/
case|case
name|HAD_ERROR
case|:
comment|/* Polling command completed with error */
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"back in cmd()\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|sc_err1
argument_list|(
name|xs
argument_list|)
operator|)
operator|==
name|SCSIRET_DO_RETRY
condition|)
goto|goto
name|retry
goto|;
break|break;
case|case
name|TRY_AGAIN_LATER
case|:
comment|/* adapter resource shortage */
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"will try again \n"
operator|)
argument_list|)
expr_stmt|;
comment|/* should sleep 1 sec here */
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
default|default:
name|retval
operator|=
name|EIO
expr_stmt|;
block|}
comment|/* 	 * If we had to copy the data out of the user's context, 	 * then do the other half (copy it back or whatever) 	 * and free the memory buffer 	 */
if|if
condition|(
name|datalen
operator|&&
operator|(
name|xs
operator|->
name|data
operator|!=
name|data_addr
operator|)
condition|)
block|{
switch|switch
condition|(
call|(
name|int
call|)
argument_list|(
name|flags
operator|&
operator|(
name|SCSI_DATA_IN
operator||
name|SCSI_DATA_OUT
operator|)
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
case|case
name|SCSI_DATA_IN
operator||
name|SCSI_DATA_OUT
case|:
comment|/* weird */
case|case
name|SCSI_DATA_IN
case|:
name|bcopy
argument_list|(
name|xs
operator|->
name|data
argument_list|,
name|data_addr
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|BOUNCE_BUFFERS
name|vm_bounce_kva_alloc_free
argument_list|(
operator|(
name|vm_offset_t
operator|)
name|xs
operator|->
name|data
argument_list|,
name|btoc
argument_list|(
name|datalen
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|free
argument_list|(
name|xs
operator|->
name|data
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * we have finished with the xfer stuct, free it and 	 * check if anyone else needs to be started up. 	 */
name|bad
label|:
name|s
operator|=
name|splbio
argument_list|()
expr_stmt|;
name|free_xs
argument_list|(
name|xs
argument_list|,
name|sc_link
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* includes the 'start' op */
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|&&
name|retval
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
name|retval
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|errval
name|sc_done
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|,
name|int
name|code
parameter_list|)
block|{
comment|/* 	 * If it has a buf, we might be working with 	 * a request from the buffer cache or some other 	 * piece of code that requires us to process 	 * errors at interrupt time. We have probably 	 * been called by scsi_done() 	 */
name|struct
name|buf
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|SCSIRET_DO_RETRY
condition|)
block|{
if|if
condition|(
name|xs
operator|->
name|retries
operator|--
condition|)
block|{
name|xs
operator|->
name|error
operator|=
name|XS_NOERROR
expr_stmt|;
name|xs
operator|->
name|flags
operator|&=
operator|~
name|ITSDONE
expr_stmt|;
return|return
name|SCSIRET_DO_RETRY
return|;
block|}
name|code
operator|=
name|EIO
expr_stmt|;
comment|/* Too many retries */
block|}
comment|/*  	 * an EOF condition results in a VALID resid..  	 */
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_EOF
condition|)
block|{
name|xs
operator|->
name|resid
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
block|}
name|bp
operator|=
name|xs
operator|->
name|bp
expr_stmt|;
if|if
condition|(
name|code
operator|!=
name|ESUCCESS
condition|)
block|{
if|if
condition|(
name|bp
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
name|bp
operator|->
name|b_error
operator|=
name|code
expr_stmt|;
name|bp
operator|->
name|b_resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"scsi_interpret_sense (bp) returned %d\n"
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"scsi_interpret_sense (no bp) returned %d\n"
operator|,
name|code
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bp
condition|)
block|{
name|bp
operator|->
name|b_error
operator|=
literal|0
expr_stmt|;
comment|/* XXX: We really shouldn't need this SCSI_RESID_VALID flag. 			 * If we initialize it to 0 and only touch it if we have 			 * a value then we can leave out the test. 			 */
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESID_VALID
condition|)
block|{
name|bp
operator|->
name|b_resid
operator|=
name|xs
operator|->
name|resid
expr_stmt|;
name|bp
operator|->
name|b_flags
operator||=
name|B_ERROR
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|->
name|b_resid
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
return|return
name|code
return|;
block|}
end_function

begin_comment
comment|/*  * submit a scsi command, given the command.. used for retries  * and callable from timeout()  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_function
name|errval
name|scsi_submit
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|sc_link
operator|->
name|adapter
operator|->
name|scsi_cmd
operator|)
operator|)
operator|(
name|xs
operator|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Retry a scsi command, given the command,  and a delay.  */
end_comment

begin_function
name|errval
name|scsi_retry
parameter_list|(
name|xs
parameter_list|,
name|delay
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
name|delay
decl_stmt|;
block|{
if|if
condition|(
name|delay
condition|)
block|{
name|timeout
argument_list|(
operator|(
operator|(
name|void
argument_list|()
operator|)
operator|*
operator|)
name|scsi_submit
argument_list|,
name|xs
argument_list|,
name|hz
operator|*
name|delay
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|scsi_submit
argument_list|(
name|xs
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * handle checking for errors..  * called at interrupt time from scsi_done() and  * at user time from scsi_scsi_cmd(), depending on whether  * there was a bp  (basically, if there is a bp, there may be no  * associated process at the time. (it could be an async operation))  * lower level routines shouldn't know about xs->bp.. we are the lowest.  */
end_comment

begin_function
specifier|static
name|errval
name|sc_err1
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|SC_DEBUG
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|,
name|SDEV_DB3
argument_list|,
operator|(
literal|"sc_err1,err = 0x%lx \n"
operator|,
name|xs
operator|->
name|error
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|int
operator|)
name|xs
operator|->
name|error
condition|)
block|{
case|case
name|XS_SENSE
case|:
return|return
name|sc_done
argument_list|(
name|xs
argument_list|,
name|scsi_interpret_sense
argument_list|(
name|xs
argument_list|)
argument_list|)
return|;
case|case
name|XS_NOERROR
case|:
return|return
name|sc_done
argument_list|(
name|xs
argument_list|,
name|ESUCCESS
argument_list|)
return|;
case|case
name|XS_BUSY
case|:
comment|/* should somehow arange for a 1 sec delay here (how?)[jre]  		 * tsleep(&localvar, priority, "foo", hz);  		 * that's how! [unknown]  		 * no, we could be at interrupt context..  use  		 * timeout(scsi_resubmit,xs,hz); [jre] (not implimenteed yet)  		 */
name|DELAY
argument_list|(
literal|1000
argument_list|)
expr_stmt|;
case|case
name|XS_TIMEOUT
case|:
return|return
name|sc_done
argument_list|(
name|xs
argument_list|,
name|SCSIRET_DO_RETRY
argument_list|)
return|;
comment|/* fall through */
case|case
name|XS_SELTIMEOUT
case|:
case|case
name|XS_DRIVER_STUFFUP
case|:
return|return
name|sc_done
argument_list|(
name|xs
argument_list|,
name|EIO
argument_list|)
return|;
default|default:
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unknown error category from scsi driver\n"
argument_list|)
expr_stmt|;
return|return
name|sc_done
argument_list|(
name|xs
argument_list|,
name|EIO
argument_list|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notyet
end_ifdef

begin_function
specifier|static
name|int
name|scsi_sense_qualifiers
parameter_list|(
name|xs
parameter_list|,
name|asc
parameter_list|,
name|ascq
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
name|int
modifier|*
name|asc
decl_stmt|;
name|int
modifier|*
name|ascq
decl_stmt|;
block|{
name|struct
name|scsi_sense_data_new
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_extended
modifier|*
name|ext
decl_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_new
operator|*
operator|)
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
name|ext
operator|=
operator|&
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|)
expr_stmt|;
if|if
condition|(
name|ext
operator|->
name|extra_len
operator|<
literal|5
condition|)
return|return
literal|0
return|;
operator|*
name|asc
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|5
operator|)
condition|?
name|ext
operator|->
name|add_sense_code
else|:
literal|0
expr_stmt|;
operator|*
name|ascq
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|6
operator|)
condition|?
name|ext
operator|->
name|add_sense_code_qual
else|:
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * scsi_sense_print will decode the sense data into human  * readable form.  Sense handlers can use this to generate  * a report.  This NOW DOES send the closing "\n".  */
end_comment

begin_function
name|void
name|scsi_sense_print
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data_new
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_extended
modifier|*
name|ext
decl_stmt|;
name|u_int32_t
name|key
decl_stmt|;
name|u_int32_t
name|info
decl_stmt|;
name|int
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
comment|/* This sense key text now matches what is in the SCSI spec 	 * (Yes, even the capitals) 	 * so that it is easier to look through the spec to find the 	 * appropriate place. 	 */
specifier|static
name|char
modifier|*
name|sense_key_text
index|[]
init|=
block|{
literal|"NO SENSE"
block|,
literal|"RECOVERED ERROR"
block|,
literal|"NOT READY"
block|,
literal|"MEDIUM ERROR"
block|,
literal|"HARDWARE FAILURE"
block|,
literal|"ILLEGAL REQUEST"
block|,
literal|"UNIT ATTENTION"
block|,
literal|"DATA PROTECT"
block|,
literal|"BLANK CHECK"
block|,
literal|"Vendor Specific"
block|,
literal|"COPY ABORTED"
block|,
literal|"ABORTED COMMAND"
block|,
literal|"EQUAL"
block|,
literal|"VOLUME OVERFLOW"
block|,
literal|"MISCOMPARE"
block|,
literal|"RESERVED"
block|}
decl_stmt|;
name|sc_print_start
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_new
operator|*
operator|)
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
name|ext
operator|=
operator|&
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|)
expr_stmt|;
name|key
operator|=
name|ext
operator|->
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
switch|switch
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
condition|)
block|{
case|case
literal|0x71
case|:
comment|/* deferred error */
name|printf
argument_list|(
literal|"Deferred Error: "
argument_list|)
expr_stmt|;
comment|/* DROP THROUGH */
case|case
literal|0x70
case|:
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sense_key_text
index|[
name|key
index|]
argument_list|)
expr_stmt|;
name|info
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
operator|(
name|long
operator|*
operator|)
name|ext
operator|->
name|info
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
switch|switch
condition|(
operator|(
name|int
operator|)
name|key
condition|)
block|{
case|case
literal|0x2
case|:
comment|/* NOT READY */
case|case
literal|0x5
case|:
comment|/* ILLEGAL REQUEST */
case|case
literal|0x6
case|:
comment|/* UNIT ATTENTION */
case|case
literal|0x7
case|:
comment|/* DATA PROTECT */
break|break;
case|case
literal|0x8
case|:
comment|/* BLANK CHECK */
name|printf
argument_list|(
literal|" req sz: %ld (decimal)"
argument_list|,
name|info
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|info
condition|)
block|{
if|if
condition|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|.
name|flags
operator|&
name|SSD_ILI
condition|)
block|{
name|printf
argument_list|(
literal|" ILI (length mismatch): %ld"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" info:%#lx"
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|info
condition|)
name|printf
argument_list|(
literal|" info?:%#lx"
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|ext
operator|->
name|extra_len
operator|>=
literal|4
condition|)
block|{
if|if
condition|(
name|bcmp
argument_list|(
name|ext
operator|->
name|cmd_spec_info
argument_list|,
literal|"\0\0\0\0"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" csi:%x,%x,%x,%x"
argument_list|,
name|ext
operator|->
name|cmd_spec_info
index|[
literal|0
index|]
argument_list|,
name|ext
operator|->
name|cmd_spec_info
index|[
literal|1
index|]
argument_list|,
name|ext
operator|->
name|cmd_spec_info
index|[
literal|2
index|]
argument_list|,
name|ext
operator|->
name|cmd_spec_info
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|asc
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|5
operator|)
condition|?
name|ext
operator|->
name|add_sense_code
else|:
literal|0
expr_stmt|;
name|ascq
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|6
operator|)
condition|?
name|ext
operator|->
name|add_sense_code_qual
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|asc
operator|||
name|ascq
condition|)
block|{
name|char
modifier|*
name|desc
init|=
name|scsi_sense_desc
argument_list|(
name|asc
argument_list|,
name|ascq
argument_list|)
decl_stmt|;
name|printf
argument_list|(
literal|" asc:%x,%x"
argument_list|,
name|asc
argument_list|,
name|ascq
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|desc
argument_list|)
operator|>
literal|40
condition|)
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
empty_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ext
operator|->
name|extra_len
operator|>=
literal|7
operator|&&
name|ext
operator|->
name|fru
condition|)
block|{
name|printf
argument_list|(
literal|" field replaceable unit: %x"
argument_list|,
name|ext
operator|->
name|fru
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ext
operator|->
name|extra_len
operator|>=
literal|10
operator|&&
operator|(
name|ext
operator|->
name|sense_key_spec_1
operator|&
name|SSD_SCS_VALID
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|" sks:%x,%x"
argument_list|,
name|ext
operator|->
name|sense_key_spec_1
argument_list|,
operator|(
name|ext
operator|->
name|sense_key_spec_2
operator||
name|ext
operator|->
name|sense_key_spec_3
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Not code 70, just report it 	 */
default|default:
name|printf
argument_list|(
literal|"error code %d"
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|)
block|{
name|printf
argument_list|(
literal|" at block no. %ld (decimal)"
argument_list|,
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockhi
operator|)
operator|<<
literal|16
operator|)
operator|+
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blockmed
operator|)
operator|<<
literal|8
operator|)
operator|+
operator|(
operator|(
name|unsigned
name|long
operator|)
name|sense
operator|->
name|ext
operator|.
name|unextended
operator|.
name|blocklow
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc_print_finish
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Look at the returned sense and act on the error, determining  * the unix error number to pass back.  (0 = report no error)  *  * THIS IS THE DEFAULT SENSE HANDLER  */
end_comment

begin_function
specifier|static
name|errval
name|scsi_interpret_sense
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|struct
name|scsi_sense_data_new
modifier|*
name|sense
decl_stmt|;
name|struct
name|scsi_sense_extended
modifier|*
name|ext
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|xs
operator|->
name|sc_link
decl_stmt|;
name|u_int32_t
name|key
decl_stmt|;
name|u_int32_t
name|silent
decl_stmt|;
name|errval
name|errcode
decl_stmt|;
name|int
name|error_code
decl_stmt|,
name|asc
decl_stmt|,
name|ascq
decl_stmt|;
comment|/* 	 * If the flags say errs are ok, then always return ok. 	 * XXX: What if it is a deferred error? 	 */
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_ERR_OK
condition|)
return|return
operator|(
name|ESUCCESS
operator|)
return|;
name|sense
operator|=
operator|(
expr|struct
name|scsi_sense_data_new
operator|*
operator|)
operator|&
operator|(
name|xs
operator|->
name|sense
operator|)
expr_stmt|;
name|ext
operator|=
operator|&
operator|(
name|sense
operator|->
name|ext
operator|.
name|extended
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SCSIDEBUG
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_DB1
condition|)
block|{
name|u_int32_t
name|count
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"code%x valid%x "
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
argument_list|,
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE_VALID
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"seg%x key%x ili%x eom%x fmark%x\n"
argument_list|,
name|ext
operator|->
name|segment
argument_list|,
name|ext
operator|->
name|flags
operator|&
name|SSD_KEY
argument_list|,
name|ext
operator|->
name|flags
operator|&
name|SSD_ILI
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ext
operator|->
name|flags
operator|&
name|SSD_EOM
condition|?
literal|1
else|:
literal|0
argument_list|,
name|ext
operator|->
name|flags
operator|&
name|SSD_FILEMARK
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"info: %x %x %x %x followed by %d extra bytes\n"
argument_list|,
name|ext
operator|->
name|info
index|[
literal|0
index|]
argument_list|,
name|ext
operator|->
name|info
index|[
literal|1
index|]
argument_list|,
name|ext
operator|->
name|info
index|[
literal|2
index|]
argument_list|,
name|ext
operator|->
name|info
index|[
literal|3
index|]
argument_list|,
name|ext
operator|->
name|extra_len
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"extra: "
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
operator|<
name|ext
operator|->
name|extra_len
condition|)
block|{
name|printf
argument_list|(
literal|"%x "
argument_list|,
name|ext
operator|->
name|extra_bytes
index|[
name|count
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*SCSIDEBUG */
comment|/* 	 * If the device has it's own sense handler, call it first. 	 * If it returns a legit errno value, return that, otherwise 	 * it should return either DO_RETRY or CONTINUE to either 	 * request a retry or continue with default sense handling. 	 */
if|if
condition|(
name|sc_link
operator|->
name|device
operator|->
name|err_handler
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"calling private err_handler()\n"
operator|)
argument_list|)
expr_stmt|;
name|errcode
operator|=
call|(
modifier|*
name|sc_link
operator|->
name|device
operator|->
name|err_handler
call|)
argument_list|(
name|xs
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"private err_handler() returned %d\n"
operator|,
name|errcode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|>=
literal|0
condition|)
block|{
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"SCSI_EOF = %d\n"
operator|,
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_EOF
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|SC_DEBUG
argument_list|(
name|sc_link
argument_list|,
name|SDEV_DB2
argument_list|,
operator|(
literal|"SCSI_RESID_VALID = %d\n"
operator|,
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESID_VALID
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_EOF
condition|)
block|{
name|xs
operator|->
name|resid
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
block|}
return|return
name|errcode
return|;
comment|/* valid errno value */
block|}
switch|switch
condition|(
name|errcode
condition|)
block|{
case|case
name|SCSIRET_DO_RETRY
case|:
comment|/* Requested a retry */
return|return
name|errcode
return|;
case|case
name|SCSIRET_CONTINUE
case|:
comment|/* Continue with default sense processing */
break|break;
default|default:
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"unknown return code %d from sense handler.\n"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return
name|errcode
return|;
block|}
block|}
comment|/* otherwise use the default */
name|silent
operator|=
name|xs
operator|->
name|flags
operator|&
name|SCSI_SILENT
expr_stmt|;
name|key
operator|=
name|ext
operator|->
name|flags
operator|&
name|SSD_KEY
expr_stmt|;
name|error_code
operator|=
name|sense
operator|->
name|error_code
operator|&
name|SSD_ERRCODE
expr_stmt|;
name|asc
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|5
operator|)
condition|?
name|ext
operator|->
name|add_sense_code
else|:
literal|0
expr_stmt|;
name|ascq
operator|=
operator|(
name|ext
operator|->
name|extra_len
operator|>=
literal|6
operator|)
condition|?
name|ext
operator|->
name|add_sense_code_qual
else|:
literal|0
expr_stmt|;
comment|/* 	 * Retry while the device is returning a ``Logical unit 	 * is in the process of becoming ready.'' (until it either 	 * eventually yields an error, or finally succeeds). 	 */
if|if
condition|(
name|error_code
operator|==
literal|0x70
comment|/* current error */
operator|&&
operator|(
name|int
operator|)
name|key
operator|==
literal|0x2
comment|/* not ready */
operator|&&
name|asc
operator|==
literal|4
operator|&&
name|ascq
operator|==
literal|1
comment|/* logical unit i i t p o b r */
condition|)
return|return
operator|(
name|SCSIRET_DO_RETRY
operator|)
return|;
if|if
condition|(
operator|!
name|silent
condition|)
block|{
name|scsi_sense_print
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|error_code
condition|)
block|{
case|case
literal|0x71
case|:
comment|/* deferred error */
comment|/* Print even if silent (not silent was already done) 		 */
if|if
condition|(
name|silent
condition|)
block|{
name|scsi_sense_print
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: 		 * This error doesn't relate to the command associated 		 * with this request sense.  A deferred error is an error 		 * for a command that has already returned GOOD status (see 7.2.14.2). 		 * 		 * By my reading of that section, it looks like the current command 		 * has been cancelled, we should now clean things up (hopefully 		 * recovering any lost data) and then 		 * retry the current command.  There are two easy choices, both 		 * wrong: 		 * 1. Drop through (like we had been doing), thus treating this as 		 * if the error were for the current command and return and stop 		 * the current command. 		 * 2. Issue a retry (like I made it do) thus hopefully recovering 		 * the current transfer, and ignoring the fact that we've dropped 		 * a command. 		 * 		 * These should probably be handled in a device specific 		 * sense handler or punted back up to a user mode daemon 		 */
return|return
name|SCSIRET_DO_RETRY
return|;
comment|/* 		 * If it's code 70, use the extended stuff and interpret the key 		 */
case|case
literal|0x70
case|:
switch|switch
condition|(
operator|(
name|int
operator|)
name|key
condition|)
block|{
case|case
literal|0x0
case|:
comment|/* NO SENSE */
case|case
literal|0x1
case|:
comment|/* RECOVERED ERROR */
case|case
literal|0xc
case|:
comment|/* EQUAL */
if|if
condition|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_EOF
condition|)
block|{
name|xs
operator|->
name|resid
operator|=
name|xs
operator|->
name|datalen
expr_stmt|;
name|xs
operator|->
name|flags
operator||=
name|SCSI_RESID_VALID
expr_stmt|;
block|}
return|return
operator|(
name|ESUCCESS
operator|)
return|;
case|case
literal|0x2
case|:
comment|/* NOT READY */
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_MEDIA_LOADED
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
case|case
literal|0x5
case|:
comment|/* ILLEGAL REQUEST */
return|return
operator|(
name|EINVAL
operator|)
return|;
case|case
literal|0x6
case|:
comment|/* UNIT ATTENTION */
name|sc_link
operator|->
name|flags
operator|&=
operator|~
name|SDEV_MEDIA_LOADED
expr_stmt|;
if|if
condition|(
name|sc_link
operator|->
name|flags
operator|&
name|SDEV_OPEN
condition|)
block|{
return|return
operator|(
name|EIO
operator|)
return|;
block|}
else|else
block|{
return|return
literal|0
return|;
block|}
case|case
literal|0x7
case|:
comment|/* DATA PROTECT */
return|return
operator|(
name|EACCES
operator|)
return|;
case|case
literal|0xd
case|:
comment|/* VOLUME OVERFLOW */
return|return
operator|(
name|ENOSPC
operator|)
return|;
case|case
literal|0x8
case|:
comment|/* BLANK CHECK */
name|xs
operator|->
name|flags
operator||=
name|SCSI_EOF
expr_stmt|;
comment|/* force EOF on tape read */
return|return
operator|(
name|ESUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
comment|/* 	 * Not code 70, return EIO 	 */
default|default:
return|return
operator|(
name|EIO
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Utility routines often used in SCSI stuff  */
end_comment

begin_comment
comment|/*  * convert a physical address to 3 bytes,  * MSB at the lowest address,  * LSB at the highest.  */
end_comment

begin_function
name|void
name|scsi_uto3b
parameter_list|(
name|val
parameter_list|,
name|bytes
parameter_list|)
name|u_int32_t
name|val
decl_stmt|;
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|bytes
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|scsi_3btou
parameter_list|(
name|bytes
parameter_list|)
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
name|u_int32_t
name|rc
decl_stmt|;
name|rc
operator|=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|16
operator|)
expr_stmt|;
name|rc
operator|+=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|8
operator|)
expr_stmt|;
name|rc
operator|+=
operator|*
name|bytes
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int32_t
name|scsi_3btoi
parameter_list|(
name|bytes
parameter_list|)
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
name|u_int32_t
name|rc
init|=
name|scsi_3btou
argument_list|(
name|bytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|rc
operator|&
literal|0x00800000
condition|)
name|rc
operator||=
literal|0xff000000
expr_stmt|;
return|return
operator|(
name|int32_t
operator|)
name|rc
return|;
block|}
end_function

begin_function
name|void
name|scsi_uto2b
parameter_list|(
name|val
parameter_list|,
name|bytes
parameter_list|)
name|u_int32_t
name|val
decl_stmt|;
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|bytes
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|scsi_2btou
parameter_list|(
name|bytes
parameter_list|)
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
name|u_int32_t
name|rc
decl_stmt|;
name|rc
operator|=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|8
operator|)
expr_stmt|;
name|rc
operator|+=
operator|*
name|bytes
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_function
name|void
name|scsi_uto4b
parameter_list|(
name|val
parameter_list|,
name|bytes
parameter_list|)
name|u_int32_t
name|val
decl_stmt|;
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff000000
operator|)
operator|>>
literal|24
expr_stmt|;
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
expr_stmt|;
operator|*
name|bytes
operator|++
operator|=
operator|(
name|val
operator|&
literal|0xff00
operator|)
operator|>>
literal|8
expr_stmt|;
operator|*
name|bytes
operator|=
name|val
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_function
name|u_int32_t
name|scsi_4btou
parameter_list|(
name|bytes
parameter_list|)
name|u_char
modifier|*
name|bytes
decl_stmt|;
block|{
name|u_int32_t
name|rc
decl_stmt|;
name|rc
operator|=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|24
operator|)
expr_stmt|;
name|rc
operator|+=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|16
operator|)
expr_stmt|;
name|rc
operator|+=
operator|(
operator|*
name|bytes
operator|++
operator|<<
literal|8
operator|)
expr_stmt|;
name|rc
operator|+=
operator|*
name|bytes
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|sc_printing
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|sc_print_init
parameter_list|()
block|{
name|sc_printing
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_print_start
parameter_list|(
name|sc_link
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|sc_printing
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|sc_print_finish
parameter_list|()
block|{
name|sc_printing
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|id_put
parameter_list|(
name|int
name|id
parameter_list|,
name|char
modifier|*
name|after
parameter_list|)
block|{
switch|switch
condition|(
name|id
condition|)
block|{
case|case
name|SCCONF_UNSPEC
case|:
break|break;
case|case
name|SCCONF_ANY
case|:
name|printf
argument_list|(
literal|"?"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"%d"
argument_list|,
name|id
argument_list|)
expr_stmt|;
break|break;
block|}
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|after
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * sc_print_addr: Print out the scsi_link structure's address info.  * This should handle any circumstance, even the transitory ones  * during system configuration.  */
end_comment

begin_function
name|void
name|sc_print_addr
parameter_list|(
name|sc_link
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
block|{
if|if
condition|(
name|sc_printing
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sc_link
operator|->
name|device
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"nodevice at "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
literal|"probe"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
name|sc_link
operator|->
name|dev_unit
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
return|return;
block|}
name|printf
argument_list|(
literal|"scbus"
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
name|sc_link
operator|->
name|scsibus
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"target "
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
name|sc_link
operator|->
name|target
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"lun "
argument_list|)
expr_stmt|;
name|id_put
argument_list|(
name|sc_link
operator|->
name|lun
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SCSIDEBUG
end_ifdef

begin_comment
comment|/*  * Given a scsi_xfer, dump the request, in all it's glory  */
end_comment

begin_function
specifier|static
name|void
name|show_scsi_xs
parameter_list|(
name|xs
parameter_list|)
name|struct
name|scsi_xfer
modifier|*
name|xs
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"xs(%p): "
argument_list|,
name|xs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"flg(0x%lx)"
argument_list|,
name|xs
operator|->
name|flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"sc_link(%p)"
argument_list|,
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"retr(0x%x)"
argument_list|,
name|xs
operator|->
name|retries
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"timo(0x%lx)"
argument_list|,
name|xs
operator|->
name|timeout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"cmd(%p)"
argument_list|,
name|xs
operator|->
name|cmd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"len(0x%lx)"
argument_list|,
name|xs
operator|->
name|cmdlen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"data(%p)"
argument_list|,
name|xs
operator|->
name|data
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"len(0x%lx)"
argument_list|,
name|xs
operator|->
name|datalen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"res(0x%lx)"
argument_list|,
name|xs
operator|->
name|resid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"err(0x%lx)"
argument_list|,
name|xs
operator|->
name|error
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"bp(%p)"
argument_list|,
name|xs
operator|->
name|bp
argument_list|)
expr_stmt|;
name|show_scsi_cmd
argument_list|(
name|xs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|show_scsi_cmd
parameter_list|(
name|struct
name|scsi_xfer
modifier|*
name|xs
parameter_list|)
block|{
name|u_char
modifier|*
name|b
init|=
operator|(
name|u_char
operator|*
operator|)
name|xs
operator|->
name|cmd
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|sc_print_addr
argument_list|(
name|xs
operator|->
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"command: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|xs
operator|->
name|flags
operator|&
name|SCSI_RESET
operator|)
condition|)
block|{
while|while
condition|(
name|i
operator|<
name|xs
operator|->
name|cmdlen
condition|)
block|{
if|if
condition|(
name|i
condition|)
name|printf
argument_list|(
literal|","
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%x"
argument_list|,
name|b
index|[
name|i
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"-[%ld bytes]\n"
argument_list|,
name|xs
operator|->
name|datalen
argument_list|)
expr_stmt|;
if|if
condition|(
name|xs
operator|->
name|datalen
condition|)
name|show_mem
argument_list|(
name|xs
operator|->
name|data
argument_list|,
name|min
argument_list|(
literal|64
argument_list|,
name|xs
operator|->
name|datalen
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"-RESET-\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|show_mem
parameter_list|(
name|address
parameter_list|,
name|num
parameter_list|)
name|unsigned
name|char
modifier|*
name|address
decl_stmt|;
name|u_int32_t
name|num
decl_stmt|;
block|{
name|u_int32_t
name|y
decl_stmt|;
name|printf
argument_list|(
literal|"------------------------------"
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|num
condition|;
name|y
operator|+=
literal|1
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|y
operator|%
literal|16
operator|)
condition|)
name|printf
argument_list|(
literal|"\n%03ld: "
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|*
name|address
operator|++
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n------------------------------\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*SCSIDEBUG */
end_comment

end_unit

