begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Written by Julian Elischer (julian@tfs.com)  * for TRW Financial Systems for use under the MACH(2.5) operating system.  *  * TRW Financial Systems, in accordance with their agreement with Carnegie  * Mellon University, makes this software available to CMU to distribute  * or use in any manner that they see fit as long as this message is kept with  * the software. For this reason TFS also grants any other persons or  * organisations permission to use or modify this software.  *  * TFS supplies this software to be publicly redistributed  * on the understanding that TFS is not responsible for the correct  * functioning of this software in any circumstances.  *  * Ported to run under 386BSD by Julian Elischer (julian@tfs.com) Sept 1992  *  * New configuration setup: dufault@hda.com  *  *      $Id: scsiconf.c,v 1.65 1996/11/06 13:33:50 joerg Exp $  */
end_comment

begin_include
include|#
directive|include
file|"opt_scsi.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PC98
end_ifdef

begin_include
include|#
directive|include
file|<sys/device.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<machine/clock.h>
end_include

begin_include
include|#
directive|include
file|"scbus.h"
end_include

begin_include
include|#
directive|include
file|"sd.h"
end_include

begin_include
include|#
directive|include
file|"st.h"
end_include

begin_include
include|#
directive|include
file|"cd.h"
end_include

begin_include
include|#
directive|include
file|"ch.h"
end_include

begin_include
include|#
directive|include
file|"od.h"
end_include

begin_include
include|#
directive|include
file|"worm.h"
end_include

begin_include
include|#
directive|include
file|"su.h"
end_include

begin_include
include|#
directive|include
file|"sctarg.h"
end_include

begin_include
include|#
directive|include
file|<scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<scsi/scsiconf.h>
end_include

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|extend_new
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|extend_release
name|__P
argument_list|(
operator|(
expr|struct
name|extend_array
operator|*
name|ea
operator|,
name|int
name|index
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|extend_set
name|__P
argument_list|(
operator|(
expr|struct
name|extend_array
operator|*
name|ea
operator|,
name|int
name|index
operator|,
name|void
operator|*
name|value
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX SCSI_DEVICE_ENTRIES() generates extern switches but it should  * generate static switches except for this.  Separate macros are  * probably required for the extern and static parts.  */
end_comment

begin_decl_stmt
specifier|extern
name|struct
name|scsi_device
name|uk_switch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************  * Extensible arrays: Use a realloc like implementation to permit  * the arrays to be extend.  These are set up to be moved out  * of this file if needed elsewhere.  */
end_comment

begin_struct
struct|struct
name|extend_array
block|{
name|int
name|nelem
decl_stmt|;
name|void
modifier|*
modifier|*
name|ps
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|make_readable
name|__P
argument_list|(
operator|(
name|char
operator|*
name|to
operator|,
name|char
operator|*
name|from
operator|,
name|size_t
name|n
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|match
name|__P
argument_list|(
operator|(
name|char
operator|*
name|pattern
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|scsi_bus_conf
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_link
operator|*
name|sc_link_proto
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|extend_alloc
parameter_list|(
name|size_t
name|s
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|malloc
argument_list|(
name|s
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
name|panic
argument_list|(
literal|"extend_alloc: malloc failed."
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extend_free
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|free
argument_list|(
name|p
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* EXTEND_CHUNK: Number of extend slots to allocate whenever we need a new  * one.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EXTEND_CHUNK
end_ifndef

begin_define
define|#
directive|define
name|EXTEND_CHUNK
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|extend_array
modifier|*
name|extend_new
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|extend_array
modifier|*
name|p
init|=
name|extend_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
operator|->
name|nelem
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ps
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|extend_set
parameter_list|(
name|struct
name|extend_array
modifier|*
name|ea
parameter_list|,
name|int
name|index
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|index
operator|>=
name|ea
operator|->
name|nelem
condition|)
block|{
name|void
modifier|*
modifier|*
name|space
decl_stmt|;
name|space
operator|=
name|extend_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|index
operator|+
name|EXTEND_CHUNK
operator|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|space
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|index
operator|+
name|EXTEND_CHUNK
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure we have something to copy before we copy it */
if|if
condition|(
name|ea
operator|->
name|nelem
condition|)
block|{
name|bcopy
argument_list|(
name|ea
operator|->
name|ps
argument_list|,
name|space
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
name|ea
operator|->
name|nelem
argument_list|)
expr_stmt|;
name|extend_free
argument_list|(
name|ea
operator|->
name|ps
argument_list|)
expr_stmt|;
block|}
name|ea
operator|->
name|ps
operator|=
name|space
expr_stmt|;
name|ea
operator|->
name|nelem
operator|=
name|index
operator|+
name|EXTEND_CHUNK
expr_stmt|;
block|}
if|if
condition|(
name|ea
operator|->
name|ps
index|[
name|index
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"extend_set: entry %d already has storage.\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|ea
operator|->
name|ps
index|[
name|index
index|]
operator|=
name|value
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|extend_get
parameter_list|(
name|struct
name|extend_array
modifier|*
name|ea
parameter_list|,
name|int
name|index
parameter_list|)
block|{
if|if
condition|(
name|ea
operator|==
name|NULL
operator|||
name|index
operator|>=
name|ea
operator|->
name|nelem
operator|||
name|index
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
return|return
name|ea
operator|->
name|ps
index|[
name|index
index|]
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|extend_release
parameter_list|(
name|struct
name|extend_array
modifier|*
name|ea
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|extend_get
argument_list|(
name|ea
argument_list|,
name|index
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|ea
operator|->
name|ps
index|[
name|index
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/***********************************************************************  * This extend_array holds an array of "scsibus_data" pointers.  * One of these is allocated and filled in for each scsi bus.  * it holds pointers to allow the scsi bus to get to the driver  * that is running each LUN on the bus  * it also has a template entry which is the prototype struct  * supplied by the adapter driver, this is used to initialise  * the others, before they have the rest of the fields filled in  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|extend_array
modifier|*
name|scbusses
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The structure of known drivers for autoconfiguration  */
end_comment

begin_struct
struct|struct
name|scsidevs
block|{
name|u_int32_t
name|type
decl_stmt|;
name|u_int32_t
name|driver
decl_stmt|;
comment|/* normally the same as type */
name|boolean
name|removable
decl_stmt|;
name|char
modifier|*
name|manufacturer
decl_stmt|;
name|char
modifier|*
name|model
decl_stmt|;
name|char
modifier|*
name|version
decl_stmt|;
name|char
modifier|*
name|devname
decl_stmt|;
name|char
name|flags
decl_stmt|;
comment|/* 1 show my comparisons during boot(debug) */
name|u_int16_t
name|quirks
decl_stmt|;
name|void
modifier|*
name|devmodes
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SC_SHOWME
value|0x01
end_define

begin_define
define|#
directive|define
name|SC_ONE_LU
value|0x00
end_define

begin_define
define|#
directive|define
name|SC_MORE_LUS
value|0x02
end_define

begin_decl_stmt
specifier|static
name|struct
name|scsidevs
name|unknowndev
init|=
block|{
name|T_UNKNOWN
block|,
name|T_UNKNOWN
block|,
literal|0
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"uk"
block|,
name|SC_MORE_LUS
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_tandberg3600
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|0
block|,
name|ST_Q_FORCE_VAR_MODE
block|,
name|QIC_525
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_120
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_tandberg4200
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|0
block|,
name|ST_Q_FORCE_VAR_MODE
block|,
literal|0
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_120
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_archive2525
init|=
block|{
block|{
literal|0
block|,
name|ST_Q_SNS_HLP
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|0
block|,
name|ST_Q_SNS_HLP
block|,
name|QIC_525
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_120
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_archive150
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_120
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_24
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_wangtek5525
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|0
block|,
name|ST_Q_BLKSIZ
block|,
name|QIC_525
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_150
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
literal|0
block|,
name|QIC_120
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_wangdat1300
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|512
block|,
name|ST_Q_FORCE_FIXED_MODE
block|,
name|DDS
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|1024
block|,
name|ST_Q_FORCE_FIXED_MODE
block|,
name|DDS
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
name|ST_Q_FORCE_VAR_MODE
block|,
name|DDS
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|st_modes
name|mode_unktape
init|=
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|,
comment|/* minor 0,1,2,3 */
block|{
literal|512
block|,
name|ST_Q_FORCE_FIXED_MODE
block|,
name|QIC_24
block|}
block|,
comment|/* minor 4,5,6,7 */
block|{
literal|0
block|,
name|ST_Q_FORCE_VAR_MODE
block|,
name|HALFINCH_1600
block|}
block|,
comment|/* minor 8,9,10,11 */
block|{
literal|0
block|,
name|ST_Q_FORCE_VAR_MODE
block|,
name|HALFINCH_6250
block|}
comment|/* minor 12,13,14,15 */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/***********************************************************************  * A list of known devices and their "quirks".  Matching is based  * first on device type, then on the manufacturer, model, and revision  * strings returned by the device.  The returned strings are fixed lengths  * of 8, 16 and 4 bytes respectively.  In the matching pattern, a  * question mark (?) matches any single character and a trailing   * asterisk (*) matches remaining characters.  For patterns shorter   * than their respective fields, trailing spaces are implied.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsidevs
name|knowndevs
index|[]
init|=
block|{
comment|/* od's must be probed before sd's since some of them identify as T_DIRECT */
if|#
directive|if
name|NOD
operator|>
literal|0
block|{
name|T_OPTICAL
block|,
name|T_OPTICAL
block|,
name|T_REMOV
block|,
literal|"MATSHITA"
block|,
literal|"PD-1 LF-1000"
block|,
literal|"*"
block|,
literal|"od"
block|,
name|SC_MORE_LUS
block|}
block|,
block|{
name|T_DIRECT
block|,
name|T_OPTICAL
block|,
name|T_REMOV
block|,
literal|"SONY"
block|,
literal|"SMO-*"
block|,
literal|"*"
block|,
literal|"od"
block|,
name|SC_MORE_LUS
block|}
block|,
block|{
name|T_OPTICAL
block|,
name|T_OPTICAL
block|,
name|T_REMOV
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"od"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NOD */
if|#
directive|if
name|NSD
operator|>
literal|0
block|{
name|T_DIRECT
block|,
name|T_DIRECT
block|,
name|T_FIXED
block|,
literal|"EMULEX"
block|,
literal|"MD21*"
block|,
literal|"*"
block|,
literal|"sd"
block|,
name|SC_MORE_LUS
block|}
block|,
block|{
name|T_DIRECT
block|,
name|T_DIRECT
block|,
name|T_FIXED
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"sd"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NSD */
if|#
directive|if
name|NST
operator|>
literal|0
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"TANDBERG"
block|,
literal|" TDC 3600"
block|,
literal|"*"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
name|ST_Q_NEEDS_PAGE_0
block|,
name|mode_tandberg3600
block|}
block|,
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"TANDBERG"
block|,
literal|" TDC 42*"
block|,
literal|"*"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
name|ST_Q_SNS_HLP
operator||
name|ST_Q_NO_1024
block|,
name|mode_tandberg4200
block|}
block|,
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 2525*"
block|,
literal|"-005"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
literal|0
block|,
name|mode_archive2525
block|}
block|,
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"ARCHIVE"
block|,
literal|"VIPER 150 *"
block|,
literal|"*"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
name|ST_Q_NEEDS_PAGE_0
block|,
name|mode_archive150
block|}
block|,
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"WANGTEK"
block|,
literal|"5525ES*"
block|,
literal|"*"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
literal|0
block|,
name|mode_wangtek5525
block|}
block|,
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"WangDAT"
block|,
literal|"Model 1300"
block|,
literal|"*"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
literal|0
block|,
name|mode_wangdat1300
block|}
block|,
block|{
name|T_SEQUENTIAL
block|,
name|T_SEQUENTIAL
block|,
name|T_REMOV
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"st"
block|,
name|SC_ONE_LU
block|,
literal|0
block|,
name|mode_unktape
block|}
block|,
endif|#
directive|endif
comment|/* NST */
if|#
directive|if
name|NCH
operator|>
literal|0
block|{
name|T_CHANGER
block|,
name|T_CHANGER
block|,
name|T_REMOV
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"ch"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NCH */
if|#
directive|if
name|NCD
operator|>
literal|0
ifndef|#
directive|ifndef
name|UKTEST
comment|/* make cdroms unrecognised to test the uk driver */
comment|/* 	* CDU-8003A aka Apple CDROM-300. 	*/
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"SONY"
block|,
literal|"CD-ROM CDU-8003A"
block|,
literal|"1.9a"
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"SONY"
block|,
literal|"CD-ROM CDU-8012"
block|,
literal|"3.1a"
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"PIONEER"
block|,
literal|"CD-ROM DRM-6??*"
block|,
literal|"*"
block|,
literal|"cd"
block|,
name|SC_MORE_LUS
block|,
name|CD_Q_NO_TOUCH
block|}
block|,
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"NRC"
block|,
literal|"MBR-7*"
block|,
literal|"*"
block|,
literal|"cd"
block|,
name|SC_MORE_LUS
block|}
block|,
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"CHINON"
block|,
literal|"CD-ROM CDS-535"
block|,
literal|"*"
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
comment|/* 	 * Note: My drive with v1.0 firmware "forgets" to generate scsi parity 	 * when answering probes.. :-( EVIL!!  You need to disable scsi parity 	 * checking in order to find out that it answers to all 7 LUNS. :-( 	 * -Peter 	 */
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"NEC"
block|,
literal|"CD-ROM DRIVE:55"
block|,
literal|"*"
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
comment|/* 	 * Same with the OEM version of this drive (1.0 firmware). 	 * -Paul 	 */
block|{
name|T_READONLY
block|,
name|T_READONLY
block|,
name|T_REMOV
block|,
literal|"NEC"
block|,
literal|"CD-ROM DRIVE:210"
block|,
literal|"*"
block|,
literal|"cd"
block|,
name|SC_ONE_LU
block|}
block|,
comment|/* 	 * Doobe-doo-be doooo 	 * -Mary 	 */
endif|#
directive|endif
comment|/* !UKTEST */
endif|#
directive|endif
comment|/* NCD */
if|#
directive|if
name|NWORM
operator|>
literal|0
block|{
name|T_READONLY
block|,
name|T_WORM
block|,
name|T_REMOV
block|,
literal|"HP"
block|,
literal|"C4324/C4325"
block|,
literal|"*"
block|,
literal|"worm"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
comment|/* That's the Philips drive, in case anybody wonders... */
name|T_READONLY
block|,
name|T_WORM
block|,
name|T_REMOV
block|,
literal|"IMS"
block|,
literal|"CDD2000*"
block|,
literal|"*"
block|,
literal|"worm"
block|,
name|SC_ONE_LU
block|}
block|,
comment|/* 	 * The Plasmon's are dual-faced: they appear as T_WORM if the 	 * drive is empty, or a CD-R medium is in the drive, and they 	 * announce theirselves as T_READONLY if a CD-ROM (or fixated 	 * CD-R) is there.  This record catches the latter case, while 	 * the former one falls under the terms of the generic T_WORM 	 * below. 	 */
block|{
name|T_READONLY
block|,
name|T_WORM
block|,
name|T_REMOV
block|,
literal|"PLASMON"
block|,
literal|"RF41*"
block|,
literal|"*"
block|,
literal|"worm"
block|,
name|SC_ONE_LU
block|}
block|,
block|{
name|T_WORM
block|,
name|T_WORM
block|,
name|T_REMOV
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"*"
block|,
literal|"worm"
block|,
name|SC_ONE_LU
block|}
block|,
endif|#
directive|endif
comment|/* NWORM */
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Declarations  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsidevs
modifier|*
name|scsi_probedev
name|__P
argument_list|(
operator|(
expr|struct
name|scsi_link
operator|*
name|sc_link
operator|,
name|boolean
operator|*
name|maybe_more
operator|,
name|int
operator|*
name|type_p
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|scsidevs
modifier|*
name|scsi_selectdev
name|__P
argument_list|(
operator|(
name|u_int32_t
name|qualifier
operator|,
name|u_int32_t
name|type
operator|,
name|boolean
name|remov
operator|,
name|char
operator|*
name|manu
operator|,
name|char
operator|*
name|model
operator|,
name|char
operator|*
name|rev
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX dufault@hda.com  * This scsi_device doesn't have the scsi_data_size.  * This is used during probe.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
name|probe_switch
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|"probe"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_bus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First bus not wired down */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|scsi_device
modifier|*
name|device_list
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|next_free_type
init|=
name|T_NTYPES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Register new functions at the head of the list.  That allows  * you to replace a standard driver with a new one.  *  * You can't register the exact device (the same in memory structure)  * more than once - the list links are part of the structure.  That is  * prevented.  *  * Custom devices should always be registered as type "-1".  Then  * the next available type number will be allocated for it.  *  * Be careful not to register a type as 0 unless you really mean to  * replace the disk driver.  *  * This is usually called only by the "device_init" function generated  * automatically in the SCSI_DEVICE_ENTRIES macro.  */
end_comment

begin_function
name|void
name|scsi_device_register
parameter_list|(
name|struct
name|scsi_device
modifier|*
name|sd
parameter_list|)
block|{
comment|/* Not only is it pointless to add the same device more than once 	 * but it will also screw up the list. 	 */
name|struct
name|scsi_device
modifier|*
name|is_there
decl_stmt|;
for|for
control|(
name|is_there
operator|=
name|device_list
init|;
name|is_there
condition|;
name|is_there
operator|=
name|is_there
operator|->
name|next
control|)
if|if
condition|(
name|is_there
operator|==
name|sd
condition|)
return|return;
if|if
condition|(
name|sd
operator|->
name|type
operator|==
operator|-
literal|1
condition|)
name|sd
operator|->
name|type
operator|=
name|next_free_type
operator|++
expr_stmt|;
name|sd
operator|->
name|next
operator|=
name|device_list
expr_stmt|;
name|device_list
operator|=
name|sd
expr_stmt|;
if|if
condition|(
name|sd
operator|->
name|links
operator|==
literal|0
condition|)
name|sd
operator|->
name|links
operator|=
name|extend_new
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|scsi_device
modifier|*
name|scsi_device_lookup
parameter_list|(
name|int
name|type
parameter_list|)
block|{
name|struct
name|scsi_device
modifier|*
name|sd
decl_stmt|;
for|for
control|(
name|sd
operator|=
name|device_list
init|;
name|sd
condition|;
name|sd
operator|=
name|sd
operator|->
name|next
control|)
if|if
condition|(
name|sd
operator|->
name|type
operator|==
name|type
condition|)
return|return
name|sd
return|;
return|return
operator|&
name|uk_switch
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|scsi_device
modifier|*
name|scsi_device_lookup_by_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|scsi_device
modifier|*
name|sd
decl_stmt|;
for|for
control|(
name|sd
operator|=
name|device_list
init|;
name|sd
condition|;
name|sd
operator|=
name|sd
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|sd
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|sd
return|;
return|return
operator|&
name|uk_switch
return|;
block|}
end_function

begin_comment
comment|/* Macro that lets us know something is specified.  */
end_comment

begin_define
define|#
directive|define
name|IS_SPECIFIED
parameter_list|(
name|ARG
parameter_list|)
value|(ARG != SCCONF_UNSPEC&& ARG != SCCONF_ANY)
end_define

begin_comment
comment|/* scsi_init: Do all the one time processing.  This initializes the  * type drivers and initializes the configuration.  */
end_comment

begin_function
specifier|static
name|void
name|scsi_init
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|done
condition|)
block|{
name|int
name|i
decl_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
name|scbusses
operator|=
name|extend_new
argument_list|()
expr_stmt|;
comment|/* First call all type initialization functions. 		 */
name|ukinit
argument_list|()
expr_stmt|;
comment|/* We always have the unknown device. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_tinit
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
call|(
modifier|*
name|scsi_tinit
index|[
name|i
index|]
call|)
argument_list|()
expr_stmt|;
comment|/* Lowest free bus for auto-configure is one 		 * more than the first one not 		 * specified in config: 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|driver
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|IS_SPECIFIED
argument_list|(
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|scbus
argument_list|)
operator|&&
name|free_bus
operator|<=
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|scbus
condition|)
name|free_bus
operator|=
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|scbus
operator|+
literal|1
expr_stmt|;
comment|/* Lowest free unit for each type for auto-configure is one 		 * more than the first one not specified in the config file: 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|scsi_device_config
modifier|*
name|sdc
init|=
name|scsi_dinit
operator|+
name|i
decl_stmt|;
name|struct
name|scsi_device
modifier|*
name|sd
init|=
name|scsi_device_lookup_by_name
argument_list|(
name|sdc
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* This is a little tricky: We don't want "sd 4" to match as 			 * a wired down device, but we do want "sd 4 target 5" or 			 * even "sd 4 scbus 1" to match. 			 */
if|if
condition|(
name|IS_SPECIFIED
argument_list|(
name|sdc
operator|->
name|unit
argument_list|)
operator|&&
operator|(
name|IS_SPECIFIED
argument_list|(
name|sdc
operator|->
name|target
argument_list|)
operator|||
name|IS_SPECIFIED
argument_list|(
name|sdc
operator|->
name|cunit
argument_list|)
operator|)
operator|&&
name|sd
operator|->
name|free_unit
operator|<=
name|sdc
operator|->
name|unit
condition|)
name|sd
operator|->
name|free_unit
operator|=
name|sdc
operator|->
name|unit
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* scsi_bus_conf: Figure out which bus this is.  If it is wired in config  * use that.  Otherwise use the next free one.  */
end_comment

begin_function
specifier|static
name|int
name|scsi_bus_conf
parameter_list|(
name|sc_link_proto
parameter_list|)
name|struct
name|scsi_link
modifier|*
name|sc_link_proto
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|bus
decl_stmt|;
comment|/* Which bus is this?  Try to find a match in the "scsi_cinit" 	 * table.  If it isn't wired down auto-configure it at the 	 * next available bus. 	 */
name|bus
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|driver
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|IS_SPECIFIED
argument_list|(
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|scbus
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|sc_link_proto
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|driver
argument_list|)
operator|&&
operator|(
name|sc_link_proto
operator|->
name|adapter_unit
operator|==
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|unit
operator|)
condition|)
block|{
if|if
condition|(
name|IS_SPECIFIED
argument_list|(
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|bus
argument_list|)
condition|)
block|{
if|if
condition|(
name|sc_link_proto
operator|->
name|adapter_bus
operator|==
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|bus
condition|)
block|{
name|bus
operator|=
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|scbus
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|sc_link_proto
operator|->
name|adapter_bus
operator|==
literal|0
condition|)
block|{
comment|/* Backwards compatibility for single bus cards */
name|bus
operator|=
name|scsi_cinit
index|[
name|i
index|]
operator|.
name|scbus
expr_stmt|;
break|break;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Ambiguous scbus configuration for %s%d "
literal|"bus %d, cannot wire down.  The kernel "
literal|"config entry for scbus%d should specify "
literal|"a controller bus.\n"
literal|"Scbus will be assigned dynamically.\n"
argument_list|,
name|sc_link_proto
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|sc_link_proto
operator|->
name|adapter_unit
argument_list|,
name|sc_link_proto
operator|->
name|adapter_bus
argument_list|,
name|sc_link_proto
operator|->
name|adapter_bus
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|bus
operator|==
name|SCCONF_UNSPEC
condition|)
name|bus
operator|=
name|free_bus
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"Choosing drivers for scbus configured at %d\n"
argument_list|,
name|bus
argument_list|)
expr_stmt|;
return|return
name|bus
return|;
block|}
end_function

begin_comment
comment|/* scsi_assign_unit: Look through the structure generated by config.  * See if there is a fixed assignment for this unit.  If there isn't,  * assign the next free unit.  */
end_comment

begin_function
specifier|static
name|int
name|scsi_assign_unit
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|found
decl_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|struct
name|cfdata
name|cf
decl_stmt|;
name|cf
operator|.
name|cf_flags
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|sc_link
operator|->
name|target
operator|==
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|target
operator|&&
operator|(
operator|(
name|sc_link
operator|->
name|lun
operator|==
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|lun
operator|)
operator|||
operator|(
name|sc_link
operator|->
name|lun
operator|==
literal|0
operator|&&
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|lun
operator|==
name|SCCONF_UNSPEC
operator|)
operator|)
operator|&&
name|sc_link
operator|->
name|scsibus
operator|==
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|cunit
condition|)
block|{
name|sc_link
operator|->
name|dev_unit
operator|=
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|unit
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
name|cf
operator|.
name|cf_flags
operator|=
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"%s is configured at %d\n"
argument_list|,
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
name|sc_link
operator|->
name|dev_unit
operator|=
name|sc_link
operator|->
name|device
operator|->
name|free_unit
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|PC98
if|if
condition|(
operator|!
name|found
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|target
operator|==
name|SCCONF_UNSPEC
operator|)
condition|)
name|cf
operator|.
name|cf_flags
operator|=
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|flags
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc_link
operator|->
name|adapter
operator|->
name|open_target_lu
condition|)
operator|(
operator|*
operator|(
name|sc_link
operator|->
name|adapter
operator|->
name|open_target_lu
operator|)
operator|)
operator|(
name|sc_link
operator|,
operator|&
name|cf
operator|)
expr_stmt|;
endif|#
directive|endif
return|return
name|sc_link
operator|->
name|dev_unit
return|;
block|}
end_function

begin_if
if|#
directive|if
name|NSCTARG
operator|>
literal|0
end_if

begin_comment
comment|/* The SCSI target configuration is simpler.  If an entry is present  * we just return the bus, target and lun for that unit.  */
end_comment

begin_function
specifier|static
name|void
name|scsi_sctarg_lookup
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|lun
parameter_list|,
name|int
modifier|*
name|bus
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|bus
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
operator|*
name|target
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
operator|*
name|lun
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|unit
operator|==
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|unit
condition|)
block|{
operator|*
name|bus
operator|=
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|cunit
expr_stmt|;
operator|*
name|target
operator|=
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|target
expr_stmt|;
operator|*
name|lun
operator|=
name|scsi_dinit
index|[
name|i
index|]
operator|.
name|lun
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSCTARG> 0 */
end_comment

begin_function
name|void
name|scsi_configure_start
parameter_list|(
name|void
parameter_list|)
block|{
name|scsi_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NSCTARG
operator|>
literal|0
end_if

begin_decl_stmt
specifier|static
name|errval
name|scsi_attach_sctarg
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|scsi_configure_finish
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
name|NSCTARG
operator|>
literal|0
name|scsi_attach_sctarg
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * scsi_attachdevs is the routine called by the adapter boards  * to get all their devices configured in.  */
end_comment

begin_function
name|void
name|scsi_attachdevs
parameter_list|(
name|scbus
parameter_list|)
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
block|{
name|int
name|scsibus
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link_proto
init|=
name|scbus
operator|->
name|adapter_link
decl_stmt|;
if|if
condition|(
operator|(
name|scsibus
operator|=
name|scsi_bus_conf
argument_list|(
name|sc_link_proto
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
return|return;
block|}
comment|/* 	 * if the adapter didn't give us this, set a default 	 * (compatibility with old adapter drivers) 	 */
if|if
condition|(
operator|!
operator|(
name|sc_link_proto
operator|->
name|opennings
operator|)
condition|)
block|{
name|sc_link_proto
operator|->
name|opennings
operator|=
literal|1
expr_stmt|;
block|}
name|sc_link_proto
operator|->
name|scsibus
operator|=
name|scsibus
expr_stmt|;
comment|/* 	 * Allocate our target-lun space. 	 */
name|scbus
operator|->
name|sc_link
operator|=
operator|(
expr|struct
name|scsi_link
operator|*
operator|(
operator|*
operator|)
index|[]
index|[
literal|8
index|]
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_link
operator|*
index|[
name|scbus
operator|->
name|maxtarg
operator|+
literal|1
index|]
index|[
literal|8
index|]
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|scbus
operator|==
literal|0
operator|||
name|scbus
operator|->
name|sc_link
operator|==
literal|0
operator|||
name|extend_set
argument_list|(
name|scbusses
argument_list|,
name|scsibus
argument_list|,
name|scbus
argument_list|)
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"scsi_attachdevs: malloc"
argument_list|)
expr_stmt|;
block|}
name|bzero
argument_list|(
name|scbus
operator|->
name|sc_link
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_link
operator|*
index|[
name|scbus
operator|->
name|maxtarg
operator|+
literal|1
index|]
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SCSI_DELAY
argument_list|)
operator|&&
name|SCSI_DELAY
operator|>
literal|2
name|printf
argument_list|(
literal|"%s%d waiting for scsi devices to settle\n"
argument_list|,
name|sc_link_proto
operator|->
name|adapter
operator|->
name|name
argument_list|,
name|sc_link_proto
operator|->
name|adapter_unit
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SCSI_DELAY> 2 */
undef|#
directive|undef
name|SCSI_DELAY
define|#
directive|define
name|SCSI_DELAY
value|2
endif|#
directive|endif
comment|/* SCSI_DELAY */
name|DELAY
argument_list|(
literal|1000000
operator|*
name|SCSI_DELAY
argument_list|)
expr_stmt|;
name|scsi_probe_bus
argument_list|(
name|scsibus
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe the requested scsi bus. It must be already set up.  * -1 requests all set up scsi busses.  * targ and lun optionally narrow the search if not -1  */
end_comment

begin_function
name|errval
name|scsi_probe_busses
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|targ
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
if|if
condition|(
name|bus
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|bus
operator|=
literal|0
init|;
name|bus
operator|<
name|scbusses
operator|->
name|nelem
condition|;
name|bus
operator|++
control|)
block|{
name|scsi_probe_bus
argument_list|(
name|bus
argument_list|,
name|targ
argument_list|,
name|lun
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
return|return
name|scsi_probe_bus
argument_list|(
name|bus
argument_list|,
name|targ
argument_list|,
name|lun
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* scsi_alloc_unit: Register a scsi_data pointer for a given  * unit in a given scsi_device structure.  *  * XXX dufault@hda.com: I still don't like the way this reallocs stuff -  * but at least now it is collected in one place instead of existing  * in multiple type drivers.  I'd like it better if we had it do a  * second pass after it knew the sizes of everything and set up everything  * at once.  */
end_comment

begin_function
specifier|static
name|int
name|scsi_alloc_unit
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|u_int32_t
name|unit
decl_stmt|;
name|struct
name|scsi_data
modifier|*
name|sd
decl_stmt|;
name|struct
name|scsi_device
modifier|*
name|dsw
decl_stmt|;
name|unit
operator|=
name|sc_link
operator|->
name|dev_unit
expr_stmt|;
name|dsw
operator|=
name|sc_link
operator|->
name|device
expr_stmt|;
comment|/* 	 * allocate the per unit data area 	 */
if|if
condition|(
name|dsw
operator|->
name|sizeof_scsi_data
condition|)
block|{
name|sd
operator|=
name|malloc
argument_list|(
name|dsw
operator|->
name|sizeof_scsi_data
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sd
condition|)
block|{
name|printf
argument_list|(
literal|"%s%ld: malloc failed for scsi_data\n"
argument_list|,
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bzero
argument_list|(
name|sd
argument_list|,
name|dsw
operator|->
name|sizeof_scsi_data
argument_list|)
expr_stmt|;
block|}
else|else
name|sd
operator|=
literal|0
expr_stmt|;
name|sc_link
operator|->
name|sd
operator|=
name|sd
expr_stmt|;
if|if
condition|(
name|extend_set
argument_list|(
name|dsw
operator|->
name|links
argument_list|,
name|unit
argument_list|,
operator|(
name|void
operator|*
operator|)
name|sc_link
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s%ld: Can't store link pointer.\n"
argument_list|,
name|sc_link
operator|->
name|device
operator|->
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|scsi_free_unit
parameter_list|(
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
if|if
condition|(
name|sc_link
operator|->
name|sd
condition|)
block|{
name|free
argument_list|(
name|sc_link
operator|->
name|sd
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|sc_link
operator|->
name|sd
operator|=
literal|0
expr_stmt|;
block|}
name|extend_release
argument_list|(
name|sc_link
operator|->
name|device
operator|->
name|links
argument_list|,
name|sc_link
operator|->
name|dev_unit
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|NSCTARG
operator|>
literal|0
end_if

begin_comment
comment|/* XXX: It is a bug that the sc_link has this information  *      about the adapter in it.  The sc_link should refer to  *      a structure that is host adpater specific.  That will also  *      pull all knowledge of an sc_link out of the adapter drivers.  */
end_comment

begin_function
name|errval
name|scsi_set_bus
parameter_list|(
name|int
name|bus
parameter_list|,
name|struct
name|scsi_link
modifier|*
name|sc_link
parameter_list|)
block|{
name|struct
name|scsi_link
modifier|*
name|ad_link
decl_stmt|;
name|struct
name|scsibus_data
modifier|*
name|scsibus_data
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
operator|||
name|bus
operator|>
name|scbusses
operator|->
name|nelem
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|scsibus_data
operator|=
operator|(
expr|struct
name|scsibus_data
operator|*
operator|)
name|extend_get
argument_list|(
name|scbusses
argument_list|,
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scsibus_data
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|ad_link
operator|=
name|scsibus_data
operator|->
name|adapter_link
expr_stmt|;
name|sc_link
operator|->
name|adapter_unit
operator|=
name|ad_link
operator|->
name|adapter_unit
expr_stmt|;
name|sc_link
operator|->
name|adapter_targ
operator|=
name|ad_link
operator|->
name|adapter_targ
expr_stmt|;
name|sc_link
operator|->
name|adapter
operator|=
name|ad_link
operator|->
name|adapter
expr_stmt|;
name|sc_link
operator|->
name|device
operator|=
name|ad_link
operator|->
name|device
expr_stmt|;
name|sc_link
operator|->
name|flags
operator|=
name|ad_link
operator|->
name|flags
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and attach as many SCSI target devices as configured.  * There are two ways that you can configure the target device:  * 1. In the configuration file.  That is handled here.  * 2. Via the minor number.  That takes precedence over the config file.  */
end_comment

begin_function
specifier|static
name|errval
name|scsi_attach_sctarg
parameter_list|()
block|{
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|NULL
decl_stmt|;
name|int
name|dev_unit
decl_stmt|;
name|struct
name|scsi_device
modifier|*
name|sctarg
init|=
name|scsi_device_lookup
argument_list|(
name|T_TARGET
argument_list|)
decl_stmt|;
if|if
condition|(
name|sctarg
operator|==
literal|0
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
for|for
control|(
name|dev_unit
operator|=
literal|0
init|;
name|dev_unit
operator|<
name|NSCTARG
condition|;
name|dev_unit
operator|++
control|)
block|{
name|int
name|target
decl_stmt|,
name|lun
decl_stmt|,
name|bus
decl_stmt|;
comment|/* If we don't have a link block allocate one. 		 */
if|if
condition|(
operator|!
name|sc_link
condition|)
block|{
name|sc_link
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc_link
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
name|scsi_sctarg_lookup
argument_list|(
name|sctarg
operator|->
name|name
argument_list|,
name|dev_unit
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|lun
argument_list|,
operator|&
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_SPECIFIED
argument_list|(
name|bus
argument_list|)
condition|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scsibus_data
decl_stmt|;
if|if
condition|(
name|bus
operator|<
literal|0
operator|||
name|bus
operator|>
name|scbusses
operator|->
name|nelem
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: configured on illegal bus %d.\n"
argument_list|,
name|sctarg
operator|->
name|name
argument_list|,
name|dev_unit
argument_list|,
name|bus
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|scsibus_data
operator|=
operator|(
expr|struct
name|scsibus_data
operator|*
operator|)
name|extend_get
argument_list|(
name|scbusses
argument_list|,
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scsibus_data
condition|)
block|{
name|printf
argument_list|(
literal|"%s%d: no bus %d.\n"
argument_list|,
name|sctarg
operator|->
name|name
argument_list|,
name|dev_unit
argument_list|,
name|bus
argument_list|)
expr_stmt|;
continue|continue;
block|}
operator|*
name|sc_link
operator|=
operator|*
name|scsibus_data
operator|->
name|adapter_link
expr_stmt|;
comment|/* struct copy */
name|sc_link
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|sc_link
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
block|}
else|else
block|{
comment|/* This will be configured in the open routine. 			 */
name|sc_link
operator|->
name|scsibus
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
name|sc_link
operator|->
name|target
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
name|sc_link
operator|->
name|lun
operator|=
name|SCCONF_UNSPEC
expr_stmt|;
block|}
name|sc_link
operator|->
name|quirks
operator|=
literal|0
expr_stmt|;
name|sc_link
operator|->
name|device
operator|=
name|sctarg
expr_stmt|;
name|sc_link
operator|->
name|dev_unit
operator|=
name|dev_unit
expr_stmt|;
if|if
condition|(
name|scsi_alloc_unit
argument_list|(
name|sc_link
argument_list|)
condition|)
block|{
if|if
condition|(
name|scsi_device_attach
argument_list|(
name|sc_link
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sc_link
operator|=
name|NULL
expr_stmt|;
comment|/* it's been used */
block|}
else|else
name|scsi_free_unit
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sc_link
condition|)
block|{
name|free
argument_list|(
name|sc_link
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NSCTARG> 0 */
end_comment

begin_comment
comment|/*  * Allocate a scsibus_data structure  * The target/lun area is dynamically allocated in scsi_attachdevs after  * the controller driver has a chance to update the maxtarg field.  */
end_comment

begin_function
name|struct
name|scsibus_data
modifier|*
name|scsi_alloc_bus
parameter_list|()
block|{
name|struct
name|scsibus_data
modifier|*
name|scbus
decl_stmt|;
comment|/* 	 * Prepare the scsibus_data area for the upperlevel 	 * scsi code. 	 */
name|scbus
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsibus_data
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scbus
condition|)
block|{
name|printf
argument_list|(
literal|"scsi_alloc_bus: - cannot malloc!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bzero
argument_list|(
name|scbus
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsibus_data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Setup the defaults */
name|scbus
operator|->
name|maxtarg
operator|=
literal|7
expr_stmt|;
name|scbus
operator|->
name|maxlun
operator|=
literal|7
expr_stmt|;
return|return
name|scbus
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the requested scsi bus. It must be already set up.  * targ and lun optionally narrow the search if not -1  */
end_comment

begin_function
name|errval
name|scsi_probe_bus
parameter_list|(
name|int
name|bus
parameter_list|,
name|int
name|targ
parameter_list|,
name|int
name|lun
parameter_list|)
block|{
name|struct
name|scsibus_data
modifier|*
name|scsibus_data
decl_stmt|;
name|int
name|maxtarg
decl_stmt|,
name|mintarg
decl_stmt|,
name|maxlun
decl_stmt|,
name|minlun
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link_proto
decl_stmt|;
name|u_int8_t
name|scsi_addr
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
init|=
name|NULL
decl_stmt|;
name|boolean
name|maybe_more
decl_stmt|;
name|int
name|type
decl_stmt|;
if|if
condition|(
operator|(
name|bus
operator|<
literal|0
operator|)
operator|||
operator|(
name|bus
operator|>=
name|scbusses
operator|->
name|nelem
operator|)
condition|)
block|{
return|return
name|ENXIO
return|;
block|}
name|scsibus_data
operator|=
operator|(
expr|struct
name|scsibus_data
operator|*
operator|)
name|extend_get
argument_list|(
name|scbusses
argument_list|,
name|bus
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scsibus_data
condition|)
return|return
name|ENXIO
return|;
name|sc_link_proto
operator|=
name|scsibus_data
operator|->
name|adapter_link
expr_stmt|;
name|scsi_addr
operator|=
name|sc_link_proto
operator|->
name|adapter_targ
expr_stmt|;
if|if
condition|(
name|targ
operator|==
operator|-
literal|1
condition|)
block|{
name|maxtarg
operator|=
name|scsibus_data
operator|->
name|maxtarg
expr_stmt|;
name|mintarg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|targ
operator|<
literal|0
operator|)
operator|||
operator|(
name|targ
operator|>
name|scsibus_data
operator|->
name|maxtarg
operator|)
condition|)
return|return
name|EINVAL
return|;
name|maxtarg
operator|=
name|mintarg
operator|=
name|targ
expr_stmt|;
block|}
if|if
condition|(
name|lun
operator|==
operator|-
literal|1
condition|)
block|{
name|maxlun
operator|=
name|scsibus_data
operator|->
name|maxlun
expr_stmt|;
name|minlun
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lun
operator|<
literal|0
operator|)
operator|||
operator|(
name|lun
operator|>
name|scsibus_data
operator|->
name|maxlun
operator|)
condition|)
return|return
name|EINVAL
return|;
name|maxlun
operator|=
name|minlun
operator|=
name|lun
expr_stmt|;
block|}
for|for
control|(
name|targ
operator|=
name|mintarg
init|;
name|targ
operator|<=
name|maxtarg
condition|;
name|targ
operator|++
control|)
block|{
name|maybe_more
operator|=
literal|0
expr_stmt|;
comment|/* by default only check 1 lun */
if|if
condition|(
name|targ
operator|==
name|scsi_addr
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|lun
operator|=
name|minlun
init|;
name|lun
operator|<=
name|maxlun
condition|;
name|lun
operator|++
control|)
block|{
comment|/* 			 * The spot appears to already have something 			 * linked in, skip past it. Must be doing a 'reprobe' 			 */
if|if
condition|(
operator|(
operator|*
name|scsibus_data
operator|->
name|sc_link
operator|)
index|[
name|targ
index|]
index|[
name|lun
index|]
condition|)
block|{
comment|/* don't do this one, but check other luns */
name|maybe_more
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we presently don't have a link block 			 * then allocate one to use while probing 			 */
if|if
condition|(
operator|!
name|sc_link
condition|)
block|{
name|sc_link
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|sc_link
argument_list|)
argument_list|,
name|M_TEMP
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
block|}
operator|*
name|sc_link
operator|=
operator|*
name|sc_link_proto
expr_stmt|;
comment|/* struct copy */
name|sc_link
operator|->
name|device
operator|=
operator|&
name|probe_switch
expr_stmt|;
name|sc_link
operator|->
name|target
operator|=
name|targ
expr_stmt|;
name|sc_link
operator|->
name|lun
operator|=
name|lun
expr_stmt|;
name|sc_link
operator|->
name|quirks
operator|=
literal|0
expr_stmt|;
name|bestmatch
operator|=
name|scsi_probedev
argument_list|(
name|sc_link
argument_list|,
operator|&
name|maybe_more
argument_list|,
operator|&
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestmatch
condition|)
block|{
name|sc_link
operator|->
name|quirks
operator|=
name|bestmatch
operator|->
name|quirks
expr_stmt|;
name|sc_link
operator|->
name|devmodes
operator|=
name|bestmatch
operator|->
name|devmodes
expr_stmt|;
block|}
else|else
block|{
name|sc_link
operator|->
name|quirks
operator|=
literal|0
expr_stmt|;
name|sc_link
operator|->
name|devmodes
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|bestmatch
condition|)
block|{
comment|/* FOUND */
name|sc_link
operator|->
name|device
operator|=
name|scsi_device_lookup
argument_list|(
name|type
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|scsi_assign_unit
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|scsi_alloc_unit
argument_list|(
name|sc_link
argument_list|)
condition|)
block|{
if|if
condition|(
name|scsi_device_attach
argument_list|(
name|sc_link
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|scsibus_data
operator|->
name|sc_link
operator|)
index|[
name|targ
index|]
index|[
name|lun
index|]
operator|=
name|sc_link
expr_stmt|;
name|sc_link
operator|=
name|NULL
expr_stmt|;
comment|/* it's been used */
block|}
else|else
name|scsi_free_unit
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|maybe_more
operator|)
condition|)
block|{
comment|/* nothing suggests we'll find more */
break|break;
comment|/* nothing here, skip to next targ */
block|}
comment|/* otherwise something says we should look further */
block|}
block|}
if|if
condition|(
name|sc_link
condition|)
block|{
name|free
argument_list|(
name|sc_link
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return the scsi_link for this device, if any.  */
end_comment

begin_function
name|struct
name|scsi_link
modifier|*
name|scsi_link_get
parameter_list|(
name|bus
parameter_list|,
name|targ
parameter_list|,
name|lun
parameter_list|)
name|int
name|bus
decl_stmt|;
name|int
name|targ
decl_stmt|;
name|int
name|lun
decl_stmt|;
block|{
name|struct
name|scsibus_data
modifier|*
name|scsibus_data
init|=
operator|(
expr|struct
name|scsibus_data
operator|*
operator|)
name|extend_get
argument_list|(
name|scbusses
argument_list|,
name|bus
argument_list|)
decl_stmt|;
return|return
operator|(
name|scsibus_data
operator|)
condition|?
operator|(
operator|*
name|scsibus_data
operator|->
name|sc_link
operator|)
index|[
name|targ
index|]
index|[
name|lun
index|]
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* make_readable: Make the inquiry data readable.  Anything less than a ' '  * is made a '?' and trailing spaces are removed.  */
end_comment

begin_function
specifier|static
name|void
name|make_readable
parameter_list|(
name|to
parameter_list|,
name|from
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|;
name|char
modifier|*
name|from
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|from
index|[
name|i
index|]
operator|&&
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|from
index|[
name|i
index|]
operator|<
literal|' '
condition|)
name|to
index|[
name|i
index|]
operator|=
literal|'?'
expr_stmt|;
else|else
name|to
index|[
name|i
index|]
operator|=
name|from
index|[
name|i
index|]
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|&&
name|to
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|i
operator|--
expr_stmt|;
name|to
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * given a target and lu, ask the device what  * it is, and find the correct driver table  * entry.  */
end_comment

begin_function
specifier|static
name|struct
name|scsidevs
modifier|*
name|scsi_probedev
parameter_list|(
name|sc_link
parameter_list|,
name|maybe_more
parameter_list|,
name|type_p
parameter_list|)
name|boolean
modifier|*
name|maybe_more
decl_stmt|;
name|struct
name|scsi_link
modifier|*
name|sc_link
decl_stmt|;
name|int
modifier|*
name|type_p
decl_stmt|;
block|{
name|u_int8_t
name|target
init|=
name|sc_link
operator|->
name|target
decl_stmt|;
name|u_int8_t
name|lu
init|=
name|sc_link
operator|->
name|lun
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
decl_stmt|;
name|int
name|dtype
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|desc
decl_stmt|;
name|char
modifier|*
name|qtype
decl_stmt|;
name|struct
name|scsi_inquiry_data
modifier|*
name|inqbuf
decl_stmt|;
name|u_int32_t
name|len
decl_stmt|,
name|qualifier
decl_stmt|,
name|type
decl_stmt|;
name|boolean
name|remov
decl_stmt|;
name|char
name|manu
index|[
literal|8
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|model
index|[
literal|16
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|version
index|[
literal|4
operator|+
literal|1
index|]
decl_stmt|;
name|inqbuf
operator|=
operator|&
name|sc_link
operator|->
name|inqbuf
expr_stmt|;
name|bzero
argument_list|(
name|inqbuf
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|inqbuf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Ask the device what it is 	 */
ifdef|#
directive|ifdef
name|SCSIDEBUG
if|if
condition|(
operator|(
name|target
operator|==
name|DEBUGTARG
operator|)
operator|&&
operator|(
name|lu
operator|==
name|DEBUGLUN
operator|)
condition|)
name|sc_link
operator|->
name|flags
operator||=
operator|(
name|DEBUGLEVEL
operator|)
expr_stmt|;
else|else
name|sc_link
operator|->
name|flags
operator|&=
operator|~
operator|(
name|SDEV_DB1
operator||
name|SDEV_DB2
operator||
name|SDEV_DB3
operator||
name|SDEV_DB4
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* SCSIDEBUG */
comment|/* catch unit attn */
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DOUBTFULL
switch|switch
condition|(
name|scsi_test_unit_ready
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* said it WAS ready */
case|case
name|EBUSY
case|:
comment|/* replied 'NOT READY' but WAS present, continue */
case|case
name|ENXIO
case|:
break|break;
case|case
name|EIO
case|:
comment|/* device timed out */
case|case
name|EINVAL
case|:
comment|/* Lun not supported */
default|default:
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
endif|#
directive|endif
comment|/*DOUBTFULL*/
ifdef|#
directive|ifdef
name|SCSI_2_DEF
comment|/* some devices need to be told to go to SCSI2 */
comment|/* However some just explode if you tell them this.. leave it out */
name|scsi_change_def
argument_list|(
name|sc_link
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
operator||
name|SCSI_SILENT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*SCSI_2_DEF */
comment|/* Now go ask the device all about itself */
if|if
condition|(
name|scsi_inquire
argument_list|(
name|sc_link
argument_list|,
name|inqbuf
argument_list|,
name|SCSI_NOSLEEP
operator||
name|SCSI_NOMASK
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
comment|/* 	 * note what BASIC type of device it is 	 */
name|type
operator|=
name|inqbuf
operator|->
name|device
operator|&
name|SID_TYPE
expr_stmt|;
name|qualifier
operator|=
name|inqbuf
operator|->
name|device
operator|&
name|SID_QUAL
expr_stmt|;
name|remov
operator|=
name|inqbuf
operator|->
name|dev_qual2
operator|&
name|SID_REMOVABLE
expr_stmt|;
comment|/* 	 * Any device qualifier that has the top bit set (qualifier&4 != 0) 	 * is vendor specific and will match in the default of this switch. 	 */
switch|switch
condition|(
operator|(
name|int
operator|)
name|qualifier
condition|)
block|{
case|case
name|SID_QUAL_LU_OK
case|:
name|qtype
operator|=
literal|""
expr_stmt|;
break|break;
case|case
name|SID_QUAL_LU_OFFLINE
case|:
name|qtype
operator|=
literal|"Supported device currently not connected"
expr_stmt|;
break|break;
case|case
name|SID_QUAL_RSVD
case|:
comment|/* Peripheral qualifier reserved in SCSI-2 spec */
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
case|case
name|SID_QUAL_BAD_LU
case|:
comment|/* Target can not support a device on this unit */
comment|/* 		 * Check for a non-existent unit.  If the device is returning 		 * this much, then we must set the flag that has 		 * the searchers keep looking on other luns. 		 */
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
default|default:
name|dtype
operator|=
literal|1
expr_stmt|;
name|qtype
operator|=
literal|"Vendor specific peripheral qualifier"
expr_stmt|;
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dtype
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_NODEVICE
condition|)
block|{
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
return|return
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
return|;
block|}
name|dtype
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * Then if it's advanced enough, more detailed 	 * information 	 */
if|if
condition|(
operator|(
name|inqbuf
operator|->
name|version
operator|&
name|SID_ANSII
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|inqbuf
operator|->
name|additional_length
operator|+
operator|(
operator|(
name|char
operator|*
operator|)
name|inqbuf
operator|->
name|unused
operator|-
operator|(
name|char
operator|*
operator|)
name|inqbuf
operator|)
operator|)
operator|>
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
operator|-
literal|1
operator|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
operator|-
literal|1
expr_stmt|;
name|desc
operator|=
name|inqbuf
operator|->
name|vendor
expr_stmt|;
name|desc
index|[
name|len
operator|-
operator|(
name|desc
operator|-
operator|(
name|char
operator|*
operator|)
name|inqbuf
operator|)
index|]
operator|=
literal|0
expr_stmt|;
name|make_readable
argument_list|(
name|manu
argument_list|,
name|inqbuf
operator|->
name|vendor
argument_list|,
sizeof|sizeof
argument_list|(
name|manu
argument_list|)
argument_list|)
expr_stmt|;
name|make_readable
argument_list|(
name|model
argument_list|,
name|inqbuf
operator|->
name|product
argument_list|,
sizeof|sizeof
argument_list|(
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|make_readable
argument_list|(
name|version
argument_list|,
name|inqbuf
operator|->
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If not advanced enough, use default values 		 */
name|desc
operator|=
literal|"early protocol device"
expr_stmt|;
name|make_readable
argument_list|(
name|manu
argument_list|,
literal|"unknown"
argument_list|,
sizeof|sizeof
argument_list|(
name|manu
argument_list|)
argument_list|)
expr_stmt|;
name|make_readable
argument_list|(
name|model
argument_list|,
literal|"unknown"
argument_list|,
sizeof|sizeof
argument_list|(
name|model
argument_list|)
argument_list|)
expr_stmt|;
name|make_readable
argument_list|(
name|version
argument_list|,
literal|"????"
argument_list|,
sizeof|sizeof
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|sc_print_start
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\"%s %s %s\" "
argument_list|,
name|manu
argument_list|,
name|model
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"type %ld %sSCSI %d"
argument_list|,
name|type
argument_list|,
name|remov
condition|?
literal|"removable "
else|:
literal|"fixed "
argument_list|,
name|inqbuf
operator|->
name|version
operator|&
name|SID_ANSII
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
index|[
literal|0
index|]
condition|)
block|{
name|sc_print_addr
argument_list|(
name|sc_link
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" qualifier %ld: %s"
argument_list|,
name|qualifier
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|sc_print_finish
argument_list|()
expr_stmt|;
comment|/* 	 * Try make as good a match as possible with 	 * available sub drivers 	 */
name|bestmatch
operator|=
operator|(
name|scsi_selectdev
argument_list|(
name|qualifier
argument_list|,
name|type
argument_list|,
name|remov
condition|?
name|T_REMOV
else|:
name|T_FIXED
argument_list|,
name|manu
argument_list|,
name|model
argument_list|,
name|version
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|bestmatch
operator|)
operator|&&
operator|(
name|bestmatch
operator|->
name|flags
operator|&
name|SC_MORE_LUS
operator|)
condition|)
block|{
operator|*
name|maybe_more
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If the device is unknown then we should be trying to look up a 	 * type driver based on the inquiry type. 	 */
if|if
condition|(
name|bestmatch
operator|==
operator|&
name|unknowndev
condition|)
operator|*
name|type_p
operator|=
name|type
expr_stmt|;
else|else
operator|*
name|type_p
operator|=
name|bestmatch
operator|->
name|driver
expr_stmt|;
return|return
name|bestmatch
return|;
block|}
end_function

begin_comment
comment|/* Try to find the major number for a device during attach.  */
end_comment

begin_function
name|dev_t
name|scsi_dev_lookup
parameter_list|(
name|d_open
parameter_list|)
name|d_open_t
modifier|*
name|d_open
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|dev_t
name|d
init|=
name|NODEV
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchrdev
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cdevsw
index|[
name|i
index|]
operator|&&
name|cdevsw
index|[
name|i
index|]
operator|->
name|d_open
operator|==
name|d_open
condition|)
block|{
name|d
operator|=
name|makedev
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * Compare name with pattern, return 0 on match.  * Short pattern matches trailing blanks in name,  * wildcard '*' in pattern matches rest of name  */
end_comment

begin_function
specifier|static
name|int
name|match
parameter_list|(
name|pattern
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|pattern
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'*'
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|c
operator|==
literal|'?'
operator|)
operator|&&
operator|(
operator|*
name|name
operator|>
literal|' '
operator|)
condition|)
continue|continue;
if|if
condition|(
name|c
operator|!=
operator|*
name|name
operator|++
condition|)
return|return
literal|1
return|;
block|}
while|while
condition|(
name|c
operator|=
operator|*
name|name
operator|++
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|' '
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Try make as good a match as possible with  * available sub drivers  */
end_comment

begin_function
specifier|static
name|struct
name|scsidevs
modifier|*
name|scsi_selectdev
parameter_list|(
name|qualifier
parameter_list|,
name|type
parameter_list|,
name|remov
parameter_list|,
name|manu
parameter_list|,
name|model
parameter_list|,
name|rev
parameter_list|)
name|u_int32_t
name|qualifier
decl_stmt|,
name|type
decl_stmt|;
name|boolean
name|remov
decl_stmt|;
name|char
modifier|*
name|manu
decl_stmt|,
decl|*
name|model
decl_stmt|,
modifier|*
name|rev
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|scsidevs
modifier|*
name|bestmatch
init|=
name|NULL
decl_stmt|;
name|struct
name|scsidevs
modifier|*
name|thisentry
decl_stmt|;
name|type
operator||=
name|qualifier
expr_stmt|;
comment|/* why? */
for|for
control|(
name|thisentry
operator|=
name|knowndevs
init|;
name|thisentry
operator|->
name|manufacturer
condition|;
name|thisentry
operator|++
control|)
block|{
if|if
condition|(
name|type
operator|!=
name|thisentry
operator|->
name|type
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|remov
operator|!=
name|thisentry
operator|->
name|removable
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|manufacturer
argument_list|,
name|manu
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|thisentry
operator|->
name|manufacturer
argument_list|,
name|manu
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|model
argument_list|,
name|model
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|thisentry
operator|->
name|model
argument_list|,
name|model
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|thisentry
operator|->
name|flags
operator|&
name|SC_SHOWME
condition|)
name|printf
argument_list|(
literal|"\n%s-\n%s-"
argument_list|,
name|thisentry
operator|->
name|version
argument_list|,
name|rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|match
argument_list|(
name|thisentry
operator|->
name|version
argument_list|,
name|rev
argument_list|)
condition|)
block|{
continue|continue;
block|}
name|bestmatch
operator|=
name|thisentry
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bestmatch
operator|==
operator|(
expr|struct
name|scsidevs
operator|*
operator|)
literal|0
condition|)
block|{
name|bestmatch
operator|=
operator|&
name|unknowndev
expr_stmt|;
block|}
return|return
operator|(
name|bestmatch
operator|)
return|;
block|}
end_block

end_unit

