begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2005 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/eventhandler.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/limits.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmckern.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/sched.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/smp.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysent.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<machine/md_var.h>
end_include

begin_include
include|#
directive|include
file|<machine/pmc_mdep.h>
end_include

begin_include
include|#
directive|include
file|<machine/specialreg.h>
end_include

begin_comment
comment|/*  * Types  */
end_comment

begin_enum
enum|enum
name|pmc_flags
block|{
name|PMC_FLAG_NONE
init|=
literal|0x00
block|,
comment|/* do nothing */
name|PMC_FLAG_REMOVE
init|=
literal|0x01
block|,
comment|/* atomically remove entry from hash */
name|PMC_FLAG_ALLOCATE
init|=
literal|0x02
block|,
comment|/* add entry to hash if not found */
block|}
enum|;
end_enum

begin_comment
comment|/*  * The offset in sysent where the syscall is allocated.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_syscall_num
init|=
name|NO_SYSCALL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pmc_cpu
modifier|*
modifier|*
name|pmc_pcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-cpu state */
end_comment

begin_decl_stmt
name|pmc_value_t
modifier|*
name|pmc_pcpu_saved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* saved PMC values: CSW handling */
end_comment

begin_define
define|#
directive|define
name|PMC_PCPU_SAVED
parameter_list|(
name|C
parameter_list|,
name|R
parameter_list|)
value|pmc_pcpu_saved[(R) + md->pmd_npmc*(C)]
end_define

begin_decl_stmt
name|struct
name|mtx_pool
modifier|*
name|pmc_mtxpool
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
modifier|*
name|pmc_pmcdisp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* PMC row dispositions */
end_comment

begin_define
define|#
directive|define
name|PMC_ROW_DISP_IS_FREE
parameter_list|(
name|R
parameter_list|)
value|(pmc_pmcdisp[(R)] == 0)
end_define

begin_define
define|#
directive|define
name|PMC_ROW_DISP_IS_THREAD
parameter_list|(
name|R
parameter_list|)
value|(pmc_pmcdisp[(R)]> 0)
end_define

begin_define
define|#
directive|define
name|PMC_ROW_DISP_IS_STANDALONE
parameter_list|(
name|R
parameter_list|)
value|(pmc_pmcdisp[(R)]< 0)
end_define

begin_define
define|#
directive|define
name|PMC_MARK_ROW_FREE
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	pmc_pmcdisp[(R)] = 0;						  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_MARK_ROW_STANDALONE
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	KASSERT(pmc_pmcdisp[(R)]<= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ 	atomic_add_int(&pmc_pmcdisp[(R)], -1);				  \ 	KASSERT(pmc_pmcdisp[(R)]>= (-mp_ncpus), ("[pmc,%d] row "	  \ 		"disposition error", __LINE__));			  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_UNMARK_ROW_STANDALONE
parameter_list|(
name|R
parameter_list|)
value|do { 				  \ 	atomic_add_int(&pmc_pmcdisp[(R)], 1);				  \ 	KASSERT(pmc_pmcdisp[(R)]<= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_MARK_ROW_THREAD
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	KASSERT(pmc_pmcdisp[(R)]>= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ 	atomic_add_int(&pmc_pmcdisp[(R)], 1);				  \ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_UNMARK_ROW_THREAD
parameter_list|(
name|R
parameter_list|)
value|do {					  \ 	atomic_add_int(&pmc_pmcdisp[(R)], -1);				  \ 	KASSERT(pmc_pmcdisp[(R)]>= 0, ("[pmc,%d] row disposition error", \ 		    __LINE__));						  \ } while (0)
end_define

begin_comment
comment|/* various event handlers */
end_comment

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|pmc_exit_tag
decl_stmt|,
name|pmc_fork_tag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Module statistics */
end_comment

begin_decl_stmt
name|struct
name|pmc_op_getdriverstats
name|pmc_stats
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Machine/processor dependent operations */
end_comment

begin_decl_stmt
name|struct
name|pmc_mdep
modifier|*
name|md
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Hash tables mapping owner processes and target threads to PMCs.  */
end_comment

begin_decl_stmt
name|struct
name|mtx
name|pmc_processhash_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* spin mutex */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|pmc_processhashmask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|pmc_processhash
argument_list|,
name|pmc_process
argument_list|)
operator|*
name|pmc_processhash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Hash table of PMC owner descriptors.  This table is protected by  * the shared PMC "sx" lock.  */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|pmc_ownerhashmask
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
name|pmc_ownerhash
argument_list|,
name|pmc_owner
argument_list|)
operator|*
name|pmc_ownerhash
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Prototypes  */
end_comment

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function_decl
specifier|static
name|int
name|pmc_debugflags_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_debugflags_parse
parameter_list|(
name|char
modifier|*
name|newstr
parameter_list|,
name|char
modifier|*
name|fence
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|load
parameter_list|(
name|struct
name|module
modifier|*
name|module
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_syscall_handler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|syscall_args
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_configure_log
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|int
name|logfd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_log_process_exit
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_allocate_pmc_descriptor
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_find_pmc_descriptor_in_process
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pmc_id_t
name|pmc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_release_pmc_descriptor
parameter_list|(
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_can_allocate_rowindex
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|ri
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc_process
modifier|*
name|pmc_find_process_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_remove_process_descriptor
parameter_list|(
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_find_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_find_pmc
parameter_list|(
name|pmc_id_t
name|pmcid
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_maybe_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_unlink_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_link_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_unlink_owner
parameter_list|(
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_cleanup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_save_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_restore_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_select_cpu
parameter_list|(
name|int
name|cpu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_exit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pmc_process_fork
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_attach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_attach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_detach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_detach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_start
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_stop
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pmc_can_attach
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Kernel tunables and sysctl(8) interface.  */
end_comment

begin_define
define|#
directive|define
name|PMC_SYSCTL_NAME_PREFIX
value|"kern." PMC_MODULE_NAME "."
end_define

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_kern
argument_list|,
name|OID_AUTO
argument_list|,
name|hwpmc
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"HWPMC parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_decl_stmt
name|unsigned
name|int
name|pmc_debugflags
init|=
name|PMC_DEBUG_DEFAULT_FLAGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|pmc_debugstr
index|[
name|PMC_DEBUG_STRSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_STR
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"debugflags"
argument_list|,
name|pmc_debugstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|debugflags
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RW
operator||
name|CTLFLAG_TUN
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pmc_debugflags_sysctl_handler
argument_list|,
literal|"A"
argument_list|,
literal|"debug flags"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * kern.pmc.hashrows -- determines the number of rows in the  * of the hash table used to look up threads  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_hashsize
init|=
name|PMC_HASH_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"hashsize"
argument_list|,
operator|&
name|pmc_hashsize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|hashsize
argument_list|,
name|CTLFLAG_TUN
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmc_hashsize
argument_list|,
literal|0
argument_list|,
literal|"rows in hash tables"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * kern.pmc.pcpusize -- the size of each per-cpu  * area for collection PC samples.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_pcpu_buffer_size
init|=
name|PMC_PCPU_BUFFER_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"pcpubuffersize"
argument_list|,
operator|&
name|pmc_pcpu_buffer_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|pcpubuffersize
argument_list|,
name|CTLFLAG_TUN
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmc_pcpu_buffer_size
argument_list|,
literal|0
argument_list|,
literal|"size of per-cpu buffer in 4K pages"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * kern.pmc.mtxpoolsize -- number of mutexes in the mutex pool.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pmc_mtxpool_size
init|=
name|PMC_MTXPOOL_SIZE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"mtxpoolsize"
argument_list|,
operator|&
name|pmc_mtxpool_size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_kern_hwpmc
argument_list|,
name|OID_AUTO
argument_list|,
name|mtxpoolsize
argument_list|,
name|CTLFLAG_TUN
operator||
name|CTLFLAG_RD
argument_list|,
operator|&
name|pmc_mtxpool_size
argument_list|,
literal|0
argument_list|,
literal|"size of spin mutex pool"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * security.bsd.unprivileged_syspmcs -- allow non-root processes to  * allocate system-wide PMCs.  *  * Allowing unprivileged processes to allocate system PMCs is convenient  * if system-wide measurements need to be taken concurrently with other  * per-process measurements.  This feature is turned off by default.  */
end_comment

begin_expr_stmt
name|SYSCTL_DECL
argument_list|(
name|_security_bsd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|pmc_unprivileged_syspmcs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TUNABLE_INT
argument_list|(
literal|"security.bsd.unprivileged_syspmcs"
argument_list|,
operator|&
name|pmc_unprivileged_syspmcs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_security_bsd
argument_list|,
name|OID_AUTO
argument_list|,
name|unprivileged_syspmcs
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|pmc_unprivileged_syspmcs
argument_list|,
literal|0
argument_list|,
literal|"allow unprivileged process to allocate system PMCs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|PMC_HASH_USE_CRC32
end_if

begin_define
define|#
directive|define
name|PMC_HASH_PTR
parameter_list|(
name|P
parameter_list|,
name|M
parameter_list|)
value|(crc32(&(P), sizeof((P)))& (M))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* integer multiplication */
end_comment

begin_if
if|#
directive|if
name|LONG_BIT
operator|==
literal|64
end_if

begin_define
define|#
directive|define
name|_PMC_HM
value|11400714819323198486u
end_define

begin_elif
elif|#
directive|elif
name|LONG_BIT
operator|==
literal|32
end_elif

begin_define
define|#
directive|define
name|_PMC_HM
value|2654435769u
end_define

begin_else
else|#
directive|else
end_else

begin_error
error|#
directive|error
error|Must know the size of 'long' to compile
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Hash function.  Discard the lower 2 bits of the pointer since  * these are always zero for our uses.  The hash multiplier is  * round((2^LONG_BIT) * ((sqrt(5)-1)/2)).  */
end_comment

begin_define
define|#
directive|define
name|PMC_HASH_PTR
parameter_list|(
name|P
parameter_list|,
name|M
parameter_list|)
value|((((unsigned long) (P)>> 2) * _PMC_HM)& (M))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Syscall structures  */
end_comment

begin_comment
comment|/* The `sysent' for the new syscall */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sysent
name|pmc_sysent
init|=
block|{
literal|2
block|,
comment|/* sy_narg */
name|pmc_syscall_handler
comment|/* sy_call */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|syscall_module_data
name|pmc_syscall_mod
init|=
block|{
name|load
block|,
name|NULL
block|,
operator|&
name|pmc_syscall_num
block|,
operator|&
name|pmc_sysent
block|,
block|{
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|moduledata_t
name|pmc_mod
init|=
block|{
name|PMC_MODULE_NAME
block|,
name|syscall_module_handler
block|,
operator|&
name|pmc_syscall_mod
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|pmc
argument_list|,
name|pmc_mod
argument_list|,
name|SI_SUB_SMP
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|pmc
argument_list|,
name|PMC_VERSION
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_function
specifier|static
name|int
name|pmc_debugflags_parse
parameter_list|(
name|char
modifier|*
name|newstr
parameter_list|,
name|char
modifier|*
name|fence
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|e
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|unsigned
name|int
name|tmpflags
decl_stmt|;
name|int
name|level
decl_stmt|;
name|char
name|tmpbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* 3 character keyword + '\0' */
name|tmpflags
operator|=
literal|0
expr_stmt|;
name|level
operator|=
literal|0xF
expr_stmt|;
comment|/* max verbosity */
name|p
operator|=
name|newstr
expr_stmt|;
name|e
operator|=
name|newstr
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|p
operator|<
name|fence
operator|&&
operator|(
name|c
operator|=
operator|*
name|p
operator|)
condition|;
control|)
block|{
comment|/* skip separators */
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|','
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|tmpbuf
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpbuf
argument_list|)
argument_list|)
expr_stmt|;
define|#
directive|define
name|CMP_SET_FLAG_MAJ
parameter_list|(
name|S
parameter_list|,
name|F
parameter_list|)
define|\
value|else if (strncmp(tmpbuf, S, 3) == 0)		\ 			tmpflags |= __PMCDFMAJ(F)
define|#
directive|define
name|CMP_SET_FLAG_MIN
parameter_list|(
name|S
parameter_list|,
name|F
parameter_list|)
define|\
value|else if (strncmp(tmpbuf, S, 3) == 0)		\ 			tmpflags |= __PMCDFMIN(F)
if|if
condition|(
name|e
operator|-
name|p
operator|>
literal|6
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"level="
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|p
operator|+=
literal|6
expr_stmt|;
comment|/* skip over keyword */
name|level
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|q
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"mod"
argument_list|,
name|MOD
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"pmc"
argument_list|,
name|PMC
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"ctx"
argument_list|,
name|CTX
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"own"
argument_list|,
name|OWN
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"prc"
argument_list|,
name|PRC
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"mdp"
argument_list|,
name|MDP
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MAJ
argument_list|(
literal|"cpu"
argument_list|,
name|CPU
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"all"
argument_list|,
name|ALL
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"rel"
argument_list|,
name|REL
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"ops"
argument_list|,
name|OPS
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"ini"
argument_list|,
name|INI
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"fnd"
argument_list|,
name|FND
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"pmh"
argument_list|,
name|PMH
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"pms"
argument_list|,
name|PMS
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"orm"
argument_list|,
name|ORM
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"omr"
argument_list|,
name|OMR
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"tlk"
argument_list|,
name|TLK
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"tul"
argument_list|,
name|TUL
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"ext"
argument_list|,
name|EXT
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"exc"
argument_list|,
name|EXC
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"frk"
argument_list|,
name|FRK
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"att"
argument_list|,
name|ATT
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"swi"
argument_list|,
name|SWI
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"swo"
argument_list|,
name|SWO
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"reg"
argument_list|,
name|REG
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"alr"
argument_list|,
name|ALR
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"rea"
argument_list|,
name|REA
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"wri"
argument_list|,
name|WRI
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"cfg"
argument_list|,
name|CFG
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"sta"
argument_list|,
name|STA
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"sto"
argument_list|,
name|STO
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"bnd"
argument_list|,
name|BND
argument_list|)
expr_stmt|;
name|CMP_SET_FLAG_MIN
argument_list|(
literal|"sel"
argument_list|,
name|SEL
argument_list|)
expr_stmt|;
else|else
comment|/* unrecognized keyword */
return|return
name|EINVAL
return|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* skip keyword and separator */
block|}
name|pmc_debugflags
operator|=
operator|(
name|tmpflags
operator||
name|level
operator|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmc_debugflags_sysctl_handler
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|char
modifier|*
name|fence
decl_stmt|,
modifier|*
name|newstr
decl_stmt|;
name|int
name|error
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
operator|(
name|void
operator|)
name|arg1
expr_stmt|;
operator|(
name|void
operator|)
name|arg2
expr_stmt|;
comment|/* unused parameters */
name|n
operator|=
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|newstr
argument_list|,
name|char
operator|*
argument_list|,
name|n
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|newstr
argument_list|,
name|pmc_debugstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl_handle_string
argument_list|(
name|oidp
argument_list|,
name|newstr
argument_list|,
name|n
argument_list|,
name|req
argument_list|)
expr_stmt|;
comment|/* if there is a new string, parse and copy it */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|req
operator|->
name|newptr
operator|!=
name|NULL
condition|)
block|{
name|fence
operator|=
name|newstr
operator|+
operator|(
name|n
operator|<
name|req
operator|->
name|newlen
condition|?
name|n
else|:
name|req
operator|->
name|newlen
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_debugflags_parse
argument_list|(
name|newstr
argument_list|,
name|fence
argument_list|)
operator|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pmc_debugstr
argument_list|,
name|newstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|newstr
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Concurrency Control  *  * The driver manages the following data structures:  *  *   - target process descriptors, one per target process  *   - owner process descriptors (and attached lists), one per owner process  *   - lookup hash tables for owner and target processes  *   - PMC descriptors (and attached lists)  *   - per-cpu hardware state  *   - the 'hook' variable through which the kernel calls into  *     this module  *   - the machine hardware state (managed by the MD layer)  *  * These data structures are accessed from:  *  * - thread context-switch code  * - interrupt handlers (possibly on multiple cpus)  * - kernel threads on multiple cpus running on behalf of user  *   processes doing system calls  * - this driver's private kernel threads  *  * = Locks and Locking strategy =  *  * The driver uses four locking strategies for its operation:  *  * - There is a 'global' SX lock "pmc_sx" that is used to protect  *   the its 'meta-data'.  *  *   Calls into the module (via syscall() or by the kernel) start with  *   this lock being held in exclusive mode.  Depending on the requested  *   operation, the lock may be downgraded to 'shared' mode to allow  *   more concurrent readers into the module.  *  *   This SX lock is held in exclusive mode for any operations that  *   modify the linkages between the driver's internal data structures.  *  *   The 'pmc_hook' function pointer is also protected by this lock.  *   It is only examined with the sx lock held in exclusive mode.  The  *   kernel module is allowed to be unloaded only with the sx lock  *   held in exclusive mode.  In normal syscall handling, after  *   acquiring the pmc_sx lock we first check that 'pmc_hook' is  *   non-null before proceeding.  This prevents races between the  *   thread unloading the module and other threads seeking to use the  *   module.  *  * - Lookups of target process structures and owner process structures  *   cannot use the global "pmc_sx" SX lock because these lookups need  *   to happen during context switches and in other critical sections  *   where sleeping is not allowed.  We protect these lookup tables  *   with their own private spin-mutexes, "pmc_processhash_mtx" and  *   "pmc_ownerhash_mtx".  These are 'leaf' mutexes, in that no other  *   lock is acquired with these locks held.  *  * - Interrupt handlers work in a lock free manner.  At interrupt  *   time, handlers look at the PMC pointer (phw->phw_pmc) configured  *   when the PMC was started.  If this pointer is NULL, the interrupt  *   is ignored after updating driver statistics.  We ensure that this  *   pointer is set (using an atomic operation if necessary) before the  *   PMC hardware is started.  Conversely, this pointer is unset atomically  *   only after the PMC hardware is stopped.  *  *   We ensure that everything needed for the operation of an  *   interrupt handler is available without it needing to acquire any  *   locks.  We also ensure that a PMC's software state is destroyed only  *   after the PMC is taken off hardware (on all CPUs).  *  * - Context-switch handling with process-private PMCs needs more  *   care.  *  *   A given process may be the target of multiple PMCs.  For example,  *   PMCATTACH and PMCDETACH may be requested by a process on one CPU  *   while the target process is running on another.  A PMC could also  *   be getting released because its owner is exiting.  We tackle  *   these situations in the following manner:  *  *   - each target process structure 'pmc_process' has an array  *     of 'struct pmc *' pointers, one for each hardware PMC.  *  *   - At context switch IN time, each "target" PMC in RUNNING state  *     gets started on hardware and a pointer to each PMC is copied into  *     the per-cpu phw array.  The 'runcount' for the PMC is  *     incremented.  *  *   - At context switch OUT time, all process-virtual PMCs are stopped  *     on hardware.  The saved value is added to the PMCs value field  *     only if the PMC is in a non-deleted state (the PMCs state could  *     have changed during the current time slice).  *  *     Note that since in-between a switch IN on a processor and a switch  *     OUT, the PMC could have been released on another CPU.  Therefore  *     context switch OUT always looks at the hardware state to turn  *     OFF PMCs and will update a PMC's saved value only if reachable  *     from the target process record.  *  *   - OP PMCRELEASE could be called on a PMC at any time (the PMC could  *     be attached to many processes at the time of the call and could  *     be active on multiple CPUs).  *  *     We prevent further scheduling of the PMC by marking it as in  *     state 'DELETED'.  If the runcount of the PMC is non-zero then  *     this PMC is currently running on a CPU somewhere.  The thread  *     doing the PMCRELEASE operation waits by repeatedly doing an  *     tsleep() till the runcount comes to zero.  *  */
end_comment

begin_comment
comment|/*  * save the cpu binding of the current kthread  */
end_comment

begin_function
specifier|static
name|void
name|pmc_save_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"%s"
argument_list|,
literal|"save-cpu"
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|pb
operator|->
name|pb_bound
operator|=
name|sched_is_bound
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|pb
operator|->
name|pb_cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"save-cpu cpu=%d"
argument_list|,
name|pb
operator|->
name|pb_cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * restore the cpu binding of the current thread  */
end_comment

begin_function
specifier|static
name|void
name|pmc_restore_cpu_binding
parameter_list|(
name|struct
name|pmc_binding
modifier|*
name|pb
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"restore-cpu curcpu=%d restore=%d"
argument_list|,
name|curthread
operator|->
name|td_oncpu
argument_list|,
name|pb
operator|->
name|pb_cpu
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|pb_bound
condition|)
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|pb
operator|->
name|pb_cpu
argument_list|)
expr_stmt|;
else|else
name|sched_unbind
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|BND
argument_list|,
literal|2
argument_list|,
literal|"%s"
argument_list|,
literal|"restore-cpu done"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * move execution over the specified cpu and bind it there.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_select_cpu
parameter_list|(
name|int
name|cpu
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d] bad cpu number %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
comment|/* never move to a disabled CPU */
name|KASSERT
argument_list|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] selecting "
literal|"disabled CPU %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|SEL
argument_list|,
literal|2
argument_list|,
literal|"select-cpu cpu=%d"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|sched_bind
argument_list|(
name|curthread
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|curthread
operator|->
name|td_oncpu
operator|==
name|cpu
argument_list|,
operator|(
literal|"[pmc,%d] CPU not bound [cpu=%d, curr=%d]"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|curthread
operator|->
name|td_oncpu
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|CPU
argument_list|,
name|SEL
argument_list|,
literal|2
argument_list|,
literal|"select-cpu cpu=%d ok"
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the per-pmc histogram  */
end_comment

begin_function
name|void
name|pmc_update_histogram
parameter_list|(
name|struct
name|pmc_hw
modifier|*
name|phw
parameter_list|,
name|uintptr_t
name|pc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|phw
expr_stmt|;
operator|(
name|void
operator|)
name|pc
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a signal to a process.  This is meant to be invoked from an  * interrupt handler.  */
end_comment

begin_function
name|void
name|pmc_send_signal
parameter_list|(
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pmc
expr_stmt|;
comment|/* shutup gcc */
if|#
directive|if
literal|0
block|struct proc   *proc; 	struct thread *td;  	KASSERT(pmc->pm_owner != NULL, 	    ("[pmc,%d] No owner for PMC", __LINE__));  	KASSERT((pmc->pm_owner->po_flags& PMC_FLAG_IS_OWNER)&& 	    (pmc->pm_owner->po_flags& PMC_FLAG_HAS_TS_PMC), 	    ("[pmc,%d] interrupting PMC owner has wrong flags 0x%x", 		__LINE__, pmc->pm_owner->po_flags));  	proc = pmc->pm_owner->po_owner;  	KASSERT(curthread->td_proc == proc, 	    ("[pmc,%d] interruping the wrong thread (owner %p, " 		"cur %p)", __LINE__, (void *) proc, curthread->td_proc));  	mtx_lock_spin(&sched_lock); 	td = TAILQ_FIRST(&proc->p_threads); 	mtx_unlock_spin(&sched_lock);
comment|/* XXX RACE HERE: can 'td' disappear now? */
block|trapsignal(td, SIGPROF, 0);
comment|/* XXX rework this to use the regular 'psignal' interface from a 	   helper thread */
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * remove an process owning PMCs  */
end_comment

begin_function
name|void
name|pmc_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|struct
name|pmc_list
modifier|*
name|pl
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|ORM
argument_list|,
literal|1
argument_list|,
literal|"remove-owner po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
comment|/* Remove descriptor from the owner hash table */
name|LIST_REMOVE
argument_list|(
name|po
argument_list|,
name|po_next
argument_list|)
expr_stmt|;
comment|/* pass 1: release all owned PMC descriptors */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pl
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pl_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|ORM
argument_list|,
literal|2
argument_list|,
literal|"pl=%p pmc=%p"
argument_list|,
name|pl
argument_list|,
name|pl
operator|->
name|pl_pmc
argument_list|)
expr_stmt|;
comment|/* remove the associated PMC descriptor, if present */
if|if
condition|(
name|pl
operator|->
name|pl_pmc
condition|)
name|pmc_release_pmc_descriptor
argument_list|(
name|pl
operator|->
name|pl_pmc
argument_list|)
expr_stmt|;
comment|/* remove the linked list entry */
name|LIST_REMOVE
argument_list|(
name|pl
argument_list|,
name|pl_next
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pl
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
comment|/* pass 2: delete the pmc_list chain */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pl
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pl_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|KASSERT
argument_list|(
name|pl
operator|->
name|pl_pmc
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] non-null pmc pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pl
argument_list|,
name|pl_next
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pl
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] PMC list not empty"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this process owns a log file used for system wide logging, 	 * remove the log file. 	 * 	 * XXX rework needed. 	 */
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_FLAG_OWNS_LOGFILE
condition|)
name|pmc_configure_log
argument_list|(
name|po
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * remove an owner process record if all conditions are met.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_maybe_remove_owner
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|)
block|{
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|OMR
argument_list|,
literal|1
argument_list|,
literal|"maybe-remove-owner po=%p"
argument_list|,
name|po
argument_list|)
expr_stmt|;
comment|/* 	 * Remove owner record if 	 * - this process does not own any PMCs 	 * - this process has not allocated a system-wide sampling buffer 	 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|)
operator|&&
operator|(
operator|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_FLAG_OWNS_LOGFILE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|po
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Add an association between a target process and a PMC.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_link_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|pt
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
operator|&&
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] Null pm %p or pp %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|0
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
operator|-
literal|1
operator|)
argument_list|,
operator|(
literal|"[pmc,%d] Illegal reference count %d for process record %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
operator|(
name|void
operator|*
operator|)
name|pp
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|TLK
argument_list|,
literal|1
argument_list|,
literal|"link-target pmc=%p ri=%d pmc-process=%p"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|pp
argument_list|)
expr_stmt|;
if|#
directive|if
name|DEBUG
name|LIST_FOREACH
argument_list|(
argument|pt
argument_list|,
argument|&pm->pm_targets
argument_list|,
argument|pt_next
argument_list|)
if|if
condition|(
name|pt
operator|->
name|pt_process
operator|==
name|pp
condition|)
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] pp %p already in pmc %p targets"
operator|,
name|__LINE__
operator|,
name|pp
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|MALLOC
argument_list|(
name|pt
argument_list|,
expr|struct
name|pmc_target
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_target
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_process
operator|=
name|pp
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|,
name|pt
argument_list|,
name|pt_next
argument_list|)
expr_stmt|;
name|atomic_store_rel_ptr
argument_list|(
operator|&
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pp_refcnt
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Removes the association between a target process and a PMC.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_unlink_target_process
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|ptgt
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
operator|&&
name|pp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] Null pm %p or pp %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|1
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal ref count %d on process record %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
operator|(
name|void
operator|*
operator|)
name|pp
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|TUL
argument_list|,
literal|1
argument_list|,
literal|"unlink-target pmc=%p ri=%d pmc-process=%p"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[pmc,%d] PMC ri %d mismatch pmc %p pp->[ri] %p"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|pm
operator|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|=
name|NULL
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|=
operator|(
name|pmc_value_t
operator|)
literal|0
expr_stmt|;
name|pp
operator|->
name|pp_refcnt
operator|--
expr_stmt|;
comment|/* Remove the target process from the PMC structure */
name|LIST_FOREACH
argument_list|(
argument|ptgt
argument_list|,
argument|&pm->pm_targets
argument_list|,
argument|pt_next
argument_list|)
if|if
condition|(
name|ptgt
operator|->
name|pt_process
operator|==
name|pp
condition|)
break|break;
name|KASSERT
argument_list|(
name|ptgt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] process %p (pp: %p) not found "
literal|"in pmc %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_proc
operator|,
name|pp
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|TUL
argument_list|,
literal|4
argument_list|,
literal|"unlink ptgt=%p"
argument_list|,
name|ptgt
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ptgt
argument_list|,
name|pt_next
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ptgt
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove PMC descriptor 'pmc' from the owner descriptor.  */
end_comment

begin_function
name|void
name|pmc_unlink_owner
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|pmc_list
modifier|*
name|pl
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] unlinking PMC with targets"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] No owner for PMC"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH_SAFE
argument_list|(
argument|pl
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pl_next
argument_list|,
argument|tmp
argument_list|)
block|{
if|if
condition|(
name|pl
operator|->
name|pl_pmc
operator|==
name|pm
condition|)
block|{
name|pl
operator|->
name|pl_pmc
operator|=
name|NULL
expr_stmt|;
name|pm
operator|->
name|pm_owner
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] couldn't find pmc in owner list"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if PMC 'pm' may be attached to target process 't'.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_can_attach
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|proc
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|o
decl_stmt|;
comment|/* pmc owner */
name|struct
name|ucred
modifier|*
name|oc
decl_stmt|,
modifier|*
name|tc
decl_stmt|;
comment|/* owner, target credentials */
name|int
name|decline_attach
decl_stmt|,
name|i
decl_stmt|;
comment|/* 	 * A PMC's owner can always attach that PMC to itself. 	 */
if|if
condition|(
operator|(
name|o
operator|=
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
operator|)
operator|==
name|t
condition|)
return|return
literal|0
return|;
name|PROC_LOCK
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|oc
operator|=
name|o
operator|->
name|p_ucred
expr_stmt|;
name|crhold
argument_list|(
name|oc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|tc
operator|=
name|t
operator|->
name|p_ucred
expr_stmt|;
name|crhold
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|t
argument_list|)
expr_stmt|;
comment|/* 	 * The effective uid of the PMC owner should match at least one 	 * of the {effective,real,saved} uids of the target process. 	 */
name|decline_attach
operator|=
name|oc
operator|->
name|cr_uid
operator|!=
name|tc
operator|->
name|cr_uid
operator|&&
name|oc
operator|->
name|cr_uid
operator|!=
name|tc
operator|->
name|cr_svuid
operator|&&
name|oc
operator|->
name|cr_uid
operator|!=
name|tc
operator|->
name|cr_ruid
expr_stmt|;
comment|/* 	 * Every one of the target's group ids, must be in the owner's 	 * group list. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
name|decline_attach
operator|&&
name|i
operator|<
name|tc
operator|->
name|cr_ngroups
condition|;
name|i
operator|++
control|)
name|decline_attach
operator|=
operator|!
name|groupmember
argument_list|(
name|tc
operator|->
name|cr_groups
index|[
name|i
index|]
argument_list|,
name|oc
argument_list|)
expr_stmt|;
comment|/* check the read and saved gids too */
if|if
condition|(
name|decline_attach
operator|==
literal|0
condition|)
name|decline_attach
operator|=
operator|!
name|groupmember
argument_list|(
name|tc
operator|->
name|cr_rgid
argument_list|,
name|oc
argument_list|)
operator|||
operator|!
name|groupmember
argument_list|(
name|tc
operator|->
name|cr_svgid
argument_list|,
name|oc
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|tc
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|oc
argument_list|)
expr_stmt|;
return|return
operator|!
name|decline_attach
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a process to a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_attach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|2
argument_list|,
literal|"attach-one pm=%p ri=%d proc=%p (%d, %s)"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
comment|/* 	 * Locate the process descriptor corresponding to process 'p', 	 * allocating space as needed. 	 * 	 * Verify that rowindex 'pm_rowindex' is free in the process 	 * descriptor. 	 * 	 * If not, allocate space for a descriptor and link the 	 * process descriptor and PMC. 	 */
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_ALLOCATE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|==
name|pm
condition|)
comment|/* already present at slot [ri] */
return|return
name|EEXIST
return|;
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|!=
name|NULL
condition|)
return|return
name|EBUSY
return|;
name|pmc_link_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* mark process as using HWPMCs */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a process and optionally its children  */
end_comment

begin_function
specifier|static
name|int
name|pmc_attach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|proc
modifier|*
name|top
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|1
argument_list|,
literal|"attach pm=%p ri=%d proc=%p (%d, %s)"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
operator|)
operator|==
literal|0
condition|)
return|return
name|pmc_attach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
return|;
comment|/* 	 * Traverse all child processes, attaching them to 	 * this PMC. 	 */
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|top
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_attach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
condition|)
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|top
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
condition|)
block|{
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
operator|(
name|void
operator|)
name|pmc_detach_process
argument_list|(
name|top
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|done
label|:
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a process from a PMC.  If there are no other PMCs tracking  * this process, remove the process structure from its hash table.  If  * 'flags' contains PMC_FLAG_REMOVE, then free the process structure.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_detach_one_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null pm pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|2
argument_list|,
literal|"detach-one pm=%p ri=%d proc=%p (%d, %s) flags=0x%x"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|!=
name|pm
condition|)
return|return
name|EINVAL
return|;
name|pmc_unlink_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* 	 * If there are no PMCs targetting this process, we remove its 	 * descriptor from the target hash table and unset the P_HWPMC 	 * flag in the struct proc. 	 */
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|0
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal refcnt %d for process struct %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|pp_refcnt
operator|!=
literal|0
condition|)
comment|/* still a target of some PMC */
return|return
literal|0
return|;
name|pmc_remove_process_descriptor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|PMC_FLAG_REMOVE
condition|)
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator|&=
operator|~
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a process and optionally its descendants from a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_detach_process
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|top
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|ATT
argument_list|,
literal|1
argument_list|,
literal|"detach pm=%p ri=%d proc=%p (%d, %s)"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
operator|)
operator|==
literal|0
condition|)
return|return
name|pmc_detach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|,
name|PMC_FLAG_REMOVE
argument_list|)
return|;
comment|/* 	 * Traverse all children, detaching them from this PMC.  We 	 * ignore errors since we could be detaching a PMC from a 	 * partially attached proc tree. 	 */
name|sx_slock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
name|top
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|(
name|void
operator|)
name|pmc_detach_one_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|,
name|PMC_FLAG_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|LIST_EMPTY
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
condition|)
name|p
operator|=
name|LIST_FIRST
argument_list|(
operator|&
name|p
operator|->
name|p_children
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|top
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
condition|)
block|{
name|p
operator|=
name|LIST_NEXT
argument_list|(
name|p
argument_list|,
name|p_sibling
argument_list|)
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|p
operator|->
name|p_pptr
expr_stmt|;
block|}
block|}
name|done
label|:
name|sx_sunlock
argument_list|(
operator|&
name|proctree_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The 'hook' invoked from the kernel proper  */
end_comment

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_decl_stmt
specifier|const
name|char
modifier|*
name|pmc_hooknames
index|[]
init|=
block|{
literal|""
block|,
literal|"EXIT"
block|,
literal|"EXEC"
block|,
literal|"FORK"
block|,
literal|"CSW-IN"
block|,
literal|"CSW-OUT"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|pmc_hook_handler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|int
name|function
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|td
operator|->
name|td_proc
operator|->
name|p_flag
operator|&
name|P_HWPMC
argument_list|,
operator|(
literal|"[pmc,%d] unregistered thread called pmc_hook()"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|PMH
argument_list|,
literal|1
argument_list|,
literal|"hook td=%p func=%d \"%s\" arg=%p"
argument_list|,
name|td
argument_list|,
name|function
argument_list|,
name|pmc_hooknames
index|[
name|function
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|function
condition|)
block|{
comment|/* 	 * Process exit. 	 * 	 * Remove this process from all hash tables.  If this process 	 * owned any PMCs, turn off those PMCs and deallocate them, 	 * removing any associations with target processes. 	 * 	 * This function will be called by the last 'thread' of a 	 * process. 	 * 	 */
case|case
name|PMC_FN_PROCESS_EXIT
case|:
comment|/* release PMCs */
block|{
name|int
name|cpu
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|pmc_value_t
name|newvalue
decl_stmt|,
name|tmp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
comment|/* 		 * Since this code is invoked by the last thread in an 		 * exiting process, we would have context switched IN 		 * at some prior point.  Kernel mode context switches 		 * may happen any time, so we want to disable a context 		 * switch OUT till we get any PMCs targetting this 		 * process off the hardware. 		 * 		 * We also need to atomically remove this process' 		 * entry from our target process hash table, using 		 * PMC_FLAG_REMOVE. 		 */
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|1
argument_list|,
literal|"process-exit proc=%p (%d, %s)"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* no preemption */
name|cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_REMOVE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|2
argument_list|,
literal|"process-exit proc=%p pmc-process=%p"
argument_list|,
name|p
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* 			 * This process could the target of some PMCs. 			 * Such PMCs will thus be running on currently 			 * executing CPU at this point in the code 			 * since we've disallowed context switches. 			 * We need to turn these PMCs off like we 			 * would do at context switch OUT time. 			 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
block|{
comment|/* 				 * Pick up the pmc pointer from hardware 				 * state similar to the CSW_OUT code. 				 */
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|2
argument_list|,
literal|"ri=%d pm=%p"
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
operator|||
operator|!
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
continue|continue;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|2
argument_list|,
literal|"ppmcs[%d]=%p pm=%p "
literal|"state=%d"
argument_list|,
name|ri
argument_list|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_state
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_rowindex
operator|==
name|ri
argument_list|,
operator|(
literal|"[pmc,%d] ri mismatch pmc(%d) ri(%d)"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_rowindex
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|==
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
operator|(
literal|"[pmc,%d] pm %p != pp_pmcs[%d] %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|ri
operator|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_runcount
operator|>
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] bad runcount ri %d rc %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|pm
operator|->
name|pm_runcount
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|md
operator|->
name|pmd_read_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|newvalue
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|newvalue
operator|-
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
operator|+=
name|tmp
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|+=
name|tmp
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
operator|(
name|int
operator|)
name|pm
operator|->
name|pm_runcount
operator|>=
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] runcount is %d"
operator|,
name|__LINE__
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
name|atomic_subtract_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* ok to be pre-empted now */
comment|/* 			 * Unlink this process from the PMCs that are 			 * targetting it.  Log value at exit() time if 			 * requested. 			 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_LOG_TC_PROCEXIT
condition|)
name|pmc_log_process_exit
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|pmc_unlink_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
else|else
name|critical_exit
argument_list|()
expr_stmt|;
comment|/* pp == NULL */
comment|/* 		 * If the process owned PMCs, free them up and free up 		 * memory. 		 */
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|po
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Process exec() 	 */
case|case
name|PMC_FN_PROCESS_EXEC
case|:
block|{
name|int
modifier|*
name|credentials_changed
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
comment|/* 		 * PMCs are not inherited across an exec():  remove any 		 * PMCs that this process is the owner of. 		 */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|po
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If this process is the target of a PMC, check if the new 		 * credentials are compatible with the owner's permissions. 		 */
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|credentials_changed
operator|=
name|arg
expr_stmt|;
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXC
argument_list|,
literal|1
argument_list|,
literal|"exec proc=%p (%d, %s) cred-changed=%d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
operator|*
name|credentials_changed
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|credentials_changed
operator|==
literal|0
condition|)
comment|/* credentials didn't change */
break|break;
comment|/* 		 * If the newly exec()'ed process has a different credential 		 * than before, allow it to be the target of a PMC only if 		 * the PMC's owner has sufficient priviledge. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pmc_can_attach
argument_list|(
name|pm
argument_list|,
name|td
operator|->
name|td_proc
argument_list|)
operator|!=
literal|0
condition|)
name|pmc_detach_one_process
argument_list|(
name|td
operator|->
name|td_proc
argument_list|,
name|pm
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>=
literal|0
operator|&&
name|pp
operator|->
name|pp_refcnt
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal ref count %d on pp %p"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|,
name|pp
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * If this process is no longer the target of any 		 * PMCs, we can remove the process entry and free 		 * up space. 		 */
if|if
condition|(
name|pp
operator|->
name|pp_refcnt
operator|==
literal|0
condition|)
block|{
name|pmc_remove_process_descriptor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Process fork() 	 */
case|case
name|PMC_FN_PROCESS_FORK
case|:
block|{
name|unsigned
name|int
name|ri
decl_stmt|;
name|uint32_t
name|do_descendants
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|ppnew
decl_stmt|,
modifier|*
name|ppold
decl_stmt|;
name|struct
name|proc
modifier|*
name|newproc
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|newproc
operator|=
operator|(
expr|struct
name|proc
operator|*
operator|)
name|arg
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FRK
argument_list|,
literal|2
argument_list|,
literal|"process-fork p1=%p p2=%p"
argument_list|,
name|curthread
operator|->
name|td_proc
argument_list|,
name|newproc
argument_list|)
expr_stmt|;
comment|/* 		 * If the parent process (curthread->td_proc) is a 		 * target of any PMCs, look for PMCs that are to be 		 * inherited, and link these into the new process 		 * descriptor. 		 */
if|if
condition|(
operator|(
name|ppold
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|do_descendants
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|ppold
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
condition|)
name|do_descendants
operator||=
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
expr_stmt|;
if|if
condition|(
name|do_descendants
operator|==
literal|0
condition|)
comment|/* nothing to do */
break|break;
if|if
condition|(
operator|(
name|ppnew
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|newproc
argument_list|,
name|PMC_FLAG_ALLOCATE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
comment|/* 		 * Run through all PMCs targeting the old process and 		 * attach them to the new process. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
if|if
condition|(
operator|(
name|pm
operator|=
name|ppold
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|!=
name|NULL
operator|&&
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_DESCENDANTS
condition|)
name|pmc_link_target_process
argument_list|(
name|pm
argument_list|,
name|ppnew
argument_list|)
expr_stmt|;
comment|/* 		 * Now mark the new process as being tracked by this 		 * driver. 		 */
name|PROC_LOCK
argument_list|(
name|newproc
argument_list|)
expr_stmt|;
name|newproc
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|newproc
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Thread context switch IN 	 */
case|case
name|PMC_FN_CSW_IN
case|:
block|{
name|int
name|cpu
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|pmc_value_t
name|newvalue
decl_stmt|;
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_proc
operator|==
name|td
operator|->
name|td_proc
argument_list|,
operator|(
literal|"[pmc,%d] not my thread state"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
comment|/* no preemption on this CPU */
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* td->td_oncpu is invalid */
name|PMCDBG
argument_list|(
name|CTX
argument_list|,
name|SWI
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d proc=%p (%d, %s) pp=%p"
argument_list|,
name|cpu
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d] wierd CPU id %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pm
operator|=
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] Target PMC in non-virtual mode (%d)"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_mode
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_rowindex
operator|==
name|ri
argument_list|,
operator|(
literal|"[pmc,%d] Row index mismatch pmc %d != ri %d"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_rowindex
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Only PMCs that are marked as 'RUNNING' need 			 * be placed on hardware. 			 */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
continue|continue;
comment|/* increment PMC runcount */
name|atomic_add_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* configure the HWPMC we are going to use. */
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null hw pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[pmc,%d] hw->pmc %p != pmc %p"
operator|,
name|__LINE__
operator|,
name|phw
operator|->
name|phw_pmc
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
comment|/* write out saved value and start the PMC */
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|newvalue
operator|=
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|md
operator|->
name|pmd_write_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|newvalue
argument_list|)
expr_stmt|;
name|md
operator|->
name|pmd_start_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * perform any other architecture/cpu dependent thread 		 * switch-in actions. 		 */
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_switch_in
argument_list|)
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
break|break;
comment|/* 	 * Thread context switch OUT. 	 */
case|case
name|PMC_FN_CSW_OUT
case|:
block|{
name|int
name|cpu
decl_stmt|;
name|unsigned
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|pmc_value_t
name|newvalue
decl_stmt|,
name|tmp
decl_stmt|;
comment|/* 		 * Locate our process descriptor; this may be NULL if 		 * this process is exiting and we have already removed 		 * the process from the target process table. 		 * 		 * Note that due to kernel preemption, multiple 		 * context switches may happen while the process is 		 * exiting. 		 * 		 * Note also that if the target process cannot be 		 * found we still need to deconfigure any PMCs that 		 * are currently running on hardware. 		 */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
name|PMC_FLAG_NONE
argument_list|)
expr_stmt|;
comment|/* 		 * save PMCs 		 */
name|critical_enter
argument_list|()
expr_stmt|;
name|cpu
operator|=
name|PCPU_GET
argument_list|(
name|cpuid
argument_list|)
expr_stmt|;
comment|/* td->td_oncpu is invalid */
name|PMCDBG
argument_list|(
name|CTX
argument_list|,
name|SWO
argument_list|,
literal|1
argument_list|,
literal|"cpu=%d proc=%p (%d, %s) pp=%p"
argument_list|,
name|cpu
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|cpu
operator|>=
literal|0
operator|&&
name|cpu
operator|<
name|mp_ncpus
argument_list|,
operator|(
literal|"[pmc,%d wierd CPU id %d"
operator|,
name|__LINE__
operator|,
name|cpu
operator|)
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
comment|/* 		 * When a PMC gets unlinked from a target PMC, it will 		 * be removed from the target's pp_pmc[] array. 		 * 		 * However, on a MP system, the target could have been 		 * executing on another CPU at the time of the unlink. 		 * So, at context switch OUT time, we need to look at 		 * the hardware to determine if a PMC is scheduled on 		 * it. 		 */
for|for
control|(
name|ri
operator|=
literal|0
init|;
name|ri
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|ri
operator|++
control|)
block|{
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|pm
operator|=
name|phw
operator|->
name|phw_pmc
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
comment|/* nothing at this row index */
continue|continue;
if|if
condition|(
operator|!
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
continue|continue;
comment|/* not a process virtual PMC */
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_rowindex
operator|==
name|ri
argument_list|,
operator|(
literal|"[pmc,%d] ri mismatch pmc(%d) ri(%d)"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_rowindex
operator|,
name|ri
operator|)
argument_list|)
expr_stmt|;
comment|/* Stop hardware */
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
comment|/* reduce this PMC's runcount */
name|atomic_subtract_rel_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 			 * If this PMC is associated with this process, 			 * save the reading. 			 */
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|==
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
argument_list|,
operator|(
literal|"[pmc,%d] pm %p != pp_pmcs[%d] %p"
operator|,
name|__LINE__
operator|,
name|pm
operator|,
name|ri
operator|,
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|>
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] pp refcnt = %d"
operator|,
name|__LINE__
operator|,
name|pp
operator|->
name|pp_refcnt
operator|)
argument_list|)
expr_stmt|;
name|md
operator|->
name|pmd_read_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|newvalue
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|newvalue
operator|-
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|int64_t
operator|)
name|tmp
operator|>=
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] negative increment cpu=%d "
literal|"ri=%d newvalue=%jx saved=%jx "
literal|"incr=%jx"
operator|,
name|__LINE__
operator|,
name|cpu
operator|,
name|ri
operator|,
name|newvalue
operator|,
name|PMC_PCPU_SAVED
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
operator|,
name|tmp
operator|)
argument_list|)
expr_stmt|;
comment|/* 				 * Increment the PMC's count and this 				 * target process's count by the difference 				 * between the current reading and the 				 * saved value at context switch in time. 				 */
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
operator|+=
name|tmp
expr_stmt|;
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmcval
operator|+=
name|tmp
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
comment|/* mark hardware as free */
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * perform any other architecture/cpu dependent thread 		 * switch out functions. 		 */
call|(
name|void
call|)
argument_list|(
operator|*
name|md
operator|->
name|pmd_switch_out
argument_list|)
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] unknown hook %d\n"
operator|,
name|__LINE__
operator|,
name|function
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * allocate a 'struct pmc_owner' descriptor in the owner hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_allocate_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|hindex
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_ownerhash
modifier|*
name|poh
decl_stmt|;
name|hindex
operator|=
name|PMC_HASH_PTR
argument_list|(
name|p
argument_list|,
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|poh
operator|=
operator|&
name|pmc_ownerhash
index|[
name|hindex
index|]
expr_stmt|;
comment|/* allocate space for N pointers and one descriptor struct */
name|MALLOC
argument_list|(
name|po
argument_list|,
expr|struct
name|pmc_owner
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_owner
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|po
operator|->
name|po_flags
operator|=
literal|0
expr_stmt|;
name|po
operator|->
name|po_owner
operator|=
name|p
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|poh
argument_list|,
name|po
argument_list|,
name|po_next
argument_list|)
expr_stmt|;
comment|/* insert into hash table */
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"allocate-owner proc=%p (%d, %s) pmc-owner=%p"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|po
argument_list|)
expr_stmt|;
return|return
name|po
return|;
block|}
end_function

begin_comment
comment|/*  * find the descriptor corresponding to process 'p', adding or removing it  * as specified by 'mode'.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc_process
modifier|*
name|pmc_find_process_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|uint32_t
name|mode
parameter_list|)
block|{
name|uint32_t
name|hindex
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|ppnew
decl_stmt|;
name|struct
name|pmc_processhash
modifier|*
name|pph
decl_stmt|;
name|hindex
operator|=
name|PMC_HASH_PTR
argument_list|(
name|p
argument_list|,
name|pmc_processhashmask
argument_list|)
expr_stmt|;
name|pph
operator|=
operator|&
name|pmc_processhash
index|[
name|hindex
index|]
expr_stmt|;
name|ppnew
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Pre-allocate memory in the FIND_ALLOCATE case since we 	 * cannot call malloc(9) once we hold a spin lock. 	 */
if|if
condition|(
name|mode
operator|&
name|PMC_FLAG_ALLOCATE
condition|)
block|{
comment|/* allocate additional space for 'n' pmc pointers */
name|MALLOC
argument_list|(
name|ppnew
argument_list|,
expr|struct
name|pmc_process
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_process
argument_list|)
operator|+
name|md
operator|->
name|pmd_npmc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_targetstate
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|pph
argument_list|,
argument|pp_next
argument_list|)
if|if
condition|(
name|pp
operator|->
name|pp_proc
operator|==
name|p
condition|)
break|break;
if|if
condition|(
operator|(
name|mode
operator|&
name|PMC_FLAG_REMOVE
operator|)
operator|&&
name|pp
operator|!=
name|NULL
condition|)
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|&
name|PMC_FLAG_ALLOCATE
operator|)
operator|&&
name|pp
operator|==
name|NULL
operator|&&
name|ppnew
operator|!=
name|NULL
condition|)
block|{
name|ppnew
operator|->
name|pp_proc
operator|=
name|p
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|pph
argument_list|,
name|ppnew
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
name|pp
operator|=
name|ppnew
expr_stmt|;
name|ppnew
operator|=
name|NULL
expr_stmt|;
block|}
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|ppnew
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ppnew
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|pp
return|;
block|}
end_function

begin_comment
comment|/*  * remove a process descriptor from the process hash table.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_remove_process_descriptor
parameter_list|(
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pp
operator|->
name|pp_refcnt
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] Removing process descriptor %p with count %d"
operator|,
name|__LINE__
operator|,
name|pp
operator|,
name|pp
operator|->
name|pp_refcnt
operator|)
argument_list|)
expr_stmt|;
name|mtx_lock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * find an owner descriptor corresponding to proc 'p'  */
end_comment

begin_function
specifier|static
name|struct
name|pmc_owner
modifier|*
name|pmc_find_owner_descriptor
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|uint32_t
name|hindex
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_ownerhash
modifier|*
name|poh
decl_stmt|;
name|hindex
operator|=
name|PMC_HASH_PTR
argument_list|(
name|p
argument_list|,
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|poh
operator|=
operator|&
name|pmc_ownerhash
index|[
name|hindex
index|]
expr_stmt|;
name|po
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|po
argument_list|,
argument|poh
argument_list|,
argument|po_next
argument_list|)
if|if
condition|(
name|po
operator|->
name|po_owner
operator|==
name|p
condition|)
break|break;
name|PMCDBG
argument_list|(
name|OWN
argument_list|,
name|FND
argument_list|,
literal|1
argument_list|,
literal|"find-owner proc=%p (%d, %s) hindex=0x%x -> "
literal|"pmc-owner=%p"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|hindex
argument_list|,
name|po
argument_list|)
expr_stmt|;
return|return
name|po
return|;
block|}
end_function

begin_comment
comment|/*  * pmc_allocate_pmc_descriptor  *  * Allocate a pmc descriptor and initialize its  * fields.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_allocate_pmc_descriptor
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pmc
decl_stmt|;
name|MALLOC
argument_list|(
name|pmc
argument_list|,
expr|struct
name|pmc
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_ZERO
operator||
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc
operator|!=
name|NULL
condition|)
block|{
name|pmc
operator|->
name|pm_owner
operator|=
name|NULL
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|pmc
operator|->
name|pm_targets
argument_list|)
expr_stmt|;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALL
argument_list|,
literal|1
argument_list|,
literal|"allocate-pmc -> pmc=%p"
argument_list|,
name|pmc
argument_list|)
expr_stmt|;
return|return
name|pmc
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a pmc descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_destroy_pmc_descriptor
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pm
expr_stmt|;
if|#
directive|if
name|DEBUG
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_DELETED
operator|||
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_FREE
argument_list|,
operator|(
literal|"[pmc,%d] destroying non-deleted PMC"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
argument_list|,
operator|(
literal|"[pmc,%d] destroying pmc with targets"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_owner
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] destroying pmc attached to an owner"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_runcount
operator|==
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] pmc has non-zero run count %d"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_runcount
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This function does the following things:  *  *  - detaches the PMC from hardware  *  - unlinks all target threads that were attached to it  *  - removes the PMC from its owner's list  *  - destroy's the PMC private mutex  *  * Once this function completes, the given pmc pointer can be safely  * FREE'd by the caller.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_release_pmc_descriptor
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
if|#
directive|if
name|DEBUG
specifier|volatile
name|int
name|maxloop
decl_stmt|;
endif|#
directive|endif
name|u_int
name|ri
decl_stmt|,
name|cpu
decl_stmt|;
name|u_char
name|curpri
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|struct
name|pmc_target
modifier|*
name|ptgt
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pm
argument_list|,
operator|(
literal|"[pmc,%d] null pmc"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|1
argument_list|,
literal|"release-pmc pmc=%p ri=%d mode=%d"
argument_list|,
name|pm
argument_list|,
name|ri
argument_list|,
name|pm
operator|->
name|pm_mode
argument_list|)
expr_stmt|;
comment|/* 	 * First, we take the PMC off hardware. 	 */
name|cpu
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
block|{
comment|/* 		 * A system mode PMC runs on a specific CPU.  Switch 		 * to this CPU and turn hardware off. 		 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|phw
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|phw
operator|->
name|phw_pmc
operator|==
name|pm
argument_list|,
operator|(
literal|"[pmc, %d] pmc ptr ri(%d) hw(%p) pm(%p)"
operator|,
name|__LINE__
operator|,
name|ri
operator|,
name|phw
operator|->
name|phw_pmc
operator|,
name|pm
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|2
argument_list|,
literal|"stopping cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|2
argument_list|,
literal|"decfg cpu=%d ri=%d"
argument_list|,
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|critical_enter
argument_list|()
expr_stmt|;
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|critical_exit
argument_list|()
expr_stmt|;
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_DELETED
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
block|{
comment|/* 		 * A virtual PMC could be running on multiple CPUs at 		 * a given instant. 		 * 		 * By marking its state as DELETED, we ensure that 		 * this PMC is never further scheduled on hardware. 		 * 		 * Then we wait till all CPUs are done with this PMC. 		 */
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_DELETED
expr_stmt|;
comment|/* 		 * Wait for the PMCs runcount to come to zero. 		 */
if|#
directive|if
name|DEBUG
name|maxloop
operator|=
literal|100
operator|*
name|mp_ncpus
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|atomic_load_acq_32
argument_list|(
operator|&
name|pm
operator|->
name|pm_runcount
argument_list|)
operator|>
literal|0
condition|)
block|{
if|#
directive|if
name|DEBUG
name|maxloop
operator|--
expr_stmt|;
name|KASSERT
argument_list|(
name|maxloop
operator|>
literal|0
argument_list|,
operator|(
literal|"[pmc,%d] (ri%d, rc%d) waiting too long for "
literal|"pmc to be free"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_rowindex
operator|,
name|pm
operator|->
name|pm_runcount
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mtx_lock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
name|curpri
operator|=
name|curthread
operator|->
name|td_priority
expr_stmt|;
name|mtx_unlock_spin
argument_list|(
operator|&
name|sched_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tsleep
argument_list|(
operator|(
name|void
operator|*
operator|)
name|pmc_release_pmc_descriptor
argument_list|,
name|curpri
argument_list|,
literal|"pmcrel"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * At this point the PMC is off all CPUs and cannot be 		 * freshly scheduled onto a CPU.  It is now safe to 		 * unlink all targets from this PMC.  If a 		 * process-record's refcount falls to zero, we remove 		 * it from the hash table.  The module-wide SX lock 		 * protects us from races. 		 */
name|LIST_FOREACH_SAFE
argument_list|(
argument|ptgt
argument_list|,
argument|&pm->pm_targets
argument_list|,
argument|pt_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|pp
operator|=
name|ptgt
operator|->
name|pt_process
expr_stmt|;
name|pmc_unlink_target_process
argument_list|(
name|pm
argument_list|,
name|pp
argument_list|)
expr_stmt|;
comment|/* frees 'ptgt' */
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REL
argument_list|,
literal|3
argument_list|,
literal|"pp->refcnt=%d"
argument_list|,
name|pp
operator|->
name|pp_refcnt
argument_list|)
expr_stmt|;
comment|/* 			 * If the target process record shows that no 			 * PMCs are attached to it, reclaim its space. 			 */
if|if
condition|(
name|pp
operator|->
name|pp_refcnt
operator|==
literal|0
condition|)
block|{
name|pmc_remove_process_descriptor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
name|cpu
operator|=
name|curthread
operator|->
name|td_oncpu
expr_stmt|;
comment|/* setup cpu for pmd_release() */
block|}
comment|/* 	 * Release any MD resources 	 */
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_release_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|pm
argument_list|)
expr_stmt|;
comment|/* 	 * Update row disposition 	 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
name|PMC_UNMARK_ROW_STANDALONE
argument_list|(
name|ri
argument_list|)
expr_stmt|;
else|else
name|PMC_UNMARK_ROW_THREAD
argument_list|(
name|ri
argument_list|)
expr_stmt|;
comment|/* unlink from the owner's list */
if|if
condition|(
name|pm
operator|->
name|pm_owner
condition|)
name|pmc_unlink_owner
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pmc_destroy_pmc_descriptor
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Register an owner and a pmc.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_register_owner
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|struct
name|pmc
modifier|*
name|pmc
parameter_list|)
block|{
name|struct
name|pmc_list
modifier|*
name|pl
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|pl
argument_list|,
expr|struct
name|pmc_list
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_list
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pl
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_allocate_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|pl
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|po
operator|->
name|po_flags
operator||=
name|PMC_FLAG_IS_OWNER
expr_stmt|;
comment|/* real owner */
block|}
if|if
condition|(
name|pmc
operator|->
name|pm_mode
operator|==
name|PMC_MODE_TS
condition|)
block|{
comment|/* can have only one TS mode PMC per process */
if|if
condition|(
name|po
operator|->
name|po_flags
operator|&
name|PMC_FLAG_HAS_TS_PMC
condition|)
block|{
name|FREE
argument_list|(
name|pl
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|po
operator|->
name|po_flags
operator||=
name|PMC_FLAG_HAS_TS_PMC
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|pmc
operator|->
name|pm_owner
operator|==
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] attempting to own an initialized PMC"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|pmc
operator|->
name|pm_owner
operator|=
name|po
expr_stmt|;
name|pl
operator|->
name|pl_pmc
operator|=
name|pmc
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|po
operator|->
name|po_pmcs
argument_list|,
name|pl
argument_list|,
name|pl_next
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|REG
argument_list|,
literal|1
argument_list|,
literal|"register-owner pmc-owner=%p pl=%p pmc=%p"
argument_list|,
name|po
argument_list|,
name|pl
argument_list|,
name|pmc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current row disposition:  * == 0 => FREE  *> 0 => PROCESS MODE  *< 0 => SYSTEM MODE  */
end_comment

begin_function
name|int
name|pmc_getrowdisp
parameter_list|(
name|int
name|ri
parameter_list|)
block|{
return|return
name|pmc_pmcdisp
index|[
name|ri
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a PMC at row index 'ri' can be allocated to the current  * process.  *  * Allocation can fail if:  *   - the current process is already being profiled by a PMC at index 'ri',  *     attached to it via OP_PMCATTACH.  *   - the current process has already allocated a PMC at index 'ri'  *     via OP_ALLOCATE.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_can_allocate_rowindex
parameter_list|(
name|struct
name|proc
modifier|*
name|p
parameter_list|,
name|unsigned
name|int
name|ri
parameter_list|)
block|{
name|struct
name|pmc_list
modifier|*
name|pl
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|1
argument_list|,
literal|"can-allocate-rowindex proc=%p (%d, %s) ri=%d"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|ri
argument_list|)
expr_stmt|;
comment|/* we shouldn't have allocated a PMC at row index 'ri' */
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|LIST_FOREACH
argument_list|(
argument|pl
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pl_next
argument_list|)
if|if
condition|(
name|pl
operator|->
name|pl_pmc
operator|->
name|pm_rowindex
operator|==
name|ri
condition|)
return|return
name|EEXIST
return|;
comment|/* we shouldn't be the target of any PMC ourselves at this index */
if|if
condition|(
operator|(
name|pp
operator|=
name|pmc_find_process_descriptor
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|pp
operator|->
name|pp_pmcs
index|[
name|ri
index|]
operator|.
name|pp_pmc
condition|)
return|return
name|EEXIST
return|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|2
argument_list|,
literal|"can-allocate-rowindex proc=%p (%d, %s) ri=%d ok"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|ri
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a given PMC at row index 'ri' can be currently used in  * mode 'mode'.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_can_allocate_row
parameter_list|(
name|int
name|ri
parameter_list|,
name|enum
name|pmc_mode
name|mode
parameter_list|)
block|{
name|enum
name|pmc_disp
name|disp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|1
argument_list|,
literal|"can-allocate-row ri=%d mode=%d"
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|disp
operator|=
name|PMC_DISP_STANDALONE
expr_stmt|;
else|else
name|disp
operator|=
name|PMC_DISP_THREAD
expr_stmt|;
comment|/* 	 * check disposition for PMC row 'ri': 	 * 	 * Expected disposition		Row-disposition		Result 	 * 	 * STANDALONE			STANDALONE or FREE	proceed 	 * STANDALONE			THREAD			fail 	 * THREAD			THREAD or FREE		proceed 	 * THREAD			STANDALONE		fail 	 */
if|if
condition|(
operator|!
name|PMC_ROW_DISP_IS_FREE
argument_list|(
name|ri
argument_list|)
operator|&&
operator|!
operator|(
name|disp
operator|==
name|PMC_DISP_THREAD
operator|&&
name|PMC_ROW_DISP_IS_THREAD
argument_list|(
name|ri
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|disp
operator|==
name|PMC_DISP_STANDALONE
operator|&&
name|PMC_ROW_DISP_IS_STANDALONE
argument_list|(
name|ri
argument_list|)
operator|)
condition|)
return|return
name|EBUSY
return|;
comment|/* 	 * All OK 	 */
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALR
argument_list|,
literal|2
argument_list|,
literal|"can-allocate-row ri=%d mode=%d ok"
argument_list|,
name|ri
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Find a PMC descriptor with user handle 'pmc' for thread 'td'.  */
end_comment

begin_function
specifier|static
name|struct
name|pmc
modifier|*
name|pmc_find_pmc_descriptor_in_process
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|pmc_id_t
name|pmcid
parameter_list|)
block|{
name|struct
name|pmc_list
modifier|*
name|pl
decl_stmt|;
name|KASSERT
argument_list|(
name|pmcid
operator|<
name|md
operator|->
name|pmd_npmc
argument_list|,
operator|(
literal|"[pmc,%d] Illegal pmc index %d (max %d)"
operator|,
name|__LINE__
operator|,
name|pmcid
operator|,
name|md
operator|->
name|pmd_npmc
operator|)
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|pl
argument_list|,
argument|&po->po_pmcs
argument_list|,
argument|pl_next
argument_list|)
if|if
condition|(
name|pl
operator|->
name|pl_pmc
operator|->
name|pm_rowindex
operator|==
name|pmcid
condition|)
return|return
name|pl
operator|->
name|pl_pmc
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pmc_find_pmc
parameter_list|(
name|pmc_id_t
name|pmcid
parameter_list|,
name|struct
name|pmc
modifier|*
modifier|*
name|pmc
parameter_list|)
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FND
argument_list|,
literal|1
argument_list|,
literal|"find-pmc id=%d"
argument_list|,
name|pmcid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ESRCH
return|;
if|if
condition|(
operator|(
name|pm
operator|=
name|pmc_find_pmc_descriptor_in_process
argument_list|(
name|po
argument_list|,
name|pmcid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EINVAL
return|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FND
argument_list|,
literal|2
argument_list|,
literal|"find-pmc id=%d -> pmc=%p"
argument_list|,
name|pmcid
argument_list|,
name|pm
argument_list|)
expr_stmt|;
operator|*
name|pmc
operator|=
name|pm
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_start
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|cpu
decl_stmt|,
name|ri
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null pm"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"start pmc=%p mode=%d ri=%d"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_mode
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_RUNNING
expr_stmt|;
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
block|{
comment|/* 		 * If a PMCATTACH hadn't been done on this 		 * PMC, attach this PMC to its owner process. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
condition|)
return|return
name|pmc_attach_process
argument_list|(
name|pm
operator|->
name|pm_owner
operator|->
name|po_owner
argument_list|,
name|pm
argument_list|)
return|;
comment|/* 		 * Nothing further to be done; thread context switch code 		 * will start/stop the PMC as appropriate. 		 */
return|return
literal|0
return|;
block|}
comment|/* 	 * A system-mode PMC.  Move to the CPU associated with this 	 * PMC, and start the hardware. 	 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
comment|/* 	 * global PMCs are configured at allocation time 	 * so write out the initial value and start the PMC. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_write_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|?
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
else|:
name|pm
operator|->
name|pm_sc
operator|.
name|pm_initial
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|md
operator|->
name|pmd_start_pmc
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|)
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Stop a PMC.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_stop
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|cpu
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|KASSERT
argument_list|(
name|pm
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] null pmc"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"stop pmc=%p mode=%d ri=%d"
argument_list|,
name|pm
argument_list|,
name|pm
operator|->
name|pm_mode
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|)
expr_stmt|;
name|pm
operator|->
name|pm_state
operator|=
name|PMC_STATE_STOPPED
expr_stmt|;
comment|/* 	 * If the PMC is a virtual mode one, changing the state to 	 * non-RUNNING is enough to ensure that the PMC never gets 	 * scheduled. 	 * 	 * If this PMC is current running on a CPU, then it will 	 * handled correctly at the time its target process is context 	 * switched out. 	 */
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * A system-mode PMC.  Move to the CPU associated with 	 * this PMC, and stop the hardware.  We update the 	 * 'initial count' so that a subsequent PMCSTART will 	 * resume counting from the current hardware count. 	 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|cpu
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
return|return
name|ENXIO
return|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_stop_pmc
argument_list|(
name|cpu
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|error
operator|=
name|md
operator|->
name|pmd_read_pmc
argument_list|(
name|cpu
argument_list|,
name|pm
operator|->
name|pm_rowindex
argument_list|,
operator|&
name|pm
operator|->
name|pm_sc
operator|.
name|pm_initial
argument_list|)
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_if
if|#
directive|if
name|DEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pmc_op_to_name
index|[]
init|=
block|{
undef|#
directive|undef
name|__PMC_OP
define|#
directive|define
name|__PMC_OP
parameter_list|(
name|N
parameter_list|,
name|D
parameter_list|)
value|#N ,
name|__PMC_OPS
argument_list|()
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The syscall interface  */
end_comment

begin_define
define|#
directive|define
name|PMC_GET_SX_XLOCK
parameter_list|(
modifier|...
parameter_list|)
value|do {		\ 	sx_xlock(&pmc_sx);			\ 	if (pmc_hook == NULL) {			\ 		sx_xunlock(&pmc_sx);		\ 		return __VA_ARGS__;		\ 	}					\ } while (0)
end_define

begin_define
define|#
directive|define
name|PMC_DOWNGRADE_SX
parameter_list|()
value|do {			\ 	sx_downgrade(&pmc_sx);			\ 	is_sx_downgraded = 1;			\ } while (0)
end_define

begin_function
specifier|static
name|int
name|pmc_syscall_handler
parameter_list|(
name|struct
name|thread
modifier|*
name|td
parameter_list|,
name|void
modifier|*
name|syscall_args
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|is_sx_downgraded
decl_stmt|,
name|op
decl_stmt|;
name|struct
name|pmc_syscall_args
modifier|*
name|c
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
name|PMC_GET_SX_XLOCK
argument_list|(
name|ENOSYS
argument_list|)
expr_stmt|;
name|is_sx_downgraded
operator|=
literal|0
expr_stmt|;
name|c
operator|=
operator|(
expr|struct
name|pmc_syscall_args
operator|*
operator|)
name|syscall_args
expr_stmt|;
name|op
operator|=
name|c
operator|->
name|pmop_code
expr_stmt|;
name|arg
operator|=
name|c
operator|->
name|pmop_data
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|PMS
argument_list|,
literal|1
argument_list|,
literal|"syscall op=%d \"%s\" arg=%p"
argument_list|,
name|op
argument_list|,
name|pmc_op_to_name
index|[
name|op
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_syscalls
argument_list|,
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
comment|/* 	 * Configure a log file. 	 * 	 * XXX This OP will be reworked. 	 */
case|case
name|PMC_OP_CONFIGURELOG
case|:
block|{
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_op_configurelog
name|cl
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|cl
argument_list|,
sizeof|sizeof
argument_list|(
name|cl
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* mark this process as owning a log file */
name|p
operator|=
name|td
operator|->
name|td_proc
expr_stmt|;
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_find_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
if|if
condition|(
operator|(
name|po
operator|=
name|pmc_allocate_owner_descriptor
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_configure_log
argument_list|(
name|po
argument_list|,
name|cl
operator|.
name|pm_logfd
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
break|break;
comment|/* 	 * Retrieve hardware configuration. 	 */
case|case
name|PMC_OP_GETCPUINFO
case|:
comment|/* CPU information */
block|{
name|struct
name|pmc_op_getcpuinfo
name|gci
decl_stmt|;
name|gci
operator|.
name|pm_cputype
operator|=
name|md
operator|->
name|pmd_cputype
expr_stmt|;
name|gci
operator|.
name|pm_npmc
operator|=
name|md
operator|->
name|pmd_npmc
expr_stmt|;
name|gci
operator|.
name|pm_nclass
operator|=
name|md
operator|->
name|pmd_nclass
expr_stmt|;
name|bcopy
argument_list|(
name|md
operator|->
name|pmd_classes
argument_list|,
operator|&
name|gci
operator|.
name|pm_classes
argument_list|,
sizeof|sizeof
argument_list|(
name|gci
operator|.
name|pm_classes
argument_list|)
argument_list|)
expr_stmt|;
name|gci
operator|.
name|pm_ncpu
operator|=
name|mp_ncpus
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|gci
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gci
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Get module statistics 	 */
case|case
name|PMC_OP_GETDRIVERSTATS
case|:
block|{
name|struct
name|pmc_op_getdriverstats
name|gms
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|pmc_stats
argument_list|,
operator|&
name|gms
argument_list|,
sizeof|sizeof
argument_list|(
name|gms
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|gms
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gms
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Retrieve module version number 	 */
case|case
name|PMC_OP_GETMODULEVERSION
case|:
block|{
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|_pmc_version
operator|.
name|mv_version
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Retrieve the state of all the PMCs on a given 	 * CPU. 	 */
case|case
name|PMC_OP_GETPMCINFO
case|:
block|{
name|uint32_t
name|cpu
decl_stmt|,
name|n
decl_stmt|,
name|npmc
decl_stmt|;
name|size_t
name|pmcinfo_size
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_info
modifier|*
name|p
decl_stmt|,
modifier|*
name|pmcinfo
decl_stmt|;
name|struct
name|pmc_op_getpmcinfo
modifier|*
name|gpi
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
name|gpi
operator|=
operator|(
expr|struct
name|pmc_op_getpmcinfo
operator|*
operator|)
name|arg
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
operator|&
name|gpi
operator|->
name|pm_cpu
argument_list|,
operator|&
name|cpu
argument_list|,
sizeof|sizeof
argument_list|(
name|cpu
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|cpu
operator|>=
operator|(
name|unsigned
name|int
operator|)
name|mp_ncpus
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* switch to CPU 'cpu' */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|npmc
operator|=
name|md
operator|->
name|pmd_npmc
expr_stmt|;
name|pmcinfo_size
operator|=
name|npmc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_info
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|pmcinfo
argument_list|,
expr|struct
name|pmc_info
operator|*
argument_list|,
name|pmcinfo_size
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|p
operator|=
name|pmcinfo
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_describe
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|p
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|PMC_ROW_DISP_IS_STANDALONE
argument_list|(
name|n
argument_list|)
condition|)
name|p
operator|->
name|pm_rowdisp
operator|=
name|PMC_DISP_STANDALONE
expr_stmt|;
elseif|else
if|if
condition|(
name|PMC_ROW_DISP_IS_THREAD
argument_list|(
name|n
argument_list|)
condition|)
name|p
operator|->
name|pm_rowdisp
operator|=
name|PMC_DISP_THREAD
expr_stmt|;
else|else
name|p
operator|->
name|pm_rowdisp
operator|=
name|PMC_DISP_FREE
expr_stmt|;
name|p
operator|->
name|pm_ownerpid
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|pm
operator|==
name|NULL
condition|)
comment|/* no PMC associated */
continue|continue;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|KASSERT
argument_list|(
name|po
operator|->
name|po_owner
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] pmc_owner had a null proc pointer"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|pm_ownerpid
operator|=
name|po
operator|->
name|po_owner
operator|->
name|p_pid
expr_stmt|;
name|p
operator|->
name|pm_mode
operator|=
name|pm
operator|->
name|pm_mode
expr_stmt|;
name|p
operator|->
name|pm_event
operator|=
name|pm
operator|->
name|pm_event
expr_stmt|;
name|p
operator|->
name|pm_flags
operator|=
name|pm
operator|->
name|pm_flags
expr_stmt|;
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
name|p
operator|->
name|pm_reloadcount
operator|=
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
expr_stmt|;
block|}
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
comment|/* now copy out the PMC info collected */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|copyout
argument_list|(
name|pmcinfo
argument_list|,
operator|&
name|gpi
operator|->
name|pm_pmcs
argument_list|,
name|pmcinfo_size
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmcinfo
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Set the administrative state of a PMC.  I.e. whether 	 * the PMC is to be used or not. 	 */
case|case
name|PMC_OP_PMCADMIN
case|:
block|{
name|int
name|cpu
decl_stmt|,
name|ri
decl_stmt|;
name|enum
name|pmc_state
name|request
decl_stmt|;
name|struct
name|pmc_cpu
modifier|*
name|pc
decl_stmt|;
name|struct
name|pmc_hw
modifier|*
name|phw
decl_stmt|;
name|struct
name|pmc_op_pmcadmin
name|pma
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|td
operator|==
name|curthread
argument_list|,
operator|(
literal|"[pmc,%d] td != curthread"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|suser
argument_list|(
name|td
argument_list|)
operator|||
name|jailed
argument_list|(
name|td
operator|->
name|td_ucred
argument_list|)
condition|)
block|{
name|error
operator|=
name|EPERM
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|pma
argument_list|,
sizeof|sizeof
argument_list|(
name|pma
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|cpu
operator|=
name|pma
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
name|cpu
operator|<
literal|0
operator|||
name|cpu
operator|>=
name|mp_ncpus
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
name|request
operator|=
name|pma
operator|.
name|pm_state
expr_stmt|;
if|if
condition|(
name|request
operator|!=
name|PMC_STATE_DISABLED
operator|&&
name|request
operator|!=
name|PMC_STATE_FREE
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ri
operator|=
name|pma
operator|.
name|pm_pmc
expr_stmt|;
comment|/* pmc id == row index */
if|if
condition|(
name|ri
operator|<
literal|0
operator|||
name|ri
operator|>=
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * We can't disable a PMC with a row-index allocated 		 * for process virtual PMCs. 		 */
if|if
condition|(
name|PMC_ROW_DISP_IS_THREAD
argument_list|(
name|ri
argument_list|)
operator|&&
name|request
operator|==
name|PMC_STATE_DISABLED
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
comment|/* 		 * otherwise, this PMC on this CPU is either free or 		 * in system-wide mode. 		 */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|pc
operator|=
name|pmc_pcpu
index|[
name|cpu
index|]
expr_stmt|;
name|phw
operator|=
name|pc
operator|->
name|pc_hwpmcs
index|[
name|ri
index|]
expr_stmt|;
comment|/* 		 * XXX do we need some kind of 'forced' disable? 		 */
if|if
condition|(
name|phw
operator|->
name|phw_pmc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|request
operator|==
name|PMC_STATE_DISABLED
operator|&&
operator|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
operator|)
condition|)
block|{
name|phw
operator|->
name|phw_state
operator|&=
operator|~
name|PMC_PHW_FLAG_IS_ENABLED
expr_stmt|;
name|PMC_MARK_ROW_STANDALONE
argument_list|(
name|ri
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|request
operator|==
name|PMC_STATE_FREE
operator|&&
operator|(
name|phw
operator|->
name|phw_state
operator|&
name|PMC_PHW_FLAG_IS_ENABLED
operator|)
operator|==
literal|0
condition|)
block|{
name|phw
operator|->
name|phw_state
operator||=
name|PMC_PHW_FLAG_IS_ENABLED
expr_stmt|;
name|PMC_UNMARK_ROW_STANDALONE
argument_list|(
name|ri
argument_list|)
expr_stmt|;
block|}
comment|/* other cases are a no-op */
block|}
else|else
name|error
operator|=
name|EBUSY
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Allocate a PMC. 	 */
case|case
name|PMC_OP_PMCALLOCATE
case|:
block|{
name|uint32_t
name|caps
decl_stmt|;
name|u_int
name|cpu
decl_stmt|;
name|int
name|n
decl_stmt|;
name|enum
name|pmc_mode
name|mode
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pmc
decl_stmt|;
name|struct
name|pmc_op_pmcallocate
name|pa
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|pa
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|caps
operator|=
name|pa
operator|.
name|pm_caps
expr_stmt|;
name|mode
operator|=
name|pa
operator|.
name|pm_mode
expr_stmt|;
name|cpu
operator|=
name|pa
operator|.
name|pm_cpu
expr_stmt|;
if|if
condition|(
operator|(
name|mode
operator|!=
name|PMC_MODE_SS
operator|&&
name|mode
operator|!=
name|PMC_MODE_SC
operator|&&
name|mode
operator|!=
name|PMC_MODE_TS
operator|&&
name|mode
operator|!=
name|PMC_MODE_TC
operator|)
operator|||
operator|(
name|cpu
operator|!=
operator|(
name|u_int
operator|)
name|PMC_CPU_ANY
operator|&&
name|cpu
operator|>=
operator|(
name|u_int
operator|)
name|mp_ncpus
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Virtual PMCs should only ask for a default CPU. 		 * System mode PMCs need to specify a non-default CPU. 		 */
if|if
condition|(
operator|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|cpu
operator|!=
operator|(
name|u_int
operator|)
name|PMC_CPU_ANY
operator|)
operator|||
operator|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|cpu
operator|==
operator|(
name|u_int
operator|)
name|PMC_CPU_ANY
operator|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Check that a disabled CPU is not being asked for. 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
operator|&&
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* 		 * Refuse an allocation for a system-wide PMC if this 		 * process has been jailed, or if this process lacks 		 * super-user credentials and the sysctl tunable 		 * 'security.bsd.unprivileged_syspmcs' is zero. 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|jailed
argument_list|(
name|curthread
operator|->
name|td_ucred
argument_list|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
elseif|else
if|if
condition|(
name|suser
argument_list|(
name|curthread
argument_list|)
operator|&&
operator|(
name|pmc_unprivileged_syspmcs
operator|==
literal|0
operator|)
condition|)
name|error
operator|=
name|EPERM
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
break|break;
comment|/* 		 * Look for valid values for 'pm_flags' 		 */
if|if
condition|(
operator|(
name|pa
operator|.
name|pm_flags
operator|&
operator|~
operator|(
name|PMC_F_DESCENDANTS
operator||
name|PMC_F_LOG_TC_CSW
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* 		 * All sampling mode PMCs need to be able to interrupt the 		 * CPU. 		 */
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|caps
operator||=
name|PMC_CAP_INTERRUPT
expr_stmt|;
name|error
operator|=
name|ENOSYS
expr_stmt|;
comment|/* for snapshot 6 */
break|break;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"event=%d caps=0x%x mode=%d cpu=%d"
argument_list|,
name|pa
operator|.
name|pm_ev
argument_list|,
name|caps
argument_list|,
name|mode
argument_list|,
name|cpu
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|pmc_allocate_pmc_descriptor
argument_list|()
expr_stmt|;
name|pmc
operator|->
name|pm_event
operator|=
name|pa
operator|.
name|pm_ev
expr_stmt|;
name|pmc
operator|->
name|pm_class
operator|=
name|pa
operator|.
name|pm_class
expr_stmt|;
name|pmc
operator|->
name|pm_state
operator|=
name|PMC_STATE_FREE
expr_stmt|;
name|pmc
operator|->
name|pm_mode
operator|=
name|mode
expr_stmt|;
name|pmc
operator|->
name|pm_caps
operator|=
name|caps
expr_stmt|;
name|pmc
operator|->
name|pm_flags
operator|=
name|pa
operator|.
name|pm_flags
expr_stmt|;
comment|/* switch thread to CPU 'cpu' */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
define|#
directive|define
name|PMC_IS_SHAREABLE_PMC
parameter_list|(
name|cpu
parameter_list|,
name|n
parameter_list|)
define|\
value|(pmc_pcpu[(cpu)]->pc_hwpmcs[(n)]->phw_state&		\ 	 PMC_PHW_FLAG_IS_SHAREABLE)
define|#
directive|define
name|PMC_IS_UNALLOCATED
parameter_list|(
name|cpu
parameter_list|,
name|n
parameter_list|)
define|\
value|(pmc_pcpu[(cpu)]->pc_hwpmcs[(n)]->phw_pmc == NULL)
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
block|{
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
if|if
condition|(
name|pmc_can_allocate_row
argument_list|(
name|n
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|pmc_can_allocate_rowindex
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|PMC_IS_UNALLOCATED
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|)
operator|||
name|PMC_IS_SHAREABLE_PMC
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|)
operator|)
operator|&&
name|md
operator|->
name|pmd_allocate_pmc
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|,
operator|&
name|pa
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* Process virtual mode */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|pmc_can_allocate_row
argument_list|(
name|n
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
operator|&&
name|pmc_can_allocate_rowindex
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|md
operator|->
name|pmd_allocate_pmc
argument_list|(
name|curthread
operator|->
name|td_oncpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|,
operator|&
name|pa
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
block|}
undef|#
directive|undef
name|PMC_IS_UNALLOCATED
undef|#
directive|undef
name|PMC_IS_SHAREABLE_PMC
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|)
block|{
name|pmc_destroy_pmc_descriptor
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|ALL
argument_list|,
literal|2
argument_list|,
literal|"ev=%d class=%d mode=%d -> n=%d"
argument_list|,
name|pmc
operator|->
name|pm_event
argument_list|,
name|pmc
operator|->
name|pm_class
argument_list|,
name|pmc
operator|->
name|pm_mode
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * Configure global pmc's immediately 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|pmc
operator|->
name|pm_mode
argument_list|)
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_config_pmc
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_release_pmc
argument_list|(
name|cpu
argument_list|,
name|n
argument_list|,
name|pmc
argument_list|)
expr_stmt|;
name|pmc_destroy_pmc_descriptor
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Mark the row index allocated. 		 */
name|pmc
operator|->
name|pm_rowindex
operator|=
name|n
expr_stmt|;
name|pmc
operator|->
name|pm_state
operator|=
name|PMC_STATE_ALLOCATED
expr_stmt|;
comment|/* 		 * mark row disposition 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|PMC_MARK_ROW_STANDALONE
argument_list|(
name|n
argument_list|)
expr_stmt|;
else|else
name|PMC_MARK_ROW_THREAD
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * If this is a system-wide CPU, mark the CPU it 		 * was allocated on. 		 */
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|mode
argument_list|)
condition|)
name|pmc
operator|->
name|pm_gv
operator|.
name|pm_cpu
operator|=
name|cpu
expr_stmt|;
comment|/* 		 * Register this PMC with the current thread as its owner. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_register_owner
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|pmc
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|pmc_release_pmc_descriptor
argument_list|(
name|pmc
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pmc
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* 		 * Return the allocated index. 		 */
name|pa
operator|.
name|pm_pmcid
operator|=
name|n
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|pa
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|pa
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Attach a PMC to a process. 	 */
case|case
name|PMC_OP_PMCATTACH
case|:
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_op_pmcattach
name|a
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|==
literal|0
condition|)
name|a
operator|.
name|pm_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|a
operator|.
name|pm_pmc
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* PMCs may be (re)attached only when allocated or stopped */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_ALLOCATED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_STOPPED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* lookup pid */
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|a
operator|.
name|pm_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
comment|/* 		 * Ignore processes that are working on exiting. 		 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* pfind() returns a locked process */
break|break;
block|}
comment|/* 		 * we are allowed to attach a PMC to a process if 		 * we can debug it. 		 */
name|error
operator|=
name|p_candebug
argument_list|(
name|curthread
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|pmc_attach_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Detach an attached PMC from a process. 	 */
case|case
name|PMC_OP_PMCDETACH
case|:
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|pmc_op_pmcattach
name|a
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|a
argument_list|,
sizeof|sizeof
argument_list|(
name|a
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|a
operator|.
name|pm_pid
operator|==
literal|0
condition|)
name|a
operator|.
name|pm_pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|a
operator|.
name|pm_pmc
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|p
operator|=
name|pfind
argument_list|(
name|a
operator|.
name|pm_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ESRCH
expr_stmt|;
break|break;
block|}
comment|/* 		 * Treat processes that are in the process of exiting 		 * as if they were not present. 		 */
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
name|P_WEXIT
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* pfind() returns a locked process */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|pmc_detach_process
argument_list|(
name|p
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Release an allocated PMC 	 */
case|case
name|PMC_OP_PMCRELEASE
case|:
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|;
name|struct
name|pmc_op_simple
name|sp
decl_stmt|;
comment|/* 		 * Find PMC pointer for the named PMC. 		 * 		 * Use pmc_release_pmc_descriptor() to switch off the 		 * PMC, remove all its target threads, and remove the 		 * PMC from its owner's list. 		 * 		 * Remove the owner record if this is the last PMC 		 * owned. 		 * 		 * Free up space. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|pmcid
operator|=
name|sp
operator|.
name|pm_pmcid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|po
operator|=
name|pm
operator|->
name|pm_owner
expr_stmt|;
name|pmc_release_pmc_descriptor
argument_list|(
name|pm
argument_list|)
expr_stmt|;
name|pmc_maybe_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|pm
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Read and/or write a PMC. 	 */
case|case
name|PMC_OP_PMCRW
case|:
block|{
name|uint32_t
name|cpu
decl_stmt|,
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_pmcrw
modifier|*
name|pprw
decl_stmt|;
name|struct
name|pmc_op_pmcrw
name|prw
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|pmc_value_t
name|oldvalue
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|prw
argument_list|,
sizeof|sizeof
argument_list|(
name|prw
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|ri
operator|=
literal|0
expr_stmt|;
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|1
argument_list|,
literal|"rw id=%d flags=0x%x"
argument_list|,
name|prw
operator|.
name|pm_pmcid
argument_list|,
name|prw
operator|.
name|pm_flags
argument_list|)
expr_stmt|;
comment|/* must have at least one flag set */
if|if
condition|(
operator|(
name|prw
operator|.
name|pm_flags
operator|&
operator|(
name|PMC_F_OLDVALUE
operator||
name|PMC_F_NEWVALUE
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* locate pmc descriptor */
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|prw
operator|.
name|pm_pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* Can't read a PMC that hasn't been started. */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_ALLOCATED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_STOPPED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
comment|/* writing a new value is allowed only for 'STOPPED' pmcs */
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
operator|&&
operator|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
operator|)
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
block|{
comment|/* read/write the saved value in the PMC record */
name|mtx_pool_lock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
name|oldvalue
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
expr_stmt|;
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
condition|)
name|pm
operator|->
name|pm_gv
operator|.
name|pm_savedvalue
operator|=
name|prw
operator|.
name|pm_value
expr_stmt|;
name|mtx_pool_unlock_spin
argument_list|(
name|pmc_mtxpool
argument_list|,
name|pm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* System mode PMCs */
name|cpu
operator|=
name|pm
operator|->
name|pm_gv
operator|.
name|pm_cpu
expr_stmt|;
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* move this thread to CPU 'cpu' */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
comment|/* save old value */
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_read_pmc
call|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
operator|&
name|oldvalue
argument_list|)
operator|)
condition|)
goto|goto
name|error
goto|;
comment|/* write out new value */
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
condition|)
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_write_pmc
call|)
argument_list|(
name|cpu
argument_list|,
name|ri
argument_list|,
name|prw
operator|.
name|pm_value
argument_list|)
expr_stmt|;
name|error
label|:
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|pprw
operator|=
operator|(
expr|struct
name|pmc_op_pmcrw
operator|*
operator|)
name|arg
expr_stmt|;
if|#
directive|if
name|DEBUG
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_NEWVALUE
condition|)
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|2
argument_list|,
literal|"rw id=%d new %jx -> old %jx"
argument_list|,
name|ri
argument_list|,
name|prw
operator|.
name|pm_value
argument_list|,
name|oldvalue
argument_list|)
expr_stmt|;
else|else
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|OPS
argument_list|,
literal|2
argument_list|,
literal|"rw id=%d -> old %jx"
argument_list|,
name|ri
argument_list|,
name|oldvalue
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* return old value if requested */
if|if
condition|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
condition|)
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|oldvalue
argument_list|,
operator|&
name|pprw
operator|->
name|pm_value
argument_list|,
sizeof|sizeof
argument_list|(
name|prw
operator|.
name|pm_value
argument_list|)
argument_list|)
operator|)
condition|)
break|break;
comment|/* 		 * send a signal (SIGIO) to the owner if it is trying to read 		 * a PMC with no target processes attached. 		 */
if|if
condition|(
name|LIST_EMPTY
argument_list|(
operator|&
name|pm
operator|->
name|pm_targets
argument_list|)
operator|&&
operator|(
name|prw
operator|.
name|pm_flags
operator|&
name|PMC_F_OLDVALUE
operator|)
condition|)
block|{
name|PROC_LOCK
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|,
name|SIGIO
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|curthread
operator|->
name|td_proc
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
comment|/* 	 * Set the sampling rate for a sampling mode PMC and the 	 * initial count for a counting mode PMC. 	 */
case|case
name|PMC_OP_PMCSETCOUNT
case|:
block|{
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_pmcsetcount
name|sc
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sc
argument_list|,
sizeof|sizeof
argument_list|(
name|sc
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|sc
operator|.
name|pm_pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|PMC_IS_SAMPLING_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
name|pm
operator|->
name|pm_sc
operator|.
name|pm_reloadcount
operator|=
name|sc
operator|.
name|pm_count
expr_stmt|;
else|else
name|pm
operator|->
name|pm_sc
operator|.
name|pm_initial
operator|=
name|sc
operator|.
name|pm_count
expr_stmt|;
block|}
break|break;
comment|/* 	 * Start a PMC. 	 */
case|case
name|PMC_OP_PMCSTART
case|:
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_simple
name|sp
decl_stmt|;
name|sx_assert
argument_list|(
operator|&
name|pmc_sx
argument_list|,
name|SX_XLOCKED
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|pmcid
operator|=
name|sp
operator|.
name|pm_pmcid
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|KASSERT
argument_list|(
name|pmcid
operator|==
name|pm
operator|->
name|pm_rowindex
argument_list|,
operator|(
literal|"[pmc,%d] row index %d != id %d"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_rowindex
operator|,
name|pmcid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_RUNNING
condition|)
comment|/* already running */
break|break;
elseif|else
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_STOPPED
operator|&&
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_ALLOCATED
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pmc_start
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Stop a PMC. 	 */
case|case
name|PMC_OP_PMCSTOP
case|:
block|{
name|pmc_id_t
name|pmcid
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_simple
name|sp
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
name|sp
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|pmcid
operator|=
name|sp
operator|.
name|pm_pmcid
expr_stmt|;
comment|/* 		 * Mark the PMC as inactive and invoke the MD stop 		 * routines if needed. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|KASSERT
argument_list|(
name|pmcid
operator|==
name|pm
operator|->
name|pm_rowindex
argument_list|,
operator|(
literal|"[pmc,%d] row index %d != pmcid %d"
operator|,
name|__LINE__
operator|,
name|pm
operator|->
name|pm_rowindex
operator|,
name|pmcid
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|==
name|PMC_STATE_STOPPED
condition|)
comment|/* already stopped */
break|break;
elseif|else
if|if
condition|(
name|pm
operator|->
name|pm_state
operator|!=
name|PMC_STATE_RUNNING
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|pmc_stop
argument_list|(
name|pm
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 	 * Write a user-entry to the log file. 	 */
case|case
name|PMC_OP_WRITELOG
case|:
block|{
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
comment|/* 		 * flush all per-cpu hash tables 		 * append user-log entry 		 */
name|error
operator|=
name|ENOSYS
expr_stmt|;
block|}
break|break;
if|#
directive|if
name|__i386__
operator|||
name|__amd64__
comment|/* 	 * Machine dependent operation for i386-class processors. 	 * 	 * Retrieve the MSR number associated with the counter 	 * 'pmc_id'.  This allows processes to directly use RDPMC 	 * instructions to read their PMCs, without the overhead of a 	 * system call. 	 */
case|case
name|PMC_OP_PMCX86GETMSR
case|:
block|{
name|int
name|ri
decl_stmt|;
name|struct
name|pmc
modifier|*
name|pm
decl_stmt|;
name|struct
name|pmc_op_x86_getmsr
name|gm
decl_stmt|;
name|PMC_DOWNGRADE_SX
argument_list|()
expr_stmt|;
comment|/* CPU has no 'GETMSR' support */
if|if
condition|(
name|md
operator|->
name|pmd_get_msr
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOSYS
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|gm
argument_list|,
sizeof|sizeof
argument_list|(
name|gm
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|pmc_find_pmc
argument_list|(
name|gm
operator|.
name|pm_pmcid
argument_list|,
operator|&
name|pm
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
comment|/* 		 * The allocated PMC needs to be a process virtual PMC, 		 * i.e., of type T[CS]. 		 * 		 * Global PMCs can only be read using the PMCREAD 		 * operation since they may be allocated on a 		 * different CPU than the one we could be running on 		 * at the time of the read. 		 */
if|if
condition|(
operator|!
name|PMC_IS_VIRTUAL_MODE
argument_list|(
name|pm
operator|->
name|pm_mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|ri
operator|=
name|pm
operator|->
name|pm_rowindex
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
call|(
modifier|*
name|md
operator|->
name|pmd_get_msr
call|)
argument_list|(
name|ri
argument_list|,
operator|&
name|gm
operator|.
name|pm_msr
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|&
name|gm
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|gm
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
block|}
break|break;
endif|#
directive|endif
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|is_sx_downgraded
condition|)
name|sx_sunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
else|else
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|pmc_stats
operator|.
name|pm_syscall_errors
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * Helper functions  */
end_comment

begin_comment
comment|/*  * Configure a log file.  */
end_comment

begin_function
specifier|static
name|int
name|pmc_configure_log
parameter_list|(
name|struct
name|pmc_owner
modifier|*
name|po
parameter_list|,
name|int
name|logfd
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
return|return
name|ENOSYS
return|;
comment|/* for now */
name|p
operator|=
name|po
operator|->
name|po_owner
expr_stmt|;
if|if
condition|(
name|po
operator|->
name|po_logfd
operator|<
literal|0
operator|&&
name|logfd
operator|<
literal|0
condition|)
comment|/* nothing to do */
return|return
literal|0
return|;
if|if
condition|(
name|po
operator|->
name|po_logfd
operator|>=
literal|0
operator|&&
name|logfd
operator|<
literal|0
condition|)
block|{
comment|/* deconfigure log */
comment|/* XXX */
name|po
operator|->
name|po_flags
operator|&=
operator|~
name|PMC_FLAG_OWNS_LOGFILE
expr_stmt|;
name|pmc_maybe_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|po
operator|->
name|po_logfd
operator|<
literal|0
operator|&&
name|logfd
operator|>=
literal|0
condition|)
block|{
comment|/* configure log file */
comment|/* XXX */
name|po
operator|->
name|po_flags
operator||=
name|PMC_FLAG_OWNS_LOGFILE
expr_stmt|;
comment|/* mark process as using HWPMCs */
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_flag
operator||=
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|EBUSY
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Log an exit event to the PMC owner's log file.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_log_process_exit
parameter_list|(
name|struct
name|pmc
modifier|*
name|pm
parameter_list|,
name|struct
name|pmc_process
modifier|*
name|pp
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|pm
operator|->
name|pm_flags
operator|&
name|PMC_F_LOG_TC_PROCEXIT
argument_list|,
operator|(
literal|"[pmc,%d] log-process-exit called gratuitously"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|pm
expr_stmt|;
operator|(
name|void
operator|)
name|pp
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Event handlers.  */
end_comment

begin_comment
comment|/*  * Handle a process exit.  *  * XXX This eventhandler gets called early in the exit process.  * Consider using a 'hook' invocation from thread_exit() or equivalent  * spot.  Another negative is that kse_exit doesn't seem to call  * exit1() [??].  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_exit
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p
parameter_list|)
block|{
name|int
name|is_using_hwpmcs
decl_stmt|;
name|PROC_LOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|is_using_hwpmcs
operator|=
name|p
operator|->
name|p_flag
operator|&
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_using_hwpmcs
condition|)
block|{
name|PMCDBG
argument_list|(
name|PRC
argument_list|,
name|EXT
argument_list|,
literal|1
argument_list|,
literal|"process-exit proc=%p (%d, %s)"
argument_list|,
name|p
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|PMC_GET_SX_XLOCK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|pmc_hook_handler
argument_list|(
name|curthread
argument_list|,
name|PMC_FN_PROCESS_EXIT
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle a process fork.  *  * If the parent process 'p1' is under HWPMC monitoring, then copy  * over any attached PMCs that have 'do_descendants' semantics.  */
end_comment

begin_function
specifier|static
name|void
name|pmc_process_fork
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|proc
modifier|*
name|p1
parameter_list|,
name|struct
name|proc
modifier|*
name|p2
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|is_using_hwpmcs
decl_stmt|;
operator|(
name|void
operator|)
name|flags
expr_stmt|;
comment|/* unused parameter */
name|PROC_LOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
name|is_using_hwpmcs
operator|=
name|p1
operator|->
name|p_flag
operator|&
name|P_HWPMC
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_using_hwpmcs
condition|)
block|{
name|PMCDBG
argument_list|(
name|PMC
argument_list|,
name|FRK
argument_list|,
literal|1
argument_list|,
literal|"process-fork proc=%p (%d, %s)"
argument_list|,
name|p1
argument_list|,
name|p1
operator|->
name|p_pid
argument_list|,
name|p1
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|PMC_GET_SX_XLOCK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|pmc_hook_handler
argument_list|(
name|curthread
argument_list|,
name|PMC_FN_PROCESS_FORK
argument_list|,
operator|(
name|void
operator|*
operator|)
name|p2
argument_list|)
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * initialization  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|pmc_name_of_pmcclass
index|[]
init|=
block|{
undef|#
directive|undef
name|__PMC_CLASS
define|#
directive|define
name|__PMC_CLASS
parameter_list|(
name|N
parameter_list|)
value|#N ,
name|__PMC_CLASSES
argument_list|()
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pmc_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|cpu
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
name|md
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|DEBUG
comment|/* parse debug flags first */
if|if
condition|(
name|TUNABLE_STR_FETCH
argument_list|(
name|PMC_SYSCTL_NAME_PREFIX
literal|"debugflags"
argument_list|,
name|pmc_debugstr
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
condition|)
name|pmc_debugflags_parse
argument_list|(
name|pmc_debugstr
argument_list|,
name|pmc_debugstr
operator|+
name|strlen
argument_list|(
name|pmc_debugstr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"PMC Initialize (version %x)"
argument_list|,
name|PMC_VERSION
argument_list|)
expr_stmt|;
comment|/* 	 * check sysctl parameters 	 */
if|if
condition|(
name|pmc_hashsize
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"pmc: sysctl variable \""
name|PMC_SYSCTL_NAME_PREFIX
literal|"hashsize\" must be greater than "
literal|"zero\n"
argument_list|)
expr_stmt|;
name|pmc_hashsize
operator|=
name|PMC_HASH_SIZE
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
comment|/* determine the CPU kind.  This is i386 specific */
if|if
condition|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"AuthenticAMD"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|=
name|pmc_amd_initialize
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"GenuineIntel"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|=
name|pmc_intel_initialize
argument_list|()
expr_stmt|;
comment|/* XXX: what about the other i386 CPU manufacturers? */
elif|#
directive|elif
name|defined
argument_list|(
name|__amd64__
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|cpu_vendor
argument_list|,
literal|"AuthenticAMD"
argument_list|)
operator|==
literal|0
condition|)
name|md
operator|=
name|pmc_amd_initialize
argument_list|()
expr_stmt|;
else|#
directive|else
comment|/* other architectures */
name|md
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|md
operator|==
name|NULL
operator|||
name|md
operator|->
name|pmd_init
operator|==
name|NULL
condition|)
return|return
name|ENOSYS
return|;
comment|/* allocate space for the per-cpu array */
name|MALLOC
argument_list|(
name|pmc_pcpu
argument_list|,
expr|struct
name|pmc_cpu
operator|*
operator|*
argument_list|,
name|mp_ncpus
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pmc_cpu
operator|*
argument_list|)
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
comment|/* per-cpu 'saved values' for managing process-mode PMCs */
name|MALLOC
argument_list|(
name|pmc_pcpu_saved
argument_list|,
name|pmc_value_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|pmc_value_t
argument_list|)
operator|*
name|mp_ncpus
operator|*
name|md
operator|->
name|pmd_npmc
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* perform cpu dependent initialization */
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|md
operator|->
name|pmd_init
argument_list|(
name|cpu
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
name|error
return|;
comment|/* allocate space for the row disposition array */
name|pmc_pmcdisp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|enum
name|pmc_mode
argument_list|)
operator|*
name|md
operator|->
name|pmd_npmc
argument_list|,
name|M_PMC
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|pmc_pmcdisp
operator|!=
name|NULL
argument_list|,
operator|(
literal|"[pmc,%d] pmcdisp allocation returned NULL"
operator|,
name|__LINE__
operator|)
argument_list|)
expr_stmt|;
comment|/* mark all PMCs as available */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_npmc
condition|;
name|n
operator|++
control|)
name|PMC_MARK_ROW_FREE
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* allocate thread hash tables */
name|pmc_ownerhash
operator|=
name|hashinit
argument_list|(
name|pmc_hashsize
argument_list|,
name|M_PMC
argument_list|,
operator|&
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|pmc_processhash
operator|=
name|hashinit
argument_list|(
name|pmc_hashsize
argument_list|,
name|M_PMC
argument_list|,
operator|&
name|pmc_processhashmask
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|,
literal|"pmc-process-hash"
argument_list|,
literal|"pmc"
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
comment|/* allocate a pool of spin mutexes */
name|pmc_mtxpool
operator|=
name|mtx_pool_create
argument_list|(
literal|"pmc"
argument_list|,
name|pmc_mtxpool_size
argument_list|,
name|MTX_SPIN
argument_list|)
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"pmc_ownerhash=%p, mask=0x%lx "
literal|"targethash=%p mask=0x%lx"
argument_list|,
name|pmc_ownerhash
argument_list|,
name|pmc_ownerhashmask
argument_list|,
name|pmc_processhash
argument_list|,
name|pmc_processhashmask
argument_list|)
expr_stmt|;
comment|/* register process {exit,fork,exec} handlers */
name|pmc_exit_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_exit
argument_list|,
name|pmc_process_exit
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
name|pmc_fork_tag
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|process_fork
argument_list|,
name|pmc_process_fork
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
comment|/* set hook functions */
name|pmc_intr
operator|=
name|md
operator|->
name|pmd_intr
expr_stmt|;
name|pmc_hook
operator|=
name|pmc_hook_handler
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
name|PMC_MODULE_NAME
literal|":"
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|md
operator|->
name|pmd_nclass
condition|;
name|n
operator|++
control|)
name|printf
argument_list|(
literal|" %s(%d)"
argument_list|,
name|pmc_name_of_pmcclass
index|[
name|md
operator|->
name|pmd_classes
index|[
name|n
index|]
index|]
argument_list|,
name|md
operator|->
name|pmd_nclasspmcs
index|[
name|n
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* prepare to be unloaded */
end_comment

begin_function
specifier|static
name|void
name|pmc_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|cpu
decl_stmt|;
name|struct
name|pmc_ownerhash
modifier|*
name|ph
decl_stmt|;
name|struct
name|pmc_owner
modifier|*
name|po
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|struct
name|pmc_binding
name|pb
decl_stmt|;
if|#
directive|if
name|DEBUG
name|struct
name|pmc_processhash
modifier|*
name|prh
decl_stmt|;
endif|#
directive|endif
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|0
argument_list|,
literal|"%s"
argument_list|,
literal|"cleanup"
argument_list|)
expr_stmt|;
name|pmc_intr
operator|=
name|NULL
expr_stmt|;
comment|/* no more interrupts please */
name|sx_xlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_hook
operator|==
name|NULL
condition|)
block|{
comment|/* being unloaded already */
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
return|return;
block|}
name|pmc_hook
operator|=
name|NULL
expr_stmt|;
comment|/* prevent new threads from entering module */
comment|/* deregister event handlers */
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_fork
argument_list|,
name|pmc_fork_tag
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|process_exit
argument_list|,
name|pmc_exit_tag
argument_list|)
expr_stmt|;
comment|/* send SIGBUS to all owner threads, free up allocations */
if|if
condition|(
name|pmc_ownerhash
condition|)
for|for
control|(
name|ph
operator|=
name|pmc_ownerhash
init|;
name|ph
operator|<=
operator|&
name|pmc_ownerhash
index|[
name|pmc_ownerhashmask
index|]
condition|;
name|ph
operator|++
control|)
block|{
name|LIST_FOREACH_SAFE
argument_list|(
argument|po
argument_list|,
argument|ph
argument_list|,
argument|po_next
argument_list|,
argument|tmp
argument_list|)
block|{
name|pmc_remove_owner
argument_list|(
name|po
argument_list|)
expr_stmt|;
comment|/* send SIGBUS to owner processes */
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|2
argument_list|,
literal|"cleanup signal proc=%p "
literal|"(%d, %s)"
argument_list|,
name|po
operator|->
name|po_owner
argument_list|,
name|po
operator|->
name|po_owner
operator|->
name|p_pid
argument_list|,
name|po
operator|->
name|po_owner
operator|->
name|p_comm
argument_list|)
expr_stmt|;
name|PROC_LOCK
argument_list|(
name|po
operator|->
name|po_owner
argument_list|)
expr_stmt|;
name|psignal
argument_list|(
name|po
operator|->
name|po_owner
argument_list|,
name|SIGBUS
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|po
operator|->
name|po_owner
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|po
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reclaim allocated data structures */
if|if
condition|(
name|pmc_mtxpool
condition|)
name|mtx_pool_destroy
argument_list|(
operator|&
name|pmc_mtxpool
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|pmc_processhash_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_processhash
condition|)
block|{
if|#
directive|if
name|DEBUG
name|struct
name|pmc_process
modifier|*
name|pp
decl_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"%s"
argument_list|,
literal|"destroy process hash"
argument_list|)
expr_stmt|;
for|for
control|(
name|prh
operator|=
name|pmc_processhash
init|;
name|prh
operator|<=
operator|&
name|pmc_processhash
index|[
name|pmc_processhashmask
index|]
condition|;
name|prh
operator|++
control|)
name|LIST_FOREACH
argument_list|(
argument|pp
argument_list|,
argument|prh
argument_list|,
argument|pp_next
argument_list|)
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"pid=%d"
argument_list|,
name|pp
operator|->
name|pp_proc
operator|->
name|p_pid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hashdestroy
argument_list|(
name|pmc_processhash
argument_list|,
name|M_PMC
argument_list|,
name|pmc_processhashmask
argument_list|)
expr_stmt|;
name|pmc_processhash
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|pmc_ownerhash
condition|)
block|{
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"%s"
argument_list|,
literal|"destroy owner hash"
argument_list|)
expr_stmt|;
name|hashdestroy
argument_list|(
name|pmc_ownerhash
argument_list|,
name|M_PMC
argument_list|,
name|pmc_ownerhashmask
argument_list|)
expr_stmt|;
name|pmc_ownerhash
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* do processor dependent cleanup */
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|3
argument_list|,
literal|"%s"
argument_list|,
literal|"md cleanup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|md
condition|)
block|{
name|pmc_save_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
for|for
control|(
name|cpu
operator|=
literal|0
init|;
name|cpu
operator|<
name|mp_ncpus
condition|;
name|cpu
operator|++
control|)
block|{
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"pmc-cleanup cpu=%d pcs=%p"
argument_list|,
name|cpu
argument_list|,
name|pmc_pcpu
index|[
name|cpu
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_cpu_is_disabled
argument_list|(
name|cpu
argument_list|)
condition|)
continue|continue;
name|pmc_select_cpu
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmc_pcpu
index|[
name|cpu
index|]
condition|)
operator|(
name|void
operator|)
name|md
operator|->
name|pmd_cleanup
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
block|}
name|FREE
argument_list|(
name|md
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|md
operator|=
name|NULL
expr_stmt|;
name|pmc_restore_cpu_binding
argument_list|(
operator|&
name|pb
argument_list|)
expr_stmt|;
block|}
comment|/* deallocate per-cpu structures */
name|FREE
argument_list|(
name|pmc_pcpu
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pcpu
operator|=
name|NULL
expr_stmt|;
name|FREE
argument_list|(
name|pmc_pcpu_saved
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pcpu_saved
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pmc_pmcdisp
condition|)
block|{
name|FREE
argument_list|(
name|pmc_pmcdisp
argument_list|,
name|M_PMC
argument_list|)
expr_stmt|;
name|pmc_pmcdisp
operator|=
name|NULL
expr_stmt|;
block|}
name|sx_xunlock
argument_list|(
operator|&
name|pmc_sx
argument_list|)
expr_stmt|;
comment|/* we are done */
block|}
end_function

begin_comment
comment|/*  * The function called at load/unload.  */
end_comment

begin_function
specifier|static
name|int
name|load
parameter_list|(
name|struct
name|module
modifier|*
name|module
name|__unused
parameter_list|,
name|int
name|cmd
parameter_list|,
name|void
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|MOD_LOAD
case|:
comment|/* initialize the subsystem */
name|error
operator|=
name|pmc_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"syscall=%d ncpus=%d"
argument_list|,
name|pmc_syscall_num
argument_list|,
name|mp_ncpus
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_SHUTDOWN
case|:
name|pmc_cleanup
argument_list|()
expr_stmt|;
name|PMCDBG
argument_list|(
name|MOD
argument_list|,
name|INI
argument_list|,
literal|1
argument_list|,
literal|"%s"
argument_list|,
literal|"unloaded"
argument_list|)
expr_stmt|;
break|break;
default|default :
name|error
operator|=
name|EINVAL
expr_stmt|;
comment|/* XXX should panic(9) */
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/* memory pool */
end_comment

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_PMC
argument_list|,
literal|"pmc"
argument_list|,
literal|"Memory space for the PMC module"
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

