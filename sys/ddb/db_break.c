begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  *  *	$Id: db_break.c,v 1.14 1997/06/14 11:52:36 bde Exp $  */
end_comment

begin_comment
comment|/*  *	Author: David B. Golub, Carnegie Mellon University  *	Date:	7/90  */
end_comment

begin_comment
comment|/*  * Breakpoints.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_kern.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_break.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_define
define|#
directive|define
name|NBREAKPOINTS
value|100
end_define

begin_decl_stmt
specifier|static
name|struct
name|db_breakpoint
name|db_break_table
index|[
name|NBREAKPOINTS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_breakpoint_t
name|db_next_free_breakpoint
init|=
operator|&
name|db_break_table
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_breakpoint_t
name|db_free_breakpoints
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_breakpoint_t
name|db_breakpoint_list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_breakpoint_t
name|db_breakpoint_alloc
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|db_breakpoint_free
name|__P
argument_list|(
operator|(
name|db_breakpoint_t
name|bkpt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|db_delete_breakpoint
name|__P
argument_list|(
operator|(
name|vm_map_t
name|map
operator|,
name|db_addr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_breakpoint_t
name|db_find_breakpoint
name|__P
argument_list|(
operator|(
name|vm_map_t
name|map
operator|,
name|db_addr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|db_list_breakpoints
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|db_set_breakpoint
name|__P
argument_list|(
operator|(
name|vm_map_t
name|map
operator|,
name|db_addr_t
name|addr
operator|,
name|int
name|count
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notused
end_ifdef

begin_decl_stmt
specifier|static
name|db_breakpoint_t
name|db_set_temp_breakpoint
name|__P
argument_list|(
operator|(
name|db_addr_t
name|addr
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|db_delete_temp_breakpoint
name|__P
argument_list|(
operator|(
name|db_breakpoint_t
name|bkpt
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|db_breakpoint_t
name|db_breakpoint_alloc
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
operator|(
name|bkpt
operator|=
name|db_free_breakpoints
operator|)
operator|!=
literal|0
condition|)
block|{
name|db_free_breakpoints
operator|=
name|bkpt
operator|->
name|link
expr_stmt|;
return|return
operator|(
name|bkpt
operator|)
return|;
block|}
if|if
condition|(
name|db_next_free_breakpoint
operator|==
operator|&
name|db_break_table
index|[
name|NBREAKPOINTS
index|]
condition|)
block|{
name|db_printf
argument_list|(
literal|"All breakpoints used.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bkpt
operator|=
name|db_next_free_breakpoint
expr_stmt|;
name|db_next_free_breakpoint
operator|++
expr_stmt|;
return|return
operator|(
name|bkpt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_breakpoint_free
parameter_list|(
name|bkpt
parameter_list|)
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
block|{
name|bkpt
operator|->
name|link
operator|=
name|db_free_breakpoints
expr_stmt|;
name|db_free_breakpoints
operator|=
name|bkpt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_set_breakpoint
parameter_list|(
name|map
parameter_list|,
name|addr
parameter_list|,
name|count
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|db_addr_t
name|addr
decl_stmt|;
name|int
name|count
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_find_breakpoint
argument_list|(
name|map
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Already set.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bkpt
operator|=
name|db_breakpoint_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|bkpt
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many breakpoints.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bkpt
operator|->
name|map
operator|=
name|map
expr_stmt|;
name|bkpt
operator|->
name|address
operator|=
name|addr
expr_stmt|;
name|bkpt
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|bkpt
operator|->
name|init_count
operator|=
name|count
expr_stmt|;
name|bkpt
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|bkpt
operator|->
name|link
operator|=
name|db_breakpoint_list
expr_stmt|;
name|db_breakpoint_list
operator|=
name|bkpt
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_delete_breakpoint
parameter_list|(
name|map
parameter_list|,
name|addr
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|db_addr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
specifier|register
name|db_breakpoint_t
modifier|*
name|prev
decl_stmt|;
for|for
control|(
name|prev
operator|=
operator|&
name|db_breakpoint_list
init|;
operator|(
name|bkpt
operator|=
operator|*
name|prev
operator|)
operator|!=
literal|0
condition|;
name|prev
operator|=
operator|&
name|bkpt
operator|->
name|link
control|)
block|{
if|if
condition|(
name|db_map_equal
argument_list|(
name|bkpt
operator|->
name|map
argument_list|,
name|map
argument_list|)
operator|&&
operator|(
name|bkpt
operator|->
name|address
operator|==
name|addr
operator|)
condition|)
block|{
operator|*
name|prev
operator|=
name|bkpt
operator|->
name|link
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|bkpt
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Not set.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_breakpoint_free
argument_list|(
name|bkpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|db_breakpoint_t
name|db_find_breakpoint
parameter_list|(
name|map
parameter_list|,
name|addr
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
name|db_addr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
block|{
if|if
condition|(
name|db_map_equal
argument_list|(
name|bkpt
operator|->
name|map
argument_list|,
name|map
argument_list|)
operator|&&
operator|(
name|bkpt
operator|->
name|address
operator|==
name|addr
operator|)
condition|)
return|return
operator|(
name|bkpt
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|db_breakpoint_t
name|db_find_breakpoint_here
parameter_list|(
name|addr
parameter_list|)
name|db_addr_t
name|addr
decl_stmt|;
block|{
return|return
name|db_find_breakpoint
argument_list|(
name|db_map_addr
argument_list|(
name|addr
argument_list|)
argument_list|,
name|addr
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|boolean_t
name|db_breakpoints_inserted
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|db_set_breakpoints
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
operator|!
name|db_breakpoints_inserted
condition|)
block|{
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
if|if
condition|(
name|db_map_current
argument_list|(
name|bkpt
operator|->
name|map
argument_list|)
condition|)
block|{
name|bkpt
operator|->
name|bkpt_inst
operator|=
name|db_get_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|BKPT_SET
argument_list|(
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|db_breakpoints_inserted
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|db_clear_breakpoints
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_breakpoints_inserted
condition|)
block|{
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
if|if
condition|(
name|db_map_current
argument_list|(
name|bkpt
operator|->
name|map
argument_list|)
condition|)
block|{
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
expr_stmt|;
block|}
name|db_breakpoints_inserted
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SOFTWARE_SSTEP
end_ifdef

begin_comment
comment|/*  * Set a temporary breakpoint.  * The instruction is changed immediately,  * so the breakpoint does not have to be on the breakpoint list.  */
end_comment

begin_function
name|db_breakpoint_t
name|db_set_temp_breakpoint
parameter_list|(
name|addr
parameter_list|)
name|db_addr_t
name|addr
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
name|bkpt
operator|=
name|db_breakpoint_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|bkpt
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many breakpoints.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|bkpt
operator|->
name|map
operator|=
name|NULL
expr_stmt|;
name|bkpt
operator|->
name|address
operator|=
name|addr
expr_stmt|;
name|bkpt
operator|->
name|flags
operator|=
name|BKPT_TEMP
expr_stmt|;
name|bkpt
operator|->
name|init_count
operator|=
literal|1
expr_stmt|;
name|bkpt
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|bkpt
operator|->
name|bkpt_inst
operator|=
name|db_get_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|BKPT_SET
argument_list|(
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bkpt
return|;
block|}
end_function

begin_function
name|void
name|db_delete_temp_breakpoint
parameter_list|(
name|bkpt
parameter_list|)
name|db_breakpoint_t
name|bkpt
decl_stmt|;
block|{
name|db_put_value
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|BKPT_SIZE
argument_list|,
name|bkpt
operator|->
name|bkpt_inst
argument_list|)
expr_stmt|;
name|db_breakpoint_free
argument_list|(
name|bkpt
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * List breakpoints.  */
end_comment

begin_function
specifier|static
name|void
name|db_list_breakpoints
parameter_list|()
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_breakpoint_list
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"No breakpoints set\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_printf
argument_list|(
literal|" Map      Count    Address\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|bkpt
operator|=
name|db_breakpoint_list
init|;
name|bkpt
operator|!=
literal|0
condition|;
name|bkpt
operator|=
name|bkpt
operator|->
name|link
control|)
block|{
name|db_printf
argument_list|(
literal|"%s%8x %5d    "
argument_list|,
name|db_map_current
argument_list|(
name|bkpt
operator|->
name|map
argument_list|)
condition|?
literal|"*"
else|:
literal|" "
argument_list|,
name|bkpt
operator|->
name|map
argument_list|,
name|bkpt
operator|->
name|init_count
argument_list|)
expr_stmt|;
name|db_printsym
argument_list|(
name|bkpt
operator|->
name|address
argument_list|,
name|DB_STGY_PROC
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete breakpoint */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_delete_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|boolean_t
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
name|db_delete_breakpoint
argument_list|(
name|db_map_addr
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set breakpoint with skip count */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_breakpoint_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|boolean_t
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
name|count
operator|=
literal|1
expr_stmt|;
name|db_set_breakpoint
argument_list|(
name|db_map_addr
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|db_addr_t
operator|)
name|addr
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* list breakpoints */
end_comment

begin_function
name|void
name|db_listbreak_cmd
parameter_list|(
name|dummy1
parameter_list|,
name|dummy2
parameter_list|,
name|dummy3
parameter_list|,
name|dummy4
parameter_list|)
name|db_expr_t
name|dummy1
decl_stmt|;
name|boolean_t
name|dummy2
decl_stmt|;
name|db_expr_t
name|dummy3
decl_stmt|;
name|char
modifier|*
name|dummy4
decl_stmt|;
block|{
name|db_list_breakpoints
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *	We want ddb to be usable before most of the kernel has been  *	initialized.  In particular, current_thread() or kernel_map  *	(or both) may be null.  */
end_comment

begin_function
name|boolean_t
name|db_map_equal
parameter_list|(
name|map1
parameter_list|,
name|map2
parameter_list|)
name|vm_map_t
name|map1
decl_stmt|,
name|map2
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|map1
operator|==
name|map2
operator|)
operator|||
operator|(
operator|(
name|map1
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|map2
operator|==
name|kernel_map
operator|)
operator|)
operator|||
operator|(
operator|(
name|map1
operator|==
name|kernel_map
operator|)
operator|&&
operator|(
name|map2
operator|==
name|NULL
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|db_map_current
parameter_list|(
name|map
parameter_list|)
name|vm_map_t
name|map
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|thread_t	thread;  	return ((map == NULL) || 		(map == kernel_map) || 		(((thread = current_thread()) != NULL)&& 		 (map == thread->task->map)));
else|#
directive|else
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|vm_map_t
name|db_map_addr
parameter_list|(
name|addr
parameter_list|)
name|vm_offset_t
name|addr
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|thread_t	thread;
comment|/* 	 *	We want to return kernel_map for all 	 *	non-user addresses, even when debugging 	 *	kernel tasks with their own maps. 	 */
block|if ((VM_MIN_ADDRESS<= addr)&& 	    (addr< VM_MAX_ADDRESS)&& 	    ((thread = current_thread()) != NULL)) 	    return thread->task->map; 	else
endif|#
directive|endif
return|return
name|kernel_map
return|;
block|}
end_function

end_unit

