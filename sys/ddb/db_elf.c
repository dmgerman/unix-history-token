begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*	$NetBSD: db_elf.c,v 1.4 1998/05/03 18:49:54 thorpej Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,  * NASA Ames Research Center.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the NetBSD  *	Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its  *    contributors may be used to endorse or promote products derived  *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__ELF__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<machine/db_machdep.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_sym.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_include
include|#
directive|include
file|<machine/elf.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|db_elf_find_strtab
name|__P
argument_list|(
operator|(
name|db_symtab_t
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STAB_TO_SYMSTART
parameter_list|(
name|stab
parameter_list|)
value|((Elf_Sym *)((stab)->start))
end_define

begin_define
define|#
directive|define
name|STAB_TO_SYMEND
parameter_list|(
name|stab
parameter_list|)
value|((Elf_Sym *)((stab)->end))
end_define

begin_define
define|#
directive|define
name|STAB_TO_EHDR
parameter_list|(
name|stab
parameter_list|)
value|((Elf_Ehdr *)((stab)->private))
end_define

begin_define
define|#
directive|define
name|STAB_TO_SHDR
parameter_list|(
name|stab
parameter_list|,
name|e
parameter_list|)
value|((Elf_Shdr *)((stab)->private + (e)->e_shoff))
end_define

begin_function_decl
name|void
name|X_db_sym_init
parameter_list|(
name|void
modifier|*
name|symtab
parameter_list|,
name|void
modifier|*
name|esymtab
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Find the symbol table and strings; tell ddb about them.  */
end_comment

begin_function
name|void
name|X_db_sym_init
parameter_list|(
name|symtab
parameter_list|,
name|esymtab
parameter_list|,
name|name
parameter_list|)
name|void
modifier|*
name|symtab
decl_stmt|;
comment|/* pointer to start of symbol table */
name|void
modifier|*
name|esymtab
decl_stmt|;
comment|/* pointer to end of string table, 				   for checking - rounded up to integer 				   boundary */
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|Elf_Ehdr
modifier|*
name|elf
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shp
decl_stmt|;
name|Elf_Sym
modifier|*
name|symp
decl_stmt|,
modifier|*
name|symtab_start
decl_stmt|,
modifier|*
name|symtab_end
decl_stmt|;
name|char
modifier|*
name|strtab_start
decl_stmt|,
modifier|*
name|strtab_end
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ALIGNED_POINTER
argument_list|(
name|symtab
argument_list|,
name|long
argument_list|)
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"DDB: bad symbol table start address %p\n"
argument_list|,
name|symtab
argument_list|)
expr_stmt|;
return|return;
block|}
name|symtab_start
operator|=
name|symtab_end
operator|=
name|NULL
expr_stmt|;
name|strtab_start
operator|=
name|strtab_end
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * The format of the symbols loaded by the boot program is: 	 * 	 *	Elf exec header 	 *	first section header 	 *	. . . 	 *	. . . 	 *	last section header 	 *	first symbol or string table section 	 *	. . . 	 *	. . . 	 *	last symbol or string table section 	 */
comment|/* 	 * Validate the Elf header. 	 */
name|elf
operator|=
operator|(
name|Elf_Ehdr
operator|*
operator|)
name|symtab
expr_stmt|;
if|if
condition|(
name|elf
operator|->
name|e_ident
index|[
name|EI_MAG0
index|]
operator|!=
name|ELFMAG0
operator|||
name|elf
operator|->
name|e_ident
index|[
name|EI_MAG1
index|]
operator|!=
name|ELFMAG1
operator|||
name|elf
operator|->
name|e_ident
index|[
name|EI_MAG2
index|]
operator|!=
name|ELFMAG2
operator|||
name|elf
operator|->
name|e_ident
index|[
name|EI_MAG3
index|]
operator|!=
name|ELFMAG3
condition|)
goto|goto
name|badheader
goto|;
if|if
condition|(
operator|!
name|ELF_MACHINE_OK
argument_list|(
name|elf
operator|->
name|e_machine
argument_list|)
condition|)
goto|goto
name|badheader
goto|;
comment|/* 	 * We need to avoid the section header string table (small string 	 * table which names the sections).  We do this by assuming that 	 * the following two conditions will be true: 	 * 	 *	(1) .shstrtab will be smaller than one page. 	 *	(2) .strtab will be larger than one page. 	 * 	 * When we encounter what we think is the .shstrtab, we change 	 * its section type Elf_sht_null so that it will be ignored 	 * later. 	 */
name|shp
operator|=
operator|(
name|Elf_Shdr
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|symtab
operator|+
name|elf
operator|->
name|e_shoff
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shp
index|[
name|i
index|]
operator|.
name|sh_addr
operator|||
name|i
operator|==
name|elf
operator|->
name|e_shstrndx
condition|)
continue|continue;
switch|switch
condition|(
name|shp
index|[
name|i
index|]
operator|.
name|sh_type
condition|)
block|{
case|case
name|SHT_STRTAB
case|:
if|if
condition|(
name|shp
index|[
name|i
index|]
operator|.
name|sh_size
operator|<
name|PAGE_SIZE
condition|)
block|{
name|shp
index|[
name|i
index|]
operator|.
name|sh_type
operator|=
name|SHT_NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strtab_start
operator|!=
name|NULL
condition|)
goto|goto
name|multiple_strtab
goto|;
name|strtab_start
operator|=
operator|(
name|char
operator|*
operator|)
name|symtab
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_offset
expr_stmt|;
name|strtab_end
operator|=
operator|(
name|char
operator|*
operator|)
name|symtab
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_offset
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_size
expr_stmt|;
break|break;
case|case
name|SHT_SYMTAB
case|:
if|if
condition|(
name|symtab_start
operator|!=
name|NULL
condition|)
goto|goto
name|multiple_symtab
goto|;
name|symtab_start
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|symtab
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_offset
operator|)
expr_stmt|;
name|symtab_end
operator|=
operator|(
name|Elf_Sym
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|symtab
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_offset
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_size
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* Ignore all other sections. */
break|break;
block|}
block|}
comment|/* 	 * Now, sanity check the symbols against the string table. 	 */
if|if
condition|(
name|symtab_start
operator|==
name|NULL
operator|||
name|strtab_start
operator|==
name|NULL
operator|||
name|ALIGNED_POINTER
argument_list|(
name|symtab_start
argument_list|,
name|long
argument_list|)
operator|==
literal|0
operator|||
name|ALIGNED_POINTER
argument_list|(
name|strtab_start
argument_list|,
name|long
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|badheader
goto|;
for|for
control|(
name|symp
operator|=
name|symtab_start
init|;
name|symp
operator|<
name|symtab_end
condition|;
name|symp
operator|++
control|)
if|if
condition|(
name|symp
operator|->
name|st_name
operator|+
name|strtab_start
operator|>
name|strtab_end
condition|)
goto|goto
name|badheader
goto|;
comment|/* 	 * Link the symbol table into the debugger. 	 */
name|db_add_symbol_table
argument_list|(
operator|(
name|char
operator|*
operator|)
name|symtab_start
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symtab_end
argument_list|,
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|symtab
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[ preserving %lu bytes of %s symbol table ]\n"
argument_list|,
operator|(
name|u_long
operator|)
name|roundup
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|esymtab
operator|-
operator|(
name|char
operator|*
operator|)
name|symtab
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
name|badheader
label|:
name|printf
argument_list|(
literal|"[ %s symbol table not valid ]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
name|multiple_strtab
label|:
name|printf
argument_list|(
literal|"[ %s has multiple string tables ]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
name|multiple_symtab
label|:
name|printf
argument_list|(
literal|"[ %s has multiple symbol tables ]\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Internal helper function - return a pointer to the string table  * for the current symbol table.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|db_elf_find_strtab
parameter_list|(
name|stab
parameter_list|)
name|db_symtab_t
modifier|*
name|stab
decl_stmt|;
block|{
name|Elf_Ehdr
modifier|*
name|elf
init|=
name|STAB_TO_EHDR
argument_list|(
name|stab
argument_list|)
decl_stmt|;
name|Elf_Shdr
modifier|*
name|shp
init|=
name|STAB_TO_SHDR
argument_list|(
name|stab
argument_list|,
name|elf
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elf
operator|->
name|e_shnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|shp
index|[
name|i
index|]
operator|.
name|sh_type
operator|==
name|SHT_STRTAB
operator|&&
operator|!
name|shp
index|[
name|i
index|]
operator|.
name|sh_addr
operator|&&
name|i
operator|!=
name|elf
operator|->
name|e_shstrndx
condition|)
return|return
operator|(
name|stab
operator|->
name|private
operator|+
name|shp
index|[
name|i
index|]
operator|.
name|sh_offset
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the symbol with the given name.  */
end_comment

begin_function
name|db_sym_t
name|X_db_lookup
parameter_list|(
name|stab
parameter_list|,
name|symstr
parameter_list|)
name|db_symtab_t
modifier|*
name|stab
decl_stmt|;
specifier|const
name|char
modifier|*
name|symstr
decl_stmt|;
block|{
name|Elf_Sym
modifier|*
name|symp
decl_stmt|,
modifier|*
name|symtab_start
decl_stmt|,
modifier|*
name|symtab_end
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
name|symtab_start
operator|=
name|STAB_TO_SYMSTART
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|symtab_end
operator|=
name|STAB_TO_SYMEND
argument_list|(
name|stab
argument_list|)
expr_stmt|;
name|strtab
operator|=
name|db_elf_find_strtab
argument_list|(
name|stab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|db_sym_t
operator|)
literal|0
operator|)
return|;
for|for
control|(
name|symp
operator|=
name|symtab_start
init|;
name|symp
operator|<
name|symtab_end
condition|;
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_name
operator|!=
literal|0
operator|&&
name|db_eqname
argument_list|(
name|strtab
operator|+
name|symp
operator|->
name|st_name
argument_list|,
name|symstr
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|(
name|db_sym_t
operator|)
name|symp
operator|)
return|;
block|}
return|return
operator|(
operator|(
name|db_sym_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Search for the symbol with the given address (matching within the  * provided threshold).  */
end_comment

begin_function
name|db_sym_t
name|X_db_search_symbol
parameter_list|(
name|symtab
parameter_list|,
name|off
parameter_list|,
name|strategy
parameter_list|,
name|diffp
parameter_list|)
name|db_symtab_t
modifier|*
name|symtab
decl_stmt|;
name|db_addr_t
name|off
decl_stmt|;
name|db_strategy_t
name|strategy
decl_stmt|;
name|db_expr_t
modifier|*
name|diffp
decl_stmt|;
comment|/* in/out */
block|{
name|Elf_Sym
modifier|*
name|rsymp
decl_stmt|,
modifier|*
name|symp
decl_stmt|,
modifier|*
name|symtab_start
decl_stmt|,
modifier|*
name|symtab_end
decl_stmt|;
name|db_expr_t
name|diff
init|=
operator|*
name|diffp
decl_stmt|;
name|symtab_start
operator|=
name|STAB_TO_SYMSTART
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|symtab_end
operator|=
name|STAB_TO_SYMEND
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
name|rsymp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|symp
operator|=
name|symtab_start
init|;
name|symp
operator|<
name|symtab_end
condition|;
name|symp
operator|++
control|)
block|{
if|if
condition|(
name|symp
operator|->
name|st_name
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_OBJECT
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
continue|continue;
if|if
condition|(
name|off
operator|>=
name|symp
operator|->
name|st_value
condition|)
block|{
if|if
condition|(
operator|(
name|off
operator|-
name|symp
operator|->
name|st_value
operator|)
operator|<
name|diff
condition|)
block|{
name|diff
operator|=
name|off
operator|-
name|symp
operator|->
name|st_value
expr_stmt|;
name|rsymp
operator|=
name|symp
expr_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strategy
operator|==
name|DB_STGY_PROC
operator|&&
name|ELF_ST_TYPE
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|==
name|STT_FUNC
operator|&&
name|ELF_ST_BIND
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
break|break;
if|if
condition|(
name|strategy
operator|==
name|DB_STGY_ANY
operator|&&
name|ELF_ST_BIND
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|off
operator|-
name|symp
operator|->
name|st_value
operator|)
operator|==
name|diff
condition|)
block|{
if|if
condition|(
name|rsymp
operator|==
name|NULL
condition|)
name|rsymp
operator|=
name|symp
expr_stmt|;
elseif|else
if|if
condition|(
name|ELF_ST_BIND
argument_list|(
name|rsymp
operator|->
name|st_info
argument_list|)
operator|==
name|STB_LOCAL
operator|&&
name|ELF_ST_BIND
argument_list|(
name|symp
operator|->
name|st_info
argument_list|)
operator|!=
name|STB_LOCAL
condition|)
block|{
comment|/* pick the external symbol */
name|rsymp
operator|=
name|symp
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|rsymp
operator|==
name|NULL
condition|)
operator|*
name|diffp
operator|=
name|off
expr_stmt|;
else|else
operator|*
name|diffp
operator|=
name|diff
expr_stmt|;
return|return
operator|(
operator|(
name|db_sym_t
operator|)
name|rsymp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the name and value for a symbol.  */
end_comment

begin_function
name|void
name|X_db_symbol_values
parameter_list|(
name|symtab
parameter_list|,
name|sym
parameter_list|,
name|namep
parameter_list|,
name|valuep
parameter_list|)
name|db_symtab_t
modifier|*
name|symtab
decl_stmt|;
name|db_sym_t
name|sym
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|namep
decl_stmt|;
name|db_expr_t
modifier|*
name|valuep
decl_stmt|;
block|{
name|Elf_Sym
modifier|*
name|symp
init|=
operator|(
name|Elf_Sym
operator|*
operator|)
name|sym
decl_stmt|;
name|char
modifier|*
name|strtab
decl_stmt|;
if|if
condition|(
name|namep
condition|)
block|{
name|strtab
operator|=
name|db_elf_find_strtab
argument_list|(
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|strtab
operator|==
name|NULL
condition|)
operator|*
name|namep
operator|=
name|NULL
expr_stmt|;
else|else
operator|*
name|namep
operator|=
name|strtab
operator|+
name|symp
operator|->
name|st_name
expr_stmt|;
block|}
if|if
condition|(
name|valuep
condition|)
operator|*
name|valuep
operator|=
name|symp
operator|->
name|st_value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return the file and line number of the current program counter  * if we can find the appropriate debugging symbol.  */
end_comment

begin_function
name|boolean_t
name|X_db_line_at_pc
parameter_list|(
name|symtab
parameter_list|,
name|cursym
parameter_list|,
name|filename
parameter_list|,
name|linenum
parameter_list|,
name|off
parameter_list|)
name|db_symtab_t
modifier|*
name|symtab
decl_stmt|;
name|db_sym_t
name|cursym
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename
decl_stmt|;
name|int
modifier|*
name|linenum
decl_stmt|;
name|db_expr_t
name|off
decl_stmt|;
block|{
comment|/* 	 * XXX We don't support this (yet). 	 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns the number of arguments to a function and their  * names if we can find the appropriate debugging symbol.  */
end_comment

begin_function
name|boolean_t
name|X_db_sym_numargs
parameter_list|(
name|symtab
parameter_list|,
name|cursym
parameter_list|,
name|nargp
parameter_list|,
name|argnamep
parameter_list|)
name|db_symtab_t
modifier|*
name|symtab
decl_stmt|;
name|c_db_sym_t
name|cursym
decl_stmt|;
name|int
modifier|*
name|nargp
decl_stmt|;
name|char
modifier|*
modifier|*
name|argnamep
decl_stmt|;
block|{
comment|/* 	 * XXX We don't support this (yet). 	 */
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialization routine for Elf files.  */
end_comment

begin_decl_stmt
specifier|extern
name|void
modifier|*
name|ksym_start
decl_stmt|,
modifier|*
name|ksym_end
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|kdb_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|ksym_end
operator|>
name|ksym_start
condition|)
name|X_db_sym_init
argument_list|(
name|ksym_start
argument_list|,
name|ksym_end
argument_list|,
literal|"kernel"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

