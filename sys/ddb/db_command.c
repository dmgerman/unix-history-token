begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Author: David B. Golub, Carnegie Mellon University  *	Date:	7/90  */
end_comment

begin_comment
comment|/*  * Command dispatcher.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_command.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/setjmp.h>
end_include

begin_comment
comment|/*  * Exported global variables  */
end_comment

begin_decl_stmt
name|int
name|db_cmd_loop_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_last_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_prev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_next
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_dump
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_fncall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_gdb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_halt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_reset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_stack_trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_stack_trace_active
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_stack_trace_all
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_watchdog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'show' commands  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_show_active_cmds
index|[]
init|=
block|{
block|{
literal|"trace"
block|,
name|db_stack_trace_active
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command_table
name|db_show_active_table
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|db_show_active_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_show_all_cmds
index|[]
init|=
block|{
block|{
literal|"trace"
block|,
name|db_stack_trace_all
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command_table
name|db_show_all_table
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|db_show_all_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_show_cmds
index|[]
init|=
block|{
block|{
literal|"active"
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|db_show_active_table
block|}
block|,
block|{
literal|"all"
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|db_show_all_table
block|}
block|,
block|{
literal|"registers"
block|,
name|db_show_regs
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"breaks"
block|,
name|db_listbreak_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"threads"
block|,
name|db_show_threads
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command_table
name|db_show_table
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|db_show_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_cmds
index|[]
init|=
block|{
block|{
literal|"print"
block|,
name|db_print_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"p"
block|,
name|db_print_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"examine"
block|,
name|db_examine_cmd
block|,
name|CS_SET_DOT
block|,
name|NULL
block|}
block|,
block|{
literal|"x"
block|,
name|db_examine_cmd
block|,
name|CS_SET_DOT
block|,
name|NULL
block|}
block|,
block|{
literal|"search"
block|,
name|db_search_cmd
block|,
name|CS_OWN
operator||
name|CS_SET_DOT
block|,
name|NULL
block|}
block|,
block|{
literal|"set"
block|,
name|db_set_cmd
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"write"
block|,
name|db_write_cmd
block|,
name|CS_MORE
operator||
name|CS_SET_DOT
block|,
name|NULL
block|}
block|,
block|{
literal|"w"
block|,
name|db_write_cmd
block|,
name|CS_MORE
operator||
name|CS_SET_DOT
block|,
name|NULL
block|}
block|,
block|{
literal|"delete"
block|,
name|db_delete_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"d"
block|,
name|db_delete_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dump"
block|,
name|db_dump
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"break"
block|,
name|db_breakpoint_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"b"
block|,
name|db_breakpoint_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"dwatch"
block|,
name|db_deletewatch_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"watch"
block|,
name|db_watchpoint_cmd
block|,
name|CS_MORE
block|,
name|NULL
block|}
block|,
block|{
literal|"dhwatch"
block|,
name|db_deletehwatch_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"hwatch"
block|,
name|db_hwatchpoint_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"step"
block|,
name|db_single_step_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"s"
block|,
name|db_single_step_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"continue"
block|,
name|db_continue_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"c"
block|,
name|db_continue_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"until"
block|,
name|db_trace_until_call_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"next"
block|,
name|db_trace_until_matching_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"match"
block|,
name|db_trace_until_matching_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"trace"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"t"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
comment|/* XXX alias for active trace */
block|{
literal|"acttrace"
block|,
name|db_stack_trace_active
block|,
literal|0
block|,
name|NULL
block|}
block|,
comment|/* XXX alias for all trace */
block|{
literal|"alltrace"
block|,
name|db_stack_trace_all
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"where"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"bt"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"call"
block|,
name|db_fncall
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"show"
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|db_show_table
block|}
block|,
block|{
literal|"ps"
block|,
name|db_ps
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"gdb"
block|,
name|db_gdb
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"halt"
block|,
name|db_halt
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"reboot"
block|,
name|db_reset
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"reset"
block|,
name|db_reset
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"kill"
block|,
name|db_kill
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"watchdog"
block|,
name|db_watchdog
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"thread"
block|,
name|db_set_thread
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"run"
block|,
name|db_run_cmd
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"script"
block|,
name|db_script_cmd
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"scripts"
block|,
name|db_scripts_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
literal|"unscript"
block|,
name|db_unscript_cmd
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"capture"
block|,
name|db_capture_cmd
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"textdump"
block|,
name|db_textdump_cmd
block|,
name|CS_OWN
block|,
name|NULL
block|}
block|,
block|{
literal|"findstack"
block|,
name|db_findstack_cmd
block|,
literal|0
block|,
name|NULL
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command_table
name|db_cmd_table
init|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|db_cmd_table
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
modifier|*
name|db_last_command
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * if 'ed' style: 'dot' is set at start of last item printed,  * and '+' points to next line.  * Otherwise: 'dot' points to next item, '..' points to last.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|db_ed_style
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Utility routine - discard tokens through end-of-line.  */
end_comment

begin_function
name|void
name|db_skip_to_eol
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
do|do
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
name|tEOL
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Results of command search.  */
end_comment

begin_define
define|#
directive|define
name|CMD_UNIQUE
value|0
end_define

begin_define
define|#
directive|define
name|CMD_FOUND
value|1
end_define

begin_define
define|#
directive|define
name|CMD_NONE
value|2
end_define

begin_define
define|#
directive|define
name|CMD_AMBIGUOUS
value|3
end_define

begin_define
define|#
directive|define
name|CMD_HELP
value|4
end_define

begin_function_decl
specifier|static
name|void
name|db_cmd_match
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|command
modifier|*
name|cmd
parameter_list|,
name|struct
name|command
modifier|*
modifier|*
name|cmdp
parameter_list|,
name|int
modifier|*
name|resultp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_cmd_list
parameter_list|(
name|struct
name|command_table
modifier|*
name|table
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|db_cmd_search
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|command_table
modifier|*
name|table
parameter_list|,
name|struct
name|command
modifier|*
modifier|*
name|cmdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_command
parameter_list|(
name|struct
name|command
modifier|*
modifier|*
name|last_cmdp
parameter_list|,
name|struct
name|command_table
modifier|*
name|cmd_table
parameter_list|,
name|int
name|dopager
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize the command lists from the static tables.  */
end_comment

begin_function
name|void
name|db_command_init
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|db_cmds
argument_list|)
condition|;
name|i
operator|++
control|)
name|db_command_register
argument_list|(
operator|&
name|db_cmd_table
argument_list|,
operator|&
name|db_cmds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|db_show_cmds
argument_list|)
condition|;
name|i
operator|++
control|)
name|db_command_register
argument_list|(
operator|&
name|db_show_table
argument_list|,
operator|&
name|db_show_cmds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|db_show_active_cmds
argument_list|)
condition|;
name|i
operator|++
control|)
name|db_command_register
argument_list|(
operator|&
name|db_show_active_table
argument_list|,
operator|&
name|db_show_active_cmds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|db_show_all_cmds
argument_list|)
condition|;
name|i
operator|++
control|)
name|db_command_register
argument_list|(
operator|&
name|db_show_all_table
argument_list|,
operator|&
name|db_show_all_cmds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Register a command.  */
end_comment

begin_function
name|void
name|db_command_register
parameter_list|(
name|struct
name|command_table
modifier|*
name|list
parameter_list|,
name|struct
name|command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|command
modifier|*
name|c
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|last
operator|=
name|NULL
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|c
argument_list|,
argument|list
argument_list|,
argument|next
argument_list|)
block|{
name|int
name|n
init|=
name|strcmp
argument_list|(
name|cmd
operator|->
name|name
argument_list|,
name|c
operator|->
name|name
argument_list|)
decl_stmt|;
comment|/* Check that the command is not already present. */
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: Warning, the command \"%s\" already exists;"
literal|" ignoring request\n"
argument_list|,
name|__func__
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* NB: keep list sorted lexicographically */
name|LIST_INSERT_BEFORE
argument_list|(
name|c
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
name|last
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|last
operator|==
name|NULL
condition|)
name|LIST_INSERT_HEAD
argument_list|(
name|list
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
else|else
name|LIST_INSERT_AFTER
argument_list|(
name|last
argument_list|,
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a command previously registered with db_command_register.  */
end_comment

begin_function
name|void
name|db_command_unregister
parameter_list|(
name|struct
name|command_table
modifier|*
name|list
parameter_list|,
name|struct
name|command
modifier|*
name|cmd
parameter_list|)
block|{
name|struct
name|command
modifier|*
name|c
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|c
argument_list|,
argument|list
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|cmd
operator|==
name|c
condition|)
block|{
name|LIST_REMOVE
argument_list|(
name|cmd
argument_list|,
name|next
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* NB: intentionally quiet */
block|}
end_function

begin_comment
comment|/*  * Helper function to match a single command.  */
end_comment

begin_function
specifier|static
name|void
name|db_cmd_match
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|command
modifier|*
name|cmd
parameter_list|,
name|struct
name|command
modifier|*
modifier|*
name|cmdp
parameter_list|,
name|int
modifier|*
name|resultp
parameter_list|)
block|{
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|lp
operator|=
name|name
expr_stmt|;
name|rp
operator|=
name|cmd
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|)
operator|==
operator|*
name|rp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* complete match */
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|resultp
operator|=
name|CMD_UNIQUE
expr_stmt|;
return|return;
block|}
name|lp
operator|++
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* end of name, not end of command - 		   partial match */
if|if
condition|(
operator|*
name|resultp
operator|==
name|CMD_FOUND
condition|)
block|{
operator|*
name|resultp
operator|=
name|CMD_AMBIGUOUS
expr_stmt|;
comment|/* but keep looking for a full match - 			   this lets us match single letters */
block|}
else|else
block|{
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|resultp
operator|=
name|CMD_FOUND
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search for command prefix.  */
end_comment

begin_function
specifier|static
name|int
name|db_cmd_search
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|command_table
modifier|*
name|table
parameter_list|,
name|struct
name|command
modifier|*
modifier|*
name|cmdp
parameter_list|)
block|{
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|int
name|result
init|=
name|CMD_NONE
decl_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cmd
argument_list|,
argument|table
argument_list|,
argument|next
argument_list|)
block|{
name|db_cmd_match
argument_list|(
name|name
argument_list|,
name|cmd
argument_list|,
name|cmdp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|CMD_UNIQUE
condition|)
break|break;
block|}
if|if
condition|(
name|result
operator|==
name|CMD_NONE
condition|)
block|{
comment|/* check for 'help' */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'h'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'l'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
name|result
operator|=
name|CMD_HELP
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_cmd_list
parameter_list|(
name|struct
name|command_table
modifier|*
name|table
parameter_list|)
block|{
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|int
name|have_subcommands
decl_stmt|;
name|have_subcommands
operator|=
literal|0
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cmd
argument_list|,
argument|table
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|more
operator|!=
name|NULL
condition|)
name|have_subcommands
operator|++
expr_stmt|;
name|db_printf
argument_list|(
literal|"%-16s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|db_end_line
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|have_subcommands
operator|>
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"\nThe following have subcommands; append \"help\" "
literal|"to list (e.g. \"show help\"):\n"
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|cmd
argument_list|,
argument|table
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|cmd
operator|->
name|more
operator|==
name|NULL
condition|)
continue|continue;
name|db_printf
argument_list|(
literal|"%-16s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|db_end_line
argument_list|(
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|db_command
parameter_list|(
name|struct
name|command
modifier|*
modifier|*
name|last_cmdp
parameter_list|,
name|struct
name|command_table
modifier|*
name|cmd_table
parameter_list|,
name|int
name|dopager
parameter_list|)
block|{
name|struct
name|command
modifier|*
name|cmd
init|=
name|NULL
decl_stmt|;
name|int
name|t
decl_stmt|;
name|char
name|modif
index|[
name|TOK_STRING_SIZE
index|]
decl_stmt|;
name|db_expr_t
name|addr
decl_stmt|,
name|count
decl_stmt|;
name|bool
name|have_addr
init|=
name|false
decl_stmt|;
name|int
name|result
decl_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tEOL
condition|)
block|{
comment|/* empty line repeats last command, at 'next' */
name|cmd
operator|=
operator|*
name|last_cmdp
expr_stmt|;
name|addr
operator|=
operator|(
name|db_expr_t
operator|)
name|db_next
expr_stmt|;
name|have_addr
operator|=
name|false
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|modif
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|tEXCL
condition|)
block|{
name|db_fncall
argument_list|(
operator|(
name|db_expr_t
operator|)
literal|0
argument_list|,
operator|(
name|bool
operator|)
name|false
argument_list|,
operator|(
name|db_expr_t
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 	     * Search for command 	     */
while|while
condition|(
name|cmd_table
condition|)
block|{
name|result
operator|=
name|db_cmd_search
argument_list|(
name|db_tok_string
argument_list|,
name|cmd_table
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|CMD_NONE
case|:
name|db_printf
argument_list|(
literal|"No such command; use \"help\" "
literal|"to list available commands\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
case|case
name|CMD_AMBIGUOUS
case|:
name|db_printf
argument_list|(
literal|"Ambiguous\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
case|case
name|CMD_HELP
case|:
if|if
condition|(
name|cmd_table
operator|==
operator|&
name|db_cmd_table
condition|)
block|{
name|db_printf
argument_list|(
literal|"This is ddb(4), the kernel debugger; "
literal|"see http://man.freebsd.org/ddb/4 for help.\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Use \"bt\" for backtrace, \"dump\" for "
literal|"kernel core dump, \"reset\" to reboot.\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"Available commands:\n"
argument_list|)
expr_stmt|;
block|}
name|db_cmd_list
argument_list|(
name|cmd_table
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|cmd_table
operator|=
name|cmd
operator|->
name|more
operator|)
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"Subcommand required; "
literal|"available subcommands:\n"
argument_list|)
expr_stmt|;
name|db_cmd_list
argument_list|(
name|cmd_table
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|flag
operator|&
name|CS_OWN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Standard syntax: 		 * command [/modifier] [addr] [,count] 		 */
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tSLASH
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad modifier\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|db_strcpy
argument_list|(
name|modif
argument_list|,
name|db_tok_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|modif
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|db_expression
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
block|{
name|db_dot
operator|=
operator|(
name|db_addr_t
operator|)
name|addr
expr_stmt|;
name|db_last_addr
operator|=
name|db_dot
expr_stmt|;
name|have_addr
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
operator|(
name|db_expr_t
operator|)
name|db_dot
expr_stmt|;
name|have_addr
operator|=
name|false
expr_stmt|;
block|}
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|count
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Count missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|flag
operator|&
name|CS_MORE
operator|)
operator|==
literal|0
condition|)
block|{
name|db_skip_to_eol
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|*
name|last_cmdp
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|NULL
condition|)
block|{
comment|/* 	     * Execute the command. 	     */
if|if
condition|(
name|dopager
condition|)
name|db_enable_pager
argument_list|()
expr_stmt|;
else|else
name|db_disable_pager
argument_list|()
expr_stmt|;
call|(
modifier|*
name|cmd
operator|->
name|fcn
call|)
argument_list|(
name|addr
argument_list|,
name|have_addr
argument_list|,
name|count
argument_list|,
name|modif
argument_list|)
expr_stmt|;
if|if
condition|(
name|dopager
condition|)
name|db_disable_pager
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flag
operator|&
name|CS_SET_DOT
condition|)
block|{
comment|/* 		 * If command changes dot, set dot to 		 * previous address displayed (if 'ed' style). 		 */
if|if
condition|(
name|db_ed_style
condition|)
block|{
name|db_dot
operator|=
name|db_prev
expr_stmt|;
block|}
else|else
block|{
name|db_dot
operator|=
name|db_next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If command does not change dot, 		 * set 'next' location to be the same. 		 */
name|db_next
operator|=
name|db_dot
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * At least one non-optional command must be implemented using  * DB_COMMAND() so that db_cmd_set gets created.  Here is one.  */
end_comment

begin_macro
name|DB_COMMAND
argument_list|(
argument|panic
argument_list|,
argument|db_panic
argument_list|)
end_macro

begin_block
block|{
name|db_disable_pager
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"from debugger"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|db_command_loop
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize 'prev' and 'next' to dot. 	 */
name|db_prev
operator|=
name|db_dot
expr_stmt|;
name|db_next
operator|=
name|db_dot
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|db_cmd_loop_done
condition|)
block|{
if|if
condition|(
name|db_print_position
argument_list|()
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"db> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|db_read_line
argument_list|()
expr_stmt|;
name|db_command
argument_list|(
operator|&
name|db_last_command
argument_list|,
operator|&
name|db_cmd_table
argument_list|,
comment|/* dopager */
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Execute a command on behalf of a script.  The caller is responsible for  * making sure that the command string is< DB_MAXLINE or it will be  * truncated.  *  * XXXRW: Runs by injecting faked input into DDB input stream; it would be  * nicer to use an alternative approach that didn't mess with the previous  * command buffer.  */
end_comment

begin_function
name|void
name|db_command_script
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|)
block|{
name|db_prev
operator|=
name|db_next
operator|=
name|db_dot
expr_stmt|;
name|db_inject_line
argument_list|(
name|command
argument_list|)
expr_stmt|;
name|db_command
argument_list|(
operator|&
name|db_last_command
argument_list|,
operator|&
name|db_cmd_table
argument_list|,
comment|/* dopager */
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_error
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
condition|)
name|db_printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
name|kdb_reenter
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_dump
parameter_list|(
name|db_expr_t
name|dummy
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
name|textdump_pending
condition|)
block|{
name|db_printf
argument_list|(
literal|"textdump_pending set.\n"
literal|"run \"textdump unset\" first or \"textdump dump\" for a textdump.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|error
operator|=
name|doadump
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|db_printf
argument_list|(
literal|"Cannot dump: "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|EBUSY
case|:
name|db_printf
argument_list|(
literal|"debugger got invoked while dumping.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ENXIO
case|:
name|db_printf
argument_list|(
literal|"no dump device specified.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|db_printf
argument_list|(
literal|"unknown error (error=%d).\n"
argument_list|,
name|error
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Call random function:  * !expr(arg,arg,arg)  */
end_comment

begin_comment
comment|/* The generic implementation supports a maximum of 10 arguments. */
end_comment

begin_typedef
typedef|typedef
name|db_expr_t
name|__db_f
parameter_list|(
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|__inline
name|int
name|db_fncall_generic
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
modifier|*
name|rv
parameter_list|,
name|int
name|nargs
parameter_list|,
name|db_expr_t
name|args
index|[]
parameter_list|)
block|{
name|__db_f
modifier|*
name|f
init|=
operator|(
name|__db_f
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|10
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many arguments (max 10)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|rv
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|,
name|args
index|[
literal|5
index|]
argument_list|,
name|args
index|[
literal|6
index|]
argument_list|,
name|args
index|[
literal|7
index|]
argument_list|,
name|args
index|[
literal|8
index|]
argument_list|,
name|args
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_fncall
parameter_list|(
name|db_expr_t
name|dummy1
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|db_expr_t
name|fn_addr
decl_stmt|;
name|db_expr_t
name|args
index|[
name|DB_MAXARGS
index|]
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|db_expr_t
name|retval
decl_stmt|;
name|int
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|fn_addr
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad function\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tLPAREN
condition|)
block|{
if|if
condition|(
name|db_expression
argument_list|(
operator|&
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|nargs
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|db_read_token
argument_list|()
operator|)
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
name|nargs
operator|==
name|DB_MAXARGS
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many arguments (max %d)\n"
argument_list|,
name|DB_MAXARGS
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|args
index|[
name|nargs
index|]
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Argument missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|nargs
operator|++
expr_stmt|;
block|}
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db_read_token
argument_list|()
operator|!=
name|tRPAREN
condition|)
block|{
name|db_printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|db_skip_to_eol
argument_list|()
expr_stmt|;
name|db_disable_pager
argument_list|()
expr_stmt|;
if|if
condition|(
name|DB_CALL
argument_list|(
name|fn_addr
argument_list|,
operator|&
name|retval
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|"= %#lr\n"
argument_list|,
operator|(
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_halt
parameter_list|(
name|db_expr_t
name|dummy
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|cpu_halt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_kill
parameter_list|(
name|db_expr_t
name|dummy1
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|db_expr_t
name|old_radix
decl_stmt|,
name|pid
decl_stmt|,
name|sig
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|DB_ERROR
parameter_list|(
name|f
parameter_list|)
value|do { db_printf f; db_flush_lex(); goto out; } while (0)
comment|/* 	 * PIDs and signal numbers are typically represented in base 	 * 10, so make that the default here.  It can, of course, be 	 * overridden by specifying a prefix. 	 */
name|old_radix
operator|=
name|db_radix
expr_stmt|;
name|db_radix
operator|=
literal|10
expr_stmt|;
comment|/* Retrieve arguments. */
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|sig
argument_list|)
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Missing signal number\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|pid
argument_list|)
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Missing process ID\n"
operator|)
argument_list|)
expr_stmt|;
name|db_skip_to_eol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|_SIG_VALID
argument_list|(
name|sig
argument_list|)
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Signal number out of range\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the process in question.  allproc_lock is not needed 	 * since we're in DDB. 	 */
comment|/* sx_slock(&allproc_lock); */
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
break|break;
comment|/* sx_sunlock(&allproc_lock); */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Can't find process with pid %ld\n"
operator|,
operator|(
name|long
operator|)
name|pid
operator|)
argument_list|)
expr_stmt|;
comment|/* If it's already locked, bail; otherwise, do the deed. */
if|if
condition|(
name|PROC_TRYLOCK
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Can't lock process with pid %ld\n"
operator|,
operator|(
name|long
operator|)
name|pid
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|pksignal
argument_list|(
name|p
argument_list|,
name|sig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|db_radix
operator|=
name|old_radix
expr_stmt|;
undef|#
directive|undef
name|DB_ERROR
block|}
end_function

begin_comment
comment|/*  * Reboot.  In case there is an additional argument, take it as delay in  * seconds.  Default to 15s if we cannot parse it and make sure we will  * never wait longer than 1 week.  Some code is similar to  * kern_shutdown.c:shutdown_panic().  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DB_RESET_MAXDELAY
end_ifndef

begin_define
define|#
directive|define
name|DB_RESET_MAXDELAY
value|(3600 * 24 * 7)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|db_reset
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|bool
name|have_addr
parameter_list|,
name|db_expr_t
name|count
name|__unused
parameter_list|,
name|char
modifier|*
name|modif
name|__unused
parameter_list|)
block|{
name|int
name|delay
decl_stmt|,
name|loop
decl_stmt|;
if|if
condition|(
name|have_addr
condition|)
block|{
name|delay
operator|=
operator|(
name|int
operator|)
name|db_hex2dec
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* If we parse to fail, use 15s. */
if|if
condition|(
name|delay
operator|==
operator|-
literal|1
condition|)
name|delay
operator|=
literal|15
expr_stmt|;
comment|/* Cap at one week. */
if|if
condition|(
operator|(
name|uintmax_t
operator|)
name|delay
operator|>
operator|(
name|uintmax_t
operator|)
name|DB_RESET_MAXDELAY
condition|)
name|delay
operator|=
name|DB_RESET_MAXDELAY
expr_stmt|;
name|db_printf
argument_list|(
literal|"Automatic reboot in %d seconds - "
literal|"press a key on the console to abort\n"
argument_list|,
name|delay
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
name|delay
operator|*
literal|10
init|;
name|loop
operator|>
literal|0
condition|;
operator|--
name|loop
control|)
block|{
name|DELAY
argument_list|(
literal|1000
operator|*
literal|100
argument_list|)
expr_stmt|;
comment|/* 1/10th second */
comment|/* Did user type a key? */
if|if
condition|(
name|cncheckc
argument_list|()
operator|!=
operator|-
literal|1
condition|)
return|return;
block|}
block|}
name|cpu_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_watchdog
parameter_list|(
name|db_expr_t
name|dummy1
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|db_expr_t
name|old_radix
decl_stmt|,
name|tout
decl_stmt|;
name|int
name|err
decl_stmt|,
name|i
decl_stmt|;
name|old_radix
operator|=
name|db_radix
expr_stmt|;
name|db_radix
operator|=
literal|10
expr_stmt|;
name|err
operator|=
name|db_expression
argument_list|(
operator|&
name|tout
argument_list|)
expr_stmt|;
name|db_skip_to_eol
argument_list|()
expr_stmt|;
name|db_radix
operator|=
name|old_radix
expr_stmt|;
comment|/* If no argument is provided the watchdog will just be disabled. */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"No argument provided, disabling watchdog\n"
argument_list|)
expr_stmt|;
name|tout
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tout
operator|&
name|WD_INTERVAL
operator|)
operator|==
name|WD_TO_NEVER
condition|)
block|{
name|db_error
argument_list|(
literal|"Out of range watchdog interval\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|EVENTHANDLER_INVOKE
argument_list|(
name|watchdog_list
argument_list|,
name|tout
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_gdb
parameter_list|(
name|db_expr_t
name|dummy1
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
if|if
condition|(
name|kdb_dbbe_select
argument_list|(
literal|"gdb"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"The remote GDB backend could not be selected.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark that we are done in the debugger.  kdb_trap() 	 * should re-enter with the new backend. 	 */
name|db_cmd_loop_done
operator|=
literal|1
expr_stmt|;
name|db_printf
argument_list|(
literal|"(ctrl-c will return control to ddb)\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_stack_trace
parameter_list|(
name|db_expr_t
name|tid
parameter_list|,
name|bool
name|hastid
parameter_list|,
name|db_expr_t
name|count
parameter_list|,
name|char
modifier|*
name|modif
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|db_expr_t
name|radix
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|t
decl_stmt|;
comment|/* 	 * We parse our own arguments. We don't like the default radix. 	 */
name|radix
operator|=
name|db_radix
expr_stmt|;
name|db_radix
operator|=
literal|10
expr_stmt|;
name|hastid
operator|=
name|db_expression
argument_list|(
operator|&
name|tid
argument_list|)
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|count
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Count missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|db_skip_to_eol
argument_list|()
expr_stmt|;
name|db_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|hastid
condition|)
block|{
name|td
operator|=
name|kdb_thr_lookup
argument_list|(
operator|(
name|lwpid_t
operator|)
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|kdb_thr_from_pid
argument_list|(
operator|(
name|pid_t
operator|)
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"Thread %d not found\n"
argument_list|,
operator|(
name|int
operator|)
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|td
operator|=
name|kdb_thread
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|!=
name|NULL
condition|)
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
else|else
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|db_printf
argument_list|(
literal|"Tracing pid %d tid %ld td %p\n"
argument_list|,
name|pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|db_trace_thread
argument_list|(
name|td
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_db_stack_trace_all
parameter_list|(
name|bool
name|active_only
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|jmp_buf
name|jb
decl_stmt|;
name|void
modifier|*
name|prev_jb
decl_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
name|prev_jb
operator|=
name|kdb_jmpbuf
argument_list|(
name|jb
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
if|if
condition|(
name|td
operator|->
name|td_state
operator|==
name|TDS_RUNNING
condition|)
name|db_printf
argument_list|(
literal|"\nTracing command %s pid %d"
literal|" tid %ld td %p (CPU %d)\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|td
argument_list|,
name|td
operator|->
name|td_oncpu
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|active_only
condition|)
continue|continue;
else|else
name|db_printf
argument_list|(
literal|"\nTracing command %s pid %d"
literal|" tid %ld td %p\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|db_trace_thread
argument_list|(
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
block|{
name|kdb_jmpbuf
argument_list|(
name|prev_jb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|kdb_jmpbuf
argument_list|(
name|prev_jb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|db_stack_trace_active
parameter_list|(
name|db_expr_t
name|dummy
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|_db_stack_trace_all
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_stack_trace_all
parameter_list|(
name|db_expr_t
name|dummy
parameter_list|,
name|bool
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|_db_stack_trace_all
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take the parsed expression value from the command line that was parsed  * as a hexadecimal value and convert it as if the expression was parsed  * as a decimal value.  Returns -1 if the expression was not a valid  * decimal value.  */
end_comment

begin_function
name|db_expr_t
name|db_hex2dec
parameter_list|(
name|db_expr_t
name|expr
parameter_list|)
block|{
name|uintptr_t
name|x
decl_stmt|,
name|y
decl_stmt|;
name|db_expr_t
name|val
decl_stmt|;
name|y
operator|=
literal|1
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|expr
expr_stmt|;
while|while
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|x
operator|%
literal|16
operator|>
literal|9
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|val
operator|+=
operator|(
name|x
operator|%
literal|16
operator|)
operator|*
operator|(
name|y
operator|)
expr_stmt|;
name|x
operator|>>=
literal|4
expr_stmt|;
name|y
operator|*=
literal|10
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

end_unit

