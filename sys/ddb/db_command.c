begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *   * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *   * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS   * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *   * Carnegie Mellon requests users of this software to return to  *   *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *   * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  *  *	$Id: db_command.c,v 1.6 1994/08/13 03:49:16 wollman Exp $  */
end_comment

begin_comment
comment|/*  *	Author: David B. Golub, Carnegie Mellon University  *	Date:	7/90  */
end_comment

begin_comment
comment|/*  * Command dispatcher.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/*  * Exported global variables  */
end_comment

begin_decl_stmt
name|boolean_t
name|db_cmd_loop_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|db_jmpbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_last_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_prev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * if 'ed' style: 'dot' is set at start of last item printed,  * and '+' points to next line.  * Otherwise: 'dot' points to next item, '..' points to last.  */
end_comment

begin_decl_stmt
name|boolean_t
name|db_ed_style
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Utility routine - discard tokens through end-of-line.  */
end_comment

begin_function
name|void
name|db_skip_to_eol
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
do|do
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
name|tEOL
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Command table  */
end_comment

begin_struct
struct|struct
name|command
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* command name */
name|void
function_decl|(
modifier|*
name|fcn
function_decl|)
parameter_list|()
function_decl|;
comment|/* function to call */
name|int
name|flag
decl_stmt|;
comment|/* extra info: */
define|#
directive|define
name|CS_OWN
value|0x1
comment|/* non-standard syntax */
define|#
directive|define
name|CS_MORE
value|0x2
comment|/* standard syntax, but may have other 				       words at end */
define|#
directive|define
name|CS_SET_DOT
value|0x100
comment|/* set dot after command */
name|struct
name|command
modifier|*
name|more
decl_stmt|;
comment|/* another level of command */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Results of command search.  */
end_comment

begin_define
define|#
directive|define
name|CMD_UNIQUE
value|0
end_define

begin_define
define|#
directive|define
name|CMD_FOUND
value|1
end_define

begin_define
define|#
directive|define
name|CMD_NONE
value|2
end_define

begin_define
define|#
directive|define
name|CMD_AMBIGUOUS
value|3
end_define

begin_define
define|#
directive|define
name|CMD_HELP
value|4
end_define

begin_comment
comment|/*  * Search for command prefix.  */
end_comment

begin_function
name|int
name|db_cmd_search
parameter_list|(
name|name
parameter_list|,
name|table
parameter_list|,
name|cmdp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|command
modifier|*
name|table
decl_stmt|;
name|struct
name|command
modifier|*
modifier|*
name|cmdp
decl_stmt|;
comment|/* out */
block|{
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|int
name|result
init|=
name|CMD_NONE
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|table
init|;
name|cmd
operator|->
name|name
operator|!=
literal|0
condition|;
name|cmd
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|char
modifier|*
name|rp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|lp
operator|=
name|name
expr_stmt|;
name|rp
operator|=
name|cmd
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|)
operator|==
operator|*
name|rp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* complete match */
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
return|return
operator|(
name|CMD_UNIQUE
operator|)
return|;
block|}
name|lp
operator|++
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* end of name, not end of command - 		   partial match */
if|if
condition|(
name|result
operator|==
name|CMD_FOUND
condition|)
block|{
name|result
operator|=
name|CMD_AMBIGUOUS
expr_stmt|;
comment|/* but keep looking for a full match - 		       this lets us match single letters */
block|}
else|else
block|{
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
name|result
operator|=
name|CMD_FOUND
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|result
operator|==
name|CMD_NONE
condition|)
block|{
comment|/* check for 'help' */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'h'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'l'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
name|result
operator|=
name|CMD_HELP
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_cmd_list
parameter_list|(
name|table
parameter_list|)
name|struct
name|command
modifier|*
name|table
decl_stmt|;
block|{
specifier|register
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|table
init|;
name|cmd
operator|->
name|name
operator|!=
literal|0
condition|;
name|cmd
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|"%-12s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|db_end_line
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|db_command
parameter_list|(
name|last_cmdp
parameter_list|,
name|cmd_table
parameter_list|)
name|struct
name|command
modifier|*
modifier|*
name|last_cmdp
decl_stmt|;
comment|/* IN_OUT */
name|struct
name|command
modifier|*
name|cmd_table
decl_stmt|;
block|{
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|int
name|t
decl_stmt|;
name|char
name|modif
index|[
name|TOK_STRING_SIZE
index|]
decl_stmt|;
name|db_expr_t
name|addr
decl_stmt|,
name|count
decl_stmt|;
name|boolean_t
name|have_addr
init|=
name|FALSE
decl_stmt|;
name|int
name|result
decl_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tEOL
condition|)
block|{
comment|/* empty line repeats last command, at 'next' */
name|cmd
operator|=
operator|*
name|last_cmdp
expr_stmt|;
name|addr
operator|=
operator|(
name|db_expr_t
operator|)
name|db_next
expr_stmt|;
name|have_addr
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|modif
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|tEXCL
condition|)
block|{
name|void
name|db_fncall
parameter_list|()
function_decl|;
name|db_fncall
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 	     * Search for command 	     */
while|while
condition|(
name|cmd_table
condition|)
block|{
name|result
operator|=
name|db_cmd_search
argument_list|(
name|db_tok_string
argument_list|,
name|cmd_table
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|CMD_NONE
case|:
name|db_printf
argument_list|(
literal|"No such command\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
case|case
name|CMD_AMBIGUOUS
case|:
name|db_printf
argument_list|(
literal|"Ambiguous\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
case|case
name|CMD_HELP
case|:
name|db_cmd_list
argument_list|(
name|cmd_table
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|cmd_table
operator|=
name|cmd
operator|->
name|more
operator|)
operator|!=
literal|0
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_cmd_list
argument_list|(
name|cmd_table
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|flag
operator|&
name|CS_OWN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Standard syntax: 		 * command [/modifier] [addr] [,count] 		 */
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tSLASH
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad modifier\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|db_strcpy
argument_list|(
name|modif
argument_list|,
name|db_tok_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|modif
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|db_expression
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
block|{
name|db_dot
operator|=
operator|(
name|db_addr_t
operator|)
name|addr
expr_stmt|;
name|db_last_addr
operator|=
name|db_dot
expr_stmt|;
name|have_addr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
operator|(
name|db_expr_t
operator|)
name|db_dot
expr_stmt|;
name|have_addr
operator|=
name|FALSE
expr_stmt|;
block|}
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|count
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Count missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|flag
operator|&
name|CS_MORE
operator|)
operator|==
literal|0
condition|)
block|{
name|db_skip_to_eol
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|*
name|last_cmdp
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * Execute the command. 	     */
call|(
modifier|*
name|cmd
operator|->
name|fcn
call|)
argument_list|(
name|addr
argument_list|,
name|have_addr
argument_list|,
name|count
argument_list|,
name|modif
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flag
operator|&
name|CS_SET_DOT
condition|)
block|{
comment|/* 		 * If command changes dot, set dot to 		 * previous address displayed (if 'ed' style). 		 */
if|if
condition|(
name|db_ed_style
condition|)
block|{
name|db_dot
operator|=
name|db_prev
expr_stmt|;
block|}
else|else
block|{
name|db_dot
operator|=
name|db_next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If command does not change dot, 		 * set 'next' location to be the same. 		 */
name|db_next
operator|=
name|db_dot
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * 'show' commands  */
end_comment

begin_decl_stmt
specifier|extern
name|void
name|db_show_one_thread
argument_list|()
decl_stmt|,
name|db_show_all_threads
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|vm_page_print
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* extern void	db_ps(); */
end_comment

begin_function_decl
specifier|extern
name|void
name|ipc_port_print
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|db_show_help
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|command
name|db_show_all_cmds
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ "threads",	db_show_all_threads,	0,	0 }, 	{ "procs",	db_ps,			0,	0 },
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command
name|db_show_cmds
index|[]
init|=
block|{
block|{
literal|"all"
block|,
literal|0
block|,
literal|0
block|,
name|db_show_all_cmds
block|}
block|,
block|{
literal|"registers"
block|,
name|db_show_regs
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"breaks"
block|,
name|db_listbreak_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"watches"
block|,
name|db_listwatch_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{ "thread",	db_show_one_thread,	0,	0 },
endif|#
directive|endif
block|{
literal|"map"
block|,
name|vm_map_print
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"object"
block|,
name|vm_object_print
block|,
literal|0
block|,
literal|0
block|}
block|,
if|#
directive|if
literal|0
block|{ "page",	vm_page_print,		0,	0 },
endif|#
directive|endif
if|#
directive|if
literal|0
block|{ "port",	ipc_port_print,		0,	0 },
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|db_help_cmd
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|db_fncall
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|struct
name|command
name|db_command_table
index|[]
init|=
block|{
block|{
literal|"print"
block|,
name|db_print_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"examine"
block|,
name|db_examine_cmd
block|,
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"x"
block|,
name|db_examine_cmd
block|,
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"search"
block|,
name|db_search_cmd
block|,
name|CS_OWN
operator||
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"set"
block|,
name|db_set_cmd
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"write"
block|,
name|db_write_cmd
block|,
name|CS_MORE
operator||
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
name|db_write_cmd
block|,
name|CS_MORE
operator||
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"delete"
block|,
name|db_delete_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"d"
block|,
name|db_delete_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|db_breakpoint_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"dwatch"
block|,
name|db_deletewatch_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"watch"
block|,
name|db_watchpoint_cmd
block|,
name|CS_MORE
block|,
literal|0
block|}
block|,
block|{
literal|"step"
block|,
name|db_single_step_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"s"
block|,
name|db_single_step_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"continue"
block|,
name|db_continue_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"c"
block|,
name|db_continue_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"until"
block|,
name|db_trace_until_call_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"next"
block|,
name|db_trace_until_matching_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"match"
block|,
name|db_trace_until_matching_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"trace"
block|,
name|db_stack_trace_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"call"
block|,
name|db_fncall
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"show"
block|,
literal|0
block|,
literal|0
block|,
name|db_show_cmds
block|}
block|,
if|#
directive|if
literal|0
block|{ "ps",		db_ps,			0,	0 },
endif|#
directive|endif
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|command
modifier|*
name|db_last_command
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|db_help_cmd
parameter_list|()
block|{
name|struct
name|command
modifier|*
name|cmd
init|=
name|db_command_table
decl_stmt|;
while|while
condition|(
name|cmd
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"%-12s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|db_end_line
argument_list|()
expr_stmt|;
name|cmd
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|db_command_loop
parameter_list|()
block|{
comment|/* 	 * Initialize 'prev' and 'next' to dot. 	 */
name|db_prev
operator|=
name|db_dot
expr_stmt|;
name|db_next
operator|=
name|db_dot
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|db_cmd_loop_done
condition|)
block|{
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|db_jmpbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_print_position
argument_list|()
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"db> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|db_read_line
argument_list|()
expr_stmt|;
name|db_command
argument_list|(
operator|&
name|db_last_command
argument_list|,
name|db_command_table
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|db_error
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
condition|)
name|db_printf
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
name|longjmp
argument_list|(
name|db_jmpbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call random function:  * !expr(arg,arg,arg)  */
end_comment

begin_function
name|void
name|db_fncall
parameter_list|()
block|{
name|db_expr_t
name|fn_addr
decl_stmt|;
define|#
directive|define
name|MAXARGS
value|11
name|db_expr_t
name|args
index|[
name|MAXARGS
index|]
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|db_expr_t
name|retval
decl_stmt|;
name|db_expr_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
name|int
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|fn_addr
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad function\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|func
operator|=
operator|(
name|db_expr_t
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|fn_addr
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tLPAREN
condition|)
block|{
if|if
condition|(
name|db_expression
argument_list|(
operator|&
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|nargs
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|db_read_token
argument_list|()
operator|)
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
name|nargs
operator|==
name|MAXARGS
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many arguments\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|args
index|[
name|nargs
index|]
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Argument missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|nargs
operator|++
expr_stmt|;
block|}
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db_read_token
argument_list|()
operator|!=
name|tRPAREN
condition|)
block|{
name|db_printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|db_skip_to_eol
argument_list|()
expr_stmt|;
while|while
condition|(
name|nargs
operator|<
name|MAXARGS
condition|)
block|{
name|args
index|[
name|nargs
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|retval
operator|=
call|(
modifier|*
name|func
call|)
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|,
name|args
index|[
literal|5
index|]
argument_list|,
name|args
index|[
literal|6
index|]
argument_list|,
name|args
index|[
literal|7
index|]
argument_list|,
name|args
index|[
literal|8
index|]
argument_list|,
name|args
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"%#n\n"
argument_list|,
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

