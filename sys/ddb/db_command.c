begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  */
end_comment

begin_comment
comment|/*  *	Author: David B. Golub, Carnegie Mellon University  *	Date:	7/90  */
end_comment

begin_comment
comment|/*  * Command dispatcher.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker_set.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kdb.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cons.h>
end_include

begin_include
include|#
directive|include
file|<sys/watchdog.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_command.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_output.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpu.h>
end_include

begin_include
include|#
directive|include
file|<machine/setjmp.h>
end_include

begin_comment
comment|/*  * Exported global variables  */
end_comment

begin_decl_stmt
name|boolean_t
name|db_cmd_loop_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_dot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_last_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_prev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_addr_t
name|db_next
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|db_cmd_set
argument_list|,
expr|struct
name|command
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SET_DECLARE
argument_list|(
name|db_show_cmd_set
argument_list|,
expr|struct
name|command
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_fncall
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_gdb
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_halt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_kill
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_reset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_stack_trace
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_stack_trace_all
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|db_cmdfcn_t
name|db_watchdog
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * 'show' commands  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_show_all_cmds
index|[]
init|=
block|{
block|{
literal|"procs"
block|,
name|db_ps
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command_table
name|db_show_all_table
init|=
block|{
name|db_show_all_cmds
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_show_cmds
index|[]
init|=
block|{
block|{
literal|"all"
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|db_show_all_table
block|}
block|,
block|{
literal|"registers"
block|,
name|db_show_regs
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"breaks"
block|,
name|db_listbreak_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"threads"
block|,
name|db_show_threads
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command_table
name|db_show_table
init|=
block|{
name|db_show_cmds
block|,
name|SET_BEGIN
argument_list|(
name|db_show_cmd_set
argument_list|)
block|,
name|SET_LIMIT
argument_list|(
argument|db_show_cmd_set
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
name|db_commands
index|[]
init|=
block|{
block|{
literal|"print"
block|,
name|db_print_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"p"
block|,
name|db_print_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"examine"
block|,
name|db_examine_cmd
block|,
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"x"
block|,
name|db_examine_cmd
block|,
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"search"
block|,
name|db_search_cmd
block|,
name|CS_OWN
operator||
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"set"
block|,
name|db_set_cmd
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"write"
block|,
name|db_write_cmd
block|,
name|CS_MORE
operator||
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"w"
block|,
name|db_write_cmd
block|,
name|CS_MORE
operator||
name|CS_SET_DOT
block|,
literal|0
block|}
block|,
block|{
literal|"delete"
block|,
name|db_delete_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"d"
block|,
name|db_delete_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"break"
block|,
name|db_breakpoint_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"b"
block|,
name|db_breakpoint_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"dwatch"
block|,
name|db_deletewatch_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"watch"
block|,
name|db_watchpoint_cmd
block|,
name|CS_MORE
block|,
literal|0
block|}
block|,
block|{
literal|"dhwatch"
block|,
name|db_deletehwatch_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"hwatch"
block|,
name|db_hwatchpoint_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"step"
block|,
name|db_single_step_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"s"
block|,
name|db_single_step_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"continue"
block|,
name|db_continue_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"c"
block|,
name|db_continue_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"until"
block|,
name|db_trace_until_call_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"next"
block|,
name|db_trace_until_matching_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"match"
block|,
name|db_trace_until_matching_cmd
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"trace"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"t"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"alltrace"
block|,
name|db_stack_trace_all
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"where"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"bt"
block|,
name|db_stack_trace
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"call"
block|,
name|db_fncall
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"show"
block|,
literal|0
block|,
literal|0
block|,
operator|&
name|db_show_table
block|}
block|,
block|{
literal|"ps"
block|,
name|db_ps
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"gdb"
block|,
name|db_gdb
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"halt"
block|,
name|db_halt
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"reboot"
block|,
name|db_reset
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"reset"
block|,
name|db_reset
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"kill"
block|,
name|db_kill
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
literal|"watchdog"
block|,
name|db_watchdog
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|"thread"
block|,
name|db_set_thread
block|,
name|CS_OWN
block|,
literal|0
block|}
block|,
block|{
operator|(
name|char
operator|*
operator|)
literal|0
block|, }
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command_table
name|db_command_table
init|=
block|{
name|db_commands
block|,
name|SET_BEGIN
argument_list|(
name|db_cmd_set
argument_list|)
block|,
name|SET_LIMIT
argument_list|(
argument|db_cmd_set
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|command
modifier|*
name|db_last_command
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * if 'ed' style: 'dot' is set at start of last item printed,  * and '+' points to next line.  * Otherwise: 'dot' points to next item, '..' points to last.  */
end_comment

begin_decl_stmt
specifier|static
name|boolean_t
name|db_ed_style
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Utility routine - discard tokens through end-of-line.  */
end_comment

begin_function
name|void
name|db_skip_to_eol
parameter_list|()
block|{
name|int
name|t
decl_stmt|;
do|do
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|t
operator|!=
name|tEOL
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Results of command search.  */
end_comment

begin_define
define|#
directive|define
name|CMD_UNIQUE
value|0
end_define

begin_define
define|#
directive|define
name|CMD_FOUND
value|1
end_define

begin_define
define|#
directive|define
name|CMD_NONE
value|2
end_define

begin_define
define|#
directive|define
name|CMD_AMBIGUOUS
value|3
end_define

begin_define
define|#
directive|define
name|CMD_HELP
value|4
end_define

begin_function_decl
specifier|static
name|void
name|db_cmd_match
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|command
modifier|*
name|cmd
parameter_list|,
name|struct
name|command
modifier|*
modifier|*
name|cmdp
parameter_list|,
name|int
modifier|*
name|resultp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_cmd_list
parameter_list|(
name|struct
name|command_table
modifier|*
name|table
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|db_cmd_search
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|command_table
modifier|*
name|table
parameter_list|,
name|struct
name|command
modifier|*
modifier|*
name|cmdp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|db_command
parameter_list|(
name|struct
name|command
modifier|*
modifier|*
name|last_cmdp
parameter_list|,
name|struct
name|command_table
modifier|*
name|cmd_table
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Helper function to match a single command.  */
end_comment

begin_function
specifier|static
name|void
name|db_cmd_match
parameter_list|(
name|name
parameter_list|,
name|cmd
parameter_list|,
name|cmdp
parameter_list|,
name|resultp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|struct
name|command
modifier|*
modifier|*
name|cmdp
decl_stmt|;
comment|/* out */
name|int
modifier|*
name|resultp
decl_stmt|;
block|{
name|char
modifier|*
name|lp
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|lp
operator|=
name|name
expr_stmt|;
name|rp
operator|=
name|cmd
operator|->
name|name
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|)
operator|==
operator|*
name|rp
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* complete match */
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|resultp
operator|=
name|CMD_UNIQUE
expr_stmt|;
return|return;
block|}
name|lp
operator|++
expr_stmt|;
name|rp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
comment|/* end of name, not end of command - 		   partial match */
if|if
condition|(
operator|*
name|resultp
operator|==
name|CMD_FOUND
condition|)
block|{
operator|*
name|resultp
operator|=
name|CMD_AMBIGUOUS
expr_stmt|;
comment|/* but keep looking for a full match - 			   this lets us match single letters */
block|}
else|else
block|{
operator|*
name|cmdp
operator|=
name|cmd
expr_stmt|;
operator|*
name|resultp
operator|=
name|CMD_FOUND
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Search for command prefix.  */
end_comment

begin_function
specifier|static
name|int
name|db_cmd_search
parameter_list|(
name|name
parameter_list|,
name|table
parameter_list|,
name|cmdp
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
name|struct
name|command_table
modifier|*
name|table
decl_stmt|;
name|struct
name|command
modifier|*
modifier|*
name|cmdp
decl_stmt|;
comment|/* out */
block|{
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|struct
name|command
modifier|*
modifier|*
name|aux_cmdp
decl_stmt|;
name|int
name|result
init|=
name|CMD_NONE
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|table
operator|->
name|table
init|;
name|cmd
operator|->
name|name
operator|!=
literal|0
condition|;
name|cmd
operator|++
control|)
block|{
name|db_cmd_match
argument_list|(
name|name
argument_list|,
name|cmd
argument_list|,
name|cmdp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|CMD_UNIQUE
condition|)
return|return
operator|(
name|CMD_UNIQUE
operator|)
return|;
block|}
if|if
condition|(
name|table
operator|->
name|aux_tablep
operator|!=
name|NULL
condition|)
for|for
control|(
name|aux_cmdp
operator|=
name|table
operator|->
name|aux_tablep
init|;
name|aux_cmdp
operator|<
name|table
operator|->
name|aux_tablep_end
condition|;
name|aux_cmdp
operator|++
control|)
block|{
name|db_cmd_match
argument_list|(
name|name
argument_list|,
operator|*
name|aux_cmdp
argument_list|,
name|cmdp
argument_list|,
operator|&
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|CMD_UNIQUE
condition|)
return|return
operator|(
name|CMD_UNIQUE
operator|)
return|;
block|}
if|if
condition|(
name|result
operator|==
name|CMD_NONE
condition|)
block|{
comment|/* check for 'help' */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'h'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'l'
operator|&&
name|name
index|[
literal|3
index|]
operator|==
literal|'p'
condition|)
name|result
operator|=
name|CMD_HELP
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_cmd_list
parameter_list|(
name|table
parameter_list|)
name|struct
name|command_table
modifier|*
name|table
decl_stmt|;
block|{
specifier|register
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
specifier|register
name|struct
name|command
modifier|*
modifier|*
name|aux_cmdp
decl_stmt|;
for|for
control|(
name|cmd
operator|=
name|table
operator|->
name|table
init|;
name|cmd
operator|->
name|name
operator|!=
literal|0
condition|;
name|cmd
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|"%-12s"
argument_list|,
name|cmd
operator|->
name|name
argument_list|)
expr_stmt|;
name|db_end_line
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|table
operator|->
name|aux_tablep
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|aux_cmdp
operator|=
name|table
operator|->
name|aux_tablep
init|;
name|aux_cmdp
operator|<
name|table
operator|->
name|aux_tablep_end
condition|;
name|aux_cmdp
operator|++
control|)
block|{
name|db_printf
argument_list|(
literal|"%-12s"
argument_list|,
operator|(
operator|*
name|aux_cmdp
operator|)
operator|->
name|name
argument_list|)
expr_stmt|;
name|db_end_line
argument_list|(
literal|12
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|db_command
parameter_list|(
name|last_cmdp
parameter_list|,
name|cmd_table
parameter_list|)
name|struct
name|command
modifier|*
modifier|*
name|last_cmdp
decl_stmt|;
comment|/* IN_OUT */
name|struct
name|command_table
modifier|*
name|cmd_table
decl_stmt|;
block|{
name|struct
name|command
modifier|*
name|cmd
decl_stmt|;
name|int
name|t
decl_stmt|;
name|char
name|modif
index|[
name|TOK_STRING_SIZE
index|]
decl_stmt|;
name|db_expr_t
name|addr
decl_stmt|,
name|count
decl_stmt|;
name|boolean_t
name|have_addr
init|=
name|FALSE
decl_stmt|;
name|int
name|result
decl_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tEOL
condition|)
block|{
comment|/* empty line repeats last command, at 'next' */
name|cmd
operator|=
operator|*
name|last_cmdp
expr_stmt|;
name|addr
operator|=
operator|(
name|db_expr_t
operator|)
name|db_next
expr_stmt|;
name|have_addr
operator|=
name|FALSE
expr_stmt|;
name|count
operator|=
literal|1
expr_stmt|;
name|modif
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|t
operator|==
name|tEXCL
condition|)
block|{
name|db_fncall
argument_list|(
operator|(
name|db_expr_t
operator|)
literal|0
argument_list|,
operator|(
name|boolean_t
operator|)
literal|0
argument_list|,
operator|(
name|db_expr_t
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* 	     * Search for command 	     */
while|while
condition|(
name|cmd_table
condition|)
block|{
name|result
operator|=
name|db_cmd_search
argument_list|(
name|db_tok_string
argument_list|,
name|cmd_table
argument_list|,
operator|&
name|cmd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|CMD_NONE
case|:
name|db_printf
argument_list|(
literal|"No such command\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
case|case
name|CMD_AMBIGUOUS
case|:
name|db_printf
argument_list|(
literal|"Ambiguous\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
case|case
name|CMD_HELP
case|:
name|db_cmd_list
argument_list|(
name|cmd_table
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
default|default:
break|break;
block|}
if|if
condition|(
operator|(
name|cmd_table
operator|=
name|cmd
operator|->
name|more
operator|)
operator|!=
name|NULL
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_cmd_list
argument_list|(
name|cmd_table
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|flag
operator|&
name|CS_OWN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Standard syntax: 		 * command [/modifier] [addr] [,count] 		 */
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tSLASH
condition|)
block|{
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad modifier\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|db_strcpy
argument_list|(
name|modif
argument_list|,
name|db_tok_string
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|modif
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|db_expression
argument_list|(
operator|&
name|addr
argument_list|)
condition|)
block|{
name|db_dot
operator|=
operator|(
name|db_addr_t
operator|)
name|addr
expr_stmt|;
name|db_last_addr
operator|=
name|db_dot
expr_stmt|;
name|have_addr
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|addr
operator|=
operator|(
name|db_expr_t
operator|)
name|db_dot
expr_stmt|;
name|have_addr
operator|=
name|FALSE
expr_stmt|;
block|}
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|count
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Count missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cmd
operator|->
name|flag
operator|&
name|CS_MORE
operator|)
operator|==
literal|0
condition|)
block|{
name|db_skip_to_eol
argument_list|()
expr_stmt|;
block|}
block|}
block|}
operator|*
name|last_cmdp
operator|=
name|cmd
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
literal|0
condition|)
block|{
comment|/* 	     * Execute the command. 	     */
name|db_enable_pager
argument_list|()
expr_stmt|;
call|(
modifier|*
name|cmd
operator|->
name|fcn
call|)
argument_list|(
name|addr
argument_list|,
name|have_addr
argument_list|,
name|count
argument_list|,
name|modif
argument_list|)
expr_stmt|;
name|db_disable_pager
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|->
name|flag
operator|&
name|CS_SET_DOT
condition|)
block|{
comment|/* 		 * If command changes dot, set dot to 		 * previous address displayed (if 'ed' style). 		 */
if|if
condition|(
name|db_ed_style
condition|)
block|{
name|db_dot
operator|=
name|db_prev
expr_stmt|;
block|}
else|else
block|{
name|db_dot
operator|=
name|db_next
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * If command does not change dot, 		 * set 'next' location to be the same. 		 */
name|db_next
operator|=
name|db_dot
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * At least one non-optional command must be implemented using  * DB_COMMAND() so that db_cmd_set gets created.  Here is one.  */
end_comment

begin_macro
name|DB_COMMAND
argument_list|(
argument|panic
argument_list|,
argument|db_panic
argument_list|)
end_macro

begin_block
block|{
name|db_disable_pager
argument_list|()
expr_stmt|;
name|panic
argument_list|(
literal|"from debugger"
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|db_command_loop
parameter_list|()
block|{
comment|/* 	 * Initialize 'prev' and 'next' to dot. 	 */
name|db_prev
operator|=
name|db_dot
expr_stmt|;
name|db_next
operator|=
name|db_dot
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|db_cmd_loop_done
condition|)
block|{
if|if
condition|(
name|db_print_position
argument_list|()
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"db> "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|db_read_line
argument_list|()
expr_stmt|;
name|db_command
argument_list|(
operator|&
name|db_last_command
argument_list|,
operator|&
name|db_command_table
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|db_error
parameter_list|(
name|s
parameter_list|)
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
condition|)
name|db_printf
argument_list|(
literal|"%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
name|kdb_reenter
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call random function:  * !expr(arg,arg,arg)  */
end_comment

begin_comment
comment|/* The generic implementation supports a maximum of 10 arguments. */
end_comment

begin_typedef
typedef|typedef
name|db_expr_t
name|__db_f
parameter_list|(
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|,
name|db_expr_t
parameter_list|)
function_decl|;
end_typedef

begin_function
specifier|static
name|__inline
name|int
name|db_fncall_generic
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|db_expr_t
modifier|*
name|rv
parameter_list|,
name|int
name|nargs
parameter_list|,
name|db_expr_t
name|args
index|[]
parameter_list|)
block|{
name|__db_f
modifier|*
name|f
init|=
operator|(
name|__db_f
operator|*
operator|)
name|addr
decl_stmt|;
if|if
condition|(
name|nargs
operator|>
literal|10
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many arguments (max 10)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|rv
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|,
name|args
index|[
literal|5
index|]
argument_list|,
name|args
index|[
literal|6
index|]
argument_list|,
name|args
index|[
literal|7
index|]
argument_list|,
name|args
index|[
literal|8
index|]
argument_list|,
name|args
index|[
literal|9
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_fncall
parameter_list|(
name|dummy1
parameter_list|,
name|dummy2
parameter_list|,
name|dummy3
parameter_list|,
name|dummy4
parameter_list|)
name|db_expr_t
name|dummy1
decl_stmt|;
name|boolean_t
name|dummy2
decl_stmt|;
name|db_expr_t
name|dummy3
decl_stmt|;
name|char
modifier|*
name|dummy4
decl_stmt|;
block|{
name|db_expr_t
name|fn_addr
decl_stmt|;
name|db_expr_t
name|args
index|[
name|DB_MAXARGS
index|]
decl_stmt|;
name|int
name|nargs
init|=
literal|0
decl_stmt|;
name|db_expr_t
name|retval
decl_stmt|;
name|int
name|t
decl_stmt|;
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|fn_addr
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Bad function\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tLPAREN
condition|)
block|{
if|if
condition|(
name|db_expression
argument_list|(
operator|&
name|args
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|nargs
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|db_read_token
argument_list|()
operator|)
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
name|nargs
operator|==
name|DB_MAXARGS
condition|)
block|{
name|db_printf
argument_list|(
literal|"Too many arguments (max %d)\n"
argument_list|,
name|DB_MAXARGS
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|args
index|[
name|nargs
index|]
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Argument missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
name|nargs
operator|++
expr_stmt|;
block|}
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|db_read_token
argument_list|()
operator|!=
name|tRPAREN
condition|)
block|{
name|db_printf
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
name|db_skip_to_eol
argument_list|()
expr_stmt|;
name|db_disable_pager
argument_list|()
expr_stmt|;
if|if
condition|(
name|DB_CALL
argument_list|(
name|fn_addr
argument_list|,
operator|&
name|retval
argument_list|,
name|nargs
argument_list|,
name|args
argument_list|)
condition|)
name|db_printf
argument_list|(
literal|"= %#lr\n"
argument_list|,
operator|(
name|long
operator|)
name|retval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_halt
parameter_list|(
name|db_expr_t
name|dummy
parameter_list|,
name|boolean_t
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|cpu_halt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_kill
parameter_list|(
name|dummy1
parameter_list|,
name|dummy2
parameter_list|,
name|dummy3
parameter_list|,
name|dummy4
parameter_list|)
name|db_expr_t
name|dummy1
decl_stmt|;
name|boolean_t
name|dummy2
decl_stmt|;
name|db_expr_t
name|dummy3
decl_stmt|;
name|char
modifier|*
name|dummy4
decl_stmt|;
block|{
name|db_expr_t
name|old_radix
decl_stmt|,
name|pid
decl_stmt|,
name|sig
decl_stmt|;
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
define|#
directive|define
name|DB_ERROR
parameter_list|(
name|f
parameter_list|)
value|do { db_printf f; db_flush_lex(); goto out; } while (0)
comment|/* 	 * PIDs and signal numbers are typically represented in base 	 * 10, so make that the default here.  It can, of course, be 	 * overridden by specifying a prefix. 	 */
name|old_radix
operator|=
name|db_radix
expr_stmt|;
name|db_radix
operator|=
literal|10
expr_stmt|;
comment|/* Retrieve arguments. */
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|sig
argument_list|)
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Missing signal number\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|pid
argument_list|)
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Missing process ID\n"
operator|)
argument_list|)
expr_stmt|;
name|db_skip_to_eol
argument_list|()
expr_stmt|;
if|if
condition|(
name|sig
operator|<
literal|0
operator|||
name|sig
operator|>
name|_SIG_MAXSIG
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Signal number out of range\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Find the process in question.  allproc_lock is not needed 	 * since we're in DDB. 	 */
comment|/* sx_slock(&allproc_lock); */
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
if|if
condition|(
name|p
operator|->
name|p_pid
operator|==
name|pid
condition|)
break|break;
comment|/* sx_sunlock(&allproc_lock); */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Can't find process with pid %ld\n"
operator|,
operator|(
name|long
operator|)
name|pid
operator|)
argument_list|)
expr_stmt|;
comment|/* If it's already locked, bail; otherwise, do the deed. */
if|if
condition|(
name|PROC_TRYLOCK
argument_list|(
name|p
argument_list|)
operator|==
literal|0
condition|)
name|DB_ERROR
argument_list|(
operator|(
literal|"Can't lock process with pid %ld\n"
operator|,
operator|(
name|long
operator|)
name|pid
operator|)
argument_list|)
expr_stmt|;
else|else
block|{
name|psignal
argument_list|(
name|p
argument_list|,
name|sig
argument_list|)
expr_stmt|;
name|PROC_UNLOCK
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|db_radix
operator|=
name|old_radix
expr_stmt|;
undef|#
directive|undef
name|DB_ERROR
block|}
end_function

begin_function
specifier|static
name|void
name|db_reset
parameter_list|(
name|dummy1
parameter_list|,
name|dummy2
parameter_list|,
name|dummy3
parameter_list|,
name|dummy4
parameter_list|)
name|db_expr_t
name|dummy1
decl_stmt|;
name|boolean_t
name|dummy2
decl_stmt|;
name|db_expr_t
name|dummy3
decl_stmt|;
name|char
modifier|*
name|dummy4
decl_stmt|;
block|{
name|cpu_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_watchdog
parameter_list|(
name|dummy1
parameter_list|,
name|dummy2
parameter_list|,
name|dummy3
parameter_list|,
name|dummy4
parameter_list|)
name|db_expr_t
name|dummy1
decl_stmt|;
name|boolean_t
name|dummy2
decl_stmt|;
name|db_expr_t
name|dummy3
decl_stmt|;
name|char
modifier|*
name|dummy4
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * XXX: It might make sense to be able to set the watchdog to a 	 * XXX: timeout here so that failure or hang as a result of subsequent 	 * XXX: ddb commands could be recovered by a reset. 	 */
name|EVENTHANDLER_INVOKE
argument_list|(
name|watchdog_list
argument_list|,
literal|0
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_gdb
parameter_list|(
name|db_expr_t
name|dummy1
parameter_list|,
name|boolean_t
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
if|if
condition|(
name|kdb_dbbe_select
argument_list|(
literal|"gdb"
argument_list|)
operator|!=
literal|0
condition|)
name|db_printf
argument_list|(
literal|"The remote GDB backend could not be selected.\n"
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"Step to enter the remote GDB backend.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_stack_trace
parameter_list|(
name|db_expr_t
name|tid
parameter_list|,
name|boolean_t
name|hastid
parameter_list|,
name|db_expr_t
name|count
parameter_list|,
name|char
modifier|*
name|modif
parameter_list|)
block|{
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|db_expr_t
name|radix
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|t
decl_stmt|;
comment|/* 	 * We parse our own arguments. We don't like the default radix. 	 */
name|radix
operator|=
name|db_radix
expr_stmt|;
name|db_radix
operator|=
literal|10
expr_stmt|;
name|hastid
operator|=
name|db_expression
argument_list|(
operator|&
name|tid
argument_list|)
expr_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|tCOMMA
condition|)
block|{
if|if
condition|(
operator|!
name|db_expression
argument_list|(
operator|&
name|count
argument_list|)
condition|)
block|{
name|db_printf
argument_list|(
literal|"Count missing\n"
argument_list|)
expr_stmt|;
name|db_flush_lex
argument_list|()
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|db_unread_token
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|count
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|db_skip_to_eol
argument_list|()
expr_stmt|;
name|db_radix
operator|=
name|radix
expr_stmt|;
if|if
condition|(
name|hastid
condition|)
block|{
name|td
operator|=
name|kdb_thr_lookup
argument_list|(
operator|(
name|lwpid_t
operator|)
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|td
operator|=
name|kdb_thr_from_pid
argument_list|(
operator|(
name|pid_t
operator|)
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
block|{
name|db_printf
argument_list|(
literal|"Thread %d not found\n"
argument_list|,
operator|(
name|int
operator|)
name|tid
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
name|td
operator|=
name|kdb_thread
expr_stmt|;
if|if
condition|(
name|td
operator|->
name|td_proc
operator|!=
name|NULL
condition|)
name|pid
operator|=
name|td
operator|->
name|td_proc
operator|->
name|p_pid
expr_stmt|;
else|else
name|pid
operator|=
operator|-
literal|1
expr_stmt|;
name|db_printf
argument_list|(
literal|"Tracing pid %d tid %ld td %p\n"
argument_list|,
name|pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|db_trace_thread
argument_list|(
name|td
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|db_stack_trace_all
parameter_list|(
name|db_expr_t
name|dummy
parameter_list|,
name|boolean_t
name|dummy2
parameter_list|,
name|db_expr_t
name|dummy3
parameter_list|,
name|char
modifier|*
name|dummy4
parameter_list|)
block|{
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
name|struct
name|thread
modifier|*
name|td
decl_stmt|;
name|jmp_buf
name|jb
decl_stmt|;
name|void
modifier|*
name|prev_jb
decl_stmt|;
name|FOREACH_PROC_IN_SYSTEM
argument_list|(
argument|p
argument_list|)
block|{
name|prev_jb
operator|=
name|kdb_jmpbuf
argument_list|(
name|jb
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|jb
argument_list|)
operator|==
literal|0
condition|)
block|{
name|FOREACH_THREAD_IN_PROC
argument_list|(
argument|p
argument_list|,
argument|td
argument_list|)
block|{
name|db_printf
argument_list|(
literal|"\nTracing command %s pid %d tid %ld td %p\n"
argument_list|,
name|p
operator|->
name|p_comm
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
operator|(
name|long
operator|)
name|td
operator|->
name|td_tid
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|db_trace_thread
argument_list|(
name|td
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_pager_quit
condition|)
block|{
name|kdb_jmpbuf
argument_list|(
name|prev_jb
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
name|kdb_jmpbuf
argument_list|(
name|prev_jb
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

