begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Mach Operating System  * Copyright (c) 1991,1990 Carnegie Mellon University  * All Rights Reserved.  *  * Permission to use, copy, modify and distribute this software and its  * documentation is hereby granted, provided that both the copyright  * notice and this permission notice appear in all copies of the  * software, derivative works or modified versions, and any portions  * thereof, and that both notices appear in supporting documentation.  *  * CARNEGIE MELLON ALLOWS FREE USE OF THIS SOFTWARE IN ITS  * CONDITION.  CARNEGIE MELLON DISCLAIMS ANY LIABILITY OF ANY KIND FOR  * ANY DAMAGES WHATSOEVER RESULTING FROM THE USE OF THIS SOFTWARE.  *  * Carnegie Mellon requests users of this software to return to  *  *  Software Distribution Coordinator  or  Software.Distribution@CS.CMU.EDU  *  School of Computer Science  *  Carnegie Mellon University  *  Pittsburgh PA 15213-3890  *  * any improvements or extensions that they make and grant Carnegie the  * rights to redistribute these changes.  *  *	$Id: db_run.c,v 1.13 1997/06/14 11:52:37 bde Exp $  */
end_comment

begin_comment
comment|/*  * 	Author: David B. Golub, Carnegie Mellon University  *	Date:	7/90  */
end_comment

begin_comment
comment|/*  * Commands to run process.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_break.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_access.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|db_run_mode
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|STEP_NONE
value|0
end_define

begin_define
define|#
directive|define
name|STEP_ONCE
value|1
end_define

begin_define
define|#
directive|define
name|STEP_RETURN
value|2
end_define

begin_define
define|#
directive|define
name|STEP_CALLT
value|3
end_define

begin_define
define|#
directive|define
name|STEP_CONTINUE
value|4
end_define

begin_define
define|#
directive|define
name|STEP_INVISIBLE
value|5
end_define

begin_define
define|#
directive|define
name|STEP_COUNT
value|6
end_define

begin_decl_stmt
specifier|static
name|boolean_t
name|db_sstep_print
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|db_loop_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|db_call_depth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|db_inst_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|db_load_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|db_store_count
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|db_set_single_step
end_ifndef

begin_decl_stmt
specifier|extern
name|void
name|db_set_single_step
name|__P
argument_list|(
operator|(
name|db_regs_t
operator|*
name|regs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|db_clear_single_step
end_ifndef

begin_decl_stmt
specifier|extern
name|void
name|db_clear_single_step
name|__P
argument_list|(
operator|(
name|db_regs_t
operator|*
name|regs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|notused
end_ifdef

begin_decl_stmt
specifier|static
name|void
name|db_single_step
name|__P
argument_list|(
operator|(
name|db_regs_t
operator|*
name|regs
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|boolean_t
name|db_stop_at_pc
parameter_list|(
name|is_breakpoint
parameter_list|)
name|boolean_t
modifier|*
name|is_breakpoint
decl_stmt|;
block|{
specifier|register
name|db_addr_t
name|pc
decl_stmt|;
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
name|db_clear_single_step
argument_list|(
name|DDB_REGS
argument_list|)
expr_stmt|;
name|db_clear_breakpoints
argument_list|()
expr_stmt|;
name|db_clear_watchpoints
argument_list|()
expr_stmt|;
name|pc
operator|=
name|PC_REGS
argument_list|(
name|DDB_REGS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FIXUP_PC_AFTER_BREAK
if|if
condition|(
operator|*
name|is_breakpoint
condition|)
block|{
comment|/* 	     * Breakpoint trap.  Fix up the PC if the 	     * machine requires it. 	     */
name|FIXUP_PC_AFTER_BREAK
name|pc
init|=
name|PC_REGS
argument_list|(
name|DDB_REGS
argument_list|)
decl_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Now check for a breakpoint at this address. 	 */
name|bkpt
operator|=
name|db_find_breakpoint_here
argument_list|(
name|pc
argument_list|)
expr_stmt|;
if|if
condition|(
name|bkpt
condition|)
block|{
if|if
condition|(
operator|--
name|bkpt
operator|->
name|count
operator|==
literal|0
condition|)
block|{
name|bkpt
operator|->
name|count
operator|=
name|bkpt
operator|->
name|init_count
expr_stmt|;
operator|*
name|is_breakpoint
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* stop here */
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|is_breakpoint
condition|)
block|{
ifdef|#
directive|ifdef
name|__i386__
comment|/* XXx */
name|ddb_regs
operator|.
name|tf_eip
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
operator|*
name|is_breakpoint
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_INVISIBLE
condition|)
block|{
name|db_run_mode
operator|=
name|STEP_CONTINUE
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* continue */
block|}
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_COUNT
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* continue */
block|}
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_ONCE
condition|)
block|{
if|if
condition|(
operator|--
name|db_loop_count
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|db_sstep_print
condition|)
block|{
name|db_printf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
name|db_print_loc_and_inst
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* continue */
block|}
block|}
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_RETURN
condition|)
block|{
name|db_expr_t
name|ins
init|=
name|db_get_value
argument_list|(
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* continue until matching return */
if|if
condition|(
operator|!
name|inst_trap_return
argument_list|(
name|ins
argument_list|)
operator|&&
operator|(
operator|!
name|inst_return
argument_list|(
name|ins
argument_list|)
operator|||
operator|--
name|db_call_depth
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|db_sstep_print
condition|)
block|{
if|if
condition|(
name|inst_call
argument_list|(
name|ins
argument_list|)
operator|||
name|inst_return
argument_list|(
name|ins
argument_list|)
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|db_printf
argument_list|(
literal|"[after %6d]     "
argument_list|,
name|db_inst_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|db_call_depth
init|;
operator|--
name|i
operator|>
literal|0
condition|;
control|)
name|db_printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
name|db_print_loc_and_inst
argument_list|(
name|pc
argument_list|)
expr_stmt|;
name|db_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|inst_call
argument_list|(
name|ins
argument_list|)
condition|)
name|db_call_depth
operator|++
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* continue */
block|}
block|}
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_CALLT
condition|)
block|{
name|db_expr_t
name|ins
init|=
name|db_get_value
argument_list|(
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* continue until call or return */
if|if
condition|(
operator|!
name|inst_call
argument_list|(
name|ins
argument_list|)
operator|&&
operator|!
name|inst_return
argument_list|(
name|ins
argument_list|)
operator|&&
operator|!
name|inst_trap_return
argument_list|(
name|ins
argument_list|)
condition|)
block|{
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* continue */
block|}
block|}
name|db_run_mode
operator|=
name|STEP_NONE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_restart_at_pc
parameter_list|(
name|watchpt
parameter_list|)
name|boolean_t
name|watchpt
decl_stmt|;
block|{
specifier|register
name|db_addr_t
name|pc
init|=
name|PC_REGS
argument_list|(
name|DDB_REGS
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|db_run_mode
operator|==
name|STEP_COUNT
operator|)
operator|||
operator|(
name|db_run_mode
operator|==
name|STEP_RETURN
operator|)
operator|||
operator|(
name|db_run_mode
operator|==
name|STEP_CALLT
operator|)
condition|)
block|{
name|db_expr_t
name|ins
decl_stmt|;
comment|/* 	     * We are about to execute this instruction, 	     * so count it now. 	     */
name|ins
operator|=
name|db_get_value
argument_list|(
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|db_inst_count
operator|++
expr_stmt|;
name|db_load_count
operator|+=
name|inst_load
argument_list|(
name|ins
argument_list|)
expr_stmt|;
name|db_store_count
operator|+=
name|inst_store
argument_list|(
name|ins
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOFTWARE_SSTEP
comment|/* XXX works on mips, but... */
if|if
condition|(
name|inst_branch
argument_list|(
name|ins
argument_list|)
operator|||
name|inst_call
argument_list|(
name|ins
argument_list|)
condition|)
block|{
name|ins
operator|=
name|db_get_value
argument_list|(
name|next_instr_address
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|db_inst_count
operator|++
expr_stmt|;
name|db_load_count
operator|+=
name|inst_load
argument_list|(
name|ins
argument_list|)
expr_stmt|;
name|db_store_count
operator|+=
name|inst_store
argument_list|(
name|ins
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|SOFTWARE_SSTEP
block|}
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_CONTINUE
condition|)
block|{
if|if
condition|(
name|watchpt
operator|||
name|db_find_breakpoint_here
argument_list|(
name|pc
argument_list|)
condition|)
block|{
comment|/* 		 * Step over breakpoint/watchpoint. 		 */
name|db_run_mode
operator|=
name|STEP_INVISIBLE
expr_stmt|;
name|db_set_single_step
argument_list|(
name|DDB_REGS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_set_breakpoints
argument_list|()
expr_stmt|;
name|db_set_watchpoints
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
name|db_set_single_step
argument_list|(
name|DDB_REGS
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|notused
end_ifdef

begin_function
specifier|static
name|void
name|db_single_step
parameter_list|(
name|regs
parameter_list|)
name|db_regs_t
modifier|*
name|regs
decl_stmt|;
block|{
if|if
condition|(
name|db_run_mode
operator|==
name|STEP_CONTINUE
condition|)
block|{
name|db_run_mode
operator|=
name|STEP_INVISIBLE
expr_stmt|;
name|db_set_single_step
argument_list|(
name|regs
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SOFTWARE_SSTEP
end_ifdef

begin_comment
comment|/*  *	Software implementation of single-stepping.  *	If your machine does not have a trace mode  *	similar to the vax or sun ones you can use  *	this implementation, done for the mips.  *	Just define the above conditional and provide  *	the functions/macros defined below.  *  * extern boolean_t  *	inst_branch(),		returns true if the instruction might branch  * extern unsigned  *	branch_taken(),		return the address the instruction might  *				branch to  *	db_getreg_val();	return the value of a user register,  *				as indicated in the hardware instruction  *				encoding, e.g. 8 for r8  *  * next_instr_address(pc,bd)	returns the address of the first  *				instruction following the one at "pc",  *				which is either in the taken path of  *				the branch (bd==1) or not.  This is  *				for machines (mips) with branch delays.  *  *	A single-step may involve at most 2 breakpoints -  *	one for branch-not-taken and one for branch taken.  *	If one of these addresses does not already have a breakpoint,  *	we allocate a breakpoint and save it here.  *	These breakpoints are deleted on return.  */
end_comment

begin_decl_stmt
name|db_breakpoint_t
name|db_not_taken_bkpt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|db_breakpoint_t
name|db_taken_bkpt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|db_set_single_step
parameter_list|(
name|regs
parameter_list|)
specifier|register
name|db_regs_t
modifier|*
name|regs
decl_stmt|;
block|{
name|db_addr_t
name|pc
init|=
name|PC_REGS
argument_list|(
name|regs
argument_list|)
decl_stmt|;
specifier|register
name|unsigned
name|inst
decl_stmt|,
name|brpc
decl_stmt|;
comment|/* 	 *	User was stopped at pc, e.g. the instruction 	 *	at pc was not executed. 	 */
name|inst
operator|=
name|db_get_value
argument_list|(
name|pc
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|inst_branch
argument_list|(
name|inst
argument_list|)
operator|||
name|inst_call
argument_list|(
name|inst
argument_list|)
condition|)
block|{
name|brpc
operator|=
name|branch_taken
argument_list|(
name|inst
argument_list|,
name|pc
argument_list|,
name|regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|brpc
operator|!=
name|pc
condition|)
block|{
comment|/* self-branches are hopeless */
name|db_taken_bkpt
operator|=
name|db_set_temp_breakpoint
argument_list|(
name|brpc
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|next_instr_address
argument_list|(
name|pc
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pc
operator|=
name|next_instr_address
argument_list|(
name|pc
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|db_not_taken_bkpt
operator|=
name|db_set_temp_breakpoint
argument_list|(
name|pc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_clear_single_step
parameter_list|(
name|regs
parameter_list|)
name|db_regs_t
modifier|*
name|regs
decl_stmt|;
block|{
specifier|register
name|db_breakpoint_t
name|bkpt
decl_stmt|;
if|if
condition|(
name|db_taken_bkpt
operator|!=
literal|0
condition|)
block|{
name|db_delete_temp_breakpoint
argument_list|(
name|db_taken_bkpt
argument_list|)
expr_stmt|;
name|db_taken_bkpt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|db_not_taken_bkpt
operator|!=
literal|0
condition|)
block|{
name|db_delete_temp_breakpoint
argument_list|(
name|db_not_taken_bkpt
argument_list|)
expr_stmt|;
name|db_not_taken_bkpt
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|SOFTWARE_SSTEP
end_endif

begin_decl_stmt
specifier|extern
name|int
name|db_cmd_loop_done
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* single-step */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_single_step_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|boolean_t
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
name|boolean_t
name|print
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|count
operator|==
operator|-
literal|1
condition|)
name|count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|modif
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
name|print
operator|=
name|TRUE
expr_stmt|;
name|db_run_mode
operator|=
name|STEP_ONCE
expr_stmt|;
name|db_loop_count
operator|=
name|count
expr_stmt|;
name|db_sstep_print
operator|=
name|print
expr_stmt|;
name|db_inst_count
operator|=
literal|0
expr_stmt|;
name|db_load_count
operator|=
literal|0
expr_stmt|;
name|db_store_count
operator|=
literal|0
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* trace and print until call/return */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_trace_until_call_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|boolean_t
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
name|boolean_t
name|print
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|modif
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
name|print
operator|=
name|TRUE
expr_stmt|;
name|db_run_mode
operator|=
name|STEP_CALLT
expr_stmt|;
name|db_sstep_print
operator|=
name|print
expr_stmt|;
name|db_inst_count
operator|=
literal|0
expr_stmt|;
name|db_load_count
operator|=
literal|0
expr_stmt|;
name|db_store_count
operator|=
literal|0
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_trace_until_matching_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|boolean_t
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
name|boolean_t
name|print
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|modif
index|[
literal|0
index|]
operator|==
literal|'p'
condition|)
name|print
operator|=
name|TRUE
expr_stmt|;
name|db_run_mode
operator|=
name|STEP_RETURN
expr_stmt|;
name|db_call_depth
operator|=
literal|1
expr_stmt|;
name|db_sstep_print
operator|=
name|print
expr_stmt|;
name|db_inst_count
operator|=
literal|0
expr_stmt|;
name|db_load_count
operator|=
literal|0
expr_stmt|;
name|db_store_count
operator|=
literal|0
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* continue */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|db_continue_cmd
parameter_list|(
name|addr
parameter_list|,
name|have_addr
parameter_list|,
name|count
parameter_list|,
name|modif
parameter_list|)
name|db_expr_t
name|addr
decl_stmt|;
name|boolean_t
name|have_addr
decl_stmt|;
name|db_expr_t
name|count
decl_stmt|;
name|char
modifier|*
name|modif
decl_stmt|;
block|{
if|if
condition|(
name|modif
index|[
literal|0
index|]
operator|==
literal|'c'
condition|)
name|db_run_mode
operator|=
name|STEP_COUNT
expr_stmt|;
else|else
name|db_run_mode
operator|=
name|STEP_CONTINUE
expr_stmt|;
name|db_inst_count
operator|=
literal|0
expr_stmt|;
name|db_load_count
operator|=
literal|0
expr_stmt|;
name|db_store_count
operator|=
literal|0
expr_stmt|;
name|db_cmd_loop_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

end_unit

