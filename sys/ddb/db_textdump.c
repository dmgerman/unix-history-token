begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Kernel text-dump support: write a series of text files to the dump  * partition for later recovery, including captured DDB output, kernel  * configuration, message buffer, and panic message.  This allows for a more  * compact representation of critical debugging information than traditional  * binary dumps, as well as allowing dump information to be used without  * access to kernel symbols, source code, etc.  *  * Storage Layout  * --------------  *  * Crash dumps are aligned to the end of the dump or swap partition in order  * to minimize the chances of swap duing fsck eating into the dump.  However,  * unlike a memory dump, we don't know the size of the textdump a priori, so  * can't just write it out sequentially in order from a known starting point  * calculated with respect to the end of the partition.  In order to address  * this, we actually write out the textdump in reverse block order, allowing  * us to directly align it to the end of the partition and then write out the  * dump header and trailer before and after it once done.  savecore(8) must  * know to reverse the order of the blocks in order to produce a readable  * file.  *  * Data is written out in the ustar file format so that we can write data  * incrementally as a stream without reference to previous files.  *  * TODO  * ----  *  * - Allow subsytems to register to submit files for inclusion in the text  *   dump in a generic way.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_config.h"
end_include

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kerneldump.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_ddb
argument_list|,
name|OID_AUTO
argument_list|,
name|textdump
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"DDB textdump options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Don't touch the first SIZEOF_METADATA bytes on the dump device.  This is  * to protect us from metadata and metadata from us.  */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_METADATA
value|(64*1024)
end_define

begin_comment
comment|/*  * Data is written out as a series of files in the ustar tar format.  ustar  * is a simple streamed format consiting of a series of files prefixed with  * headers, and all padded to 512-byte block boundaries, which maps  * conveniently to our requirements.  */
end_comment

begin_struct
struct|struct
name|ustar_header
block|{
name|char
name|uh_filename
index|[
literal|100
index|]
decl_stmt|;
name|char
name|uh_mode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uh_tar_owner
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uh_tar_group
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uh_size
index|[
literal|12
index|]
decl_stmt|;
name|char
name|uh_mtime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|uh_sum
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uh_type
decl_stmt|;
name|char
name|uh_linkfile
index|[
literal|100
index|]
decl_stmt|;
name|char
name|uh_ustar
index|[
literal|6
index|]
decl_stmt|;
name|char
name|uh_version
index|[
literal|2
index|]
decl_stmt|;
name|char
name|uh_owner
index|[
literal|32
index|]
decl_stmt|;
name|char
name|uh_group
index|[
literal|32
index|]
decl_stmt|;
name|char
name|uh_major
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uh_minor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uh_filenameprefix
index|[
literal|155
index|]
decl_stmt|;
name|char
name|uh_zeropad
index|[
literal|12
index|]
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_comment
comment|/*  * Various size assertions -- pretty much everything must be one block in  * size.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|kerneldumpheader
argument_list|)
operator|==
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|CTASSERT
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ustar_header
argument_list|)
operator|==
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Is a textdump scheduled?  If so, the shutdown code will invoke our dumpsys  * routine instead of the machine-dependent kernel dump routine.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TEXTDUMP_PREFERRED
end_ifdef

begin_decl_stmt
name|int
name|textdump_pending
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|textdump_pending
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_textdump
argument_list|,
name|OID_AUTO
argument_list|,
name|pending
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|textdump_pending
argument_list|,
literal|0
argument_list|,
literal|"Perform textdump instead of regular kernel dump."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Various constants for tar headers and contents.  */
end_comment

begin_define
define|#
directive|define
name|TAR_USER
value|"root"
end_define

begin_define
define|#
directive|define
name|TAR_GROUP
value|"wheel"
end_define

begin_define
define|#
directive|define
name|TAR_UID
value|"0"
end_define

begin_define
define|#
directive|define
name|TAR_GID
value|"0"
end_define

begin_define
define|#
directive|define
name|TAR_MODE
value|"0600"
end_define

begin_define
define|#
directive|define
name|TAR_USTAR
value|"ustar"
end_define

begin_define
define|#
directive|define
name|TAR_CONFIG_FILENAME
value|"config.txt"
end_define

begin_comment
comment|/* Kernel configuration. */
end_comment

begin_define
define|#
directive|define
name|TAR_MSGBUF_FILENAME
value|"msgbuf.txt"
end_define

begin_comment
comment|/* Kernel messsage buffer. */
end_comment

begin_define
define|#
directive|define
name|TAR_PANIC_FILENAME
value|"panic.txt"
end_define

begin_comment
comment|/* Panic message. */
end_comment

begin_define
define|#
directive|define
name|TAR_VERSION_FILENAME
value|"version.txt"
end_define

begin_comment
comment|/* Kernel version. */
end_comment

begin_comment
comment|/*  * Configure which files will be dumped.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_CONFIG_FILE
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|textdump_do_config
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_textdump
argument_list|,
name|OID_AUTO
argument_list|,
name|do_config
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|textdump_do_config
argument_list|,
literal|0
argument_list|,
literal|"Dump kernel configuration in textdump"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|textdump_do_ddb
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_textdump
argument_list|,
name|OID_AUTO
argument_list|,
name|do_ddb
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|textdump_do_ddb
argument_list|,
literal|0
argument_list|,
literal|"Dump DDB captured output in textdump"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|textdump_do_msgbuf
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_textdump
argument_list|,
name|OID_AUTO
argument_list|,
name|do_msgbuf
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|textdump_do_msgbuf
argument_list|,
literal|0
argument_list|,
literal|"Dump kernel message buffer in textdump"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|textdump_do_panic
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_textdump
argument_list|,
name|OID_AUTO
argument_list|,
name|do_panic
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|textdump_do_panic
argument_list|,
literal|0
argument_list|,
literal|"Dump kernel panic message in textdump"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|textdump_do_version
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_textdump
argument_list|,
name|OID_AUTO
argument_list|,
name|do_version
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|textdump_do_version
argument_list|,
literal|0
argument_list|,
literal|"Dump kernel version string in textdump"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * State related to incremental writing of blocks to disk.  */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|textdump_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Offset of next sequential write. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|textdump_error
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Carried write error, if any. */
end_comment

begin_comment
comment|/*  * Statically allocate space to prepare block-sized headers and data.  */
end_comment

begin_decl_stmt
name|char
name|textdump_block_buffer
index|[
name|TEXTDUMP_BLOCKSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kerneldumpheader
name|kdh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Calculate and fill in the checksum for a ustar header.  */
end_comment

begin_function
specifier|static
name|void
name|ustar_checksum
parameter_list|(
name|struct
name|ustar_header
modifier|*
name|uhp
parameter_list|)
block|{
name|u_int
name|sum
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_sum
argument_list|)
condition|;
name|i
operator|++
control|)
name|uhp
operator|->
name|uh_sum
index|[
name|i
index|]
operator|=
literal|' '
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|uhp
argument_list|)
condition|;
name|i
operator|++
control|)
name|sum
operator|+=
operator|(
operator|(
name|u_char
operator|*
operator|)
name|uhp
operator|)
index|[
name|i
index|]
expr_stmt|;
name|snprintf
argument_list|(
name|uhp
operator|->
name|uh_sum
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_sum
argument_list|)
argument_list|,
literal|"%6o"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Each file in the tarball has a block-sized header with its name and other,  * largely hard-coded, properties.  */
end_comment

begin_function
name|void
name|textdump_mkustar
parameter_list|(
name|char
modifier|*
name|block_buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|u_int
name|size
parameter_list|)
block|{
name|struct
name|ustar_header
modifier|*
name|uhp
decl_stmt|;
ifdef|#
directive|ifdef
name|TEXTDUMP_VERBOSE
if|if
condition|(
name|textdump_error
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"textdump: creating '%s'.\n"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|uhp
operator|=
operator|(
expr|struct
name|ustar_header
operator|*
operator|)
name|block_buffer
expr_stmt|;
name|bzero
argument_list|(
name|uhp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|uhp
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_filename
argument_list|,
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_filename
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_mode
argument_list|,
name|TAR_MODE
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_mode
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|uhp
operator|->
name|uh_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_size
argument_list|)
argument_list|,
literal|"%o"
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_tar_owner
argument_list|,
name|TAR_UID
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_tar_owner
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_tar_group
argument_list|,
name|TAR_GID
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_tar_group
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_owner
argument_list|,
name|TAR_USER
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_owner
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_group
argument_list|,
name|TAR_GROUP
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_group
argument_list|)
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|uhp
operator|->
name|uh_mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_mtime
argument_list|)
argument_list|,
literal|"%lo"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|time_second
argument_list|)
expr_stmt|;
name|uhp
operator|->
name|uh_type
operator|=
literal|0
expr_stmt|;
name|strlcpy
argument_list|(
name|uhp
operator|->
name|uh_ustar
argument_list|,
name|TAR_USTAR
argument_list|,
sizeof|sizeof
argument_list|(
name|uhp
operator|->
name|uh_ustar
argument_list|)
argument_list|)
expr_stmt|;
name|ustar_checksum
argument_list|(
name|uhp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * textdump_writeblock() writes TEXTDUMP_BLOCKSIZE-sized blocks of data to  * the space between di->mediaoffset and di->mediaoffset + di->mediasize.  It  * accepts an offset relative to di->mediaoffset.  If we're carrying any  * error from previous I/O, return that error and don't continue to try to  * write.  Most writers ignore the error and forge ahead on the basis that  * there's not much you can do.  */
end_comment

begin_function
specifier|static
name|int
name|textdump_writeblock
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
if|if
condition|(
name|textdump_error
condition|)
return|return
operator|(
name|textdump_error
operator|)
return|;
if|if
condition|(
name|offset
operator|+
name|TEXTDUMP_BLOCKSIZE
operator|>
name|di
operator|->
name|mediasize
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
if|if
condition|(
name|offset
operator|<
name|SIZEOF_METADATA
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
name|textdump_error
operator|=
name|dump_write
argument_list|(
name|di
argument_list|,
name|buffer
argument_list|,
literal|0
argument_list|,
name|offset
operator|+
name|di
operator|->
name|mediaoffset
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|textdump_error
condition|)
name|printf
argument_list|(
literal|"textdump_writeblock: offset %jd, error %d\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|,
name|textdump_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|textdump_error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interfaces to save and restore the dump offset, so that printers can go  * back to rewrite a header if required, while avoiding their knowing about  * the global layout of the blocks.  *  * If we ever want to support writing textdumps to tape or other  * stream-oriented target, we'll need to remove this.  */
end_comment

begin_function
name|void
name|textdump_saveoff
parameter_list|(
name|off_t
modifier|*
name|offsetp
parameter_list|)
block|{
operator|*
name|offsetp
operator|=
name|textdump_offset
expr_stmt|;
block|}
end_function

begin_function
name|void
name|textdump_restoreoff
parameter_list|(
name|off_t
name|offset
parameter_list|)
block|{
name|textdump_offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interface to write the "next block" relative to the current offset; since  * we write backwards from the end of the partition, we subtract, but there's  * no reason for the caller to know this.  */
end_comment

begin_function
name|int
name|textdump_writenextblock
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|textdump_writeblock
argument_list|(
name|di
argument_list|,
name|textdump_offset
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|textdump_offset
operator|-=
name|TEXTDUMP_BLOCKSIZE
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INCLUDE_CONFIG_FILE
end_ifdef

begin_decl_stmt
specifier|extern
name|char
name|kernconfstring
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Dump kernel configuration.  */
end_comment

begin_function
specifier|static
name|void
name|textdump_dump_config
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|,
name|fullblocks
decl_stmt|,
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|kernconfstring
argument_list|)
expr_stmt|;
name|textdump_mkustar
argument_list|(
name|textdump_block_buffer
argument_list|,
name|TAR_CONFIG_FILENAME
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * Write out all full blocks directly from the string, and handle any 	 * left-over bits by copying it to out to the local buffer and 	 * zero-padding it. 	 */
name|fullblocks
operator|=
name|len
operator|/
name|TEXTDUMP_BLOCKSIZE
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|fullblocks
condition|;
name|count
operator|++
control|)
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|kernconfstring
operator|+
name|count
operator|*
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|%
name|TEXTDUMP_BLOCKSIZE
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|textdump_block_buffer
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|kernconfstring
operator|+
name|count
operator|*
name|TEXTDUMP_BLOCKSIZE
argument_list|,
name|textdump_block_buffer
argument_list|,
name|len
operator|%
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* INCLUDE_CONFIG_FILE */
end_comment

begin_comment
comment|/*  * Dump kernel message buffer.  */
end_comment

begin_function
specifier|static
name|void
name|textdump_dump_msgbuf
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|)
block|{
name|off_t
name|end_offset
decl_stmt|,
name|tarhdr_offset
decl_stmt|;
name|u_int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|offset
decl_stmt|,
name|seq
decl_stmt|,
name|total_len
decl_stmt|;
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
comment|/* 	 * Write out a dummy tar header to advance the offset; we'll rewrite 	 * it later once we know the true size. 	 */
name|textdump_saveoff
argument_list|(
operator|&
name|tarhdr_offset
argument_list|)
expr_stmt|;
name|textdump_mkustar
argument_list|(
name|textdump_block_buffer
argument_list|,
name|TAR_MSGBUF_FILENAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * Copy out the data in small chunks, but don't copy nuls that may be 	 * present if the message buffer has not yet completely filled at 	 * least once. 	 */
name|total_len
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|msgbuf_peekbytes
argument_list|(
name|msgbufp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|seq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|msgbuf_peekbytes
argument_list|(
name|msgbufp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|&
name|seq
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|textdump_block_buffer
index|[
name|offset
index|]
operator|=
name|buf
index|[
name|i
index|]
expr_stmt|;
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
sizeof|sizeof
argument_list|(
name|textdump_block_buffer
argument_list|)
condition|)
continue|continue;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
name|total_len
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|total_len
operator|+=
name|offset
expr_stmt|;
comment|/* Without the zero-padding. */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
name|textdump_block_buffer
operator|+
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|textdump_block_buffer
argument_list|)
operator|-
name|offset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Rewrite tar header to reflect how much was actually written. 	 */
name|textdump_saveoff
argument_list|(
operator|&
name|end_offset
argument_list|)
expr_stmt|;
name|textdump_restoreoff
argument_list|(
name|tarhdr_offset
argument_list|)
expr_stmt|;
name|textdump_mkustar
argument_list|(
name|textdump_block_buffer
argument_list|,
name|TAR_MSGBUF_FILENAME
argument_list|,
name|total_len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
name|textdump_restoreoff
argument_list|(
name|end_offset
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|textdump_dump_panic
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
comment|/* 	 * Write out tar header -- we store up to one block of panic message. 	 */
name|len
operator|=
name|min
argument_list|(
name|strlen
argument_list|(
name|panicstr
argument_list|)
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
name|textdump_mkustar
argument_list|(
name|textdump_block_buffer
argument_list|,
name|TAR_PANIC_FILENAME
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * Zero-pad the panic string and write out block. 	 */
name|bzero
argument_list|(
name|textdump_block_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|textdump_block_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|panicstr
argument_list|,
name|textdump_block_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|textdump_dump_version
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
comment|/* 	 * Write out tar header -- at most one block of version information. 	 */
name|len
operator|=
name|min
argument_list|(
name|strlen
argument_list|(
name|version
argument_list|)
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
name|textdump_mkustar
argument_list|(
name|textdump_block_buffer
argument_list|,
name|TAR_VERSION_FILENAME
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
comment|/* 	 * Zero pad the version string and write out block. 	 */
name|bzero
argument_list|(
name|textdump_block_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|textdump_block_buffer
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|version
argument_list|,
name|textdump_block_buffer
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Commit text dump to disk.  */
end_comment

begin_function
name|void
name|textdump_dumpsys
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|)
block|{
name|off_t
name|dumplen
decl_stmt|,
name|trailer_offset
decl_stmt|;
if|if
condition|(
name|di
operator|->
name|blocksize
operator|!=
name|TEXTDUMP_BLOCKSIZE
condition|)
block|{
name|printf
argument_list|(
literal|"Dump partition block size (%ju) not textdump "
literal|"block size (%ju)"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|di
operator|->
name|blocksize
argument_list|,
operator|(
name|uintmax_t
operator|)
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * We don't know a priori how large the dump will be, but we do know 	 * that we need to reserve space for metadata and that we need two 	 * dump headers.  Also leave room for one ustar header and one block 	 * of data. 	 */
if|if
condition|(
name|di
operator|->
name|mediasize
operator|<
name|SIZEOF_METADATA
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|kdh
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"Insufficient space on dump partition for minimal textdump.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|textdump_error
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Position the start of the dump so that we'll write the kernel dump 	 * trailer immediately before the end of the partition, and then work 	 * our way back.  We will rewrite this header later to reflect the 	 * true size if things go well. 	 */
name|textdump_offset
operator|=
name|di
operator|->
name|mediasize
operator|-
sizeof|sizeof
argument_list|(
name|kdh
argument_list|)
expr_stmt|;
name|textdump_saveoff
argument_list|(
operator|&
name|trailer_offset
argument_list|)
expr_stmt|;
name|mkdumpheader
argument_list|(
operator|&
name|kdh
argument_list|,
name|TEXTDUMPMAGIC
argument_list|,
name|KERNELDUMP_TEXT_VERSION
argument_list|,
literal|0
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|kdh
argument_list|)
expr_stmt|;
comment|/* 	 * Write a series of files in ustar format. 	 */
if|if
condition|(
name|textdump_do_ddb
condition|)
name|db_capture_dump
argument_list|(
name|di
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INCLUDE_CONFIG_FILE
if|if
condition|(
name|textdump_do_config
condition|)
name|textdump_dump_config
argument_list|(
name|di
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|textdump_do_msgbuf
condition|)
name|textdump_dump_msgbuf
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|textdump_do_panic
operator|&&
name|panicstr
operator|!=
name|NULL
condition|)
name|textdump_dump_panic
argument_list|(
name|di
argument_list|)
expr_stmt|;
if|if
condition|(
name|textdump_do_version
condition|)
name|textdump_dump_version
argument_list|(
name|di
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we know the true size, we can write out the header, then 	 * seek back to the end and rewrite the trailer with the correct 	 * size. 	 */
name|dumplen
operator|=
name|trailer_offset
operator|-
operator|(
name|textdump_offset
operator|+
name|TEXTDUMP_BLOCKSIZE
operator|)
expr_stmt|;
name|mkdumpheader
argument_list|(
operator|&
name|kdh
argument_list|,
name|TEXTDUMPMAGIC
argument_list|,
name|KERNELDUMP_TEXT_VERSION
argument_list|,
name|dumplen
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|kdh
argument_list|)
expr_stmt|;
name|textdump_restoreoff
argument_list|(
name|trailer_offset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|kdh
argument_list|)
expr_stmt|;
comment|/* 	 * Terminate the dump, report any errors, and clear the pending flag. 	 */
if|if
condition|(
name|textdump_error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|dump_write
argument_list|(
name|di
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|textdump_error
operator|==
name|ENOSPC
condition|)
name|printf
argument_list|(
literal|"Textdump: Insufficient space on dump partition\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|textdump_error
operator|!=
literal|0
condition|)
name|printf
argument_list|(
literal|"Textdump: Error %d writing dump\n"
argument_list|,
name|textdump_error
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Textdump complete.\n"
argument_list|)
expr_stmt|;
name|textdump_pending
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * DDB(4) command to manage textdumps:  *  * textdump set        - request a textdump  * textdump status     - print DDB output textdump status  * textdump unset      - clear textdump request  */
end_comment

begin_function
specifier|static
name|void
name|db_textdump_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|db_printf
argument_list|(
literal|"textdump [unset|set|status|dump]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_textdump_cmd
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|bool
name|have_addr
parameter_list|,
name|db_expr_t
name|count
parameter_list|,
name|char
modifier|*
name|modif
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_textdump_usage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|db_read_token
argument_list|()
operator|!=
name|tEOL
condition|)
block|{
name|db_textdump_usage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|textdump_pending
operator|=
literal|1
expr_stmt|;
name|db_printf
argument_list|(
literal|"textdump set\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"status"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|textdump_pending
condition|)
name|db_printf
argument_list|(
literal|"textdump is set\n"
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"textdump is not set\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"unset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|textdump_pending
operator|=
literal|0
expr_stmt|;
name|db_printf
argument_list|(
literal|"textdump unset\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"dump"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|textdump_pending
operator|=
literal|1
expr_stmt|;
name|doadump
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|db_textdump_usage
argument_list|()
expr_stmt|;
block|}
block|}
end_function

end_unit

