begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * DDB capture support: capture kernel debugger output into a fixed-size  * buffer for later dumping to disk or extraction from user space.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_ddb.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kerneldump.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msgbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/sx.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<ddb/ddb.h>
end_include

begin_include
include|#
directive|include
file|<ddb/db_lex.h>
end_include

begin_comment
comment|/*  * While it would be desirable to use a small block-sized buffer and dump  * incrementally to disk in fixed-size blocks, it's not possible to enter  * kernel dumper routines without restarting the kernel, which is undesirable  * in the midst of debugging.  Instead, we maintain a large static global  * buffer that we fill from DDB's output routines.  *  * We enforce an invariant at runtime that buffer sizes are even multiples of  * the textdump block size, which is a design choice that we might want to  * reconsider.  */
end_comment

begin_expr_stmt
specifier|static
name|MALLOC_DEFINE
argument_list|(
name|M_DDB_CAPTURE
argument_list|,
literal|"ddb_capture"
argument_list|,
literal|"DDB capture buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|DDB_CAPTURE_DEFAULTBUFSIZE
end_ifndef

begin_define
define|#
directive|define
name|DDB_CAPTURE_DEFAULTBUFSIZE
value|48*1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DDB_CAPTURE_MAXBUFSIZE
end_ifndef

begin_define
define|#
directive|define
name|DDB_CAPTURE_MAXBUFSIZE
value|5*1024*1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DDB_CAPTURE_FILENAME
value|"ddb.txt"
end_define

begin_comment
comment|/* Captured DDB output. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|db_capture_buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|db_capture_bufsize
init|=
name|DDB_CAPTURE_DEFAULTBUFSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int
name|db_capture_maxbufsize
init|=
name|DDB_CAPTURE_MAXBUFSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Read-only. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|db_capture_bufoff
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Next location to write in buffer. */
end_comment

begin_decl_stmt
specifier|static
name|u_int
name|db_capture_bufpadding
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Amount of zero padding. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|db_capture_inpager
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Suspend capture in pager. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|db_capture_inprogress
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* DDB capture currently in progress. */
end_comment

begin_decl_stmt
name|struct
name|sx
name|db_capture_sx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Lock against user thread races. */
end_comment

begin_expr_stmt
name|SX_SYSINIT
argument_list|(
name|db_capture_sx
argument_list|,
operator|&
name|db_capture_sx
argument_list|,
literal|"db_capture_sx"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_debug_ddb
argument_list|,
name|OID_AUTO
argument_list|,
name|capture
argument_list|,
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|"DDB capture options"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_ddb_capture
argument_list|,
name|OID_AUTO
argument_list|,
name|bufoff
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|db_capture_bufoff
argument_list|,
literal|0
argument_list|,
literal|"Bytes of data in DDB capture buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_UINT
argument_list|(
name|_debug_ddb_capture
argument_list|,
name|OID_AUTO
argument_list|,
name|maxbufsize
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|db_capture_maxbufsize
argument_list|,
literal|0
argument_list|,
literal|"Maximum value for debug.ddb.capture.bufsize"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_debug_ddb_capture
argument_list|,
name|OID_AUTO
argument_list|,
name|inprogress
argument_list|,
name|CTLFLAG_RD
argument_list|,
operator|&
name|db_capture_inprogress
argument_list|,
literal|0
argument_list|,
literal|"DDB output capture in progress"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Boot-time allocation of the DDB capture buffer, if any.  Force all buffer  * sizes, including the maximum size, to be rounded to block sizes.  */
end_comment

begin_function
specifier|static
name|void
name|db_capture_sysinit
parameter_list|(
name|__unused
name|void
modifier|*
name|dummy
parameter_list|)
block|{
name|TUNABLE_INT_FETCH
argument_list|(
literal|"debug.ddb.capture.bufsize"
argument_list|,
operator|&
name|db_capture_bufsize
argument_list|)
expr_stmt|;
name|db_capture_maxbufsize
operator|=
name|roundup
argument_list|(
name|db_capture_maxbufsize
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
name|db_capture_bufsize
operator|=
name|roundup
argument_list|(
name|db_capture_bufsize
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_capture_bufsize
operator|>
name|db_capture_maxbufsize
condition|)
name|db_capture_bufsize
operator|=
name|db_capture_maxbufsize
expr_stmt|;
if|if
condition|(
name|db_capture_bufsize
operator|!=
literal|0
condition|)
name|db_capture_buf
operator|=
name|malloc
argument_list|(
name|db_capture_bufsize
argument_list|,
name|M_DDB_CAPTURE
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|db_capture
argument_list|,
name|SI_SUB_DDB_SERVICES
argument_list|,
name|SI_ORDER_ANY
argument_list|,
name|db_capture_sysinit
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Run-time adjustment of the capture buffer.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_debug_ddb_capture_bufsize
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|error
decl_stmt|;
name|size
operator|=
name|db_capture_bufsize
expr_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|req
operator|->
name|newptr
operator|==
name|NULL
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|size
operator|=
name|roundup
argument_list|(
name|size
argument_list|,
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|db_capture_maxbufsize
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|sx_xlock
argument_list|(
operator|&
name|db_capture_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Potentially the buffer is quite large, so if we can't 		 * allocate it, fail rather than waiting. 		 */
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|,
name|M_DDB_CAPTURE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|sx_xunlock
argument_list|(
operator|&
name|db_capture_sx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
name|len
operator|=
name|min
argument_list|(
name|db_capture_bufoff
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|buf
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|db_capture_buf
operator|!=
name|NULL
operator|&&
name|buf
operator|!=
name|NULL
condition|)
name|bcopy
argument_list|(
name|db_capture_buf
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_capture_buf
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|db_capture_buf
argument_list|,
name|M_DDB_CAPTURE
argument_list|)
expr_stmt|;
name|db_capture_bufoff
operator|=
name|len
expr_stmt|;
name|db_capture_buf
operator|=
name|buf
expr_stmt|;
name|db_capture_bufsize
operator|=
name|size
expr_stmt|;
name|sx_xunlock
argument_list|(
operator|&
name|db_capture_sx
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|db_capture_bufoff
operator|<=
name|db_capture_bufsize
argument_list|,
operator|(
literal|"sysctl_debug_ddb_capture_bufsize: bufoff> bufsize"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|db_capture_bufsize
operator|<=
name|db_capture_maxbufsize
argument_list|,
operator|(
literal|"sysctl_debug_ddb_capture_maxbufsize: bufsize> maxbufsize"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_ddb_capture
argument_list|,
name|OID_AUTO
argument_list|,
name|bufsize
argument_list|,
name|CTLTYPE_UINT
operator||
name|CTLFLAG_RW
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sysctl_debug_ddb_capture_bufsize
argument_list|,
literal|"IU"
argument_list|,
literal|"Size of DDB capture buffer"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Sysctl to read out the capture buffer from userspace.  We require  * privilege as sensitive process/memory information may be accessed.  */
end_comment

begin_function
specifier|static
name|int
name|sysctl_debug_ddb_capture_data
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|error
operator|=
name|priv_check
argument_list|(
name|req
operator|->
name|td
argument_list|,
name|PRIV_DDB_CAPTURE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sx_slock
argument_list|(
operator|&
name|db_capture_sx
argument_list|)
expr_stmt|;
name|error
operator|=
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|db_capture_buf
argument_list|,
name|db_capture_bufoff
argument_list|)
expr_stmt|;
name|sx_sunlock
argument_list|(
operator|&
name|db_capture_sx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ch
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_debug_ddb_capture
argument_list|,
name|OID_AUTO
argument_list|,
name|data
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_debug_ddb_capture_data
argument_list|,
literal|"A"
argument_list|,
literal|"DDB capture data"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Routines for capturing DDB output into a fixed-size buffer.  These are  * invoked from DDB's input and output routines.  If we hit the limit on the  * buffer, we simply drop further data.  */
end_comment

begin_function
name|void
name|db_capture_write
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|u_int
name|buflen
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
if|if
condition|(
name|db_capture_inprogress
operator|==
literal|0
operator|||
name|db_capture_inpager
condition|)
return|return;
name|len
operator|=
name|min
argument_list|(
name|buflen
argument_list|,
name|db_capture_bufsize
operator|-
name|db_capture_bufoff
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buffer
argument_list|,
name|db_capture_buf
operator|+
name|db_capture_bufoff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|db_capture_bufoff
operator|+=
name|len
expr_stmt|;
name|KASSERT
argument_list|(
name|db_capture_bufoff
operator|<=
name|db_capture_bufsize
argument_list|,
operator|(
literal|"db_capture_write: bufoff> bufsize"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_capture_writech
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|db_capture_write
argument_list|(
operator|&
name|ch
argument_list|,
sizeof|sizeof
argument_list|(
name|ch
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_capture_enterpager
parameter_list|(
name|void
parameter_list|)
block|{
name|db_capture_inpager
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_capture_exitpager
parameter_list|(
name|void
parameter_list|)
block|{
name|db_capture_inpager
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Zero out any bytes left in the last block of the DDB capture buffer.  This  * is run shortly before writing the blocks to disk, rather than when output  * capture is stopped, in order to avoid injecting nul's into the middle of  * output.  */
end_comment

begin_function
specifier|static
name|void
name|db_capture_zeropad
parameter_list|(
name|void
parameter_list|)
block|{
name|u_int
name|len
decl_stmt|;
name|len
operator|=
name|min
argument_list|(
name|TEXTDUMP_BLOCKSIZE
argument_list|,
operator|(
name|db_capture_bufsize
operator|-
name|db_capture_bufoff
operator|)
operator|%
name|TEXTDUMP_BLOCKSIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|db_capture_buf
operator|+
name|db_capture_bufoff
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|db_capture_bufpadding
operator|=
name|len
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset capture state, which flushes buffers.  */
end_comment

begin_function
specifier|static
name|void
name|db_capture_reset
parameter_list|(
name|void
parameter_list|)
block|{
name|db_capture_inprogress
operator|=
literal|0
expr_stmt|;
name|db_capture_bufoff
operator|=
literal|0
expr_stmt|;
name|db_capture_bufpadding
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start capture.  Only one session is allowed at any time, but we may  * continue a previous session, so the buffer isn't reset.  */
end_comment

begin_function
specifier|static
name|void
name|db_capture_start
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|db_capture_inprogress
condition|)
block|{
name|db_printf
argument_list|(
literal|"Capture already started\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_capture_inprogress
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Terminate DDB output capture--real work is deferred to db_capture_dump,  * which executes outside of the DDB context.  We don't zero pad here because  * capture may be started again before the dump takes place.  */
end_comment

begin_function
specifier|static
name|void
name|db_capture_stop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|db_capture_inprogress
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"Capture not started\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|db_capture_inprogress
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dump DDB(4) captured output (and resets capture buffers).  */
end_comment

begin_function
name|void
name|db_capture_dump
parameter_list|(
name|struct
name|dumperinfo
modifier|*
name|di
parameter_list|)
block|{
name|u_int
name|offset
decl_stmt|;
if|if
condition|(
name|db_capture_bufoff
operator|==
literal|0
condition|)
return|return;
name|db_capture_zeropad
argument_list|()
expr_stmt|;
name|textdump_mkustar
argument_list|(
name|textdump_block_buffer
argument_list|,
name|DDB_CAPTURE_FILENAME
argument_list|,
name|db_capture_bufoff
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|textdump_block_buffer
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|db_capture_bufoff
operator|+
name|db_capture_bufpadding
condition|;
name|offset
operator|+=
name|TEXTDUMP_BLOCKSIZE
control|)
operator|(
name|void
operator|)
name|textdump_writenextblock
argument_list|(
name|di
argument_list|,
name|db_capture_buf
operator|+
name|offset
argument_list|)
expr_stmt|;
name|db_capture_bufoff
operator|=
literal|0
expr_stmt|;
name|db_capture_bufpadding
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*-  * DDB(4) command to manage capture:  *  * capture on          - start DDB output capture  * capture off         - stop DDB output capture  * capture reset       - reset DDB capture buffer (also stops capture)  * capture status      - print DDB output capture status  */
end_comment

begin_function
specifier|static
name|void
name|db_capture_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|db_error
argument_list|(
literal|"capture [on|off|reset|status]\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_capture_cmd
parameter_list|(
name|db_expr_t
name|addr
parameter_list|,
name|bool
name|have_addr
parameter_list|,
name|db_expr_t
name|count
parameter_list|,
name|char
modifier|*
name|modif
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|t
operator|=
name|db_read_token
argument_list|()
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|tIDENT
condition|)
block|{
name|db_capture_usage
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|db_read_token
argument_list|()
operator|!=
name|tEOL
condition|)
name|db_error
argument_list|(
literal|"?\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
condition|)
name|db_capture_start
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|db_capture_stop
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"reset"
argument_list|)
operator|==
literal|0
condition|)
name|db_capture_reset
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|db_tok_string
argument_list|,
literal|"status"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|db_printf
argument_list|(
literal|"%u/%u bytes used\n"
argument_list|,
name|db_capture_bufoff
argument_list|,
name|db_capture_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_capture_inprogress
condition|)
name|db_printf
argument_list|(
literal|"capture is on\n"
argument_list|)
expr_stmt|;
else|else
name|db_printf
argument_list|(
literal|"capture is off\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|db_capture_usage
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

