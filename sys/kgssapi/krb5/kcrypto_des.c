begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  * Authors: Doug Rabson<dfr@rabson.org>  * Developed with Red Inc: Alfred Perlstein<alfred@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/md5.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<crypto/des/des.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/gssapi.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/gssapi_impl.h>
end_include

begin_include
include|#
directive|include
file|"kcrypto.h"
end_include

begin_struct
struct|struct
name|des1_state
block|{
name|struct
name|mtx
name|ds_lock
decl_stmt|;
name|uint64_t
name|ds_session
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|des1_init
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|)
block|{
name|struct
name|des1_state
modifier|*
name|ds
decl_stmt|;
name|ds
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|des1_state
argument_list|)
argument_list|,
name|M_GSSAPI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
literal|"gss des lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ks
operator|->
name|ks_priv
operator|=
name|ds
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_destroy
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|)
block|{
name|struct
name|des1_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_session
condition|)
name|crypto_freesession
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ks
operator|->
name|ks_priv
argument_list|,
name|M_GSSAPI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_set_key
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|void
modifier|*
name|kp
init|=
name|ks
operator|->
name|ks_key
decl_stmt|;
name|struct
name|des1_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
name|struct
name|cryptoini
name|cri
index|[
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|kp
operator|!=
name|in
condition|)
name|bcopy
argument_list|(
name|in
argument_list|,
name|kp
argument_list|,
name|ks
operator|->
name|ks_class
operator|->
name|ec_keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_session
condition|)
name|crypto_freesession
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cri
argument_list|,
sizeof|sizeof
argument_list|(
name|cri
argument_list|)
argument_list|)
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_alg
operator|=
name|CRYPTO_DES_CBC
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_klen
operator|=
literal|64
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_mlen
operator|=
literal|0
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_key
operator|=
name|ks
operator|->
name|ks_key
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_next
operator|=
name|NULL
expr_stmt|;
name|crypto_newsession
argument_list|(
operator|&
name|ds
operator|->
name|ds_session
argument_list|,
name|cri
argument_list|,
name|CRYPTOCAP_F_HARDWARE
operator||
name|CRYPTOCAP_F_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_random_to_key
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|uint8_t
modifier|*
name|outkey
init|=
name|ks
operator|->
name|ks_key
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|inkey
init|=
name|in
decl_stmt|;
comment|/* 	 * Expand 56 bits of random data to 64 bits as follows 	 * (in the example, bit number 1 is the MSB of the 56 	 * bits of random data): 	 * 	 * expanded =  	 *	 1  2  3  4  5  6  7  p 	 *	 9 10 11 12 13 14 15  p 	 *	17 18 19 20 21 22 23  p 	 *	25 26 27 28 29 30 31  p 	 *	33 34 35 36 37 38 39  p 	 *	41 42 43 44 45 46 47  p 	 *	49 50 51 52 53 54 55  p 	 *	56 48 40 32 24 16  8  p 	 */
name|outkey
index|[
literal|0
index|]
operator|=
name|inkey
index|[
literal|0
index|]
expr_stmt|;
name|outkey
index|[
literal|1
index|]
operator|=
name|inkey
index|[
literal|1
index|]
expr_stmt|;
name|outkey
index|[
literal|2
index|]
operator|=
name|inkey
index|[
literal|2
index|]
expr_stmt|;
name|outkey
index|[
literal|3
index|]
operator|=
name|inkey
index|[
literal|3
index|]
expr_stmt|;
name|outkey
index|[
literal|4
index|]
operator|=
name|inkey
index|[
literal|4
index|]
expr_stmt|;
name|outkey
index|[
literal|5
index|]
operator|=
name|inkey
index|[
literal|5
index|]
expr_stmt|;
name|outkey
index|[
literal|6
index|]
operator|=
name|inkey
index|[
literal|6
index|]
expr_stmt|;
name|outkey
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|inkey
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|1
index|]
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|2
index|]
operator|&
literal|1
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|3
index|]
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|4
index|]
operator|&
literal|1
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|5
index|]
operator|&
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|des_set_odd_parity
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|outkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|des_is_weak_key
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|outkey
argument_list|)
condition|)
name|outkey
index|[
literal|7
index|]
operator|^=
literal|0xf0
expr_stmt|;
name|des1_set_key
argument_list|(
name|ks
argument_list|,
name|ks
operator|->
name|ks_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|des1_crypto_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|des1_state
modifier|*
name|ds
init|=
operator|(
expr|struct
name|des1_state
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
decl_stmt|;
if|if
condition|(
name|CRYPTO_SESID2CAPS
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
operator|&
name|CRYPTOCAP_F_SYNC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_DONE
operator|)
condition|)
name|wakeup
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_encrypt_1
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|int
name|buftype
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|,
name|int
name|encdec
parameter_list|)
block|{
name|struct
name|des1_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|crd
operator|->
name|crd_skip
operator|=
name|skip
expr_stmt|;
name|crd
operator|->
name|crd_len
operator|=
name|len
expr_stmt|;
name|crd
operator|->
name|crd_flags
operator|=
name|CRD_F_IV_EXPLICIT
operator||
name|CRD_F_IV_PRESENT
operator||
name|encdec
expr_stmt|;
if|if
condition|(
name|ivec
condition|)
block|{
name|bcopy
argument_list|(
name|ivec
argument_list|,
name|crd
operator|->
name|crd_iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|crd
operator|->
name|crd_iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|crd
operator|->
name|crd_next
operator|=
name|NULL
expr_stmt|;
name|crd
operator|->
name|crd_alg
operator|=
name|CRYPTO_DES_CBC
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|ds
operator|->
name|ds_session
expr_stmt|;
name|crp
operator|->
name|crp_flags
operator|=
name|buftype
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
name|buf
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|void
operator|*
operator|)
name|ds
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|des1_crypto_cb
expr_stmt|;
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CRYPTO_SESID2CAPS
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
operator|&
name|CRYPTOCAP_F_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_DONE
operator|)
condition|)
name|error
operator|=
name|msleep
argument_list|(
name|crp
argument_list|,
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
literal|0
argument_list|,
literal|"gssdes"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_encrypt
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|,
name|size_t
name|ivlen
parameter_list|)
block|{
name|des1_encrypt_1
argument_list|(
name|ks
argument_list|,
name|CRYPTO_F_IMBUF
argument_list|,
name|inout
argument_list|,
name|skip
argument_list|,
name|len
argument_list|,
name|ivec
argument_list|,
name|CRD_F_ENCRYPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_decrypt
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|,
name|size_t
name|ivlen
parameter_list|)
block|{
name|des1_encrypt_1
argument_list|(
name|ks
argument_list|,
name|CRYPTO_F_IMBUF
argument_list|,
name|inout
argument_list|,
name|skip
argument_list|,
name|len
argument_list|,
name|ivec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|MD5Update_int
parameter_list|(
name|void
modifier|*
name|ctx
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|MD5Update
argument_list|(
name|ctx
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|des1_checksum
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|int
name|usage
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|inlen
parameter_list|,
name|size_t
name|outlen
parameter_list|)
block|{
name|char
name|hash
index|[
literal|16
index|]
decl_stmt|;
name|MD5_CTX
name|md5
decl_stmt|;
comment|/* 	 * This checksum is specifically for GSS-API. First take the 	 * MD5 checksum of the message, then calculate the CBC mode 	 * checksum of that MD5 checksum using a zero IV. 	 */
name|MD5Init
argument_list|(
operator|&
name|md5
argument_list|)
expr_stmt|;
name|m_apply
argument_list|(
name|inout
argument_list|,
name|skip
argument_list|,
name|inlen
argument_list|,
name|MD5Update_int
argument_list|,
operator|&
name|md5
argument_list|)
expr_stmt|;
name|MD5Final
argument_list|(
name|hash
argument_list|,
operator|&
name|md5
argument_list|)
expr_stmt|;
name|des1_encrypt_1
argument_list|(
name|ks
argument_list|,
literal|0
argument_list|,
name|hash
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
name|NULL
argument_list|,
name|CRD_F_ENCRYPT
argument_list|)
expr_stmt|;
name|m_copyback
argument_list|(
name|inout
argument_list|,
name|skip
operator|+
name|inlen
argument_list|,
name|outlen
argument_list|,
name|hash
operator|+
literal|8
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|krb5_encryption_class
name|krb5_des_encryption_class
init|=
block|{
literal|"des-cbc-md5"
block|,
comment|/* name */
name|ETYPE_DES_CBC_CRC
block|,
comment|/* etype */
literal|0
block|,
comment|/* flags */
literal|8
block|,
comment|/* blocklen */
literal|8
block|,
comment|/* msgblocklen */
literal|8
block|,
comment|/* checksumlen */
literal|56
block|,
comment|/* keybits */
literal|8
block|,
comment|/* keylen */
name|des1_init
block|,
name|des1_destroy
block|,
name|des1_set_key
block|,
name|des1_random_to_key
block|,
name|des1_encrypt
block|,
name|des1_decrypt
block|,
name|des1_checksum
block|}
decl_stmt|;
end_decl_stmt

end_unit

