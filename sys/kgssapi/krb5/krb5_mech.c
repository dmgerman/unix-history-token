begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  * Authors: Doug Rabson<dfr@rabson.org>  * Developed with Red Inc: Alfred Perlstein<alfred@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/gssapi.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/gssapi_impl.h>
end_include

begin_include
include|#
directive|include
file|"kgss_if.h"
end_include

begin_include
include|#
directive|include
file|"kcrypto.h"
end_include

begin_define
define|#
directive|define
name|GSS_TOKEN_SENT_BY_ACCEPTOR
value|1
end_define

begin_define
define|#
directive|define
name|GSS_TOKEN_SEALED
value|2
end_define

begin_define
define|#
directive|define
name|GSS_TOKEN_ACCEPTOR_SUBKEY
value|4
end_define

begin_decl_stmt
specifier|static
name|gss_OID_desc
name|krb5_mech_oid
init|=
block|{
literal|9
block|,
operator|(
name|void
operator|*
operator|)
literal|"\x2a\x86\x48\x86\xf7\x12\x01\x02\x02"
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|krb5_data
block|{
name|size_t
name|kd_length
decl_stmt|;
name|void
modifier|*
name|kd_data
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|krb5_keyblock
block|{
name|uint16_t
name|kk_type
decl_stmt|;
comment|/* encryption type */
name|struct
name|krb5_data
name|kk_key
decl_stmt|;
comment|/* key data */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|krb5_address
block|{
name|uint16_t
name|ka_type
decl_stmt|;
name|struct
name|krb5_data
name|ka_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The km_elem array is ordered so that the highest received sequence  * number is listed first.  */
end_comment

begin_struct
struct|struct
name|krb5_msg_order
block|{
name|uint32_t
name|km_flags
decl_stmt|;
name|uint32_t
name|km_start
decl_stmt|;
name|uint32_t
name|km_length
decl_stmt|;
name|uint32_t
name|km_jitter_window
decl_stmt|;
name|uint32_t
name|km_first_seq
decl_stmt|;
name|uint32_t
modifier|*
name|km_elem
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|krb5_context
block|{
name|struct
name|_gss_ctx_id_t
name|kc_common
decl_stmt|;
name|struct
name|mtx
name|kc_lock
decl_stmt|;
name|uint32_t
name|kc_ac_flags
decl_stmt|;
name|uint32_t
name|kc_ctx_flags
decl_stmt|;
name|uint32_t
name|kc_more_flags
decl_stmt|;
define|#
directive|define
name|LOCAL
value|1
define|#
directive|define
name|OPEN
value|2
define|#
directive|define
name|COMPAT_OLD_DES3
value|4
define|#
directive|define
name|COMPAT_OLD_DES3_SELECTED
value|8
define|#
directive|define
name|ACCEPTOR_SUBKEY
value|16
name|struct
name|krb5_address
name|kc_local_address
decl_stmt|;
name|struct
name|krb5_address
name|kc_remote_address
decl_stmt|;
name|uint16_t
name|kc_local_port
decl_stmt|;
name|uint16_t
name|kc_remote_port
decl_stmt|;
name|struct
name|krb5_keyblock
name|kc_keyblock
decl_stmt|;
name|struct
name|krb5_keyblock
name|kc_local_subkey
decl_stmt|;
name|struct
name|krb5_keyblock
name|kc_remote_subkey
decl_stmt|;
specifier|volatile
name|uint32_t
name|kc_local_seqnumber
decl_stmt|;
name|uint32_t
name|kc_remote_seqnumber
decl_stmt|;
name|uint32_t
name|kc_keytype
decl_stmt|;
name|uint32_t
name|kc_cksumtype
decl_stmt|;
name|struct
name|krb5_data
name|kc_source_name
decl_stmt|;
name|struct
name|krb5_data
name|kc_target_name
decl_stmt|;
name|uint32_t
name|kc_lifetime
decl_stmt|;
name|struct
name|krb5_msg_order
name|kc_msg_order
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_tokenkey
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_encryptkey
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_checksumkey
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_send_seal_Ke
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_send_seal_Ki
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_send_seal_Kc
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_send_sign_Kc
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_recv_seal_Ke
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_recv_seal_Ki
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_recv_seal_Kc
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|kc_recv_sign_Kc
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|uint16_t
name|get_uint16
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|pp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
if|if
condition|(
operator|*
name|lenp
operator|<
literal|2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|v
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|2
expr_stmt|;
operator|*
name|lenp
operator|=
operator|*
name|lenp
operator|-
literal|2
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|get_uint32
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|pp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|uint32_t
name|v
decl_stmt|;
if|if
condition|(
operator|*
name|lenp
operator|<
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|v
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
expr_stmt|;
operator|*
name|pp
operator|=
name|p
operator|+
literal|4
expr_stmt|;
operator|*
name|lenp
operator|=
operator|*
name|lenp
operator|-
literal|4
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_data
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|pp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|struct
name|krb5_data
modifier|*
name|dp
parameter_list|)
block|{
name|size_t
name|sz
init|=
name|get_uint32
argument_list|(
name|pp
argument_list|,
name|lenp
argument_list|)
decl_stmt|;
name|dp
operator|->
name|kd_length
operator|=
name|sz
expr_stmt|;
name|dp
operator|->
name|kd_data
operator|=
name|malloc
argument_list|(
name|sz
argument_list|,
name|M_GSSAPI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|lenp
operator|<
name|sz
condition|)
name|sz
operator|=
operator|*
name|lenp
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|pp
argument_list|,
name|dp
operator|->
name|kd_data
argument_list|,
name|sz
argument_list|)
expr_stmt|;
operator|(
operator|*
name|pp
operator|)
operator|+=
name|sz
expr_stmt|;
operator|(
operator|*
name|lenp
operator|)
operator|-=
name|sz
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_data
parameter_list|(
name|struct
name|krb5_data
modifier|*
name|dp
parameter_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|kd_data
condition|)
block|{
name|free
argument_list|(
name|dp
operator|->
name|kd_data
argument_list|,
name|M_GSSAPI
argument_list|)
expr_stmt|;
name|dp
operator|->
name|kd_length
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|kd_data
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_address
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|pp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|struct
name|krb5_address
modifier|*
name|ka
parameter_list|)
block|{
name|ka
operator|->
name|ka_type
operator|=
name|get_uint16
argument_list|(
name|pp
argument_list|,
name|lenp
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|pp
argument_list|,
name|lenp
argument_list|,
operator|&
name|ka
operator|->
name|ka_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_address
parameter_list|(
name|struct
name|krb5_address
modifier|*
name|ka
parameter_list|)
block|{
name|delete_data
argument_list|(
operator|&
name|ka
operator|->
name|ka_addr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_keyblock
parameter_list|(
specifier|const
name|uint8_t
modifier|*
modifier|*
name|pp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|struct
name|krb5_keyblock
modifier|*
name|kk
parameter_list|)
block|{
name|kk
operator|->
name|kk_type
operator|=
name|get_uint16
argument_list|(
name|pp
argument_list|,
name|lenp
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
name|pp
argument_list|,
name|lenp
argument_list|,
operator|&
name|kk
operator|->
name|kk_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|delete_keyblock
parameter_list|(
name|struct
name|krb5_keyblock
modifier|*
name|kk
parameter_list|)
block|{
if|if
condition|(
name|kk
operator|->
name|kk_key
operator|.
name|kd_data
condition|)
name|bzero
argument_list|(
name|kk
operator|->
name|kk_key
operator|.
name|kd_data
argument_list|,
name|kk
operator|->
name|kk_key
operator|.
name|kd_length
argument_list|)
expr_stmt|;
name|delete_data
argument_list|(
operator|&
name|kk
operator|->
name|kk_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|copy_key
parameter_list|(
name|struct
name|krb5_keyblock
modifier|*
name|from
parameter_list|,
name|struct
name|krb5_keyblock
modifier|*
modifier|*
name|to
parameter_list|)
block|{
if|if
condition|(
name|from
operator|->
name|kk_key
operator|.
name|kd_length
condition|)
operator|*
name|to
operator|=
name|from
expr_stmt|;
else|else
operator|*
name|to
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return non-zero if we are initiator.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_initiator
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|)
block|{
return|return
operator|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|LOCAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return non-zero if we are acceptor.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|is_acceptor
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|)
block|{
return|return
operator|!
operator|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|LOCAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_initiator_subkey
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|krb5_keyblock
modifier|*
modifier|*
name|kdp
parameter_list|)
block|{
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
name|copy_key
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_subkey
argument_list|,
name|kdp
argument_list|)
expr_stmt|;
else|else
name|copy_key
argument_list|(
operator|&
name|kc
operator|->
name|kc_remote_subkey
argument_list|,
name|kdp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|kdp
condition|)
name|copy_key
argument_list|(
operator|&
name|kc
operator|->
name|kc_keyblock
argument_list|,
name|kdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_acceptor_subkey
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|krb5_keyblock
modifier|*
modifier|*
name|kdp
parameter_list|)
block|{
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
name|copy_key
argument_list|(
operator|&
name|kc
operator|->
name|kc_remote_subkey
argument_list|,
name|kdp
argument_list|)
expr_stmt|;
else|else
name|copy_key
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_subkey
argument_list|,
name|kdp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|get_keys
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|)
block|{
name|struct
name|krb5_keyblock
modifier|*
name|keydata
decl_stmt|;
name|struct
name|krb5_encryption_class
modifier|*
name|ec
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|key
decl_stmt|;
name|int
name|etype
decl_stmt|;
name|keydata
operator|=
name|NULL
expr_stmt|;
name|get_acceptor_subkey
argument_list|(
name|kc
argument_list|,
operator|&
name|keydata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keydata
condition|)
if|if
condition|(
operator|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|ACCEPTOR_SUBKEY
operator|)
operator|==
literal|0
condition|)
name|get_initiator_subkey
argument_list|(
name|kc
argument_list|,
operator|&
name|keydata
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|keydata
condition|)
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
comment|/* 	 * GSS-API treats all DES etypes the same and all DES3 etypes 	 * the same. 	 */
switch|switch
condition|(
name|keydata
operator|->
name|kk_type
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
case|case
name|ETYPE_DES_CBC_MD4
case|:
case|case
name|ETYPE_DES_CBC_MD5
case|:
name|etype
operator|=
name|ETYPE_DES_CBC_CRC
expr_stmt|;
break|break;
case|case
name|ETYPE_DES3_CBC_MD5
case|:
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
case|case
name|ETYPE_OLD_DES3_CBC_SHA1
case|:
name|etype
operator|=
name|ETYPE_DES3_CBC_SHA1
expr_stmt|;
break|break;
default|default:
name|etype
operator|=
name|keydata
operator|->
name|kk_type
expr_stmt|;
block|}
name|ec
operator|=
name|krb5_find_encryption_class
argument_list|(
name|etype
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ec
condition|)
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
name|key
operator|=
name|krb5_create_key
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|krb5_set_key
argument_list|(
name|key
argument_list|,
name|keydata
operator|->
name|kk_key
operator|.
name|kd_data
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_tokenkey
operator|=
name|key
expr_stmt|;
switch|switch
condition|(
name|etype
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
block|{
comment|/* 		 * Single DES and ARCFOUR uses a 'derived' key (XOR 		 * with 0xf0) for encrypting wrap tokens. The original 		 * key is used for checksums and sequence numbers. 		 */
name|struct
name|krb5_key_state
modifier|*
name|ekey
decl_stmt|;
name|uint8_t
modifier|*
name|ekp
decl_stmt|,
modifier|*
name|kp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ekey
operator|=
name|krb5_create_key
argument_list|(
name|ec
argument_list|)
expr_stmt|;
name|ekp
operator|=
name|ekey
operator|->
name|ks_key
expr_stmt|;
name|kp
operator|=
name|key
operator|->
name|ks_key
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ec
operator|->
name|ec_keylen
condition|;
name|i
operator|++
control|)
name|ekp
index|[
name|i
index|]
operator|=
name|kp
index|[
name|i
index|]
operator|^
literal|0xf0
expr_stmt|;
name|krb5_set_key
argument_list|(
name|ekey
argument_list|,
name|ekp
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_encryptkey
operator|=
name|ekey
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|key
operator|->
name|ks_refs
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_checksumkey
operator|=
name|key
expr_stmt|;
break|break;
block|}
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
comment|/* 		 * Triple DES uses a RFC 3961 style derived key with 		 * usage number KG_USAGE_SIGN for checksums. The 		 * original key is used for encryption and sequence 		 * numbers. 		 */
name|kc
operator|->
name|kc_checksumkey
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_SIGN
argument_list|)
expr_stmt|;
name|refcount_acquire
argument_list|(
operator|&
name|key
operator|->
name|ks_refs
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_encryptkey
operator|=
name|key
expr_stmt|;
break|break;
default|default:
comment|/* 		 * We need eight derived keys four for sending and 		 * four for receiving. 		 */
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
block|{
comment|/* 			 * We are initiator. 			 */
name|kc
operator|->
name|kc_send_seal_Ke
operator|=
name|krb5_get_encryption_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_send_seal_Ki
operator|=
name|krb5_get_integrity_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_send_seal_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_send_sign_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SIGN
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_seal_Ke
operator|=
name|krb5_get_encryption_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_seal_Ki
operator|=
name|krb5_get_integrity_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_seal_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_sign_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SIGN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We are acceptor. 			 */
name|kc
operator|->
name|kc_send_seal_Ke
operator|=
name|krb5_get_encryption_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_send_seal_Ki
operator|=
name|krb5_get_integrity_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_send_seal_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_send_sign_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_ACCEPTOR_SIGN
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_seal_Ke
operator|=
name|krb5_get_encryption_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_seal_Ki
operator|=
name|krb5_get_integrity_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_seal_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SEAL
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_recv_sign_Kc
operator|=
name|krb5_get_checksum_key
argument_list|(
name|key
argument_list|,
name|KG_USAGE_INITIATOR_SIGN
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|krb5_init
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
name|mtx_init
argument_list|(
operator|&
name|kc
operator|->
name|kc_lock
argument_list|,
literal|"krb5 gss lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_import
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|enum
name|sec_context_format
name|format
parameter_list|,
specifier|const
name|gss_buffer_t
name|context_token
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
name|OM_uint32
name|res
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|p
init|=
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|context_token
operator|->
name|value
decl_stmt|;
name|size_t
name|len
init|=
name|context_token
operator|->
name|length
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * We support heimdal 0.6 and heimdal 1.1 	 */
if|if
condition|(
name|format
operator|!=
name|KGSS_HEIMDAL_0_6
operator|&&
name|format
operator|!=
name|KGSS_HEIMDAL_1_1
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
define|#
directive|define
name|SC_LOCAL_ADDRESS
value|1
define|#
directive|define
name|SC_REMOTE_ADDRESS
value|2
define|#
directive|define
name|SC_KEYBLOCK
value|4
define|#
directive|define
name|SC_LOCAL_SUBKEY
value|8
define|#
directive|define
name|SC_REMOTE_SUBKEY
value|16
comment|/* 	 * Ensure that the token starts with krb5 oid. 	 */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0x00
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|krb5_mech_oid
operator|.
name|length
operator|||
name|len
operator|<
name|krb5_mech_oid
operator|.
name|length
operator|+
literal|2
operator|||
name|bcmp
argument_list|(
name|krb5_mech_oid
operator|.
name|elements
argument_list|,
name|p
operator|+
literal|2
argument_list|,
name|krb5_mech_oid
operator|.
name|length
argument_list|)
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
name|krb5_mech_oid
operator|.
name|length
operator|+
literal|2
expr_stmt|;
name|len
operator|-=
name|krb5_mech_oid
operator|.
name|length
operator|+
literal|2
expr_stmt|;
name|flags
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_ac_flags
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SC_LOCAL_ADDRESS
condition|)
name|get_address
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_local_address
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SC_REMOTE_ADDRESS
condition|)
name|get_address
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_remote_address
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_local_port
operator|=
name|get_uint16
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_remote_port
operator|=
name|get_uint16
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SC_KEYBLOCK
condition|)
name|get_keyblock
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_keyblock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SC_LOCAL_SUBKEY
condition|)
name|get_keyblock
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_local_subkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SC_REMOTE_SUBKEY
condition|)
name|get_keyblock
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_remote_subkey
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_local_seqnumber
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_remote_seqnumber
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_keytype
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_cksumtype
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_source_name
argument_list|)
expr_stmt|;
name|get_data
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|kc
operator|->
name|kc_target_name
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_ctx_flags
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_more_flags
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_lifetime
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
comment|/* 	 * Heimdal 1.1 adds the message order stuff. 	 */
if|if
condition|(
name|format
operator|==
name|KGSS_HEIMDAL_1_1
condition|)
block|{
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_flags
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_start
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_length
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_jitter_window
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_first_seq
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_elem
operator|=
name|malloc
argument_list|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_jitter_window
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_GSSAPI
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_jitter_window
condition|;
name|i
operator|++
control|)
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_elem
index|[
name|i
index|]
operator|=
name|get_uint32
argument_list|(
operator|&
name|p
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_flags
operator|=
literal|0
expr_stmt|;
block|}
name|res
operator|=
name|get_keys
argument_list|(
name|kc
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|res
argument_list|)
condition|)
return|return
operator|(
name|res
operator|)
return|;
comment|/* 	 * We don't need these anymore. 	 */
name|delete_keyblock
argument_list|(
operator|&
name|kc
operator|->
name|kc_keyblock
argument_list|)
expr_stmt|;
name|delete_keyblock
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_subkey
argument_list|)
expr_stmt|;
name|delete_keyblock
argument_list|(
operator|&
name|kc
operator|->
name|kc_remote_subkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|krb5_delete
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|gss_buffer_t
name|output_token
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
name|delete_address
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_address
argument_list|)
expr_stmt|;
name|delete_address
argument_list|(
operator|&
name|kc
operator|->
name|kc_remote_address
argument_list|)
expr_stmt|;
name|delete_keyblock
argument_list|(
operator|&
name|kc
operator|->
name|kc_keyblock
argument_list|)
expr_stmt|;
name|delete_keyblock
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_subkey
argument_list|)
expr_stmt|;
name|delete_keyblock
argument_list|(
operator|&
name|kc
operator|->
name|kc_remote_subkey
argument_list|)
expr_stmt|;
name|delete_data
argument_list|(
operator|&
name|kc
operator|->
name|kc_source_name
argument_list|)
expr_stmt|;
name|delete_data
argument_list|(
operator|&
name|kc
operator|->
name|kc_target_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_elem
condition|)
name|free
argument_list|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_elem
argument_list|,
name|M_GSSAPI
argument_list|)
expr_stmt|;
if|if
condition|(
name|output_token
condition|)
block|{
name|output_token
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|output_token
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|kc
operator|->
name|kc_tokenkey
condition|)
block|{
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_encryptkey
condition|)
block|{
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_encryptkey
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_checksumkey
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_send_seal_Ke
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_send_seal_Ki
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_send_seal_Kc
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_send_sign_Kc
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_recv_seal_Ke
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_recv_seal_Ki
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_recv_seal_Kc
argument_list|)
expr_stmt|;
name|krb5_free_key
argument_list|(
name|kc
operator|->
name|kc_recv_sign_Kc
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_destroy
argument_list|(
operator|&
name|kc
operator|->
name|kc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|gss_OID
name|krb5_mech_type
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|)
block|{
return|return
operator|(
operator|&
name|krb5_mech_oid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a token with the given type and length (the length includes  * the TOK_ID), initialising the token header appropriately. Return a  * pointer to the TOK_ID of the token.  A new mbuf is allocated with  * the framing header plus hlen bytes of space.  *  * Format is as follows:  *  *	0x60			[APPLICATION 0] SEQUENCE  *	DER encoded length	length of oid + type + inner token length  *	0x06 NN<oid data>	OID of mechanism type  *	TT TT			TOK_ID  *<inner token>		data for inner token  *	  * 1:		der encoded length  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|krb5_make_token
parameter_list|(
name|char
name|tok_id
index|[
literal|2
index|]
parameter_list|,
name|size_t
name|hlen
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|)
block|{
name|size_t
name|inside_len
decl_stmt|,
name|len_len
decl_stmt|,
name|tlen
decl_stmt|;
name|gss_OID
name|oid
init|=
operator|&
name|krb5_mech_oid
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|inside_len
operator|=
literal|2
operator|+
name|oid
operator|->
name|length
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|inside_len
operator|<
literal|128
condition|)
name|len_len
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|inside_len
operator|<
literal|0x100
condition|)
name|len_len
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|inside_len
operator|<
literal|0x10000
condition|)
name|len_len
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|inside_len
operator|<
literal|0x1000000
condition|)
name|len_len
operator|=
literal|4
expr_stmt|;
else|else
name|len_len
operator|=
literal|5
expr_stmt|;
name|tlen
operator|=
literal|1
operator|+
name|len_len
operator|+
literal|2
operator|+
name|oid
operator|->
name|length
operator|+
name|hlen
expr_stmt|;
name|KASSERT
argument_list|(
name|tlen
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"token head too large"
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|M_ALIGN
argument_list|(
name|m
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|tlen
expr_stmt|;
name|p
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|m_data
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0x60
expr_stmt|;
switch|switch
condition|(
name|len_len
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p
operator|++
operator|=
name|inside_len
expr_stmt|;
break|break;
case|case
literal|2
case|:
operator|*
name|p
operator|++
operator|=
literal|0x81
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
expr_stmt|;
break|break;
case|case
literal|3
case|:
operator|*
name|p
operator|++
operator|=
literal|0x82
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
operator|>>
literal|8
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|p
operator|++
operator|=
literal|0x83
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
operator|>>
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
operator|>>
literal|8
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
expr_stmt|;
break|break;
case|case
literal|5
case|:
operator|*
name|p
operator|++
operator|=
literal|0x84
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
operator|>>
literal|24
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
operator|>>
literal|16
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
operator|>>
literal|8
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|inside_len
expr_stmt|;
break|break;
block|}
operator|*
name|p
operator|++
operator|=
literal|0x06
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|oid
operator|->
name|length
expr_stmt|;
name|bcopy
argument_list|(
name|oid
operator|->
name|elements
argument_list|,
name|p
argument_list|,
name|oid
operator|->
name|length
argument_list|)
expr_stmt|;
name|p
operator|+=
name|oid
operator|->
name|length
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
name|tok_id
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|tok_id
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify a token, checking the inner token length and mechanism oid.  * pointer to the first byte of the TOK_ID. The length of the  * encapsulated data is checked to be at least len bytes; the actual  * length of the encapsulated data (including TOK_ID) is returned in  * *encap_len.  *  * If can_pullup is TRUE and the token header is fragmented, we will  * rearrange it.  *  * Format is as follows:  *  *	0x60			[APPLICATION 0] SEQUENCE  *	DER encoded length	length of oid + type + inner token length  *	0x06 NN<oid data>	OID of mechanism type  *	TT TT			TOK_ID  *<inner token>		data for inner token  *	  * 1:		der encoded length  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|krb5_verify_token
parameter_list|(
name|char
name|tok_id
index|[
literal|2
index|]
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|size_t
modifier|*
name|encap_len
parameter_list|,
name|bool_t
name|can_pullup
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|size_t
name|tlen
decl_stmt|,
name|hlen
decl_stmt|,
name|len_len
decl_stmt|,
name|inside_len
decl_stmt|;
name|gss_OID
name|oid
init|=
operator|&
name|krb5_mech_oid
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|tlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
literal|2
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Ensure that at least the framing part of the token is 	 * contigous. 	 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|2
condition|)
block|{
if|if
condition|(
name|can_pullup
condition|)
operator|*
name|mp
operator|=
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x60
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|<
literal|0x80
condition|)
block|{
name|inside_len
operator|=
operator|*
name|p
operator|++
expr_stmt|;
name|len_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Ensure there is enough space for the DER encoded length. 		 */
name|len_len
operator|=
operator|(
operator|*
name|p
operator|&
literal|0x7f
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tlen
operator|<
name|len_len
operator|+
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|len_len
operator|+
literal|1
condition|)
block|{
if|if
condition|(
name|can_pullup
condition|)
operator|*
name|mp
operator|=
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|len_len
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|m
operator|->
name|m_data
operator|+
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
operator|*
name|p
operator|++
condition|)
block|{
case|case
literal|0x81
case|:
name|inside_len
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
case|case
literal|0x82
case|:
name|inside_len
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|0x83
case|:
name|inside_len
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|2
index|]
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|0x84
case|:
name|inside_len
operator|=
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|3
index|]
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|tlen
operator|!=
name|inside_len
operator|+
name|len_len
operator|+
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|inside_len
operator|<
literal|2
operator|+
name|oid
operator|->
name|length
operator|+
name|len
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Now that we know the value of len_len, we can pullup the 	 * whole header. The header is 1 + len_len + 2 + oid->length + 	 * len bytes. 	 */
name|hlen
operator|=
literal|1
operator|+
name|len_len
operator|+
literal|2
operator|+
name|oid
operator|->
name|length
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hlen
condition|)
block|{
if|if
condition|(
name|can_pullup
condition|)
operator|*
name|mp
operator|=
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|m
operator|->
name|m_data
operator|+
literal|1
operator|+
name|len_len
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
literal|0x06
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|oid
operator|->
name|length
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|bcmp
argument_list|(
name|oid
operator|->
name|elements
argument_list|,
name|p
argument_list|,
name|oid
operator|->
name|length
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|+=
name|oid
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|tok_id
index|[
literal|0
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
name|tok_id
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|encap_len
operator|=
name|inside_len
operator|-
literal|2
operator|-
name|oid
operator|->
name|length
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|krb5_insert_seq
parameter_list|(
name|struct
name|krb5_msg_order
modifier|*
name|mo
parameter_list|,
name|uint32_t
name|seq
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|mo
operator|->
name|km_length
operator|<
name|mo
operator|->
name|km_jitter_window
condition|)
name|mo
operator|->
name|km_length
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mo
operator|->
name|km_length
operator|-
literal|1
init|;
name|i
operator|>
name|index
condition|;
name|i
operator|--
control|)
name|mo
operator|->
name|km_elem
index|[
name|i
index|]
operator|=
name|mo
operator|->
name|km_elem
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|mo
operator|->
name|km_elem
index|[
name|index
index|]
operator|=
name|seq
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check sequence numbers according to RFC 2743 section 1.2.3.  */
end_comment

begin_function
specifier|static
name|OM_uint32
name|krb5_sequence_check
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|OM_uint32
name|res
init|=
name|GSS_S_FAILURE
decl_stmt|;
name|struct
name|krb5_msg_order
modifier|*
name|mo
init|=
operator|&
name|kc
operator|->
name|kc_msg_order
decl_stmt|;
name|int
name|check_sequence
init|=
name|mo
operator|->
name|km_flags
operator|&
name|GSS_C_SEQUENCE_FLAG
decl_stmt|;
name|int
name|check_replay
init|=
name|mo
operator|->
name|km_flags
operator|&
name|GSS_C_REPLAY_FLAG
decl_stmt|;
name|int
name|i
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|kc
operator|->
name|kc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Message is in-sequence with no gap. 	 */
if|if
condition|(
name|mo
operator|->
name|km_length
operator|==
literal|0
operator|||
name|seq
operator|==
name|mo
operator|->
name|km_elem
index|[
literal|0
index|]
operator|+
literal|1
condition|)
block|{
comment|/* 		 * This message is received in-sequence with no gaps. 		 */
name|krb5_insert_seq
argument_list|(
name|mo
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|res
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|seq
operator|>
name|mo
operator|->
name|km_elem
index|[
literal|0
index|]
condition|)
block|{
comment|/* 		 * This message is received in-sequence with a gap. 		 */
name|krb5_insert_seq
argument_list|(
name|mo
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_sequence
condition|)
name|res
operator|=
name|GSS_S_GAP_TOKEN
expr_stmt|;
else|else
name|res
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|seq
operator|<
name|mo
operator|->
name|km_elem
index|[
name|mo
operator|->
name|km_length
operator|-
literal|1
index|]
condition|)
block|{
if|if
condition|(
name|check_replay
operator|&&
operator|!
name|check_sequence
condition|)
name|res
operator|=
name|GSS_S_OLD_TOKEN
expr_stmt|;
else|else
name|res
operator|=
name|GSS_S_UNSEQ_TOKEN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mo
operator|->
name|km_length
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mo
operator|->
name|km_elem
index|[
name|i
index|]
operator|==
name|seq
condition|)
block|{
name|res
operator|=
name|GSS_S_DUPLICATE_TOKEN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mo
operator|->
name|km_elem
index|[
name|i
index|]
operator|<
name|seq
condition|)
block|{
comment|/* 			 * We need to insert this seq here, 			 */
name|krb5_insert_seq
argument_list|(
name|mo
argument_list|,
name|seq
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|check_replay
operator|&&
operator|!
name|check_sequence
condition|)
name|res
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
else|else
name|res
operator|=
name|GSS_S_UNSEQ_TOKEN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|out
label|:
name|mtx_unlock
argument_list|(
operator|&
name|kc
operator|->
name|kc_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|uint8_t
name|sgn_alg_des_md5
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|seal_alg_des
index|[]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|sgn_alg_des3_sha1
index|[]
init|=
block|{
literal|0x04
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|seal_alg_des3
index|[]
init|=
block|{
literal|0x02
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|seal_alg_rc4
index|[]
init|=
block|{
literal|0x10
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint8_t
name|sgn_alg_hmac_md5
index|[]
init|=
block|{
literal|0x11
block|,
literal|0x00
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the size of the inner token given the use of the key's  * encryption class. For wrap tokens, the length of the padded  * plaintext will be added to this.  */
end_comment

begin_function
specifier|static
name|size_t
name|token_length
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|key
parameter_list|)
block|{
return|return
operator|(
literal|16
operator|+
name|key
operator|->
name|ks_class
operator|->
name|ec_checksumlen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_get_mic_old
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|micp
parameter_list|,
name|uint8_t
name|sgn_alg
index|[
literal|2
index|]
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|mic
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
name|dir
decl_stmt|;
name|size_t
name|tlen
decl_stmt|,
name|mlen
decl_stmt|,
name|cklen
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|char
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|token_length
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|)
expr_stmt|;
name|p
operator|=
name|krb5_make_token
argument_list|(
literal|"\x01\x01"
argument_list|,
name|tlen
argument_list|,
name|tlen
argument_list|,
operator|&
name|mic
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* TOK_ID */
operator|*
name|p
operator|++
operator|=
name|sgn_alg
index|[
literal|0
index|]
expr_stmt|;
comment|/* SGN_ALG */
operator|*
name|p
operator|++
operator|=
name|sgn_alg
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
comment|/* filler */
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
comment|/* 	 * SGN_CKSUM: 	 * 	 * Calculate the keyed checksum of the token header plus the 	 * message. 	 */
name|cklen
operator|=
name|kc
operator|->
name|kc_checksumkey
operator|->
name|ks_class
operator|->
name|ec_checksumlen
expr_stmt|;
name|mic
operator|->
name|m_len
operator|=
name|p
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|mic
operator|->
name|m_data
expr_stmt|;
name|mic
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|tm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|cklen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|tm
expr_stmt|;
name|krb5_checksum
argument_list|(
name|kc
operator|->
name|kc_checksumkey
argument_list|,
literal|15
argument_list|,
name|mic
argument_list|,
name|mic
operator|->
name|m_len
operator|-
literal|8
argument_list|,
literal|8
operator|+
name|mlen
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|tm
operator|->
name|m_data
argument_list|,
name|p
operator|+
literal|8
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|mic
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_free
argument_list|(
name|tm
argument_list|)
expr_stmt|;
comment|/* 	 * SND_SEQ: 	 * 	 * Take the four bytes of the sequence number least 	 * significant first followed by four bytes of direction 	 * marker (zero for initiator and 0xff for acceptor). Encrypt 	 * that data using the SGN_CKSUM as IV. Note: ARC4 wants the 	 * sequence number big-endian. 	 */
name|seq
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_seqnumber
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgn_alg
index|[
literal|0
index|]
operator|==
literal|0x11
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
block|{
name|dir
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
literal|0xff
expr_stmt|;
block|}
name|p
index|[
literal|4
index|]
operator|=
name|dir
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|dir
expr_stmt|;
name|p
index|[
literal|6
index|]
operator|=
name|dir
expr_stmt|;
name|p
index|[
literal|7
index|]
operator|=
name|dir
expr_stmt|;
name|bcopy
argument_list|(
name|p
operator|+
literal|8
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * Set the mic buffer to its final size so that the encrypt 	 * can see the SND_SEQ part. 	 */
name|mic
operator|->
name|m_len
operator|+=
literal|8
operator|+
name|cklen
expr_stmt|;
name|krb5_encrypt
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|,
name|mic
argument_list|,
name|mic
operator|->
name|m_len
operator|-
name|cklen
operator|-
literal|8
argument_list|,
literal|8
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
operator|*
name|micp
operator|=
name|mic
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_get_mic_new
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|micp
parameter_list|)
block|{
name|struct
name|krb5_key_state
modifier|*
name|key
init|=
name|kc
operator|->
name|kc_send_sign_Kc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|mic
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|cklen
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|cklen
operator|=
name|key
operator|->
name|ks_class
operator|->
name|ec_checksumlen
expr_stmt|;
name|KASSERT
argument_list|(
literal|16
operator|+
name|cklen
operator|<=
name|MLEN
argument_list|,
operator|(
literal|"checksum too large for an mbuf"
operator|)
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|mic
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|M_ALIGN
argument_list|(
name|mic
argument_list|,
literal|16
operator|+
name|cklen
argument_list|)
expr_stmt|;
name|mic
operator|->
name|m_len
operator|=
literal|16
operator|+
name|cklen
expr_stmt|;
name|p
operator|=
name|mic
operator|->
name|m_data
expr_stmt|;
comment|/* TOK_ID */
name|p
index|[
literal|0
index|]
operator|=
literal|0x04
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* Flags */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_acceptor
argument_list|(
name|kc
argument_list|)
condition|)
name|flags
operator||=
name|GSS_TOKEN_SENT_BY_ACCEPTOR
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|ACCEPTOR_SUBKEY
condition|)
name|flags
operator||=
name|GSS_TOKEN_ACCEPTOR_SUBKEY
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|flags
expr_stmt|;
comment|/* Filler */
name|p
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
literal|0xff
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
literal|0xff
expr_stmt|;
name|p
index|[
literal|6
index|]
operator|=
literal|0xff
expr_stmt|;
name|p
index|[
literal|7
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* SND_SEQ */
name|p
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|11
index|]
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_seqnumber
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|12
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
name|p
index|[
literal|13
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|p
index|[
literal|14
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
index|[
literal|15
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
comment|/* 	 * SGN_CKSUM: 	 * 	 * Calculate the keyed checksum of the message plus the first 	 * 16 bytes of the token header. 	 */
name|mlast
operator|->
name|m_next
operator|=
name|mic
expr_stmt|;
name|krb5_checksum
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|mlen
operator|+
literal|16
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
operator|*
name|micp
operator|=
name|mic
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_get_mic
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|gss_qop_t
name|qop_req
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|micp
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qop_req
operator|!=
name|GSS_C_QOP_DEFAULT
condition|)
return|return
operator|(
name|GSS_S_BAD_QOP
operator|)
return|;
if|if
condition|(
name|time_uptime
operator|>
name|kc
operator|->
name|kc_lifetime
condition|)
return|return
operator|(
name|GSS_S_CONTEXT_EXPIRED
operator|)
return|;
switch|switch
condition|(
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
operator|->
name|ec_type
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
return|return
operator|(
name|krb5_get_mic_old
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|micp
argument_list|,
name|sgn_alg_des_md5
argument_list|)
operator|)
return|;
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
return|return
operator|(
name|krb5_get_mic_old
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|micp
argument_list|,
name|sgn_alg_des3_sha1
argument_list|)
operator|)
return|;
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
return|return
operator|(
name|krb5_get_mic_old
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|micp
argument_list|,
name|sgn_alg_hmac_md5
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|krb5_get_mic_new
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|micp
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_verify_mic_old
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mic
parameter_list|,
name|uint8_t
name|sgn_alg
index|[
literal|2
index|]
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
name|dir
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|tlen
decl_stmt|,
name|elen
decl_stmt|,
name|miclen
decl_stmt|;
name|size_t
name|cklen
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|token_length
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|)
expr_stmt|;
name|p
operator|=
name|krb5_verify_token
argument_list|(
literal|"\x01\x01"
argument_list|,
name|tlen
argument_list|,
operator|&
name|mic
argument_list|,
operator|&
name|elen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|#
directive|if
literal|0
comment|/* 	 * Disable this check - heimdal-1.1 generates DES3 MIC tokens 	 * that are 2 bytes too big. 	 */
block|if (elen != tlen) 		return (GSS_S_DEFECTIVE_TOKEN);
endif|#
directive|endif
comment|/* TOK_ID */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* SGN_ALG */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|sgn_alg
index|[
literal|0
index|]
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|sgn_alg
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|0xff
operator|||
name|p
index|[
literal|2
index|]
operator|!=
literal|0xff
operator|||
name|p
index|[
literal|3
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
literal|4
expr_stmt|;
comment|/* 	 * SGN_CKSUM: 	 * 	 * Calculate the keyed checksum of the token header plus the 	 * message. 	 */
name|cklen
operator|=
name|kc
operator|->
name|kc_checksumkey
operator|->
name|ks_class
operator|->
name|ec_checksumlen
expr_stmt|;
name|miclen
operator|=
name|mic
operator|->
name|m_len
expr_stmt|;
name|mic
operator|->
name|m_len
operator|=
name|p
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|mic
operator|->
name|m_data
expr_stmt|;
name|mic
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|tm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|cklen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|tm
expr_stmt|;
name|krb5_checksum
argument_list|(
name|kc
operator|->
name|kc_checksumkey
argument_list|,
literal|15
argument_list|,
name|mic
argument_list|,
name|mic
operator|->
name|m_len
operator|-
literal|8
argument_list|,
literal|8
operator|+
name|mlen
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|mic
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|tm
operator|->
name|m_data
argument_list|,
name|p
operator|+
literal|8
argument_list|,
name|cklen
argument_list|)
condition|)
block|{
name|m_free
argument_list|(
name|tm
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_BAD_SIG
operator|)
return|;
block|}
comment|/* 	 * SND_SEQ: 	 * 	 * Take the four bytes of the sequence number least 	 * significant first followed by four bytes of direction 	 * marker (zero for initiator and 0xff for acceptor). Encrypt 	 * that data using the SGN_CKSUM as IV.  Note: ARC4 wants the 	 * sequence number big-endian. 	 */
name|bcopy
argument_list|(
name|p
argument_list|,
name|tm
operator|->
name|m_data
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
literal|8
expr_stmt|;
name|krb5_decrypt
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|,
name|tm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|,
name|p
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|tp
operator|=
name|tm
operator|->
name|m_data
expr_stmt|;
if|if
condition|(
name|sgn_alg
index|[
literal|0
index|]
operator|==
literal|0x11
condition|)
block|{
name|seq
operator|=
name|tp
index|[
literal|3
index|]
operator||
operator|(
name|tp
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|tp
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|tp
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|tp
index|[
literal|0
index|]
operator||
operator|(
name|tp
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|tp
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|tp
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
block|{
name|dir
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tp
index|[
literal|4
index|]
operator|!=
name|dir
operator|||
name|tp
index|[
literal|5
index|]
operator|!=
name|dir
operator|||
name|tp
index|[
literal|6
index|]
operator|!=
name|dir
operator|||
name|tp
index|[
literal|7
index|]
operator|!=
name|dir
condition|)
block|{
name|m_free
argument_list|(
name|tm
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
block|}
name|m_free
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_flags
operator|&
operator|(
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
operator|)
condition|)
block|{
return|return
operator|(
name|krb5_sequence_check
argument_list|(
name|kc
argument_list|,
name|seq
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_verify_mic_new
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mic
parameter_list|)
block|{
name|OM_uint32
name|res
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|key
init|=
name|kc
operator|->
name|kc_recv_sign_Kc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mlast
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|cklen
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|cklen
operator|=
name|key
operator|->
name|ks_class
operator|->
name|ec_checksumlen
expr_stmt|;
name|KASSERT
argument_list|(
name|mic
operator|->
name|m_next
operator|==
name|NULL
argument_list|,
operator|(
literal|"MIC should be contiguous"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mic
operator|->
name|m_len
operator|!=
literal|16
operator|+
name|cklen
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|=
name|mic
operator|->
name|m_data
expr_stmt|;
comment|/* TOK_ID */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0x04
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0x04
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* Flags */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
name|flags
operator||=
name|GSS_TOKEN_SENT_BY_ACCEPTOR
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|ACCEPTOR_SUBKEY
condition|)
name|flags
operator||=
name|GSS_TOKEN_ACCEPTOR_SUBKEY
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
name|flags
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* Filler */
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|4
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|5
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|6
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|7
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* SND_SEQ */
if|if
condition|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_flags
operator|&
operator|(
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
operator|)
condition|)
block|{
name|uint32_t
name|seq
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|8
index|]
operator|||
name|p
index|[
literal|9
index|]
operator|||
name|p
index|[
literal|10
index|]
operator|||
name|p
index|[
literal|11
index|]
condition|)
block|{
name|res
operator|=
name|GSS_S_UNSEQ_TOKEN
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
operator|(
name|p
index|[
literal|12
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|13
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|14
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|15
index|]
expr_stmt|;
name|res
operator|=
name|krb5_sequence_check
argument_list|(
name|kc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|res
argument_list|)
condition|)
return|return
operator|(
name|res
operator|)
return|;
block|}
else|else
block|{
name|res
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
block|}
comment|/* 	 * SGN_CKSUM: 	 * 	 * Calculate the keyed checksum of the message plus the first 	 * 16 bytes of the token header. 	 */
name|m_copydata
argument_list|(
name|mic
argument_list|,
literal|16
argument_list|,
name|cklen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|mic
expr_stmt|;
name|krb5_checksum
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|mlen
operator|+
literal|16
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|p
operator|+
literal|16
argument_list|,
name|cklen
argument_list|)
condition|)
block|{
return|return
operator|(
name|GSS_S_BAD_SIG
operator|)
return|;
block|}
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_verify_mic
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mic
parameter_list|,
name|gss_qop_t
modifier|*
name|qop_state
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qop_state
condition|)
operator|*
name|qop_state
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|>
name|kc
operator|->
name|kc_lifetime
condition|)
return|return
operator|(
name|GSS_S_CONTEXT_EXPIRED
operator|)
return|;
switch|switch
condition|(
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
operator|->
name|ec_type
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
return|return
operator|(
name|krb5_verify_mic_old
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|mic
argument_list|,
name|sgn_alg_des_md5
argument_list|)
operator|)
return|;
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
return|return
operator|(
name|krb5_verify_mic_old
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|mic
argument_list|,
name|sgn_alg_hmac_md5
argument_list|)
operator|)
return|;
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
return|return
operator|(
name|krb5_verify_mic_old
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|mic
argument_list|,
name|sgn_alg_des3_sha1
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|krb5_verify_mic_new
argument_list|(
name|kc
argument_list|,
name|m
argument_list|,
name|mic
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_wrap_old
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|int
name|conf_req_flag
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|,
name|uint8_t
name|sgn_alg
index|[
literal|2
index|]
parameter_list|,
name|uint8_t
name|seal_alg
index|[
literal|2
index|]
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|tm
decl_stmt|,
modifier|*
name|cm
decl_stmt|,
modifier|*
name|pm
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|tlen
decl_stmt|,
name|padlen
decl_stmt|,
name|datalen
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
name|dir
decl_stmt|;
name|size_t
name|cklen
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
comment|/* 	 * How many trailing pad bytes do we need? 	 */
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
operator|->
name|ec_msgblocklen
expr_stmt|;
name|padlen
operator|=
name|tlen
operator|-
operator|(
name|mlen
operator|%
name|tlen
operator|)
expr_stmt|;
comment|/* 	 * The data part of the token has eight bytes of random 	 * confounder prepended and followed by up to eight bytes of 	 * padding bytes each of which is set to the number of padding 	 * bytes. 	 */
name|datalen
operator|=
name|mlen
operator|+
literal|8
operator|+
name|padlen
expr_stmt|;
name|tlen
operator|=
name|token_length
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|)
expr_stmt|;
name|p
operator|=
name|krb5_make_token
argument_list|(
literal|"\x02\x01"
argument_list|,
name|tlen
argument_list|,
name|datalen
operator|+
name|tlen
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* TOK_ID */
operator|*
name|p
operator|++
operator|=
name|sgn_alg
index|[
literal|0
index|]
expr_stmt|;
comment|/* SGN_ALG */
operator|*
name|p
operator|++
operator|=
name|sgn_alg
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|conf_req_flag
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|seal_alg
index|[
literal|0
index|]
expr_stmt|;
comment|/* SEAL_ALG */
operator|*
name|p
operator|++
operator|=
name|seal_alg
index|[
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
comment|/* SEAL_ALG = none */
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
comment|/* filler */
operator|*
name|p
operator|++
operator|=
literal|0xff
expr_stmt|;
comment|/* 	 * Copy the padded message data. 	 */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
literal|8
condition|)
block|{
name|m
operator|->
name|m_data
operator|-=
literal|8
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|cm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|cm
operator|->
name|m_len
operator|=
literal|8
expr_stmt|;
name|cm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|cm
expr_stmt|;
block|}
name|arc4rand
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mlast
argument_list|)
operator|>=
name|padlen
condition|)
block|{
name|memset
argument_list|(
name|mlast
operator|->
name|m_data
operator|+
name|mlast
operator|->
name|m_len
argument_list|,
name|padlen
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
name|mlast
operator|->
name|m_len
operator|+=
name|padlen
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|pm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pm
operator|->
name|m_data
argument_list|,
name|padlen
argument_list|,
name|padlen
argument_list|)
expr_stmt|;
name|pm
operator|->
name|m_len
operator|=
name|padlen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|pm
expr_stmt|;
name|mlast
operator|=
name|pm
expr_stmt|;
block|}
name|tm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
comment|/* 	 * SGN_CKSUM: 	 * 	 * Calculate the keyed checksum of the token header plus the 	 * padded message. Fiddle with tm->m_len so that we only 	 * checksum the 8 bytes of head that we care about. 	 */
name|cklen
operator|=
name|kc
operator|->
name|kc_checksumkey
operator|->
name|ks_class
operator|->
name|ec_checksumlen
expr_stmt|;
name|tlen
operator|=
name|tm
operator|->
name|m_len
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|p
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|tm
operator|->
name|m_data
expr_stmt|;
name|MGET
argument_list|(
name|cm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|cm
operator|->
name|m_len
operator|=
name|cklen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|cm
expr_stmt|;
name|krb5_checksum
argument_list|(
name|kc
operator|->
name|kc_checksumkey
argument_list|,
literal|13
argument_list|,
name|tm
argument_list|,
name|tm
operator|->
name|m_len
operator|-
literal|8
argument_list|,
name|datalen
operator|+
literal|8
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|tlen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|bcopy
argument_list|(
name|cm
operator|->
name|m_data
argument_list|,
name|p
operator|+
literal|8
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* 	 * SND_SEQ: 	 * 	 * Take the four bytes of the sequence number least 	 * significant first (most significant first for ARCFOUR) 	 * followed by four bytes of direction marker (zero for 	 * initiator and 0xff for acceptor). Encrypt that data using 	 * the SGN_CKSUM as IV. 	 */
name|seq
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_seqnumber
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgn_alg
index|[
literal|0
index|]
operator|==
literal|0x11
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
name|p
index|[
literal|0
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
block|{
name|dir
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
literal|0xff
expr_stmt|;
block|}
name|p
index|[
literal|4
index|]
operator|=
name|dir
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|dir
expr_stmt|;
name|p
index|[
literal|6
index|]
operator|=
name|dir
expr_stmt|;
name|p
index|[
literal|7
index|]
operator|=
name|dir
expr_stmt|;
name|krb5_encrypt
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|,
name|tm
argument_list|,
name|p
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|tm
operator|->
name|m_data
argument_list|,
literal|8
argument_list|,
name|p
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|conf_req_flag
condition|)
block|{
comment|/* 		 * Encrypt the padded message with an IV of zero for 		 * DES and DES3, or an IV of the sequence number in 		 * big-endian format for ARCFOUR. 		 */
if|if
condition|(
name|seal_alg
index|[
literal|0
index|]
operator|==
literal|0x10
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
name|krb5_encrypt
argument_list|(
name|kc
operator|->
name|kc_encryptkey
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|krb5_encrypt
argument_list|(
name|kc
operator|->
name|kc_encryptkey
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|datalen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
name|conf_req_flag
expr_stmt|;
operator|*
name|mp
operator|=
name|tm
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_wrap_new
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|int
name|conf_req_flag
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|)
block|{
name|struct
name|krb5_key_state
modifier|*
name|Ke
init|=
name|kc
operator|->
name|kc_send_seal_Ke
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|Ki
init|=
name|kc
operator|->
name|kc_send_seal_Ki
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|Kc
init|=
name|kc
operator|->
name|kc_send_seal_Kc
decl_stmt|;
specifier|const
name|struct
name|krb5_encryption_class
modifier|*
name|ec
init|=
name|Ke
operator|->
name|ks_class
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|tm
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|EC
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|blen
decl_stmt|,
name|mblen
decl_stmt|,
name|cklen
decl_stmt|,
name|ctlen
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
specifier|static
name|char
name|zpad
index|[
literal|32
index|]
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|blen
operator|=
name|ec
operator|->
name|ec_blocklen
expr_stmt|;
name|mblen
operator|=
name|ec
operator|->
name|ec_msgblocklen
expr_stmt|;
name|cklen
operator|=
name|ec
operator|->
name|ec_checksumlen
expr_stmt|;
if|if
condition|(
name|conf_req_flag
condition|)
block|{
comment|/* 		 * For sealed messages, we need space for 16 bytes of 		 * header, blen confounder, plaintext, padding, copy 		 * of header and checksum. 		 * 		 * We pad to mblen (which may be different from 		 * blen). If the encryption class is using CTS, mblen 		 * will be one (i.e. no padding required). 		 */
if|if
condition|(
name|mblen
operator|>
literal|1
condition|)
name|EC
operator|=
name|mlen
operator|%
name|mblen
expr_stmt|;
else|else
name|EC
operator|=
literal|0
expr_stmt|;
name|ctlen
operator|=
name|blen
operator|+
name|mlen
operator|+
name|EC
operator|+
literal|16
expr_stmt|;
comment|/* 		 * Put initial header and confounder before the 		 * message. 		 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|16
operator|+
name|blen
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 		 * Append padding + copy of header and checksum. Try 		 * to fit this into the end of the original message, 		 * otherwise allocate a trailer. 		 */
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|mlast
argument_list|)
operator|>=
name|EC
operator|+
literal|16
operator|+
name|cklen
condition|)
block|{
name|tm
operator|=
name|NULL
expr_stmt|;
name|mlast
operator|->
name|m_len
operator|+=
name|EC
operator|+
literal|16
operator|+
name|cklen
expr_stmt|;
block|}
else|else
block|{
name|MGET
argument_list|(
name|tm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|EC
operator|+
literal|16
operator|+
name|cklen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|tm
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * For unsealed messages, we need 16 bytes of header 		 * plus space for the plaintext and a checksum. EC is 		 * set to the checksum size. We leave space in tm for 		 * a copy of the header - this will be trimmed later. 		 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
literal|16
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|MGET
argument_list|(
name|tm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_len
operator|=
name|cklen
operator|+
literal|16
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|tm
expr_stmt|;
name|ctlen
operator|=
literal|0
expr_stmt|;
name|EC
operator|=
name|cklen
expr_stmt|;
block|}
name|p
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
comment|/* TOK_ID */
name|p
index|[
literal|0
index|]
operator|=
literal|0x05
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x04
expr_stmt|;
comment|/* Flags */
name|flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf_req_flag
condition|)
name|flags
operator|=
name|GSS_TOKEN_SEALED
expr_stmt|;
if|if
condition|(
name|is_acceptor
argument_list|(
name|kc
argument_list|)
condition|)
name|flags
operator||=
name|GSS_TOKEN_SENT_BY_ACCEPTOR
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|ACCEPTOR_SUBKEY
condition|)
name|flags
operator||=
name|GSS_TOKEN_ACCEPTOR_SUBKEY
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|flags
expr_stmt|;
comment|/* Filler */
name|p
index|[
literal|3
index|]
operator|=
literal|0xff
expr_stmt|;
comment|/* EC + RRC - set to zero initially */
name|p
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|6
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
comment|/* SND_SEQ */
name|p
index|[
literal|8
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|9
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|10
index|]
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|11
index|]
operator|=
literal|0
expr_stmt|;
name|seq
operator|=
name|atomic_fetchadd_32
argument_list|(
operator|&
name|kc
operator|->
name|kc_local_seqnumber
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|p
index|[
literal|12
index|]
operator|=
operator|(
name|seq
operator|>>
literal|24
operator|)
expr_stmt|;
name|p
index|[
literal|13
index|]
operator|=
operator|(
name|seq
operator|>>
literal|16
operator|)
expr_stmt|;
name|p
index|[
literal|14
index|]
operator|=
operator|(
name|seq
operator|>>
literal|8
operator|)
expr_stmt|;
name|p
index|[
literal|15
index|]
operator|=
operator|(
name|seq
operator|>>
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|conf_req_flag
condition|)
block|{
comment|/* 		 * Encrypt according to RFC 4121 section 4.2 and RFC 		 * 3961 section 5.3. Note: we don't generate tokens 		 * with RRC values other than zero. If we did, we 		 * should zero RRC in the copied header. 		 */
name|arc4rand
argument_list|(
name|p
operator|+
literal|16
argument_list|,
name|blen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|EC
condition|)
block|{
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|16
operator|+
name|blen
operator|+
name|mlen
argument_list|,
name|EC
argument_list|,
name|zpad
argument_list|)
expr_stmt|;
block|}
name|m_copyback
argument_list|(
name|m
argument_list|,
literal|16
operator|+
name|blen
operator|+
name|mlen
operator|+
name|EC
argument_list|,
literal|16
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|krb5_checksum
argument_list|(
name|Ki
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
literal|16
argument_list|,
name|ctlen
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|krb5_encrypt
argument_list|(
name|Ke
argument_list|,
name|m
argument_list|,
literal|16
argument_list|,
name|ctlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The plaintext message is followed by a checksum of 		 * the plaintext plus a version of the header where EC 		 * and RRC are set to zero. Also, the original EC must 		 * be our checksum size. 		 */
name|bcopy
argument_list|(
name|p
argument_list|,
name|tm
operator|->
name|m_data
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|krb5_checksum
argument_list|(
name|Kc
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
literal|16
argument_list|,
name|mlen
operator|+
literal|16
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|tm
operator|->
name|m_data
operator|+=
literal|16
expr_stmt|;
name|tm
operator|->
name|m_len
operator|-=
literal|16
expr_stmt|;
block|}
comment|/* 	 * Finally set EC to its actual value 	 */
name|p
index|[
literal|4
index|]
operator|=
name|EC
operator|>>
literal|8
expr_stmt|;
name|p
index|[
literal|5
index|]
operator|=
name|EC
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_wrap
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|int
name|conf_req_flag
parameter_list|,
name|gss_qop_t
name|qop_req
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qop_req
operator|!=
name|GSS_C_QOP_DEFAULT
condition|)
return|return
operator|(
name|GSS_S_BAD_QOP
operator|)
return|;
if|if
condition|(
name|time_uptime
operator|>
name|kc
operator|->
name|kc_lifetime
condition|)
return|return
operator|(
name|GSS_S_CONTEXT_EXPIRED
operator|)
return|;
switch|switch
condition|(
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
operator|->
name|ec_type
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
return|return
operator|(
name|krb5_wrap_old
argument_list|(
name|kc
argument_list|,
name|conf_req_flag
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|,
name|sgn_alg_des_md5
argument_list|,
name|seal_alg_des
argument_list|)
operator|)
return|;
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
return|return
operator|(
name|krb5_wrap_old
argument_list|(
name|kc
argument_list|,
name|conf_req_flag
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|,
name|sgn_alg_hmac_md5
argument_list|,
name|seal_alg_rc4
argument_list|)
operator|)
return|;
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
return|return
operator|(
name|krb5_wrap_old
argument_list|(
name|kc
argument_list|,
name|conf_req_flag
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|,
name|sgn_alg_des3_sha1
argument_list|,
name|seal_alg_des3
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|krb5_wrap_new
argument_list|(
name|kc
argument_list|,
name|conf_req_flag
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
name|GSS_S_FAILURE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|m_trim
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|off
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
name|n
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|len
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|n
operator|->
name|m_len
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|m_next
condition|)
block|{
name|m_freem
argument_list|(
name|n
operator|->
name|m_next
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_unwrap_old
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|,
name|uint8_t
name|sgn_alg
index|[
literal|2
index|]
parameter_list|,
name|uint8_t
name|seal_alg
index|[
literal|2
index|]
parameter_list|)
block|{
name|OM_uint32
name|res
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|hm
decl_stmt|,
modifier|*
name|cm
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
name|dir
decl_stmt|;
name|size_t
name|mlen
decl_stmt|,
name|tlen
decl_stmt|,
name|elen
decl_stmt|,
name|datalen
decl_stmt|,
name|padlen
decl_stmt|;
name|size_t
name|cklen
decl_stmt|;
name|uint8_t
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|conf
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
name|tlen
operator|=
name|token_length
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|)
expr_stmt|;
name|cklen
operator|=
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
operator|->
name|ec_checksumlen
expr_stmt|;
name|p
operator|=
name|krb5_verify_token
argument_list|(
literal|"\x02\x01"
argument_list|,
name|tlen
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|elen
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|datalen
operator|=
name|elen
operator|-
name|tlen
expr_stmt|;
comment|/* 	 * Trim the framing header first to make life a little easier 	 * later. 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|p
operator|-
operator|(
name|uint8_t
operator|*
operator|)
name|m
operator|->
name|m_data
argument_list|)
expr_stmt|;
comment|/* TOK_ID */
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* SGN_ALG */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
name|sgn_alg
index|[
literal|0
index|]
operator|||
name|p
index|[
literal|1
index|]
operator|!=
name|sgn_alg
index|[
literal|1
index|]
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* SEAL_ALG */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
name|seal_alg
index|[
literal|0
index|]
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|seal_alg
index|[
literal|1
index|]
condition|)
name|conf
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|0xff
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|0xff
condition|)
name|conf
operator|=
literal|0
expr_stmt|;
else|else
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0xff
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * SND_SEQ: 	 * 	 * Take the four bytes of the sequence number least 	 * significant first (most significant for ARCFOUR) followed 	 * by four bytes of direction marker (zero for initiator and 	 * 0xff for acceptor). Encrypt that data using the SGN_CKSUM 	 * as IV. 	 */
name|krb5_decrypt
argument_list|(
name|kc
operator|->
name|kc_tokenkey
argument_list|,
name|m
argument_list|,
literal|8
argument_list|,
literal|8
argument_list|,
name|p
operator|+
literal|8
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|sgn_alg
index|[
literal|0
index|]
operator|==
literal|0x11
condition|)
block|{
name|seq
operator|=
name|p
index|[
literal|3
index|]
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|0
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
name|p
index|[
literal|0
index|]
operator||
operator|(
name|p
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|p
index|[
literal|2
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|3
index|]
operator|<<
literal|24
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
block|{
name|dir
operator|=
literal|0xff
expr_stmt|;
block|}
else|else
block|{
name|dir
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|p
index|[
literal|4
index|]
operator|!=
name|dir
operator|||
name|p
index|[
literal|5
index|]
operator|!=
name|dir
operator|||
name|p
index|[
literal|6
index|]
operator|!=
name|dir
operator|||
name|p
index|[
literal|7
index|]
operator|!=
name|dir
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_flags
operator|&
operator|(
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
operator|)
condition|)
block|{
name|res
operator|=
name|krb5_sequence_check
argument_list|(
name|kc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|res
argument_list|)
condition|)
return|return
operator|(
name|res
operator|)
return|;
block|}
else|else
block|{
name|res
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
block|}
comment|/* 	 * If the token was encrypted, decode it in-place. 	 */
if|if
condition|(
name|conf
condition|)
block|{
comment|/* 		 * Decrypt the padded message with an IV of zero for 		 * DES and DES3 or an IV of the big-endian encoded 		 * sequence number for ARCFOUR. 		 */
if|if
condition|(
name|seal_alg
index|[
literal|0
index|]
operator|==
literal|0x10
condition|)
block|{
name|krb5_decrypt
argument_list|(
name|kc
operator|->
name|kc_encryptkey
argument_list|,
name|m
argument_list|,
literal|16
operator|+
name|cklen
argument_list|,
name|datalen
argument_list|,
name|p
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|krb5_decrypt
argument_list|(
name|kc
operator|->
name|kc_encryptkey
argument_list|,
name|m
argument_list|,
literal|16
operator|+
name|cklen
argument_list|,
name|datalen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
name|conf
expr_stmt|;
comment|/* 	 * Check the trailing pad bytes. 	 * RFC1964 specifies between 1<->8 bytes, each with a binary value 	 * equal to the number of bytes. 	 */
if|if
condition|(
name|mlast
operator|->
name|m_len
operator|>
literal|0
condition|)
name|padlen
operator|=
name|mlast
operator|->
name|m_data
index|[
name|mlast
operator|->
name|m_len
operator|-
literal|1
index|]
expr_stmt|;
else|else
block|{
name|n
operator|=
name|m_getptr
argument_list|(
name|m
argument_list|,
name|tlen
operator|+
name|datalen
operator|-
literal|1
argument_list|,
operator|&
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * When the position is exactly equal to the # of data bytes 		 * in the mbuf list, m_getptr() will return the last mbuf in 		 * the list and an off == m_len for that mbuf, so that case 		 * needs to be checked as well as a NULL return. 		 */
if|if
condition|(
name|n
operator|==
name|NULL
operator|||
name|n
operator|->
name|m_len
operator|==
name|i
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|padlen
operator|=
name|n
operator|->
name|m_data
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|padlen
operator|<
literal|1
operator|||
name|padlen
operator|>
literal|8
operator|||
name|padlen
operator|>
name|tlen
operator|+
name|datalen
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|tlen
operator|+
name|datalen
operator|-
name|padlen
argument_list|,
name|padlen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|padlen
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|!=
name|padlen
condition|)
block|{
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
block|}
block|}
comment|/* 	 * SGN_CKSUM: 	 * 	 * Calculate the keyed checksum of the token header plus the 	 * padded message. We do a little mbuf surgery to trim out the 	 * parts we don't want to checksum. 	 */
name|hm
operator|=
name|m
expr_stmt|;
operator|*
name|mp
operator|=
name|m
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
literal|16
operator|+
name|cklen
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mlast
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|hm
operator|->
name|m_len
operator|=
literal|8
expr_stmt|;
name|hm
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|MGET
argument_list|(
name|cm
argument_list|,
name|M_WAITOK
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
name|cm
operator|->
name|m_len
operator|=
name|cklen
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|cm
expr_stmt|;
name|krb5_checksum
argument_list|(
name|kc
operator|->
name|kc_checksumkey
argument_list|,
literal|13
argument_list|,
name|hm
argument_list|,
literal|0
argument_list|,
name|datalen
operator|+
literal|8
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|hm
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|cm
operator|->
name|m_data
argument_list|,
name|hm
operator|->
name|m_data
operator|+
literal|16
argument_list|,
name|cklen
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|hm
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
return|return
operator|(
name|GSS_S_BAD_SIG
operator|)
return|;
block|}
name|m_freem
argument_list|(
name|hm
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|cm
argument_list|)
expr_stmt|;
comment|/* 	 * Trim off the confounder and padding. 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlast
operator|->
name|m_len
operator|>=
name|padlen
condition|)
block|{
name|mlast
operator|->
name|m_len
operator|-=
name|padlen
expr_stmt|;
block|}
else|else
block|{
name|m_trim
argument_list|(
name|m
argument_list|,
name|datalen
operator|-
literal|8
operator|-
name|padlen
argument_list|)
expr_stmt|;
block|}
operator|*
name|mp
operator|=
name|m
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_unwrap_new
parameter_list|(
name|struct
name|krb5_context
modifier|*
name|kc
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|)
block|{
name|OM_uint32
name|res
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|Ke
init|=
name|kc
operator|->
name|kc_recv_seal_Ke
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|Ki
init|=
name|kc
operator|->
name|kc_recv_seal_Ki
decl_stmt|;
name|struct
name|krb5_key_state
modifier|*
name|Kc
init|=
name|kc
operator|->
name|kc_recv_seal_Kc
decl_stmt|;
specifier|const
name|struct
name|krb5_encryption_class
modifier|*
name|ec
init|=
name|Ke
operator|->
name|ks_class
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mlast
decl_stmt|,
modifier|*
name|hm
decl_stmt|,
modifier|*
name|cm
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|int
name|sealed
decl_stmt|,
name|flags
decl_stmt|,
name|EC
decl_stmt|,
name|RRC
decl_stmt|;
name|size_t
name|blen
decl_stmt|,
name|cklen
decl_stmt|,
name|ctlen
decl_stmt|,
name|mlen
decl_stmt|,
name|plen
decl_stmt|,
name|tlen
decl_stmt|;
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|,
name|buf2
index|[
literal|32
index|]
decl_stmt|;
name|m
operator|=
operator|*
name|mp
expr_stmt|;
name|mlen
operator|=
name|m_length
argument_list|(
name|m
argument_list|,
operator|&
name|mlast
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlen
operator|<=
literal|16
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
literal|16
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
literal|16
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|m
expr_stmt|;
block|}
name|p
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
comment|/* TOK_ID */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|0x05
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|!=
literal|0x04
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* Flags */
name|sealed
operator|=
name|p
index|[
literal|2
index|]
operator|&
name|GSS_TOKEN_SEALED
expr_stmt|;
name|flags
operator|=
name|sealed
expr_stmt|;
if|if
condition|(
name|is_initiator
argument_list|(
name|kc
argument_list|)
condition|)
name|flags
operator||=
name|GSS_TOKEN_SENT_BY_ACCEPTOR
expr_stmt|;
if|if
condition|(
name|kc
operator|->
name|kc_more_flags
operator|&
name|ACCEPTOR_SUBKEY
condition|)
name|flags
operator||=
name|GSS_TOKEN_ACCEPTOR_SUBKEY
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|2
index|]
operator|!=
name|flags
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* Filler */
if|if
condition|(
name|p
index|[
literal|3
index|]
operator|!=
literal|0xff
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* EC + RRC */
name|EC
operator|=
operator|(
name|p
index|[
literal|4
index|]
operator|<<
literal|8
operator|)
operator|+
name|p
index|[
literal|5
index|]
expr_stmt|;
name|RRC
operator|=
operator|(
name|p
index|[
literal|6
index|]
operator|<<
literal|8
operator|)
operator|+
name|p
index|[
literal|7
index|]
expr_stmt|;
comment|/* SND_SEQ */
if|if
condition|(
name|kc
operator|->
name|kc_msg_order
operator|.
name|km_flags
operator|&
operator|(
name|GSS_C_REPLAY_FLAG
operator||
name|GSS_C_SEQUENCE_FLAG
operator|)
condition|)
block|{
name|uint32_t
name|seq
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|8
index|]
operator|||
name|p
index|[
literal|9
index|]
operator|||
name|p
index|[
literal|10
index|]
operator|||
name|p
index|[
literal|11
index|]
condition|)
block|{
name|res
operator|=
name|GSS_S_UNSEQ_TOKEN
expr_stmt|;
block|}
else|else
block|{
name|seq
operator|=
operator|(
name|p
index|[
literal|12
index|]
operator|<<
literal|24
operator|)
operator||
operator|(
name|p
index|[
literal|13
index|]
operator|<<
literal|16
operator|)
operator||
operator|(
name|p
index|[
literal|14
index|]
operator|<<
literal|8
operator|)
operator||
name|p
index|[
literal|15
index|]
expr_stmt|;
name|res
operator|=
name|krb5_sequence_check
argument_list|(
name|kc
argument_list|,
name|seq
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|res
argument_list|)
condition|)
return|return
operator|(
name|res
operator|)
return|;
block|}
else|else
block|{
name|res
operator|=
name|GSS_S_COMPLETE
expr_stmt|;
block|}
comment|/* 	 * Separate the header before dealing with RRC. We only need 	 * to keep the header if the message isn't encrypted. 	 */
if|if
condition|(
name|sealed
condition|)
block|{
name|hm
operator|=
name|NULL
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hm
operator|=
name|m
expr_stmt|;
operator|*
name|mp
operator|=
name|m
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
literal|16
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mlast
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Undo the effects of RRC by rotating left. 	 */
if|if
condition|(
name|RRC
operator|>
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|rm
decl_stmt|;
name|size_t
name|rlen
decl_stmt|;
name|rlen
operator|=
name|mlen
operator|-
literal|16
expr_stmt|;
if|if
condition|(
name|RRC
operator|<=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|&&
name|m
operator|->
name|m_len
operator|>=
name|rlen
condition|)
block|{
comment|/* 			 * Simple case, just rearrange the bytes in m. 			 */
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
argument_list|,
name|buf
argument_list|,
name|RRC
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|m
operator|->
name|m_data
operator|+
name|RRC
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
name|rlen
operator|-
name|RRC
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|m
operator|->
name|m_data
operator|+
name|rlen
operator|-
name|RRC
argument_list|,
name|RRC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * More complicated - rearrange the mbuf 			 * chain. 			 */
name|rm
operator|=
name|m
expr_stmt|;
operator|*
name|mp
operator|=
name|m
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|RRC
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|m_cat
argument_list|(
name|m
argument_list|,
name|rm
argument_list|)
expr_stmt|;
name|mlast
operator|=
name|rm
expr_stmt|;
block|}
block|}
name|blen
operator|=
name|ec
operator|->
name|ec_blocklen
expr_stmt|;
name|cklen
operator|=
name|ec
operator|->
name|ec_checksumlen
expr_stmt|;
if|if
condition|(
name|sealed
condition|)
block|{
comment|/* 		 * Decrypt according to RFC 4121 section 4.2 and RFC 		 * 3961 section 5.3. The message must be large enough 		 * for a blocksize confounder, at least one block of 		 * cyphertext and a checksum. 		 */
if|if
condition|(
name|mlen
operator|<
literal|16
operator|+
literal|2
operator|*
name|blen
operator|+
name|cklen
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
name|ctlen
operator|=
name|mlen
operator|-
literal|16
operator|-
name|cklen
expr_stmt|;
name|krb5_decrypt
argument_list|(
name|Ke
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|ctlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * The size of the plaintext is ctlen minus blocklen 		 * (for the confounder), 16 (for the copy of the token 		 * header) and EC (for the filler). The actual 		 * plaintext starts after the confounder. 		 */
name|plen
operator|=
name|ctlen
operator|-
name|blen
operator|-
literal|16
operator|-
name|EC
expr_stmt|;
name|pp
operator|=
name|p
operator|+
literal|16
operator|+
name|blen
expr_stmt|;
comment|/* 		 * Checksum the padded plaintext. 		 */
name|m_copydata
argument_list|(
name|m
argument_list|,
name|ctlen
argument_list|,
name|cklen
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|krb5_checksum
argument_list|(
name|Ki
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|ctlen
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|ctlen
argument_list|,
name|cklen
argument_list|,
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|buf
argument_list|,
name|buf2
argument_list|,
name|cklen
argument_list|)
condition|)
return|return
operator|(
name|GSS_S_BAD_SIG
operator|)
return|;
comment|/* 		 * Trim the message back to just plaintext. 		 */
name|m_adj
argument_list|(
name|m
argument_list|,
name|blen
argument_list|)
expr_stmt|;
name|tlen
operator|=
literal|16
operator|+
name|EC
operator|+
name|cklen
expr_stmt|;
if|if
condition|(
name|mlast
operator|->
name|m_len
operator|>=
name|tlen
condition|)
block|{
name|mlast
operator|->
name|m_len
operator|-=
name|tlen
expr_stmt|;
block|}
else|else
block|{
name|m_trim
argument_list|(
name|m
argument_list|,
name|plen
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * The plaintext message is followed by a checksum of 		 * the plaintext plus a version of the header where EC 		 * and RRC are set to zero. Also, the original EC must 		 * be our checksum size. 		 */
if|if
condition|(
name|mlen
operator|<
literal|16
operator|+
name|cklen
operator|||
name|EC
operator|!=
name|cklen
condition|)
return|return
operator|(
name|GSS_S_DEFECTIVE_TOKEN
operator|)
return|;
comment|/* 		 * The size of the plaintext is simply the message 		 * size less header and checksum. The plaintext starts 		 * right after the header (which we have saved in hm). 		 */
name|plen
operator|=
name|mlen
operator|-
literal|16
operator|-
name|cklen
expr_stmt|;
comment|/* 		 * Insert a copy of the header (with EC and RRC set to 		 * zero) between the plaintext message and the 		 * checksum. 		 */
name|p
operator|=
name|hm
operator|->
name|m_data
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
name|p
index|[
literal|5
index|]
operator|=
name|p
index|[
literal|6
index|]
operator|=
name|p
index|[
literal|7
index|]
operator|=
literal|0
expr_stmt|;
name|cm
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|plen
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
name|mlast
operator|=
name|m_last
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_next
operator|=
name|hm
expr_stmt|;
name|hm
operator|->
name|m_next
operator|=
name|cm
expr_stmt|;
name|bcopy
argument_list|(
name|cm
operator|->
name|m_data
argument_list|,
name|buf
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
name|krb5_checksum
argument_list|(
name|Kc
argument_list|,
literal|0
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
name|plen
operator|+
literal|16
argument_list|,
name|cklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
name|cm
operator|->
name|m_data
argument_list|,
name|buf
argument_list|,
name|cklen
argument_list|)
condition|)
return|return
operator|(
name|GSS_S_BAD_SIG
operator|)
return|;
comment|/* 		 * The checksum matches, discard all buf the plaintext. 		 */
name|mlast
operator|->
name|m_next
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|hm
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
operator|(
name|sealed
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_unwrap
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|struct
name|mbuf
modifier|*
modifier|*
name|mp
parameter_list|,
name|int
modifier|*
name|conf_state
parameter_list|,
name|gss_qop_t
modifier|*
name|qop_state
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
name|OM_uint32
name|maj_stat
decl_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qop_state
condition|)
operator|*
name|qop_state
operator|=
name|GSS_C_QOP_DEFAULT
expr_stmt|;
if|if
condition|(
name|conf_state
condition|)
operator|*
name|conf_state
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|time_uptime
operator|>
name|kc
operator|->
name|kc_lifetime
condition|)
return|return
operator|(
name|GSS_S_CONTEXT_EXPIRED
operator|)
return|;
switch|switch
condition|(
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
operator|->
name|ec_type
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
name|maj_stat
operator|=
name|krb5_unwrap_old
argument_list|(
name|kc
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|,
name|sgn_alg_des_md5
argument_list|,
name|seal_alg_des
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
name|maj_stat
operator|=
name|krb5_unwrap_old
argument_list|(
name|kc
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|,
name|sgn_alg_hmac_md5
argument_list|,
name|seal_alg_rc4
argument_list|)
expr_stmt|;
break|break;
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
name|maj_stat
operator|=
name|krb5_unwrap_old
argument_list|(
name|kc
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|,
name|sgn_alg_des3_sha1
argument_list|,
name|seal_alg_des3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|maj_stat
operator|=
name|krb5_unwrap_new
argument_list|(
name|kc
argument_list|,
name|mp
argument_list|,
name|conf_state
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|GSS_ERROR
argument_list|(
name|maj_stat
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
operator|*
name|mp
argument_list|)
expr_stmt|;
operator|*
name|mp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|maj_stat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|OM_uint32
name|krb5_wrap_size_limit
parameter_list|(
name|gss_ctx_id_t
name|ctx
parameter_list|,
name|OM_uint32
modifier|*
name|minor_status
parameter_list|,
name|int
name|conf_req_flag
parameter_list|,
name|gss_qop_t
name|qop_req
parameter_list|,
name|OM_uint32
name|req_output_size
parameter_list|,
name|OM_uint32
modifier|*
name|max_input_size
parameter_list|)
block|{
name|struct
name|krb5_context
modifier|*
name|kc
init|=
operator|(
expr|struct
name|krb5_context
operator|*
operator|)
name|ctx
decl_stmt|;
specifier|const
name|struct
name|krb5_encryption_class
modifier|*
name|ec
decl_stmt|;
name|OM_uint32
name|overhead
decl_stmt|;
operator|*
name|minor_status
operator|=
literal|0
expr_stmt|;
operator|*
name|max_input_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|qop_req
operator|!=
name|GSS_C_QOP_DEFAULT
condition|)
return|return
operator|(
name|GSS_S_BAD_QOP
operator|)
return|;
name|ec
operator|=
name|kc
operator|->
name|kc_tokenkey
operator|->
name|ks_class
expr_stmt|;
switch|switch
condition|(
name|ec
operator|->
name|ec_type
condition|)
block|{
case|case
name|ETYPE_DES_CBC_CRC
case|:
case|case
name|ETYPE_DES3_CBC_SHA1
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5
case|:
case|case
name|ETYPE_ARCFOUR_HMAC_MD5_56
case|:
comment|/* 		 * up to 5 bytes for [APPLICATION 0] SEQUENCE 		 * 2 + krb5 oid length 		 * 8 bytes of header 		 * 8 bytes of confounder 		 * maximum of 8 bytes of padding 		 * checksum 		 */
name|overhead
operator|=
literal|5
operator|+
literal|2
operator|+
name|krb5_mech_oid
operator|.
name|length
expr_stmt|;
name|overhead
operator|+=
literal|8
operator|+
literal|8
operator|+
name|ec
operator|->
name|ec_msgblocklen
expr_stmt|;
name|overhead
operator|+=
name|ec
operator|->
name|ec_checksumlen
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|conf_req_flag
condition|)
block|{
comment|/* 			 * 16 byts of header 			 * blocklen bytes of confounder 			 * up to msgblocklen - 1 bytes of padding 			 * 16 bytes for copy of header 			 * checksum 			 */
name|overhead
operator|=
literal|16
operator|+
name|ec
operator|->
name|ec_blocklen
expr_stmt|;
name|overhead
operator|+=
name|ec
operator|->
name|ec_msgblocklen
operator|-
literal|1
expr_stmt|;
name|overhead
operator|+=
literal|16
expr_stmt|;
name|overhead
operator|+=
name|ec
operator|->
name|ec_checksumlen
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * 16 bytes of header plus checksum. 			 */
name|overhead
operator|=
literal|16
operator|+
name|ec
operator|->
name|ec_checksumlen
expr_stmt|;
block|}
block|}
operator|*
name|max_input_size
operator|=
name|req_output_size
operator|-
name|overhead
expr_stmt|;
return|return
operator|(
name|GSS_S_COMPLETE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|kobj_method_t
name|krb5_methods
index|[]
init|=
block|{
name|KOBJMETHOD
argument_list|(
name|kgss_init
argument_list|,
name|krb5_init
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_import
argument_list|,
name|krb5_import
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_delete
argument_list|,
name|krb5_delete
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_mech_type
argument_list|,
name|krb5_mech_type
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_get_mic
argument_list|,
name|krb5_get_mic
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_verify_mic
argument_list|,
name|krb5_verify_mic
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_wrap
argument_list|,
name|krb5_wrap
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_unwrap
argument_list|,
name|krb5_unwrap
argument_list|)
block|,
name|KOBJMETHOD
argument_list|(
name|kgss_wrap_size_limit
argument_list|,
name|krb5_wrap_size_limit
argument_list|)
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kobj_class
name|krb5_class
init|=
block|{
literal|"kerberosv5"
block|,
name|krb5_methods
block|,
expr|sizeof
operator|(
expr|struct
name|krb5_context
operator|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Kernel module glue  */
end_comment

begin_function
specifier|static
name|int
name|kgssapi_krb5_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|kgss_install_mech
argument_list|(
operator|&
name|krb5_mech_oid
argument_list|,
literal|"kerberosv5"
argument_list|,
operator|&
name|krb5_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|MOD_UNLOAD
case|:
name|kgss_uninstall_mech
argument_list|(
operator|&
name|krb5_mech_oid
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|kgssapi_krb5_mod
init|=
block|{
literal|"kgssapi_krb5"
block|,
name|kgssapi_krb5_modevent
block|,
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|kgssapi_krb5
argument_list|,
name|kgssapi_krb5_mod
argument_list|,
name|SI_SUB_VFS
argument_list|,
name|SI_ORDER_ANY
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|kgssapi_krb5
argument_list|,
name|kgssapi
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|kgssapi_krb5
argument_list|,
name|crypto
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|kgssapi_krb5
argument_list|,
name|rc4
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|kgssapi_krb5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

