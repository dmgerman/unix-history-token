begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Isilon Inc http://www.isilon.com/  * Authors: Doug Rabson<dfr@rabson.org>  * Developed with Red Inc: Alfred Perlstein<alfred@freebsd.org>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<crypto/des/des.h>
end_include

begin_include
include|#
directive|include
file|<opencrypto/cryptodev.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/gssapi.h>
end_include

begin_include
include|#
directive|include
file|<kgssapi/gssapi_impl.h>
end_include

begin_include
include|#
directive|include
file|"kcrypto.h"
end_include

begin_define
define|#
directive|define
name|DES3_FLAGS
value|(CRYPTOCAP_F_HARDWARE | CRYPTOCAP_F_SOFTWARE)
end_define

begin_struct
struct|struct
name|des3_state
block|{
name|struct
name|mtx
name|ds_lock
decl_stmt|;
name|uint64_t
name|ds_session
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|des3_init
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|)
block|{
name|struct
name|des3_state
modifier|*
name|ds
decl_stmt|;
name|ds
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|des3_state
argument_list|)
argument_list|,
name|M_GSSAPI
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
literal|"gss des3 lock"
argument_list|,
name|NULL
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|ks
operator|->
name|ks_priv
operator|=
name|ds
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_destroy
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|)
block|{
name|struct
name|des3_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_session
condition|)
name|crypto_freesession
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ks
operator|->
name|ks_priv
argument_list|,
name|M_GSSAPI
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_set_key
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|void
modifier|*
name|kp
init|=
name|ks
operator|->
name|ks_key
decl_stmt|;
name|struct
name|des3_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
name|struct
name|cryptoini
name|cri
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|kp
operator|!=
name|in
condition|)
name|bcopy
argument_list|(
name|in
argument_list|,
name|kp
argument_list|,
name|ks
operator|->
name|ks_class
operator|->
name|ec_keylen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_session
condition|)
name|crypto_freesession
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|cri
argument_list|,
sizeof|sizeof
argument_list|(
name|cri
argument_list|)
argument_list|)
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_alg
operator|=
name|CRYPTO_SHA1_HMAC
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_klen
operator|=
literal|192
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_mlen
operator|=
literal|0
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_key
operator|=
name|ks
operator|->
name|ks_key
expr_stmt|;
name|cri
index|[
literal|0
index|]
operator|.
name|cri_next
operator|=
operator|&
name|cri
index|[
literal|1
index|]
expr_stmt|;
name|cri
index|[
literal|1
index|]
operator|.
name|cri_alg
operator|=
name|CRYPTO_3DES_CBC
expr_stmt|;
name|cri
index|[
literal|1
index|]
operator|.
name|cri_klen
operator|=
literal|192
expr_stmt|;
name|cri
index|[
literal|1
index|]
operator|.
name|cri_mlen
operator|=
literal|0
expr_stmt|;
name|cri
index|[
literal|1
index|]
operator|.
name|cri_key
operator|=
name|ks
operator|->
name|ks_key
expr_stmt|;
name|cri
index|[
literal|1
index|]
operator|.
name|cri_next
operator|=
name|NULL
expr_stmt|;
name|crypto_newsession
argument_list|(
operator|&
name|ds
operator|->
name|ds_session
argument_list|,
name|cri
argument_list|,
name|CRYPTOCAP_F_HARDWARE
operator||
name|CRYPTOCAP_F_SOFTWARE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_random_to_key
parameter_list|(
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
specifier|const
name|void
modifier|*
name|in
parameter_list|)
block|{
name|uint8_t
modifier|*
name|outkey
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|inkey
decl_stmt|;
name|int
name|subkey
decl_stmt|;
for|for
control|(
name|subkey
operator|=
literal|0
operator|,
name|outkey
operator|=
name|ks
operator|->
name|ks_key
operator|,
name|inkey
operator|=
name|in
init|;
name|subkey
operator|<
literal|3
condition|;
name|subkey
operator|++
operator|,
name|outkey
operator|+=
literal|8
operator|,
name|inkey
operator|+=
literal|7
control|)
block|{
comment|/* 		 * Expand 56 bits of random data to 64 bits as follows 		 * (in the example, bit number 1 is the MSB of the 56 		 * bits of random data): 		 * 		 * expanded =  		 *	 1  2  3  4  5  6  7  p 		 *	 9 10 11 12 13 14 15  p 		 *	17 18 19 20 21 22 23  p 		 *	25 26 27 28 29 30 31  p 		 *	33 34 35 36 37 38 39  p 		 *	41 42 43 44 45 46 47  p 		 *	49 50 51 52 53 54 55  p 		 *	56 48 40 32 24 16  8  p 		 */
name|outkey
index|[
literal|0
index|]
operator|=
name|inkey
index|[
literal|0
index|]
expr_stmt|;
name|outkey
index|[
literal|1
index|]
operator|=
name|inkey
index|[
literal|1
index|]
expr_stmt|;
name|outkey
index|[
literal|2
index|]
operator|=
name|inkey
index|[
literal|2
index|]
expr_stmt|;
name|outkey
index|[
literal|3
index|]
operator|=
name|inkey
index|[
literal|3
index|]
expr_stmt|;
name|outkey
index|[
literal|4
index|]
operator|=
name|inkey
index|[
literal|4
index|]
expr_stmt|;
name|outkey
index|[
literal|5
index|]
operator|=
name|inkey
index|[
literal|5
index|]
expr_stmt|;
name|outkey
index|[
literal|6
index|]
operator|=
name|inkey
index|[
literal|6
index|]
expr_stmt|;
name|outkey
index|[
literal|7
index|]
operator|=
operator|(
operator|(
operator|(
name|inkey
index|[
literal|0
index|]
operator|&
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|1
index|]
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|2
index|]
operator|&
literal|1
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|3
index|]
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|4
index|]
operator|&
literal|1
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|5
index|]
operator|&
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|inkey
index|[
literal|6
index|]
operator|&
literal|1
operator|)
operator|<<
literal|7
operator|)
operator|)
expr_stmt|;
name|des_set_odd_parity
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|outkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|des_is_weak_key
argument_list|(
operator|(
name|des_cblock
operator|*
operator|)
name|outkey
argument_list|)
condition|)
name|outkey
index|[
literal|7
index|]
operator|^=
literal|0xf0
expr_stmt|;
block|}
name|des3_set_key
argument_list|(
name|ks
argument_list|,
name|ks
operator|->
name|ks_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|des3_crypto_cb
parameter_list|(
name|struct
name|cryptop
modifier|*
name|crp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|des3_state
modifier|*
name|ds
init|=
operator|(
expr|struct
name|des3_state
operator|*
operator|)
name|crp
operator|->
name|crp_opaque
decl_stmt|;
if|if
condition|(
name|CRYPTO_SESID2CAPS
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
operator|&
name|CRYPTOCAP_F_SYNC
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|crp
operator|->
name|crp_etype
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EAGAIN
condition|)
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_DONE
operator|)
condition|)
name|wakeup
argument_list|(
name|crp
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_encrypt_1
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|,
name|int
name|encdec
parameter_list|)
block|{
name|struct
name|des3_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|crd
operator|->
name|crd_skip
operator|=
name|skip
expr_stmt|;
name|crd
operator|->
name|crd_len
operator|=
name|len
expr_stmt|;
name|crd
operator|->
name|crd_flags
operator|=
name|CRD_F_IV_EXPLICIT
operator||
name|CRD_F_IV_PRESENT
operator||
name|encdec
expr_stmt|;
if|if
condition|(
name|ivec
condition|)
block|{
name|bcopy
argument_list|(
name|ivec
argument_list|,
name|crd
operator|->
name|crd_iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|crd
operator|->
name|crd_iv
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
name|crd
operator|->
name|crd_next
operator|=
name|NULL
expr_stmt|;
name|crd
operator|->
name|crd_alg
operator|=
name|CRYPTO_3DES_CBC
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|ds
operator|->
name|ds_session
expr_stmt|;
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_IMBUF
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|inout
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|void
operator|*
operator|)
name|ds
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|des3_crypto_cb
expr_stmt|;
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CRYPTO_SESID2CAPS
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
operator|&
name|CRYPTOCAP_F_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_DONE
operator|)
condition|)
name|error
operator|=
name|msleep
argument_list|(
name|crp
argument_list|,
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
literal|0
argument_list|,
literal|"gssdes3"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_encrypt
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|,
name|size_t
name|ivlen
parameter_list|)
block|{
name|des3_encrypt_1
argument_list|(
name|ks
argument_list|,
name|inout
argument_list|,
name|skip
argument_list|,
name|len
argument_list|,
name|ivec
argument_list|,
name|CRD_F_ENCRYPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_decrypt
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
modifier|*
name|ivec
parameter_list|,
name|size_t
name|ivlen
parameter_list|)
block|{
name|des3_encrypt_1
argument_list|(
name|ks
argument_list|,
name|inout
argument_list|,
name|skip
argument_list|,
name|len
argument_list|,
name|ivec
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|des3_checksum
parameter_list|(
specifier|const
name|struct
name|krb5_key_state
modifier|*
name|ks
parameter_list|,
name|int
name|usage
parameter_list|,
name|struct
name|mbuf
modifier|*
name|inout
parameter_list|,
name|size_t
name|skip
parameter_list|,
name|size_t
name|inlen
parameter_list|,
name|size_t
name|outlen
parameter_list|)
block|{
name|struct
name|des3_state
modifier|*
name|ds
init|=
name|ks
operator|->
name|ks_priv
decl_stmt|;
name|struct
name|cryptop
modifier|*
name|crp
decl_stmt|;
name|struct
name|cryptodesc
modifier|*
name|crd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|crp
operator|=
name|crypto_getreq
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|crd
operator|=
name|crp
operator|->
name|crp_desc
expr_stmt|;
name|crd
operator|->
name|crd_skip
operator|=
name|skip
expr_stmt|;
name|crd
operator|->
name|crd_len
operator|=
name|inlen
expr_stmt|;
name|crd
operator|->
name|crd_inject
operator|=
name|skip
operator|+
name|inlen
expr_stmt|;
name|crd
operator|->
name|crd_flags
operator|=
literal|0
expr_stmt|;
name|crd
operator|->
name|crd_next
operator|=
name|NULL
expr_stmt|;
name|crd
operator|->
name|crd_alg
operator|=
name|CRYPTO_SHA1_HMAC
expr_stmt|;
name|crp
operator|->
name|crp_sid
operator|=
name|ds
operator|->
name|ds_session
expr_stmt|;
name|crp
operator|->
name|crp_ilen
operator|=
name|inlen
expr_stmt|;
name|crp
operator|->
name|crp_olen
operator|=
literal|20
expr_stmt|;
name|crp
operator|->
name|crp_etype
operator|=
literal|0
expr_stmt|;
name|crp
operator|->
name|crp_flags
operator|=
name|CRYPTO_F_IMBUF
operator||
name|CRYPTO_F_CBIFSYNC
expr_stmt|;
name|crp
operator|->
name|crp_buf
operator|=
operator|(
name|void
operator|*
operator|)
name|inout
expr_stmt|;
name|crp
operator|->
name|crp_opaque
operator|=
operator|(
name|void
operator|*
operator|)
name|ds
expr_stmt|;
name|crp
operator|->
name|crp_callback
operator|=
name|des3_crypto_cb
expr_stmt|;
name|error
operator|=
name|crypto_dispatch
argument_list|(
name|crp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|CRYPTO_SESID2CAPS
argument_list|(
name|ds
operator|->
name|ds_session
argument_list|)
operator|&
name|CRYPTOCAP_F_SYNC
operator|)
operator|==
literal|0
condition|)
block|{
name|mtx_lock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|!
operator|(
name|crp
operator|->
name|crp_flags
operator|&
name|CRYPTO_F_DONE
operator|)
condition|)
name|error
operator|=
name|msleep
argument_list|(
name|crp
argument_list|,
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
literal|0
argument_list|,
literal|"gssdes3"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
name|crypto_freereq
argument_list|(
name|crp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|struct
name|krb5_encryption_class
name|krb5_des3_encryption_class
init|=
block|{
literal|"des3-cbc-sha1"
block|,
comment|/* name */
name|ETYPE_DES3_CBC_SHA1
block|,
comment|/* etype */
name|EC_DERIVED_KEYS
block|,
comment|/* flags */
literal|8
block|,
comment|/* blocklen */
literal|8
block|,
comment|/* msgblocklen */
literal|20
block|,
comment|/* checksumlen */
literal|168
block|,
comment|/* keybits */
literal|24
block|,
comment|/* keylen */
name|des3_init
block|,
name|des3_destroy
block|,
name|des3_set_key
block|,
name|des3_random_to_key
block|,
name|des3_encrypt
block|,
name|des3_decrypt
block|,
name|des3_checksum
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
literal|0
end_if

begin_define
unit|struct des3_dk_test { 	uint8_t key[24]; 	uint8_t usage[8]; 	size_t usagelen; 	uint8_t dk[24]; }; struct des3_dk_test tests[] = { 	{{0xdc, 0xe0, 0x6b, 0x1f, 0x64, 0xc8, 0x57, 0xa1, 0x1c, 0x3d, 0xb5, 	  0x7c, 0x51, 0x89, 0x9b, 0x2c, 0xc1, 0x79, 0x10, 0x08, 0xce, 0x97, 	  0x3b, 0x92}, 	 {0x00, 0x00, 0x00, 0x01, 0x55}, 5, 	 {0x92, 0x51, 0x79, 0xd0, 0x45, 0x91, 0xa7, 0x9b, 0x5d, 0x31, 0x92, 	  0xc4, 0xa7, 0xe9, 0xc2, 0x89, 0xb0, 0x49, 0xc7, 0x1f, 0x6e, 0xe6, 	  0x04, 0xcd}},  	{{0x5e, 0x13, 0xd3, 0x1c, 0x70, 0xef, 0x76, 0x57, 0x46, 0x57, 0x85, 	  0x31, 0xcb, 0x51, 0xc1, 0x5b, 0xf1, 0x1c, 0xa8, 0x2c, 0x97, 0xce, 	  0xe9, 0xf2}, 	 {0x00, 0x00, 0x00, 0x01, 0xaa}, 5, 	 {0x9e, 0x58, 0xe5, 0xa1, 0x46, 0xd9, 0x94, 0x2a, 0x10, 0x1c, 0x46, 	  0x98, 0x45, 0xd6, 0x7a, 0x20, 0xe3, 0xc4, 0x25, 0x9e, 0xd9, 0x13, 	  0xf2, 0x07}},  	{{0x98, 0xe6, 0xfd, 0x8a, 0x04, 0xa4, 0xb6, 0x85, 0x9b, 0x75, 0xa1, 	  0x76, 0x54, 0x0b, 0x97, 0x52, 0xba, 0xd3, 0xec, 0xd6, 0x10, 0xa2, 	  0x52, 0xbc}, 	 {0x00, 0x00, 0x00, 0x01, 0x55}, 5, 	 {0x13, 0xfe, 0xf8, 0x0d, 0x76, 0x3e, 0x94, 0xec, 0x6d, 0x13, 0xfd, 	  0x2c, 0xa1, 0xd0, 0x85, 0x07, 0x02, 0x49, 0xda, 0xd3, 0x98, 0x08, 	  0xea, 0xbf}},  	{{0x62, 0x2a, 0xec, 0x25, 0xa2, 0xfe, 0x2c, 0xad, 0x70, 0x94, 0x68, 	  0x0b, 0x7c, 0x64, 0x94, 0x02, 0x80, 0x08, 0x4c, 0x1a, 0x7c, 0xec, 	  0x92, 0xb5}, 	 {0x00, 0x00, 0x00, 0x01, 0xaa}, 5, 	 {0xf8, 0xdf, 0xbf, 0x04, 0xb0, 0x97, 0xe6, 0xd9, 0xdc, 0x07, 0x02, 	  0x68, 0x6b, 0xcb, 0x34, 0x89, 0xd9, 0x1f, 0xd9, 0xa4, 0x51, 0x6b, 	  0x70, 0x3e}},  	{{0xd3, 0xf8, 0x29, 0x8c, 0xcb, 0x16, 0x64, 0x38, 0xdc, 0xb9, 0xb9, 	  0x3e, 0xe5, 0xa7, 0x62, 0x92, 0x86, 0xa4, 0x91, 0xf8, 0x38, 0xf8, 	  0x02, 0xfb}, 	 {0x6b, 0x65, 0x72, 0x62, 0x65, 0x72, 0x6f, 0x73}, 8, 	 {0x23, 0x70, 0xda, 0x57, 0x5d, 0x2a, 0x3d, 0xa8, 0x64, 0xce, 0xbf, 	  0xdc, 0x52, 0x04, 0xd5, 0x6d, 0xf7, 0x79, 0xa7, 0xdf, 0x43, 0xd9, 	  0xda, 0x43}},  	{{0xc1, 0x08, 0x16, 0x49, 0xad, 0xa7, 0x43, 0x62, 0xe6, 0xa1, 0x45, 	  0x9d, 0x01, 0xdf, 0xd3, 0x0d, 0x67, 0xc2, 0x23, 0x4c, 0x94, 0x07, 	  0x04, 0xda}, 	 {0x00, 0x00, 0x00, 0x01, 0x55}, 5, 	 {0x34, 0x80, 0x57, 0xec, 0x98, 0xfd, 0xc4, 0x80, 0x16, 0x16, 0x1c, 	  0x2a, 0x4c, 0x7a, 0x94, 0x3e, 0x92, 0xae, 0x49, 0x2c, 0x98, 0x91, 	  0x75, 0xf7}},  	{{0x5d, 0x15, 0x4a, 0xf2, 0x38, 0xf4, 0x67, 0x13, 0x15, 0x57, 0x19, 	  0xd5, 0x5e, 0x2f, 0x1f, 0x79, 0x0d, 0xd6, 0x61, 0xf2, 0x79, 0xa7, 	  0x91, 0x7c}, 	 {0x00, 0x00, 0x00, 0x01, 0xaa}, 5, 	 {0xa8, 0x80, 0x8a, 0xc2, 0x67, 0xda, 0xda, 0x3d, 0xcb, 0xe9, 0xa7, 	  0xc8, 0x46, 0x26, 0xfb, 0xc7, 0x61, 0xc2, 0x94, 0xb0, 0x13, 0x15, 	  0xe5, 0xc1}},  	{{0x79, 0x85, 0x62, 0xe0, 0x49, 0x85, 0x2f, 0x57, 0xdc, 0x8c, 0x34, 	  0x3b, 0xa1, 0x7f, 0x2c, 0xa1, 0xd9, 0x73, 0x94, 0xef, 0xc8, 0xad, 	  0xc4, 0x43}, 	 {0x00, 0x00, 0x00, 0x01, 0x55}, 5, 	 {0xc8, 0x13, 0xf8, 0x8a, 0x3b, 0xe3, 0xb3, 0x34, 0xf7, 0x54, 0x25, 	  0xce, 0x91, 0x75, 0xfb, 0xe3, 0xc8, 0x49, 0x3b, 0x89, 0xc8, 0x70, 	  0x3b, 0x49}},  	{{0x26, 0xdc, 0xe3, 0x34, 0xb5, 0x45, 0x29, 0x2f, 0x2f, 0xea, 0xb9, 	  0xa8, 0x70, 0x1a, 0x89, 0xa4, 0xb9, 0x9e, 0xb9, 0x94, 0x2c, 0xec, 	  0xd0, 0x16}, 	 {0x00, 0x00, 0x00, 0x01, 0xaa}, 5, 	 {0xf4, 0x8f, 0xfd, 0x6e, 0x83, 0xf8, 0x3e, 0x73, 0x54, 0xe6, 0x94, 	  0xfd, 0x25, 0x2c, 0xf8, 0x3b, 0xfe, 0x58, 0xf7, 0xd5, 0xba, 0x37, 	  0xec, 0x5d}}, };
define|#
directive|define
name|N_TESTS
value|(sizeof(tests) / sizeof(tests[0]))
end_define

begin_endif
unit|int main(int argc, char **argv) { 	struct krb5_key_state *key, *dk; 	uint8_t *dkp; 	int j, i;  	for (j = 0; j< N_TESTS; j++) { 		struct des3_dk_test *t =&tests[j]; 		key = krb5_create_key(&des3_encryption_class); 		krb5_set_key(key, t->key); 		dk = krb5_derive_key(key, t->usage, t->usagelen); 		krb5_free_key(key); 		if (memcmp(dk->ks_key, t->dk, 24)) { 			printf("DES3 dk("); 			for (i = 0; i< 24; i++) 				printf("%02x", t->key[i]); 			printf(", "); 			for (i = 0; i< t->usagelen; i++) 				printf("%02x", t->usage[i]); 			printf(") failed\n"); 			printf("should be: "); 			for (i = 0; i< 24; i++) 				printf("%02x", t->dk[i]); 			printf("\n result was: "); 			dkp = dk->ks_key; 			for (i = 0; i< 24; i++) 				printf("%02x", dkp[i]); 			printf("\n"); 		} 		krb5_free_key(dk); 	}  	return (0); }
endif|#
directive|endif
end_endif

end_unit

