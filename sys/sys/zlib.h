begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$	*/
end_comment

begin_comment
comment|/*  * This file is derived from zlib.h and zconf.h from the zlib-1.0.4  * distribution by Jean-loup Gailly and Mark Adler, with some additions  * by Paul Mackerras to aid in implementing Deflate compression and  * decompression for PPP packets.  */
end_comment

begin_comment
comment|/*  *  ==FILEVERSION 971127==  *  * This marker is used by the Linux installation script to determine  * whether an up-to-date version of this file is already installed.  */
end_comment

begin_comment
comment|/* +++ zlib.h */
end_comment

begin_comment
comment|/*-   zlib.h -- interface of the 'zlib' general purpose compression library   version 1.0.4, Jul 24th, 1996.    Copyright (C) 1995-1996 Jean-loup Gailly and Mark Adler    This software is provided 'as-is', without any express or implied   warranty.  In no event will the authors be held liable for any damages   arising from the use of this software.    Permission is granted to anyone to use this software for any purpose,   including commercial applications, and to alter it and redistribute it   freely, subject to the following restrictions:    1. The origin of this software must not be misrepresented; you must not      claim that you wrote the original software. If you use this software      in a product, an acknowledgment in the product documentation would be      appreciated but is not required.   2. Altered source versions must be plainly marked as such, and must not be      misrepresented as being the original software.   3. This notice may not be removed or altered from any source distribution.    Jean-loup Gailly        Mark Adler   gzip@prep.ai.mit.edu    madler@alumni.caltech.edu */
end_comment

begin_comment
comment|/*   The data format used by the zlib library is described by RFCs (Request for   Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt   (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_ZLIB_H
end_ifndef

begin_define
define|#
directive|define
name|_ZLIB_H
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* +++ zconf.h */
comment|/* zconf.h -- configuration of the zlib compression library  * Copyright (C) 1995-1996 Jean-loup Gailly.  * For conditions of distribution and use, see copyright notice in zlib.h   */
comment|/* From: zconf.h,v 1.20 1996/07/02 15:09:28 me Exp $ */
ifndef|#
directive|ifndef
name|_ZCONF_H
define|#
directive|define
name|_ZCONF_H
comment|/*  * If you *really* need a unique prefix for all types and library functions,  * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.  */
ifdef|#
directive|ifdef
name|Z_PREFIX
define|#
directive|define
name|deflateInit_
value|z_deflateInit_
define|#
directive|define
name|deflate
value|z_deflate
define|#
directive|define
name|deflateEnd
value|z_deflateEnd
define|#
directive|define
name|inflateInit_
value|z_inflateInit_
define|#
directive|define
name|inflate
value|z_inflate
define|#
directive|define
name|inflateEnd
value|z_inflateEnd
define|#
directive|define
name|deflateInit2_
value|z_deflateInit2_
define|#
directive|define
name|deflateSetDictionary
value|z_deflateSetDictionary
define|#
directive|define
name|deflateCopy
value|z_deflateCopy
define|#
directive|define
name|deflateReset
value|z_deflateReset
define|#
directive|define
name|deflateParams
value|z_deflateParams
define|#
directive|define
name|inflateInit2_
value|z_inflateInit2_
define|#
directive|define
name|inflateSetDictionary
value|z_inflateSetDictionary
define|#
directive|define
name|inflateSync
value|z_inflateSync
define|#
directive|define
name|inflateReset
value|z_inflateReset
define|#
directive|define
name|compress
value|z_compress
define|#
directive|define
name|uncompress
value|z_uncompress
define|#
directive|define
name|adler32
value|z_adler32
if|#
directive|if
literal|0
define|#
directive|define
name|crc32
value|z_crc32
define|#
directive|define
name|get_crc_table
value|z_get_crc_table
endif|#
directive|endif
define|#
directive|define
name|Byte
value|z_Byte
define|#
directive|define
name|uInt
value|z_uInt
define|#
directive|define
name|uLong
value|z_uLong
define|#
directive|define
name|Bytef
value|z_Bytef
define|#
directive|define
name|charf
value|z_charf
define|#
directive|define
name|intf
value|z_intf
define|#
directive|define
name|uIntf
value|z_uIntf
define|#
directive|define
name|uLongf
value|z_uLongf
define|#
directive|define
name|voidpf
value|z_voidpf
define|#
directive|define
name|voidp
value|z_voidp
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__WIN32__
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|WIN32
argument_list|)
define|#
directive|define
name|WIN32
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__386__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
ifndef|#
directive|ifndef
name|__32BIT__
define|#
directive|define
name|__32BIT__
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
define|#
directive|define
name|MSDOS
endif|#
directive|endif
comment|/*  * Compile with -DMAXSEG_64K if the alloc function cannot allocate more  * than 64k bytes at a time (needed on systems with 16-bit int).  */
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__32BIT__
argument_list|)
define|#
directive|define
name|MAXSEG_64K
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MSDOS
define|#
directive|define
name|UNALIGNED_OK
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|_WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|WIN32
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STDC
argument_list|)
define|#
directive|define
name|STDC
endif|#
directive|endif
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|STDC
argument_list|)
define|#
directive|define
name|STDC
endif|#
directive|endif
ifndef|#
directive|ifndef
name|STDC
ifndef|#
directive|ifndef
name|const
comment|/* cannot use !defined(STDC)&& !defined(const) on Mac */
define|#
directive|define
name|const
endif|#
directive|endif
endif|#
directive|endif
comment|/* Some Mac compilers merge all .h files incorrectly: */
if|#
directive|if
name|defined
argument_list|(
name|__MWERKS__
argument_list|)
operator|||
name|defined
argument_list|(
name|applec
argument_list|)
operator|||
name|defined
argument_list|(
name|THINK_C
argument_list|)
operator|||
name|defined
argument_list|(
name|__SC__
argument_list|)
define|#
directive|define
name|NO_DUMMY_DECL
endif|#
directive|endif
comment|/* Maximum value for memLevel in deflateInit2 */
ifndef|#
directive|ifndef
name|MAX_MEM_LEVEL
ifdef|#
directive|ifdef
name|MAXSEG_64K
define|#
directive|define
name|MAX_MEM_LEVEL
value|8
else|#
directive|else
define|#
directive|define
name|MAX_MEM_LEVEL
value|9
endif|#
directive|endif
endif|#
directive|endif
comment|/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
ifndef|#
directive|ifndef
name|MAX_WBITS
define|#
directive|define
name|MAX_WBITS
value|15
comment|/* 32K LZ77 window */
endif|#
directive|endif
comment|/* The memory requirements for deflate are (in bytes):             1<< (windowBits+2)   +  1<< (memLevel+9)  that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)  plus a few kilobytes for small objects. For example, if you want to reduce  the default memory requirements from 256K to 128K, compile with      make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"  Of course this will generally degrade compression (there's no free lunch).     The memory requirements for inflate are (in bytes) 1<< windowBits  that is, 32K for windowBits=15 (default value) plus a few kilobytes  for small objects. */
comment|/* Type declarations */
ifndef|#
directive|ifndef
name|OF
comment|/* function prototypes */
ifdef|#
directive|ifdef
name|STDC
define|#
directive|define
name|OF
parameter_list|(
name|args
parameter_list|)
value|args
else|#
directive|else
define|#
directive|define
name|OF
parameter_list|(
name|args
parameter_list|)
value|()
endif|#
directive|endif
endif|#
directive|endif
comment|/* The following definitions for FAR are needed only for MSDOS mixed  * model programming (small or medium model with some far allocations).  * This was tested only with MSC; for other MSDOS compilers you may have  * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,  * just define FAR to be empty.  */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|M_I86SM
argument_list|)
operator|||
name|defined
argument_list|(
name|M_I86MM
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__32BIT__
argument_list|)
comment|/* MSC small or medium model */
define|#
directive|define
name|SMALL_MEDIUM
ifdef|#
directive|ifdef
name|_MSC_VER
define|#
directive|define
name|FAR
value|__far
else|#
directive|else
define|#
directive|define
name|FAR
value|far
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
operator|(
name|defined
argument_list|(
name|__SMALL__
argument_list|)
operator|||
name|defined
argument_list|(
name|__MEDIUM__
argument_list|)
operator|)
ifndef|#
directive|ifndef
name|__32BIT__
define|#
directive|define
name|SMALL_MEDIUM
define|#
directive|define
name|FAR
value|__far
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|FAR
define|#
directive|define
name|FAR
endif|#
directive|endif
typedef|typedef
name|unsigned
name|char
name|Byte
typedef|;
comment|/* 8 bits */
typedef|typedef
name|unsigned
name|int
name|uInt
typedef|;
comment|/* 16 bits or more */
typedef|typedef
name|unsigned
name|long
name|uLong
typedef|;
comment|/* 32 bits or more */
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
operator|&&
name|defined
argument_list|(
name|SMALL_MEDIUM
argument_list|)
comment|/* Borland C/C++ ignores FAR inside typedef */
define|#
directive|define
name|Bytef
value|Byte FAR
else|#
directive|else
typedef|typedef
name|Byte
name|FAR
name|Bytef
typedef|;
endif|#
directive|endif
typedef|typedef
name|char
name|FAR
name|charf
typedef|;
typedef|typedef
name|int
name|FAR
name|intf
typedef|;
typedef|typedef
name|uInt
name|FAR
name|uIntf
typedef|;
typedef|typedef
name|uLong
name|FAR
name|uLongf
typedef|;
ifdef|#
directive|ifdef
name|STDC
typedef|typedef
name|void
name|FAR
modifier|*
name|voidpf
typedef|;
typedef|typedef
name|void
modifier|*
name|voidp
typedef|;
else|#
directive|else
typedef|typedef
name|Byte
name|FAR
modifier|*
name|voidpf
typedef|;
typedef|typedef
name|Byte
modifier|*
name|voidp
typedef|;
endif|#
directive|endif
comment|/* Compile with -DZLIB_DLL for Windows DLL support */
if|#
directive|if
operator|(
name|defined
argument_list|(
name|_WINDOWS
argument_list|)
operator|||
name|defined
argument_list|(
name|WINDOWS
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|ZLIB_DLL
argument_list|)
include|#
directive|include
file|<windows.h>
define|#
directive|define
name|EXPORT
value|WINAPI
else|#
directive|else
define|#
directive|define
name|EXPORT
endif|#
directive|endif
endif|#
directive|endif
comment|/* _ZCONF_H */
comment|/* --- zconf.h */
define|#
directive|define
name|ZLIB_VERSION
value|"1.0.4P"
comment|/*       The 'zlib' compression library provides in-memory compression and   decompression functions, including integrity checks of the uncompressed   data.  This version of the library supports only one compression method   (deflation) but other algorithms may be added later and will have the same   stream interface.       For compression the application must provide the output buffer and   may optionally provide the input buffer for optimization. For decompression,   the application must provide the input buffer and may optionally provide   the output buffer for optimization.       Compression can be done in a single step if the buffers are large   enough (for example if an input file is mmap'ed), or can be done by   repeated calls of the compression function.  In the latter case, the   application must provide more input and/or consume the output   (providing more output space) before each call.       The library does not install any signal handler. It is recommended to   add at least a handler for SIGSEGV when decompressing; the library checks   the consistency of the input data whenever possible but may go nuts   for some forms of corrupted input. */
typedef|typedef
name|voidpf
argument_list|(
argument|*alloc_func
argument_list|)
name|OF
argument_list|(
operator|(
name|voidpf
name|opaque
operator|,
name|uInt
name|items
operator|,
name|uInt
name|size
operator|)
argument_list|)
expr_stmt|;
typedef|typedef
name|void
argument_list|(
argument|*free_func
argument_list|)
name|OF
argument_list|(
operator|(
name|voidpf
name|opaque
operator|,
name|voidpf
name|address
operator|)
argument_list|)
expr_stmt|;
struct_decl|struct
name|internal_state
struct_decl|;
typedef|typedef
struct|struct
name|z_stream_s
block|{
name|Bytef
modifier|*
name|next_in
decl_stmt|;
comment|/* next input byte */
name|uInt
name|avail_in
decl_stmt|;
comment|/* number of bytes available at next_in */
name|uLong
name|total_in
decl_stmt|;
comment|/* total nb of input bytes read so far */
name|Bytef
modifier|*
name|next_out
decl_stmt|;
comment|/* next output byte should be put there */
name|uInt
name|avail_out
decl_stmt|;
comment|/* remaining free space at next_out */
name|uLong
name|total_out
decl_stmt|;
comment|/* total nb of bytes output so far */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
comment|/* last error message, NULL if no error */
name|struct
name|internal_state
name|FAR
modifier|*
name|state
decl_stmt|;
comment|/* not visible by applications */
name|alloc_func
name|zalloc
decl_stmt|;
comment|/* used to allocate the internal state */
name|free_func
name|zfree
decl_stmt|;
comment|/* used to free the internal state */
name|voidpf
name|opaque
decl_stmt|;
comment|/* private data object passed to zalloc and zfree */
name|int
name|data_type
decl_stmt|;
comment|/* best guess about the data type: ascii or binary */
name|uLong
name|adler
decl_stmt|;
comment|/* adler32 value of the uncompressed data */
name|uLong
name|reserved
decl_stmt|;
comment|/* reserved for future use */
block|}
name|z_stream
typedef|;
typedef|typedef
name|z_stream
name|FAR
modifier|*
name|z_streamp
typedef|;
comment|/*    The application must update next_in and avail_in when avail_in has    dropped to zero. It must update next_out and avail_out when avail_out    has dropped to zero. The application must initialize zalloc, zfree and    opaque before calling the init function. All other fields are set by the    compression library and must not be updated by the application.     The opaque value provided by the application will be passed as the first    parameter for calls of zalloc and zfree. This can be useful for custom    memory management. The compression library attaches no meaning to the    opaque value.     zalloc must return Z_NULL if there is not enough memory for the object.    On 16-bit systems, the functions zalloc and zfree must be able to allocate    exactly 65536 bytes, but will not be required to allocate more than this    if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,    pointers returned by zalloc for objects of exactly 65536 bytes *must*    have their offset normalized to zero. The default allocation function    provided by this library ensures this (see zutil.c). To reduce memory    requirements and avoid any allocation of 64K objects, at the expense of    compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).     The fields total_in and total_out can be used for statistics or    progress reports. After compression, total_in holds the total size of    the uncompressed data and may be saved for use in the decompressor    (particularly if the decompressor wants to decompress everything in    a single step). */
comment|/* constants */
define|#
directive|define
name|Z_NO_FLUSH
value|0
define|#
directive|define
name|Z_PARTIAL_FLUSH
value|1
define|#
directive|define
name|Z_PACKET_FLUSH
value|2
define|#
directive|define
name|Z_SYNC_FLUSH
value|3
define|#
directive|define
name|Z_FULL_FLUSH
value|4
define|#
directive|define
name|Z_FINISH
value|5
comment|/* Allowed flush values; see deflate() below for details */
define|#
directive|define
name|Z_OK
value|0
define|#
directive|define
name|Z_STREAM_END
value|1
define|#
directive|define
name|Z_NEED_DICT
value|2
define|#
directive|define
name|Z_ERRNO
value|(-1)
define|#
directive|define
name|Z_STREAM_ERROR
value|(-2)
define|#
directive|define
name|Z_DATA_ERROR
value|(-3)
define|#
directive|define
name|Z_MEM_ERROR
value|(-4)
define|#
directive|define
name|Z_BUF_ERROR
value|(-5)
define|#
directive|define
name|Z_VERSION_ERROR
value|(-6)
comment|/* Return codes for the compression/decompression functions. Negative  * values are errors, positive values are used for special but normal events.  */
define|#
directive|define
name|Z_NO_COMPRESSION
value|0
define|#
directive|define
name|Z_BEST_SPEED
value|1
define|#
directive|define
name|Z_BEST_COMPRESSION
value|9
define|#
directive|define
name|Z_DEFAULT_COMPRESSION
value|(-1)
comment|/* compression levels */
define|#
directive|define
name|Z_FILTERED
value|1
define|#
directive|define
name|Z_HUFFMAN_ONLY
value|2
define|#
directive|define
name|Z_DEFAULT_STRATEGY
value|0
comment|/* compression strategy; see deflateInit2() below for details */
define|#
directive|define
name|Z_BINARY
value|0
define|#
directive|define
name|Z_ASCII
value|1
define|#
directive|define
name|Z_UNKNOWN
value|2
comment|/* Possible values of the data_type field */
define|#
directive|define
name|Z_DEFLATED
value|8
comment|/* The deflate compression method (the only one supported in this version) */
define|#
directive|define
name|Z_NULL
value|0
comment|/* for initializing zalloc, zfree, opaque */
define|#
directive|define
name|zlib_version
value|zlibVersion()
comment|/* for compatibility with versions< 1.0.2 */
comment|/* basic functions */
specifier|extern
specifier|const
name|char
modifier|*
name|EXPORT
name|zlibVersion
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* The application can compare zlibVersion and ZLIB_VERSION for consistency.    If the first character differs, the library code actually used is    not compatible with the zlib.h header file used by the application.    This check is automatically made by deflateInit and inflateInit.  */
comment|/*  extern int EXPORT deflateInit OF((z_streamp strm, int level));       Initializes the internal stream state for compression. The fields    zalloc, zfree and opaque must be initialized before by the caller.    If zalloc and zfree are set to Z_NULL, deflateInit updates them to    use default allocation functions.       The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:    1 gives best speed, 9 gives best compression, 0 gives no compression at    all (the input data is simply copied a block at a time).    Z_DEFAULT_COMPRESSION requests a default compromise between speed and    compression (currently equivalent to level 6).       deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not    enough memory, Z_STREAM_ERROR if level is not a valid compression level,    Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible    with the version assumed by the caller (ZLIB_VERSION).    msg is set to null if there is no error message.  deflateInit does not    perform any compression: this will be done by deflate(). */
specifier|extern
name|int
name|EXPORT
name|deflate
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
comment|/*   Performs one or both of the following actions:    - Compress more input starting at next_in and update next_in and avail_in     accordingly. If not all input can be processed (because there is not     enough room in the output buffer), next_in and avail_in are updated and     processing will resume at this point for the next call of deflate().    - Provide more output starting at next_out and update next_out and avail_out     accordingly. This action is forced if the parameter flush is non zero.     Forcing flush frequently degrades the compression ratio, so this parameter     should be set only when necessary (in interactive applications).     Some output may be provided even if flush is not set.    Before the call of deflate(), the application should ensure that at least   one of the actions is possible, by providing more input and/or consuming   more output, and updating avail_in or avail_out accordingly; avail_out   should never be zero before the call. The application can consume the   compressed output when it wants, for example when the output buffer is full   (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK   and with zero avail_out, it must be called again after making room in the   output buffer because there might be more output pending.      If the parameter flush is set to Z_PARTIAL_FLUSH, the current compression   block is terminated and flushed to the output buffer so that the   decompressor can get all input data available so far. For method 9, a future   variant on method 8, the current block will be flushed but not terminated.   Z_SYNC_FLUSH has the same effect as partial flush except that the compressed   output is byte aligned (the compressor can clear its internal bit buffer)   and the current block is always terminated; this can be useful if the   compressor has to be restarted from scratch after an interruption (in which   case the internal state of the compressor may be lost).     If flush is set to Z_FULL_FLUSH, the compression block is terminated, a   special marker is output and the compression dictionary is discarded; this   is useful to allow the decompressor to synchronize if one compressed block   has been damaged (see inflateSync below).  Flushing degrades compression and   so should be used only when necessary.  Using Z_FULL_FLUSH too often can   seriously degrade the compression. If deflate returns with avail_out == 0,   this function must be called again with the same value of the flush   parameter and more output space (updated avail_out), until the flush is   complete (deflate returns with non-zero avail_out).      If the parameter flush is set to Z_PACKET_FLUSH, the compression   block is terminated, and a zero-length stored block is output,   omitting the length bytes (the effect of this is that the 3-bit type   code 000 for a stored block is output, and the output is then   byte-aligned).  This is designed for use at the end of a PPP packet.      If the parameter flush is set to Z_FINISH, pending input is processed,   pending output is flushed and deflate returns with Z_STREAM_END if there   was enough output space; if deflate returns with Z_OK, this function must be   called again with Z_FINISH and more output space (updated avail_out) but no   more input data, until it returns with Z_STREAM_END or an error. After   deflate has returned Z_STREAM_END, the only possible operations on the   stream are deflateReset or deflateEnd.        Z_FINISH can be used immediately after deflateInit if all the compression   is to be done in a single step. In this case, avail_out must be at least   0.1% larger than avail_in plus 12 bytes.  If deflate does not return   Z_STREAM_END, then it must be called again as described above.      deflate() may update data_type if it can make a good guess about   the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered   binary. This field is only for information purposes and does not affect   the compression algorithm in any manner.      deflate() returns Z_OK if some progress has been made (more input   processed or more output produced), Z_STREAM_END if all input has been   consumed and all output has been produced (only when flush is set to   Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example   if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible. */
specifier|extern
name|int
name|EXPORT
name|deflateEnd
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      All dynamically allocated data structures for this stream are freed.    This function discards any unprocessed input and does not flush any    pending output.       deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the    stream state was inconsistent, Z_DATA_ERROR if the stream was freed    prematurely (some input or output was discarded). In the error case,    msg may be set but then points to a static string (which must not be    deallocated). */
comment|/*  extern int EXPORT inflateInit OF((z_streamp strm));       Initializes the internal stream state for decompression. The fields    zalloc, zfree and opaque must be initialized before by the caller.  If    zalloc and zfree are set to Z_NULL, inflateInit updates them to use default    allocation functions.       inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not    enough memory, Z_VERSION_ERROR if the zlib library version is incompatible    with the version assumed by the caller.  msg is set to null if there is no    error message. inflateInit does not perform any decompression: this will be    done by inflate(). */
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
define|#
directive|define
name|inflate
value|_zlib104_inflate
comment|/* FreeBSD already has an inflate :-( */
endif|#
directive|endif
specifier|extern
name|int
name|EXPORT
name|inflate
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
comment|/*   Performs one or both of the following actions:    - Decompress more input starting at next_in and update next_in and avail_in     accordingly. If not all input can be processed (because there is not     enough room in the output buffer), next_in is updated and processing     will resume at this point for the next call of inflate().    - Provide more output starting at next_out and update next_out and avail_out     accordingly.  inflate() provides as much output as possible, until there     is no more input data or no more space in the output buffer (see below     about the flush parameter).    Before the call of inflate(), the application should ensure that at least   one of the actions is possible, by providing more input and/or consuming   more output, and updating the next_* and avail_* values accordingly.   The application can consume the uncompressed output when it wants, for   example when the output buffer is full (avail_out == 0), or after each   call of inflate(). If inflate returns Z_OK and with zero avail_out, it   must be called again after making room in the output buffer because there   might be more output pending.      If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,   inflate flushes as much output as possible to the output buffer. The   flushing behavior of inflate is not specified for values of the flush   parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the   current implementation actually flushes as much output as possible   anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data   has been consumed, it is expecting to see the length field of a stored   block; if not, it returns Z_DATA_ERROR.      inflate() should normally be called until it returns Z_STREAM_END or an   error. However if all decompression is to be performed in a single step   (a single call of inflate), the parameter flush should be set to   Z_FINISH. In this case all pending input is processed and all pending   output is flushed; avail_out must be large enough to hold all the   uncompressed data. (The size of the uncompressed data may have been saved   by the compressor for this purpose.) The next operation on this stream must   be inflateEnd to deallocate the decompression state. The use of Z_FINISH   is never required, but can be used to inform inflate that a faster routine   may be used for the single inflate() call.      inflate() returns Z_OK if some progress has been made (more input   processed or more output produced), Z_STREAM_END if the end of the   compressed data has been reached and all uncompressed output has been   produced, Z_NEED_DICT if a preset dictionary is needed at this point (see   inflateSetDictionary below), Z_DATA_ERROR if the input data was corrupted,   Z_STREAM_ERROR if the stream structure was inconsistent (for example if   next_in or next_out was NULL), Z_MEM_ERROR if there was not enough memory,   Z_BUF_ERROR if no progress is possible or if there was not enough room in   the output buffer when Z_FINISH is used. In the Z_DATA_ERROR case, the   application may then call inflateSync to look for a good compression block.   In the Z_NEED_DICT case, strm->adler is set to the Adler32 value of the   dictionary chosen by the compressor. */
specifier|extern
name|int
name|EXPORT
name|inflateEnd
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      All dynamically allocated data structures for this stream are freed.    This function discards any unprocessed input and does not flush any    pending output.       inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state    was inconsistent. In the error case, msg may be set but then points to a    static string (which must not be deallocated). */
comment|/* Advanced functions */
comment|/*     The following functions are needed only in some special applications. */
comment|/*    extern int EXPORT deflateInit2 OF((z_streamp strm,                                    int  level,                                    int  method,                                    int  windowBits,                                    int  memLevel,                                    int  strategy));       This is another version of deflateInit with more compression options. The    fields next_in, zalloc, zfree and opaque must be initialized before by    the caller.       The method parameter is the compression method. It must be Z_DEFLATED in    this version of the library. (Method 9 will allow a 64K history buffer and    partial block flushes.)       The windowBits parameter is the base two logarithm of the window size    (the size of the history buffer).  It should be in the range 8..15 for this    version of the library (the value 16 will be allowed for method 9). Larger    values of this parameter result in better compression at the expense of    memory usage. The default value is 15 if deflateInit is used instead.       The memLevel parameter specifies how much memory should be allocated    for the internal compression state. memLevel=1 uses minimum memory but    is slow and reduces compression ratio; memLevel=9 uses maximum memory    for optimal speed. The default value is 8. See zconf.h for total memory    usage as a function of windowBits and memLevel.       The strategy parameter is used to tune the compression algorithm. Use the    value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a    filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no    string match).  Filtered data consists mostly of small values with a    somewhat random distribution. In this case, the compression algorithm is    tuned to compress them better. The effect of Z_FILTERED is to force more    Huffman coding and less string matching; it is somewhat intermediate    between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects    the compression ratio but not the correctness of the compressed output even    if it is not set appropriately.       If next_in is not null, the library will use this buffer to hold also    some history information; the buffer must either hold the entire input    data, or have at least 1<<(windowBits+1) bytes and be writable. If next_in    is null, the library will allocate its own history buffer (and leave next_in    null). next_out need not be provided here but must be provided by the    application for the next call of deflate().       If the history buffer is provided by the application, next_in must    must never be changed by the application since the compressor maintains    information inside this buffer from call to call; the application    must provide more input only by increasing avail_in. next_in is always    reset by the library in this case.        deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was    not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as    an invalid method). msg is set to null if there is no error message.    deflateInit2 does not perform any compression: this will be done by    deflate().  */
specifier|extern
name|int
name|EXPORT
name|deflateSetDictionary
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
specifier|const
name|Bytef
operator|*
name|dictionary
operator|,
name|uInt
name|dictLength
operator|)
argument_list|)
decl_stmt|;
comment|/*      Initializes the compression dictionary (history buffer) from the given    byte sequence without producing any compressed output. This function must    be called immediately after deflateInit or deflateInit2, before any call    of deflate. The compressor and decompressor must use exactly the same    dictionary (see inflateSetDictionary).      The dictionary should consist of strings (byte sequences) that are likely    to be encountered later in the data to be compressed, with the most commonly    used strings preferably put towards the end of the dictionary. Using a    dictionary is most useful when the data to be compressed is short and    can be predicted with good accuracy; the data can then be compressed better    than with the default empty dictionary. In this version of the library,    only the last 32K bytes of the dictionary are used.      Upon return of this function, strm->adler is set to the Adler32 value    of the dictionary; the decompressor may later use this value to determine    which dictionary has been used by the compressor. (The Adler32 value    applies to the whole dictionary even if only a subset of the dictionary is    actually used by the compressor.)       deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a    parameter is invalid (such as NULL dictionary) or the stream state    is inconsistent (for example if deflate has already been called for this    stream). deflateSetDictionary does not perform any compression: this will    be done by deflate().  */
specifier|extern
name|int
name|EXPORT
name|deflateCopy
name|OF
argument_list|(
operator|(
name|z_streamp
name|dest
operator|,
name|z_streamp
name|source
operator|)
argument_list|)
decl_stmt|;
comment|/*      Sets the destination stream as a complete copy of the source stream.  If    the source stream is using an application-supplied history buffer, a new    buffer is allocated for the destination stream.  The compressed output    buffer is always application-supplied. It's the responsibility of the    application to provide the correct values of next_out and avail_out for the    next call of deflate.       This function can be useful when several compression strategies will be    tried, for example when there are several ways of pre-processing the input    data with a filter. The streams that will be discarded should then be freed    by calling deflateEnd.  Note that deflateCopy duplicates the internal    compression state which can be quite large, so this strategy is slow and    can consume lots of memory.       deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not    enough memory, Z_STREAM_ERROR if the source stream state was inconsistent    (such as zalloc being NULL). msg is left unchanged in both source and    destination. */
specifier|extern
name|int
name|EXPORT
name|deflateReset
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      This function is equivalent to deflateEnd followed by deflateInit,    but does not free and reallocate all the internal compression state.    The stream will keep the same compression level and any other attributes    that may have been set by deflateInit2.        deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source    stream state was inconsistent (such as zalloc or state being NULL). */
specifier|extern
name|int
name|EXPORT
name|deflateParams
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|int
name|level
operator|,
name|int
name|strategy
operator|)
argument_list|)
decl_stmt|;
comment|/*      Dynamically update the compression level and compression strategy.    This can be used to switch between compression and straight copy of    the input data, or to switch to a different kind of input data requiring    a different strategy. If the compression level is changed, the input    available so far is compressed with the old level (and may be flushed);    the new level will take effect only at the next call of deflate().       Before the call of deflateParams, the stream state must be set as for    a call of deflate(), since the currently available input may have to    be compressed and flushed. In particular, strm->avail_out must be non-zero.       deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source    stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR    if strm->avail_out was zero. */
specifier|extern
name|int
name|EXPORT
name|deflateOutputPending
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      Returns the number of bytes of output which are immediately    available from the compressor (i.e. without any further input    or flush). */
comment|/*    extern int EXPORT inflateInit2 OF((z_streamp strm,                                    int  windowBits));       This is another version of inflateInit with more compression options. The    fields next_out, zalloc, zfree and opaque must be initialized before by    the caller.       The windowBits parameter is the base two logarithm of the maximum window    size (the size of the history buffer).  It should be in the range 8..15 for    this version of the library (the value 16 will be allowed soon). The    default value is 15 if inflateInit is used instead. If a compressed stream    with a larger window size is given as input, inflate() will return with    the error code Z_DATA_ERROR instead of trying to allocate a larger window.       If next_out is not null, the library will use this buffer for the history    buffer; the buffer must either be large enough to hold the entire output    data, or have at least 1<<windowBits bytes.  If next_out is null, the    library will allocate its own buffer (and leave next_out null). next_in    need not be provided here but must be provided by the application for the    next call of inflate().       If the history buffer is provided by the application, next_out must    never be changed by the application since the decompressor maintains    history information inside this buffer from call to call; the application    can only reset next_out to the beginning of the history buffer when    avail_out is zero and all output has been consumed.        inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was    not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as    windowBits< 8). msg is set to null if there is no error message.    inflateInit2 does not perform any decompression: this will be done by    inflate(). */
specifier|extern
name|int
name|EXPORT
name|inflateSetDictionary
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
specifier|const
name|Bytef
operator|*
name|dictionary
operator|,
name|uInt
name|dictLength
operator|)
argument_list|)
decl_stmt|;
comment|/*      Initializes the decompression dictionary (history buffer) from the given    uncompressed byte sequence. This function must be called immediately after    a call of inflate if this call returned Z_NEED_DICT. The dictionary chosen    by the compressor can be determined from the Adler32 value returned by this    call of inflate. The compressor and decompressor must use exactly the same    dictionary (see deflateSetDictionary).       inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a    parameter is invalid (such as NULL dictionary) or the stream state is    inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the    expected one (incorrect Adler32 value). inflateSetDictionary does not    perform any decompression: this will be done by subsequent calls of    inflate(). */
specifier|extern
name|int
name|EXPORT
name|inflateSync
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      Skips invalid compressed data until the special marker (see deflate()   above) can be found, or until all available input is skipped. No output   is provided.      inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR   if no more input was provided, Z_DATA_ERROR if no marker has been found,   or Z_STREAM_ERROR if the stream structure was inconsistent. In the success   case, the application may save the current current value of total_in which   indicates where valid compressed data was found. In the error case, the   application may repeatedly call inflateSync, providing more input each time,   until success or end of the input data. */
specifier|extern
name|int
name|EXPORT
name|inflateReset
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      This function is equivalent to inflateEnd followed by inflateInit,    but does not free and reallocate all the internal decompression state.    The stream will keep attributes that may have been set by inflateInit2.        inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source    stream state was inconsistent (such as zalloc or state being NULL). */
specifier|extern
name|int
name|inflateIncomp
name|OF
argument_list|(
operator|(
name|z_stream
operator|*
name|strm
operator|)
argument_list|)
decl_stmt|;
comment|/*      This function adds the data at next_in (avail_in bytes) to the output    history without performing any output.  There must be no pending output,    and the decompressor must be expecting to see the start of a block.    Calling this function is equivalent to decompressing a stored block    containing the data at next_in (except that the data is not output). */
comment|/* utility functions */
comment|/*      The following utility functions are implemented on top of the    basic stream-oriented functions. To simplify the interface, some    default options are assumed (compression level, window size,    standard memory allocation functions). The source code of these    utility functions can easily be modified if you need special options. */
specifier|extern
name|int
name|EXPORT
name|compress
name|OF
argument_list|(
operator|(
name|Bytef
operator|*
name|dest
operator|,
name|uLongf
operator|*
name|destLen
operator|,
specifier|const
name|Bytef
operator|*
name|source
operator|,
name|uLong
name|sourceLen
operator|)
argument_list|)
decl_stmt|;
comment|/*      Compresses the source buffer into the destination buffer.  sourceLen is    the byte length of the source buffer. Upon entry, destLen is the total    size of the destination buffer, which must be at least 0.1% larger than    sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the    compressed buffer.      This function can be used to compress a whole file at once if the    input file is mmap'ed.      compress returns Z_OK if success, Z_MEM_ERROR if there was not    enough memory, Z_BUF_ERROR if there was not enough room in the output    buffer. */
specifier|extern
name|int
name|EXPORT
name|uncompress
name|OF
argument_list|(
operator|(
name|Bytef
operator|*
name|dest
operator|,
name|uLongf
operator|*
name|destLen
operator|,
specifier|const
name|Bytef
operator|*
name|source
operator|,
name|uLong
name|sourceLen
operator|)
argument_list|)
decl_stmt|;
comment|/*      Decompresses the source buffer into the destination buffer.  sourceLen is    the byte length of the source buffer. Upon entry, destLen is the total    size of the destination buffer, which must be large enough to hold the    entire uncompressed data. (The size of the uncompressed data must have    been saved previously by the compressor and transmitted to the decompressor    by some mechanism outside the scope of this compression library.)    Upon exit, destLen is the actual size of the compressed buffer.      This function can be used to decompress a whole file at once if the    input file is mmap'ed.       uncompress returns Z_OK if success, Z_MEM_ERROR if there was not    enough memory, Z_BUF_ERROR if there was not enough room in the output    buffer, or Z_DATA_ERROR if the input data was corrupted. */
typedef|typedef
name|voidp
name|gzFile
typedef|;
specifier|extern
name|gzFile
name|EXPORT
name|gzopen
name|OF
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
comment|/*      Opens a gzip (.gz) file for reading or writing. The mode parameter    is as in fopen ("rb" or "wb") but can also include a compression level    ("wb9").  gzopen can be used to read a file which is not in gzip format;    in this case gzread will directly read from the file without decompression.      gzopen returns NULL if the file could not be opened or if there was    insufficient memory to allocate the (de)compression state; errno    can be checked to distinguish the two cases (if errno is zero, the    zlib error is Z_MEM_ERROR). */
specifier|extern
name|gzFile
name|EXPORT
name|gzdopen
name|OF
argument_list|(
operator|(
name|int
name|fd
operator|,
specifier|const
name|char
operator|*
name|mode
operator|)
argument_list|)
decl_stmt|;
comment|/*      gzdopen() associates a gzFile with the file descriptor fd.  File    descriptors are obtained from calls like open, dup, creat, pipe or    fileno (in the file has been previously opened with fopen).    The mode parameter is as in gzopen.      The next call of gzclose on the returned gzFile will also close the    file descriptor fd, just like fclose(fdopen(fd), mode) closes the file    descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).      gzdopen returns NULL if there was insufficient memory to allocate    the (de)compression state. */
specifier|extern
name|int
name|EXPORT
name|gzread
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|,
name|voidp
name|buf
operator|,
name|unsigned
name|len
operator|)
argument_list|)
decl_stmt|;
comment|/*      Reads the given number of uncompressed bytes from the compressed file.    If the input file was not in gzip format, gzread copies the given number    of bytes into the buffer.      gzread returns the number of uncompressed bytes actually read (0 for    end of file, -1 for error). */
specifier|extern
name|int
name|EXPORT
name|gzwrite
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|,
specifier|const
name|voidp
name|buf
operator|,
name|unsigned
name|len
operator|)
argument_list|)
decl_stmt|;
comment|/*      Writes the given number of uncompressed bytes into the compressed file.    gzwrite returns the number of uncompressed bytes actually written    (0 in case of error). */
specifier|extern
name|int
name|EXPORT
name|gzflush
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|,
name|int
name|flush
operator|)
argument_list|)
decl_stmt|;
comment|/*      Flushes all pending output into the compressed file. The parameter    flush is as in the deflate() function. The return value is the zlib    error number (see function gzerror below). gzflush returns Z_OK if    the flush parameter is Z_FINISH and all output could be flushed.      gzflush should be called only when strictly necessary because it can    degrade compression. */
specifier|extern
name|int
name|EXPORT
name|gzclose
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|)
argument_list|)
decl_stmt|;
comment|/*      Flushes all pending output if necessary, closes the compressed file    and deallocates all the (de)compression state. The return value is the zlib    error number (see function gzerror below). */
specifier|extern
specifier|const
name|char
modifier|*
name|EXPORT
name|gzerror
name|OF
argument_list|(
operator|(
name|gzFile
name|file
operator|,
name|int
operator|*
name|errnum
operator|)
argument_list|)
decl_stmt|;
comment|/*      Returns the error message for the last error which occurred on the    given compressed file. errnum is set to zlib error number. If an    error occurred in the filesystem and not in the compression library,    errnum is set to Z_ERRNO and the application may consult errno    to get the exact error code. */
comment|/* checksum functions */
comment|/*      These functions are not related to compression but are exported    anyway because they might be useful in applications using the    compression library. */
specifier|extern
name|uLong
name|EXPORT
name|adler32
name|OF
argument_list|(
operator|(
name|uLong
name|adler
operator|,
specifier|const
name|Bytef
operator|*
name|buf
operator|,
name|uInt
name|len
operator|)
argument_list|)
decl_stmt|;
comment|/*      Update a running Adler-32 checksum with the bytes buf[0..len-1] and    return the updated checksum. If buf is NULL, this function returns    the required initial value for the checksum.    An Adler-32 checksum is almost as reliable as a CRC32 but can be computed    much faster. Usage example:       uLong adler = adler32(0L, Z_NULL, 0);       while (read_buffer(buffer, length) != EOF) {        adler = adler32(adler, buffer, length);      }      if (adler != original_adler) error(); */
if|#
directive|if
literal|0
block|extern uLong EXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
comment|/*      Update a running crc with the bytes buf[0..len-1] and return the updated    crc. If buf is NULL, this function returns the required initial value    for the crc. Pre- and post-conditioning (one's complement) is performed    within this function so it shouldn't be done by the application.    Usage example:       uLong crc = crc32(0L, Z_NULL, 0);       while (read_buffer(buffer, length) != EOF) {        crc = crc32(crc, buffer, length);      }      if (crc != original_crc) error(); */
endif|#
directive|endif
comment|/* various hacks, don't look :) */
comment|/* deflateInit and inflateInit are macros to allow checking the zlib version  * and the compiler's view of z_stream:  */
specifier|extern
name|int
name|EXPORT
name|deflateInit_
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|int
name|level
operator|,
specifier|const
name|char
operator|*
name|version
operator|,
name|int
name|stream_size
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|EXPORT
name|inflateInit_
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
specifier|const
name|char
operator|*
name|version
operator|,
name|int
name|stream_size
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|EXPORT
name|deflateInit2_
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|int
name|level
operator|,
name|int
name|method
operator|,
name|int
name|windowBits
operator|,
name|int
name|memLevel
operator|,
name|int
name|strategy
operator|,
specifier|const
name|char
operator|*
name|version
operator|,
name|int
name|stream_size
operator|)
argument_list|)
decl_stmt|;
specifier|extern
name|int
name|EXPORT
name|inflateInit2_
name|OF
argument_list|(
operator|(
name|z_streamp
name|strm
operator|,
name|int
name|windowBits
operator|,
specifier|const
name|char
operator|*
name|version
operator|,
name|int
name|stream_size
operator|)
argument_list|)
decl_stmt|;
define|#
directive|define
name|deflateInit
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|)
define|\
value|deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
define|#
directive|define
name|inflateInit
parameter_list|(
name|strm
parameter_list|)
define|\
value|inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
define|#
directive|define
name|deflateInit2
parameter_list|(
name|strm
parameter_list|,
name|level
parameter_list|,
name|method
parameter_list|,
name|windowBits
parameter_list|,
name|memLevel
parameter_list|,
name|strategy
parameter_list|)
define|\
value|deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\ 		      (strategy),           ZLIB_VERSION, sizeof(z_stream))
define|#
directive|define
name|inflateInit2
parameter_list|(
name|strm
parameter_list|,
name|windowBits
parameter_list|)
define|\
value|inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_Z_UTIL_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_DUMMY_DECL
argument_list|)
struct|struct
name|internal_state
block|{
name|int
name|dummy
decl_stmt|;
block|}
struct|;
comment|/* hack for buggy compilers */
endif|#
directive|endif
name|uLongf
modifier|*
name|get_crc_table
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
comment|/* can be used by asm versions of crc32() */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _ZLIB_H */
end_comment

begin_comment
comment|/* --- zlib.h */
end_comment

end_unit

