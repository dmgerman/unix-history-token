begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-   * Copyright (c) 2009 The FreeBSD Foundation   * All rights reserved.   *   * This software was developed by Rui Paulo under sponsorship from the  * FreeBSD Foundation.   *    * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:   * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF   * SUCH DAMAGE.   */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11s Mesh Point (MBSS) support.  *  * Based on March 2009, D3.0 802.11s draft spec.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_action.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_mesh.h>
end_include

begin_function_decl
specifier|static
name|void
name|mesh_rt_flush_invalid
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_select_proto_path
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_select_proto_metric
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_rt_cleanup_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_gatemode_setup
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_gatemode_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_linkchange
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|enum
name|ieee80211_mesh_mlstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_checkid
parameter_list|(
name|void
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint32_t
name|mesh_generateid
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_checkpseq
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_transmit_to_gate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|ieee80211_mesh_route
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_forward
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_input
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_rx_stats
modifier|*
name|rxs
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|ieee80211_rx_stats
modifier|*
name|rxs
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_recv_ctl
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_peer_timeout_setup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_peer_timeout_backoff
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mesh_peer_timeout_cb
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|mesh_peer_timeout_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_verify_meshid
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_verify_meshconf
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mesh_verify_meshpeer
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|uint8_t
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|uint32_t
name|mesh_airtime_calc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Timeout values come from the specification and are in milliseconds.  */
end_comment

begin_expr_stmt
specifier|static
name|SYSCTL_NODE
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|mesh
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IEEE 802.11s parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_gateint
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|gateint
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_gateint
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"mesh gate interval (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_retrytimeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|retrytimeout
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_retrytimeout
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"Retry timeout (msec)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_holdingtimeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|holdingtimeout
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_holdingtimeout
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"Holding state timeout (msec)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_confirmtimeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|confirmtimeout
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_confirmtimeout
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"Confirm state timeout (msec)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_backofftimeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|backofftimeout
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_backofftimeout
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"Backoff timeout (msec). This is to throutles peering forever when "
literal|"not receiving answer or is rejected by a neighbor"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_maxretries
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|maxretries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_maxretries
argument_list|,
literal|0
argument_list|,
literal|"Maximum retries during peer link establishment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_mesh_maxholding
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan_mesh
argument_list|,
name|OID_AUTO
argument_list|,
name|maxholding
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_mesh_maxholding
argument_list|,
literal|0
argument_list|,
literal|"Maximum times we are allowed to transition to HOLDING state before "
literal|"backinoff during peer link establishment"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|broadcastaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|mesh_recv_action_meshpeering_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|mesh_recv_action_meshpeering_confirm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|mesh_recv_action_meshpeering_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|mesh_recv_action_meshlmetric
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|mesh_recv_action_meshgate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|mesh_send_action_meshpeering_open
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|mesh_send_action_meshpeering_confirm
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|mesh_send_action_meshpeering_close
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|mesh_send_action_meshlmetric
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|mesh_send_action_meshgate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_mesh_proto_metric
name|mesh_metric_airtime
init|=
block|{
operator|.
name|mpm_descr
operator|=
literal|"AIRTIME"
block|,
operator|.
name|mpm_ie
operator|=
name|IEEE80211_MESHCONF_METRIC_AIRTIME
block|,
operator|.
name|mpm_metric
operator|=
name|mesh_airtime_calc
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ieee80211_mesh_proto_path
name|mesh_proto_paths
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ieee80211_mesh_proto_metric
name|mesh_proto_metrics
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_MESH_PREQ
argument_list|,
literal|"80211preq"
argument_list|,
literal|"802.11 MESH Path Request frame"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_MESH_PREP
argument_list|,
literal|"80211prep"
argument_list|,
literal|"802.11 MESH Path Reply frame"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_MESH_PERR
argument_list|,
literal|"80211perr"
argument_list|,
literal|"802.11 MESH Path Error frame"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* The longer one of the lifetime should be stored as new lifetime */
end_comment

begin_define
define|#
directive|define
name|MESH_ROUTE_LIFETIME_MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a> b ? a : b)
end_define

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_MESH_RT
argument_list|,
literal|"80211mesh_rt"
argument_list|,
literal|"802.11s routing table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_MESH_GT_RT
argument_list|,
literal|"80211mesh_gt"
argument_list|,
literal|"802.11s known gates table"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Helper functions to manipulate the Mesh routing table.  */
end_comment

begin_function
specifier|static
name|struct
name|ieee80211_mesh_route
modifier|*
name|mesh_rt_find_locked
parameter_list|(
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|MESH_RT_LOCK_ASSERT
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|dest
argument_list|,
name|rt
operator|->
name|rt_dest
argument_list|)
condition|)
return|return
name|rt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_mesh_route
modifier|*
name|mesh_rt_add_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|KASSERT
argument_list|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|broadcastaddr
argument_list|,
name|dest
argument_list|)
argument_list|,
operator|(
literal|"%s: adding broadcast to the routing table"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MESH_RT_LOCK_ASSERT
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|rt
operator|=
name|IEEE80211_MALLOC
argument_list|(
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_mesh_route
argument_list|)
argument_list|)
operator|+
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_privlen
argument_list|,
name|M_80211_MESH_RT
argument_list|,
name|IEEE80211_M_NOWAIT
operator||
name|IEEE80211_M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|rt
operator|->
name|rt_vap
operator|=
name|vap
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rt
operator|->
name|rt_dest
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_priv
operator|=
operator|(
name|void
operator|*
operator|)
name|ALIGN
argument_list|(
operator|&
name|rt
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MESH_RT_ENTRY_LOCK_INIT
argument_list|(
name|rt
argument_list|,
literal|"MBSS_RT"
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|rt
operator|->
name|rt_discovery
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_updtime
operator|=
name|ticks
expr_stmt|;
comment|/* create time */
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ms
operator|->
name|ms_routes
argument_list|,
name|rt
argument_list|,
name|rt_next
argument_list|)
expr_stmt|;
block|}
return|return
name|rt
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_mesh_route
modifier|*
name|ieee80211_mesh_rt_find
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|rt
operator|=
name|mesh_rt_find_locked
argument_list|(
name|ms
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_mesh_route
modifier|*
name|ieee80211_mesh_rt_add
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|KASSERT
argument_list|(
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|dest
argument_list|)
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: duplicate entry in the routing table"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|dest
argument_list|)
argument_list|,
operator|(
literal|"%s: adding self to the routing table"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|rt
operator|=
name|mesh_rt_add_locked
argument_list|(
name|vap
argument_list|,
name|dest
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|rt
return|;
block|}
end_function

begin_comment
comment|/*  * Update the route lifetime and returns the updated lifetime.  * If new_lifetime is zero and route is timedout it will be invalidated.  * new_lifetime is in msec  */
end_comment

begin_function
name|int
name|ieee80211_mesh_rt_update
parameter_list|(
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
parameter_list|,
name|int
name|new_lifetime
parameter_list|)
block|{
name|int
name|timesince
decl_stmt|,
name|now
decl_stmt|;
name|uint32_t
name|lifetime
init|=
literal|0
decl_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"route is NULL"
operator|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|ticks
expr_stmt|;
name|MESH_RT_ENTRY_LOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
comment|/* dont clobber a proxy entry gated by us */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
operator|&&
name|rt
operator|->
name|rt_nhops
operator|==
literal|0
condition|)
block|{
name|MESH_RT_ENTRY_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
name|rt
operator|->
name|rt_lifetime
return|;
block|}
name|timesince
operator|=
name|ticks_to_msecs
argument_list|(
name|now
operator|-
name|rt
operator|->
name|rt_updtime
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_updtime
operator|=
name|now
expr_stmt|;
if|if
condition|(
name|timesince
operator|>=
name|rt
operator|->
name|rt_lifetime
condition|)
block|{
if|if
condition|(
name|new_lifetime
operator|!=
literal|0
condition|)
block|{
name|rt
operator|->
name|rt_lifetime
operator|=
name|new_lifetime
expr_stmt|;
block|}
else|else
block|{
name|rt
operator|->
name|rt_flags
operator|&=
operator|~
name|IEEE80211_MESHRT_FLAGS_VALID
expr_stmt|;
name|rt
operator|->
name|rt_lifetime
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* update what is left of lifetime */
name|rt
operator|->
name|rt_lifetime
operator|=
name|rt
operator|->
name|rt_lifetime
operator|-
name|timesince
expr_stmt|;
name|rt
operator|->
name|rt_lifetime
operator|=
name|MESH_ROUTE_LIFETIME_MAX
argument_list|(
name|new_lifetime
argument_list|,
name|rt
operator|->
name|rt_lifetime
argument_list|)
expr_stmt|;
block|}
name|lifetime
operator|=
name|rt
operator|->
name|rt_lifetime
expr_stmt|;
name|MESH_RT_ENTRY_UNLOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
return|return
name|lifetime
return|;
block|}
end_function

begin_comment
comment|/*  * Add a proxy route (as needed) for the specified destination.  */
end_comment

begin_function
name|void
name|ieee80211_mesh_proxy_check
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|rt
operator|=
name|mesh_rt_find_locked
argument_list|(
name|ms
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|rt
operator|=
name|mesh_rt_add_locked
argument_list|(
name|vap
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|dest
argument_list|,
literal|"%s"
argument_list|,
literal|"unable to add proxy entry"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_rtaddfailed
operator|++
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|dest
argument_list|,
literal|"%s"
argument_list|,
literal|"add proxy entry"
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rt
operator|->
name|rt_mesh_gate
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rt
operator|->
name|rt_nexthop
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator||=
name|IEEE80211_MESHRT_FLAGS_VALID
operator||
name|IEEE80211_MESHRT_FLAGS_PROXY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
argument_list|,
operator|(
literal|"no proxy flag for poxy entry"
operator|)
argument_list|)
expr_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
comment|/* 		 * Fix existing entry created by received frames from 		 * stations that have some memory of dest.  We also 		 * flush any frames held on the staging queue; delivering 		 * them is too much trouble right now. 		 */
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|dest
argument_list|,
literal|"%s"
argument_list|,
literal|"fix proxy entry"
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rt
operator|->
name|rt_nexthop
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_flags
operator||=
name|IEEE80211_MESHRT_FLAGS_VALID
operator||
name|IEEE80211_MESHRT_FLAGS_PROXY
expr_stmt|;
comment|/* XXX belongs in hwmp */
name|ieee80211_ageq_drain_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ieee80211_mac_hash
argument_list|(
name|ic
argument_list|,
name|dest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX stat? */
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mesh_rt_del
parameter_list|(
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
parameter_list|,
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ms
operator|->
name|ms_routes
argument_list|,
name|rt
argument_list|,
name|rt_next
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the lock before destroying it, to be sure no one else 	 * is holding the route. 	 */
name|MESH_RT_ENTRY_LOCK
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|rt
operator|->
name|rt_discovery
argument_list|)
expr_stmt|;
name|MESH_RT_ENTRY_LOCK_DESTROY
argument_list|(
name|rt
argument_list|)
expr_stmt|;
name|IEEE80211_FREE
argument_list|(
name|rt
argument_list|,
name|M_80211_MESH_RT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_mesh_rt_del
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|rt
operator|->
name|rt_dest
argument_list|,
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
condition|)
block|{
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_senderror
argument_list|(
name|vap
argument_list|,
name|dest
argument_list|,
name|rt
argument_list|,
name|IEEE80211_REASON_MESH_PERR_NO_PROXY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_senderror
argument_list|(
name|vap
argument_list|,
name|dest
argument_list|,
name|rt
argument_list|,
name|IEEE80211_REASON_MESH_PERR_DEST_UNREACH
argument_list|)
expr_stmt|;
block|}
name|mesh_rt_del
argument_list|(
name|ms
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_mesh_rt_flush
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
return|return;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|,
argument|next
argument_list|)
name|mesh_rt_del
argument_list|(
name|ms
argument_list|,
name|rt
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_mesh_rt_flush_peer
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|peer
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|rt
operator|->
name|rt_nexthop
argument_list|,
name|peer
argument_list|)
condition|)
name|mesh_rt_del
argument_list|(
name|ms
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush expired routing entries, i.e. those in invalid state for  * some time.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_rt_flush_invalid
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
return|return;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|,
argument|next
argument_list|)
block|{
comment|/* Discover paths will be deleted by their own callout */
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_DISCOVER
condition|)
continue|continue;
name|ieee80211_mesh_rt_update
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
operator|)
operator|==
literal|0
condition|)
name|mesh_rt_del
argument_list|(
name|ms
argument_list|,
name|rt
argument_list|)
expr_stmt|;
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieee80211_mesh_register_proto_path
parameter_list|(
specifier|const
name|struct
name|ieee80211_mesh_proto_path
modifier|*
name|mpp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|firstempty
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mesh_proto_paths
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|mpp
operator|->
name|mpp_descr
argument_list|,
name|mesh_proto_paths
index|[
name|i
index|]
operator|.
name|mpp_descr
argument_list|,
name|IEEE80211_MESH_PROTO_DSZ
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EEXIST
return|;
if|if
condition|(
operator|!
name|mesh_proto_paths
index|[
name|i
index|]
operator|.
name|mpp_active
operator|&&
name|firstempty
operator|==
operator|-
literal|1
condition|)
name|firstempty
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|firstempty
operator|<
literal|0
condition|)
return|return
name|ENOSPC
return|;
name|memcpy
argument_list|(
operator|&
name|mesh_proto_paths
index|[
name|firstempty
index|]
argument_list|,
name|mpp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpp
argument_list|)
argument_list|)
expr_stmt|;
name|mesh_proto_paths
index|[
name|firstempty
index|]
operator|.
name|mpp_active
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_mesh_register_proto_metric
parameter_list|(
specifier|const
name|struct
name|ieee80211_mesh_proto_metric
modifier|*
name|mpm
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|firstempty
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mesh_proto_metrics
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|mpm
operator|->
name|mpm_descr
argument_list|,
name|mesh_proto_metrics
index|[
name|i
index|]
operator|.
name|mpm_descr
argument_list|,
name|IEEE80211_MESH_PROTO_DSZ
argument_list|)
operator|==
literal|0
condition|)
return|return
name|EEXIST
return|;
if|if
condition|(
operator|!
name|mesh_proto_metrics
index|[
name|i
index|]
operator|.
name|mpm_active
operator|&&
name|firstempty
operator|==
operator|-
literal|1
condition|)
name|firstempty
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|firstempty
operator|<
literal|0
condition|)
return|return
name|ENOSPC
return|;
name|memcpy
argument_list|(
operator|&
name|mesh_proto_metrics
index|[
name|firstempty
index|]
argument_list|,
name|mpm
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mpm
argument_list|)
argument_list|)
expr_stmt|;
name|mesh_proto_metrics
index|[
name|firstempty
index|]
operator|.
name|mpm_active
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_select_proto_path
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mesh_proto_paths
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|mesh_proto_paths
index|[
name|i
index|]
operator|.
name|mpp_descr
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ms
operator|->
name|ms_ppath
operator|=
operator|&
name|mesh_proto_paths
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_select_proto_metric
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|mesh_proto_metrics
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|mesh_proto_metrics
index|[
name|i
index|]
operator|.
name|mpm_descr
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ms
operator|->
name|ms_pmetric
operator|=
operator|&
name|mesh_proto_metrics
index|[
name|i
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
return|return
name|ENOENT
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_gatemode_setup
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
comment|/* 	 * NB: When a mesh gate is running as a ROOT it shall 	 * not send out periodic GANNs but instead mark the 	 * mesh gate flag for the corresponding proactive PREQ 	 * and RANN frames. 	 */
if|if
condition|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_ROOT
operator|||
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_GATE
operator|)
operator|==
literal|0
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|ms
operator|->
name|ms_gatetimer
argument_list|)
expr_stmt|;
return|return ;
block|}
name|callout_reset
argument_list|(
operator|&
name|ms
operator|->
name|ms_gatetimer
argument_list|,
name|ieee80211_mesh_gateint
argument_list|,
name|mesh_gatemode_cb
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_gatemode_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
operator|(
expr|struct
name|ieee80211vap
operator|*
operator|)
name|arg
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_meshgann_ie
name|gann
decl_stmt|;
name|gann
operator|.
name|gann_flags
operator|=
literal|0
expr_stmt|;
comment|/* Reserved */
name|gann
operator|.
name|gann_hopcount
operator|=
literal|0
expr_stmt|;
name|gann
operator|.
name|gann_ttl
operator|=
name|ms
operator|->
name|ms_ttl
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|gann
operator|.
name|gann_addr
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|gann
operator|.
name|gann_seq
operator|=
name|ms
operator|->
name|ms_gateseq
operator|++
expr_stmt|;
name|gann
operator|.
name|gann_interval
operator|=
name|ieee80211_mesh_gateint
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|,
literal|"send broadcast GANN (seq %u)"
argument_list|,
name|gann
operator|.
name|gann_seq
argument_list|)
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|,
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_GANN
argument_list|,
operator|&
name|gann
argument_list|)
expr_stmt|;
name|mesh_gatemode_setup
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_mesh_init
parameter_list|(
name|void
parameter_list|)
block|{
name|memset
argument_list|(
name|mesh_proto_paths
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mesh_proto_paths
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mesh_proto_metrics
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mesh_proto_metrics
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Setup mesh parameters that depends on the clock frequency. 	 */
name|ieee80211_mesh_gateint
operator|=
name|msecs_to_ticks
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|ieee80211_mesh_retrytimeout
operator|=
name|msecs_to_ticks
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|ieee80211_mesh_holdingtimeout
operator|=
name|msecs_to_ticks
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|ieee80211_mesh_confirmtimeout
operator|=
name|msecs_to_ticks
argument_list|(
literal|40
argument_list|)
expr_stmt|;
name|ieee80211_mesh_backofftimeout
operator|=
name|msecs_to_ticks
argument_list|(
literal|5000
argument_list|)
expr_stmt|;
comment|/* 	 * Register action frame handlers. 	 */
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|,
name|mesh_recv_action_meshpeering_open
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|mesh_recv_action_meshpeering_confirm
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|mesh_recv_action_meshpeering_close
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_LMETRIC
argument_list|,
name|mesh_recv_action_meshlmetric
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_GANN
argument_list|,
name|mesh_recv_action_meshgate
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|,
name|mesh_send_action_meshpeering_open
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|mesh_send_action_meshpeering_confirm
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|mesh_send_action_meshpeering_close
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_LMETRIC
argument_list|,
name|mesh_send_action_meshlmetric
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_GANN
argument_list|,
name|mesh_send_action_meshgate
argument_list|)
expr_stmt|;
comment|/* 	 * Register Airtime Link Metric. 	 */
name|ieee80211_mesh_register_proto_metric
argument_list|(
operator|&
name|mesh_metric_airtime
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_mesh
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_mesh_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_mesh_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_vattach
index|[
name|IEEE80211_M_MBSS
index|]
operator|=
name|mesh_vattach
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_mesh_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|mesh_vdetach_peers
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|args
index|[
literal|3
index|]
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_mlstate
operator|==
name|IEEE80211_NODE_MESH_ESTABLISHED
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
name|callout_drain
argument_list|(
operator|&
name|ni
operator|->
name|ni_mltimer
argument_list|)
expr_stmt|;
comment|/* XXX belongs in hwmp */
name|ieee80211_ageq_drain_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ieee80211_mac_hash
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ms
operator|->
name|ms_cleantimer
argument_list|)
expr_stmt|;
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_sta
argument_list|,
name|mesh_vdetach_peers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ieee80211_mesh_rt_flush
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|MESH_RT_LOCK_DESTROY
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_FREE
argument_list|(
name|vap
operator|->
name|iv_mesh
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_mesh
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
decl_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|mesh_newstate
expr_stmt|;
name|vap
operator|->
name|iv_input
operator|=
name|mesh_input
expr_stmt|;
name|vap
operator|->
name|iv_opdetach
operator|=
name|mesh_vdetach
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|mesh_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_ctl
operator|=
name|mesh_recv_ctl
expr_stmt|;
name|ms
operator|=
name|IEEE80211_MALLOC
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_mesh_state
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|IEEE80211_M_NOWAIT
operator||
name|IEEE80211_M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: couldn't alloc MBSS state\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|vap
operator|->
name|iv_mesh
operator|=
name|ms
expr_stmt|;
name|ms
operator|->
name|ms_seq
operator|=
literal|0
expr_stmt|;
name|ms
operator|->
name|ms_flags
operator|=
operator|(
name|IEEE80211_MESHFLAGS_AP
operator||
name|IEEE80211_MESHFLAGS_FWD
operator|)
expr_stmt|;
name|ms
operator|->
name|ms_ttl
operator|=
name|IEEE80211_MESH_DEFAULT_TTL
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ms
operator|->
name|ms_known_gates
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ms
operator|->
name|ms_routes
argument_list|)
expr_stmt|;
name|MESH_RT_LOCK_INIT
argument_list|(
name|ms
argument_list|,
literal|"MBSS"
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ms
operator|->
name|ms_cleantimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ms
operator|->
name|ms_gatetimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_gateseq
operator|=
literal|0
expr_stmt|;
name|mesh_select_proto_metric
argument_list|(
name|vap
argument_list|,
literal|"AIRTIME"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ms
operator|->
name|ms_pmetric
argument_list|,
operator|(
literal|"ms_pmetric == NULL"
operator|)
argument_list|)
expr_stmt|;
name|mesh_select_proto_path
argument_list|(
name|vap
argument_list|,
literal|"HWMP"
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ms
operator|->
name|ms_ppath
argument_list|,
operator|(
literal|"ms_ppath == NULL"
operator|)
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * IEEE80211_M_MBSS vap state machine handler.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ostate
operator|=
name|vap
operator|->
name|iv_state
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_state
operator|=
name|nstate
expr_stmt|;
comment|/* state transition */
if|if
condition|(
name|ostate
operator|!=
name|IEEE80211_S_SCAN
condition|)
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* background scan */
name|ni
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
comment|/* NB: no reference held */
if|if
condition|(
name|nstate
operator|!=
name|IEEE80211_S_RUN
operator|&&
name|ostate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
name|callout_drain
argument_list|(
operator|&
name|ms
operator|->
name|ms_cleantimer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ms
operator|->
name|ms_gatetimer
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_SCAN
case|:
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_CAC
case|:
name|ieee80211_dfs_cac_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|mesh_vdetach_peers
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|ostate
operator|!=
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* NB: optimize INIT -> INIT case */
name|ieee80211_reset_bss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_mesh_rt_flush
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
if|if
condition|(
name|vap
operator|->
name|iv_des_chan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
operator|!
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|vap
operator|->
name|iv_des_chan
argument_list|)
operator|&&
name|ms
operator|->
name|ms_idlen
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Already have a channel and a mesh ID; bypass 				 * the scan and startup immediately. 				 */
name|ieee80211_create_ibss
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_des_chan
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Initiate a scan.  We can come here as a result 			 * of an IEEE80211_IOC_SCAN_REQ too in which case 			 * the vap will be marked with IEEE80211_FEXT_SCANREQ 			 * and the scan request parameters will be present 			 * in iv_scanreq.  Otherwise we do the default. 			*/
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SCANREQ
condition|)
block|{
name|ieee80211_check_scan
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_scanreq_flags
argument_list|,
name|vap
operator|->
name|iv_scanreq_duration
argument_list|,
name|vap
operator|->
name|iv_scanreq_mindwell
argument_list|,
name|vap
operator|->
name|iv_scanreq_maxdwell
argument_list|,
name|vap
operator|->
name|iv_scanreq_nssid
argument_list|,
name|vap
operator|->
name|iv_scanreq_ssid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_SCANREQ
expr_stmt|;
block|}
else|else
name|ieee80211_check_scan_current
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_CAC
case|:
comment|/* 		 * Start CAC on a DFS channel.  We come here when starting 		 * a bss on a DFS channel (see ieee80211_create_ibss). 		 */
name|ieee80211_dfs_cac_start
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
comment|/* 			 * Already have a channel; bypass the 			 * scan and startup immediately. 			 * Note that ieee80211_create_ibss will call 			 * back to do a RUN->RUN state change. 			 */
name|ieee80211_create_ibss
argument_list|(
name|vap
argument_list|,
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|vap
operator|->
name|iv_flags_ht
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NB: iv_bss is changed on return */
break|break;
case|case
name|IEEE80211_S_CAC
case|:
comment|/* 			 * NB: This is the normal state change when CAC 			 * expires and no radar was detected; no need to 			 * clear the CAC timer as it's already expired. 			 */
comment|/* fall thru... */
case|case
name|IEEE80211_S_CSA
case|:
if|#
directive|if
literal|0
comment|/* 			 * Shorten inactivity timer of associated stations 			 * to weed out sta's that don't follow a CSA. 			 */
block|ieee80211_iterate_nodes(&ic->ic_sta, sta_csa, vap);
endif|#
directive|endif
comment|/* 			 * Update bss node channel to reflect where 			 * we landed after CSA. 			 */
name|ieee80211_node_set_chan
argument_list|(
name|ni
argument_list|,
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|ieee80211_htchanflags
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX bypass debug msgs */
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
case|case
name|IEEE80211_S_RUN
case|:
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_debug
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|ieee80211_note
argument_list|(
name|vap
argument_list|,
literal|"synchronized with %s meshid "
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_meshid
argument_list|)
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|ni
operator|->
name|ni_meshid
argument_list|,
name|ni
operator|->
name|ni_meshidlen
argument_list|)
expr_stmt|;
comment|/* XXX MCS/HT */
name|printf
argument_list|(
literal|" channel %d\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
default|default:
break|break;
block|}
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ms
operator|->
name|ms_cleantimer
argument_list|,
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|,
name|mesh_rt_cleanup_cb
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|mesh_gatemode_setup
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* NB: ostate not nstate */
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_newstate
argument_list|(
name|vap
argument_list|,
name|ostate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_rt_cleanup_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|mesh_rt_flush_invalid
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ms
operator|->
name|ms_cleantimer
argument_list|,
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|,
name|mesh_rt_cleanup_cb
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mark a mesh STA as gate and return a pointer to it.  * If this is first time, we create a new gate route.  * Always update the path route to this mesh gate.  */
end_comment

begin_function
name|struct
name|ieee80211_mesh_gate_route
modifier|*
name|ieee80211_mesh_mark_gate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|addr
parameter_list|,
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_gate_route
modifier|*
name|gr
init|=
name|NULL
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|gr
argument_list|,
argument|&ms->ms_known_gates
argument_list|,
argument|gr_next
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|gr
operator|->
name|gr_addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* New mesh gate add it to known table. */
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|addr
argument_list|,
literal|"%s"
argument_list|,
literal|"stored new gate information from pro-PREQ."
argument_list|)
expr_stmt|;
name|gr
operator|=
name|IEEE80211_MALLOC
argument_list|(
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_mesh_gate_route
argument_list|)
argument_list|)
argument_list|,
name|M_80211_MESH_GT_RT
argument_list|,
name|IEEE80211_M_NOWAIT
operator||
name|IEEE80211_M_ZERO
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|gr
operator|->
name|gr_addr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ms
operator|->
name|ms_known_gates
argument_list|,
name|gr
argument_list|,
name|gr_next
argument_list|)
expr_stmt|;
block|}
name|gr
operator|->
name|gr_route
operator|=
name|rt
expr_stmt|;
comment|/* TODO: link from path route to gate route */
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
name|gr
return|;
block|}
end_function

begin_comment
comment|/*  * Helper function to note the Mesh Peer Link FSM change.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_linkchange
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|enum
name|ieee80211_mesh_mlstate
name|state
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
specifier|static
specifier|const
name|char
modifier|*
name|meshlinkstates
index|[]
init|=
block|{
index|[
name|IEEE80211_NODE_MESH_IDLE
index|]
operator|=
literal|"IDLE"
block|,
index|[
name|IEEE80211_NODE_MESH_OPENSNT
index|]
operator|=
literal|"OPEN SENT"
block|,
index|[
name|IEEE80211_NODE_MESH_OPENRCV
index|]
operator|=
literal|"OPEN RECEIVED"
block|,
index|[
name|IEEE80211_NODE_MESH_CONFIRMRCV
index|]
operator|=
literal|"CONFIRM RECEIVED"
block|,
index|[
name|IEEE80211_NODE_MESH_ESTABLISHED
index|]
operator|=
literal|"ESTABLISHED"
block|,
index|[
name|IEEE80211_NODE_MESH_HOLDING
index|]
operator|=
literal|"HOLDING"
block|}
decl_stmt|;
endif|#
directive|endif
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"peer link: %s -> %s"
argument_list|,
name|meshlinkstates
index|[
name|ni
operator|->
name|ni_mlstate
index|]
argument_list|,
name|meshlinkstates
index|[
name|state
index|]
argument_list|)
expr_stmt|;
comment|/* track neighbor count */
if|if
condition|(
name|state
operator|==
name|IEEE80211_NODE_MESH_ESTABLISHED
operator|&&
name|ni
operator|->
name|ni_mlstate
operator|!=
name|IEEE80211_NODE_MESH_ESTABLISHED
condition|)
block|{
name|KASSERT
argument_list|(
name|ms
operator|->
name|ms_neighbors
operator|<
literal|65535
argument_list|,
operator|(
literal|"neighbor count overflow"
operator|)
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_neighbors
operator|++
expr_stmt|;
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_MESHCONF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_mlstate
operator|==
name|IEEE80211_NODE_MESH_ESTABLISHED
operator|&&
name|state
operator|!=
name|IEEE80211_NODE_MESH_ESTABLISHED
condition|)
block|{
name|KASSERT
argument_list|(
name|ms
operator|->
name|ms_neighbors
operator|>
literal|0
argument_list|,
operator|(
literal|"neighbor count 0"
operator|)
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_neighbors
operator|--
expr_stmt|;
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_MESHCONF
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|ni_mlstate
operator|=
name|state
expr_stmt|;
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_peerdown
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_ESTABLISHED
case|:
name|ieee80211_mesh_discover
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Helper function to generate a unique local ID required for mesh  * peer establishment.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_checkid
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint16_t
modifier|*
name|r
init|=
name|arg
decl_stmt|;
if|if
condition|(
operator|*
name|r
operator|==
name|ni
operator|->
name|ni_mllid
condition|)
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|arg
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|mesh_generateid
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|int
name|maxiter
init|=
literal|4
decl_stmt|;
name|uint16_t
name|r
decl_stmt|;
do|do
block|{
name|get_random_bytes
argument_list|(
operator|&
name|r
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_sta
argument_list|,
name|mesh_checkid
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|maxiter
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|r
operator|==
literal|0
operator|&&
name|maxiter
operator|>
literal|0
condition|)
do|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * Verifies if we already received this packet by checking its  * sequence number.  * Returns 0 if the frame is to be accepted, 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_checkpseq
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|source
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint32_t
name|seq
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|rt
operator|=
name|ieee80211_mesh_rt_add
argument_list|(
name|vap
argument_list|,
name|source
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|source
argument_list|,
literal|"%s"
argument_list|,
literal|"add mcast route failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_rtaddfailed
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|source
argument_list|,
literal|"add mcast route, mesh seqno %d"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
name|rt
operator|->
name|rt_lastmseq
operator|=
name|seq
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|IEEE80211_MESH_SEQ_GEQ
argument_list|(
name|rt
operator|->
name|rt_lastmseq
argument_list|,
name|seq
argument_list|)
condition|)
block|{
return|return
literal|1
return|;
block|}
else|else
block|{
name|rt
operator|->
name|rt_lastmseq
operator|=
name|seq
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Iterate the routing table and locate the next hop.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_mesh_find_txnode
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|dest
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|dest
argument_list|,
literal|"%s: !valid, flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|rt
operator|->
name|rt_flags
argument_list|)
expr_stmt|;
comment|/* XXX stat */
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
condition|)
block|{
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|rt
operator|->
name|rt_mesh_gate
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|dest
argument_list|,
literal|"%s: meshgate !valid, flags 0x%x"
argument_list|,
name|__func__
argument_list|,
name|rt
operator|->
name|rt_flags
argument_list|)
expr_stmt|;
comment|/* XXX stat */
return|return
name|NULL
return|;
block|}
block|}
return|return
name|ieee80211_find_txnode
argument_list|(
name|vap
argument_list|,
name|rt
operator|->
name|rt_nexthop
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_transmit_to_gate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt_gate
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_mesh_find_txnode
argument_list|(
name|vap
argument_list|,
name|rt_gate
operator|->
name|rt_dest
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Send through the VAP packet transmit path. 	 * This consumes the node ref grabbed above and 	 * the mbuf, regardless of whether there's a problem 	 * or not. 	 */
operator|(
name|void
operator|)
name|ieee80211_vap_pkt_send_dest
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Forward the queued frames to known valid mesh gates.  * Assume destination to be outside the MBSS (i.e. proxy entry),  * If no valid mesh gates are known silently discard queued frames.  * After transmitting frames to all known valid mesh gates, this route  * will be marked invalid, and a new path discovery will happen in the hopes  * that (at least) one of the mesh gates have a new proxy entry for us to use.  */
end_comment

begin_function
name|void
name|ieee80211_mesh_forward_to_gates
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt_dest
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt_gate
decl_stmt|;
name|struct
name|ieee80211_mesh_gate_route
modifier|*
name|gr
init|=
name|NULL
decl_stmt|,
modifier|*
name|gr_next
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mcopy
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rt_dest
operator|->
name|rt_flags
operator|==
name|IEEE80211_MESHRT_FLAGS_DISCOVER
argument_list|,
operator|(
literal|"Route is not marked with IEEE80211_MESHRT_FLAGS_DISCOVER"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX: send to more than one valid mash gate */
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_ageq_remove
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|,
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|ieee80211_mac_hash
argument_list|(
name|ic
argument_list|,
name|rt_dest
operator|->
name|rt_dest
argument_list|)
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|gr
argument_list|,
argument|&ms->ms_known_gates
argument_list|,
argument|gr_next
argument_list|,
argument|gr_next
argument_list|)
block|{
name|rt_gate
operator|=
name|gr
operator|->
name|gr_route
expr_stmt|;
if|if
condition|(
name|rt_gate
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_HWMP
argument_list|,
name|rt_dest
operator|->
name|rt_dest
argument_list|,
literal|"mesh gate with no path %6D"
argument_list|,
name|gr
operator|->
name|gr_addr
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|rt_gate
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|KASSERT
argument_list|(
name|rt_gate
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_GATE
argument_list|,
operator|(
literal|"route not marked as a mesh gate"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|rt_gate
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"found mesh gate that is also marked porxy"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * convert route to a proxy route gated by the current 		 * mesh gate, this is needed so encap can built data 		 * frame with correct address. 		 */
name|rt_dest
operator|->
name|rt_flags
operator|=
name|IEEE80211_MESHRT_FLAGS_PROXY
operator||
name|IEEE80211_MESHRT_FLAGS_VALID
expr_stmt|;
name|rt_dest
operator|->
name|rt_ext_seq
operator|=
literal|1
expr_stmt|;
comment|/* random value */
name|IEEE80211_ADDR_COPY
argument_list|(
name|rt_dest
operator|->
name|rt_mesh_gate
argument_list|,
name|rt_gate
operator|->
name|rt_dest
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rt_dest
operator|->
name|rt_nexthop
argument_list|,
name|rt_gate
operator|->
name|rt_nexthop
argument_list|)
expr_stmt|;
name|rt_dest
operator|->
name|rt_metric
operator|=
name|rt_gate
operator|->
name|rt_metric
expr_stmt|;
name|rt_dest
operator|->
name|rt_nhops
operator|=
name|rt_gate
operator|->
name|rt_nhops
expr_stmt|;
name|ieee80211_mesh_rt_update
argument_list|(
name|rt_dest
argument_list|,
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
comment|/* XXX: lock?? */
name|mcopy
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|mcopy
operator|!=
name|NULL
condition|;
name|mcopy
operator|=
name|next
control|)
block|{
name|next
operator|=
name|mcopy
operator|->
name|m_nextpkt
expr_stmt|;
name|mcopy
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_HWMP
argument_list|,
name|rt_dest
operator|->
name|rt_dest
argument_list|,
literal|"flush queued frame %p len %d"
argument_list|,
name|mcopy
argument_list|,
name|mcopy
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|mesh_transmit_to_gate
argument_list|(
name|vap
argument_list|,
name|mcopy
argument_list|,
name|rt_gate
argument_list|)
expr_stmt|;
block|}
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
name|rt_dest
operator|->
name|rt_flags
operator|=
literal|0
expr_stmt|;
comment|/* Mark invalid */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Forward the specified frame.  * Decrement the TTL and set TA to our MAC address.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_forward
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mcopy
decl_stmt|;
name|struct
name|ieee80211_meshcntl
modifier|*
name|mccopy
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|whcopy
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* This is called from the RX path - don't hold this lock */
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * mesh ttl of 1 means we are the last one receiving it, 	 * according to amendment we decrement and then check if 	 * 0, if so we dont forward. 	 */
if|if
condition|(
name|mc
operator|->
name|mc_ttl
operator|<
literal|1
condition|)
block|{
name|IEEE80211_NOTE_FRAME
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
literal|"%s"
argument_list|,
literal|"frame not fwd'd, ttl 1"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_fwd_ttl
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_FWD
operator|)
condition|)
block|{
name|IEEE80211_NOTE_FRAME
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
literal|"%s"
argument_list|,
literal|"frame not fwd'd, fwding disabled"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_fwd_disabled
operator|++
expr_stmt|;
return|return;
block|}
name|mcopy
operator|=
name|m_dup
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcopy
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NOTE_FRAME
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
literal|"%s"
argument_list|,
literal|"frame not fwd'd, cannot dup"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_fwd_nobuf
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|mcopy
operator|=
name|m_pullup
argument_list|(
name|mcopy
argument_list|,
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mcopy
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NOTE_FRAME
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
literal|"%s"
argument_list|,
literal|"frame not fwd'd, too short"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_fwd_tooshort
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
return|return;
block|}
name|whcopy
operator|=
name|mtod
argument_list|(
name|mcopy
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|mccopy
operator|=
operator|(
expr|struct
name|ieee80211_meshcntl
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|mcopy
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
operator|)
expr_stmt|;
comment|/* XXX clear other bits? */
name|whcopy
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_FC1_RETRY
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|whcopy
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|mcopy
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
block|}
else|else
block|{
name|ni
operator|=
name|ieee80211_mesh_find_txnode
argument_list|(
name|vap
argument_list|,
name|whcopy
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * [Optional] any of the following three actions: 			 * o silently discard 			 * o trigger a path discovery 			 * o inform TA that meshDA is unknown. 			 */
name|IEEE80211_NOTE_FRAME
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
literal|"%s"
argument_list|,
literal|"frame not fwd'd, no path"
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_senderror
argument_list|(
name|vap
argument_list|,
name|whcopy
operator|->
name|i_addr3
argument_list|,
name|NULL
argument_list|,
name|IEEE80211_REASON_MESH_PERR_NO_FI
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_fwd_nopath
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|mcopy
argument_list|)
expr_stmt|;
return|return;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|whcopy
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
name|KASSERT
argument_list|(
name|mccopy
operator|->
name|mc_ttl
operator|>
literal|0
argument_list|,
operator|(
literal|"%s called with wrong ttl"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|mccopy
operator|->
name|mc_ttl
operator|--
expr_stmt|;
comment|/* XXX calculate priority so drivers can find the tx queue */
name|M_WME_SETAC
argument_list|(
name|mcopy
argument_list|,
name|WME_AC_BE
argument_list|)
expr_stmt|;
comment|/* XXX do we know m_nextpkt is NULL? */
name|mcopy
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
comment|/* 	 * XXX this bypasses all of the VAP TX handling; it passes frames 	 * directly to the parent interface. 	 * 	 * Because of this, there's no TX lock being held as there's no 	 * encaps state being used. 	 * 	 * Doing a direct parent transmit may not be the correct thing 	 * to do here; we'll have to re-think this soon. 	 */
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|err
operator|=
name|ieee80211_parent_xmitpkt
argument_list|(
name|ic
argument_list|,
name|mcopy
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|mesh_decap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hdrlen
parameter_list|,
name|int
name|meshdrlen
parameter_list|)
block|{
define|#
directive|define
name|WHDIR
parameter_list|(
name|wh
parameter_list|)
value|((wh)->i_fc[1]& IEEE80211_FC1_DIR_MASK)
define|#
directive|define
name|MC01
parameter_list|(
name|mc
parameter_list|)
value|((const struct ieee80211_meshcntl_ae01 *)mc)
name|uint8_t
name|b
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe_addr4
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl_ae10
argument_list|)
index|]
decl_stmt|;
specifier|const
name|struct
name|ieee80211_qosframe_addr4
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshcntl_ae10
modifier|*
name|mc
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|int
name|ae
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hdrlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|llc
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hdrlen
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|llc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"discard data frame: %s"
argument_list|,
literal|"m_pullup failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
name|b
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|wh
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
operator|&
name|b
index|[
literal|0
index|]
expr_stmt|;
name|mc
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshcntl_ae10
operator|*
operator|)
operator|&
name|b
index|[
name|hdrlen
operator|-
name|meshdrlen
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|WHDIR
argument_list|(
name|wh
argument_list|)
operator|==
name|IEEE80211_FC1_DIR_FROMDS
operator|||
name|WHDIR
argument_list|(
name|wh
argument_list|)
operator|==
name|IEEE80211_FC1_DIR_DSTODS
argument_list|,
operator|(
literal|"bogus dir, fc 0x%x:0x%x"
operator|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|llc
operator|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
name|hdrlen
operator|)
expr_stmt|;
if|if
condition|(
name|llc
operator|->
name|llc_dsap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc
operator|->
name|llc_ssap
operator|==
name|LLC_SNAP_LSAP
operator|&&
name|llc
operator|->
name|llc_control
operator|==
name|LLC_UI
operator|&&
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|==
literal|0
operator|&&
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|==
literal|0
operator|&&
comment|/* NB: preserve AppleTalk frames that have a native SNAP hdr */
operator|!
operator|(
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_AARP
argument_list|)
operator|||
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPX
argument_list|)
operator|)
condition|)
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|m_adj
argument_list|(
name|m
argument_list|,
name|hdrlen
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|ae
operator|=
name|mc
operator|->
name|mc_flags
operator|&
name|IEEE80211_MESH_AE_MASK
expr_stmt|;
if|if
condition|(
name|WHDIR
argument_list|(
name|wh
argument_list|)
operator|==
name|IEEE80211_FC1_DIR_FROMDS
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_00
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_01
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|MC01
argument_list|(
name|mc
argument_list|)
operator|->
name|mc_addr4
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame
operator|*
operator|)
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"bad AE %d"
argument_list|,
name|ae
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_badae
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_00
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|wh
operator|->
name|i_addr4
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_10
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|,
name|mc
operator|->
name|mc_addr5
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|mc
operator|->
name|mc_addr6
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_frame
operator|*
operator|)
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"bad AE %d"
argument_list|,
name|ae
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_badae
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
ifndef|#
directive|ifndef
name|__NO_STRICT_ALIGNMENT
if|if
condition|(
operator|!
name|ALIGNED_POINTER
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|,
name|uint32_t
argument_list|)
condition|)
block|{
name|m
operator|=
name|ieee80211_realign
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
endif|#
directive|endif
comment|/* !__NO_STRICT_ALIGNMENT */
if|if
condition|(
name|llc
operator|!=
name|NULL
condition|)
block|{
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
name|eh
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
undef|#
directive|undef
name|WDIR
undef|#
directive|undef
name|MC01
block|}
end_function

begin_comment
comment|/*  * Return non-zero if the unicast mesh data frame should be processed  * locally.  Frames that are not proxy'd have our address, otherwise  * we need to consult the routing table to look for a proxy entry.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|mesh_isucastforme
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
name|mc
parameter_list|)
block|{
name|int
name|ae
init|=
name|mc
operator|->
name|mc_flags
operator|&
literal|3
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
operator|)
operator|==
name|IEEE80211_FC1_DIR_DSTODS
argument_list|,
operator|(
literal|"bad dir 0x%x:0x%x"
operator|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ae
operator|==
name|IEEE80211_MESH_AE_00
operator|||
name|ae
operator|==
name|IEEE80211_MESH_AE_10
argument_list|,
operator|(
literal|"bad AE %d"
operator|,
name|ae
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_10
condition|)
block|{
comment|/* ucast w/ proxy */
specifier|const
name|struct
name|ieee80211_meshcntl_ae10
modifier|*
name|mc10
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshcntl_ae10
operator|*
operator|)
name|mc
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
init|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|mc10
operator|->
name|mc_addr5
argument_list|)
decl_stmt|;
comment|/* check for proxy route to ourself */
return|return
operator|(
name|rt
operator|!=
name|NULL
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
operator|)
operator|)
return|;
block|}
else|else
comment|/* ucast w/o proxy */
return|return
name|IEEE80211_ADDR_EQ
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verifies transmitter, updates lifetime, precursor list and forwards data.  *> 0 means we have forwarded data and no need to process locally  * == 0 means we want to process locally (and we may have forwarded data  *< 0 means there was an error and data should be discarded  */
end_comment

begin_function
specifier|static
name|int
name|mesh_recv_indiv_data_to_fwrd
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|ieee80211_qosframe_addr4
modifier|*
name|qwh
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt_meshda
decl_stmt|,
modifier|*
name|rt_meshsa
decl_stmt|;
comment|/* This is called from the RX path - don't hold this lock */
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|qwh
operator|=
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
expr_stmt|;
comment|/* 	 * TODO: 	 * o verify addr2 is  a legitimate transmitter 	 * o lifetime of precursor of addr3 (addr2) is max(init, curr) 	 * o lifetime of precursor of addr4 (nexthop) is max(init, curr) 	 */
comment|/* set lifetime of addr3 (meshDA) to initial value */
name|rt_meshda
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|qwh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_meshda
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|qwh
operator|->
name|i_addr2
argument_list|,
literal|"no route to meshDA(%6D)"
argument_list|,
name|qwh
operator|->
name|i_addr3
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
comment|/* 		 * [Optional] any of the following three actions: 		 * o silently discard 				[X] 		 * o trigger a path discovery			[ ] 		 * o inform TA that meshDA is unknown.		[ ] 		 */
comment|/* XXX: stats */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ieee80211_mesh_rt_update
argument_list|(
name|rt_meshda
argument_list|,
name|ticks_to_msecs
argument_list|(
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set lifetime of addr4 (meshSA) to initial value */
name|rt_meshsa
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|qwh
operator|->
name|i_addr4
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rt_meshsa
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no route"
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_mesh_rt_update
argument_list|(
name|rt_meshsa
argument_list|,
name|ticks_to_msecs
argument_list|(
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|)
argument_list|)
expr_stmt|;
name|mesh_forward
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|mc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* dont process locally */
block|}
end_function

begin_comment
comment|/*  * Verifies transmitter, updates lifetime, precursor list and process data  * locally, if data is proxy with AE = 10 it could mean data should go  * on another mesh path or data should be forwarded to the DS.  *  *> 0 means we have forwarded data and no need to process locally  * == 0 means we want to process locally (and we may have forwarded data  *< 0 means there was an error and data should be discarded  */
end_comment

begin_function
specifier|static
name|int
name|mesh_recv_indiv_data_to_me
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
name|mc
parameter_list|)
block|{
name|struct
name|ieee80211_qosframe_addr4
modifier|*
name|qwh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshcntl_ae10
modifier|*
name|mc10
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|int
name|ae
decl_stmt|;
comment|/* This is called from the RX path - don't hold this lock */
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|qwh
operator|=
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
expr_stmt|;
name|mc10
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshcntl_ae10
operator|*
operator|)
name|mc
expr_stmt|;
comment|/* 	 * TODO: 	 * o verify addr2 is  a legitimate transmitter 	 * o lifetime of precursor entry is max(init, curr) 	 */
comment|/* set lifetime of addr4 (meshSA) to initial value */
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|qwh
operator|->
name|i_addr4
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no route"
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_mesh_rt_update
argument_list|(
name|rt
argument_list|,
name|ticks_to_msecs
argument_list|(
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|)
argument_list|)
expr_stmt|;
name|rt
operator|=
name|NULL
expr_stmt|;
name|ae
operator|=
name|mc10
operator|->
name|mc_flags
operator|&
name|IEEE80211_MESH_AE_MASK
expr_stmt|;
name|KASSERT
argument_list|(
name|ae
operator|==
name|IEEE80211_MESH_AE_00
operator|||
name|ae
operator|==
name|IEEE80211_MESH_AE_10
argument_list|,
operator|(
literal|"bad AE %d"
operator|,
name|ae
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_10
condition|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|mc10
operator|->
name|mc_addr5
argument_list|,
name|qwh
operator|->
name|i_addr3
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
comment|/* process locally */
block|}
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|mc10
operator|->
name|mc_addr5
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
operator|)
operator|&&
operator|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Forward on another mesh-path, according to 			 * amendment as specified in 9.32.4.1 			 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|qwh
operator|->
name|i_addr3
argument_list|,
name|mc10
operator|->
name|mc_addr5
argument_list|)
expr_stmt|;
name|mesh_forward
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_meshcntl
operator|*
operator|)
name|mc10
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
comment|/* dont process locally */
block|}
comment|/* 		 * All other cases: forward of MSDUs from the MBSS to DS indiv. 		 * addressed according to 13.11.3.2. 		 */
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|qwh
operator|->
name|i_addr2
argument_list|,
literal|"forward frame to DS, SA(%6D) DA(%6D)"
argument_list|,
name|mc10
operator|->
name|mc_addr6
argument_list|,
literal|":"
argument_list|,
name|mc10
operator|->
name|mc_addr5
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* process locally */
block|}
end_function

begin_comment
comment|/*  * Try to forward the group addressed data on to other mesh STAs, and  * also to the DS.  *  *> 0 means we have forwarded data and no need to process locally  * == 0 means we want to process locally (and we may have forwarded data  *< 0 means there was an error and data should be discarded  */
end_comment

begin_function
specifier|static
name|int
name|mesh_recv_group_data
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
name|mc
parameter_list|)
block|{
define|#
directive|define
name|MC01
parameter_list|(
name|mc
parameter_list|)
value|((const struct ieee80211_meshcntl_ae01 *)mc)
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
comment|/* This is called from the RX path - don't hold this lock */
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|mesh_forward
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|mc
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_ttl
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|mc
operator|->
name|mc_flags
operator|&
name|IEEE80211_MESH_AE_01
condition|)
block|{
comment|/* 			 * Forward of MSDUs from the MBSS to DS group addressed 			 * (according to 13.11.3.2) 			 * This happens by delivering the packet, and a bridge 			 * will sent it on another port member. 			 */
if|if
condition|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_GATE
operator|&&
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_FWD
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|MC01
argument_list|(
name|mc
argument_list|)
operator|->
name|mc_addr4
argument_list|,
literal|"%s"
argument_list|,
literal|"forward from MBSS to the DS"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* process locally */
undef|#
directive|undef
name|MC01
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_input
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_rx_stats
modifier|*
name|rxs
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
define|#
directive|define
name|HAS_SEQ
parameter_list|(
name|type
parameter_list|)
value|((type& 0x4) == 0)
define|#
directive|define
name|MC01
parameter_list|(
name|mc
parameter_list|)
value|((const struct ieee80211_meshcntl_ae01 *)mc)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshcntl
modifier|*
name|mc
decl_stmt|;
name|int
name|hdrspace
decl_stmt|,
name|meshdrlen
decl_stmt|,
name|need_tap
decl_stmt|,
name|error
decl_stmt|;
name|uint8_t
name|dir
decl_stmt|,
name|type
decl_stmt|,
name|subtype
decl_stmt|,
name|ae
decl_stmt|;
name|uint32_t
name|seq
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|addr
decl_stmt|;
name|uint8_t
name|qos
index|[
literal|2
index|]
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|need_tap
operator|=
literal|1
expr_stmt|;
comment|/* mbuf need to be tapped. */
name|type
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* undefined */
comment|/* This is called from the RX path - don't hold this lock */
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_min
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"too short (1): len %u"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Bit of a cheat here, we use a pointer for a 3-address 	 * frame format but don't reference fields past outside 	 * ieee80211_frame_min w/o first validating the data is 	 * present. 	*/
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"wrong version %x"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_badversion
operator|++
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|dir
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
expr_stmt|;
name|type
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
expr_stmt|;
name|subtype
operator|=
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_RSSI_LPF
argument_list|(
name|ni
operator|->
name|ni_avgrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_noise
operator|=
name|nf
expr_stmt|;
if|if
condition|(
name|HAS_SEQ
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|uint8_t
name|tid
init|=
name|ieee80211_gettid
argument_list|(
name|wh
argument_list|)
decl_stmt|;
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
operator|&&
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
operator|>=
name|WME_AC_VI
condition|)
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_traffic
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_check_rxseq
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|,
name|rxs
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
comment|/* 	 * It's easier, but too expensive, to simulate different mesh 	 * topologies by consulting the ACL policy very early, so do this 	 * only under DEBUG. 	 * 	 * NB: this check is also done upon peering link initiation. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_acl
operator|!=
name|NULL
operator|&&
operator|!
name|vap
operator|->
name|iv_acl
operator|->
name|iac_check
argument_list|(
name|vap
argument_list|,
name|wh
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACL
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"disallowed by ACL"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_acl
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ni
operator|->
name|ni_mlstate
operator|!=
name|IEEE80211_NODE_MESH_ESTABLISHED
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"peer link not yet established (%d)"
argument_list|,
name|ni
operator|->
name|ni_mlstate
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_nolink
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|dir
operator|!=
name|IEEE80211_FC1_DIR_FROMDS
operator|&&
name|dir
operator|!=
name|IEEE80211_FC1_DIR_DSTODS
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
literal|"data"
argument_list|,
literal|"incorrect dir 0x%x"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_wrongdir
operator|++
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* All Mesh data frames are QoS subtype */
if|if
condition|(
operator|!
name|HAS_SEQ
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
literal|"data"
argument_list|,
literal|"incorrect subtype 0x%x"
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_badsubtype
operator|++
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* 		 * Next up, any fragmentation. 		 * XXX: we defrag before we even try to forward, 		 * Mesh Control field is not present in sub-sequent 		 * fragmented frames. This is in contrast to Draft 4.0. 		 */
name|hdrspace
operator|=
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|m
operator|=
name|ieee80211_defrag
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|hdrspace
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* Fragment dropped or frame not complete yet */
goto|goto
name|out
goto|;
block|}
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: after defrag */
comment|/* 		 * Now we have a complete Mesh Data frame. 		 */
comment|/* 		 * Only fromDStoDS data frames use 4 address qos frames 		 * as specified in amendment. Otherwise addr4 is located 		 * in the Mesh Control field and a 3 address qos frame 		 * is used. 		 */
if|if
condition|(
name|IEEE80211_IS_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|qos
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
else|else
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|qos
operator|=
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
comment|/* 		 * NB: The mesh STA sets the Mesh Control Present 		 * subfield to 1 in the Mesh Data frame containing 		 * an unfragmented MSDU, an A-MSDU, or the first 		 * fragment of an MSDU. 		 * After defrag it should always be present. 		 */
if|if
condition|(
operator|!
operator|(
name|qos
index|[
literal|1
index|]
operator|&
name|IEEE80211_QOS_MC
operator|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"Mesh control field not present"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_elem_missing
operator|++
expr_stmt|;
comment|/* XXX: kinda */
goto|goto
name|err
goto|;
block|}
comment|/* pull up enough to get to the mesh control */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hdrspace
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hdrspace
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"data too short: expecting %u"
argument_list|,
name|hdrspace
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* XXX */
block|}
comment|/* 		 * Now calculate the full extent of the headers. Note 		 * mesh_decap will pull up anything we didn't get 		 * above when it strips the 802.11 headers. 		 */
name|mc
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshcntl
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrspace
operator|)
expr_stmt|;
name|ae
operator|=
name|mc
operator|->
name|mc_flags
operator|&
name|IEEE80211_MESH_AE_MASK
expr_stmt|;
name|meshdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
operator|+
name|ae
operator|*
name|IEEE80211_ADDR_LEN
expr_stmt|;
name|hdrspace
operator|+=
name|meshdrlen
expr_stmt|;
comment|/* pull complete hdrspace = ieee80211_hdrspace + meshcontrol */
if|if
condition|(
operator|(
name|meshdrlen
operator|>
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_len
operator|<
name|hdrspace
operator|)
operator|&&
operator|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hdrspace
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"data too short: expecting %u"
argument_list|,
name|hdrspace
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
comment|/* XXX */
block|}
comment|/* XXX: are we sure there is no reallocating after m_pullup? */
name|seq
operator|=
name|le32dec
argument_list|(
name|mc
operator|->
name|mc_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|addr
operator|=
name|wh
operator|->
name|i_addr3
expr_stmt|;
elseif|else
if|if
condition|(
name|ae
operator|==
name|IEEE80211_MESH_AE_01
condition|)
name|addr
operator|=
name|MC01
argument_list|(
name|mc
argument_list|)
operator|->
name|mc_addr4
expr_stmt|;
else|else
name|addr
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_addr4
expr_stmt|;
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|addr
argument_list|,
literal|"data"
argument_list|,
literal|"%s"
argument_list|,
literal|"not to me"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_wrongbss
operator|++
expr_stmt|;
comment|/* XXX kinda */
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|mesh_checkpseq
argument_list|(
name|vap
argument_list|,
name|addr
argument_list|,
name|seq
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_dup
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* This code "routes" the frame to the right control path */
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
condition|)
name|error
operator|=
name|mesh_recv_indiv_data_to_me
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|wh
argument_list|,
name|mc
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
condition|)
name|error
operator|=
name|mesh_recv_group_data
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|wh
argument_list|,
name|mc
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|mesh_recv_indiv_data_to_fwrd
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|wh
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
else|else
name|error
operator|=
name|mesh_recv_group_data
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|wh
argument_list|,
name|mc
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
elseif|else
if|if
condition|(
name|error
operator|>
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
name|ieee80211_radiotap_rx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|need_tap
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Finally, strip the 802.11 header. 		 */
name|m
operator|=
name|mesh_decap
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|hdrspace
argument_list|,
name|meshdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX mask bit to check for both */
comment|/* don't count Null data frames as errors */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_NODATA
operator|||
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
condition|)
goto|goto
name|out
goto|;
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"data"
argument_list|,
literal|"%s"
argument_list|,
literal|"decap error"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_decap
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_decap
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_AMSDU
condition|)
block|{
name|m
operator|=
name|ieee80211_decap_amsdu
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|IEEE80211_FC0_TYPE_DATA
return|;
block|}
name|ieee80211_deliver_data
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
name|type
return|;
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgmt
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_mgmt
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|!=
name|IEEE80211_FC1_DIR_NODS
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
literal|"mgt"
argument_list|,
literal|"incorrect dir 0x%x"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_wrongdir
operator|++
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"mgt"
argument_list|,
literal|"too short: len %u"
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
goto|goto
name|out
goto|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
operator|(
name|ieee80211_msg_debug
argument_list|(
name|vap
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|)
operator|||
name|ieee80211_msg_dumppkts
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"received %s from %s rssi %d\n"
argument_list|,
name|ieee80211_mgt_subtype_name
argument_list|(
name|subtype
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"WEP set but not permitted"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
comment|/* XXX */
goto|goto
name|out
goto|;
block|}
name|vap
operator|->
name|iv_recv_mgmt
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|subtype
argument_list|,
name|rxs
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|IEEE80211_FC0_TYPE_CTL
case|:
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_ctl
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_ctrl
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|wh
argument_list|,
literal|"bad"
argument_list|,
literal|"frame type 0x%x"
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* should not come here */
break|break;
block|}
name|err
label|:
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|need_tap
operator|&&
name|ieee80211_radiotap_active_vap
argument_list|(
name|vap
argument_list|)
condition|)
name|ieee80211_radiotap_rx
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|type
return|;
undef|#
directive|undef
name|HAS_SEQ
undef|#
directive|undef
name|MC01
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|subtype
parameter_list|,
specifier|const
name|struct
name|ieee80211_rx_stats
modifier|*
name|rxs
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|rxchan
init|=
name|ic
operator|->
name|ic_curchan
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|,
modifier|*
name|efrm
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|frm
operator|=
operator|(
name|uint8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
expr_stmt|;
name|efrm
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|m0
operator|->
name|m_len
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_BEACON
case|:
block|{
name|struct
name|ieee80211_scanparams
name|scan
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
comment|/* 		 * We process beacon/probe response 		 * frames to discover neighbors. 		 */
if|if
condition|(
name|rxs
operator|!=
name|NULL
condition|)
block|{
name|c
operator|=
name|ieee80211_lookup_channel_rxstatus
argument_list|(
name|vap
argument_list|,
name|rxs
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|rxchan
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_parse_beacon
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|,
name|rxchan
argument_list|,
operator|&
name|scan
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* 		 * Count frame now that we know it's to be processed. 		 */
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_beacon
operator|++
expr_stmt|;
comment|/* XXX remove */
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_beacons
argument_list|)
expr_stmt|;
block|}
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_proberesp
argument_list|)
expr_stmt|;
comment|/* 		 * If scanning, just pass information to the scan module. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_PROBECHAN
condition|)
block|{
comment|/* 				 * Actively scanning a channel marked passive; 				 * send a probe request now that we know there 				 * is 802.11 traffic present. 				 * 				 * XXX check if the beacon we recv'd gives 				 * us what we need and suppress the probe req 				 */
name|ieee80211_probe_curchan
argument_list|(
name|vap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_PROBECHAN
expr_stmt|;
block|}
name|ieee80211_add_scan
argument_list|(
name|vap
argument_list|,
name|rxchan
argument_list|,
operator|&
name|scan
argument_list|,
name|wh
argument_list|,
name|subtype
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The rest of this code assumes we are running */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
return|return;
comment|/* 		 * Ignore non-mesh STAs. 		 */
if|if
condition|(
operator|(
name|scan
operator|.
name|capinfo
operator|&
operator|(
name|IEEE80211_CAPINFO_ESS
operator||
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|)
operator|||
name|scan
operator|.
name|meshid
operator|==
name|NULL
operator|||
name|scan
operator|.
name|meshconf
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
literal|"beacon"
argument_list|,
literal|"%s"
argument_list|,
literal|"not a mesh sta"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_wrongmesh
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * Ignore STAs for other mesh networks. 		 */
if|if
condition|(
name|memcmp
argument_list|(
name|scan
operator|.
name|meshid
operator|+
literal|2
argument_list|,
name|ms
operator|->
name|ms_id
argument_list|,
name|ms
operator|->
name|ms_idlen
argument_list|)
operator|!=
literal|0
operator|||
name|mesh_verify_meshconf
argument_list|(
name|vap
argument_list|,
name|scan
operator|.
name|meshconf
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
literal|"beacon"
argument_list|,
literal|"%s"
argument_list|,
literal|"not for our mesh"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_wrongmesh
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * Peer only based on the current ACL policy. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_acl
operator|!=
name|NULL
operator|&&
operator|!
name|vap
operator|->
name|iv_acl
operator|->
name|iac_check
argument_list|(
name|vap
argument_list|,
name|wh
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACL
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"disallowed by ACL"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_acl
operator|++
expr_stmt|;
return|return;
block|}
comment|/* 		 * Do neighbor discovery. 		 */
if|if
condition|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
condition|)
block|{
comment|/* 			 * Create a new entry in the neighbor table. 			 */
name|ni
operator|=
name|ieee80211_add_neighbor
argument_list|(
name|vap
argument_list|,
name|wh
argument_list|,
operator|&
name|scan
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Automatically peer with discovered nodes if possible. 		 */
if|if
condition|(
name|ni
operator|!=
name|vap
operator|->
name|iv_bss
operator|&&
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_AP
operator|)
condition|)
block|{
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_IDLE
case|:
block|{
name|uint16_t
name|args
index|[
literal|1
index|]
decl_stmt|;
comment|/* Wait for backoff callout to reset counter */
if|if
condition|(
name|ni
operator|->
name|ni_mlhcnt
operator|>=
name|ieee80211_mesh_maxholding
condition|)
return|return;
name|ni
operator|->
name|ni_mlpid
operator|=
name|mesh_generateid
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_mlpid
operator|==
literal|0
condition|)
return|return;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_OPENSNT
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_mlrcnt
operator|=
literal|0
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IEEE80211_NODE_MESH_ESTABLISHED
case|:
block|{
comment|/* 				 * Valid beacon from a peer mesh STA 				 * bump TA lifetime 				 */
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_mesh_rt_update
argument_list|(
name|rt
argument_list|,
name|ticks_to_msecs
argument_list|(
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_inact
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
default|default:
break|break;
comment|/* ignore */
block|}
block|}
break|break;
block|}
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
case|:
block|{
name|uint8_t
modifier|*
name|ssid
decl_stmt|,
modifier|*
name|meshid
decl_stmt|,
modifier|*
name|rates
decl_stmt|,
modifier|*
name|xrates
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"wrong state %s"
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
condition|)
block|{
comment|/* frame must be directed */
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"not unicast"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
comment|/* XXX stat */
return|return;
block|}
comment|/* 		 * prreq frame format 		 *      [tlv] ssid 		 *      [tlv] supported rates 		 *      [tlv] extended supported rates 		 *	[tlv] mesh id 		 */
name|ssid
operator|=
name|meshid
operator|=
name|rates
operator|=
name|xrates
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|efrm
operator|-
name|frm
operator|>
literal|1
condition|)
block|{
name|IEEE80211_VERIFY_LENGTH
argument_list|(
argument|efrm - frm
argument_list|,
argument|frm[
literal|1
argument|] +
literal|2
argument_list|,
argument|return
argument_list|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|frm
condition|)
block|{
case|case
name|IEEE80211_ELEMID_SSID
case|:
name|ssid
operator|=
name|frm
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_RATES
case|:
name|rates
operator|=
name|frm
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_XRATES
case|:
name|xrates
operator|=
name|frm
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_MESHID
case|:
name|meshid
operator|=
name|frm
expr_stmt|;
break|break;
block|}
name|frm
operator|+=
name|frm
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
block|}
name|IEEE80211_VERIFY_ELEMENT
argument_list|(
argument|ssid
argument_list|,
argument|IEEE80211_NWID_LEN
argument_list|,
argument|return
argument_list|)
empty_stmt|;
name|IEEE80211_VERIFY_ELEMENT
argument_list|(
argument|rates
argument_list|,
argument|IEEE80211_RATE_MAXSIZE
argument_list|,
argument|return
argument_list|)
empty_stmt|;
if|if
condition|(
name|xrates
operator|!=
name|NULL
condition|)
name|IEEE80211_VERIFY_ELEMENT
argument_list|(
argument|xrates
argument_list|,
argument|IEEE80211_RATE_MAXSIZE - rates[
literal|1
argument|]
argument_list|,
argument|return
argument_list|)
empty_stmt|;
if|if
condition|(
name|meshid
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_VERIFY_ELEMENT
argument_list|(
argument|meshid
argument_list|,
argument|IEEE80211_MESHID_LEN
argument_list|,
argument|return
argument_list|)
empty_stmt|;
comment|/* NB: meshid, not ssid */
name|IEEE80211_VERIFY_SSID
argument_list|(
argument|vap->iv_bss
argument_list|,
argument|meshid
argument_list|,
argument|return
argument_list|)
empty_stmt|;
block|}
comment|/* XXX find a better class or define it's own */
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
literal|"%s"
argument_list|,
literal|"recv probe req"
argument_list|)
expr_stmt|;
comment|/* 		 * Some legacy 11b clients cannot hack a complete 		 * probe response frame.  When the request includes 		 * only a bare-bones rate set, communicate this to 		 * the transmit side. 		 */
name|ieee80211_send_proberesp
argument_list|(
name|vap
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|IEEE80211_FC0_SUBTYPE_ACTION
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_ACTION_NOACK
case|:
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"unknown node"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"not for us"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"wrong state %s"
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ieee80211_parse_action
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|ic
operator|->
name|ic_recv_action
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|frm
argument_list|,
name|efrm
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_TIMING_ADV
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_ATIM
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DISASSOC
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"not handled"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
default|default:
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|wh
argument_list|,
literal|"mgt"
argument_list|,
literal|"subtype 0x%x not handled"
argument_list|,
name|subtype
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_badsubtype
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_recv_ctl
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_BAR
case|:
name|ieee80211_recv_bar
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse meshpeering action ie's for MPM frames  */
end_comment

begin_function
specifier|static
specifier|const
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|mesh_parse_meshpeering_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
comment|/* XXX for VERIFY_LENGTH */
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|,
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|mp
parameter_list|,
name|uint8_t
name|subtype
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|mpie
decl_stmt|;
name|uint16_t
name|args
index|[
literal|3
index|]
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|meshid
decl_stmt|,
modifier|*
name|meshconf
decl_stmt|;
name|uint8_t
name|sendclose
init|=
literal|0
decl_stmt|;
comment|/* 1 = MPM frame rejected, close will be sent */
name|meshid
operator|=
name|meshconf
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|efrm
operator|-
name|frm
operator|>
literal|1
condition|)
block|{
name|IEEE80211_VERIFY_LENGTH
argument_list|(
argument|efrm - frm
argument_list|,
argument|frm[
literal|1
argument|] +
literal|2
argument_list|,
argument|return NULL
argument_list|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|frm
condition|)
block|{
case|case
name|IEEE80211_ELEMID_MESHID
case|:
name|meshid
operator|=
name|frm
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_MESHCONF
case|:
name|meshconf
operator|=
name|frm
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_MESHPEER
case|:
name|mpie
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshpeer_ie
operator|*
operator|)
name|frm
expr_stmt|;
name|memset
argument_list|(
name|mp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mp
argument_list|)
argument_list|)
expr_stmt|;
name|mp
operator|->
name|peer_len
operator|=
name|mpie
operator|->
name|peer_len
expr_stmt|;
name|mp
operator|->
name|peer_proto
operator|=
name|le16dec
argument_list|(
operator|&
name|mpie
operator|->
name|peer_proto
argument_list|)
expr_stmt|;
name|mp
operator|->
name|peer_llinkid
operator|=
name|le16dec
argument_list|(
operator|&
name|mpie
operator|->
name|peer_llinkid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
case|:
name|mp
operator|->
name|peer_linkid
operator|=
name|le16dec
argument_list|(
operator|&
name|mpie
operator|->
name|peer_linkid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ACTION_MESHPEERING_CLOSE
case|:
comment|/* NB: peer link ID is optional */
if|if
condition|(
name|mpie
operator|->
name|peer_len
operator|==
operator|(
name|IEEE80211_MPM_BASE_SZ
operator|+
literal|2
operator|)
condition|)
block|{
name|mp
operator|->
name|peer_linkid
operator|=
literal|0
expr_stmt|;
name|mp
operator|->
name|peer_rcode
operator|=
name|le16dec
argument_list|(
operator|&
name|mpie
operator|->
name|peer_linkid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mp
operator|->
name|peer_linkid
operator|=
name|le16dec
argument_list|(
operator|&
name|mpie
operator|->
name|peer_linkid
argument_list|)
expr_stmt|;
name|mp
operator|->
name|peer_rcode
operator|=
name|le16dec
argument_list|(
operator|&
name|mpie
operator|->
name|peer_rcode
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
name|frm
operator|+=
name|frm
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
block|}
comment|/* 	 * Verify the contents of the frame. 	 * If it fails validation, close the peer link. 	 */
if|if
condition|(
name|mesh_verify_meshpeer
argument_list|(
name|vap
argument_list|,
name|subtype
argument_list|,
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|mp
argument_list|)
condition|)
block|{
name|sendclose
operator|=
literal|1
expr_stmt|;
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"MPM validation failed"
argument_list|)
expr_stmt|;
block|}
comment|/* If meshid is not the same reject any frames type. */
if|if
condition|(
name|sendclose
operator|==
literal|0
operator|&&
name|mesh_verify_meshid
argument_list|(
name|vap
argument_list|,
name|meshid
argument_list|)
condition|)
block|{
name|sendclose
operator|=
literal|1
expr_stmt|;
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"not for our mesh"
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_ACTION_MESHPEERING_CLOSE
condition|)
block|{
comment|/* 			 * Standard not clear about this, if we dont ignore 			 * there will be an endless loop between nodes sending 			 * CLOSE frames between each other with wrong meshid. 			 * Discard and timers will bring FSM to IDLE state. 			 */
return|return
name|NULL
return|;
block|}
block|}
comment|/* 	 * Close frames are accepted if meshid is the same. 	 * Verify the other two types. 	 */
if|if
condition|(
name|sendclose
operator|==
literal|0
operator|&&
name|subtype
operator|!=
name|IEEE80211_ACTION_MESHPEERING_CLOSE
operator|&&
name|mesh_verify_meshconf
argument_list|(
name|vap
argument_list|,
name|meshconf
argument_list|)
condition|)
block|{
name|sendclose
operator|=
literal|1
expr_stmt|;
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"configuration missmatch"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sendclose
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_IDLE
case|:
case|case
name|IEEE80211_NODE_MESH_ESTABLISHED
case|:
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
comment|/* ignore */
break|break;
case|case
name|IEEE80211_NODE_MESH_OPENSNT
case|:
case|case
name|IEEE80211_NODE_MESH_OPENRCV
case|:
case|case
name|IEEE80211_NODE_MESH_CONFIRMRCV
case|:
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
comment|/* Reason codes for rejection */
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_ACTION_MESHPEERING_OPEN
case|:
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_MESH_CPVIOLATION
expr_stmt|;
break|break;
case|case
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
case|:
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_MESH_INCONS_PARAMS
expr_stmt|;
break|break;
block|}
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|NULL
return|;
block|}
return|return
operator|(
specifier|const
expr|struct
name|ieee80211_meshpeer_ie
operator|*
operator|)
name|mp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_recv_action_meshpeering_open
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_meshpeer_ie
name|ie
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|meshpeer
decl_stmt|;
name|uint16_t
name|args
index|[
literal|3
index|]
decl_stmt|;
comment|/* +2+2 for action + code + capabilites */
name|meshpeer
operator|=
name|mesh_parse_meshpeering_action
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|frm
operator|+
literal|2
operator|+
literal|2
argument_list|,
name|efrm
argument_list|,
operator|&
name|ie
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|meshpeer
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* XXX move up */
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"recv PEER OPEN, lid 0x%x"
argument_list|,
name|meshpeer
operator|->
name|peer_llinkid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_IDLE
case|:
comment|/* Reject open request if reached our maximum neighbor count */
if|if
condition|(
name|ms
operator|->
name|ms_neighbors
operator|>=
name|IEEE80211_MESH_MAX_NEIGHBORS
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|meshpeer
operator|->
name|peer_llinkid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_MESH_MAX_PEERS
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* stay in IDLE state */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Open frame accepted */
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_OPENRCV
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_mllid
operator|=
name|meshpeer
operator|->
name|peer_llinkid
expr_stmt|;
name|ni
operator|->
name|ni_mlpid
operator|=
name|mesh_generateid
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_mlpid
operator|==
literal|0
condition|)
return|return
literal|0
return|;
comment|/* XXX */
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
comment|/* Announce we're open too... */
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* ...and confirm the link. */
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_OPENRCV
case|:
comment|/* Wrong Link ID */
if|if
condition|(
name|ni
operator|->
name|ni_mllid
operator|!=
name|meshpeer
operator|->
name|peer_llinkid
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Duplicate open, confirm again. */
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_OPENSNT
case|:
name|ni
operator|->
name|ni_mllid
operator|=
name|meshpeer
operator|->
name|peer_llinkid
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_OPENRCV
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* NB: don't setup/clear any timeout */
break|break;
case|case
name|IEEE80211_NODE_MESH_CONFIRMRCV
case|:
if|if
condition|(
name|ni
operator|->
name|ni_mlpid
operator|!=
name|meshpeer
operator|->
name|peer_linkid
operator|||
name|ni
operator|->
name|ni_mllid
operator|!=
name|meshpeer
operator|->
name|peer_llinkid
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_ESTABLISHED
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_mllid
operator|=
name|meshpeer
operator|->
name|peer_llinkid
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_stop
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_ESTABLISHED
case|:
if|if
condition|(
name|ni
operator|->
name|ni_mllid
operator|!=
name|meshpeer
operator|->
name|peer_llinkid
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|meshpeer
operator|->
name|peer_llinkid
expr_stmt|;
comment|/* Standard not clear about what the reaason code should be */
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_recv_action_meshpeering_confirm
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_meshpeer_ie
name|ie
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|meshpeer
decl_stmt|;
name|uint16_t
name|args
index|[
literal|3
index|]
decl_stmt|;
comment|/* +2+2+2+2 for action + code + capabilites + status code + AID */
name|meshpeer
operator|=
name|mesh_parse_meshpeering_action
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|frm
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
argument_list|,
name|efrm
argument_list|,
operator|&
name|ie
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|)
expr_stmt|;
if|if
condition|(
name|meshpeer
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"recv PEER CONFIRM, local id 0x%x, peer id 0x%x"
argument_list|,
name|meshpeer
operator|->
name|peer_llinkid
argument_list|,
name|meshpeer
operator|->
name|peer_linkid
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_OPENRCV
case|:
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_ESTABLISHED
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_stop
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_OPENSNT
case|:
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_CONFIRMRCV
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|meshpeer
operator|->
name|peer_llinkid
expr_stmt|;
comment|/* Standard not clear about what the reaason code should be */
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_CONFIRMRCV
case|:
if|if
condition|(
name|ni
operator|->
name|ni_mllid
operator|!=
name|meshpeer
operator|->
name|peer_llinkid
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_PEER_LINK_CANCELED
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|wh
argument_list|,
name|NULL
argument_list|,
literal|"received confirm in invalid state %d"
argument_list|,
name|ni
operator|->
name|ni_mlstate
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_recv_action_meshpeering_close
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211_meshpeer_ie
name|ie
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|meshpeer
decl_stmt|;
name|uint16_t
name|args
index|[
literal|3
index|]
decl_stmt|;
comment|/* +2 for action + code */
name|meshpeer
operator|=
name|mesh_parse_meshpeering_action
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|frm
operator|+
literal|2
argument_list|,
name|efrm
argument_list|,
operator|&
name|ie
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|meshpeer
operator|==
name|NULL
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* 	 * XXX: check reason code, for example we could receive 	 * IEEE80211_REASON_MESH_MAX_PEERS then we should not attempt 	 * to peer again. 	 */
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"recv PEER CLOSE"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_IDLE
case|:
comment|/* ignore */
break|break;
case|case
name|IEEE80211_NODE_MESH_OPENRCV
case|:
case|case
name|IEEE80211_NODE_MESH_OPENSNT
case|:
case|case
name|IEEE80211_NODE_MESH_CONFIRMRCV
case|:
case|case
name|IEEE80211_NODE_MESH_ESTABLISHED
case|:
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|ni
operator|->
name|ni_mllid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_MESH_CLOSE_RCVD
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_IDLE
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_stop
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Link Metric handling.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_recv_action_meshlmetric
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_meshlmetric_ie
modifier|*
name|ie
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshlmetric_ie
operator|*
operator|)
operator|(
name|frm
operator|+
literal|2
operator|)
decl_stmt|;
comment|/* action + code */
name|struct
name|ieee80211_meshlmetric_ie
name|lm_rep
decl_stmt|;
if|if
condition|(
name|ie
operator|->
name|lm_flags
operator|&
name|IEEE80211_MESH_LMETRIC_FLAGS_REQ
condition|)
block|{
name|lm_rep
operator|.
name|lm_flags
operator|=
literal|0
expr_stmt|;
name|lm_rep
operator|.
name|lm_metric
operator|=
name|mesh_airtime_calc
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_LMETRIC
argument_list|,
operator|&
name|lm_rep
argument_list|)
expr_stmt|;
block|}
comment|/* XXX: else do nothing for now */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse meshgate action ie's for GANN frames.  * Returns -1 if parsing fails, otherwise 0.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_parse_meshgate_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
comment|/* XXX for VERIFY_LENGTH */
name|struct
name|ieee80211_meshgann_ie
modifier|*
name|ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_meshgann_ie
modifier|*
name|gannie
decl_stmt|;
while|while
condition|(
name|efrm
operator|-
name|frm
operator|>
literal|1
condition|)
block|{
name|IEEE80211_VERIFY_LENGTH
argument_list|(
argument|efrm - frm
argument_list|,
argument|frm[
literal|1
argument|] +
literal|2
argument_list|,
argument|return -
literal|1
argument_list|)
empty_stmt|;
switch|switch
condition|(
operator|*
name|frm
condition|)
block|{
case|case
name|IEEE80211_ELEMID_MESHGANN
case|:
name|gannie
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshgann_ie
operator|*
operator|)
name|frm
expr_stmt|;
name|memset
argument_list|(
name|ie
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ie
argument_list|)
argument_list|)
expr_stmt|;
name|ie
operator|->
name|gann_ie
operator|=
name|gannie
operator|->
name|gann_ie
expr_stmt|;
name|ie
operator|->
name|gann_len
operator|=
name|gannie
operator|->
name|gann_len
expr_stmt|;
name|ie
operator|->
name|gann_flags
operator|=
name|gannie
operator|->
name|gann_flags
expr_stmt|;
name|ie
operator|->
name|gann_hopcount
operator|=
name|gannie
operator|->
name|gann_hopcount
expr_stmt|;
name|ie
operator|->
name|gann_ttl
operator|=
name|gannie
operator|->
name|gann_ttl
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ie
operator|->
name|gann_addr
argument_list|,
name|gannie
operator|->
name|gann_addr
argument_list|)
expr_stmt|;
name|ie
operator|->
name|gann_seq
operator|=
name|le32dec
argument_list|(
operator|&
name|gannie
operator|->
name|gann_seq
argument_list|)
expr_stmt|;
name|ie
operator|->
name|gann_interval
operator|=
name|le16dec
argument_list|(
operator|&
name|gannie
operator|->
name|gann_interval
argument_list|)
expr_stmt|;
break|break;
block|}
name|frm
operator|+=
name|frm
index|[
literal|1
index|]
operator|+
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Mesh Gate Announcement handling.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_recv_action_meshgate
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_mesh_gate_route
modifier|*
name|gr
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt_gate
decl_stmt|;
name|struct
name|ieee80211_meshgann_ie
name|pgann
decl_stmt|;
name|struct
name|ieee80211_meshgann_ie
name|ie
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* +2 for action + code */
if|if
condition|(
name|mesh_parse_meshgate_action
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
operator|&
name|ie
argument_list|,
name|frm
operator|+
literal|2
argument_list|,
name|efrm
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"GANN parsing failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|)
condition|)
return|return
literal|0
return|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"received GANN, meshgate: %6D (seq %u)"
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|,
literal|":"
argument_list|,
name|ie
operator|.
name|gann_seq
argument_list|)
expr_stmt|;
if|if
condition|(
name|ms
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|gr
argument_list|,
argument|&ms->ms_known_gates
argument_list|,
argument|gr_next
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|gr
operator|->
name|gr_addr
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ie
operator|.
name|gann_seq
operator|<=
name|gr
operator|->
name|gr_lastseq
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"GANN old seqno %u<= %u"
argument_list|,
name|ie
operator|.
name|gann_seq
argument_list|,
name|gr
operator|->
name|gr_lastseq
argument_list|)
expr_stmt|;
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* corresponding mesh gate found& GANN accepted */
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
comment|/* this GANN is from a new mesh Gate add it to known table. */
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|,
literal|"stored new GANN information, seq %u."
argument_list|,
name|ie
operator|.
name|gann_seq
argument_list|)
expr_stmt|;
name|gr
operator|=
name|IEEE80211_MALLOC
argument_list|(
name|ALIGN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_mesh_gate_route
argument_list|)
argument_list|)
argument_list|,
name|M_80211_MESH_GT_RT
argument_list|,
name|IEEE80211_M_NOWAIT
operator||
name|IEEE80211_M_ZERO
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|gr
operator|->
name|gr_addr
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ms
operator|->
name|ms_known_gates
argument_list|,
name|gr
argument_list|,
name|gr_next
argument_list|)
expr_stmt|;
block|}
name|gr
operator|->
name|gr_lastseq
operator|=
name|ie
operator|.
name|gann_seq
expr_stmt|;
comment|/* check if we have a path to this gate */
name|rt_gate
operator|=
name|mesh_rt_find_locked
argument_list|(
name|ms
argument_list|,
name|gr
operator|->
name|gr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt_gate
operator|!=
name|NULL
operator|&&
name|rt_gate
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_VALID
condition|)
block|{
name|gr
operator|->
name|gr_route
operator|=
name|rt_gate
expr_stmt|;
name|rt_gate
operator|->
name|rt_flags
operator||=
name|IEEE80211_MESHRT_FLAGS_GATE
expr_stmt|;
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
comment|/* popagate only if decremented ttl>= 1&& forwarding is enabled */
if|if
condition|(
operator|(
name|ie
operator|.
name|gann_ttl
operator|-
literal|1
operator|)
operator|<
literal|1
operator|&&
operator|!
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_FWD
operator|)
condition|)
return|return
literal|0
return|;
name|pgann
operator|.
name|gann_flags
operator|=
name|ie
operator|.
name|gann_flags
expr_stmt|;
comment|/* Reserved */
name|pgann
operator|.
name|gann_hopcount
operator|=
name|ie
operator|.
name|gann_hopcount
operator|+
literal|1
expr_stmt|;
name|pgann
operator|.
name|gann_ttl
operator|=
name|ie
operator|.
name|gann_ttl
operator|-
literal|1
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|pgann
operator|.
name|gann_addr
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|)
expr_stmt|;
name|pgann
operator|.
name|gann_seq
operator|=
name|ie
operator|.
name|gann_seq
expr_stmt|;
name|pgann
operator|.
name|gann_interval
operator|=
name|ie
operator|.
name|gann_interval
expr_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ie
operator|.
name|gann_addr
argument_list|,
literal|"%s"
argument_list|,
literal|"propagate GANN"
argument_list|)
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|,
name|IEEE80211_ACTION_CAT_MESH
argument_list|,
name|IEEE80211_ACTION_MESH_GANN
argument_list|,
operator|&
name|pgann
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_send_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_bpf_params
name|params
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|ni
argument_list|,
literal|"block %s frame in CAC state"
argument_list|,
literal|"Mesh action"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_ACTION
argument_list|,
name|IEEE80211_NONQOS_TID
argument_list|,
name|sa
argument_list|,
name|da
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_ENCAP
expr_stmt|;
comment|/* mark encapsulated */
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|ibp_pri
operator|=
name|WME_AC_VO
expr_stmt|;
name|params
operator|.
name|ibp_rate0
operator|=
name|ni
operator|->
name|ni_txparms
operator|->
name|mgmtrate
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|da
argument_list|)
condition|)
name|params
operator|.
name|ibp_try0
operator|=
literal|1
expr_stmt|;
else|else
name|params
operator|.
name|ibp_try0
operator|=
name|ni
operator|->
name|ni_txparms
operator|->
name|maxretry
expr_stmt|;
name|params
operator|.
name|ibp_power
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|ADDWORD
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = ((v)>> 8)& 0xff;		\ 	frm[2] = ((v)>> 16)& 0xff;		\ 	frm[3] = ((v)>> 24)& 0xff;		\ 	frm += 4;				\ } while (0)
end_define

begin_function
specifier|static
name|int
name|mesh_send_action_meshpeering_open
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|args0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
modifier|*
name|args
init|=
name|args0
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"send PEER OPEN action: localid 0x%x"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* capabilites */
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
literal|2
operator|+
name|IEEE80211_MESHID_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshconf_ie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshpeer_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * mesh peer open action frame format: 		 *   [1] category 		 *   [1] action 		 *   [2] capabilities 		 *   [tlv] rates 		 *   [tlv] xrates 		 *   [tlv] mesh id 		 *   [tlv] mesh conf 		 *   [tlv] mesh peer link mgmt 		 */
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ieee80211_getcapinfo
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshid
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshconf
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshpeer
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|mesh_send_action
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_send_action_meshpeering_confirm
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|args0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
modifier|*
name|args
init|=
name|args0
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"send PEER CONFIRM action: localid 0x%x, peerid 0x%x"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* capabilites */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* status code */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* AID */
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
literal|2
operator|+
name|IEEE80211_MESHID_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshconf_ie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshpeer_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * mesh peer confirm action frame format: 		 *   [1] category 		 *   [1] action 		 *   [2] capabilities 		 *   [2] status code 		 *   [2] association id (peer ID) 		 *   [tlv] rates 		 *   [tlv] xrates 		 *   [tlv] mesh id 		 *   [tlv] mesh conf 		 *   [tlv] mesh peer link mgmt 		 */
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ieee80211_getcapinfo
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* status code */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* AID */
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshid
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshconf
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshpeer
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|mesh_send_action
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_send_action_meshpeering_close
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|args0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
modifier|*
name|args
init|=
name|args0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"send PEER CLOSE action: localid 0x%x, peerid 0x%x reason %d (%s)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|ieee80211_reason_to_string
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* reason code */
operator|+
literal|2
operator|+
name|IEEE80211_MESHID_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshpeer_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * mesh peer close action frame format: 		 *   [1] category 		 *   [1] action 		 *   [tlv] mesh id 		 *   [tlv] mesh peer link mgmt 		 */
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshid
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshpeer
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|mesh_send_action
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_send_action_meshlmetric
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_meshlmetric_ie
modifier|*
name|ie
init|=
name|arg0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
if|if
condition|(
name|ie
operator|->
name|lm_flags
operator|&
name|IEEE80211_MESH_LMETRIC_FLAGS_REQ
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"send LINK METRIC REQUEST action"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"send LINK METRIC REPLY action: metric 0x%x"
argument_list|,
name|ie
operator|->
name|lm_metric
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
comment|/* action+category */
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshlmetric_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * mesh link metric 		 *   [1] category 		 *   [1] action 		 *   [tlv] mesh link metric 		 */
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshlmetric
argument_list|(
name|frm
argument_list|,
name|ie
operator|->
name|lm_flags
argument_list|,
name|ie
operator|->
name|lm_metric
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|mesh_send_action
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_send_action_meshgate
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_meshgann_ie
modifier|*
name|ie
init|=
name|arg0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
comment|/* action+category */
name|IEEE80211_MESHGANN_BASE_SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * mesh link metric 		 *   [1] category 		 *   [1] action 		 *   [tlv] mesh gate annoucement 		 */
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshgate
argument_list|(
name|frm
argument_list|,
name|ie
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|mesh_send_action
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|broadcastaddr
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_peer_timeout_setup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
name|ni
operator|->
name|ni_mltval
operator|=
name|ieee80211_mesh_holdingtimeout
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_CONFIRMRCV
case|:
name|ni
operator|->
name|ni_mltval
operator|=
name|ieee80211_mesh_confirmtimeout
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_IDLE
case|:
name|ni
operator|->
name|ni_mltval
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|ni
operator|->
name|ni_mltval
operator|=
name|ieee80211_mesh_retrytimeout
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ni
operator|->
name|ni_mltval
condition|)
name|callout_reset
argument_list|(
operator|&
name|ni
operator|->
name|ni_mltimer
argument_list|,
name|ni
operator|->
name|ni_mltval
argument_list|,
name|mesh_peer_timeout_cb
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Same as above but backoffs timer statisically 50%.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_peer_timeout_backoff
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint32_t
name|r
decl_stmt|;
name|r
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|ni
operator|->
name|ni_mltval
operator|+=
name|r
operator|%
name|ni
operator|->
name|ni_mltval
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ni
operator|->
name|ni_mltimer
argument_list|,
name|ni
operator|->
name|ni_mltval
argument_list|,
name|mesh_peer_timeout_cb
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|mesh_peer_timeout_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|ni
operator|->
name|ni_mltimer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mesh_peer_backoff_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|arg
decl_stmt|;
comment|/* After backoff timeout, try to peer automatically again. */
name|ni
operator|->
name|ni_mlhcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Mesh Peer Link Management FSM timeout handling.  */
end_comment

begin_function
specifier|static
name|void
name|mesh_peer_timeout_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|arg
decl_stmt|;
name|uint16_t
name|args
index|[
literal|3
index|]
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|ni
argument_list|,
literal|"mesh link timeout, state %d, retry counter %d"
argument_list|,
name|ni
operator|->
name|ni_mlstate
argument_list|,
name|ni
operator|->
name|ni_mlrcnt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ni
operator|->
name|ni_mlstate
condition|)
block|{
case|case
name|IEEE80211_NODE_MESH_IDLE
case|:
case|case
name|IEEE80211_NODE_MESH_ESTABLISHED
case|:
break|break;
case|case
name|IEEE80211_NODE_MESH_OPENSNT
case|:
case|case
name|IEEE80211_NODE_MESH_OPENRCV
case|:
if|if
condition|(
name|ni
operator|->
name|ni_mlrcnt
operator|==
name|ieee80211_mesh_maxretries
condition|)
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_MESH_MAX_RETRIES
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_mlrcnt
operator|=
literal|0
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_OPEN
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_mlrcnt
operator|++
expr_stmt|;
name|mesh_peer_timeout_backoff
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_NODE_MESH_CONFIRMRCV
case|:
name|args
index|[
literal|0
index|]
operator|=
name|ni
operator|->
name|ni_mlpid
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_REASON_MESH_CONFIRM_TIMEOUT
expr_stmt|;
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_SELF_PROT
argument_list|,
name|IEEE80211_ACTION_MESHPEERING_CLOSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_HOLDING
argument_list|)
expr_stmt|;
name|mesh_peer_timeout_setup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_NODE_MESH_HOLDING
case|:
name|ni
operator|->
name|ni_mlhcnt
operator|++
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_mlhcnt
operator|>=
name|ieee80211_mesh_maxholding
condition|)
name|callout_reset
argument_list|(
operator|&
name|ni
operator|->
name|ni_mlhtimer
argument_list|,
name|ieee80211_mesh_backofftimeout
argument_list|,
name|mesh_peer_backoff_cb
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|mesh_linkchange
argument_list|(
name|ni
argument_list|,
name|IEEE80211_NODE_MESH_IDLE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_verify_meshid
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
if|if
condition|(
name|ie
operator|==
name|NULL
operator|||
name|ie
index|[
literal|1
index|]
operator|!=
name|ms
operator|->
name|ms_idlen
condition|)
return|return
literal|1
return|;
return|return
name|memcmp
argument_list|(
name|ms
operator|->
name|ms_id
argument_list|,
name|ie
operator|+
literal|2
argument_list|,
name|ms
operator|->
name|ms_idlen
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if we are using the same algorithms for this mesh.  */
end_comment

begin_function
specifier|static
name|int
name|mesh_verify_meshconf
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_meshconf_ie
modifier|*
name|meshconf
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshconf_ie
operator|*
operator|)
name|ie
decl_stmt|;
specifier|const
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
if|if
condition|(
name|meshconf
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|meshconf
operator|->
name|conf_pselid
operator|!=
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_ie
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
literal|"unknown path selection algorithm: 0x%x\n"
argument_list|,
name|meshconf
operator|->
name|conf_pselid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|meshconf
operator|->
name|conf_pmetid
operator|!=
name|ms
operator|->
name|ms_pmetric
operator|->
name|mpm_ie
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
literal|"unknown path metric algorithm: 0x%x\n"
argument_list|,
name|meshconf
operator|->
name|conf_pmetid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|meshconf
operator|->
name|conf_ccid
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
literal|"unknown congestion control algorithm: 0x%x\n"
argument_list|,
name|meshconf
operator|->
name|conf_ccid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|meshconf
operator|->
name|conf_syncid
operator|!=
name|IEEE80211_MESHCONF_SYNC_NEIGHOFF
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
literal|"unknown sync algorithm: 0x%x\n"
argument_list|,
name|meshconf
operator|->
name|conf_syncid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|meshconf
operator|->
name|conf_authid
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
literal|"unknown auth auth algorithm: 0x%x\n"
argument_list|,
name|meshconf
operator|->
name|conf_pselid
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Not accepting peers */
if|if
condition|(
operator|!
operator|(
name|meshconf
operator|->
name|conf_cap
operator|&
name|IEEE80211_MESHCONF_CAP_AP
operator|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
literal|"not accepting peers: 0x%x\n"
argument_list|,
name|meshconf
operator|->
name|conf_cap
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_verify_meshpeer
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|uint8_t
name|subtype
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_meshpeer_ie
modifier|*
name|meshpeer
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_meshpeer_ie
operator|*
operator|)
name|ie
decl_stmt|;
if|if
condition|(
name|meshpeer
operator|==
name|NULL
operator|||
name|meshpeer
operator|->
name|peer_len
operator|<
name|IEEE80211_MPM_BASE_SZ
operator|||
name|meshpeer
operator|->
name|peer_len
operator|>
name|IEEE80211_MPM_MAX_SZ
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|meshpeer
operator|->
name|peer_proto
operator|!=
name|IEEE80211_MPPID_MPM
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_MESH
argument_list|,
literal|"Only MPM protocol is supported (proto: 0x%02X)"
argument_list|,
name|meshpeer
operator|->
name|peer_proto
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_ACTION_MESHPEERING_OPEN
case|:
if|if
condition|(
name|meshpeer
operator|->
name|peer_len
operator|!=
name|IEEE80211_MPM_BASE_SZ
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
case|:
if|if
condition|(
name|meshpeer
operator|->
name|peer_len
operator|!=
name|IEEE80211_MPM_BASE_SZ
operator|+
literal|2
condition|)
return|return
literal|1
return|;
break|break;
case|case
name|IEEE80211_ACTION_MESHPEERING_CLOSE
case|:
if|if
condition|(
name|meshpeer
operator|->
name|peer_len
operator|<
name|IEEE80211_MPM_BASE_SZ
operator|+
literal|2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|meshpeer
operator|->
name|peer_len
operator|==
operator|(
name|IEEE80211_MPM_BASE_SZ
operator|+
literal|2
operator|)
operator|&&
name|meshpeer
operator|->
name|peer_linkid
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|meshpeer
operator|->
name|peer_rcode
operator|==
literal|0
condition|)
return|return
literal|1
return|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a Mesh ID IE to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_meshid
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
argument_list|,
operator|(
literal|"not a mbss vap"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_MESHID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ms
operator|->
name|ms_idlen
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ms
operator|->
name|ms_id
argument_list|,
name|ms
operator|->
name|ms_idlen
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|ms
operator|->
name|ms_idlen
return|;
block|}
end_function

begin_comment
comment|/*  * Add a Mesh Configuration IE to a frame.  * For now just use HWMP routing, Airtime link metric, Null Congestion  * Signaling, Null Sync Protocol and Null Authentication.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_meshconf
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|uint16_t
name|caps
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
argument_list|,
operator|(
literal|"not a MBSS vap"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_MESHCONF
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MESH_CONF_SZ
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_ie
expr_stmt|;
comment|/* path selection */
operator|*
name|frm
operator|++
operator|=
name|ms
operator|->
name|ms_pmetric
operator|->
name|mpm_ie
expr_stmt|;
comment|/* link metric */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MESHCONF_CC_DISABLED
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MESHCONF_SYNC_NEIGHOFF
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MESHCONF_AUTH_DISABLED
expr_stmt|;
comment|/* NB: set the number of neighbors before the rest */
operator|*
name|frm
operator|=
operator|(
name|ms
operator|->
name|ms_neighbors
operator|>
name|IEEE80211_MESH_MAX_NEIGHBORS
condition|?
name|IEEE80211_MESH_MAX_NEIGHBORS
else|:
name|ms
operator|->
name|ms_neighbors
operator|)
operator|<<
literal|1
expr_stmt|;
if|if
condition|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_GATE
condition|)
operator|*
name|frm
operator||=
name|IEEE80211_MESHCONF_FORM_GATE
expr_stmt|;
name|frm
operator|+=
literal|1
expr_stmt|;
name|caps
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_AP
condition|)
name|caps
operator||=
name|IEEE80211_MESHCONF_CAP_AP
expr_stmt|;
if|if
condition|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_FWD
condition|)
name|caps
operator||=
name|IEEE80211_MESHCONF_CAP_FWRD
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|caps
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Add a Mesh Peer Management IE to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_meshpeer
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|uint8_t
name|subtype
parameter_list|,
name|uint16_t
name|localid
parameter_list|,
name|uint16_t
name|peerid
parameter_list|,
name|uint16_t
name|reason
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|localid
operator|!=
literal|0
argument_list|,
operator|(
literal|"localid == 0"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_MESHPEER
expr_stmt|;
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_ACTION_MESHPEERING_OPEN
case|:
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MPM_BASE_SZ
expr_stmt|;
comment|/* length */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|IEEE80211_MPPID_MPM
argument_list|)
expr_stmt|;
comment|/* proto */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|localid
argument_list|)
expr_stmt|;
comment|/* local ID */
break|break;
case|case
name|IEEE80211_ACTION_MESHPEERING_CONFIRM
case|:
name|KASSERT
argument_list|(
name|peerid
operator|!=
literal|0
argument_list|,
operator|(
literal|"sending peer confirm without peer id"
operator|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MPM_BASE_SZ
operator|+
literal|2
expr_stmt|;
comment|/* length */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|IEEE80211_MPPID_MPM
argument_list|)
expr_stmt|;
comment|/* proto */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|localid
argument_list|)
expr_stmt|;
comment|/* local ID */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|peerid
argument_list|)
expr_stmt|;
comment|/* peer ID */
break|break;
case|case
name|IEEE80211_ACTION_MESHPEERING_CLOSE
case|:
if|if
condition|(
name|peerid
condition|)
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MPM_MAX_SZ
expr_stmt|;
comment|/* length */
else|else
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MPM_BASE_SZ
operator|+
literal|2
expr_stmt|;
comment|/* length */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|IEEE80211_MPPID_MPM
argument_list|)
expr_stmt|;
comment|/* proto */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|localid
argument_list|)
expr_stmt|;
comment|/* local ID */
if|if
condition|(
name|peerid
condition|)
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|peerid
argument_list|)
expr_stmt|;
comment|/* peer ID */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|reason
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Compute an Airtime Link Metric for the link with this node.  *  * Based on Draft 3.0 spec (11B.10, p.149).  */
end_comment

begin_comment
comment|/*  * Max 802.11s overhead.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_MESH_MAXOVERHEAD
define|\
value|(sizeof(struct ieee80211_qosframe_addr4) \ 	 + sizeof(struct ieee80211_meshcntl_ae10) \ 	+ sizeof(struct llc) \ 	+ IEEE80211_ADDR_LEN \ 	+ IEEE80211_WEP_IVLEN \ 	+ IEEE80211_WEP_KIDLEN \ 	+ IEEE80211_WEP_CRCLEN \ 	+ IEEE80211_WEP_MICLEN \ 	+ IEEE80211_CRC_LEN)
end_define

begin_function
name|uint32_t
name|mesh_airtime_calc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|M_BITS
value|8
define|#
directive|define
name|S_FACTOR
value|(2 * M_BITS)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
decl_stmt|;
specifier|const
specifier|static
name|int
name|nbits
init|=
literal|8192
operator|<<
name|M_BITS
decl_stmt|;
name|uint32_t
name|overhead
decl_stmt|,
name|rate
decl_stmt|,
name|errrate
decl_stmt|;
name|uint64_t
name|res
decl_stmt|;
comment|/* Time to transmit a frame */
name|rate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
name|overhead
operator|=
name|ieee80211_compute_duration
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|ifp
operator|->
name|if_mtu
operator|+
name|IEEE80211_MESH_MAXOVERHEAD
argument_list|,
name|rate
argument_list|,
literal|0
argument_list|)
operator|<<
name|M_BITS
expr_stmt|;
comment|/* Error rate in percentage */
comment|/* XXX assuming small failures are ok */
name|errrate
operator|=
operator|(
operator|(
operator|(
name|ifp
operator|->
name|if_get_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|)
operator|+
name|ifp
operator|->
name|if_get_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_IERRORS
argument_list|)
operator|)
operator|/
literal|100
operator|)
operator|<<
name|M_BITS
operator|)
operator|/
literal|100
expr_stmt|;
name|res
operator|=
operator|(
name|overhead
operator|+
operator|(
name|nbits
operator|/
name|rate
operator|)
operator|)
operator|*
operator|(
operator|(
literal|1
operator|<<
name|S_FACTOR
operator|)
operator|/
operator|(
operator|(
literal|1
operator|<<
name|M_BITS
operator|)
operator|-
name|errrate
operator|)
operator|)
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|res
operator|>>
name|S_FACTOR
argument_list|)
return|;
undef|#
directive|undef
name|M_BITS
undef|#
directive|undef
name|S_FACTOR
block|}
end_function

begin_comment
comment|/*  * Add a Mesh Link Metric report IE to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_meshlmetric
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|uint8_t
name|flags
parameter_list|,
name|uint32_t
name|metric
parameter_list|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_MESHLINK
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|5
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|flags
expr_stmt|;
name|ADDWORD
argument_list|(
name|frm
argument_list|,
name|metric
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Add a Mesh Gate Announcement IE to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_meshgate
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_meshgann_ie
modifier|*
name|ie
parameter_list|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_MESHGANN
expr_stmt|;
comment|/* ie */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_MESHGANN_BASE_SZ
expr_stmt|;
comment|/* len */
operator|*
name|frm
operator|++
operator|=
name|ie
operator|->
name|gann_flags
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ie
operator|->
name|gann_hopcount
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ie
operator|->
name|gann_ttl
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|frm
argument_list|,
name|ie
operator|->
name|gann_addr
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|6
expr_stmt|;
name|ADDWORD
argument_list|(
name|frm
argument_list|,
name|ie
operator|->
name|gann_seq
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ie
operator|->
name|gann_interval
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ADDSHORT
end_undef

begin_undef
undef|#
directive|undef
name|ADDWORD
end_undef

begin_comment
comment|/*  * Initialize any mesh-specific node state.  */
end_comment

begin_function
name|void
name|ieee80211_mesh_node_init
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ni
operator|->
name|ni_mltimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ni
operator|->
name|ni_mlhtimer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cleanup any mesh-specific node state.  */
end_comment

begin_function
name|void
name|ieee80211_mesh_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ni
operator|->
name|ni_mltimer
argument_list|)
expr_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ni
operator|->
name|ni_mlhtimer
argument_list|)
expr_stmt|;
comment|/* NB: short-circuit callbacks after mesh_vdetach */
if|if
condition|(
name|vap
operator|->
name|iv_mesh
operator|!=
name|NULL
condition|)
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_peerdown
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_parse_meshid
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|ni
operator|->
name|ni_meshidlen
operator|=
name|ie
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_meshid
argument_list|,
name|ie
operator|+
literal|2
argument_list|,
name|ie
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup mesh-specific node state on neighbor discovery.  */
end_comment

begin_function
name|void
name|ieee80211_mesh_init_neighbor
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|ieee80211_parse_meshid
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|meshid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_mesh_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
argument_list|,
operator|(
literal|"not a MBSS vap"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_MESHCONF
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_add_meshconf
argument_list|(
name|bo
operator|->
name|bo_meshconf
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_MESHCONF
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|mesh_ioctl_get80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|uint8_t
name|tmpmeshid
index|[
name|IEEE80211_NWID_LEN
index|]
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
decl_stmt|;
name|struct
name|ieee80211req_mesh_route
modifier|*
name|imr
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|off
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_MBSS
condition|)
return|return
name|ENOSYS
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_MESH_ID
case|:
name|ireq
operator|->
name|i_len
operator|=
name|ms
operator|->
name|ms_idlen
expr_stmt|;
name|memcpy
argument_list|(
name|tmpmeshid
argument_list|,
name|ms
operator|->
name|ms_id
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|tmpmeshid
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_AP
case|:
name|ireq
operator|->
name|i_val
operator|=
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_AP
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_FWRD
case|:
name|ireq
operator|->
name|i_val
operator|=
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_FWD
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_GATE
case|:
name|ireq
operator|->
name|i_val
operator|=
operator|(
name|ms
operator|->
name|ms_flags
operator|&
name|IEEE80211_MESHFLAGS_GATE
operator|)
operator|!=
literal|0
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_TTL
case|:
name|ireq
operator|->
name|i_val
operator|=
name|ms
operator|->
name|ms_ttl
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_RTCMD
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
name|IEEE80211_MESH_RTCMD_LIST
case|:
name|len
operator|=
literal|0
expr_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|)
block|{
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|imr
argument_list|)
expr_stmt|;
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|ireq
operator|->
name|i_len
operator|||
name|ireq
operator|->
name|i_len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|imr
argument_list|)
condition|)
block|{
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
comment|/* XXX M_WAIT? */
name|p
operator|=
name|IEEE80211_MALLOC
argument_list|(
name|len
argument_list|,
name|M_TEMP
argument_list|,
name|IEEE80211_M_NOWAIT
operator||
name|IEEE80211_M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|off
operator|=
literal|0
expr_stmt|;
name|MESH_RT_LOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|rt
argument_list|,
argument|&ms->ms_routes
argument_list|,
argument|rt_next
argument_list|)
block|{
if|if
condition|(
name|off
operator|>=
name|len
condition|)
break|break;
name|imr
operator|=
operator|(
expr|struct
name|ieee80211req_mesh_route
operator|*
operator|)
operator|(
name|p
operator|+
name|off
operator|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|imr
operator|->
name|imr_dest
argument_list|,
name|rt
operator|->
name|rt_dest
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|imr
operator|->
name|imr_nexthop
argument_list|,
name|rt
operator|->
name|rt_nexthop
argument_list|)
expr_stmt|;
name|imr
operator|->
name|imr_metric
operator|=
name|rt
operator|->
name|rt_metric
expr_stmt|;
name|imr
operator|->
name|imr_nhops
operator|=
name|rt
operator|->
name|rt_nhops
expr_stmt|;
name|imr
operator|->
name|imr_lifetime
operator|=
name|ieee80211_mesh_rt_update
argument_list|(
name|rt
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|imr
operator|->
name|imr_lastmseq
operator|=
name|rt
operator|->
name|rt_lastmseq
expr_stmt|;
name|imr
operator|->
name|imr_flags
operator|=
name|rt
operator|->
name|rt_flags
expr_stmt|;
comment|/* last */
name|off
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|imr
argument_list|)
expr_stmt|;
block|}
name|MESH_RT_UNLOCK
argument_list|(
name|ms
argument_list|)
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|p
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ireq
operator|->
name|i_data
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|IEEE80211_FREE
argument_list|(
name|p
argument_list|,
name|M_TEMP
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MESH_RTCMD_FLUSH
case|:
case|case
name|IEEE80211_MESH_RTCMD_ADD
case|:
case|case
name|IEEE80211_MESH_RTCMD_DELETE
case|:
return|return
name|EINVAL
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
break|break;
case|case
name|IEEE80211_IOC_MESH_PR_METRIC
case|:
name|len
operator|=
name|strlen
argument_list|(
name|ms
operator|->
name|ms_pmetric
operator|->
name|mpm_descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ireq
operator|->
name|i_len
operator|<
name|len
condition|)
return|return
name|EINVAL
return|;
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|ms
operator|->
name|ms_pmetric
operator|->
name|mpm_descr
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ireq
operator|->
name|i_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_PR_PATH
case|:
name|len
operator|=
name|strlen
argument_list|(
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_descr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ireq
operator|->
name|i_len
operator|<
name|len
condition|)
return|return
name|EINVAL
return|;
name|ireq
operator|->
name|i_len
operator|=
name|len
expr_stmt|;
name|error
operator|=
name|copyout
argument_list|(
name|ms
operator|->
name|ms_ppath
operator|->
name|mpp_descr
argument_list|,
operator|(
name|uint8_t
operator|*
operator|)
name|ireq
operator|->
name|i_data
argument_list|,
name|len
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_GET
argument_list|(
name|mesh
argument_list|,
name|mesh_ioctl_get80211
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|mesh_ioctl_set80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|uint8_t
name|tmpmeshid
index|[
name|IEEE80211_NWID_LEN
index|]
decl_stmt|;
name|uint8_t
name|tmpaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|char
name|tmpproto
index|[
name|IEEE80211_MESH_PROTO_DSZ
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_MBSS
condition|)
return|return
name|ENOSYS
return|;
name|error
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_MESH_ID
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|!=
literal|0
operator|||
name|ireq
operator|->
name|i_len
operator|>
name|IEEE80211_MESHID_LEN
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|tmpmeshid
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|memset
argument_list|(
name|ms
operator|->
name|ms_id
argument_list|,
literal|0
argument_list|,
name|IEEE80211_NWID_LEN
argument_list|)
expr_stmt|;
name|ms
operator|->
name|ms_idlen
operator|=
name|ireq
operator|->
name|i_len
expr_stmt|;
name|memcpy
argument_list|(
name|ms
operator|->
name|ms_id
argument_list|,
name|tmpmeshid
argument_list|,
name|ireq
operator|->
name|i_len
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENETRESET
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_AP
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
name|ms
operator|->
name|ms_flags
operator||=
name|IEEE80211_MESHFLAGS_AP
expr_stmt|;
else|else
name|ms
operator|->
name|ms_flags
operator|&=
operator|~
name|IEEE80211_MESHFLAGS_AP
expr_stmt|;
name|error
operator|=
name|ENETRESET
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_FWRD
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
name|ms
operator|->
name|ms_flags
operator||=
name|IEEE80211_MESHFLAGS_FWD
expr_stmt|;
else|else
name|ms
operator|->
name|ms_flags
operator|&=
operator|~
name|IEEE80211_MESHFLAGS_FWD
expr_stmt|;
name|mesh_gatemode_setup
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_GATE
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
name|ms
operator|->
name|ms_flags
operator||=
name|IEEE80211_MESHFLAGS_GATE
expr_stmt|;
else|else
name|ms
operator|->
name|ms_flags
operator|&=
operator|~
name|IEEE80211_MESHFLAGS_GATE
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_TTL
case|:
name|ms
operator|->
name|ms_ttl
operator|=
operator|(
name|uint8_t
operator|)
name|ireq
operator|->
name|i_val
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_MESH_RTCMD
case|:
switch|switch
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
case|case
name|IEEE80211_MESH_RTCMD_LIST
case|:
return|return
name|EINVAL
return|;
case|case
name|IEEE80211_MESH_RTCMD_FLUSH
case|:
name|ieee80211_mesh_rt_flush
argument_list|(
name|vap
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MESH_RTCMD_ADD
case|:
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|)
operator|||
name|IEEE80211_ADDR_EQ
argument_list|(
name|broadcastaddr
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|)
condition|)
return|return
name|EINVAL
return|;
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
operator|&
name|tmpaddr
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|ieee80211_mesh_discover
argument_list|(
name|vap
argument_list|,
name|tmpaddr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_MESH_RTCMD_DELETE
case|:
name|ieee80211_mesh_rt_del
argument_list|(
name|vap
argument_list|,
name|ireq
operator|->
name|i_data
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
break|break;
case|case
name|IEEE80211_IOC_MESH_PR_METRIC
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|tmpproto
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpproto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|mesh_select_proto_metric
argument_list|(
name|vap
argument_list|,
name|tmpproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ENETRESET
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_IOC_MESH_PR_PATH
case|:
name|error
operator|=
name|copyin
argument_list|(
name|ireq
operator|->
name|i_data
argument_list|,
name|tmpproto
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpproto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|mesh_select_proto_path
argument_list|(
name|vap
argument_list|,
name|tmpproto
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|ENETRESET
expr_stmt|;
block|}
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_SET
argument_list|(
name|mesh
argument_list|,
name|mesh_ioctl_set80211
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

