begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/*  * Association id's are managed with a bit vector.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AID_SET
parameter_list|(
name|b
parameter_list|,
name|w
parameter_list|)
define|\
value|((w)[IEEE80211_AID(b) / 32] |= (1<< (IEEE80211_AID(b) % 32)))
end_define

begin_define
define|#
directive|define
name|IEEE80211_AID_CLR
parameter_list|(
name|b
parameter_list|,
name|w
parameter_list|)
define|\
value|((w)[IEEE80211_AID(b) / 32]&= ~(1<< (IEEE80211_AID(b) % 32)))
end_define

begin_define
define|#
directive|define
name|IEEE80211_AID_ISSET
parameter_list|(
name|b
parameter_list|,
name|w
parameter_list|)
define|\
value|((w)[IEEE80211_AID(b) / 32]& (1<< (IEEE80211_AID(b) % 32)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
end_ifdef

begin_define
define|#
directive|define
name|REFCNT_LOC
value|"%s (%s:%u) %p<%s> refcnt %d\n", __func__, func, line
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REFCNT_LOC
value|"%s %p<%s> refcnt %d\n", __func__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ieee80211_sta_join1
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|node_alloc
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int8_t
name|node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_setup_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|uint8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|inact
parameter_list|,
name|int
name|keymaxix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_reset
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_cleanup
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_erp_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_NODE
argument_list|,
literal|"80211node"
argument_list|,
literal|"802.11 node state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_node_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_node_alloc
operator|=
name|node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_cleanup
operator|=
name|node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_getrssi
operator|=
name|node_getrssi
expr_stmt|;
name|ic
operator|->
name|ic_node_getsignal
operator|=
name|node_getsignal
expr_stmt|;
comment|/* default station inactivity timer setings */
name|ic
operator|->
name|ic_inact_init
operator|=
name|IEEE80211_INACT_INIT
expr_stmt|;
name|ic
operator|->
name|ic_inact_auth
operator|=
name|IEEE80211_INACT_AUTH
expr_stmt|;
name|ic
operator|->
name|ic_inact_run
operator|=
name|IEEE80211_INACT_RUN
expr_stmt|;
name|ic
operator|->
name|ic_inact_probe
operator|=
name|IEEE80211_INACT_PROBE
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|/* NB: driver should override */
name|ic
operator|->
name|ic_max_aid
operator|=
name|IEEE80211_AID_DEF
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_INACT
expr_stmt|;
comment|/* inactivity processing */
block|}
end_function

begin_function
name|void
name|ieee80211_node_lateattach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_rsnparms
modifier|*
name|rsn
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_max_aid
operator|>
name|IEEE80211_AID_MAX
condition|)
name|ic
operator|->
name|ic_max_aid
operator|=
name|IEEE80211_AID_MAX
expr_stmt|;
name|MALLOC
argument_list|(
name|ic
operator|->
name|ic_aid_bitmap
argument_list|,
name|uint32_t
operator|*
argument_list|,
name|howmany
argument_list|(
name|ic
operator|->
name|ic_max_aid
argument_list|,
literal|32
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_aid_bitmap
operator|==
name|NULL
condition|)
block|{
comment|/* XXX no way to recover */
name|printf
argument_list|(
literal|"%s: no memory for AID bitmap!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_max_aid
operator|=
literal|0
expr_stmt|;
block|}
name|ieee80211_node_table_init
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
literal|"station"
argument_list|,
name|IEEE80211_INACT_INIT
argument_list|,
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_max_keyix
argument_list|)
expr_stmt|;
name|ieee80211_reset_bss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Setup "global settings" in the bss node so that 	 * each new station automatically inherits them. 	 */
name|rsn
operator|=
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
expr_stmt|;
comment|/* WEP, TKIP, and AES-CCM are always supported */
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_WEP
expr_stmt|;
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_TKIP
expr_stmt|;
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_CCM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_AES
condition|)
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_OCB
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_CKIP
condition|)
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_CKIP
expr_stmt|;
comment|/* 	 * Default unicast cipher to WEP for 802.1x use.  If 	 * WPA is enabled the management code will set these 	 * values to reflect. 	 */
name|rsn
operator|->
name|rsn_ucastcipher
operator|=
name|IEEE80211_CIPHER_WEP
expr_stmt|;
name|rsn
operator|->
name|rsn_ucastkeylen
operator|=
literal|104
operator|/
name|NBBY
expr_stmt|;
comment|/* 	 * WPA says the multicast cipher is the lowest unicast 	 * cipher supported.  But we skip WEP which would 	 * otherwise be used based on this criteria. 	 */
name|rsn
operator|->
name|rsn_mcastcipher
operator|=
name|IEEE80211_CIPHER_TKIP
expr_stmt|;
name|rsn
operator|->
name|rsn_mcastkeylen
operator|=
literal|128
operator|/
name|NBBY
expr_stmt|;
comment|/* 	 * We support both WPA-PSK and 802.1x; the one used 	 * is determined by the authentication mode and the 	 * setting of the PSK state. 	 */
name|rsn
operator|->
name|rsn_keymgmtset
operator|=
name|WPA_ASE_8021X_UNSPEC
operator||
name|WPA_ASE_8021X_PSK
expr_stmt|;
name|rsn
operator|->
name|rsn_keymgmt
operator|=
name|WPA_ASE_8021X_PSK
expr_stmt|;
name|ic
operator|->
name|ic_auth
operator|=
name|ieee80211_authenticator_get
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|=
name|NULL
expr_stmt|;
block|}
name|ieee80211_node_table_cleanup
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_aid_bitmap
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|ic
operator|->
name|ic_aid_bitmap
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_aid_bitmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Port authorize/unauthorize interfaces for use by an authenticator.  */
end_comment

begin_function
name|void
name|ieee80211_node_authorize
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_AUTH
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|ic
operator|->
name|ic_inact_run
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_unauthorize
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_AUTH
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|ic
operator|->
name|ic_inact_auth
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_inact
operator|>
name|ni
operator|->
name|ni_inact_reload
condition|)
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change the channel.  The rate set is also updated as  * to insure a consistent view by drivers.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_set_chan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|ic
operator|->
name|ic_bsschan
decl_stmt|;
if|#
directive|if
literal|0
block|KASSERT(chan != IEEE80211_CHAN_ANYC, ("bss channel not setup"));
else|#
directive|else
if|if
condition|(
name|chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
comment|/* XXX while scanning */
name|chan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
endif|#
directive|endif
name|ni
operator|->
name|ni_chan
operator|=
name|chan
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * XXX Gotta be careful here; the rate set returned by 		 * ieee80211_get_suprates is actually any HT rate 		 * set so blindly copying it will be bad.  We must 		 * install the legacy rate est in ni_rates and the 		 * HT rate set in ni_htrates. 		 */
name|ni
operator|->
name|ni_htrates
operator|=
operator|*
name|ieee80211_get_suphtrates
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|ni_rates
operator|=
operator|*
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Probe the curent channel, if allowed, while scanning.  * If the channel is not marked passive-only then send  * a probe request immediately.  Otherwise mark state and  * listen for beacons on the channel; if we receive something  * then we'll transmit a probe request.  */
end_comment

begin_function
name|void
name|ieee80211_probe_curchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
operator|==
literal|0
operator|||
name|force
condition|)
block|{
comment|/* 		 * XXX send both broadcast+directed probe request 		 */
name|ieee80211_send_probereq
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
name|ic
operator|->
name|ic_des_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ic
operator|->
name|ic_des_ssid
index|[
literal|0
index|]
operator|.
name|len
argument_list|,
name|ic
operator|->
name|ic_opt_ie
argument_list|,
name|ic
operator|->
name|ic_opt_ie_len
argument_list|)
expr_stmt|;
block|}
else|else
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_PROBECHAN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|copy_bss
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|nbss
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|obss
parameter_list|)
block|{
comment|/* propagate useful state */
name|nbss
operator|->
name|ni_authmode
operator|=
name|obss
operator|->
name|ni_authmode
expr_stmt|;
name|nbss
operator|->
name|ni_txpower
operator|=
name|obss
operator|->
name|ni_txpower
expr_stmt|;
name|nbss
operator|->
name|ni_vlan
operator|=
name|obss
operator|->
name|ni_vlan
expr_stmt|;
name|nbss
operator|->
name|ni_rsn
operator|=
name|obss
operator|->
name|ni_rsn
expr_stmt|;
comment|/* XXX statistics? */
block|}
end_function

begin_function
name|void
name|ieee80211_create_ibss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: creating ibss\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Create the station/neighbor table.  Note that for adhoc 	 * mode we make the initial inactivity timer longer since 	 * we create nodes only through discovery and they typically 	 * are long-lived associations. 	 */
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|nt
operator|->
name|nt_name
operator|=
literal|"station"
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|ic
operator|->
name|ic_inact_init
expr_stmt|;
block|}
else|else
block|{
name|nt
operator|->
name|nt_name
operator|=
literal|"neighbor"
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|ic
operator|->
name|ic_inact_run
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* XXX recovery? */
return|return;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_esslen
operator|=
name|ic
operator|->
name|ic_des_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_des_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|ni
operator|->
name|ni_capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_phytype
operator|==
name|IEEE80211_T_FH
condition|)
block|{
name|ni
operator|->
name|ni_fhdwell
operator|=
literal|200
expr_stmt|;
comment|/* XXX */
name|ni
operator|->
name|ni_fhindex
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SIBSS
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator||=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_des_bssid
argument_list|)
expr_stmt|;
else|else
block|{
name|get_random_bytes
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* clear group bit, add local bit */
name|ni
operator|->
name|ni_bssid
index|[
literal|0
index|]
operator|=
operator|(
name|ni
operator|->
name|ni_bssid
index|[
literal|0
index|]
operator|&
operator|~
literal|0x01
operator|)
operator||
literal|0x02
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_des_bssid
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
literal|0
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Fix the channel and related attributes. 	 */
name|ic
operator|->
name|ic_bsschan
operator|=
name|chan
expr_stmt|;
name|ieee80211_node_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Do mode-specific rate setup. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_FULL
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 			 * Use a mixed 11b/11g rate set. 			 */
name|ieee80211_set11gbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 			 * Force pure 11b rate set. 			 */
name|ieee80211_set11gbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|ieee80211_sta_join1
argument_list|(
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset bss state on transition to the INIT state.  * Clear any stations from the table (they have been  * deauth'd) and reset the bss node (clears key, rate  * etc. state).  */
end_comment

begin_function
name|void
name|ieee80211_reset_bss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|,
modifier|*
name|obss
decl_stmt|;
name|callout_drain
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|)
expr_stmt|;
name|ieee80211_node_table_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unable to setup inital BSS node"
operator|)
argument_list|)
expr_stmt|;
name|obss
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|obss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|obss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|match_ssid
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|nssid
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_ssid
name|ssids
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nssid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_esslen
operator|==
name|ssids
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|memcmp
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Test a node for suitability/compatibility.  */
end_comment

begin_function
specifier|static
name|int
name|check_bss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint8_t
name|rate
decl_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
return|return
literal|0
return|;
block|}
name|rate
operator|=
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_F_JOIN
operator||
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DOFRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|ic
operator|->
name|ic_des_nssid
operator|!=
literal|0
operator|&&
operator|!
name|match_ssid
argument_list|(
name|ni
argument_list|,
name|ic
operator|->
name|ic_des_nssid
argument_list|,
name|ic
operator|->
name|ic_des_ssid
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|ic
operator|->
name|ic_des_bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_comment
comment|/*  * Display node suitability/compatibility.  */
end_comment

begin_function
specifier|static
name|void
name|check_bss_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint8_t
name|rate
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
condition|)
name|fail
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x02
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x02
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x04
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
name|fail
operator||=
literal|0x04
expr_stmt|;
block|}
name|rate
operator|=
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_F_JOIN
operator||
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DOFRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
name|fail
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_des_nssid
operator|!=
literal|0
operator|&&
operator|!
name|match_ssid
argument_list|(
name|ni
argument_list|,
name|ic
operator|->
name|ic_des_nssid
argument_list|,
name|ic
operator|->
name|ic_des_ssid
argument_list|)
condition|)
name|fail
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|ic
operator|->
name|ic_des_bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
condition|)
name|fail
operator||=
literal|0x20
expr_stmt|;
name|printf
argument_list|(
literal|" %c %s"
argument_list|,
name|fail
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s%c"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|fail
operator|&
literal|0x20
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d%c"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|,
name|fail
operator|&
literal|0x01
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %+4d"
argument_list|,
name|ni
operator|->
name|ni_rssi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %2dM%c"
argument_list|,
operator|(
name|rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
name|fail
operator|&
literal|0x08
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s%c"
argument_list|,
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
condition|?
literal|"ess"
else|:
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
condition|?
literal|"ibss"
else|:
literal|"????"
argument_list|,
name|fail
operator|&
literal|0x02
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s%c "
argument_list|,
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
condition|?
literal|"wep"
else|:
literal|"no"
argument_list|,
name|fail
operator|&
literal|0x04
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fail
operator|&
literal|0x10
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_DEBUG */
end_comment

begin_comment
comment|/*  * Handle 802.11 ad hoc network merge.  The  * convention, set by the Wireless Ethernet Compatibility Alliance  * (WECA), is that an 802.11 station will change its BSSID to match  * the "oldest" 802.11 ad hoc network, on the same channel, that  * has the station's desired SSID.  The "oldest" 802.11 network  * sends beacons with the greatest TSF timestamp.  *  * The caller is assumed to validate TSF's before attempting a merge.  *  * Return !0 if the BSSID changed, 0 otherwise.  */
end_comment

begin_function
name|int
name|ieee80211_ibss_merge
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
if|if
condition|(
name|ni
operator|==
name|ic
operator|->
name|ic_bss
operator|||
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
condition|)
block|{
comment|/* unchanged, nothing to do */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|check_bss
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
condition|)
block|{
comment|/* capabilities mismatch */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: merge failed, capabilities mismatch\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_assoc
argument_list|(
name|ic
argument_list|)
condition|)
name|check_bss_debug
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ic
operator|->
name|ic_stats
operator|.
name|is_ibss_capmismatch
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: new bssid %s: %s preamble, %s slot time%s\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|?
literal|", protection"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|ieee80211_sta_join1
argument_list|(
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join the specified IBSS/BSS network.  The node is assumed to  * be passed in with a held reference.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_sta_join1
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|selbs
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|selbs
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|obss
decl_stmt|;
name|int
name|canreassoc
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
comment|/* 		 * Fillin the neighbor table; it will already 		 * exist if we are simply switching mastership. 		 * XXX ic_sta always setup so this is unnecessary? 		 */
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_name
operator|=
literal|"neighbor"
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|ic
operator|->
name|ic_inact_run
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Committed to selbs, setup state. 	 */
name|obss
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
comment|/* 	 * Check if old+new node have the same address in which 	 * case we can reassociate when operating in sta mode. 	 */
name|canreassoc
operator|=
operator|(
name|obss
operator|!=
name|NULL
operator|&&
name|ic
operator|->
name|ic_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|IEEE80211_ADDR_EQ
argument_list|(
name|obss
operator|->
name|ni_macaddr
argument_list|,
name|selbs
operator|->
name|ni_macaddr
argument_list|)
operator|)
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|=
name|selbs
expr_stmt|;
comment|/* NB: caller assumed to bump refcnt */
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
name|copy_bss
argument_list|(
name|selbs
argument_list|,
name|obss
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|obss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Delete unusable rates; we've already checked 	 * that the negotiated rate set is acceptable. 	 */
name|ieee80211_fix_rate
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|,
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_F_DODEL
operator||
name|IEEE80211_F_JOIN
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bsschan
operator|=
name|selbs
operator|->
name|ni_chan
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|ic
operator|->
name|ic_bsschan
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Set the erp state (mostly the slot time) to deal with 	 * the auto-select case; this should be redundant if the 	 * mode is locked. 	 */
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_initparams
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
if|if
condition|(
name|canreassoc
condition|)
block|{
comment|/* Reassociate */
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_ASSOC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Act as if we received a DEAUTH frame in case we 			 * are invoked from the RUN state.  This will cause 			 * us to try to re-authenticate if we are operating 			 * as a station. 			 */
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_AUTH
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_sta_join
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|se
operator|->
name|se_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* XXX msg */
return|return
literal|0
return|;
block|}
comment|/* 	 * Expand scan state into node's format. 	 * XXX may not need all this stuff 	 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|se
operator|->
name|se_bssid
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_esslen
operator|=
name|se
operator|->
name|se_ssid
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|se
operator|->
name|se_ssid
operator|+
literal|2
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rstamp
operator|=
name|se
operator|->
name|se_rstamp
expr_stmt|;
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|=
name|se
operator|->
name|se_tstamp
operator|.
name|tsf
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|se
operator|->
name|se_intval
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator|=
name|se
operator|->
name|se_capinfo
expr_stmt|;
comment|/* XXX shift to 11n channel if htinfo present */
name|ni
operator|->
name|ni_chan
operator|=
name|se
operator|->
name|se_chan
expr_stmt|;
name|ni
operator|->
name|ni_timoff
operator|=
name|se
operator|->
name|se_timoff
expr_stmt|;
name|ni
operator|->
name|ni_fhdwell
operator|=
name|se
operator|->
name|se_fhdwell
expr_stmt|;
name|ni
operator|->
name|ni_fhindex
operator|=
name|se
operator|->
name|se_fhindex
expr_stmt|;
name|ni
operator|->
name|ni_erp
operator|=
name|se
operator|->
name|se_erp
expr_stmt|;
name|ni
operator|->
name|ni_rssi
operator|=
name|se
operator|->
name|se_rssi
expr_stmt|;
name|ni
operator|->
name|ni_noise
operator|=
name|se
operator|->
name|se_noise
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_htcap_ie
operator|!=
name|NULL
condition|)
name|ieee80211_ht_node_init
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_htcap_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_htinfo_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_htinfo
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_htinfo_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_wpa_ie
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wpa_ie
argument_list|,
name|se
operator|->
name|se_wpa_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_rsn_ie
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_rsn_ie
argument_list|,
name|se
operator|->
name|se_rsn_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_wme_ie
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wme_ie
argument_list|,
name|se
operator|->
name|se_wme_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_ath_ie
operator|!=
name|NULL
condition|)
name|ieee80211_saveath
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_ath_ie
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_dtim_period
operator|=
name|se
operator|->
name|se_dtimperiod
expr_stmt|;
name|ic
operator|->
name|ic_dtim_count
operator|=
literal|0
expr_stmt|;
comment|/* NB: must be after ni_chan is setup */
name|ieee80211_setup_rates
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_rates
argument_list|,
name|se
operator|->
name|se_xrates
argument_list|,
name|IEEE80211_F_DOSORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_htcap_ie
operator|!=
name|NULL
condition|)
name|ieee80211_setup_htrates
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_htcap_ie
argument_list|,
name|IEEE80211_F_JOIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_htinfo_ie
operator|!=
name|NULL
condition|)
name|ieee80211_setup_basic_htrates
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_htinfo_ie
argument_list|)
expr_stmt|;
return|return
name|ieee80211_sta_join1
argument_list|(
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave the specified IBSS/BSS network.  The node is assumed to  * be passed in with a held reference.  */
end_comment

begin_function
name|void
name|ieee80211_sta_leave
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ic
operator|->
name|ic_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|node_alloc
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|MALLOC
argument_list|(
name|ni
argument_list|,
expr|struct
name|ieee80211_node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim any resources in a node and reset any critical  * state.  Typically nodes are free'd immediately after,  * but in some cases the storage may be reused so we need  * to insure consistent state (should probably fix that).  */
end_comment

begin_function
specifier|static
name|void
name|node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* NB: preserve ni_table */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|ic
operator|->
name|ic_ps_sta
operator|--
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_PWR_MGT
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"[%s] power save mode off, %u sta's in ps mode\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_ps_sta
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear AREF flag that marks the authorization refcnt bump 	 * has happened.  This is probably not needed as the node 	 * should always be removed from the table so not found but 	 * do it just in case. 	 */
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_AREF
expr_stmt|;
comment|/* 	 * Drain power save queue and, if needed, clear TIM. 	 */
if|if
condition|(
name|ieee80211_node_saveq_drain
argument_list|(
name|ni
argument_list|)
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_set_tim
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_associd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|ni
operator|->
name|ni_challenge
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_challenge
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Preserve SSID, WPA, and WME ie's so the bss node is 	 * reusable during a re-auth/re-assoc state transition. 	 * If we remove these data they will not be recreated 	 * because they come from a probe-response or beacon frame 	 * which cannot be expected prior to the association-response. 	 * This should not be an issue when operating in other modes 	 * as stations leaving always go through a full state transition 	 * which will rebuild this state. 	 * 	 * XXX does this leave us open to inheriting old state? 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ni
operator|->
name|ni_rxfrag
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Must be careful here to remove any key map entry w/o a LOR. 	 */
name|ieee80211_node_delucastkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|void
name|node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ic
operator|->
name|ic_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_wpa_ie
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ni
operator|->
name|ni_wpa_ie
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_rsn_ie
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ni
operator|->
name|ni_rsn_ie
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_wme_ie
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ni
operator|->
name|ni_wme_ie
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_ath_ie
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ni
operator|->
name|ni_ath_ie
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_DESTROY
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ni
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int8_t
name|node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
return|return
name|ni
operator|->
name|ni_rssi
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
operator|*
name|rssi
operator|=
name|ni
operator|->
name|ni_rssi
expr_stmt|;
operator|*
name|noise
operator|=
name|ni
operator|->
name|ni_noise
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_setup_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s> in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|ieee80211_node_initref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|ni
operator|->
name|ni_chan
operator|=
name|IEEE80211_CHAN_ANYC
expr_stmt|;
name|ni
operator|->
name|ni_authmode
operator|=
name|IEEE80211_AUTH_OPEN
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_txpowlimit
expr_stmt|;
comment|/* max power */
name|ieee80211_crypto_resetkey
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|nt
operator|->
name|nt_inact_init
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|ni
operator|->
name|ni_ath_defkeyix
operator|=
literal|0x7fff
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_INIT
argument_list|(
name|ni
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nt
operator|->
name|nt_hash
index|[
name|hash
index|]
argument_list|,
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|nt
expr_stmt|;
name|ni
operator|->
name|ni_ic
operator|=
name|ic
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_alloc_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_setup_node
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
else|else
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Craft a temporary node suitable for sending a management frame  * to the specified station.  We craft only as much state as we  * need to do the work since the node will be immediately reclaimed  * once the send completes.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_tmp_node
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ieee80211_node_initref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_txpower
expr_stmt|;
comment|/* NB: required by ieee80211_fix_rate */
name|ieee80211_node_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_crypto_resetkey
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
comment|/* XXX optimize away */
name|IEEE80211_NODE_SAVEQ_INIT
argument_list|(
name|ni
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|NULL
expr_stmt|;
comment|/* NB: pedantic */
name|ni
operator|->
name|ni_ic
operator|=
name|ic
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX msg */
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_dup_bss
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_setup_node
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
comment|/* 		 * Inherit from ic_bss. 		 */
name|ni
operator|->
name|ni_authmode
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_txpower
expr_stmt|;
name|ni
operator|->
name|ni_vlan
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_vlan
expr_stmt|;
comment|/* XXX?? */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ieee80211_node_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rsn
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
expr_stmt|;
block|}
else|else
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|_ieee80211_find_node_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|_ieee80211_find_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ni
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
end_ifdef

begin_define
define|#
directive|define
name|_ieee80211_find_node
parameter_list|(
name|nt
parameter_list|,
name|mac
parameter_list|)
define|\
value|_ieee80211_find_node_debug(nt, mac, func, line)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Fake up a node; this handles node discovery in adhoc mode.  * Note that for the driver's benefit we we treat this like  * an association so the driver has an opportunity to setup  * it's private state.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_fakeup_adhoc_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: mac<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_dup_bss
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX no rate negotiation; just dup */
name|ni
operator|->
name|ni_rates
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rates
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 			 * In adhoc demo mode there are no management 			 * frames to use to discover neighbor capabilities, 			 * so blindly propagate the local configuration  			 * so we can do interesting things (e.g. use 			 * WME to disable ACK's). 			 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_FF
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_FF
expr_stmt|;
block|}
comment|/* XXX not right for 802.1x/WPA */
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_init_neighbor
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|ni
operator|->
name|ni_esslen
operator|=
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|sp
operator|->
name|ssid
operator|+
literal|2
argument_list|,
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
name|sp
operator|->
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ni
operator|->
name|ni_tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|sp
operator|->
name|bintval
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator|=
name|sp
operator|->
name|capinfo
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_curchan
expr_stmt|;
name|ni
operator|->
name|ni_fhdwell
operator|=
name|sp
operator|->
name|fhdwell
expr_stmt|;
name|ni
operator|->
name|ni_fhindex
operator|=
name|sp
operator|->
name|fhindex
expr_stmt|;
name|ni
operator|->
name|ni_erp
operator|=
name|sp
operator|->
name|erp
expr_stmt|;
name|ni
operator|->
name|ni_timoff
operator|=
name|sp
operator|->
name|timoff
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|wme
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wme_ie
argument_list|,
name|sp
operator|->
name|wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|wpa
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wpa_ie
argument_list|,
name|sp
operator|->
name|wpa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|rsn
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_rsn_ie
argument_list|,
name|sp
operator|->
name|rsn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|ath
operator|!=
name|NULL
condition|)
name|ieee80211_saveath
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|ath
argument_list|)
expr_stmt|;
comment|/* NB: must be after ni_chan is setup */
name|ieee80211_setup_rates
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|rates
argument_list|,
name|sp
operator|->
name|xrates
argument_list|,
name|IEEE80211_F_DOSORT
operator||
name|IEEE80211_F_DOFRATE
operator||
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DODEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do node discovery in adhoc mode on receipt of a beacon  * or probe response frame.  Note that for the driver's  * benefit we we treat this like an association so the  * driver has an opportunity to setup it's private state.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_add_neighbor
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: mac<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_dup_bss
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
comment|/* XXX alloc_node? */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_init_neighbor
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX not right for 802.1x/WPA */
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_CTL
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL)
end_define

begin_define
define|#
directive|define
name|IS_PSPOLL
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_PS_POLL)
end_define

begin_define
define|#
directive|define
name|IS_BAR
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_BAR)
end_define

begin_comment
comment|/*  * Locate the node for sender, track state, and then pass the  * (referenced) node up to the 802.11 layer for its use.  We  * are required to pass some node so we fall back to ic_bss  * when this frame is from an unknown sender.  The 802.11 layer  * knows this means the sender wasn't in the node table and  * acts accordingly.   */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_rxnode_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_rxnode
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* XXX check ic_bss first in station mode */
comment|/* XXX 4-address frames? */
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CTL
argument_list|(
name|wh
argument_list|)
operator|&&
operator|!
name|IS_PSPOLL
argument_list|(
name|wh
argument_list|)
operator|&&
operator|!
name|IS_BAR
argument_list|(
name|wh
argument_list|)
comment|/*&& !IS_RTS(ah)*/
condition|)
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
else|else
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Like ieee80211_find_rxnode but use the supplied h/w  * key index as a hint to locate the node in the key  * mapping table.  If an entry is present at the key  * index we return it; otherwise do a normal lookup and  * update the mapping table if the station has a unicast  * key assigned to it.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_rxnode_withkey_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
name|ieee80211_keyix
name|keyix
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_rxnode_withkey
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
name|ieee80211_keyix
name|keyix
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|)
name|ni
operator|=
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
expr_stmt|;
else|else
name|ni
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|IS_CTL
argument_list|(
name|wh
argument_list|)
operator|&&
operator|!
name|IS_PSPOLL
argument_list|(
name|wh
argument_list|)
operator|&&
operator|!
name|IS_BAR
argument_list|(
name|wh
argument_list|)
comment|/*&& !IS_RTS(ah)*/
condition|)
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
else|else
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the station has a unicast key cache slot 			 * assigned update the key->node mapping table. 			 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
comment|/* XXX can keyixmap[keyix] != NULL? */
if|if
condition|(
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: add key map entry %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|IS_BAR
end_undef

begin_undef
undef|#
directive|undef
name|IS_PSPOLL
end_undef

begin_undef
undef|#
directive|undef
name|IS_CTL
end_undef

begin_comment
comment|/*  * Return a reference to the appropriate node for sending  * a data frame.  This handles node discovery in adhoc networks.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_txnode_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_txnode
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* 	 * The destination address should be in the node table 	 * unless this is a multicast/broadcast frame.  We can 	 * also optimize station mode operation, all frames go 	 * to the bss node. 	 */
comment|/* XXX can't hold lock across dup_bss 'cuz of recursive locking */
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|IEEE80211_IS_MULTICAST
argument_list|(
name|macaddr
argument_list|)
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
else|else
block|{
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_associd
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Station is not associated; don't permit the 			 * data frame to be sent by returning NULL.  This 			 * is kinda a kludge but the least intrusive way 			 * to add this check into all drivers. 			 */
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
comment|/* NB: null's ni */
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 			 * In adhoc mode cons up a node for the destination. 			 * Note that we need an additional reference for the 			 * caller to be consistent with _ieee80211_find_node. 			 */
name|ni
operator|=
name|ieee80211_fakeup_adhoc_node
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"[%s] no node, discard frame (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nonode
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Like find but search based on the ssid too.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_with_ssid_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|,
name|u_int
name|ssidlen
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ssid
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node_with_ssid
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|macaddr
parameter_list|,
name|u_int
name|ssidlen
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ssid
parameter_list|)
endif|#
directive|endif
block|{
define|#
directive|define
name|MATCH_SSID
parameter_list|(
name|ni
parameter_list|,
name|ssid
parameter_list|,
name|ssidlen
parameter_list|)
define|\
value|(ni->ni_esslen == ssidlen&& memcmp(ni->ni_essid, ssid, ssidlen) == 0)
specifier|static
specifier|const
name|uint8_t
name|zeromac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
comment|/* 	 * A mac address that is all zero means match only the ssid; 	 * otherwise we must match both. 	 */
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|macaddr
argument_list|,
name|zeromac
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|MATCH_SSID
argument_list|(
name|ni
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
condition|)
break|break;
block|}
block|}
else|else
block|{
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
operator|&&
name|MATCH_SSID
argument_list|(
name|ni
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|REFCNT_LOC
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
undef|#
directive|undef
name|MATCH_SSID
block|}
end_function

begin_function
specifier|static
name|void
name|_ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s> in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|nt
operator|!=
name|NULL
condition|?
name|nt
operator|->
name|nt_name
else|:
literal|"<gone>"
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
block|}
name|ic
operator|->
name|ic_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_free_node_debug
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
block|{
comment|/* 			 * Last reference, reclaim state. 			 */
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|==
literal|1
operator|&&
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_keyix
name|keyix
decl_stmt|;
comment|/* 			 * Check for a last reference in the key mapping table. 			 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
if|if
condition|(
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|ni
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s> clear key map entry"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX needed? */
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reclaim a unicast key and clear any key cache state.  */
end_comment

begin_function
name|int
name|ieee80211_node_delucastkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|nikey
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|;
name|int
name|isowned
decl_stmt|,
name|status
decl_stmt|;
comment|/* 	 * NB: We must beware of LOR here; deleting the key 	 * can cause the crypto layer to block traffic updates 	 * which can generate a LOR against the node table lock; 	 * grab it here and stash the key index for our use below. 	 * 	 * Must also beware of recursion on the node table lock. 	 * When called from node_cleanup we may already have 	 * the node table lock held.  Unfortunately there's no 	 * way to separate out this path so we must do this 	 * conditionally. 	 */
name|isowned
operator|=
name|IEEE80211_NODE_IS_LOCKED
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isowned
condition|)
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
name|status
operator|=
name|ieee80211_crypto_delkey
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|)
block|{
name|nikey
operator|=
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
empty_stmt|;
block|}
else|else
name|nikey
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isowned
condition|)
name|IEEE80211_NODE_UNLOCK
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|nikey
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|nikey
operator|==
name|ni
argument_list|,
operator|(
literal|"key map out of sync, ni %p nikey %p"
operator|,
name|ni
operator|,
name|nikey
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: delete key map entry %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim a node.  If this is the last reference count then  * do the normal free work.  Otherwise remove it from the node  * table and mark it gone by clearing the back-reference.  */
end_comment

begin_function
specifier|static
name|void
name|node_reclaim
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ieee80211_keyix
name|keyix
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: remove %p<%s> from %s table, refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear any entry in the unicast key mapping table. 	 * We need to do it here so rx lookups don't find it 	 * in the mapping table even if it's not in the hash 	 * table.  We cannot depend on the mapping table entry 	 * being cleared because the node may not be free'd. 	 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|ni
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s> clear key map entry\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* NB: don't need free */
block|}
if|if
condition|(
operator|!
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
block|{
comment|/* 		 * Other references are present, just remove the 		 * node from the table so it cannot be found.  When 		 * the references are dropped storage will be 		 * reclaimed. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|NULL
expr_stmt|;
comment|/* clear reference */
block|}
else|else
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_free_allnodes_locked
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: free all nodes in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ni
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
block|}
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Timeout inactive stations and do related housekeeping.  * Note that we cannot hold the node lock while sending a  * frame as this would lead to a LOR.  Instead we use a  * generation number to mark nodes that we've scanned and  * drop the lock and restart a scan if we have to time out  * a node.  Since we are single-threaded by virtue of  * controlling the inactivity timer we can be sure this will  * process each node only once.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_timeout_stations
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|int
name|isadhoc
decl_stmt|;
name|isadhoc
operator|=
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|)
expr_stmt|;
name|IEEE80211_SCAN_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|++
name|nt
operator|->
name|nt_scangen
expr_stmt|;
name|restart
label|:
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_scangen
operator|==
name|gen
condition|)
comment|/* previously handled */
continue|continue;
name|ni
operator|->
name|ni_scangen
operator|=
name|gen
expr_stmt|;
comment|/* 		 * Ignore entries for which have yet to receive an 		 * authentication frame.  These are transient and 		 * will be reclaimed when the last reference to them 		 * goes away (when frame xmits complete). 		 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AREF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Free fragment if not needed anymore 		 * (last fragment older than 1s). 		 * XXX doesn't belong here 		 */
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|ticks
operator|>
name|ni
operator|->
name|ni_rxfragstamp
operator|+
name|hz
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ni
operator|->
name|ni_inact
operator|>
literal|0
condition|)
name|ni
operator|->
name|ni_inact
operator|--
expr_stmt|;
comment|/* 		 * Special case ourself; we may be idle for extended periods 		 * of time and regardless reclaiming our state is wrong. 		 */
if|if
condition|(
name|ni
operator|==
name|ic
operator|->
name|ic_bss
condition|)
continue|continue;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
operator|||
name|isadhoc
condition|)
block|{
comment|/* 			 * Age frames on the power save queue. 			 */
if|if
condition|(
name|ieee80211_node_saveq_age
argument_list|(
name|ni
argument_list|)
operator|!=
literal|0
operator|&&
name|IEEE80211_NODE_SAVEQ_QLEN
argument_list|(
name|ni
argument_list|)
operator|==
literal|0
operator|&&
name|ic
operator|->
name|ic_set_tim
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Probe the station before time it out.  We 			 * send a null data frame which may not be 			 * universally supported by drivers (need it 			 * for ps-poll support so it should be...). 			 * 			 * XXX don't probe the station unless we've 			 *     received a frame from them (and have 			 *     some idea of the rates they are capable 			 *     of); this will get fixed more properly 			 *     soon with better handling of the rate set. 			 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_INACT
operator|)
operator|&&
operator|(
literal|0
operator|<
name|ni
operator|->
name|ni_inact
operator|&&
name|ni
operator|->
name|ni_inact
operator|<=
name|ic
operator|->
name|ic_inact_probe
operator|)
operator|&&
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INACT
operator||
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"probe station due to inactivity"
argument_list|)
expr_stmt|;
comment|/* 				 * Grab a reference before unlocking the table 				 * so the node cannot be reclaimed before we 				 * send the frame. ieee80211_send_nulldata 				 * understands we've done this and reclaims the 				 * ref for us as needed. 				 */
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_send_nulldata
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX stat? */
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_INACT
operator|)
operator|&&
name|ni
operator|->
name|ni_inact
operator|<=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INACT
operator||
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"station timed out due to inactivity "
literal|"(refcnt %u)"
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Send a deauthenticate frame and drop the station. 			 * This is somewhat complicated due to reference counts 			 * and locking.  At this point a station will typically 			 * have a reference count of 1.  ieee80211_node_leave 			 * will do a "free" of the node which will drop the 			 * reference count.  But in the meantime a reference 			 * wil be held by the deauth frame.  The actual reclaim 			 * of the node will happen either after the tx is 			 * completed or by ieee80211_node_leave. 			 * 			 * Separately we must drop the node lock before sending 			 * in case the driver takes a lock, as this can result 			 * in a LOR between the node lock and the driver lock. 			 */
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|,
name|IEEE80211_REASON_AUTH_EXPIRE
argument_list|)
expr_stmt|;
block|}
name|ieee80211_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_node_timeout
operator|++
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_SCAN_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|ieee80211_scan_timeout
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_timeout_stations
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_erp_timeout
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|,
name|IEEE80211_INACT_WAIT
operator|*
name|hz
argument_list|,
name|ieee80211_node_timeout
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_iterate_nodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|ieee80211_iter_func
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|IEEE80211_SCAN_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|++
name|nt
operator|->
name|nt_scangen
expr_stmt|;
name|restart
label|:
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_scangen
operator|!=
name|gen
condition|)
block|{
name|ni
operator|->
name|ni_scangen
operator|=
name|gen
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|arg
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_SCAN_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dump_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|printf
argument_list|(
literal|"0x%p: mac %s refcnt %d\n"
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tscangen %u authmode %u flags 0x%x\n"
argument_list|,
name|ni
operator|->
name|ni_scangen
argument_list|,
name|ni
operator|->
name|ni_authmode
argument_list|,
name|ni
operator|->
name|ni_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tassocid 0x%x txpower %u vlan %u\n"
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|,
name|ni
operator|->
name|ni_txpower
argument_list|,
name|ni
operator|->
name|ni_vlan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttxseq %u rxseq %u fragno %u rxfragstamp %u\n"
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
argument_list|,
name|ni
operator|->
name|ni_rxseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|,
name|ni
operator|->
name|ni_rxseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|&
name|IEEE80211_SEQ_FRAG_MASK
argument_list|,
name|ni
operator|->
name|ni_rxfragstamp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trstamp %u rssi %d noise %d intval %u capinfo 0x%x\n"
argument_list|,
name|ni
operator|->
name|ni_rstamp
argument_list|,
name|ni
operator|->
name|ni_rssi
argument_list|,
name|ni
operator|->
name|ni_noise
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbssid %s essid \"%.*s\" channel %u:0x%x\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfails %u inact %u txrate %u\n"
argument_list|,
name|ni
operator|->
name|ni_fails
argument_list|,
name|ni
operator|->
name|ni_inact
argument_list|,
name|ni
operator|->
name|ni_txrate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\thtcap %x htparam %x htctlchan %u ht2ndchan %u\n"
argument_list|,
name|ni
operator|->
name|ni_htcap
argument_list|,
name|ni
operator|->
name|ni_htparam
argument_list|,
name|ni
operator|->
name|ni_htctlchan
argument_list|,
name|ni
operator|->
name|ni_ht2ndchan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\thtopmode %x htstbc %x chw %u\n"
argument_list|,
name|ni
operator|->
name|ni_htopmode
argument_list|,
name|ni
operator|->
name|ni_htstbc
argument_list|,
name|ni
operator|->
name|ni_chw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dump_nodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|ieee80211_iterate_nodes
argument_list|(
name|nt
argument_list|,
operator|(
name|ieee80211_iter_func
operator|*
operator|)
name|ieee80211_dump_node
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_erp
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|ieee80211_beacon_notify
argument_list|(
name|ic
argument_list|,
name|IEEE80211_BEACON_ERP
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a station joining an 11g network.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_join_11g
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
comment|/* 	 * Station isn't capable of short slot time.  Bump 	 * the count of long slot time stations and disable 	 * use of short slot time.  Note that the actual switch 	 * over to long slot time use may not occur until the 	 * next beacon transmission (per sec. 7.3.1.4 of 11g). 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_longslotsta
operator|++
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"station needs long slot time, count %d"
argument_list|,
name|ic
operator|->
name|ic_longslotsta
argument_list|)
expr_stmt|;
comment|/* XXX vap's w/ conflicting needs won't work */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
comment|/* 			 * Don't force slot time when switched to turbo 			 * mode as non-ERP stations won't be present; this 			 * need only be done when on the normal G channel. 			 */
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the new station is not an ERP station 	 * then bump the counter and enable protection 	 * if configured. 	 */
if|if
condition|(
operator|!
name|ieee80211_iserp_rateset
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_nonerpsta
operator|++
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"station is !ERP, %d non-ERP stations associated"
argument_list|,
name|ic
operator|->
name|ic_nonerpsta
argument_list|)
expr_stmt|;
comment|/* 		 * If station does not support short preamble 		 * then we must enable use of Barker preamble. 		 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"station needs long preamble"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEBARKER
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
block|}
comment|/* 		 * If protection is configured, enable it. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|!=
name|IEEE80211_PROT_NONE
operator|&&
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|1
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: enable use of protection\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEPROT
expr_stmt|;
name|ieee80211_notify_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ERP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_join
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|resp
parameter_list|)
block|{
name|int
name|newassoc
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|aid
decl_stmt|;
comment|/* 		 * It would be good to search the bitmap 		 * more efficiently, but this will do for now. 		 */
for|for
control|(
name|aid
operator|=
literal|1
init|;
name|aid
operator|<
name|ic
operator|->
name|ic_max_aid
condition|;
name|aid
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_AID_ISSET
argument_list|(
name|aid
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|aid
operator|>=
name|ic
operator|->
name|ic_max_aid
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|resp
argument_list|,
name|IEEE80211_REASON_ASSOC_TOOMANY
argument_list|)
expr_stmt|;
name|ieee80211_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
return|return;
block|}
name|ni
operator|->
name|ni_associd
operator|=
name|aid
operator||
literal|0xc000
expr_stmt|;
name|IEEE80211_AID_SET
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_sta_assoc
operator|++
expr_stmt|;
name|newassoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_FULL
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_node_join_11g
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
name|newassoc
operator|=
literal|0
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
name|ni
argument_list|,
literal|"station %sassociated at aid %d: %s preamble, %s slot time%s%s%s%s%s"
argument_list|,
name|newassoc
condition|?
literal|""
else|:
literal|"re"
argument_list|,
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|?
literal|", protection"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|?
literal|", QoS"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|?
operator|(
name|ni
operator|->
name|ni_chw
operator|==
literal|20
condition|?
literal|", HT20"
else|:
literal|", HT40"
operator|)
else|:
literal|""
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_FF
argument_list|)
condition|?
literal|", fast-frames"
else|:
literal|""
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_TURBOP
argument_list|)
condition|?
literal|", turbo"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* give driver a chance to setup state like ni_txrate */
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
name|newassoc
argument_list|)
expr_stmt|;
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|resp
argument_list|,
name|IEEE80211_STATUS_SUCCESS
argument_list|)
expr_stmt|;
comment|/* tell the authenticator about new station */
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_join
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_join
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_join
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|newassoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_protection
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%d non ERP stations, flags 0x%x"
operator|,
name|ic
operator|->
name|ic_nonerpsta
operator|,
name|ic
operator|->
name|ic_flags_ext
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEPROT
expr_stmt|;
comment|/* XXX verify mode? */
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHPREAMBLE
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
name|ieee80211_notify_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a station leaving an 11g network.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_leave_11g
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
argument_list|,
operator|(
literal|"not in 11g, bss %u:0x%x, curmode %u"
operator|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
operator|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_flags
operator|,
name|ic
operator|->
name|ic_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If a long slot station do the slot time bookkeeping. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_longslotsta
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus long slot station count %d"
operator|,
name|ic
operator|->
name|ic_longslotsta
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_longslotsta
operator|--
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"long slot time station leaves, count now %d"
argument_list|,
name|ic
operator|->
name|ic_longslotsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_longslotsta
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Re-enable use of short slot time if supported 			 * and not operating in IBSS mode (per spec). 			 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_IBSS
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: re-enable use of short slot time\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If a non-ERP station do the protection-related bookkeeping. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_ERP
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_nonerpsta
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus non-ERP station count %d"
operator|,
name|ic
operator|->
name|ic_nonerpsta
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_nonerpsta
operator|--
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"non-ERP station leaves, count now %d%s"
argument_list|,
name|ic
operator|->
name|ic_nonerpsta
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
condition|?
literal|" (non-ERP sta present)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: disable use of protection\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|disable_protection
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Time out presence of an overlapping bss with non-ERP  * stations.  When operating in hostap mode we listen for  * beacons from other stations and if we identify a non-ERP  * station is present we enable protection.  To identify  * when all non-ERP stations are gone we time out this  * condition.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_erp_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|&&
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastnonerp
operator|+
name|IEEE80211_NONERP_PRESENT_AGE
argument_list|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s\n"
argument_list|,
literal|"age out non-ERP sta present on channel"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_NONERP_PR
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
condition|)
name|disable_protection
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle bookkeeping for station deauthentication/disassociation  * when operating as an ap.  */
end_comment

begin_function
name|void
name|ieee80211_node_leave
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
name|ni
argument_list|,
literal|"station with aid %d leaves"
argument_list|,
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"unexpected operating mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If node wasn't previously associated all 	 * we need to do is reclaim the reference. 	 */
comment|/* XXX ibss mode bypasses 11g and notification */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Tell the authenticator the station is leaving. 	 * Note that we must do this before yanking the 	 * association id as the authenticator uses the 	 * associd to locate it's state block. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_associd
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_sta_assoc
operator|--
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_FULL
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_node_leave_11g
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup station state.  In particular clear various 	 * state that might otherwise be reused if the node 	 * is reused before the reference count goes to zero 	 * (and memory is reclaimed). 	 */
name|ieee80211_sta_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Remove the node from any table it's recorded in and 	 * drop the caller's reference.  Removal from the table 	 * is important to insure the node is not reprocessed 	 * for inactivity. 	 */
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int8_t
name|ieee80211_getrssi
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|NZ
parameter_list|(
name|x
parameter_list|)
value|((x) == 0 ? 1 : (x))
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|int
name|rssi_samples
decl_stmt|;
name|int32_t
name|rssi_total
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|rssi_total
operator|=
literal|0
expr_stmt|;
name|rssi_samples
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
comment|/* average of all ibss neighbors */
case|case
name|IEEE80211_M_AHDEMO
case|:
comment|/* average of all neighbors */
case|case
name|IEEE80211_M_HOSTAP
case|:
comment|/* average of all associated stations */
comment|/* XXX locking */
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
condition|)
block|{
name|int8_t
name|rssi
init|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
decl_stmt|;
if|if
condition|(
name|rssi
operator|!=
literal|0
condition|)
block|{
name|rssi_samples
operator|++
expr_stmt|;
name|rssi_total
operator|+=
name|rssi
expr_stmt|;
block|}
block|}
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* XXX */
case|case
name|IEEE80211_M_STA
case|:
comment|/* use stats from associated ap */
default|default:
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
name|rssi_total
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|rssi_samples
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|rssi_total
operator|/
name|NZ
argument_list|(
name|rssi_samples
argument_list|)
return|;
undef|#
directive|undef
name|NZ
block|}
end_function

begin_function
name|void
name|ieee80211_getsignal
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|==
name|NULL
condition|)
comment|/* NB: shouldn't happen */
return|return;
name|ic
operator|->
name|ic_node_getsignal
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|,
name|rssi
argument_list|,
name|noise
argument_list|)
expr_stmt|;
comment|/* for non-station mode return avg'd rssi accounting */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
operator|*
name|rssi
operator|=
name|ieee80211_getrssi
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Node table support.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_table_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|inact
parameter_list|,
name|int
name|keyixmax
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %s table, inact %u\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|inact
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_ic
operator|=
name|ic
expr_stmt|;
comment|/* XXX need unit */
name|IEEE80211_NODE_LOCK_INIT
argument_list|(
name|nt
argument_list|,
name|ic
operator|->
name|ic_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IEEE80211_SCAN_LOCK_INIT
argument_list|(
name|nt
argument_list|,
name|ic
operator|->
name|ic_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_name
operator|=
name|name
expr_stmt|;
name|nt
operator|->
name|nt_scangen
operator|=
literal|1
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|inact
expr_stmt|;
name|nt
operator|->
name|nt_keyixmax
operator|=
name|keyixmax
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmax
operator|>
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|nt
operator|->
name|nt_keyixmap
argument_list|,
expr|struct
name|ieee80211_node
operator|*
operator|*
argument_list|,
name|keyixmax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
operator|*
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|==
name|NULL
condition|)
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"Cannot allocate key index map with %u entries\n"
argument_list|,
name|keyixmax
argument_list|)
expr_stmt|;
block|}
else|else
name|nt
operator|->
name|nt_keyixmap
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_node_table_reset
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %s table\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_free_allnodes_locked
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_node_table_cleanup
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %s table\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_free_allnodes_locked
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX verify all entries are NULL */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: %s[%u] still active\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|nt
operator|->
name|nt_keyixmap
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
operator|=
name|NULL
expr_stmt|;
block|}
name|IEEE80211_SCAN_LOCK_DESTROY
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK_DESTROY
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

