begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/*  * Association id's are managed with a bit vector.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AID_SET
parameter_list|(
name|b
parameter_list|,
name|w
parameter_list|)
define|\
value|((w)[IEEE80211_AID(b) / 32] |= (1<< (IEEE80211_AID(b) % 32)))
end_define

begin_define
define|#
directive|define
name|IEEE80211_AID_CLR
parameter_list|(
name|b
parameter_list|,
name|w
parameter_list|)
define|\
value|((w)[IEEE80211_AID(b) / 32]&= ~(1<< (IEEE80211_AID(b) % 32)))
end_define

begin_define
define|#
directive|define
name|IEEE80211_AID_ISSET
parameter_list|(
name|b
parameter_list|,
name|w
parameter_list|)
define|\
value|((w)[IEEE80211_AID(b) / 32]& (1<< (IEEE80211_AID(b) % 32)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
end_ifdef

begin_define
define|#
directive|define
name|REFCNT_LOC
value|"%s (%s:%u) %p<%s> refcnt %d\n", __func__, func, line
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REFCNT_LOC
value|"%s %p<%s> refcnt %d\n", __func__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|node_alloc
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int8_t
name|node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_setup_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_free_allnodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_timeout_scan_candidates
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_timeout_stations
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_set_tim
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int
name|set
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|inact
parameter_list|,
name|int
name|keyixmax
parameter_list|,
name|void
function_decl|(
modifier|*
name|timeout
function_decl|)
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_cleanup
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_NODE
argument_list|,
literal|"80211node"
argument_list|,
literal|"802.11 node state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_node_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_node_alloc
operator|=
name|node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_cleanup
operator|=
name|node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_getrssi
operator|=
name|node_getrssi
expr_stmt|;
comment|/* default station inactivity timer setings */
name|ic
operator|->
name|ic_inact_init
operator|=
name|IEEE80211_INACT_INIT
expr_stmt|;
name|ic
operator|->
name|ic_inact_auth
operator|=
name|IEEE80211_INACT_AUTH
expr_stmt|;
name|ic
operator|->
name|ic_inact_run
operator|=
name|IEEE80211_INACT_RUN
expr_stmt|;
name|ic
operator|->
name|ic_inact_probe
operator|=
name|IEEE80211_INACT_PROBE
expr_stmt|;
comment|/* NB: driver should override */
name|ic
operator|->
name|ic_max_aid
operator|=
name|IEEE80211_AID_DEF
expr_stmt|;
name|ic
operator|->
name|ic_set_tim
operator|=
name|ieee80211_set_tim
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_lateattach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_rsnparms
modifier|*
name|rsn
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_max_aid
operator|>
name|IEEE80211_AID_MAX
condition|)
name|ic
operator|->
name|ic_max_aid
operator|=
name|IEEE80211_AID_MAX
expr_stmt|;
name|MALLOC
argument_list|(
name|ic
operator|->
name|ic_aid_bitmap
argument_list|,
name|u_int32_t
operator|*
argument_list|,
name|howmany
argument_list|(
name|ic
operator|->
name|ic_max_aid
argument_list|,
literal|32
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_aid_bitmap
operator|==
name|NULL
condition|)
block|{
comment|/* XXX no way to recover */
name|printf
argument_list|(
literal|"%s: no memory for AID bitmap!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_max_aid
operator|=
literal|0
expr_stmt|;
block|}
comment|/* XXX defer until using hostap/ibss mode */
name|ic
operator|->
name|ic_tim_len
operator|=
name|howmany
argument_list|(
name|ic
operator|->
name|ic_max_aid
argument_list|,
literal|8
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int8_t
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|ic
operator|->
name|ic_tim_bitmap
argument_list|,
name|u_int8_t
operator|*
argument_list|,
name|ic
operator|->
name|ic_tim_len
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_tim_bitmap
operator|==
name|NULL
condition|)
block|{
comment|/* XXX no way to recover */
name|printf
argument_list|(
literal|"%s: no memory for TIM bitmap!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
name|ieee80211_node_table_init
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
literal|"station"
argument_list|,
name|IEEE80211_INACT_INIT
argument_list|,
name|ic
operator|->
name|ic_crypto
operator|.
name|cs_max_keyix
argument_list|,
name|ieee80211_timeout_stations
argument_list|)
expr_stmt|;
name|ieee80211_node_table_init
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_scan
argument_list|,
literal|"scan"
argument_list|,
name|IEEE80211_INACT_SCAN
argument_list|,
literal|0
argument_list|,
name|ieee80211_timeout_scan_candidates
argument_list|)
expr_stmt|;
name|ieee80211_reset_bss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Setup "global settings" in the bss node so that 	 * each new station automatically inherits them. 	 */
name|rsn
operator|=
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
expr_stmt|;
comment|/* WEP, TKIP, and AES-CCM are always supported */
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_WEP
expr_stmt|;
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_TKIP
expr_stmt|;
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_CCM
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_AES
condition|)
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_OCB
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_CKIP
condition|)
name|rsn
operator|->
name|rsn_ucastcipherset
operator||=
literal|1
operator|<<
name|IEEE80211_CIPHER_CKIP
expr_stmt|;
comment|/* 	 * Default unicast cipher to WEP for 802.1x use.  If 	 * WPA is enabled the management code will set these 	 * values to reflect. 	 */
name|rsn
operator|->
name|rsn_ucastcipher
operator|=
name|IEEE80211_CIPHER_WEP
expr_stmt|;
name|rsn
operator|->
name|rsn_ucastkeylen
operator|=
literal|104
operator|/
name|NBBY
expr_stmt|;
comment|/* 	 * WPA says the multicast cipher is the lowest unicast 	 * cipher supported.  But we skip WEP which would 	 * otherwise be used based on this criteria. 	 */
name|rsn
operator|->
name|rsn_mcastcipher
operator|=
name|IEEE80211_CIPHER_TKIP
expr_stmt|;
name|rsn
operator|->
name|rsn_mcastkeylen
operator|=
literal|128
operator|/
name|NBBY
expr_stmt|;
comment|/* 	 * We support both WPA-PSK and 802.1x; the one used 	 * is determined by the authentication mode and the 	 * setting of the PSK state. 	 */
name|rsn
operator|->
name|rsn_keymgmtset
operator|=
name|WPA_ASE_8021X_UNSPEC
operator||
name|WPA_ASE_8021X_PSK
expr_stmt|;
name|rsn
operator|->
name|rsn_keymgmt
operator|=
name|WPA_ASE_8021X_PSK
expr_stmt|;
name|ic
operator|->
name|ic_auth
operator|=
name|ieee80211_authenticator_get
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|=
name|NULL
expr_stmt|;
block|}
name|ieee80211_node_table_cleanup
argument_list|(
operator|&
name|ic
operator|->
name|ic_scan
argument_list|)
expr_stmt|;
name|ieee80211_node_table_cleanup
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_aid_bitmap
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|ic
operator|->
name|ic_aid_bitmap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_aid_bitmap
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_tim_bitmap
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|ic
operator|->
name|ic_tim_bitmap
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_tim_bitmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Port authorize/unauthorize interfaces for use by an authenticator.  */
end_comment

begin_function
name|void
name|ieee80211_node_authorize
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_AUTH
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|ic
operator|->
name|ic_inact_run
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_unauthorize
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_AUTH
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change the channel.  The rate set is also updated as  * to insure a consistent view by drivers.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_chan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
comment|/* XXX while scanning */
name|chan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|chan
expr_stmt|;
name|ni
operator|->
name|ni_rates
operator|=
operator|*
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * AP scanning support.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|dump_chanlist
parameter_list|(
specifier|const
name|u_char
name|chans
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|int
name|i
decl_stmt|;
name|sep
operator|=
literal|" "
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_CHAN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isset
argument_list|(
name|chans
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%u"
argument_list|,
name|sep
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_DEBUG */
end_comment

begin_comment
comment|/*  * Initialize the channel set to scan based on the  * of available channels and the current PHY mode.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_reset_scan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* XXX ic_des_chan should be handled with ic_chan_active */
if|if
condition|(
name|ic
operator|->
name|ic_des_chan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
block|{
name|memset
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|)
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_des_chan
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|,
name|ic
operator|->
name|ic_chan_active
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_scan
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s: scan set:"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|dump_chanlist
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" start chan %u\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_DEBUG */
block|}
end_function

begin_comment
comment|/*  * Begin an active scan.  */
end_comment

begin_function
name|void
name|ieee80211_begin_scan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|reset
parameter_list|)
block|{
name|ic
operator|->
name|ic_scan
operator|.
name|nt_scangen
operator|++
expr_stmt|;
comment|/* 	 * In all but hostap mode scanning starts off in 	 * an active mode before switching to passive. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_ASCAN
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_scan_active
operator|++
expr_stmt|;
block|}
else|else
name|ic
operator|->
name|ic_stats
operator|.
name|is_scan_passive
operator|++
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"begin %s scan in %s mode, scangen %u\n"
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_ASCAN
operator|)
condition|?
literal|"active"
else|:
literal|"passive"
argument_list|,
name|ieee80211_phymode_name
index|[
name|ic
operator|->
name|ic_curmode
index|]
argument_list|,
name|ic
operator|->
name|ic_scan
operator|.
name|nt_scangen
argument_list|)
expr_stmt|;
comment|/* 	 * Clear scan state and flush any previously seen AP's. 	 */
name|ieee80211_reset_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|reset
condition|)
name|ieee80211_free_allnodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_scan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SCAN
expr_stmt|;
comment|/* Scan the next channel. */
name|ieee80211_next_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Switch to the next channel marked for scanning.  */
end_comment

begin_function
name|int
name|ieee80211_next_scan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
comment|/* 	 * Insure any previous mgt frame timeouts don't fire. 	 * This assumes the driver does the right thing in 	 * flushing anything queued in the driver and below. 	 */
name|ic
operator|->
name|ic_mgt_timer
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_PROBECHAN
expr_stmt|;
name|chan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|chan
operator|>
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|IEEE80211_CHAN_MAX
index|]
condition|)
name|chan
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|)
condition|)
block|{
name|clrbit
argument_list|(
name|ic
operator|->
name|ic_chan_scan
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: chan %d->%d\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|chan
expr_stmt|;
comment|/* 			 * XXX drivers should do this as needed, 			 * XXX for now maintain compatibility 			 */
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rates
operator|=
operator|*
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
do|while
condition|(
name|chan
operator|!=
name|ic
operator|->
name|ic_curchan
condition|)
do|;
name|ieee80211_end_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Probe the curent channel, if allowed, while scanning.  * If the channel is not marked passive-only then send  * a probe request immediately.  Otherwise mark state and  * listen for beacons on the channel; if we receive something  * then we'll transmit a probe request.  */
end_comment

begin_function
name|void
name|ieee80211_probe_curchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_PASSIVE
operator|)
operator|==
literal|0
operator|||
name|force
condition|)
block|{
comment|/* 		 * XXX send both broadcast+directed probe request 		 */
name|ieee80211_send_probereq
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|,
name|ic
operator|->
name|ic_des_essid
argument_list|,
name|ic
operator|->
name|ic_des_esslen
argument_list|,
name|ic
operator|->
name|ic_opt_ie
argument_list|,
name|ic
operator|->
name|ic_opt_ie_len
argument_list|)
expr_stmt|;
block|}
else|else
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_PROBECHAN
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|copy_bss
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|nbss
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|obss
parameter_list|)
block|{
comment|/* propagate useful state */
name|nbss
operator|->
name|ni_authmode
operator|=
name|obss
operator|->
name|ni_authmode
expr_stmt|;
name|nbss
operator|->
name|ni_txpower
operator|=
name|obss
operator|->
name|ni_txpower
expr_stmt|;
name|nbss
operator|->
name|ni_vlan
operator|=
name|obss
operator|->
name|ni_vlan
expr_stmt|;
name|nbss
operator|->
name|ni_rsn
operator|=
name|obss
operator|->
name|ni_rsn
expr_stmt|;
comment|/* XXX statistics? */
block|}
end_function

begin_function
name|void
name|ieee80211_create_ibss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: creating ibss\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 	 * Create the station/neighbor table.  Note that for adhoc 	 * mode we make the initial inactivity timer longer since 	 * we create nodes only through discovery and they typically 	 * are long-lived associations. 	 */
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|nt
operator|->
name|nt_name
operator|=
literal|"station"
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|ic
operator|->
name|ic_inact_init
expr_stmt|;
block|}
else|else
block|{
name|nt
operator|->
name|nt_name
operator|=
literal|"neighbor"
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|ic
operator|->
name|ic_inact_run
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* XXX recovery? */
return|return;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_esslen
operator|=
name|ic
operator|->
name|ic_des_esslen
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_des_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|ni
operator|->
name|ni_capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_phytype
operator|==
name|IEEE80211_T_FH
condition|)
block|{
name|ni
operator|->
name|ni_fhdwell
operator|=
literal|200
expr_stmt|;
comment|/* XXX */
name|ni
operator|->
name|ni_fhindex
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SIBSS
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator||=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_des_bssid
argument_list|)
expr_stmt|;
else|else
name|ni
operator|->
name|ni_bssid
index|[
literal|0
index|]
operator||=
literal|0x02
expr_stmt|;
comment|/* local bit for IBSS */
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_des_bssid
argument_list|)
expr_stmt|;
else|else
name|memset
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
literal|0
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
block|}
comment|/*  	 * Fix the channel and related attributes. 	 */
name|ieee80211_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Do mode-specific rate setup. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
comment|/* 		 * Use a mixed 11b/11g rate set. 		 */
name|ieee80211_set11gbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11B
condition|)
block|{
comment|/* 		 * Force pure 11b rate set. 		 */
name|ieee80211_set11gbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ieee80211_sta_join
argument_list|(
name|ic
argument_list|,
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_reset_bss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|,
modifier|*
name|obss
decl_stmt|;
name|ieee80211_node_table_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_scan
argument_list|)
expr_stmt|;
name|ieee80211_node_table_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_scan
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unable to setup inital BSS node"
operator|)
argument_list|)
expr_stmt|;
name|obss
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|obss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|obss
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX tunable */
end_comment

begin_define
define|#
directive|define
name|STA_FAILS_MAX
value|2
end_define

begin_comment
comment|/* assoc failures before ignored */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_match_bss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|u_int8_t
name|rate
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
condition|)
name|fail
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_des_chan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
name|ni
operator|->
name|ni_chan
operator|!=
name|ic
operator|->
name|ic_des_chan
condition|)
name|fail
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x02
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x02
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x04
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
name|fail
operator||=
literal|0x04
expr_stmt|;
block|}
name|rate
operator|=
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DOFRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
name|fail
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_des_esslen
operator|!=
literal|0
operator|&&
operator|(
name|ni
operator|->
name|ni_esslen
operator|!=
name|ic
operator|->
name|ic_des_esslen
operator|||
name|memcmp
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_des_essid
argument_list|,
name|ic
operator|->
name|ic_des_esslen
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|fail
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|ic
operator|->
name|ic_des_bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
condition|)
name|fail
operator||=
literal|0x20
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_fails
operator|>=
name|STA_FAILS_MAX
condition|)
name|fail
operator||=
literal|0x40
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_scan
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" %c %s"
argument_list|,
name|fail
operator|&
literal|0x40
condition|?
literal|'='
else|:
name|fail
operator|&
literal|0x80
condition|?
literal|'^'
else|:
name|fail
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s%c"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|fail
operator|&
literal|0x20
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d%c"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|,
name|fail
operator|&
literal|0x01
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %+4d"
argument_list|,
name|ni
operator|->
name|ni_rssi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %2dM%c"
argument_list|,
operator|(
name|rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
name|fail
operator|&
literal|0x08
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s%c"
argument_list|,
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
condition|?
literal|"ess"
else|:
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
condition|?
literal|"ibss"
else|:
literal|"????"
argument_list|,
name|fail
operator|&
literal|0x02
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s%c "
argument_list|,
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
condition|?
literal|"wep"
else|:
literal|"no"
argument_list|,
name|fail
operator|&
literal|0x04
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fail
operator|&
literal|0x10
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fail
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int8_t
name|maxrate
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
init|=
operator|&
name|ni
operator|->
name|ni_rates
decl_stmt|;
comment|/* NB: assumes rate set is sorted (happens on frame receive) */
return|return
name|rs
operator|->
name|rs_rates
index|[
name|rs
operator|->
name|rs_nrates
operator|-
literal|1
index|]
operator|&
name|IEEE80211_RATE_VAL
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the capabilities of two nodes and decide which is  * more desirable (return>0 if a is considered better).  Note  * that we assume compatibility/usability has already been checked  * so we don't need to (e.g. validate whether privacy is supported).  * Used to select the best scan candidate for association in a BSS.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_node_compare
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|b
parameter_list|)
block|{
name|u_int8_t
name|maxa
decl_stmt|,
name|maxb
decl_stmt|;
name|u_int8_t
name|rssia
decl_stmt|,
name|rssib
decl_stmt|;
name|int
name|weight
decl_stmt|;
comment|/* privacy support preferred */
if|if
condition|(
operator|(
name|a
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|&&
operator|(
name|b
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
name|a
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|b
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* compare count of previous failures */
name|weight
operator|=
name|b
operator|->
name|ni_fails
operator|-
name|a
operator|->
name|ni_fails
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|weight
argument_list|)
operator|>
literal|1
condition|)
return|return
name|weight
return|;
name|rssia
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|rssib
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|rssib
operator|-
name|rssia
argument_list|)
operator|<
literal|5
condition|)
block|{
comment|/* best/max rate preferred if signal level close enough XXX */
name|maxa
operator|=
name|maxrate
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|maxrate
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxa
operator|!=
name|maxb
condition|)
return|return
name|maxa
operator|-
name|maxb
return|;
comment|/* XXX use freq for channel preference */
comment|/* for now just prefer 5Ghz band to all other bands */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|a
operator|->
name|ni_chan
argument_list|)
operator|&&
operator|!
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|b
operator|->
name|ni_chan
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|a
operator|->
name|ni_chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|b
operator|->
name|ni_chan
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* all things being equal, use signal level */
return|return
name|rssia
operator|-
name|rssib
return|;
block|}
end_function

begin_comment
comment|/*  * Mark an ongoing scan stopped.  */
end_comment

begin_function
name|void
name|ieee80211_cancel_scan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: end %s scan\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_ASCAN
operator|)
condition|?
literal|"active"
else|:
literal|"passive"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
operator|(
name|IEEE80211_F_SCAN
operator||
name|IEEE80211_F_ASCAN
operator|)
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_PROBECHAN
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete a scan of potential channels.  */
end_comment

begin_function
name|void
name|ieee80211_end_scan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_scan
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|,
modifier|*
name|selbs
decl_stmt|;
name|ieee80211_cancel_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_notify_scan_done
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|u_int8_t
name|maxrssi
index|[
name|IEEE80211_CHAN_MAX
index|]
decl_stmt|;
comment|/* XXX off stack? */
name|int
name|i
decl_stmt|,
name|bestchan
decl_stmt|;
name|u_int8_t
name|rssi
decl_stmt|;
comment|/* 		 * The passive scan to look for existing AP's completed, 		 * select a channel to camp on.  Identify the channels 		 * that already have one or more AP's and try to locate 		 * an unoccupied one.  If that fails, pick a channel that 		 * looks to be quietest. 		 */
name|memset
argument_list|(
name|maxrssi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|maxrssi
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
name|rssi
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|i
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|>
name|maxrssi
index|[
name|i
index|]
condition|)
name|maxrssi
index|[
name|i
index|]
operator|=
name|rssi
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
comment|/* XXX select channel more intelligently */
name|bestchan
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_CHAN_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* 				 * If the channel is unoccupied the max rssi 				 * should be zero; just take it.  Otherwise 				 * track the channel with the lowest rssi and 				 * use that when all channels appear occupied. 				 */
if|if
condition|(
name|maxrssi
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|bestchan
operator|=
name|i
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bestchan
operator|==
operator|-
literal|1
operator|||
name|maxrssi
index|[
name|i
index|]
operator|<
name|maxrssi
index|[
name|bestchan
index|]
condition|)
name|bestchan
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bestchan
operator|!=
operator|-
literal|1
condition|)
block|{
name|ieee80211_create_ibss
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|bestchan
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* no suitable channel, should not happen */
block|}
comment|/* 	 * When manually sequencing the state machine; scan just once 	 * regardless of whether we have a candidate or not.  The 	 * controlling application is expected to setup state and 	 * initiate an association. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_roaming
operator|==
name|IEEE80211_ROAMING_MANUAL
condition|)
return|return;
comment|/* 	 * Automatic sequencing; look for a candidate and 	 * if found join the network. 	 */
comment|/* NB: unlocked read should be ok */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no scan candidate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|notfound
label|:
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_IBSSON
operator|)
operator|&&
name|ic
operator|->
name|ic_des_esslen
operator|!=
literal|0
condition|)
block|{
name|ieee80211_create_ibss
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_ibss_chan
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Decrement the failure counts so entries will be 		 * reconsidered the next time around.  We really want 		 * to do this only for sta's where we've previously 		 * had some success. 		 */
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
if|if
condition|(
name|ni
operator|->
name|ni_fails
condition|)
name|ni
operator|->
name|ni_fails
operator|--
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
comment|/* 		 * Reset the list of channels to scan and start again. 		 */
name|ieee80211_reset_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SCAN
expr_stmt|;
name|ieee80211_next_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return;
block|}
name|selbs
operator|=
name|NULL
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"\t%s\n"
argument_list|,
literal|"macaddr          bssid         chan  rssi rate flag  wep  essid"
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ieee80211_match_bss
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
name|selbs
operator|=
name|ni
expr_stmt|;
elseif|else
if|if
condition|(
name|ieee80211_node_compare
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|selbs
argument_list|)
operator|>
literal|0
condition|)
name|selbs
operator|=
name|ni
expr_stmt|;
block|}
block|}
if|if
condition|(
name|selbs
operator|!=
name|NULL
condition|)
comment|/* NB: grab ref while dropping lock */
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|selbs
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
goto|goto
name|notfound
goto|;
if|if
condition|(
operator|!
name|ieee80211_sta_join
argument_list|(
name|ic
argument_list|,
name|selbs
argument_list|)
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|selbs
argument_list|)
expr_stmt|;
goto|goto
name|notfound
goto|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle 802.11 ad hoc network merge.  The  * convention, set by the Wireless Ethernet Compatibility Alliance  * (WECA), is that an 802.11 station will change its BSSID to match  * the "oldest" 802.11 ad hoc network, on the same channel, that  * has the station's desired SSID.  The "oldest" 802.11 network  * sends beacons with the greatest TSF timestamp.  *  * The caller is assumed to validate TSF's before attempting a merge.  *  * Return !0 if the BSSID changed, 0 otherwise.  */
end_comment

begin_function
name|int
name|ieee80211_ibss_merge
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
if|if
condition|(
name|ni
operator|==
name|ic
operator|->
name|ic_bss
operator|||
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
condition|)
block|{
comment|/* unchanged, nothing to do */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|ieee80211_match_bss
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* capabilities mismatch */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: merge failed, capabilities mismatch\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ibss_capmismatch
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: new bssid %s: %s preamble, %s slot time%s\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|?
literal|", protection"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|ieee80211_sta_join
argument_list|(
name|ic
argument_list|,
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Join the specified IBSS/BSS network.  The node is assumed to  * be passed in with a held reference.  */
end_comment

begin_function
name|int
name|ieee80211_sta_join
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|selbs
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|obss
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
comment|/* 		 * Delete unusable rates; we've already checked 		 * that the negotiated rate set is acceptable. 		 */
name|ieee80211_fix_rate
argument_list|(
name|selbs
argument_list|,
name|IEEE80211_F_DODEL
argument_list|)
expr_stmt|;
comment|/* 		 * Fillin the neighbor table; it will already 		 * exist if we are simply switching mastership. 		 * XXX ic_sta always setup so this is unnecessary? 		 */
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_name
operator|=
literal|"neighbor"
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|ic
operator|->
name|ic_inact_run
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Committed to selbs, setup state. 	 */
name|obss
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|ic
operator|->
name|ic_bss
operator|=
name|selbs
expr_stmt|;
comment|/* NB: caller assumed to bump refcnt */
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
name|copy_bss
argument_list|(
name|selbs
argument_list|,
name|obss
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|obss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set the erp state (mostly the slot time) to deal with 	 * the auto-select case; this should be redundant if the 	 * mode is locked. 	 */
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|selbs
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|selbs
operator|->
name|ni_chan
expr_stmt|;
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_initparams
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_AUTH
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Leave the specified IBSS/BSS network.  The node is assumed to  * be passed in with a held reference.  */
end_comment

begin_function
name|void
name|ieee80211_sta_leave
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ic
operator|->
name|ic_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|node_alloc
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|MALLOC
argument_list|(
name|ni
argument_list|,
expr|struct
name|ieee80211_node
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim any resources in a node and reset any critical  * state.  Typically nodes are free'd immediately after,  * but in some cases the storage may be reused so we need  * to insure consistent state (should probably fix that).  */
end_comment

begin_function
specifier|static
name|void
name|node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|qlen
decl_stmt|;
comment|/* NB: preserve ni_table */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
condition|)
block|{
name|ic
operator|->
name|ic_ps_sta
operator|--
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_PWR_MGT
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"[%s] power save mode off, %u sta's in ps mode\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_ps_sta
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clear AREF flag that marks the authorization refcnt bump 	 * has happened.  This is probably not needed as the node 	 * should always be removed from the table so not found but 	 * do it just in case. 	 */
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_AREF
expr_stmt|;
comment|/* 	 * Drain power save queue and, if needed, clear TIM. 	 */
name|IEEE80211_NODE_SAVEQ_DRAIN
argument_list|(
name|ni
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlen
operator|!=
literal|0
operator|&&
name|ic
operator|->
name|ic_set_tim
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_associd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|ni
operator|->
name|ni_challenge
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_challenge
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Preserve SSID, WPA, and WME ie's so the bss node is 	 * reusable during a re-auth/re-assoc state transition. 	 * If we remove these data they will not be recreated 	 * because they come from a probe-response or beacon frame 	 * which cannot be expected prior to the association-response. 	 * This should not be an issue when operating in other modes 	 * as stations leaving always go through a full state transition 	 * which will rebuild this state. 	 * 	 * XXX does this leave us open to inheriting old state? 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ni
operator|->
name|ni_rxfrag
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Must be careful here to remove any key map entry w/o a LOR. 	 */
name|ieee80211_node_delucastkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|void
name|node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ic
operator|->
name|ic_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_wpa_ie
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ni
operator|->
name|ni_wpa_ie
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_wme_ie
operator|!=
name|NULL
condition|)
name|FREE
argument_list|(
name|ni
operator|->
name|ni_wme_ie
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_DESTROY
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|ni
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
name|node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
return|return
name|ni
operator|->
name|ni_rssi
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_setup_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s> in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|ieee80211_node_initref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|ni
operator|->
name|ni_chan
operator|=
name|IEEE80211_CHAN_ANYC
expr_stmt|;
name|ni
operator|->
name|ni_authmode
operator|=
name|IEEE80211_AUTH_OPEN
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_txpowlimit
expr_stmt|;
comment|/* max power */
name|ieee80211_crypto_resetkey
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|nt
operator|->
name|nt_inact_init
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_INIT
argument_list|(
name|ni
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nt
operator|->
name|nt_hash
index|[
name|hash
index|]
argument_list|,
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|nt
expr_stmt|;
name|ni
operator|->
name|ni_ic
operator|=
name|ic
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_alloc_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_setup_node
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
else|else
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Craft a temporary node suitable for sending a management frame  * to the specified station.  We craft only as much state as we  * need to do the work since the node will be immediately reclaimed  * once the send completes.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_tmp_node
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ieee80211_node_initref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_txpower
expr_stmt|;
comment|/* NB: required by ieee80211_fix_rate */
name|ieee80211_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|ieee80211_crypto_resetkey
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
comment|/* XXX optimize away */
name|IEEE80211_NODE_SAVEQ_INIT
argument_list|(
name|ni
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|NULL
expr_stmt|;
comment|/* NB: pedantic */
name|ni
operator|->
name|ni_ic
operator|=
name|ic
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX msg */
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_dup_bss
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_setup_node
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
comment|/* 		 * Inherit from ic_bss. 		 */
name|ni
operator|->
name|ni_authmode
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_txpower
expr_stmt|;
name|ni
operator|->
name|ni_vlan
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_vlan
expr_stmt|;
comment|/* XXX?? */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ieee80211_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rsn
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
expr_stmt|;
block|}
else|else
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|_ieee80211_find_node_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|_ieee80211_find_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ni
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
end_ifdef

begin_define
define|#
directive|define
name|_ieee80211_find_node
parameter_list|(
name|nt
parameter_list|,
name|mac
parameter_list|)
define|\
value|_ieee80211_find_node_debug(nt, mac, func, line)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Fake up a node; this handles node discovery in adhoc mode.  * Note that for the driver's benefit we we treat this like  * an association so the driver has an opportunity to setup  * it's private state.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_fakeup_adhoc_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: mac<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_dup_bss
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX no rate negotiation; just dup */
name|ni
operator|->
name|ni_rates
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rates
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX not right for 802.1x/WPA */
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 			 * Blindly propagate capabilities based on the 			 * local configuration.  In particular this permits 			 * us to use QoS to disable ACK's. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
block|}
block|}
return|return
name|ni
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|dump_probe_beacon
parameter_list|(
name|u_int8_t
name|subtype
parameter_list|,
name|int
name|isnew
parameter_list|,
specifier|const
name|u_int8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|printf
argument_list|(
literal|"[%s] %s%s on chan %u (bss chan %u) "
argument_list|,
name|ether_sprintf
argument_list|(
name|mac
argument_list|)
argument_list|,
name|isnew
condition|?
literal|"new "
else|:
literal|""
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
name|subtype
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|,
name|sp
operator|->
name|chan
argument_list|,
name|sp
operator|->
name|bchan
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|sp
operator|->
name|ssid
operator|+
literal|2
argument_list|,
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnew
condition|)
block|{
name|printf
argument_list|(
literal|"[%s] caps 0x%x bintval %u erp 0x%x"
argument_list|,
name|ether_sprintf
argument_list|(
name|mac
argument_list|)
argument_list|,
name|sp
operator|->
name|capinfo
argument_list|,
name|sp
operator|->
name|bintval
argument_list|,
name|sp
operator|->
name|erp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|country
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
name|printf
argument_list|(
literal|" country info %*D"
argument_list|,
name|sp
operator|->
name|country
index|[
literal|1
index|]
argument_list|,
name|sp
operator|->
name|country
operator|+
literal|2
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|" country info"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sp
operator|->
name|country
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %02x"
argument_list|,
name|sp
operator|->
name|country
index|[
name|i
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_DEBUG */
end_comment

begin_function
specifier|static
name|void
name|saveie
parameter_list|(
name|u_int8_t
modifier|*
modifier|*
name|iep
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ie
parameter_list|)
block|{
if|if
condition|(
name|ie
operator|==
name|NULL
condition|)
operator|*
name|iep
operator|=
name|NULL
expr_stmt|;
else|else
name|ieee80211_saveie
argument_list|(
name|iep
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a beacon or probe response frame.  */
end_comment

begin_function
name|void
name|ieee80211_add_scan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|rstamp
parameter_list|)
block|{
define|#
directive|define
name|ISPROBE
parameter_list|(
name|_st
parameter_list|)
value|((_st) == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_scan
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|newnode
init|=
literal|0
decl_stmt|;
name|ni
operator|=
name|ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Create a new entry. 		 */
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
return|return;
block|}
name|ieee80211_setup_node
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
comment|/* 		 * XXX inherit from ic_bss. 		 */
name|ni
operator|->
name|ni_authmode
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_txpower
expr_stmt|;
name|ni
operator|->
name|ni_vlan
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_vlan
expr_stmt|;
comment|/* XXX?? */
name|ieee80211_set_chan
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rsn
operator|=
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
expr_stmt|;
name|newnode
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_scan
argument_list|(
name|ic
argument_list|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
condition|)
name|dump_probe_beacon
argument_list|(
name|subtype
argument_list|,
name|newnode
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* XXX ap beaconing multiple ssid w/ same bssid */
if|if
condition|(
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|ISPROBE
argument_list|(
name|subtype
argument_list|)
operator|||
name|ni
operator|->
name|ni_esslen
operator|==
literal|0
operator|)
condition|)
block|{
name|ni
operator|->
name|ni_esslen
operator|=
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|sp
operator|->
name|ssid
operator|+
literal|2
argument_list|,
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|ni_scangen
operator|=
name|ic
operator|->
name|ic_scan
operator|.
name|nt_scangen
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rssi
operator|=
name|rssi
expr_stmt|;
name|ni
operator|->
name|ni_rstamp
operator|=
name|rstamp
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
name|sp
operator|->
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ni
operator|->
name|ni_tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|sp
operator|->
name|bintval
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator|=
name|sp
operator|->
name|capinfo
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|sp
operator|->
name|chan
index|]
expr_stmt|;
name|ni
operator|->
name|ni_fhdwell
operator|=
name|sp
operator|->
name|fhdwell
expr_stmt|;
name|ni
operator|->
name|ni_fhindex
operator|=
name|sp
operator|->
name|fhindex
expr_stmt|;
name|ni
operator|->
name|ni_erp
operator|=
name|sp
operator|->
name|erp
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tim
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee80211_tim_ie
modifier|*
name|ie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|sp
operator|->
name|tim
decl_stmt|;
name|ni
operator|->
name|ni_dtim_count
operator|=
name|ie
operator|->
name|tim_count
expr_stmt|;
name|ni
operator|->
name|ni_dtim_period
operator|=
name|ie
operator|->
name|tim_period
expr_stmt|;
block|}
comment|/* 	 * Record the byte offset from the mac header to 	 * the start of the TIM information element for 	 * use by hardware and/or to speedup software 	 * processing of beacon frames. 	 */
name|ni
operator|->
name|ni_timoff
operator|=
name|sp
operator|->
name|timoff
expr_stmt|;
comment|/* 	 * Record optional information elements that might be 	 * used by applications or drivers. 	 */
name|saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wme_ie
argument_list|,
name|sp
operator|->
name|wme
argument_list|)
expr_stmt|;
name|saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wpa_ie
argument_list|,
name|sp
operator|->
name|wpa
argument_list|)
expr_stmt|;
comment|/* NB: must be after ni_chan is setup */
name|ieee80211_setup_rates
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|rates
argument_list|,
name|sp
operator|->
name|xrates
argument_list|,
name|IEEE80211_F_DOSORT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newnode
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ISPROBE
block|}
end_function

begin_function
name|void
name|ieee80211_init_neighbor
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_esslen
operator|=
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|sp
operator|->
name|ssid
operator|+
literal|2
argument_list|,
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
name|sp
operator|->
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ni
operator|->
name|ni_tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|sp
operator|->
name|bintval
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator|=
name|sp
operator|->
name|capinfo
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_curchan
expr_stmt|;
name|ni
operator|->
name|ni_fhdwell
operator|=
name|sp
operator|->
name|fhdwell
expr_stmt|;
name|ni
operator|->
name|ni_fhindex
operator|=
name|sp
operator|->
name|fhindex
expr_stmt|;
name|ni
operator|->
name|ni_erp
operator|=
name|sp
operator|->
name|erp
expr_stmt|;
name|ni
operator|->
name|ni_timoff
operator|=
name|sp
operator|->
name|timoff
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|wme
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wme_ie
argument_list|,
name|sp
operator|->
name|wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|wpa
operator|!=
name|NULL
condition|)
name|ieee80211_saveie
argument_list|(
operator|&
name|ni
operator|->
name|ni_wpa_ie
argument_list|,
name|sp
operator|->
name|wpa
argument_list|)
expr_stmt|;
comment|/* NB: must be after ni_chan is setup */
name|ieee80211_setup_rates
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|rates
argument_list|,
name|sp
operator|->
name|xrates
argument_list|,
name|IEEE80211_F_DOSORT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do node discovery in adhoc mode on receipt of a beacon  * or probe response frame.  Note that for the driver's  * benefit we we treat this like an association so the  * driver has an opportunity to setup it's private state.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_add_neighbor
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: mac<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_dup_bss
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
comment|/* XXX alloc_node? */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_init_neighbor
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX not right for 802.1x/WPA */
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_CTL
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& IEEE80211_FC0_TYPE_MASK) == IEEE80211_FC0_TYPE_CTL)
end_define

begin_define
define|#
directive|define
name|IS_PSPOLL
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& IEEE80211_FC0_SUBTYPE_MASK) == IEEE80211_FC0_SUBTYPE_PS_POLL)
end_define

begin_comment
comment|/*  * Locate the node for sender, track state, and then pass the  * (referenced) node up to the 802.11 layer for its use.  We  * are required to pass some node so we fall back to ic_bss  * when this frame is from an unknown sender.  The 802.11 layer  * knows this means the sender wasn't in the node table and  * acts accordingly.   */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_rxnode_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_rxnode
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* XXX may want scanned nodes in the neighbor table for adhoc */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
condition|)
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_scan
expr_stmt|;
else|else
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
comment|/* XXX check ic_bss first in station mode */
comment|/* XXX 4-address frames? */
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_CTL
argument_list|(
name|wh
argument_list|)
operator|&&
operator|!
name|IS_PSPOLL
argument_list|(
name|wh
argument_list|)
comment|/*&& !IS_RTS(ah)*/
condition|)
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
else|else
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Like ieee80211_find_rxnode but use the supplied h/w  * key index as a hint to locate the node in the key  * mapping table.  If an entry is present at the key  * index we return it; otherwise do a normal lookup and  * update the mapping table if the station has a unicast  * key assigned to it.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_rxnode_withkey_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
name|ieee80211_keyix
name|keyix
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_rxnode_withkey
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
name|ieee80211_keyix
name|keyix
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
condition|)
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_scan
expr_stmt|;
else|else
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|)
name|ni
operator|=
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
expr_stmt|;
else|else
name|ni
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|IS_CTL
argument_list|(
name|wh
argument_list|)
operator|&&
operator|!
name|IS_PSPOLL
argument_list|(
name|wh
argument_list|)
comment|/*&& !IS_RTS(ah)*/
condition|)
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
else|else
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the station has a unicast key cache slot 			 * assigned update the key->node mapping table. 			 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
comment|/* XXX can keyixmap[keyix] != NULL? */
if|if
condition|(
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: add key map entry %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|IS_PSPOLL
end_undef

begin_undef
undef|#
directive|undef
name|IS_CTL
end_undef

begin_comment
comment|/*  * Return a reference to the appropriate node for sending  * a data frame.  This handles node discovery in adhoc networks.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_txnode_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_txnode
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* 	 * The destination address should be in the node table 	 * unless this is a multicast/broadcast frame.  We can 	 * also optimize station mode operation, all frames go 	 * to the bss node. 	 */
comment|/* XXX can't hold lock across dup_bss 'cuz of recursive locking */
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|IEEE80211_IS_MULTICAST
argument_list|(
name|macaddr
argument_list|)
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
else|else
block|{
name|ni
operator|=
name|_ieee80211_find_node
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_associd
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Station is not associated; don't permit the 			 * data frame to be sent by returning NULL.  This 			 * is kinda a kludge but the least intrusive way 			 * to add this check into all drivers. 			 */
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
comment|/* NB: null's ni */
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 			 * In adhoc mode cons up a node for the destination. 			 * Note that we need an additional reference for the 			 * caller to be consistent with _ieee80211_find_node. 			 */
name|ni
operator|=
name|ieee80211_fakeup_adhoc_node
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"[%s] no node, discard frame (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nonode
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Like find but search based on the channel too.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_with_channel_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node_with_channel
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
operator|&&
name|ni
operator|->
name|ni_chan
operator|==
name|chan
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|REFCNT_LOC
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Like find but search based on the ssid too.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_with_ssid_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
name|u_int
name|ssidlen
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ssid
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node_with_ssid
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|macaddr
parameter_list|,
name|u_int
name|ssidlen
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ssid
parameter_list|)
endif|#
directive|endif
block|{
define|#
directive|define
name|MATCH_SSID
parameter_list|(
name|ni
parameter_list|,
name|ssid
parameter_list|,
name|ssidlen
parameter_list|)
define|\
value|(ni->ni_esslen == ssidlen&& memcmp(ni->ni_essid, ssid, ssidlen) == 0)
specifier|static
specifier|const
name|u_int8_t
name|zeromac
index|[
name|IEEE80211_ADDR_LEN
index|]
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
comment|/* 	 * A mac address that is all zero means match only the ssid; 	 * otherwise we must match both. 	 */
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|macaddr
argument_list|,
name|zeromac
argument_list|)
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|MATCH_SSID
argument_list|(
name|ni
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
condition|)
break|break;
block|}
block|}
else|else
block|{
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
operator|&&
name|MATCH_SSID
argument_list|(
name|ni
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|REFCNT_LOC
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
undef|#
directive|undef
name|MATCH_SSID
block|}
end_function

begin_function
specifier|static
name|void
name|_ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s> in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|nt
operator|!=
name|NULL
condition|?
name|nt
operator|->
name|nt_name
else|:
literal|"<gone>"
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
block|}
name|ic
operator|->
name|ic_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_free_node_debug
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
block|{
comment|/* 			 * Last reference, reclaim state. 			 */
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|==
literal|1
operator|&&
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_keyix
name|keyix
decl_stmt|;
comment|/* 			 * Check for a last reference in the key mapping table. 			 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
if|if
condition|(
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|ni
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s> clear key map entry"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX needed? */
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reclaim a unicast key and clear any key cache state.  */
end_comment

begin_function
name|int
name|ieee80211_node_delucastkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|nikey
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|;
name|int
name|isowned
decl_stmt|,
name|status
decl_stmt|;
comment|/* 	 * NB: We must beware of LOR here; deleting the key 	 * can cause the crypto layer to block traffic updates 	 * which can generate a LOR against the node table lock; 	 * grab it here and stash the key index for our use below. 	 * 	 * Must also beware of recursion on the node table lock. 	 * When called from node_cleanup we may already have 	 * the node table lock held.  Unfortunately there's no 	 * way to separate out this path so we must do this 	 * conditionally. 	 */
name|isowned
operator|=
name|IEEE80211_NODE_IS_LOCKED
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isowned
condition|)
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
name|status
operator|=
name|ieee80211_crypto_delkey
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|)
block|{
name|nikey
operator|=
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
empty_stmt|;
block|}
else|else
name|nikey
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|isowned
condition|)
name|IEEE80211_NODE_UNLOCK
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
if|if
condition|(
name|nikey
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|nikey
operator|==
name|ni
argument_list|,
operator|(
literal|"key map out of sync, ni %p nikey %p"
operator|,
name|ni
operator|,
name|nikey
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: delete key map entry %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim a node.  If this is the last reference count then  * do the normal free work.  Otherwise remove it from the node  * table and mark it gone by clearing the back-reference.  */
end_comment

begin_function
specifier|static
name|void
name|node_reclaim
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ieee80211_keyix
name|keyix
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: remove %p<%s> from %s table, refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear any entry in the unicast key mapping table. 	 * We need to do it here so rx lookups don't find it 	 * in the mapping table even if it's not in the hash 	 * table.  We cannot depend on the mapping table entry 	 * being cleared because the node may not be free'd. 	 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|ni
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s> clear key map entry\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* NB: don't need free */
block|}
if|if
condition|(
operator|!
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
block|{
comment|/* 		 * Other references are present, just remove the 		 * node from the table so it cannot be found.  When 		 * the references are dropped storage will be 		 * reclaimed. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|NULL
expr_stmt|;
comment|/* clear reference */
block|}
else|else
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_free_allnodes_locked
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: free all nodes in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ni
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
block|}
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_free_allnodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_free_allnodes_locked
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timeout entries in the scan cache.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_timeout_scan_candidates
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|,
modifier|*
name|tni
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
comment|/* XXX belongs elsewhere */
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|ticks
operator|>
name|ni
operator|->
name|ni_rxfragstamp
operator|+
name|hz
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|,
argument|tni
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_inact
operator|&&
operator|--
name|ni
operator|->
name|ni_inact
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"[%s] scan candidate purged from cache "
literal|"(refcnt %u)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_inact_timer
operator|=
name|IEEE80211_INACT_WAIT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timeout inactive stations and do related housekeeping.  * Note that we cannot hold the node lock while sending a  * frame as this would lead to a LOR.  Instead we use a  * generation number to mark nodes that we've scanned and  * drop the lock and restart a scan if we have to time out  * a node.  Since we are single-threaded by virtue of  * controlling the inactivity timer we can be sure this will  * process each node only once.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_timeout_stations
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|int
name|isadhoc
decl_stmt|;
name|isadhoc
operator|=
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|)
expr_stmt|;
name|IEEE80211_SCAN_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|++
name|nt
operator|->
name|nt_scangen
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %s scangen %u\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|gen
argument_list|)
expr_stmt|;
name|restart
label|:
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_scangen
operator|==
name|gen
condition|)
comment|/* previously handled */
continue|continue;
name|ni
operator|->
name|ni_scangen
operator|=
name|gen
expr_stmt|;
comment|/* 		 * Ignore entries for which have yet to receive an 		 * authentication frame.  These are transient and 		 * will be reclaimed when the last reference to them 		 * goes away (when frame xmits complete). 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AREF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Free fragment if not needed anymore 		 * (last fragment older than 1s). 		 * XXX doesn't belong here 		 */
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|ticks
operator|>
name|ni
operator|->
name|ni_rxfragstamp
operator|+
name|hz
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Special case ourself; we may be idle for extended periods 		 * of time and regardless reclaiming our state is wrong. 		 */
if|if
condition|(
name|ni
operator|==
name|ic
operator|->
name|ic_bss
condition|)
continue|continue;
name|ni
operator|->
name|ni_inact
operator|--
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
operator|||
name|isadhoc
condition|)
block|{
comment|/* 			 * Age frames on the power save queue. The 			 * aging interval is 4 times the listen 			 * interval specified by the station.  This 			 * number is factored into the age calculations 			 * when the frame is placed on the queue.  We 			 * store ages as time differences we can check 			 * and/or adjust only the head of the list. 			 */
if|if
condition|(
name|IEEE80211_NODE_SAVEQ_QLEN
argument_list|(
name|ni
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|discard
init|=
literal|0
decl_stmt|;
name|IEEE80211_NODE_SAVEQ_LOCK
argument_list|(
name|ni
argument_list|)
expr_stmt|;
while|while
condition|(
name|IF_POLL
argument_list|(
operator|&
name|ni
operator|->
name|ni_savedq
argument_list|,
name|m
argument_list|)
operator|!=
name|NULL
operator|&&
name|M_AGE_GET
argument_list|(
name|m
argument_list|)
operator|<
name|IEEE80211_INACT_WAIT
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"[%s] discard frame, age %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|M_AGE_GET
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/*XXX*/
name|_IEEE80211_NODE_SAVEQ_DEQUEUE_HEAD
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|discard
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|M_AGE_SUB
argument_list|(
name|m
argument_list|,
name|IEEE80211_INACT_WAIT
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_UNLOCK
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|discard
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"[%s] discard %u frames for age\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|discard
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_ADD
argument_list|(
name|ni
argument_list|,
name|ps_discard
argument_list|,
name|discard
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_NODE_SAVEQ_QLEN
argument_list|(
name|ni
argument_list|)
operator|==
literal|0
condition|)
name|ic
operator|->
name|ic_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 			 * Probe the station before time it out.  We 			 * send a null data frame which may not be 			 * universally supported by drivers (need it 			 * for ps-poll support so it should be...). 			 */
if|if
condition|(
literal|0
operator|<
name|ni
operator|->
name|ni_inact
operator|&&
name|ni
operator|->
name|ni_inact
operator|<=
name|ic
operator|->
name|ic_inact_probe
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INACT
operator||
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"probe station due to inactivity"
argument_list|)
expr_stmt|;
comment|/* 				 * Grab a reference before unlocking the table 				 * so the node cannot be reclaimed before we 				 * send the frame. ieee80211_send_nulldata 				 * understands we've done this and reclaims the 				 * ref for us as needed. 				 */
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_send_nulldata
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX stat? */
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
name|ni
operator|->
name|ni_inact
operator|<=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INACT
operator||
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"station timed out due to inactivity "
literal|"(refcnt %u)"
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Send a deauthenticate frame and drop the station. 			 * This is somewhat complicated due to reference counts 			 * and locking.  At this point a station will typically 			 * have a reference count of 1.  ieee80211_node_leave 			 * will do a "free" of the node which will drop the 			 * reference count.  But in the meantime a reference 			 * wil be held by the deauth frame.  The actual reclaim 			 * of the node will happen either after the tx is 			 * completed or by ieee80211_node_leave. 			 * 			 * Separately we must drop the node lock before sending 			 * in case the driver takes a lock, as this will result 			 * in  LOR between the node lock and the driver lock. 			 */
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|,
name|IEEE80211_REASON_AUTH_EXPIRE
argument_list|)
expr_stmt|;
block|}
name|ieee80211_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_node_timeout
operator|++
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_SCAN_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_inact_timer
operator|=
name|IEEE80211_INACT_WAIT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_iterate_nodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|ieee80211_iter_func
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|IEEE80211_SCAN_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|++
name|nt
operator|->
name|nt_scangen
expr_stmt|;
name|restart
label|:
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_scangen
operator|!=
name|gen
condition|)
block|{
name|ni
operator|->
name|ni_scangen
operator|=
name|gen
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|arg
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_SCAN_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dump_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|printf
argument_list|(
literal|"0x%p: mac %s refcnt %d\n"
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tscangen %u authmode %u flags 0x%x\n"
argument_list|,
name|ni
operator|->
name|ni_scangen
argument_list|,
name|ni
operator|->
name|ni_authmode
argument_list|,
name|ni
operator|->
name|ni_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tassocid 0x%x txpower %u vlan %u\n"
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|,
name|ni
operator|->
name|ni_txpower
argument_list|,
name|ni
operator|->
name|ni_vlan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttxseq %u rxseq %u fragno %u rxfragstamp %u\n"
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
literal|0
index|]
argument_list|,
name|ni
operator|->
name|ni_rxseqs
index|[
literal|0
index|]
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|,
name|ni
operator|->
name|ni_rxseqs
index|[
literal|0
index|]
operator|&
name|IEEE80211_SEQ_FRAG_MASK
argument_list|,
name|ni
operator|->
name|ni_rxfragstamp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trstamp %u rssi %u intval %u capinfo 0x%x\n"
argument_list|,
name|ni
operator|->
name|ni_rstamp
argument_list|,
name|ni
operator|->
name|ni_rssi
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbssid %s essid \"%.*s\" channel %u:0x%x\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tfails %u inact %u txrate %u\n"
argument_list|,
name|ni
operator|->
name|ni_fails
argument_list|,
name|ni
operator|->
name|ni_inact
argument_list|,
name|ni
operator|->
name|ni_txrate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dump_nodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|ieee80211_iterate_nodes
argument_list|(
name|nt
argument_list|,
operator|(
name|ieee80211_iter_func
operator|*
operator|)
name|ieee80211_dump_node
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a station joining an 11g network.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_join_11g
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
comment|/* 	 * Station isn't capable of short slot time.  Bump 	 * the count of long slot time stations and disable 	 * use of short slot time.  Note that the actual switch 	 * over to long slot time use may not occur until the 	 * next beacon transmission (per sec. 7.3.1.4 of 11g). 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_longslotsta
operator|++
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] station needs long slot time, count %d\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_longslotsta
argument_list|)
expr_stmt|;
comment|/* XXX vap's w/ conflicting needs won't work */
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the new station is not an ERP station 	 * then bump the counter and enable protection 	 * if configured. 	 */
if|if
condition|(
operator|!
name|ieee80211_iserp_rateset
argument_list|(
name|ic
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_nonerpsta
operator|++
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] station is !ERP, %d non-ERP stations associated\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_nonerpsta
argument_list|)
expr_stmt|;
comment|/* 		 * If protection is configured, enable it. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|!=
name|IEEE80211_PROT_NONE
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: enable use of protection\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEPROT
expr_stmt|;
block|}
comment|/* 		 * If station does not support short preamble 		 * then we must enable use of Barker preamble. 		 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] station needs long preamble\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEBARKER
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|1
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_ERPUPDATE
expr_stmt|;
block|}
else|else
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ERP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_join
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|resp
parameter_list|)
block|{
name|int
name|newassoc
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
block|{
name|u_int16_t
name|aid
decl_stmt|;
comment|/* 		 * It would be good to search the bitmap 		 * more efficiently, but this will do for now. 		 */
for|for
control|(
name|aid
operator|=
literal|1
init|;
name|aid
operator|<
name|ic
operator|->
name|ic_max_aid
condition|;
name|aid
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_AID_ISSET
argument_list|(
name|aid
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|aid
operator|>=
name|ic
operator|->
name|ic_max_aid
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|resp
argument_list|,
name|IEEE80211_REASON_ASSOC_TOOMANY
argument_list|)
expr_stmt|;
name|ieee80211_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
return|return;
block|}
name|ni
operator|->
name|ni_associd
operator|=
name|aid
operator||
literal|0xc000
expr_stmt|;
name|IEEE80211_AID_SET
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_sta_assoc
operator|++
expr_stmt|;
name|newassoc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|ieee80211_node_join_11g
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
name|newassoc
operator|=
literal|0
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"[%s] station %sassociated at aid %d: %s preamble, %s slot time%s%s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|newassoc
condition|?
literal|""
else|:
literal|"re"
argument_list|,
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|?
literal|", protection"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|?
literal|", QoS"
else|:
literal|""
argument_list|)
expr_stmt|;
comment|/* give driver a chance to setup state like ni_txrate */
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
name|newassoc
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|ic
operator|->
name|ic_inact_auth
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|resp
argument_list|,
name|IEEE80211_STATUS_SUCCESS
argument_list|)
expr_stmt|;
comment|/* tell the authenticator about new station */
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_join
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_join
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_join
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|newassoc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a station leaving an 11g network.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_leave_11g
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
argument_list|,
operator|(
literal|"not in 11g, bss %u:0x%x, curmode %u"
operator|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
operator|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
operator|,
name|ic
operator|->
name|ic_curmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If a long slot station do the slot time bookkeeping. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_longslotsta
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus long slot station count %d"
operator|,
name|ic
operator|->
name|ic_longslotsta
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_longslotsta
operator|--
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] long slot time station leaves, count now %d\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_longslotsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_longslotsta
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Re-enable use of short slot time if supported 			 * and not operating in IBSS mode (per spec). 			 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_IBSS
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: re-enable use of short slot time\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If a non-ERP station do the protection-related bookkeeping. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_ERP
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_nonerpsta
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus non-ERP station count %d"
operator|,
name|ic
operator|->
name|ic_nonerpsta
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_nonerpsta
operator|--
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] non-ERP station leaves, count now %d\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_nonerpsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: disable use of protection\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEPROT
expr_stmt|;
comment|/* XXX verify mode? */
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHPREAMBLE
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: re-enable use of short preamble\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_ERPUPDATE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Handle bookkeeping for station deauthentication/disassociation  * when operating as an ap.  */
end_comment

begin_function
name|void
name|ieee80211_node_leave
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"[%s] station with aid %d leaves\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
argument_list|,
operator|(
literal|"unexpected operating mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If node wasn't previously associated all 	 * we need to do is reclaim the reference. 	 */
comment|/* XXX ibss mode bypasses 11g and notification */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Tell the authenticator the station is leaving. 	 * Note that we must do this before yanking the 	 * association id as the authenticator uses the 	 * associd to locate it's state block. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|,
name|ic
operator|->
name|ic_aid_bitmap
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_associd
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_sta_assoc
operator|--
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|ieee80211_node_leave_11g
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup station state.  In particular clear various 	 * state that might otherwise be reused if the node 	 * is reused before the reference count goes to zero 	 * (and memory is reclaimed). 	 */
name|ieee80211_sta_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Remove the node from any table it's recorded in and 	 * drop the caller's reference.  Removal from the table 	 * is important to insure the node is not reprocessed 	 * for inactivity. 	 */
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|u_int8_t
name|ieee80211_getrssi
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|NZ
parameter_list|(
name|x
parameter_list|)
value|((x) == 0 ? 1 : (x))
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|u_int32_t
name|rssi_samples
decl_stmt|,
name|rssi_total
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|rssi_total
operator|=
literal|0
expr_stmt|;
name|rssi_samples
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
comment|/* average of all ibss neighbors */
comment|/* XXX locking */
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
if|if
condition|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
condition|)
block|{
name|rssi_samples
operator|++
expr_stmt|;
name|rssi_total
operator|+=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
comment|/* average of all neighbors */
comment|/* XXX locking */
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
name|rssi_samples
operator|++
expr_stmt|;
name|rssi_total
operator|+=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
comment|/* average of all associated stations */
comment|/* XXX locking */
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
if|if
condition|(
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rssi_samples
operator|++
expr_stmt|;
name|rssi_total
operator|+=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* XXX */
case|case
name|IEEE80211_M_STA
case|:
comment|/* use stats from associated ap */
default|default:
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
name|rssi_total
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
name|rssi_samples
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|rssi_total
operator|/
name|NZ
argument_list|(
name|rssi_samples
argument_list|)
return|;
undef|#
directive|undef
name|NZ
block|}
end_function

begin_comment
comment|/*  * Indicate whether there are frames queued for a station in power-save mode.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_tim
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|u_int16_t
name|aid
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
argument_list|,
operator|(
literal|"operating mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
name|aid
operator|=
name|IEEE80211_AID
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|aid
operator|<
name|ic
operator|->
name|ic_max_aid
argument_list|,
operator|(
literal|"bogus aid %u, max %u"
operator|,
name|aid
operator|,
name|ic
operator|->
name|ic_max_aid
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_BEACON_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|!=
operator|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_tim_bitmap
argument_list|,
name|aid
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|set
condition|)
block|{
name|setbit
argument_list|(
name|ic
operator|->
name|ic_tim_bitmap
argument_list|,
name|aid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ps_pending
operator|++
expr_stmt|;
block|}
else|else
block|{
name|clrbit
argument_list|(
name|ic
operator|->
name|ic_tim_bitmap
argument_list|,
name|aid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ps_pending
operator|--
expr_stmt|;
block|}
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_TIMUPDATE
expr_stmt|;
block|}
name|IEEE80211_BEACON_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Node table support.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_table_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|inact
parameter_list|,
name|int
name|keyixmax
parameter_list|,
name|void
function_decl|(
modifier|*
name|timeout
function_decl|)
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|)
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %s table, inact %u\n"
argument_list|,
name|__func__
argument_list|,
name|name
argument_list|,
name|inact
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_ic
operator|=
name|ic
expr_stmt|;
comment|/* XXX need unit */
name|IEEE80211_NODE_LOCK_INIT
argument_list|(
name|nt
argument_list|,
name|ic
operator|->
name|ic_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IEEE80211_SCAN_LOCK_INIT
argument_list|(
name|nt
argument_list|,
name|ic
operator|->
name|ic_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_name
operator|=
name|name
expr_stmt|;
name|nt
operator|->
name|nt_scangen
operator|=
literal|1
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|inact
expr_stmt|;
name|nt
operator|->
name|nt_timeout
operator|=
name|timeout
expr_stmt|;
name|nt
operator|->
name|nt_keyixmax
operator|=
name|keyixmax
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmax
operator|>
literal|0
condition|)
block|{
name|MALLOC
argument_list|(
name|nt
operator|->
name|nt_keyixmap
argument_list|,
expr|struct
name|ieee80211_node
operator|*
operator|*
argument_list|,
name|keyixmax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
operator|*
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|==
name|NULL
condition|)
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"Cannot allocate key index map with %u entries\n"
argument_list|,
name|keyixmax
argument_list|)
expr_stmt|;
block|}
else|else
name|nt
operator|->
name|nt_keyixmap
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_table_reset
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %s table\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_inact_timer
operator|=
literal|0
expr_stmt|;
name|ieee80211_free_allnodes_locked
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_node_table_cleanup
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %s table\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_free_allnodes_locked
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX verify all entries are NULL */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: %s[%u] still active\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|nt
operator|->
name|nt_keyixmap
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
operator|=
name|NULL
expr_stmt|;
block|}
name|IEEE80211_SCAN_LOCK_DESTROY
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK_DESTROY
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

