begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_wds.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_mesh.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/*  * IEEE80211_NODE_HASHSIZE must be a power of 2.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
operator|(
name|IEEE80211_NODE_HASHSIZE
operator|&
operator|(
name|IEEE80211_NODE_HASHSIZE
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Association id's are managed with a bit vector.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AID_SET
parameter_list|(
name|_vap
parameter_list|,
name|b
parameter_list|)
define|\
value|((_vap)->iv_aid_bitmap[IEEE80211_AID(b) / 32] |= \ 		(1<< (IEEE80211_AID(b) % 32)))
end_define

begin_define
define|#
directive|define
name|IEEE80211_AID_CLR
parameter_list|(
name|_vap
parameter_list|,
name|b
parameter_list|)
define|\
value|((_vap)->iv_aid_bitmap[IEEE80211_AID(b) / 32]&= \ 		~(1<< (IEEE80211_AID(b) % 32)))
end_define

begin_define
define|#
directive|define
name|IEEE80211_AID_ISSET
parameter_list|(
name|_vap
parameter_list|,
name|b
parameter_list|)
define|\
value|((_vap)->iv_aid_bitmap[IEEE80211_AID(b) / 32]& (1<< (IEEE80211_AID(b) % 32)))
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
end_ifdef

begin_define
define|#
directive|define
name|REFCNT_LOC
value|"%s (%s:%u) %p<%s> refcnt %d\n", __func__, func, line
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|REFCNT_LOC
value|"%s %p<%s> refcnt %d\n", __func__
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|ieee80211_sta_join1
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|uint8_t
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_age
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int8_t
name|node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|,
name|int8_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|node_getmimoinfo
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_mimo_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|inact
parameter_list|,
name|int
name|keymaxix
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_reset
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_node_table_cleanup
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_erp_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_NODE
argument_list|,
literal|"80211node"
argument_list|,
literal|"802.11 node state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_NODE_IE
argument_list|,
literal|"80211nodeie"
argument_list|,
literal|"802.11 node ie"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_node_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* XXX really want maxlen enforced per-sta */
name|ieee80211_ageq_init
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|,
name|ic
operator|->
name|ic_max_keyix
operator|*
literal|8
argument_list|,
literal|"802.11 staging q"
argument_list|)
expr_stmt|;
name|ieee80211_node_table_init
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
literal|"station"
argument_list|,
name|IEEE80211_INACT_INIT
argument_list|,
name|ic
operator|->
name|ic_max_keyix
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|,
name|IEEE80211_INACT_WAIT
operator|*
name|hz
argument_list|,
name|ieee80211_node_timeout
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_node_alloc
operator|=
name|node_alloc
expr_stmt|;
name|ic
operator|->
name|ic_node_free
operator|=
name|node_free
expr_stmt|;
name|ic
operator|->
name|ic_node_cleanup
operator|=
name|node_cleanup
expr_stmt|;
name|ic
operator|->
name|ic_node_age
operator|=
name|node_age
expr_stmt|;
name|ic
operator|->
name|ic_node_drain
operator|=
name|node_age
expr_stmt|;
comment|/* NB: same as age */
name|ic
operator|->
name|ic_node_getrssi
operator|=
name|node_getrssi
expr_stmt|;
name|ic
operator|->
name|ic_node_getsignal
operator|=
name|node_getsignal
expr_stmt|;
name|ic
operator|->
name|ic_node_getmimoinfo
operator|=
name|node_getmimoinfo
expr_stmt|;
comment|/* 	 * Set flags to be propagated to all vap's; 	 * these define default behaviour/configuration. 	 */
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_INACT
expr_stmt|;
comment|/* inactivity processing */
block|}
end_function

begin_function
name|void
name|ieee80211_node_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|callout_drain
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|)
expr_stmt|;
name|ieee80211_node_table_cleanup
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
name|ieee80211_ageq_cleanup
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
comment|/* NB: driver can override */
name|vap
operator|->
name|iv_max_aid
operator|=
name|IEEE80211_AID_DEF
expr_stmt|;
comment|/* default station inactivity timer setings */
name|vap
operator|->
name|iv_inact_init
operator|=
name|IEEE80211_INACT_INIT
expr_stmt|;
name|vap
operator|->
name|iv_inact_auth
operator|=
name|IEEE80211_INACT_AUTH
expr_stmt|;
name|vap
operator|->
name|iv_inact_run
operator|=
name|IEEE80211_INACT_RUN
expr_stmt|;
name|vap
operator|->
name|iv_inact_probe
operator|=
name|IEEE80211_INACT_PROBE
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
argument_list|,
literal|"%s: init %u auth %u run %u probe %u\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_inact_init
argument_list|,
name|vap
operator|->
name|iv_inact_auth
argument_list|,
name|vap
operator|->
name|iv_inact_run
argument_list|,
name|vap
operator|->
name|iv_inact_probe
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_latevattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* XXX should we allow max aid to be zero? */
if|if
condition|(
name|vap
operator|->
name|iv_max_aid
operator|<
name|IEEE80211_AID_MIN
condition|)
block|{
name|vap
operator|->
name|iv_max_aid
operator|=
name|IEEE80211_AID_MIN
expr_stmt|;
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"WARNING: max aid too small, changed to %d\n"
argument_list|,
name|vap
operator|->
name|iv_max_aid
argument_list|)
expr_stmt|;
block|}
name|vap
operator|->
name|iv_aid_bitmap
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|malloc
argument_list|(
name|howmany
argument_list|(
name|vap
operator|->
name|iv_max_aid
argument_list|,
literal|32
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_aid_bitmap
operator|==
name|NULL
condition|)
block|{
comment|/* XXX no way to recover */
name|printf
argument_list|(
literal|"%s: no memory for AID bitmap, max aid %d!\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_max_aid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_max_aid
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|ieee80211_reset_bss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_auth
operator|=
name|ieee80211_authenticator_get
argument_list|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_authmode
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|ieee80211_node_table_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_bss
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_aid_bitmap
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|vap
operator|->
name|iv_aid_bitmap
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_aid_bitmap
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*   * Port authorize/unauthorize interfaces for use by an authenticator.  */
end_comment

begin_function
name|void
name|ieee80211_node_authorize
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_AUTH
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|vap
operator|->
name|iv_inact_run
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
argument_list|,
name|ni
argument_list|,
literal|"%s: inact_reload %u"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_inact_reload
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_unauthorize
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_AUTH
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|vap
operator|->
name|iv_inact_auth
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_inact
operator|>
name|ni
operator|->
name|ni_inact_reload
condition|)
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
argument_list|,
name|ni
argument_list|,
literal|"%s: inact_reload %u inact %u"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_inact_reload
argument_list|,
name|ni
operator|->
name|ni_inact
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Fix tx parameters for a node according to ``association state''.  */
end_comment

begin_function
name|void
name|ieee80211_node_setuptxparms
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|mode
operator|=
name|IEEE80211_MODE_11NA
expr_stmt|;
else|else
name|mode
operator|=
name|IEEE80211_MODE_11NG
expr_stmt|;
block|}
else|else
block|{
comment|/* legacy rate handling */
if|if
condition|(
name|IEEE80211_IS_CHAN_ST
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|mode
operator|=
name|IEEE80211_MODE_STURBO_A
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|mode
operator|=
name|IEEE80211_MODE_HALF
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|mode
operator|=
name|IEEE80211_MODE_QUARTER
expr_stmt|;
comment|/* NB: 108A should be handled as 11a */
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|mode
operator|=
name|IEEE80211_MODE_11A
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
operator|||
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_ERP
operator|)
condition|)
name|mode
operator|=
name|IEEE80211_MODE_11G
expr_stmt|;
else|else
name|mode
operator|=
name|IEEE80211_MODE_11B
expr_stmt|;
block|}
name|ni
operator|->
name|ni_txparms
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set/change the channel.  The rate set is also updated as  * to insure a consistent view by drivers.  * XXX should be private but hostap needs it to deal with CSA  */
end_comment

begin_function
name|void
name|ieee80211_node_set_chan
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|KASSERT
argument_list|(
name|chan
operator|!=
name|IEEE80211_CHAN_ANYC
argument_list|,
operator|(
literal|"no channel"
operator|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|chan
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 		 * XXX Gotta be careful here; the rate set returned by 		 * ieee80211_get_suprates is actually any HT rate 		 * set so blindly copying it will be bad.  We must 		 * install the legacy rate est in ni_rates and the 		 * HT rate set in ni_htrates. 		 */
name|ni
operator|->
name|ni_htrates
operator|=
operator|*
name|ieee80211_get_suphtrates
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* 		 * Setup bss tx parameters based on operating mode.  We 		 * use legacy rates when operating in a mixed HT+non-HT bss 		 * and non-ERP rates in 11g for mixed ERP+non-ERP bss. 		 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11NA
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_PUREN
operator|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|IEEE80211_MODE_11A
expr_stmt|;
elseif|else
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11NG
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_PUREN
operator|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|IEEE80211_MODE_11G
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11G
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PUREG
operator|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|IEEE80211_MODE_11B
expr_stmt|;
block|}
name|ni
operator|->
name|ni_txparms
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
expr_stmt|;
name|ni
operator|->
name|ni_rates
operator|=
operator|*
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|copy_bss
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|nbss
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|obss
parameter_list|)
block|{
comment|/* propagate useful state */
name|nbss
operator|->
name|ni_authmode
operator|=
name|obss
operator|->
name|ni_authmode
expr_stmt|;
name|nbss
operator|->
name|ni_txpower
operator|=
name|obss
operator|->
name|ni_txpower
expr_stmt|;
name|nbss
operator|->
name|ni_vlan
operator|=
name|obss
operator|->
name|ni_vlan
expr_stmt|;
comment|/* XXX statistics? */
comment|/* XXX legacy WDS bssid? */
block|}
end_function

begin_function
name|void
name|ieee80211_create_ibss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: creating %s on channel %u\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_opmode_name
index|[
name|vap
operator|->
name|iv_opmode
index|]
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* XXX recovery? */
return|return;
block|}
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_esslen
operator|=
name|vap
operator|->
name|iv_des_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|vap
operator|->
name|iv_des_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|!=
name|NULL
condition|)
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|ni
operator|->
name|ni_capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_phytype
operator|==
name|IEEE80211_T_FH
condition|)
block|{
name|ni
operator|->
name|ni_fhdwell
operator|=
literal|200
expr_stmt|;
comment|/* XXX */
name|ni
operator|->
name|ni_fhindex
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_SIBSS
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator||=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DESBSSID
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|vap
operator|->
name|iv_des_bssid
argument_list|)
expr_stmt|;
else|else
block|{
name|get_random_bytes
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
comment|/* clear group bit, add local bit */
name|ni
operator|->
name|ni_bssid
index|[
literal|0
index|]
operator|=
operator|(
name|ni
operator|->
name|ni_bssid
index|[
literal|0
index|]
operator|&
operator|~
literal|0x01
operator|)
operator||
literal|0x02
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DESBSSID
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|vap
operator|->
name|iv_des_bssid
argument_list|)
expr_stmt|;
elseif|else
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
condition|)
endif|#
directive|endif
name|memset
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
literal|0
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|ni
operator|->
name|ni_meshidlen
operator|=
name|vap
operator|->
name|iv_mesh
operator|->
name|ms_idlen
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_meshid
argument_list|,
name|vap
operator|->
name|iv_mesh
operator|->
name|ms_id
argument_list|,
name|ni
operator|->
name|ni_meshidlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  	 * Fix the channel and related attributes. 	 */
comment|/* clear DFS CAC state on previous channel */
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
operator|!=
name|chan
operator|->
name|ic_freq
operator|&&
name|IEEE80211_IS_CHAN_CACDONE
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_dfs_cac_clear
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bsschan
operator|=
name|chan
expr_stmt|;
name|ieee80211_node_set_chan
argument_list|(
name|ni
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
expr_stmt|;
comment|/* 	 * Do mode-specific setup. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_FULL
argument_list|(
name|chan
argument_list|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 			 * Use a mixed 11b/11g basic rate set. 			 */
name|ieee80211_setbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PUREG
condition|)
block|{
comment|/* 				 * Also mark OFDM rates basic so 11b 				 * stations do not join (WiFi compliance). 				 */
name|ieee80211_addbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* 			 * Force pure 11b rate set. 			 */
name|ieee80211_setbasicrates
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|ieee80211_sta_join1
argument_list|(
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset bss state on transition to the INIT state.  * Clear any stations from the table (they have been  * deauth'd) and reset the bss node (clears key, rate  * etc. state).  */
end_comment

begin_function
name|void
name|ieee80211_reset_bss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|,
modifier|*
name|obss
decl_stmt|;
name|ieee80211_node_table_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* XXX multi-bss: wrong */
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"unable to setup inital BSS node"
operator|)
argument_list|)
expr_stmt|;
name|obss
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
name|vap
operator|->
name|iv_bss
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|obss
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|obss
argument_list|)
expr_stmt|;
block|}
else|else
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_ssid
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|nssid
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_ssid
name|ssids
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nssid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_esslen
operator|==
name|ssids
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|memcmp
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Test a node for suitability/compatibility.  */
end_comment

begin_function
specifier|static
name|int
name|check_bss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
return|return
literal|0
return|;
block|}
name|rate
operator|=
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_F_JOIN
operator||
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DOFRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|vap
operator|->
name|iv_des_nssid
operator|!=
literal|0
operator|&&
operator|!
name|match_ssid
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_des_nssid
argument_list|,
name|vap
operator|->
name|iv_des_ssid
argument_list|)
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_des_bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_comment
comment|/*  * Display node suitability/compatibility.  */
end_comment

begin_function
specifier|static
name|void
name|check_bss_debug
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
condition|)
name|fail
operator||=
literal|0x01
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x02
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x02
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
literal|0x04
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
name|fail
operator||=
literal|0x04
expr_stmt|;
block|}
name|rate
operator|=
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_F_JOIN
operator||
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DOFRATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
name|fail
operator||=
literal|0x08
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_des_nssid
operator|!=
literal|0
operator|&&
operator|!
name|match_ssid
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_des_nssid
argument_list|,
name|vap
operator|->
name|iv_des_ssid
argument_list|)
condition|)
name|fail
operator||=
literal|0x10
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_des_bssid
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
condition|)
name|fail
operator||=
literal|0x20
expr_stmt|;
name|printf
argument_list|(
literal|" %c %s"
argument_list|,
name|fail
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s%c"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|fail
operator|&
literal|0x20
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d%c"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|,
name|fail
operator|&
literal|0x01
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %2dM%c"
argument_list|,
operator|(
name|rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
name|fail
operator|&
literal|0x08
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s%c"
argument_list|,
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
condition|?
literal|"ess"
else|:
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
condition|?
literal|"ibss"
else|:
literal|"????"
argument_list|,
name|fail
operator|&
literal|0x02
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s%c "
argument_list|,
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
condition|?
literal|"wep"
else|:
literal|"no"
argument_list|,
name|fail
operator|&
literal|0x04
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fail
operator|&
literal|0x10
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_DEBUG */
end_comment

begin_comment
comment|/*  * Handle 802.11 ad hoc network merge.  The  * convention, set by the Wireless Ethernet Compatibility Alliance  * (WECA), is that an 802.11 station will change its BSSID to match  * the "oldest" 802.11 ad hoc network, on the same channel, that  * has the station's desired SSID.  The "oldest" 802.11 network  * sends beacons with the greatest TSF timestamp.  *  * The caller is assumed to validate TSF's before attempting a merge.  *  * Return !0 if the BSSID changed, 0 otherwise.  */
end_comment

begin_function
name|int
name|ieee80211_ibss_merge
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|||
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_bssid
argument_list|)
condition|)
block|{
comment|/* unchanged, nothing to do */
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
name|check_bss
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|)
condition|)
block|{
comment|/* capabilities mismatch */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: merge failed, capabilities mismatch\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_assoc
argument_list|(
name|vap
argument_list|)
condition|)
name|check_bss_debug
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|vap
operator|->
name|iv_stats
operator|.
name|is_ibss_capmismatch
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: new bssid %s: %s preamble, %s slot time%s\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|?
literal|", protection"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
name|ieee80211_sta_join1
argument_list|(
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate HT channel promotion flags for all vaps.  * This assumes ni_chan have been setup for each vap.  */
end_comment

begin_function
specifier|static
name|int
name|gethtadjustflags
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* XXX locking */
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|<
name|IEEE80211_S_RUN
condition|)
continue|continue;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_WDS
case|:
case|case
name|IEEE80211_M_STA
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
case|case
name|IEEE80211_M_HOSTAP
case|:
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_MBSS
case|:
name|flags
operator||=
name|ieee80211_htchanflags
argument_list|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
return|return
name|flags
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the current channel needs to change based on whether  * any vap's are using HT20/HT40.  This is used to sync the state  * of ic_curchan after a channel width change on a running vap.  */
end_comment

begin_function
name|void
name|ieee80211_sync_curchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|gethtadjustflags
argument_list|(
name|ic
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|ic
operator|->
name|ic_curchan
condition|)
block|{
name|ic
operator|->
name|ic_curchan
operator|=
name|c
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_rt
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_chan_change
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup the current channel.  The request channel may be  * promoted if other vap's are operating with HT20/HT40.  */
end_comment

begin_function
name|void
name|ieee80211_setupcurchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_HT
condition|)
block|{
name|int
name|flags
init|=
name|gethtadjustflags
argument_list|(
name|ic
argument_list|)
decl_stmt|;
comment|/* 		 * Check for channel promotion required to support the 		 * set of running vap's.  This assumes we are called 		 * after ni_chan is setup for each vap. 		 */
comment|/* NB: this assumes IEEE80211_FHT_USEHT40> IEEE80211_FHT_HT */
if|if
condition|(
name|flags
operator|>
name|ieee80211_htchanflags
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|c
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|ic
operator|->
name|ic_bsschan
operator|=
name|ic
operator|->
name|ic_curchan
operator|=
name|c
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_rt
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the current channel.  The channel change is guaranteed to have  * happened before the next state change.  */
end_comment

begin_function
name|void
name|ieee80211_setcurchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|ieee80211_setupcurchan
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_chan_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Join the specified IBSS/BSS network.  The node is assumed to  * be passed in with a held reference.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_sta_join1
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|selbs
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|selbs
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|selbs
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|obss
decl_stmt|;
name|int
name|canreassoc
decl_stmt|;
comment|/* 	 * Committed to selbs, setup state. 	 */
name|obss
operator|=
name|vap
operator|->
name|iv_bss
expr_stmt|;
comment|/* 	 * Check if old+new node have the same address in which 	 * case we can reassociate when operating in sta mode. 	 */
name|canreassoc
operator|=
operator|(
name|obss
operator|!=
name|NULL
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|IEEE80211_ADDR_EQ
argument_list|(
name|obss
operator|->
name|ni_macaddr
argument_list|,
name|selbs
operator|->
name|ni_macaddr
argument_list|)
operator|)
expr_stmt|;
name|vap
operator|->
name|iv_bss
operator|=
name|selbs
expr_stmt|;
comment|/* NB: caller assumed to bump refcnt */
if|if
condition|(
name|obss
operator|!=
name|NULL
condition|)
block|{
name|copy_bss
argument_list|(
name|selbs
argument_list|,
name|obss
argument_list|)
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|obss
argument_list|)
expr_stmt|;
comment|/* iv_bss reference */
name|ieee80211_free_node
argument_list|(
name|obss
argument_list|)
expr_stmt|;
comment|/* station table reference */
name|obss
operator|=
name|NULL
expr_stmt|;
comment|/* NB: guard against later use */
block|}
comment|/* 	 * Delete unusable rates; we've already checked 	 * that the negotiated rate set is acceptable. 	 */
name|ieee80211_fix_rate
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|,
operator|&
name|vap
operator|->
name|iv_bss
operator|->
name|ni_rates
argument_list|,
name|IEEE80211_F_DODEL
operator||
name|IEEE80211_F_JOIN
argument_list|)
expr_stmt|;
name|ieee80211_setcurchan
argument_list|(
name|ic
argument_list|,
name|selbs
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
comment|/* 	 * Set the erp state (mostly the slot time) to deal with 	 * the auto-select case; this should be redundant if the 	 * mode is locked. 	 */
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_initparams
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
if|if
condition|(
name|canreassoc
condition|)
block|{
comment|/* Reassociate */
name|ieee80211_new_state
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_ASSOC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Act as if we received a DEAUTH frame in case we 			 * are invoked from the RUN state.  This will cause 			 * us to try to re-authenticate if we are operating 			 * as a station. 			 */
name|ieee80211_new_state
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_AUTH
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ieee80211_new_state
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_sta_join
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|,
name|se
operator|->
name|se_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* XXX msg */
return|return
literal|0
return|;
block|}
comment|/* 	 * Expand scan state into node's format. 	 * XXX may not need all this stuff 	 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|se
operator|->
name|se_bssid
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_esslen
operator|=
name|se
operator|->
name|se_ssid
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|se
operator|->
name|se_ssid
operator|+
literal|2
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
operator|=
name|se
operator|->
name|se_tstamp
operator|.
name|tsf
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|se
operator|->
name|se_intval
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator|=
name|se
operator|->
name|se_capinfo
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|chan
expr_stmt|;
name|ni
operator|->
name|ni_timoff
operator|=
name|se
operator|->
name|se_timoff
expr_stmt|;
name|ni
operator|->
name|ni_fhdwell
operator|=
name|se
operator|->
name|se_fhdwell
expr_stmt|;
name|ni
operator|->
name|ni_fhindex
operator|=
name|se
operator|->
name|se_fhindex
expr_stmt|;
name|ni
operator|->
name|ni_erp
operator|=
name|se
operator|->
name|se_erp
expr_stmt|;
name|IEEE80211_RSSI_LPF
argument_list|(
name|ni
operator|->
name|ni_avgrssi
argument_list|,
name|se
operator|->
name|se_rssi
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_noise
operator|=
name|se
operator|->
name|se_noise
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
comment|/* NB: only infrastructure mode requires an associd */
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ASSOCID
expr_stmt|;
block|}
if|if
condition|(
name|ieee80211_ies_init
argument_list|(
operator|&
name|ni
operator|->
name|ni_ies
argument_list|,
name|se
operator|->
name|se_ies
operator|.
name|data
argument_list|,
name|se
operator|->
name|se_ies
operator|.
name|len
argument_list|)
condition|)
block|{
name|ieee80211_ies_expand
argument_list|(
operator|&
name|ni
operator|->
name|ni_ies
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|ath_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_ath
argument_list|(
name|ni
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|ath_ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|htcap_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_htcap
argument_list|(
name|ni
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|htcap_ie
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|htinfo_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_htinfo
argument_list|(
name|ni
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|htinfo_ie
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|meshid_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_meshid
argument_list|(
name|ni
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|meshid_ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|tdma_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_tdma
argument_list|(
name|ni
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|tdma_ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|vap
operator|->
name|iv_dtim_period
operator|=
name|se
operator|->
name|se_dtimperiod
expr_stmt|;
name|vap
operator|->
name|iv_dtim_count
operator|=
literal|0
expr_stmt|;
comment|/* NB: must be after ni_chan is setup */
name|ieee80211_setup_rates
argument_list|(
name|ni
argument_list|,
name|se
operator|->
name|se_rates
argument_list|,
name|se
operator|->
name|se_xrates
argument_list|,
name|IEEE80211_F_DOSORT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_iserp_rateset
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ERP
expr_stmt|;
name|ieee80211_node_setuptxparms
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ieee80211_sta_join1
argument_list|(
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Leave the specified IBSS/BSS network.  The node is assumed to  * be passed in with a held reference.  */
end_comment

begin_function
name|void
name|ieee80211_sta_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ic
operator|->
name|ic_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Send a deauthenticate frame and drop the station.  */
end_comment

begin_function
name|void
name|ieee80211_node_deauth
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
comment|/* NB: bump the refcnt to be sure temporay nodes are not reclaimed */
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
name|IEEE80211_SEND_MGMT
argument_list|(
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|,
name|reason
argument_list|)
expr_stmt|;
name|ieee80211_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_node
modifier|*
name|node_alloc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize an ie blob with the specified data.  If previous  * data exists re-use the data block.  As a side effect we clear  * all references to specific ie's; the caller is required to  * recalculate them.  */
end_comment

begin_function
name|int
name|ieee80211_ies_init
parameter_list|(
name|struct
name|ieee80211_ies
modifier|*
name|ies
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
comment|/* NB: assumes data+len are the last fields */
name|memset
argument_list|(
name|ies
argument_list|,
literal|0
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|ieee80211_ies
argument_list|,
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ies
operator|->
name|data
operator|!=
name|NULL
operator|&&
name|ies
operator|->
name|len
operator|!=
name|len
condition|)
block|{
comment|/* data size changed */
name|free
argument_list|(
name|ies
operator|->
name|data
argument_list|,
name|M_80211_NODE_IE
argument_list|)
expr_stmt|;
name|ies
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ies
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|ies
operator|->
name|data
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|malloc
argument_list|(
name|len
argument_list|,
name|M_80211_NODE_IE
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|ies
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|ies
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* NB: pointers have already been zero'd above */
return|return
literal|0
return|;
block|}
block|}
name|memcpy
argument_list|(
name|ies
operator|->
name|data
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ies
operator|->
name|len
operator|=
name|len
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim storage for an ie blob.  */
end_comment

begin_function
name|void
name|ieee80211_ies_cleanup
parameter_list|(
name|struct
name|ieee80211_ies
modifier|*
name|ies
parameter_list|)
block|{
if|if
condition|(
name|ies
operator|->
name|data
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ies
operator|->
name|data
argument_list|,
name|M_80211_NODE_IE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Expand an ie blob data contents and to fillin individual  * ie pointers.  The data blob is assumed to be well-formed;  * we don't do any validity checking of ie lengths.  */
end_comment

begin_function
name|void
name|ieee80211_ies_expand
parameter_list|(
name|struct
name|ieee80211_ies
modifier|*
name|ies
parameter_list|)
block|{
name|uint8_t
modifier|*
name|ie
decl_stmt|;
name|int
name|ielen
decl_stmt|;
name|ie
operator|=
name|ies
operator|->
name|data
expr_stmt|;
name|ielen
operator|=
name|ies
operator|->
name|len
expr_stmt|;
while|while
condition|(
name|ielen
operator|>
literal|0
condition|)
block|{
switch|switch
condition|(
name|ie
index|[
literal|0
index|]
condition|)
block|{
case|case
name|IEEE80211_ELEMID_VENDOR
case|:
if|if
condition|(
name|iswpaoui
argument_list|(
name|ie
argument_list|)
condition|)
name|ies
operator|->
name|wpa_ie
operator|=
name|ie
expr_stmt|;
elseif|else
if|if
condition|(
name|iswmeoui
argument_list|(
name|ie
argument_list|)
condition|)
name|ies
operator|->
name|wme_ie
operator|=
name|ie
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
elseif|else
if|if
condition|(
name|isatherosoui
argument_list|(
name|ie
argument_list|)
condition|)
name|ies
operator|->
name|ath_ie
operator|=
name|ie
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
elseif|else
if|if
condition|(
name|istdmaoui
argument_list|(
name|ie
argument_list|)
condition|)
name|ies
operator|->
name|tdma_ie
operator|=
name|ie
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|IEEE80211_ELEMID_RSN
case|:
name|ies
operator|->
name|rsn_ie
operator|=
name|ie
expr_stmt|;
break|break;
case|case
name|IEEE80211_ELEMID_HTCAP
case|:
name|ies
operator|->
name|htcap_ie
operator|=
name|ie
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
case|case
name|IEEE80211_ELEMID_MESHID
case|:
name|ies
operator|->
name|meshid_ie
operator|=
name|ie
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|ielen
operator|-=
literal|2
operator|+
name|ie
index|[
literal|1
index|]
expr_stmt|;
name|ie
operator|+=
literal|2
operator|+
name|ie
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reclaim any resources in a node and reset any critical  * state.  Typically nodes are free'd immediately after,  * but in some cases the storage may be reused so we need  * to insure consistent state (should probably fix that).  */
end_comment

begin_function
specifier|static
name|void
name|node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* NB: preserve ni_table */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
name|vap
operator|->
name|iv_ps_sta
operator|--
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_PWR_MGT
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
name|ni
argument_list|,
literal|"power save mode off, %u sta's in ps mode"
argument_list|,
name|vap
operator|->
name|iv_ps_sta
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Cleanup any HT-related state. 	 */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
name|ieee80211_ht_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ath_flags
operator|&
name|IEEE80211_NODE_ATH
condition|)
name|ieee80211_ff_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
comment|/* 	 * Cleanup any mesh-related state. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|ieee80211_mesh_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Clear any staging queue entries. 	 */
name|ieee80211_ageq_drain_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * Clear AREF flag that marks the authorization refcnt bump 	 * has happened.  This is probably not needed as the node 	 * should always be removed from the table so not found but 	 * do it just in case. 	 * Likewise clear the ASSOCID flag as these flags are intended 	 * to be managed in tandem. 	 */
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
operator|(
name|IEEE80211_NODE_AREF
operator||
name|IEEE80211_NODE_ASSOCID
operator|)
expr_stmt|;
comment|/* 	 * Drain power save queue and, if needed, clear TIM. 	 */
if|if
condition|(
name|ieee80211_node_psq_drain
argument_list|(
name|ni
argument_list|)
operator|!=
literal|0
operator|&&
name|vap
operator|->
name|iv_set_tim
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_associd
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ni
operator|->
name|ni_challenge
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_challenge
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Preserve SSID, WPA, and WME ie's so the bss node is 	 * reusable during a re-auth/re-assoc state transition. 	 * If we remove these data they will not be recreated 	 * because they come from a probe-response or beacon frame 	 * which cannot be expected prior to the association-response. 	 * This should not be an issue when operating in other modes 	 * as stations leaving always go through a full state transition 	 * which will rebuild this state. 	 * 	 * XXX does this leave us open to inheriting old state? 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|ni
operator|->
name|ni_rxfrag
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Must be careful here to remove any key map entry w/o a LOR. 	 */
name|ieee80211_node_delucastkey
argument_list|(
name|ni
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|N
block|}
end_function

begin_function
specifier|static
name|void
name|node_free
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ic
operator|->
name|ic_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_ies_cleanup
argument_list|(
operator|&
name|ni
operator|->
name|ni_ies
argument_list|)
expr_stmt|;
name|ieee80211_psq_cleanup
argument_list|(
operator|&
name|ni
operator|->
name|ni_psq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ni
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_age
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_sta
argument_list|)
expr_stmt|;
comment|/* 	 * Age frames on the power save queue. 	 */
if|if
condition|(
name|ieee80211_node_psq_age
argument_list|(
name|ni
argument_list|)
operator|!=
literal|0
operator|&&
name|ni
operator|->
name|ni_psq
operator|.
name|psq_len
operator|==
literal|0
operator|&&
name|vap
operator|->
name|iv_set_tim
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_set_tim
argument_list|(
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Age out HT resources (e.g. frames on the 	 * A-MPDU reorder queues). 	 */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
operator|)
condition|)
name|ieee80211_ht_node_age
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int8_t
name|node_getrssi
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint32_t
name|avgrssi
init|=
name|ni
operator|->
name|ni_avgrssi
decl_stmt|;
name|int32_t
name|rssi
decl_stmt|;
if|if
condition|(
name|avgrssi
operator|==
name|IEEE80211_RSSI_DUMMY_MARKER
condition|)
return|return
literal|0
return|;
name|rssi
operator|=
name|IEEE80211_RSSI_GET
argument_list|(
name|avgrssi
argument_list|)
expr_stmt|;
return|return
name|rssi
operator|<
literal|0
condition|?
literal|0
else|:
name|rssi
operator|>
literal|127
condition|?
literal|127
else|:
name|rssi
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_getsignal
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
operator|*
name|rssi
operator|=
name|node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
operator|*
name|noise
operator|=
name|ni
operator|->
name|ni_noise
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|node_getmimoinfo
parameter_list|(
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_mimo_info
modifier|*
name|info
parameter_list|)
block|{
comment|/* XXX zero data? */
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_alloc_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|nt
operator|->
name|nt_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|vap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s> in %s table\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|ieee80211_node_initref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
name|ni
operator|->
name|ni_chan
operator|=
name|IEEE80211_CHAN_ANYC
expr_stmt|;
name|ni
operator|->
name|ni_authmode
operator|=
name|IEEE80211_AUTH_OPEN
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|ic
operator|->
name|ic_txpowlimit
expr_stmt|;
comment|/* max power */
name|ni
operator|->
name|ni_txparms
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
index|]
expr_stmt|;
name|ieee80211_crypto_resetkey
argument_list|(
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_avgrssi
operator|=
name|IEEE80211_RSSI_DUMMY_MARKER
expr_stmt|;
name|ni
operator|->
name|ni_inact_reload
operator|=
name|nt
operator|->
name|nt_inact_init
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
name|ni
operator|->
name|ni_inact_reload
expr_stmt|;
name|ni
operator|->
name|ni_ath_defkeyix
operator|=
literal|0x7fff
expr_stmt|;
name|ieee80211_psq_init
argument_list|(
operator|&
name|ni
operator|->
name|ni_psq
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|ieee80211_mesh_node_init
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|nt
operator|->
name|nt_hash
index|[
name|hash
index|]
argument_list|,
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|nt
expr_stmt|;
name|ni
operator|->
name|ni_vap
operator|=
name|vap
expr_stmt|;
name|ni
operator|->
name|ni_ic
operator|=
name|ic
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
argument_list|,
name|ni
argument_list|,
literal|"%s: inact_reload %u"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_inact_reload
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Craft a temporary node suitable for sending a management frame  * to the specified station.  We craft only as much state as we  * need to do the work since the node will be immediately reclaimed  * once the send completes.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_tmp_node
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ic
operator|->
name|ic_node_alloc
argument_list|(
name|vap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|bss
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s %p<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|NULL
expr_stmt|;
comment|/* NB: pedantic */
name|ni
operator|->
name|ni_ic
operator|=
name|ic
expr_stmt|;
comment|/* NB: needed to set channel */
name|ni
operator|->
name|ni_vap
operator|=
name|vap
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ieee80211_node_initref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
comment|/* NB: required by ieee80211_fix_rate */
name|ieee80211_node_set_chan
argument_list|(
name|ni
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|ieee80211_crypto_resetkey
argument_list|(
name|vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|,
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txpower
operator|=
name|bss
operator|->
name|ni_txpower
expr_stmt|;
comment|/* XXX optimize away */
name|ieee80211_psq_init
argument_list|(
operator|&
name|ni
operator|->
name|ni_psq
argument_list|,
literal|"unknown"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX msg */
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_nodealloc
operator|++
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_dup_bss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|bss
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
comment|/* 		 * Inherit from iv_bss. 		 */
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|bss
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|ieee80211_node_set_chan
argument_list|(
name|ni
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Create a bss node for a legacy WDS vap.  The far end does  * not associate so we just create create a new node and  * simulate an association.  The caller is responsible for  * installing the node as the bss node and handling any further  * setup work like authorizing the port.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_node_create_wds
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* XXX check if node already in sta table? */
name|ni
operator|=
name|ieee80211_alloc_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|vap
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|->
name|ni_wdsvap
operator|=
name|vap
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
comment|/* 		 * Inherit any manually configured settings. 		 */
name|copy_bss
argument_list|(
name|ni
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|ieee80211_node_set_chan
argument_list|(
name|ni
argument_list|,
name|chan
argument_list|)
expr_stmt|;
comment|/* NB: propagate ssid so available to WPA supplicant */
name|ni
operator|->
name|ni_esslen
operator|=
name|vap
operator|->
name|iv_des_ssid
index|[
literal|0
index|]
operator|.
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|vap
operator|->
name|iv_des_ssid
index|[
literal|0
index|]
operator|.
name|ssid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
comment|/* NB: no associd for peer */
comment|/* 		 * There are no management frames to use to 		 * discover neighbor capabilities, so blindly 		 * propagate the local configuration. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_FF
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_FF
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_HT
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HT
operator|)
condition|)
block|{
comment|/* 			 * Device is HT-capable and HT is enabled for 			 * the vap; setup HT operation.  On return 			 * ni_chan will be adjusted to an HT channel. 			 */
name|ieee80211_ht_wds_init
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|ni
operator|->
name|ni_chan
decl_stmt|;
comment|/* 			 * Force a legacy channel to be used. 			 */
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|c
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no legacy channel, %u/%x"
operator|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
operator|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
operator|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|c
expr_stmt|;
block|}
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_locked_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node_locked
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ni
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_node_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_node_locked
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_vap_node_locked_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_vap_node_locked
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|hash
operator|=
name|IEEE80211_NODE_HASH
argument_list|(
name|nt
operator|->
name|nt_ic
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_hash[hash]
argument_list|,
argument|ni_hash
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|==
name|vap
operator|&&
name|IEEE80211_ADDR_EQ
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
block|{
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* mark referenced */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ni
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_vap_node_debug
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_vap_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_find_vap_node_locked
argument_list|(
name|nt
argument_list|,
name|vap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Fake up a node; this handles node discovery in adhoc mode.  * Note that for the driver's benefit we we treat this like  * an association so the driver has an opportunity to setup  * it's private state.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_fakeup_adhoc_node
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: mac<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_dup_bss
argument_list|(
name|vap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
comment|/* XXX no rate negotiation; just dup */
name|ni
operator|->
name|ni_rates
operator|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_rates
expr_stmt|;
if|if
condition|(
name|ieee80211_iserp_rateset
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ERP
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 			 * In adhoc demo mode there are no management 			 * frames to use to discover neighbor capabilities, 			 * so blindly propagate the local configuration  			 * so we can do interesting things (e.g. use 			 * WME to disable ACK's). 			 */
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_FF
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_FF
expr_stmt|;
endif|#
directive|endif
block|}
name|ieee80211_node_setuptxparms
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX not right for 802.1x/WPA */
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_init_neighbor
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|ni
operator|->
name|ni_esslen
operator|=
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_essid
argument_list|,
name|sp
operator|->
name|ssid
operator|+
literal|2
argument_list|,
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
name|sp
operator|->
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ni
operator|->
name|ni_tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_intval
operator|=
name|sp
operator|->
name|bintval
expr_stmt|;
name|ni
operator|->
name|ni_capinfo
operator|=
name|sp
operator|->
name|capinfo
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_curchan
expr_stmt|;
name|ni
operator|->
name|ni_fhdwell
operator|=
name|sp
operator|->
name|fhdwell
expr_stmt|;
name|ni
operator|->
name|ni_fhindex
operator|=
name|sp
operator|->
name|fhindex
expr_stmt|;
name|ni
operator|->
name|ni_erp
operator|=
name|sp
operator|->
name|erp
expr_stmt|;
name|ni
operator|->
name|ni_timoff
operator|=
name|sp
operator|->
name|timoff
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|ieee80211_mesh_init_neighbor
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|sp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ieee80211_ies_init
argument_list|(
operator|&
name|ni
operator|->
name|ni_ies
argument_list|,
name|sp
operator|->
name|ies
argument_list|,
name|sp
operator|->
name|ies_len
argument_list|)
condition|)
block|{
name|ieee80211_ies_expand
argument_list|(
operator|&
name|ni
operator|->
name|ni_ies
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|wme_ie
operator|!=
name|NULL
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_QOS
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|ni
operator|->
name|ni_ies
operator|.
name|ath_ie
operator|!=
name|NULL
condition|)
name|ieee80211_parse_ath
argument_list|(
name|ni
argument_list|,
name|ni
operator|->
name|ni_ies
operator|.
name|ath_ie
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* NB: must be after ni_chan is setup */
name|ieee80211_setup_rates
argument_list|(
name|ni
argument_list|,
name|sp
operator|->
name|rates
argument_list|,
name|sp
operator|->
name|xrates
argument_list|,
name|IEEE80211_F_DOSORT
operator||
name|IEEE80211_F_DOFRATE
operator||
name|IEEE80211_F_DONEGO
operator||
name|IEEE80211_F_DODEL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Do node discovery in adhoc mode on receipt of a beacon  * or probe response frame.  Note that for the driver's  * benefit we we treat this like an association so the  * driver has an opportunity to setup it's private state.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
name|ieee80211_add_neighbor
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: mac<%s>\n"
argument_list|,
name|__func__
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_dup_bss
argument_list|(
name|vap
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
comment|/* XXX alloc_node? */
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|ieee80211_init_neighbor
argument_list|(
name|ni
argument_list|,
name|wh
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_iserp_rateset
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ERP
expr_stmt|;
name|ieee80211_node_setuptxparms
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX not right for 802.1x/WPA */
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ni
return|;
block|}
end_function

begin_define
define|#
directive|define
name|IS_PROBEREQ
parameter_list|(
name|wh
parameter_list|)
define|\
value|((wh->i_fc[0]& (IEEE80211_FC0_TYPE_MASK|IEEE80211_FC0_SUBTYPE_MASK)) \ 	    == (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_REQ))
end_define

begin_define
define|#
directive|define
name|IS_BCAST_PROBEREQ
parameter_list|(
name|wh
parameter_list|)
define|\
value|(IS_PROBEREQ(wh)&& IEEE80211_IS_MULTICAST( \ 	    ((const struct ieee80211_frame *)(wh))->i_addr3))
end_define

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ieee80211_node
operator|*
name|_find_rxnode
argument_list|(
argument|struct ieee80211_node_table *nt
argument_list|,
argument|const struct ieee80211_frame_min *wh
argument_list|)
block|{
if|if
condition|(
name|IS_BCAST_PROBEREQ
argument_list|(
name|wh
argument_list|)
condition|)
return|return
name|NULL
return|;
end_expr_stmt

begin_comment
comment|/* spam bcast probe req to all vap's */
end_comment

begin_return
return|return
name|ieee80211_find_node_locked
argument_list|(
name|nt
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/*  * Locate the node for sender, track state, and then pass the  * (referenced) node up to the 802.11 layer for its use.  Note  * we can return NULL if the sender is not in the table.  */
end_comment

begin_function
unit|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_rxnode_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_rxnode
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ni
operator|=
name|_find_rxnode
argument_list|(
name|nt
argument_list|,
name|wh
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_comment
comment|/*  * Like ieee80211_find_rxnode but use the supplied h/w  * key index as a hint to locate the node in the key  * mapping table.  If an entry is present at the key  * index we return it; otherwise do a normal lookup and  * update the mapping table if the station has a unicast  * key assigned to it.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_rxnode_withkey_debug
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
name|ieee80211_keyix
name|keyix
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_rxnode_withkey
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
parameter_list|,
name|ieee80211_keyix
name|keyix
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|nt
operator|=
operator|&
name|ic
operator|->
name|ic_sta
expr_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|)
name|ni
operator|=
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
expr_stmt|;
else|else
name|ni
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
name|ni
operator|=
name|_find_rxnode
argument_list|(
name|nt
argument_list|,
name|wh
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
operator|&&
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If the station has a unicast key cache slot 			 * assigned update the key->node mapping table. 			 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
comment|/* XXX can keyixmap[keyix] != NULL? */
if|if
condition|(
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: add key map entry %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|IS_BCAST_PROBEREQ
argument_list|(
name|wh
argument_list|)
condition|)
name|ni
operator|=
name|NULL
expr_stmt|;
comment|/* spam bcast probe req to all vap's */
else|else
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
return|return
name|ni
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|IS_BCAST_PROBEREQ
end_undef

begin_undef
undef|#
directive|undef
name|IS_PROBEREQ
end_undef

begin_comment
comment|/*  * Return a reference to the appropriate node for sending  * a data frame.  This handles node discovery in adhoc networks.  */
end_comment

begin_function
name|struct
name|ieee80211_node
modifier|*
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_find_txnode_debug
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_find_txnode
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
comment|/* 	 * The destination address should be in the node table 	 * unless this is a multicast/broadcast frame.  We can 	 * also optimize station mode operation, all frames go 	 * to the bss node. 	 */
comment|/* XXX can't hold lock across dup_bss 'cuz of recursive locking */
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|||
name|IEEE80211_IS_MULTICAST
argument_list|(
name|macaddr
argument_list|)
condition|)
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
else|else
name|ni
operator|=
name|ieee80211_find_node_locked
argument_list|(
name|nt
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 			 * In adhoc mode cons up a node for the destination. 			 * Note that we need an additional reference for the 			 * caller to be consistent with 			 * ieee80211_find_node_locked. 			 */
name|ni
operator|=
name|ieee80211_fakeup_adhoc_node
argument_list|(
name|vap
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|macaddr
argument_list|,
literal|"no node, discard frame (%s)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nonode
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ni
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
comment|/* 	 * NB: careful about referencing the vap as it may be 	 * gone if the last reference was held by a driver. 	 * We know the com will always be present so it's safe 	 * to use ni_ic below to reclaim resources. 	 */
if|#
directive|if
literal|0
block|IEEE80211_DPRINTF(vap, IEEE80211_MSG_NODE, 		"%s %p<%s> in %s table\n", __func__, ni, 		ether_sprintf(ni->ni_macaddr), 		nt != NULL ? nt->nt_name : "<gone>");
endif|#
directive|endif
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_aid_bitmap
operator|!=
name|NULL
condition|)
name|IEEE80211_AID_CLR
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|ni_ic
operator|->
name|ic_node_free
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|ieee80211_free_node_debug
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|,
name|int
name|line
parameter_list|)
else|#
directive|else
function|ieee80211_free_node
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG_REFCNT
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|func
argument_list|,
name|line
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
block|{
comment|/* 			 * Last reference, reclaim state. 			 */
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|==
literal|1
operator|&&
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_keyix
name|keyix
decl_stmt|;
comment|/* 			 * Check for a last reference in the key mapping table. 			 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
if|if
condition|(
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|ni
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s> clear key map entry"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX needed? */
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Reclaim a unicast key and clear any key cache state.  */
end_comment

begin_function
name|int
name|ieee80211_node_delucastkey
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|nikey
decl_stmt|;
name|ieee80211_keyix
name|keyix
decl_stmt|;
name|int
name|isowned
decl_stmt|,
name|status
decl_stmt|;
comment|/* 	 * NB: We must beware of LOR here; deleting the key 	 * can cause the crypto layer to block traffic updates 	 * which can generate a LOR against the node table lock; 	 * grab it here and stash the key index for our use below. 	 * 	 * Must also beware of recursion on the node table lock. 	 * When called from node_cleanup we may already have 	 * the node table lock held.  Unfortunately there's no 	 * way to separate out this path so we must do this 	 * conditionally. 	 */
name|isowned
operator|=
name|IEEE80211_NODE_IS_LOCKED
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isowned
condition|)
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|nikey
operator|=
name|NULL
expr_stmt|;
name|status
operator|=
literal|1
expr_stmt|;
comment|/* NB: success */
if|if
condition|(
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_keyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
block|{
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
name|status
operator|=
name|ieee80211_crypto_delkey
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|)
block|{
name|nikey
operator|=
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isowned
condition|)
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|nikey
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|nikey
operator|==
name|ni
argument_list|,
operator|(
literal|"key map out of sync, ni %p nikey %p"
operator|,
name|ni
operator|,
name|nikey
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: delete key map entry %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/*  * Reclaim a node.  If this is the last reference count then  * do the normal free work.  Otherwise remove it from the node  * table and mark it gone by clearing the back-reference.  */
end_comment

begin_function
specifier|static
name|void
name|node_reclaim
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|ieee80211_keyix
name|keyix
decl_stmt|;
name|IEEE80211_NODE_LOCK_ASSERT
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: remove %p<%s> from %s table, refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Clear any entry in the unicast key mapping table. 	 * We need to do it here so rx lookups don't find it 	 * in the mapping table even if it's not in the hash 	 * table.  We cannot depend on the mapping table entry 	 * being cleared because the node may not be free'd. 	 */
name|keyix
operator|=
name|ni
operator|->
name|ni_ucastkey
operator|.
name|wk_rxkeyix
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
operator|&&
name|keyix
operator|<
name|nt
operator|->
name|nt_keyixmax
operator|&&
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|==
name|ni
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"%s: %p<%s> clear key map entry %u\n"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
index|[
name|keyix
index|]
operator|=
name|NULL
expr_stmt|;
name|ieee80211_node_decref
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* NB: don't need free */
block|}
if|if
condition|(
operator|!
name|ieee80211_node_dectestref
argument_list|(
name|ni
argument_list|)
condition|)
block|{
comment|/* 		 * Other references are present, just remove the 		 * node from the table so it cannot be found.  When 		 * the references are dropped storage will be 		 * reclaimed. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|,
name|ni
argument_list|,
name|ni_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ni
argument_list|,
name|ni_hash
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_table
operator|=
name|NULL
expr_stmt|;
comment|/* clear reference */
block|}
else|else
name|_ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Node table support.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_table_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|inact
parameter_list|,
name|int
name|keyixmax
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|nt
operator|->
name|nt_ic
operator|=
name|ic
expr_stmt|;
name|IEEE80211_NODE_LOCK_INIT
argument_list|(
name|nt
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_ITERATE_LOCK_INIT
argument_list|(
name|nt
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nt
operator|->
name|nt_node
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_name
operator|=
name|name
expr_stmt|;
name|nt
operator|->
name|nt_scangen
operator|=
literal|1
expr_stmt|;
name|nt
operator|->
name|nt_inact_init
operator|=
name|inact
expr_stmt|;
name|nt
operator|->
name|nt_keyixmax
operator|=
name|keyixmax
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmax
operator|>
literal|0
condition|)
block|{
name|nt
operator|->
name|nt_keyixmap
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|keyixmax
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_node
operator|*
argument_list|)
argument_list|,
name|M_80211_NODE
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|==
name|NULL
condition|)
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"Cannot allocate key index map with %u entries\n"
argument_list|,
name|keyixmax
argument_list|)
expr_stmt|;
block|}
else|else
name|nt
operator|->
name|nt_keyixmap
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_node_table_reset
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|match
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|match
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_vap
operator|!=
name|match
condition|)
continue|continue;
comment|/* XXX can this happen?  if so need's work */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_auth
operator|->
name|ia_node_leave
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_auth
operator|->
name|ia_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_aid_bitmap
operator|!=
name|NULL
condition|)
name|IEEE80211_AID_CLR
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|ni_wdsvap
operator|=
name|NULL
expr_stmt|;
comment|/* clear reference */
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|match
operator|!=
name|NULL
operator|&&
name|match
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
condition|)
block|{
comment|/* 		 * Make a separate pass to clear references to this vap 		 * held by DWDS entries.  They will not be matched above 		 * because ni_vap will point to the ap vap but we still 		 * need to clear ni_wdsvap when the WDS vap is destroyed 		 * and/or reset. 		 */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|,
argument|next
argument_list|)
if|if
condition|(
name|ni
operator|->
name|ni_wdsvap
operator|==
name|match
condition|)
name|ni
operator|->
name|ni_wdsvap
operator|=
name|NULL
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_node_table_cleanup
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|ieee80211_node_table_reset
argument_list|(
name|nt
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DIAGNOSTIC
comment|/* XXX verify all entries are NULL */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nt
operator|->
name|nt_keyixmax
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nt
operator|->
name|nt_keyixmap
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"%s: %s[%u] still active\n"
argument_list|,
name|__func__
argument_list|,
name|nt
operator|->
name|nt_name
argument_list|,
name|i
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|nt
operator|->
name|nt_keyixmap
argument_list|,
name|M_80211_NODE
argument_list|)
expr_stmt|;
name|nt
operator|->
name|nt_keyixmap
operator|=
name|NULL
expr_stmt|;
block|}
name|IEEE80211_NODE_ITERATE_LOCK_DESTROY
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_LOCK_DESTROY
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Timeout inactive stations and do related housekeeping.  * Note that we cannot hold the node lock while sending a  * frame as this would lead to a LOR.  Instead we use a  * generation number to mark nodes that we've scanned and  * drop the lock and restart a scan if we have to time out  * a node.  Since we are single-threaded by virtue of  * controlling the inactivity timer we can be sure this will  * process each node only once.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_timeout_stations
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|int
name|gen
init|=
literal|0
decl_stmt|;
name|IEEE80211_NODE_ITERATE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|++
name|nt
operator|->
name|nt_scangen
expr_stmt|;
name|restart
label|:
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_scangen
operator|==
name|gen
condition|)
comment|/* previously handled */
continue|continue;
name|ni
operator|->
name|ni_scangen
operator|=
name|gen
expr_stmt|;
comment|/* 		 * Ignore entries for which have yet to receive an 		 * authentication frame.  These are transient and 		 * will be reclaimed when the last reference to them 		 * goes away (when frame xmits complete). 		 */
name|vap
operator|=
name|ni
operator|->
name|ni_vap
expr_stmt|;
comment|/* 		 * Only process stations when in RUN state.  This 		 * insures, for example, that we don't timeout an 		 * inactive station during CAC.  Note that CSA state 		 * is actually handled in ieee80211_node_timeout as 		 * it applies to more than timeout processing. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
continue|continue;
comment|/* XXX can vap be NULL? */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AREF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Free fragment if not needed anymore 		 * (last fragment older than 1s). 		 * XXX doesn't belong here, move to node_age 		 */
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|!=
name|NULL
operator|&&
name|ticks
operator|>
name|ni
operator|->
name|ni_rxfragstamp
operator|+
name|hz
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ni
operator|->
name|ni_inact
operator|>
literal|0
condition|)
block|{
name|ni
operator|->
name|ni_inact
operator|--
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
argument_list|,
name|ni
argument_list|,
literal|"%s: inact %u inact_reload %u nrates %u"
argument_list|,
name|__func__
argument_list|,
name|ni
operator|->
name|ni_inact
argument_list|,
name|ni
operator|->
name|ni_inact_reload
argument_list|,
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Special case ourself; we may be idle for extended periods 		 * of time and regardless reclaiming our state is wrong. 		 * XXX run ic_node_age 		 */
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
condition|)
continue|continue;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
operator|||
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|)
condition|)
block|{
comment|/* 			 * Age/drain resources held by the station. 			 */
name|ic
operator|->
name|ic_node_age
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 			 * Probe the station before time it out.  We 			 * send a null data frame which may not be 			 * universally supported by drivers (need it 			 * for ps-poll support so it should be...). 			 * 			 * XXX don't probe the station unless we've 			 *     received a frame from them (and have 			 *     some idea of the rates they are capable 			 *     of); this will get fixed more properly 			 *     soon with better handling of the rate set. 			 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_INACT
operator|)
operator|&&
operator|(
literal|0
operator|<
name|ni
operator|->
name|ni_inact
operator|&&
name|ni
operator|->
name|ni_inact
operator|<=
name|vap
operator|->
name|iv_inact_probe
operator|)
operator|&&
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
operator||
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"probe station due to inactivity"
argument_list|)
expr_stmt|;
comment|/* 				 * Grab a reference before unlocking the table 				 * so the node cannot be reclaimed before we 				 * send the frame. ieee80211_send_nulldata 				 * understands we've done this and reclaims the 				 * ref for us as needed. 				 */
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|ieee80211_send_nulldata
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX stat? */
goto|goto
name|restart
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_INACT
operator|)
operator|&&
name|ni
operator|->
name|ni_inact
operator|<=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INACT
operator||
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"station timed out due to inactivity "
literal|"(refcnt %u)"
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Send a deauthenticate frame and drop the station. 			 * This is somewhat complicated due to reference counts 			 * and locking.  At this point a station will typically 			 * have a reference count of 1.  ieee80211_node_leave 			 * will do a "free" of the node which will drop the 			 * reference count.  But in the meantime a reference 			 * wil be held by the deauth frame.  The actual reclaim 			 * of the node will happen either after the tx is 			 * completed or by ieee80211_node_leave. 			 * 			 * Separately we must drop the node lock before sending 			 * in case the driver takes a lock, as this can result 			 * in a LOR between the node lock and the driver lock. 			 */
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|,
name|IEEE80211_REASON_AUTH_EXPIRE
argument_list|)
expr_stmt|;
block|}
name|ieee80211_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_node_timeout
operator|++
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_ITERATE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Aggressively reclaim resources.  This should be used  * only in a critical situation to reclaim mbuf resources.  */
end_comment

begin_function
name|void
name|ieee80211_drain
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
operator|&
name|ic
operator|->
name|ic_sta
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
comment|/* 		 * Ignore entries for which have yet to receive an 		 * authentication frame.  These are transient and 		 * will be reclaimed when the last reference to them 		 * goes away (when frame xmits complete). 		 */
name|vap
operator|=
name|ni
operator|->
name|ni_vap
expr_stmt|;
comment|/* 		 * Only process stations when in RUN state.  This 		 * insures, for example, that we don't timeout an 		 * inactive station during CAC.  Note that CSA state 		 * is actually handled in ieee80211_node_timeout as 		 * it applies to more than timeout processing. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
condition|)
continue|continue;
comment|/* XXX can vap be NULL? */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|)
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AREF
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Free fragments. 		 * XXX doesn't belong here, move to node_drain 		 */
if|if
condition|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_rxfrag
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Drain resources held by the station. 		 */
name|ic
operator|->
name|ic_node_drain
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Per-ieee80211com inactivity timer callback.  */
end_comment

begin_function
name|void
name|ieee80211_node_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
comment|/* 	 * Defer timeout processing if a channel switch is pending. 	 * We typically need to be mute so not doing things that 	 * might generate frames is good to handle in one place. 	 * Supressing the station timeout processing may extend the 	 * lifetime of inactive stations (by not decrementing their 	 * idle counters) but this should be ok unless the CSA is 	 * active for an unusually long time. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_CSAPENDING
operator|)
operator|==
literal|0
condition|)
block|{
name|ieee80211_scan_timeout
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_timeout_stations
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_ageq_age
argument_list|(
operator|&
name|ic
operator|->
name|ic_stageq
argument_list|,
name|IEEE80211_INACT_WAIT
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_erp_timeout
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_ht_timeout
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|callout_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_inact
argument_list|,
name|IEEE80211_INACT_WAIT
operator|*
name|hz
argument_list|,
name|ieee80211_node_timeout
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_iterate_nodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|ieee80211_iter_func
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|IEEE80211_NODE_ITERATE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|gen
operator|=
operator|++
name|nt
operator|->
name|nt_scangen
expr_stmt|;
name|restart
label|:
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ni
argument_list|,
argument|&nt->nt_node
argument_list|,
argument|ni_list
argument_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_scangen
operator|!=
name|gen
condition|)
block|{
name|ni
operator|->
name|ni_scangen
operator|=
name|gen
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|arg
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_ITERATE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dump_node
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|printf
argument_list|(
literal|"0x%p: mac %s refcnt %d\n"
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tscangen %u authmode %u flags 0x%x\n"
argument_list|,
name|ni
operator|->
name|ni_scangen
argument_list|,
name|ni
operator|->
name|ni_authmode
argument_list|,
name|ni
operator|->
name|ni_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tassocid 0x%x txpower %u vlan %u\n"
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|,
name|ni
operator|->
name|ni_txpower
argument_list|,
name|ni
operator|->
name|ni_vlan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\ttxseq %u rxseq %u fragno %u rxfragstamp %u\n"
argument_list|,
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
argument_list|,
name|ni
operator|->
name|ni_rxseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|,
name|ni
operator|->
name|ni_rxseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|&
name|IEEE80211_SEQ_FRAG_MASK
argument_list|,
name|ni
operator|->
name|ni_rxfragstamp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\trssi %d noise %d intval %u capinfo 0x%x\n"
argument_list|,
name|node_getrssi
argument_list|(
name|ni
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_noise
argument_list|,
name|ni
operator|->
name|ni_intval
argument_list|,
name|ni
operator|->
name|ni_capinfo
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tbssid %s essid \"%.*s\" channel %u:0x%x\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tinact %u inact_reload %u txrate %u\n"
argument_list|,
name|ni
operator|->
name|ni_inact
argument_list|,
name|ni
operator|->
name|ni_inact_reload
argument_list|,
name|ni
operator|->
name|ni_txrate
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\thtcap %x htparam %x htctlchan %u ht2ndchan %u\n"
argument_list|,
name|ni
operator|->
name|ni_htcap
argument_list|,
name|ni
operator|->
name|ni_htparam
argument_list|,
name|ni
operator|->
name|ni_htctlchan
argument_list|,
name|ni
operator|->
name|ni_ht2ndchan
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\thtopmode %x htstbc %x chw %u\n"
argument_list|,
name|ni
operator|->
name|ni_htopmode
argument_list|,
name|ni
operator|->
name|ni_htstbc
argument_list|,
name|ni
operator|->
name|ni_chw
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dump_nodes
parameter_list|(
name|struct
name|ieee80211_node_table
modifier|*
name|nt
parameter_list|)
block|{
name|ieee80211_iterate_nodes
argument_list|(
name|nt
argument_list|,
operator|(
name|ieee80211_iter_func
operator|*
operator|)
name|ieee80211_dump_node
argument_list|,
name|nt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_notify_erp_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_ERP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_erp
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_notify_erp_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a station joining an 11g network.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_join_11g
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Station isn't capable of short slot time.  Bump 	 * the count of long slot time stations and disable 	 * use of short slot time.  Note that the actual switch 	 * over to long slot time use may not occur until the 	 * next beacon transmission (per sec. 7.3.1.4 of 11g). 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_longslotsta
operator|++
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"station needs long slot time, count %d"
argument_list|,
name|ic
operator|->
name|ic_longslotsta
argument_list|)
expr_stmt|;
comment|/* XXX vap's w/ conflicting needs won't work */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
comment|/* 			 * Don't force slot time when switched to turbo 			 * mode as non-ERP stations won't be present; this 			 * need only be done when on the normal G channel. 			 */
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If the new station is not an ERP station 	 * then bump the counter and enable protection 	 * if configured. 	 */
if|if
condition|(
operator|!
name|ieee80211_iserp_rateset
argument_list|(
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
condition|)
block|{
name|ic
operator|->
name|ic_nonerpsta
operator|++
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"station is !ERP, %d non-ERP stations associated"
argument_list|,
name|ic
operator|->
name|ic_nonerpsta
argument_list|)
expr_stmt|;
comment|/* 		 * If station does not support short preamble 		 * then we must enable use of Barker preamble. 		 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"station needs long preamble"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEBARKER
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
block|}
comment|/* 		 * If protection is configured and this is the first 		 * indication we should use protection, enable it. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_protmode
operator|!=
name|IEEE80211_PROT_NONE
operator|&&
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|1
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: enable use of protection\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEPROT
expr_stmt|;
name|ieee80211_notify_erp_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_ERP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_node_join
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|resp
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|newassoc
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
block|{
name|uint16_t
name|aid
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_aid_bitmap
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no aid bitmap"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * It would be good to search the bitmap 		 * more efficiently, but this will do for now. 		 */
for|for
control|(
name|aid
operator|=
literal|1
init|;
name|aid
operator|<
name|vap
operator|->
name|iv_max_aid
condition|;
name|aid
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_AID_ISSET
argument_list|(
name|vap
argument_list|,
name|aid
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|aid
operator|>=
name|vap
operator|->
name|iv_max_aid
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ni
argument_list|,
name|resp
argument_list|,
name|IEEE80211_STATUS_TOOMANY
argument_list|)
expr_stmt|;
name|ieee80211_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return;
block|}
name|ni
operator|->
name|ni_associd
operator|=
name|aid
operator||
literal|0xc000
expr_stmt|;
name|ni
operator|->
name|ni_jointime
operator|=
name|time_uptime
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_AID_SET
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_sta_assoc
operator|++
expr_stmt|;
name|ic
operator|->
name|ic_sta_assoc
operator|++
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_ht_node_join
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_FULL
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_node_join_11g
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|newassoc
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|newassoc
operator|=
literal|0
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
name|ni
argument_list|,
literal|"station associated at aid %d: %s preamble, %s slot time%s%s%s%s%s%s%s%s"
argument_list|,
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|?
literal|"short"
else|:
literal|"long"
argument_list|,
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|?
literal|", protection"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|?
literal|", QoS"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|?
operator|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
condition|?
literal|", HT40"
else|:
literal|", HT20"
operator|)
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AMPDU
condition|?
literal|" (+AMPDU)"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_MIMO_RTS
condition|?
literal|" (+SMPS-DYN)"
else|:
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_MIMO_PS
condition|?
literal|" (+SMPS)"
else|:
literal|""
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_RIFS
condition|?
literal|" (+RIFS)"
else|:
literal|""
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_FF
argument_list|)
condition|?
literal|", fast-frames"
else|:
literal|""
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_TURBOP
argument_list|)
condition|?
literal|", turbo"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ieee80211_node_setuptxparms
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* give driver a chance to setup state like ni_txrate */
if|if
condition|(
name|ic
operator|->
name|ic_newassoc
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_newassoc
argument_list|(
name|ni
argument_list|,
name|newassoc
argument_list|)
expr_stmt|;
name|IEEE80211_SEND_MGMT
argument_list|(
name|ni
argument_list|,
name|resp
argument_list|,
name|IEEE80211_STATUS_SUCCESS
argument_list|)
expr_stmt|;
comment|/* tell the authenticator about new station */
if|if
condition|(
name|vap
operator|->
name|iv_auth
operator|->
name|ia_node_join
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_auth
operator|->
name|ia_node_join
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_join
argument_list|(
name|ni
argument_list|,
name|resp
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disable_protection
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"%d non ERP stations, flags 0x%x"
operator|,
name|ic
operator|->
name|ic_nonerpsta
operator|,
name|ic
operator|->
name|ic_flags_ext
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEPROT
expr_stmt|;
comment|/* XXX verify mode? */
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHPREAMBLE
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
name|ieee80211_notify_erp_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a station leaving an 11g network.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_node_leave_11g
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
argument_list|,
operator|(
literal|"not in 11g, bss %u:0x%x"
operator|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
operator|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_flags
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If a long slot station do the slot time bookkeeping. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_longslotsta
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus long slot station count %d"
operator|,
name|ic
operator|->
name|ic_longslotsta
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_longslotsta
operator|--
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"long slot time station leaves, count now %d"
argument_list|,
name|ic
operator|->
name|ic_longslotsta
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_longslotsta
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Re-enable use of short slot time if supported 			 * and not operating in IBSS mode (per spec). 			 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_IBSS
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: re-enable use of short slot time\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If a non-ERP station do the protection-related bookkeeping. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_ERP
operator|)
operator|==
literal|0
condition|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_nonerpsta
operator|>
literal|0
argument_list|,
operator|(
literal|"bogus non-ERP station count %d"
operator|,
name|ic
operator|->
name|ic_nonerpsta
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_nonerpsta
operator|--
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"non-ERP station leaves, count now %d%s"
argument_list|,
name|ic
operator|->
name|ic_nonerpsta
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
condition|?
literal|" (non-ERP sta present)"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"%s: disable use of protection\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|disable_protection
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Time out presence of an overlapping bss with non-ERP  * stations.  When operating in hostap mode we listen for  * beacons from other stations and if we identify a non-ERP  * station is present we enable protection.  To identify  * when all non-ERP stations are gone we time out this  * condition.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_erp_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONERP_PR
operator|)
operator|&&
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastnonerp
operator|+
name|IEEE80211_NONERP_PRESENT_AGE
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|IEEE80211_NOTE(vap, IEEE80211_MSG_ASSOC, ni, 		    "%s", "age out non-ERP sta present on channel");
endif|#
directive|endif
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_NONERP_PR
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|==
literal|0
condition|)
name|disable_protection
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle bookkeeping for station deauthentication/disassociation  * when operating as an ap.  */
end_comment

begin_function
name|void
name|ieee80211_node_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_node_table
modifier|*
name|nt
init|=
name|ni
operator|->
name|ni_table
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
name|ni
argument_list|,
literal|"station with aid %d leaves"
argument_list|,
name|IEEE80211_NODE_AID
argument_list|(
name|ni
argument_list|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"unexpected operating mode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If node wasn't previously associated all 	 * we need to do is reclaim the reference. 	 */
comment|/* XXX ibss mode bypasses 11g and notification */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Tell the authenticator the station is leaving. 	 * Note that we must do this before yanking the 	 * association id as the authenticator uses the 	 * associd to locate it's state block. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_auth
operator|->
name|ia_node_leave
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_auth
operator|->
name|ia_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_AID_CLR
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_associd
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|iv_sta_assoc
operator|--
expr_stmt|;
name|ic
operator|->
name|ic_sta_assoc
operator|--
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_ht_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_FULL
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ieee80211_node_leave_11g
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Cleanup station state.  In particular clear various 	 * state that might otherwise be reused if the node 	 * is reused before the reference count goes to zero 	 * (and memory is reclaimed). 	 */
name|ieee80211_sta_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|done
label|:
comment|/* 	 * Remove the node from any table it's recorded in and 	 * drop the caller's reference.  Removal from the table 	 * is important to insure the node is not reprocessed 	 * for inactivity. 	 */
if|if
condition|(
name|nt
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_NODE_LOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
name|node_reclaim
argument_list|(
name|nt
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_UNLOCK
argument_list|(
name|nt
argument_list|)
expr_stmt|;
block|}
else|else
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|rssiinfo
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|rssi_samples
decl_stmt|;
name|uint32_t
name|rssi_total
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|get_hostap_rssi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|rssiinfo
modifier|*
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int8_t
name|rssi
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|vap
operator|!=
name|vap
condition|)
return|return;
comment|/* only associated stations */
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
condition|)
return|return;
name|rssi
operator|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|rssi_samples
operator|++
expr_stmt|;
name|info
operator|->
name|rssi_total
operator|+=
name|rssi
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_adhoc_rssi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|rssiinfo
modifier|*
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int8_t
name|rssi
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|vap
operator|!=
name|vap
condition|)
return|return;
comment|/* only neighbors */
comment|/* XXX check bssid */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
return|return;
name|rssi
operator|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|rssi_samples
operator|++
expr_stmt|;
name|info
operator|->
name|rssi_total
operator|+=
name|rssi
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
end_ifdef

begin_function
specifier|static
name|void
name|get_mesh_rssi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|rssiinfo
modifier|*
name|info
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int8_t
name|rssi
decl_stmt|;
if|if
condition|(
name|info
operator|->
name|vap
operator|!=
name|vap
condition|)
return|return;
comment|/* only neighbors that peered successfully */
if|if
condition|(
name|ni
operator|->
name|ni_mlstate
operator|!=
name|IEEE80211_NODE_MESH_ESTABLISHED
condition|)
return|return;
name|rssi
operator|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|!=
literal|0
condition|)
block|{
name|info
operator|->
name|rssi_samples
operator|++
expr_stmt|;
name|info
operator|->
name|rssi_total
operator|+=
name|rssi
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_MESH */
end_comment

begin_function
name|int8_t
name|ieee80211_getrssi
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|NZ
parameter_list|(
name|x
parameter_list|)
value|((x) == 0 ? 1 : (x))
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|rssiinfo
name|info
decl_stmt|;
name|info
operator|.
name|rssi_total
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|rssi_samples
operator|=
literal|0
expr_stmt|;
name|info
operator|.
name|vap
operator|=
name|vap
expr_stmt|;
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_IBSS
case|:
comment|/* average of all ibss neighbors */
case|case
name|IEEE80211_M_AHDEMO
case|:
comment|/* average of all neighbors */
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|get_adhoc_rssi
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
comment|/* average of all associated stations */
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|get_hostap_rssi
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
case|case
name|IEEE80211_M_MBSS
case|:
comment|/* average of all mesh neighbors */
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|get_mesh_rssi
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* XXX */
case|case
name|IEEE80211_M_STA
case|:
comment|/* use stats from associated ap */
default|default:
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|!=
name|NULL
condition|)
name|info
operator|.
name|rssi_total
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|info
operator|.
name|rssi_samples
operator|=
literal|1
expr_stmt|;
break|break;
block|}
return|return
name|info
operator|.
name|rssi_total
operator|/
name|NZ
argument_list|(
name|info
operator|.
name|rssi_samples
argument_list|)
return|;
undef|#
directive|undef
name|NZ
block|}
end_function

begin_function
name|void
name|ieee80211_getsignal
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int8_t
modifier|*
name|rssi
parameter_list|,
name|int8_t
modifier|*
name|noise
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|==
name|NULL
condition|)
comment|/* NB: shouldn't happen */
return|return;
name|vap
operator|->
name|iv_ic
operator|->
name|ic_node_getsignal
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|,
name|rssi
argument_list|,
name|noise
argument_list|)
expr_stmt|;
comment|/* for non-station mode return avg'd rssi accounting */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
operator|*
name|rssi
operator|=
name|ieee80211_getrssi
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

