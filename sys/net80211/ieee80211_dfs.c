begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2008 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11 DFS/Radar support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_DFS
argument_list|,
literal|"80211dfs"
argument_list|,
literal|"802.11 DFS state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_nol_timeout
init|=
literal|30
operator|*
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 30 minutes */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|nol_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_nol_timeout
argument_list|,
literal|0
argument_list|,
literal|"NOL timeout (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|NOL_TIMEOUT
value|msecs_to_ticks(ieee80211_nol_timeout*1000)
end_define

begin_decl_stmt
specifier|static
name|int
name|ieee80211_cac_timeout
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 60 seconds */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|cac_timeout
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_cac_timeout
argument_list|,
literal|0
argument_list|,
literal|"CAC timeout (secs)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|CAC_TIMEOUT
value|msecs_to_ticks(ieee80211_cac_timeout*1000)
end_define

begin_function
name|void
name|ieee80211_dfs_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|callout_init
argument_list|(
operator|&
name|dfs
operator|->
name|nol_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|dfs
operator|->
name|cac_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dfs_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* NB: we assume no locking is needed */
name|ieee80211_dfs_reset
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dfs_reset
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* NB: we assume no locking is needed */
comment|/* NB: cac_timer should be cleared by the state machine */
name|callout_drain
argument_list|(
operator|&
name|dfs
operator|->
name|nol_timer
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
operator|.
name|ic_state
operator|=
literal|0
expr_stmt|;
name|dfs
operator|->
name|lastchan
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cac_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_CAC
condition|)
comment|/* NB: just in case */
return|return;
comment|/* 	 * When radar is detected during a CAC we are woken 	 * up prematurely to switch to a new channel. 	 * Check the channel to decide how to act. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
name|ieee80211_notify_cac
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|IEEE80211_NOTIFY_CAC_RADAR
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"CAC timer on channel %u (%u MHz) stopped due to radar\n"
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_ieee
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
comment|/* XXX clobbers any existing desired channel */
comment|/* NB: dfs->newchan may be NULL, that's ok */
name|vap
operator|->
name|iv_des_chan
operator|=
name|dfs
operator|->
name|newchan
expr_stmt|;
name|ieee80211_new_state
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"CAC timer on channel %u (%u MHz) expired; "
literal|"no radar detected\n"
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_ieee
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
comment|/* 		 * Mark all channels with the current frequency 		 * as having completed CAC; this keeps us from 		 * doing it again until we change channels. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
condition|)
name|c
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_CACDONE
expr_stmt|;
block|}
name|ieee80211_notify_cac
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|IEEE80211_NOTIFY_CAC_EXPIRE
argument_list|)
expr_stmt|;
name|ieee80211_cac_completeswitch
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Initiate the CAC timer.  The driver is responsible  * for setting up the hardware to scan for radar on the  * channnel, we just handle timing things out.  */
end_comment

begin_function
name|void
name|ieee80211_dfs_cac_start
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|dfs
operator|->
name|cac_timer
argument_list|,
name|CAC_TIMEOUT
argument_list|,
name|cac_timeout
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"start %d second CAC timer on channel %u (%u MHz)\n"
argument_list|,
name|ticks_to_secs
argument_list|(
name|CAC_TIMEOUT
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_ieee
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|ieee80211_notify_cac
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|IEEE80211_NOTIFY_CAC_START
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clear the CAC timer.  */
end_comment

begin_function
name|void
name|ieee80211_dfs_cac_stop
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* NB: racey but not important */
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|dfs
operator|->
name|cac_timer
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"stop CAC timer on channel %u (%u MHz)\n"
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_ieee
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
name|ieee80211_notify_cac
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|,
name|IEEE80211_NOTIFY_CAC_STOP
argument_list|)
expr_stmt|;
block|}
comment|/* XXX cannot use drain 'cuz holding a lock */
name|callout_stop
argument_list|(
operator|&
name|dfs
operator|->
name|cac_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_dfs_cac_clear
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|chan
operator|->
name|ic_freq
condition|)
name|c
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_CACDONE
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dfs_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|oldest
decl_stmt|,
name|now
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|now
operator|=
name|oldest
operator|=
name|ticks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|time_after_eq
argument_list|(
name|now
argument_list|,
name|dfs
operator|->
name|nol_event
index|[
name|i
index|]
operator|+
name|NOL_TIMEOUT
argument_list|)
condition|)
block|{
name|c
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_RADAR
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_state
operator|&
name|IEEE80211_CHANSTATE_NORADAR
condition|)
block|{
comment|/* 					 * NB: do this here so we get only one 					 * msg instead of one for every channel 					 * table entry. 					 */
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"radar on channel"
literal|" %u (%u MHz) cleared after timeout\n"
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
comment|/* notify user space */
name|c
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_NORADAR
expr_stmt|;
name|ieee80211_notify_radar
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dfs
operator|->
name|nol_event
index|[
name|i
index|]
operator|<
name|oldest
condition|)
name|oldest
operator|=
name|dfs
operator|->
name|nol_event
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldest
operator|!=
name|now
condition|)
block|{
comment|/* arrange to process next channel up for a status change */
name|callout_reset
argument_list|(
operator|&
name|dfs
operator|->
name|nol_timer
argument_list|,
name|oldest
operator|+
name|NOL_TIMEOUT
argument_list|,
name|dfs_timeout
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|announce_radar
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|curchan
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|newchan
parameter_list|)
block|{
if|if
condition|(
name|newchan
operator|==
name|NULL
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"radar detected on channel %u (%u MHz)\n"
argument_list|,
name|curchan
operator|->
name|ic_ieee
argument_list|,
name|curchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
else|else
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"radar detected on channel %u (%u MHz), "
literal|"moving to channel %u (%u MHz)\n"
argument_list|,
name|curchan
operator|->
name|ic_ieee
argument_list|,
name|curchan
operator|->
name|ic_freq
argument_list|,
name|newchan
operator|->
name|ic_ieee
argument_list|,
name|newchan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a radar detection event on a channel. The channel is  * added to the NOL list and we record the time of the event.  * Entries are aged out after NOL_TIMEOUT.  If radar was  * detected while doing CAC we force a state/channel change.  * Otherwise radar triggers a channel switch using the CSA  * mechanism (when the channel is the bss channel).  */
end_comment

begin_function
name|void
name|ieee80211_dfs_notify_radar
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211_dfs_state
modifier|*
name|dfs
init|=
operator|&
name|ic
operator|->
name|ic_dfs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|now
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Mark all entries with this frequency.  Notify user 	 * space and arrange for notification when the radar 	 * indication is cleared.  Then kick the NOL processing 	 * thread if not already running. 	 */
name|now
operator|=
name|ticks
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|chan
operator|->
name|ic_freq
condition|)
block|{
name|c
operator|->
name|ic_state
operator|&=
operator|~
name|IEEE80211_CHANSTATE_CACDONE
expr_stmt|;
name|c
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_RADAR
expr_stmt|;
name|dfs
operator|->
name|nol_event
index|[
name|i
index|]
operator|=
name|now
expr_stmt|;
block|}
block|}
name|ieee80211_notify_radar
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|chan
operator|->
name|ic_state
operator||=
name|IEEE80211_CHANSTATE_NORADAR
expr_stmt|;
if|if
condition|(
operator|!
name|callout_pending
argument_list|(
operator|&
name|dfs
operator|->
name|nol_timer
argument_list|)
condition|)
name|callout_reset
argument_list|(
operator|&
name|dfs
operator|->
name|nol_timer
argument_list|,
name|NOL_TIMEOUT
argument_list|,
name|dfs_timeout
argument_list|,
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * If radar is detected on the bss channel while 	 * doing CAC; force a state change by scheduling the 	 * callout to be dispatched asap.  Otherwise, if this 	 * event is for the bss channel then we must quiet 	 * traffic and schedule a channel switch. 	 * 	 * Note this allows us to receive notification about 	 * channels other than the bss channel; not sure 	 * that can/will happen but it's simple to support. 	 */
if|if
condition|(
name|chan
operator|==
name|ic
operator|->
name|ic_bsschan
condition|)
block|{
comment|/* XXX need a way to defer to user app */
name|dfs
operator|->
name|newchan
operator|=
name|ieee80211_dfs_pickchannel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|announce_radar
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
name|chan
argument_list|,
name|dfs
operator|->
name|newchan
argument_list|)
expr_stmt|;
if|if
condition|(
name|callout_pending
argument_list|(
operator|&
name|dfs
operator|->
name|cac_timer
argument_list|)
condition|)
name|callout_schedule
argument_list|(
operator|&
name|dfs
operator|->
name|cac_timer
argument_list|,
literal|0
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dfs
operator|->
name|newchan
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX mode 1, switch count 2 */
comment|/* XXX calculate switch count based on max 			  switch time and beacon interval? */
name|ieee80211_csa_startswitch
argument_list|(
name|ic
argument_list|,
name|dfs
operator|->
name|newchan
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Spec says to stop all transmissions and 			 * wait on the current channel for an entry 			 * on the NOL to expire. 			 */
comment|/*XXX*/
block|}
block|}
else|else
block|{
comment|/* 		 * Issue rate-limited console msgs. 		 */
if|if
condition|(
name|dfs
operator|->
name|lastchan
operator|!=
name|chan
condition|)
block|{
name|dfs
operator|->
name|lastchan
operator|=
name|chan
expr_stmt|;
name|dfs
operator|->
name|cureps
operator|=
literal|0
expr_stmt|;
name|announce_radar
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
name|chan
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|dfs
operator|->
name|lastevent
argument_list|,
operator|&
name|dfs
operator|->
name|cureps
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|announce_radar
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
name|chan
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_dfs_pickchannel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flags
decl_stmt|;
name|uint16_t
name|v
decl_stmt|;
comment|/* 	 * Consult the scan cache first. 	 */
name|flags
operator|=
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALL
expr_stmt|;
comment|/* 	 * XXX if curchan is HT this will never find a channel 	 * XXX 'cuz we scan only legacy channels 	 */
name|c
operator|=
name|ieee80211_scan_pickchannel
argument_list|(
name|ic
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
return|return
name|c
return|;
comment|/* 	 * No channel found in scan cache; select a compatible 	 * one at random (skipping channels where radar has 	 * been detected). 	 */
name|get_random_bytes
argument_list|(
operator|&
name|v
argument_list|,
sizeof|sizeof
argument_list|(
name|v
argument_list|)
argument_list|)
expr_stmt|;
name|v
operator|%=
name|ic
operator|->
name|ic_nchans
expr_stmt|;
for|for
control|(
name|i
operator|=
name|v
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
return|return
name|c
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|v
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|flags
operator|)
operator|==
name|flags
condition|)
return|return
name|c
return|;
block|}
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"HELP, no channel located to switch to!\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

end_unit

