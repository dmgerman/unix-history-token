begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskqueue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_comment
comment|/* XXX for ether_sprintf */
end_comment

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_adhoc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_sta.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_hostap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_wds.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_monitor.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_comment
comment|/* XXX tunables */
end_comment

begin_define
define|#
directive|define
name|AGGRESSIVE_MODE_SWITCH_HYSTERESIS
value|3
end_define

begin_comment
comment|/* pkts / 100ms */
end_comment

begin_define
define|#
directive|define
name|HIGH_PRI_SWITCH_THRESH
value|10
end_define

begin_comment
comment|/* pkts / 100ms */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_mgt_subtype_name
index|[]
init|=
block|{
literal|"assoc_req"
block|,
literal|"assoc_resp"
block|,
literal|"reassoc_req"
block|,
literal|"reassoc_resp"
block|,
literal|"probe_req"
block|,
literal|"probe_resp"
block|,
literal|"reserved#6"
block|,
literal|"reserved#7"
block|,
literal|"beacon"
block|,
literal|"atim"
block|,
literal|"disassoc"
block|,
literal|"auth"
block|,
literal|"deauth"
block|,
literal|"action"
block|,
literal|"reserved#14"
block|,
literal|"reserved#15"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_ctl_subtype_name
index|[]
init|=
block|{
literal|"reserved#0"
block|,
literal|"reserved#1"
block|,
literal|"reserved#2"
block|,
literal|"reserved#3"
block|,
literal|"reserved#3"
block|,
literal|"reserved#5"
block|,
literal|"reserved#6"
block|,
literal|"reserved#7"
block|,
literal|"reserved#8"
block|,
literal|"reserved#9"
block|,
literal|"ps_poll"
block|,
literal|"rts"
block|,
literal|"cts"
block|,
literal|"ack"
block|,
literal|"cf_end"
block|,
literal|"cf_end_ack"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_opmode_name
index|[
name|IEEE80211_OPMODE_MAX
index|]
init|=
block|{
literal|"IBSS"
block|,
comment|/* IEEE80211_M_IBSS */
literal|"STA"
block|,
comment|/* IEEE80211_M_STA */
literal|"WDS"
block|,
comment|/* IEEE80211_M_WDS */
literal|"AHDEMO"
block|,
comment|/* IEEE80211_M_AHDEMO */
literal|"HOSTAP"
block|,
comment|/* IEEE80211_M_HOSTAP */
literal|"MONITOR"
comment|/* IEEE80211_M_MONITOR */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_state_name
index|[
name|IEEE80211_S_MAX
index|]
init|=
block|{
literal|"INIT"
block|,
comment|/* IEEE80211_S_INIT */
literal|"SCAN"
block|,
comment|/* IEEE80211_S_SCAN */
literal|"AUTH"
block|,
comment|/* IEEE80211_S_AUTH */
literal|"ASSOC"
block|,
comment|/* IEEE80211_S_ASSOC */
literal|"CAC"
block|,
comment|/* IEEE80211_S_CAC */
literal|"RUN"
block|,
comment|/* IEEE80211_S_RUN */
literal|"CSA"
block|,
comment|/* IEEE80211_S_CSA */
literal|"SLEEP"
block|,
comment|/* IEEE80211_S_SLEEP */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_wme_acnames
index|[]
init|=
block|{
literal|"WME_AC_BE"
block|,
literal|"WME_AC_BK"
block|,
literal|"WME_AC_VI"
block|,
literal|"WME_AC_VO"
block|,
literal|"WME_UPSD"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|parent_updown
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_new_state_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|null_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ni
operator|->
name|ni_ic
operator|->
name|ic_ifp
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"missing ic_raw_xmit callback, drop frame\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
comment|/* override the 802.3 setting */
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe_addr4
argument_list|)
operator|+
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
operator|+
name|IEEE80211_WEP_EXTIVLEN
expr_stmt|;
comment|/* XXX no way to recalculate on ifdetach */
if|if
condition|(
name|ALIGN
argument_list|(
name|ifp
operator|->
name|if_hdrlen
argument_list|)
operator|>
name|max_linkhdr
condition|)
block|{
comment|/* XXX sanity check... */
name|max_linkhdr
operator|=
name|ALIGN
argument_list|(
name|ifp
operator|->
name|if_hdrlen
argument_list|)
expr_stmt|;
name|max_hdr
operator|=
name|max_linkhdr
operator|+
name|max_protohdr
expr_stmt|;
name|max_datalen
operator|=
name|MHLEN
operator|-
name|max_hdr
expr_stmt|;
block|}
name|ic
operator|->
name|ic_protmode
operator|=
name|IEEE80211_PROT_CTSONLY
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|,
literal|0
argument_list|,
name|parent_updown
argument_list|,
name|ifp
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_switch_hysteresis
operator|=
name|AGGRESSIVE_MODE_SWITCH_HYSTERESIS
expr_stmt|;
comment|/* initialize management frame handlers */
name|ic
operator|->
name|ic_send_mgmt
operator|=
name|ieee80211_send_mgmt
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|null_raw_xmit
expr_stmt|;
name|ieee80211_adhoc_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_sta_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wds_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_hostap_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_monitor_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ieee80211_monitor_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_hostap_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wds_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_adhoc_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_sta_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|null_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_proto_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* override the 802.3 setting */
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_hdrlen
expr_stmt|;
name|vap
operator|->
name|iv_rtsthreshold
operator|=
name|IEEE80211_RTS_DEFAULT
expr_stmt|;
name|vap
operator|->
name|iv_fragthreshold
operator|=
name|IEEE80211_FRAG_DEFAULT
expr_stmt|;
name|vap
operator|->
name|iv_bmiss_max
operator|=
name|IEEE80211_BMISS_MAX
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vap
operator|->
name|iv_mgtsend
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
comment|/* 	 * Install default tx rate handling: no fixed rate, lowest 	 * supported rate for mgmt and multicast frames.  Default 	 * max retry count.  These settings can be changed by the 	 * driver and/or user applications. 	 */
for|for
control|(
name|i
operator|=
name|IEEE80211_MODE_11A
init|;
name|i
operator|<
name|IEEE80211_MODE_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
init|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|i
index|]
decl_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|ucastrate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|IEEE80211_MODE_11NA
operator|||
name|i
operator|==
name|IEEE80211_MODE_11NG
condition|)
block|{
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mgmtrate
operator|=
literal|0
operator||
name|IEEE80211_RATE_MCS
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mcastrate
operator|=
literal|0
operator||
name|IEEE80211_RATE_MCS
expr_stmt|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mgmtrate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mcastrate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
block|}
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|maxretry
operator|=
name|IEEE80211_TXMAX_DEFAULT
expr_stmt|;
block|}
name|vap
operator|->
name|iv_roaming
operator|=
name|IEEE80211_ROAMING_AUTO
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|null_update_beacon
expr_stmt|;
name|vap
operator|->
name|iv_deliver_data
operator|=
name|ieee80211_deliver_data
expr_stmt|;
comment|/* attach support for operating mode */
name|ic
operator|->
name|ic_vattach
index|[
name|vap
operator|->
name|iv_opmode
index|]
operator|(
name|vap
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|FREEAPPIE
parameter_list|(
name|ie
parameter_list|)
value|do { \ 	if (ie != NULL) \ 		free(ie, M_80211_NODE_IE); \ } while (0)
comment|/* 	 * Detach operating mode module. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opdetach
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_opdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * This should not be needed as we detach when reseting 	 * the state but be conservative here since the 	 * authenticator may do things like spawn kernel threads. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_auth
operator|->
name|ia_detach
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_auth
operator|->
name|ia_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * Detach any ACL'ator. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_acl
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_acl
operator|->
name|iac_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_beacon
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_probereq
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_proberesp
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_assocreq
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_assocresp
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_wpa
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FREEAPPIE
block|}
end_function

begin_comment
comment|/*  * Simple-minded authenticator module support.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AUTH_MAX
value|(IEEE80211_AUTH_WPA+1)
end_define

begin_comment
comment|/* XXX well-known names */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|auth_modnames
index|[
name|IEEE80211_AUTH_MAX
index|]
init|=
block|{
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_NONE */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_OPEN */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_SHARED */
literal|"wlan_xauth"
block|,
comment|/* IEEE80211_AUTH_8021X	 */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_AUTO */
literal|"wlan_xauth"
block|,
comment|/* IEEE80211_AUTH_WPA */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|authenticators
index|[
name|IEEE80211_AUTH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_authenticator
name|auth_internal
init|=
block|{
operator|.
name|ia_name
operator|=
literal|"wlan_internal"
block|,
operator|.
name|ia_attach
operator|=
name|NULL
block|,
operator|.
name|ia_detach
operator|=
name|NULL
block|,
operator|.
name|ia_node_join
operator|=
name|NULL
block|,
operator|.
name|ia_node_leave
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Setup internal authenticators once; they are never unregistered.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_auth_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_OPEN
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_SHARED
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_AUTO
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_auth
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_auth_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|ieee80211_authenticator_get
parameter_list|(
name|int
name|auth
parameter_list|)
block|{
if|if
condition|(
name|auth
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|authenticators
index|[
name|auth
index|]
operator|==
name|NULL
condition|)
name|ieee80211_load_module
argument_list|(
name|auth_modnames
index|[
name|auth
index|]
argument_list|)
expr_stmt|;
return|return
name|authenticators
index|[
name|auth
index|]
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_authenticator_register
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|auth
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return;
name|authenticators
index|[
name|type
index|]
operator|=
name|auth
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_authenticator_unregister
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return;
name|authenticators
index|[
name|type
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Very simple-minded ACL module support.  */
end_comment

begin_comment
comment|/* XXX just one for now */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|acl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ieee80211_aclator_register
parameter_list|(
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|iac
parameter_list|)
block|{
name|printf
argument_list|(
literal|"wlan: %s acl policy registered\n"
argument_list|,
name|iac
operator|->
name|iac_name
argument_list|)
expr_stmt|;
name|acl
operator|=
name|iac
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_aclator_unregister
parameter_list|(
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|iac
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|iac
condition|)
name|acl
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"wlan: %s acl policy unregistered\n"
argument_list|,
name|iac
operator|->
name|iac_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|ieee80211_aclator_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
name|ieee80211_load_module
argument_list|(
literal|"wlan_acl"
argument_list|)
expr_stmt|;
return|return
name|acl
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|acl
operator|->
name|iac_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|?
name|acl
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_print_essid
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|essid
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|IEEE80211_NWID_LEN
condition|)
name|len
operator|=
name|IEEE80211_NWID_LEN
expr_stmt|;
comment|/* determine printable or not */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
operator|||
operator|*
name|p
operator|>
literal|0x7e
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_dump_pkt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rate
parameter_list|,
name|int
name|rssi
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wh
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_frame
operator|*
operator|)
name|buf
expr_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
name|printf
argument_list|(
literal|"NODS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
name|printf
argument_list|(
literal|"TODS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|printf
argument_list|(
literal|"FRDS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
name|printf
argument_list|(
literal|"DSDS %s"
argument_list|,
name|ether_sprintf
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|printf
argument_list|(
literal|" data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" type#%d"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|ieee80211_qosframe
modifier|*
name|qwh
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|buf
decl_stmt|;
name|printf
argument_list|(
literal|" QoS [TID %u%s]"
argument_list|,
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_TID
argument_list|,
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_ACKPOLICY
condition|?
literal|" ACM"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
name|int
name|off
decl_stmt|;
name|off
operator|=
name|ieee80211_anyhdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" WEP [IV %.02x %.02x %.02x"
argument_list|,
name|buf
index|[
name|off
operator|+
literal|0
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|1
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|off
operator|+
name|IEEE80211_WEP_IVLEN
index|]
operator|&
name|IEEE80211_WEP_EXTIV
condition|)
name|printf
argument_list|(
literal|" %.02x %.02x %.02x"
argument_list|,
name|buf
index|[
name|off
operator|+
literal|4
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|5
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|6
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" KID %u]"
argument_list|,
name|buf
index|[
name|off
operator|+
name|IEEE80211_WEP_IVLEN
index|]
operator|>>
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rate
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" %dM"
argument_list|,
name|rate
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" +%d"
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|findrix
parameter_list|(
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|r
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_fix_rate
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rateset
modifier|*
name|nrs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
define|#
directive|define
name|RV
parameter_list|(
name|v
parameter_list|)
value|((v)& IEEE80211_RATE_VAL)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rix
decl_stmt|,
name|error
decl_stmt|;
name|int
name|okrate
decl_stmt|,
name|badrate
decl_stmt|,
name|fixedrate
decl_stmt|,
name|ucastrate
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|srs
decl_stmt|;
name|uint8_t
name|r
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|okrate
operator|=
name|badrate
operator|=
literal|0
expr_stmt|;
name|ucastrate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
index|]
operator|.
name|ucastrate
expr_stmt|;
if|if
condition|(
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
comment|/* 		 * Workaround awkwardness with fixed rate.  We are called 		 * to check both the legacy rate set and the HT rate set 		 * but we must apply any legacy fixed rate check only to the 		 * legacy rate set and vice versa.  We cannot tell what type 		 * of rate set we've been given (legacy or HT) but we can 		 * distinguish the fixed rate type (MCS have 0x80 set). 		 * So to deal with this the caller communicates whether to 		 * check MCS or legacy rate using the flags and we use the 		 * type of any fixed rate to avoid applying an MCS to a 		 * legacy rate and vice versa. 		 */
if|if
condition|(
name|ucastrate
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOFRATE
condition|)
name|flags
operator|&=
operator|~
name|IEEE80211_F_DOFRATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ucastrate
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOFMCS
condition|)
name|flags
operator|&=
operator|~
name|IEEE80211_F_DOFMCS
expr_stmt|;
block|}
comment|/* NB: required to make MCS match below work */
name|ucastrate
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
block|}
name|fixedrate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
comment|/* 	 * XXX we are called to process both MCS and legacy rates; 	 * we must use the appropriate basic rate set or chaos will 	 * ensue; for now callers that want MCS must supply 	 * IEEE80211_F_DOBRS; at some point we'll need to split this 	 * function so there are two variants, one for MCS and one 	 * for legacy rates. 	 */
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOBRS
condition|)
name|srs
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_rateset
operator|*
operator|)
name|ieee80211_get_suphtrates
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
else|else
name|srs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOSORT
condition|)
block|{
comment|/* 			 * Sort rates. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|RV
argument_list|(
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
argument_list|)
operator|>
name|RV
argument_list|(
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|r
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
block|}
block|}
block|}
name|r
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|badrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check for fixed rate. 		 */
if|if
condition|(
name|r
operator|==
name|ucastrate
condition|)
name|fixedrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check against supported rates. 		 */
name|rix
operator|=
name|findrix
argument_list|(
name|srs
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DONEGO
condition|)
block|{
if|if
condition|(
name|rix
operator|<
literal|0
condition|)
block|{
comment|/* 				 * A rate in the node's rate set is not 				 * supported.  If this is a basic rate and we 				 * are operating as a STA then this is an error. 				 * Otherwise we just discard/ignore the rate. 				 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_JOIN
operator|)
operator|&&
operator|(
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
condition|)
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_JOIN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Overwrite with the supported rate 				 * value so any basic rate bit is set. 				 */
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|srs
operator|->
name|rs_rates
index|[
name|rix
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_DODEL
operator|)
operator|&&
name|rix
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Delete unacceptable rates. 			 */
name|nrs
operator|->
name|rs_nrates
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rix
operator|>=
literal|0
condition|)
name|okrate
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|okrate
operator|==
literal|0
operator|||
name|error
operator|!=
literal|0
operator|||
operator|(
operator|(
name|flags
operator|&
operator|(
name|IEEE80211_F_DOFRATE
operator||
name|IEEE80211_F_DOFMCS
operator|)
operator|)
operator|&&
name|fixedrate
operator|!=
name|ucastrate
operator|)
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: flags 0x%x okrate %d error %d fixedrate 0x%x "
literal|"ucastrate %x\n"
argument_list|,
name|__func__
argument_list|,
name|fixedrate
argument_list|,
name|ucastrate
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|badrate
operator||
name|IEEE80211_RATE_BASIC
return|;
block|}
else|else
return|return
name|RV
argument_list|(
name|okrate
argument_list|)
return|;
undef|#
directive|undef
name|RV
block|}
end_function

begin_comment
comment|/*  * Reset 11g-related state.  */
end_comment

begin_function
name|void
name|ieee80211_reset_erp
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEPROT
expr_stmt|;
name|ic
operator|->
name|ic_nonerpsta
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_longslotsta
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Short slot time is enabled only when operating in 11g 	 * and not in an IBSS.  We must also honor whether or not 	 * the driver is capable of doing it. 	 */
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|||
operator|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set short preamble and ERP barker-preamble flags. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|||
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHPREAMBLE
operator|)
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the short slot time state and notify the driver.  */
end_comment

begin_function
name|void
name|ieee80211_set_shortslottime
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|onoff
condition|)
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHSLOT
expr_stmt|;
else|else
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHSLOT
expr_stmt|;
comment|/* notify driver */
if|if
condition|(
name|ic
operator|->
name|ic_updateslot
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_updateslot
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the specified rate set supports ERP.  * NB: the rate set is assumed to be sorted.  */
end_comment

begin_function
name|int
name|ieee80211_iserp_rateset
parameter_list|(
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
specifier|static
specifier|const
name|int
name|rates
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|12
block|,
literal|24
block|,
literal|48
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|<
name|N
argument_list|(
name|rates
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|rates
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|rates
index|[
name|i
index|]
operator|==
name|r
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|r
operator|>
name|rates
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
name|next
label|:
empty_stmt|;
block|}
return|return
literal|1
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Mark the basic rates for the rate table based on the  * operating mode.  For real 11g we mark all the 11b rates  * and 6, 12, and 24 OFDM.  For 11b compatibility we mark only  * 11b rates.  There's also a pseudo 11a-mode used to mark only  * the basic OFDM rates.  */
end_comment

begin_function
specifier|static
name|void
name|setbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
name|int
name|add
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|basic
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
block|{
literal|2
block|,
literal|4
block|}
block|}
block|,
comment|/* NB: mixed b/g */
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|12
block|,
literal|24
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|3
block|,
literal|6
block|,
literal|12
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
comment|/* NB: mixed b/g */
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|add
condition|)
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|basic
index|[
name|mode
index|]
operator|.
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|basic
index|[
name|mode
index|]
operator|.
name|rs_rates
index|[
name|j
index|]
operator|==
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
condition|)
block|{
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator||=
name|IEEE80211_RATE_BASIC
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set the basic rates in a rate set.  */
end_comment

begin_function
name|void
name|ieee80211_setbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
name|setbasicrates
argument_list|(
name|rs
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add basic rates to a rate set.  */
end_comment

begin_function
name|void
name|ieee80211_addbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
name|setbasicrates
argument_list|(
name|rs
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * WME protocol support.  *  * The default 11a/b/g/n parameters come from the WiFi Alliance WMM  * System Interopability Test Plan (v1.4, Appendix F) and the 802.11n  * Draft 2.0 Test Plan (Appendix D).  *  * Static/Dynamic Turbo mode settings come from Atheros.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|phyParamType
block|{
name|uint8_t
name|aifsn
decl_stmt|;
name|uint8_t
name|logcwmin
decl_stmt|;
name|uint8_t
name|logcwmax
decl_stmt|;
name|uint16_t
name|txopLimit
decl_stmt|;
name|uint8_t
name|acm
decl_stmt|;
block|}
name|paramType
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_BE
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_BK
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_VI
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_VO
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_BE
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_VI
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_VO
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ieee80211_wme_initparams_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
specifier|const
name|paramType
modifier|*
name|pPhyParam
decl_stmt|,
modifier|*
name|pBssPhyParam
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Select mode; we can be called early in which case we 	 * always use auto mode.  We know we'll be called when 	 * entering the RUN state with bsschan setup properly 	 * so state will eventually get set correctly 	 */
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|WME_AC_BK
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_BK
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|phyParamForAC_BK
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_VI
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_VI
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_VI
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_VO
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_VO
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_VO
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_BE
case|:
default|default:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_BE
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_BE
index|[
name|mode
index|]
expr_stmt|;
break|break;
block|}
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|wmep
operator|->
name|wmep_acm
operator|=
name|pPhyParam
operator|->
name|acm
expr_stmt|;
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|pPhyParam
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|pPhyParam
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|pPhyParam
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|pPhyParam
operator|->
name|txopLimit
expr_stmt|;
block|}
else|else
block|{
name|wmep
operator|->
name|wmep_acm
operator|=
name|pBssPhyParam
operator|->
name|acm
expr_stmt|;
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|pBssPhyParam
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|pBssPhyParam
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|pBssPhyParam
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|pBssPhyParam
operator|->
name|txopLimit
expr_stmt|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s chan [acm %u aifsn %u log2(cwmin) %u "
literal|"log2(cwmax) %u txpoLimit %u]\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|,
name|wmep
operator|->
name|wmep_acm
argument_list|,
name|wmep
operator|->
name|wmep_aifsn
argument_list|,
name|wmep
operator|->
name|wmep_logcwmin
argument_list|,
name|wmep
operator|->
name|wmep_logcwmax
argument_list|,
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|->
name|wmep_acm
operator|=
name|pBssPhyParam
operator|->
name|acm
expr_stmt|;
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|pBssPhyParam
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|pBssPhyParam
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|pBssPhyParam
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|pBssPhyParam
operator|->
name|txopLimit
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s  bss [acm %u aifsn %u log2(cwmin) %u "
literal|"log2(cwmax) %u txpoLimit %u]\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|,
name|wmep
operator|->
name|wmep_acm
argument_list|,
name|wmep
operator|->
name|wmep_aifsn
argument_list|,
name|wmep
operator|->
name|wmep_logcwmin
argument_list|,
name|wmep
operator|->
name|wmep_logcwmax
argument_list|,
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
comment|/* NB: check ic_bss to avoid NULL deref on initial attach */
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Calculate agressive mode switching threshold based 		 * on beacon interval.  This doesn't need locking since 		 * we're only called before entering the RUN state at 		 * which point we start sending beacon frames. 		 */
name|wme
operator|->
name|wme_hipri_switch_thresh
operator|=
operator|(
name|HIGH_PRI_SWITCH_THRESH
operator|*
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
operator|)
operator|/
literal|100
expr_stmt|;
name|ieee80211_wme_updateparams
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_wme_initparams
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_initparams_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for ourself and the BSS.  */
end_comment

begin_function
name|void
name|ieee80211_wme_updateparams_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
specifier|static
specifier|const
name|paramType
name|phyParam
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
comment|/* XXXcheck*/
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
comment|/* XXXcheck*/
block|}
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|chanp
decl_stmt|,
modifier|*
name|bssp
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* set up the channel access parameters for the physical device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|wmep
operator|->
name|wmep_logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|wmep
operator|->
name|wmep_logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|wmep
operator|->
name|wmep_logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|wmep
operator|->
name|wmep_logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
block|}
comment|/* 	 * Select mode; we can be called early in which case we 	 * always use auto mode.  We know we'll be called when 	 * entering the RUN state with bsschan setup properly 	 * so state will eventually get set correctly 	 */
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
comment|/* 	 * This implements agressive mode as found in certain 	 * vendors' AP's.  When there is significant high 	 * priority (VI/VO) traffic in the BSS throttle back BE 	 * traffic by using conservative parameters.  Otherwise 	 * BE uses agressive params to optimize performance of 	 * legacy/non-QoS traffic. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|==
literal|0
condition|)
block|{
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|bssp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|bssp
operator|->
name|wmep_aifsn
operator|=
name|phyParam
index|[
name|mode
index|]
operator|.
name|aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|bssp
operator|->
name|wmep_logcwmin
operator|=
name|phyParam
index|[
name|mode
index|]
operator|.
name|logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|bssp
operator|->
name|wmep_logcwmax
operator|=
name|phyParam
index|[
name|mode
index|]
operator|.
name|logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|bssp
operator|->
name|wmep_txopLimit
operator|=
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_BURST
operator|)
condition|?
name|phyParam
index|[
name|mode
index|]
operator|.
name|txopLimit
else|:
literal|0
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s [acm %u aifsn %u log2(cwmin) %u "
literal|"log2(cwmax) %u txpoLimit %u]\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BE
index|]
argument_list|,
name|chanp
operator|->
name|wmep_acm
argument_list|,
name|chanp
operator|->
name|wmep_aifsn
argument_list|,
name|chanp
operator|->
name|wmep_logcwmin
argument_list|,
name|chanp
operator|->
name|wmep_logcwmax
argument_list|,
name|chanp
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
comment|/* XXX multi-bss */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|ic
operator|->
name|ic_sta_assoc
operator|<
literal|2
operator|&&
operator|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|uint8_t
name|logCwMin
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
literal|4
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
literal|4
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
literal|3
block|, 		}
decl_stmt|;
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|bssp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|bssp
operator|->
name|wmep_logcwmin
operator|=
name|logCwMin
index|[
name|mode
index|]
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s log2(cwmin) %u\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BE
index|]
argument_list|,
name|chanp
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* XXX ibss? */
comment|/* 		 * Arrange for a beacon update and bump the parameter 		 * set number so associated stations load the new values. 		 */
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
operator|=
operator|(
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
operator|+
literal|1
operator|)
operator|&
name|WME_QOSINFO_COUNT
expr_stmt|;
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_WME
argument_list|)
expr_stmt|;
block|}
name|wme
operator|->
name|wme_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: WME params updated, cap_info 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|?
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_info
else|:
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_wme_updateparams
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
condition|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parent_updown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|parent
init|=
name|arg
decl_stmt|;
name|parent
operator|->
name|if_ioctl
argument_list|(
name|parent
argument_list|,
name|SIOCSIFFLAGS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Block until the parent is in a known state.  This is  * used after any operations that dispatch a task (e.g.  * to auto-configure the parent device up/down).  */
end_comment

begin_function
name|void
name|ieee80211_waitfor_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a vap running.  If this is the first vap to be  * set running on the underlying device then we  * automatically bring the device up.  */
end_comment

begin_function
name|void
name|ieee80211_start_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|parent
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"start running, %d vaps running\n"
argument_list|,
name|ic
operator|->
name|ic_nrunning
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Mark us running.  Note that it's ok to do this first; 		 * if we need to bring the parent device up we defer that 		 * to avoid dropping the com lock.  We expect the device 		 * to respond to being marked up by calling back into us 		 * through ieee80211_start_all at which point we'll come 		 * back in here and complete the work. 		 */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* 		 * We are not running; if this we are the first vap 		 * to be brought up auto-up the parent if necessary. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|++
operator|==
literal|0
operator|&&
operator|(
name|parent
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s: up parent %s\n"
argument_list|,
name|__func__
argument_list|,
name|parent
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|parent
operator|->
name|if_flags
operator||=
name|IFF_UP
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If the parent is up and running, then kick the 	 * 802.11 state machine as appropriate. 	 */
if|if
condition|(
operator|(
name|parent
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|&&
name|vap
operator|->
name|iv_roaming
operator|!=
name|IEEE80211_ROAMING_MANUAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX bypasses scan too easily; disable for now */
comment|/* 			 * Try to be intelligent about clocking the state 			 * machine.  If we're currently in RUN state then 			 * we should be able to apply any new state/parameters 			 * simply by re-associating.  Otherwise we need to 			 * re-scan to select an appropriate ap. 			 */
block|if (vap->iv_state>= IEEE80211_S_RUN) 				ieee80211_new_state_locked(vap, 				    IEEE80211_S_ASSOC, 1); 			else
endif|#
directive|endif
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * For monitor+wds mode there's nothing to do but 			 * start running.  Otherwise if this is the first 			 * vap to be brought up, start a scan which may be 			 * preempted if the station is locked to a particular 			 * channel. 			 */
comment|/* XXX needed? */
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start a single vap.  */
end_comment

begin_function
name|void
name|ieee80211_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
comment|/* 	 * This routine is publicly accessible through the vap's 	 * if_init method so guard against calls during detach. 	 * ieee80211_vap_detach null's the backpointer before 	 * tearing down state to signal any callback should be 	 * rejected/ignored. 	 */
if|if
condition|(
name|vap
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|ieee80211_start_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Start all runnable vap's on a device.  */
end_comment

begin_function
name|void
name|ieee80211_start_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
comment|/* NB: avoid recursion */
name|ieee80211_start_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop a vap.  We force it down using the state machine  * then mark it's ifnet not running.  If this is the last  * vap running on the underlying device then we close it  * too to insure it will be properly initialized when the  * next vap is brought up.  */
end_comment

begin_function
name|void
name|ieee80211_stop_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|parent
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"stop running, %d vaps running\n"
argument_list|,
name|ic
operator|->
name|ic_nrunning
argument_list|)
expr_stmt|;
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* mark us stopped */
if|if
condition|(
operator|--
name|ic
operator|->
name|ic_nrunning
operator|==
literal|0
operator|&&
operator|(
name|parent
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"down parent %s\n"
argument_list|,
name|parent
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|parent
operator|->
name|if_flags
operator|&=
operator|~
name|IFF_UP
expr_stmt|;
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_stop
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop all vap's running on a device.  */
end_comment

begin_function
name|void
name|ieee80211_stop_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
comment|/* NB: avoid recursion */
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_waitfor_parent
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop all vap's running on a device and arrange  * for those that were running to be resumed.  */
end_comment

begin_function
name|void
name|ieee80211_suspend_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* NB: avoid recursion */
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_RESUME
expr_stmt|;
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_waitfor_parent
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start all vap's marked for resume.  */
end_comment

begin_function
name|void
name|ieee80211_resume_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
operator|!
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_RESUME
operator|)
condition|)
block|{
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_RESUME
expr_stmt|;
name|ieee80211_start_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Switch between turbo and non-turbo operating modes.  * Use the specified channel flags to locate the new  * channel, update 802.11 state, and then call back into  * the driver to effect the change.  */
end_comment

begin_function
name|void
name|ieee80211_dturbo_switch
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
comment|/* XXX should not happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no channel with freq %u flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
return|return;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: %s -> %s (freq %u flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_phymode_name
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
index|]
argument_list|,
name|ieee80211_phymode_name
index|[
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
index|]
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bsschan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_prevchan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* NB: do not need to reset ERP state 'cuz we're in sta mode */
block|}
end_function

begin_function
name|void
name|ieee80211_beacon_miss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
return|return;
comment|/* XXX locking */
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
comment|/* 		 * We only pass events through for sta vap's in RUN state; 		 * may be too restrictive but for now this saves all the 		 * handlers duplicating these checks. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_bmiss
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Software beacon miss handling.  Check if any beacons  * were received in the last period.  If not post a  * beacon miss; otherwise reset the counter.  */
end_comment

begin_function
name|void
name|ieee80211_swbmiss
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
comment|/* XXX sleep state? */
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"wrong state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
block|{
comment|/* 		 * If scanning just ignore and reset state.  If we get a 		 * bmiss after coming out of scan because we haven't had 		 * time to receive a beacon then we should probe the AP 		 * before posting a real bmiss (unless iv_bmiss_max has 		 * been artifiically lowered).  A cleaner solution might 		 * be to disable the timer on scan start/end but to handle 		 * case of multiple sta vap's we'd need to disable the 		 * timers of all affected vap's. 		 */
name|vap
operator|->
name|iv_swbmiss_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_swbmiss_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_bmiss
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_bmiss_count
operator|==
literal|0
condition|)
comment|/* don't re-arm timer */
return|return;
block|}
else|else
name|vap
operator|->
name|iv_swbmiss_count
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|,
name|vap
operator|->
name|iv_swbmiss_period
argument_list|,
name|ieee80211_swbmiss
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start an 802.11h channel switch.  We record the parameters,  * mark the operation pending, notify each vap through the  * beacon update mechanism so it can update the beacon frame  * contents, and then switch vap's to CSA state to block outbound  * traffic.  Devices that handle CSA directly can use the state  * switch to do the right thing so long as they call  * ieee80211_csa_completeswitch when it's time to complete the  * channel change.  Devices that depend on the net80211 layer can  * use ieee80211_beacon_update to handle the countdown and the  * channel switch.  */
end_comment

begin_function
name|void
name|ieee80211_csa_startswitch
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_csa_newchan
operator|=
name|c
expr_stmt|;
name|ic
operator|->
name|ic_csa_count
operator|=
name|count
expr_stmt|;
comment|/* XXX record mode? */
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_CSAPENDING
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_CSA
argument_list|)
expr_stmt|;
comment|/* switch to CSA state to block outbound traffic */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_CSA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ieee80211_notify_csa
argument_list|(
name|ic
argument_list|,
name|c
argument_list|,
name|mode
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete an 802.11h channel switch started by ieee80211_csa_startswitch.  * We clear state and move all vap's in CSA state to RUN state  * so they can again transmit.  */
end_comment

begin_function
name|void
name|ieee80211_csa_completeswitch
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_CSAPENDING
argument_list|,
operator|(
literal|"csa not pending"
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_setcurchan
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_csa_newchan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_csa_newchan
operator|=
name|NULL
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_CSAPENDING
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CSA
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete a DFS CAC started by ieee80211_dfs_cac_start.  * We clear state and move all vap's in CAC state to RUN state.  */
end_comment

begin_function
name|void
name|ieee80211_cac_completeswitch
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap0
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Complete CAC state change for lead vap first; then 	 * clock all the other vap's waiting. 	 */
name|KASSERT
argument_list|(
name|vap0
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
argument_list|,
operator|(
literal|"wrong state %d"
operator|,
name|vap0
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_new_state_locked
argument_list|(
name|vap0
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Force all vap's other than the specified vap to the INIT state  * and mark them as waiting for a scan to complete.  These vaps  * will be brought up when the scan completes and the scanning vap  * reaches RUN state by wakeupwaiting.  * XXX if we do this in threads we can use sleep/wakeup.  */
end_comment

begin_function
specifier|static
name|void
name|markwaiting
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap0
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|==
name|vap0
condition|)
continue|continue;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_INIT
condition|)
block|{
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Wakeup all vap's waiting for a scan to complete.  This is the  * companion to markwaiting (above) and is used to coordinate  * multiple vaps scanning.  */
end_comment

begin_function
specifier|static
name|void
name|wakeupwaiting
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap0
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|==
name|vap0
condition|)
continue|continue;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SCANWAIT
condition|)
block|{
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
comment|/* NB: sta's cannot go INIT->RUN */
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|?
name|IEEE80211_S_SCAN
else|:
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Handle post state change work common to all operating modes.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_newstate_cb
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s arg %d\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * OACTIVE may be set on the vap if the upper layer 		 * tried to transmit (e.g. IPv6 NDP) before we reach 		 * RUN state.  Clear it and restart xmit. 		 * 		 * Note this can also happen as a result of SLEEP->RUN 		 * (i.e. coming out of power save mode). 		 */
name|vap
operator|->
name|iv_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
name|if_start
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|)
expr_stmt|;
comment|/* bring up any vaps waiting on us */
name|wakeupwaiting
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 		 * Flush the scan cache if we did the last scan (XXX?) 		 * and flush any frames on send queues from this vap. 		 * Note the mgt q is used only for legacy drivers and 		 * will go away shortly. 		 */
name|ieee80211_scan_flush
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* XXX NB: cast for altq */
name|ieee80211_flush_ifq
argument_list|(
operator|(
expr|struct
name|ifqueue
operator|*
operator|)
operator|&
name|ic
operator|->
name|ic_ifp
operator|->
name|if_snd
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
name|vap
operator|->
name|iv_newstate_cb
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public interface for initiating a state machine change.  * This routine single-threads the request and coordinates  * the scheduling of multiple vaps for the purpose of selecting  * an operating channel.  Specifically the following scenarios  * are handled:  * o only one vap can be selecting a channel so on transition to  *   SCAN state if another vap is already scanning then  *   mark the caller for later processing and return without  *   doing anything (XXX? expectations by caller of synchronous operation)  * o only one vap can be doing CAC of a channel so on transition to  *   CAC state if another vap is already scanning for radar then  *   mark the caller for later processing and return without  *   doing anything (XXX? expectations by caller of synchronous operation)  * o if another vap is already running when a request is made  *   to SCAN then an operating channel has been chosen; bypass  *   the scan and just join the channel  *  * Note that the state change call is done through the iv_newstate  * method pointer so any driver routine gets invoked.  The driver  * will normally call back into operating mode-specific  * ieee80211_newstate routines (below) unless it needs to completely  * bypass the state machine (e.g. because the firmware has it's  * own idea how things should work).  Bypassing the net80211 layer  * is usually a mistake and indicates lack of proper integration  * with the net80211 layer.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_new_state_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vp
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
decl_stmt|;
name|int
name|nrunning
decl_stmt|,
name|nscanning
decl_stmt|,
name|rc
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|nrunning
operator|=
name|nscanning
operator|=
literal|0
expr_stmt|;
comment|/* XXX can track this state instead of calculating */
name|TAILQ_FOREACH
argument_list|(
argument|vp
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vp
operator|!=
name|vap
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
name|nrunning
operator|++
expr_stmt|;
comment|/* XXX doesn't handle bg scan */
comment|/* NB: CAC+AUTH+ASSOC treated like SCAN */
elseif|else
if|if
condition|(
name|vp
operator|->
name|iv_state
operator|>
name|IEEE80211_S_INIT
condition|)
name|nscanning
operator|++
expr_stmt|;
block|}
block|}
name|ostate
operator|=
name|vap
operator|->
name|iv_state
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s (nrunning %d nscanning %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|nrunning
argument_list|,
name|nscanning
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_SCAN
case|:
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 			 * INIT -> SCAN happens on initial bringup. 			 */
name|KASSERT
argument_list|(
operator|!
operator|(
name|nscanning
operator|&&
name|nrunning
operator|)
argument_list|,
operator|(
literal|"%d scanning and %d running"
operator|,
name|nscanning
operator|,
name|nrunning
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nscanning
condition|)
block|{
comment|/* 				 * Someone is scanning, defer our state 				 * change until the work has completed. 				 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: defer %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|nrunning
condition|)
block|{
comment|/* 				 * Someone is operating; just join the channel 				 * they have chosen. 				 */
comment|/* XXX kill arg? */
comment|/* XXX check each opmode, adhoc? */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|nstate
operator|=
name|IEEE80211_S_SCAN
expr_stmt|;
else|else
name|nstate
operator|=
name|IEEE80211_S_RUN
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|nstate
operator|!=
name|IEEE80211_S_SCAN
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: override, now %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* 			 * SCAN was forced; e.g. on beacon miss.  Force 			 * other running vap's to INIT state and mark 			 * them as waiting for the scan to complete.  This 			 * insures they don't interfere with our scanning. 			 * 			 * XXX not always right, assumes ap follows sta 			 */
name|markwaiting
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_WDSLEGACY
operator|)
operator|&&
name|nscanning
condition|)
block|{
comment|/* 			 * Legacy WDS with someone else scanning; don't 			 * go online until that completes as we should 			 * follow the other vap to the channel they choose. 			 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: defer %s -> %s (legacy WDS)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DFS
operator|)
operator|&&
operator|!
name|IEEE80211_IS_CHAN_CACDONE
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
comment|/* 			 * This is a DFS channel, transition to CAC state 			 * instead of RUN.  This allows us to initiate 			 * Channel Availability Check (CAC) as specified 			 * by 11h/DFS. 			 */
name|nstate
operator|=
name|IEEE80211_S_CAC
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: override %s -> %s (DFS)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_INIT
case|:
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* XXX don't believe this */
comment|/* INIT -> INIT. nothing to do */
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
block|}
comment|/* fall thru... */
default|default:
break|break;
block|}
comment|/* XXX on transition RUN->CAC do we need to set nstate = iv_state? */
if|if
condition|(
name|ostate
operator|!=
name|nstate
condition|)
block|{
comment|/* 		 * Arrange for work to happen after state change completes. 		 * If this happens asynchronously the caller must arrange 		 * for the com lock to be held. 		 */
name|vap
operator|->
name|iv_newstate_cb
operator|=
name|ieee80211_newstate_cb
expr_stmt|;
block|}
name|rc
operator|=
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|==
literal|0
operator|&&
name|vap
operator|->
name|iv_newstate_cb
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_newstate_cb
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|done
label|:
return|return
name|rc
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_new_state
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

end_unit

