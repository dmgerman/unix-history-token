begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2008 Sam Leffler, Errno Consulting  * Copyright (c) 2012 IEEE  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_comment
comment|/* XXX for ether_sprintf */
end_comment

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_adhoc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_sta.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_hostap.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_wds.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_mesh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_monitor.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_comment
comment|/* XXX tunables */
end_comment

begin_define
define|#
directive|define
name|AGGRESSIVE_MODE_SWITCH_HYSTERESIS
value|3
end_define

begin_comment
comment|/* pkts / 100ms */
end_comment

begin_define
define|#
directive|define
name|HIGH_PRI_SWITCH_THRESH
value|10
end_define

begin_comment
comment|/* pkts / 100ms */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mgt_subtype_name
index|[]
init|=
block|{
literal|"assoc_req"
block|,
literal|"assoc_resp"
block|,
literal|"reassoc_req"
block|,
literal|"reassoc_resp"
block|,
literal|"probe_req"
block|,
literal|"probe_resp"
block|,
literal|"timing_adv"
block|,
literal|"reserved#7"
block|,
literal|"beacon"
block|,
literal|"atim"
block|,
literal|"disassoc"
block|,
literal|"auth"
block|,
literal|"deauth"
block|,
literal|"action"
block|,
literal|"action_noack"
block|,
literal|"reserved#15"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ctl_subtype_name
index|[]
init|=
block|{
literal|"reserved#0"
block|,
literal|"reserved#1"
block|,
literal|"reserved#2"
block|,
literal|"reserved#3"
block|,
literal|"reserved#4"
block|,
literal|"reserved#5"
block|,
literal|"reserved#6"
block|,
literal|"control_wrap"
block|,
literal|"bar"
block|,
literal|"ba"
block|,
literal|"ps_poll"
block|,
literal|"rts"
block|,
literal|"cts"
block|,
literal|"ack"
block|,
literal|"cf_end"
block|,
literal|"cf_end_ack"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_opmode_name
index|[
name|IEEE80211_OPMODE_MAX
index|]
init|=
block|{
literal|"IBSS"
block|,
comment|/* IEEE80211_M_IBSS */
literal|"STA"
block|,
comment|/* IEEE80211_M_STA */
literal|"WDS"
block|,
comment|/* IEEE80211_M_WDS */
literal|"AHDEMO"
block|,
comment|/* IEEE80211_M_AHDEMO */
literal|"HOSTAP"
block|,
comment|/* IEEE80211_M_HOSTAP */
literal|"MONITOR"
block|,
comment|/* IEEE80211_M_MONITOR */
literal|"MBSS"
comment|/* IEEE80211_M_MBSS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_state_name
index|[
name|IEEE80211_S_MAX
index|]
init|=
block|{
literal|"INIT"
block|,
comment|/* IEEE80211_S_INIT */
literal|"SCAN"
block|,
comment|/* IEEE80211_S_SCAN */
literal|"AUTH"
block|,
comment|/* IEEE80211_S_AUTH */
literal|"ASSOC"
block|,
comment|/* IEEE80211_S_ASSOC */
literal|"CAC"
block|,
comment|/* IEEE80211_S_CAC */
literal|"RUN"
block|,
comment|/* IEEE80211_S_RUN */
literal|"CSA"
block|,
comment|/* IEEE80211_S_CSA */
literal|"SLEEP"
block|,
comment|/* IEEE80211_S_SLEEP */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_wme_acnames
index|[]
init|=
block|{
literal|"WME_AC_BE"
block|,
literal|"WME_AC_BK"
block|,
literal|"WME_AC_VI"
block|,
literal|"WME_AC_VO"
block|,
literal|"WME_UPSD"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reason code descriptions were (mostly) obtained from  * IEEE Std 802.11-2012, pp. 442-445 Table 8-36.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|ieee80211_reason_to_string
parameter_list|(
name|uint16_t
name|reason
parameter_list|)
block|{
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|IEEE80211_REASON_UNSPECIFIED
case|:
return|return
operator|(
literal|"unspecified"
operator|)
return|;
case|case
name|IEEE80211_REASON_AUTH_EXPIRE
case|:
return|return
operator|(
literal|"previous authentication is expired"
operator|)
return|;
case|case
name|IEEE80211_REASON_AUTH_LEAVE
case|:
return|return
operator|(
literal|"sending STA is leaving/has left IBSS or ESS"
operator|)
return|;
case|case
name|IEEE80211_REASON_ASSOC_EXPIRE
case|:
return|return
operator|(
literal|"disassociated due to inactivity"
operator|)
return|;
case|case
name|IEEE80211_REASON_ASSOC_TOOMANY
case|:
return|return
operator|(
literal|"too many associated STAs"
operator|)
return|;
case|case
name|IEEE80211_REASON_NOT_AUTHED
case|:
return|return
operator|(
literal|"class 2 frame received from nonauthenticated STA"
operator|)
return|;
case|case
name|IEEE80211_REASON_NOT_ASSOCED
case|:
return|return
operator|(
literal|"class 3 frame received from nonassociated STA"
operator|)
return|;
case|case
name|IEEE80211_REASON_ASSOC_LEAVE
case|:
return|return
operator|(
literal|"sending STA is leaving/has left BSS"
operator|)
return|;
case|case
name|IEEE80211_REASON_ASSOC_NOT_AUTHED
case|:
return|return
operator|(
literal|"STA requesting (re)association is not authenticated"
operator|)
return|;
case|case
name|IEEE80211_REASON_DISASSOC_PWRCAP_BAD
case|:
return|return
operator|(
literal|"information in the Power Capability element is "
literal|"unacceptable"
operator|)
return|;
case|case
name|IEEE80211_REASON_DISASSOC_SUPCHAN_BAD
case|:
return|return
operator|(
literal|"information in the Supported Channels element is "
literal|"unacceptable"
operator|)
return|;
case|case
name|IEEE80211_REASON_IE_INVALID
case|:
return|return
operator|(
literal|"invalid element"
operator|)
return|;
case|case
name|IEEE80211_REASON_MIC_FAILURE
case|:
return|return
operator|(
literal|"MIC failure"
operator|)
return|;
case|case
name|IEEE80211_REASON_4WAY_HANDSHAKE_TIMEOUT
case|:
return|return
operator|(
literal|"4-Way handshake timeout"
operator|)
return|;
case|case
name|IEEE80211_REASON_GROUP_KEY_UPDATE_TIMEOUT
case|:
return|return
operator|(
literal|"group key update timeout"
operator|)
return|;
case|case
name|IEEE80211_REASON_IE_IN_4WAY_DIFFERS
case|:
return|return
operator|(
literal|"element in 4-Way handshake different from "
literal|"(re)association request/probe response/beacon frame"
operator|)
return|;
case|case
name|IEEE80211_REASON_GROUP_CIPHER_INVALID
case|:
return|return
operator|(
literal|"invalid group cipher"
operator|)
return|;
case|case
name|IEEE80211_REASON_PAIRWISE_CIPHER_INVALID
case|:
return|return
operator|(
literal|"invalid pairwise cipher"
operator|)
return|;
case|case
name|IEEE80211_REASON_AKMP_INVALID
case|:
return|return
operator|(
literal|"invalid AKMP"
operator|)
return|;
case|case
name|IEEE80211_REASON_UNSUPP_RSN_IE_VERSION
case|:
return|return
operator|(
literal|"unsupported version in RSN IE"
operator|)
return|;
case|case
name|IEEE80211_REASON_INVALID_RSN_IE_CAP
case|:
return|return
operator|(
literal|"invalid capabilities in RSN IE"
operator|)
return|;
case|case
name|IEEE80211_REASON_802_1X_AUTH_FAILED
case|:
return|return
operator|(
literal|"IEEE 802.1X authentication failed"
operator|)
return|;
case|case
name|IEEE80211_REASON_CIPHER_SUITE_REJECTED
case|:
return|return
operator|(
literal|"cipher suite rejected because of the security "
literal|"policy"
operator|)
return|;
case|case
name|IEEE80211_REASON_UNSPECIFIED_QOS
case|:
return|return
operator|(
literal|"unspecified (QoS-related)"
operator|)
return|;
case|case
name|IEEE80211_REASON_INSUFFICIENT_BW
case|:
return|return
operator|(
literal|"QoS AP lacks sufficient bandwidth for this QoS STA"
operator|)
return|;
case|case
name|IEEE80211_REASON_TOOMANY_FRAMES
case|:
return|return
operator|(
literal|"too many frames need to be acknowledged"
operator|)
return|;
case|case
name|IEEE80211_REASON_OUTSIDE_TXOP
case|:
return|return
operator|(
literal|"STA is transmitting outside the limits of its TXOPs"
operator|)
return|;
case|case
name|IEEE80211_REASON_LEAVING_QBSS
case|:
return|return
operator|(
literal|"requested from peer STA (the STA is "
literal|"resetting/leaving the BSS)"
operator|)
return|;
case|case
name|IEEE80211_REASON_BAD_MECHANISM
case|:
return|return
operator|(
literal|"requested from peer STA (it does not want to use "
literal|"the mechanism)"
operator|)
return|;
case|case
name|IEEE80211_REASON_SETUP_NEEDED
case|:
return|return
operator|(
literal|"requested from peer STA (setup is required for the "
literal|"used mechanism)"
operator|)
return|;
case|case
name|IEEE80211_REASON_TIMEOUT
case|:
return|return
operator|(
literal|"requested from peer STA (timeout)"
operator|)
return|;
case|case
name|IEEE80211_REASON_PEER_LINK_CANCELED
case|:
return|return
operator|(
literal|"SME cancels the mesh peering instance (not related "
literal|"to the maximum number of peer mesh STAs)"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_MAX_PEERS
case|:
return|return
operator|(
literal|"maximum number of peer mesh STAs was reached"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_CPVIOLATION
case|:
return|return
operator|(
literal|"the received information violates the Mesh "
literal|"Configuration policy configured in the mesh STA "
literal|"profile"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_CLOSE_RCVD
case|:
return|return
operator|(
literal|"the mesh STA has received a Mesh Peering Close "
literal|"message requesting to close the mesh peering"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_MAX_RETRIES
case|:
return|return
operator|(
literal|"the mesh STA has resent dot11MeshMaxRetries Mesh "
literal|"Peering Open messages, without receiving a Mesh "
literal|"Peering Confirm message"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_CONFIRM_TIMEOUT
case|:
return|return
operator|(
literal|"the confirmTimer for the mesh peering instance times "
literal|"out"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_INVALID_GTK
case|:
return|return
operator|(
literal|"the mesh STA fails to unwrap the GTK or the values "
literal|"in the wrapped contents do not match"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_INCONS_PARAMS
case|:
return|return
operator|(
literal|"the mesh STA receives inconsistent information about "
literal|"the mesh parameters between Mesh Peering Management "
literal|"frames"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_INVALID_SECURITY
case|:
return|return
operator|(
literal|"the mesh STA fails the authenticated mesh peering "
literal|"exchange because due to failure in selecting "
literal|"pairwise/group ciphersuite"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_PERR_NO_PROXY
case|:
return|return
operator|(
literal|"the mesh STA does not have proxy information for "
literal|"this external destination"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_PERR_NO_FI
case|:
return|return
operator|(
literal|"the mesh STA does not have forwarding information "
literal|"for this destination"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_PERR_DEST_UNREACH
case|:
return|return
operator|(
literal|"the mesh STA determines that the link to the next "
literal|"hop of an active path in its forwarding information "
literal|"is no longer usable"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_MAC_ALRDY_EXISTS_MBSS
case|:
return|return
operator|(
literal|"the MAC address of the STA already exists in the "
literal|"mesh BSS"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_CHAN_SWITCH_REG
case|:
return|return
operator|(
literal|"the mesh STA performs channel switch to meet "
literal|"regulatory requirements"
operator|)
return|;
case|case
name|IEEE80211_REASON_MESH_CHAN_SWITCH_UNSPEC
case|:
return|return
operator|(
literal|"the mesh STA performs channel switch with "
literal|"unspecified reason"
operator|)
return|;
default|default:
return|return
operator|(
literal|"reserved/unknown"
operator|)
return|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|beacon_miss
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|beacon_swmiss
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parent_updown
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_mcast
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_promisc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_channel
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_chw
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|vap_update_wme
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|restart_vaps
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_newstate_cb
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|null_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|ic_printf
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
literal|"missing ic_raw_xmit callback, drop frame\n"
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|ENETDOWN
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|uint8_t
name|hdrlen
decl_stmt|;
comment|/* override the 802.3 setting */
name|hdrlen
operator|=
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe_addr4
argument_list|)
operator|+
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
operator|+
name|IEEE80211_WEP_EXTIVLEN
expr_stmt|;
comment|/* XXX no way to recalculate on ifdetach */
if|if
condition|(
name|ALIGN
argument_list|(
name|hdrlen
argument_list|)
operator|>
name|max_linkhdr
condition|)
block|{
comment|/* XXX sanity check... */
name|max_linkhdr
operator|=
name|ALIGN
argument_list|(
name|hdrlen
argument_list|)
expr_stmt|;
name|max_hdr
operator|=
name|max_linkhdr
operator|+
name|max_protohdr
expr_stmt|;
name|max_datalen
operator|=
name|MHLEN
operator|-
name|max_hdr
expr_stmt|;
block|}
name|ic
operator|->
name|ic_protmode
operator|=
name|IEEE80211_PROT_CTSONLY
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|,
literal|0
argument_list|,
name|parent_updown
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_mcast_task
argument_list|,
literal|0
argument_list|,
name|update_mcast
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_promisc_task
argument_list|,
literal|0
argument_list|,
name|update_promisc
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_chan_task
argument_list|,
literal|0
argument_list|,
name|update_channel
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_bmiss_task
argument_list|,
literal|0
argument_list|,
name|beacon_miss
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_chw_task
argument_list|,
literal|0
argument_list|,
name|update_chw
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_restart_task
argument_list|,
literal|0
argument_list|,
name|restart_vaps
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_switch_hysteresis
operator|=
name|AGGRESSIVE_MODE_SWITCH_HYSTERESIS
expr_stmt|;
comment|/* initialize management frame handlers */
name|ic
operator|->
name|ic_send_mgmt
operator|=
name|ieee80211_send_mgmt
expr_stmt|;
name|ic
operator|->
name|ic_raw_xmit
operator|=
name|null_raw_xmit
expr_stmt|;
name|ieee80211_adhoc_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_sta_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wds_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_hostap_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
name|ieee80211_mesh_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_monitor_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ieee80211_monitor_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
name|ieee80211_mesh_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_hostap_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wds_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_adhoc_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_sta_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|null_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|item
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_proto_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* override the 802.3 setting */
name|ifp
operator|->
name|if_hdrlen
operator|=
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe_addr4
argument_list|)
operator|+
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
operator|+
name|IEEE80211_WEP_EXTIVLEN
expr_stmt|;
name|vap
operator|->
name|iv_rtsthreshold
operator|=
name|IEEE80211_RTS_DEFAULT
expr_stmt|;
name|vap
operator|->
name|iv_fragthreshold
operator|=
name|IEEE80211_FRAG_DEFAULT
expr_stmt|;
name|vap
operator|->
name|iv_bmiss_max
operator|=
name|IEEE80211_BMISS_MAX
expr_stmt|;
name|callout_init_mtx
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|,
name|IEEE80211_LOCK_OBJ
argument_list|(
name|ic
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|vap
operator|->
name|iv_mgtsend
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|vap
operator|->
name|iv_nstate_task
argument_list|,
literal|0
argument_list|,
name|ieee80211_newstate_cb
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss_task
argument_list|,
literal|0
argument_list|,
name|beacon_swmiss
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|TASK_INIT
argument_list|(
operator|&
name|vap
operator|->
name|iv_wme_task
argument_list|,
literal|0
argument_list|,
name|vap_update_wme
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * Install default tx rate handling: no fixed rate, lowest 	 * supported rate for mgmt and multicast frames.  Default 	 * max retry count.  These settings can be changed by the 	 * driver and/or user applications. 	 */
for|for
control|(
name|i
operator|=
name|IEEE80211_MODE_11A
init|;
name|i
operator|<
name|IEEE80211_MODE_MAX
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
init|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|i
index|]
decl_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|ucastrate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
comment|/* 		 * Setting the management rate to MCS 0 assumes that the 		 * BSS Basic rate set is empty and the BSS Basic MCS set 		 * is not. 		 * 		 * Since we're not checking this, default to the lowest 		 * defined rate for this mode. 		 * 		 * At least one 11n AP (DLINK DIR-825) is reported to drop 		 * some MCS management traffic (eg BA response frames.) 		 * 		 * See also: 9.6.0 of the 802.11n-2009 specification. 		 */
ifdef|#
directive|ifdef
name|NOTYET
if|if
condition|(
name|i
operator|==
name|IEEE80211_MODE_11NA
operator|||
name|i
operator|==
name|IEEE80211_MODE_11NG
condition|)
block|{
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mgmtrate
operator|=
literal|0
operator||
name|IEEE80211_RATE_MCS
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mcastrate
operator|=
literal|0
operator||
name|IEEE80211_RATE_MCS
expr_stmt|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mgmtrate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mcastrate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
block|}
endif|#
directive|endif
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mgmtrate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|mcastrate
operator|=
name|rs
operator|->
name|rs_rates
index|[
literal|0
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|i
index|]
operator|.
name|maxretry
operator|=
name|IEEE80211_TXMAX_DEFAULT
expr_stmt|;
block|}
name|vap
operator|->
name|iv_roaming
operator|=
name|IEEE80211_ROAMING_AUTO
expr_stmt|;
name|vap
operator|->
name|iv_update_beacon
operator|=
name|null_update_beacon
expr_stmt|;
name|vap
operator|->
name|iv_deliver_data
operator|=
name|ieee80211_deliver_data
expr_stmt|;
comment|/* attach support for operating mode */
name|ic
operator|->
name|ic_vattach
index|[
name|vap
operator|->
name|iv_opmode
index|]
operator|(
name|vap
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|FREEAPPIE
parameter_list|(
name|ie
parameter_list|)
value|do { \ 	if (ie != NULL) \ 		IEEE80211_FREE(ie, M_80211_NODE_IE); \ } while (0)
comment|/* 	 * Detach operating mode module. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opdetach
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_opdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * This should not be needed as we detach when reseting 	 * the state but be conservative here since the 	 * authenticator may do things like spawn kernel threads. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_auth
operator|->
name|ia_detach
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_auth
operator|->
name|ia_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * Detach any ACL'ator. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_acl
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_acl
operator|->
name|iac_detach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_beacon
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_probereq
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_proberesp
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_assocreq
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_assocresp
argument_list|)
expr_stmt|;
name|FREEAPPIE
argument_list|(
name|vap
operator|->
name|iv_appie_wpa
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|FREEAPPIE
block|}
end_function

begin_comment
comment|/*  * Simple-minded authenticator module support.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AUTH_MAX
value|(IEEE80211_AUTH_WPA+1)
end_define

begin_comment
comment|/* XXX well-known names */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|auth_modnames
index|[
name|IEEE80211_AUTH_MAX
index|]
init|=
block|{
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_NONE */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_OPEN */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_SHARED */
literal|"wlan_xauth"
block|,
comment|/* IEEE80211_AUTH_8021X	 */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_AUTO */
literal|"wlan_xauth"
block|,
comment|/* IEEE80211_AUTH_WPA */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|authenticators
index|[
name|IEEE80211_AUTH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_authenticator
name|auth_internal
init|=
block|{
operator|.
name|ia_name
operator|=
literal|"wlan_internal"
block|,
operator|.
name|ia_attach
operator|=
name|NULL
block|,
operator|.
name|ia_detach
operator|=
name|NULL
block|,
operator|.
name|ia_node_join
operator|=
name|NULL
block|,
operator|.
name|ia_node_leave
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Setup internal authenticators once; they are never unregistered.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_auth_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_OPEN
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_SHARED
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_AUTO
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_auth
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_auth_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|ieee80211_authenticator_get
parameter_list|(
name|int
name|auth
parameter_list|)
block|{
if|if
condition|(
name|auth
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|authenticators
index|[
name|auth
index|]
operator|==
name|NULL
condition|)
name|ieee80211_load_module
argument_list|(
name|auth_modnames
index|[
name|auth
index|]
argument_list|)
expr_stmt|;
return|return
name|authenticators
index|[
name|auth
index|]
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_authenticator_register
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|auth
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return;
name|authenticators
index|[
name|type
index|]
operator|=
name|auth
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_authenticator_unregister
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return;
name|authenticators
index|[
name|type
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Very simple-minded ACL module support.  */
end_comment

begin_comment
comment|/* XXX just one for now */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|acl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ieee80211_aclator_register
parameter_list|(
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|iac
parameter_list|)
block|{
name|printf
argument_list|(
literal|"wlan: %s acl policy registered\n"
argument_list|,
name|iac
operator|->
name|iac_name
argument_list|)
expr_stmt|;
name|acl
operator|=
name|iac
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_aclator_unregister
parameter_list|(
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|iac
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|iac
condition|)
name|acl
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"wlan: %s acl policy unregistered\n"
argument_list|,
name|iac
operator|->
name|iac_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|ieee80211_aclator_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
name|ieee80211_load_module
argument_list|(
literal|"wlan_acl"
argument_list|)
expr_stmt|;
return|return
name|acl
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|acl
operator|->
name|iac_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|?
name|acl
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_print_essid
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|essid
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|IEEE80211_NWID_LEN
condition|)
name|len
operator|=
name|IEEE80211_NWID_LEN
expr_stmt|;
comment|/* determine printable or not */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
operator|||
operator|*
name|p
operator|>
literal|0x7e
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_dump_pkt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rate
parameter_list|,
name|int
name|rssi
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wh
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_frame
operator|*
operator|)
name|buf
expr_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
name|printf
argument_list|(
literal|"NODS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
name|printf
argument_list|(
literal|"TODS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|printf
argument_list|(
literal|"FRDS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
name|printf
argument_list|(
literal|"DSDS %s"
argument_list|,
name|ether_sprintf
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|printf
argument_list|(
literal|" data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ieee80211_mgt_subtype_name
argument_list|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" type#%d"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IEEE80211_QOS_HAS_SEQ
argument_list|(
name|wh
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|ieee80211_qosframe
modifier|*
name|qwh
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|buf
decl_stmt|;
name|printf
argument_list|(
literal|" QoS [TID %u%s]"
argument_list|,
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_TID
argument_list|,
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_ACKPOLICY
condition|?
literal|" ACM"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PROTECTED
condition|)
block|{
name|int
name|off
decl_stmt|;
name|off
operator|=
name|ieee80211_anyhdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" WEP [IV %.02x %.02x %.02x"
argument_list|,
name|buf
index|[
name|off
operator|+
literal|0
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|1
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|off
operator|+
name|IEEE80211_WEP_IVLEN
index|]
operator|&
name|IEEE80211_WEP_EXTIV
condition|)
name|printf
argument_list|(
literal|" %.02x %.02x %.02x"
argument_list|,
name|buf
index|[
name|off
operator|+
literal|4
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|5
index|]
argument_list|,
name|buf
index|[
name|off
operator|+
literal|6
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" KID %u]"
argument_list|,
name|buf
index|[
name|off
operator|+
name|IEEE80211_WEP_IVLEN
index|]
operator|>>
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rate
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" %dM"
argument_list|,
name|rate
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" +%d"
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|findrix
parameter_list|(
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|r
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_fix_rate
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rateset
modifier|*
name|nrs
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rix
decl_stmt|,
name|error
decl_stmt|;
name|int
name|okrate
decl_stmt|,
name|badrate
decl_stmt|,
name|fixedrate
decl_stmt|,
name|ucastrate
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|srs
decl_stmt|;
name|uint8_t
name|r
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|okrate
operator|=
name|badrate
operator|=
literal|0
expr_stmt|;
name|ucastrate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
index|]
operator|.
name|ucastrate
expr_stmt|;
if|if
condition|(
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
comment|/* 		 * Workaround awkwardness with fixed rate.  We are called 		 * to check both the legacy rate set and the HT rate set 		 * but we must apply any legacy fixed rate check only to the 		 * legacy rate set and vice versa.  We cannot tell what type 		 * of rate set we've been given (legacy or HT) but we can 		 * distinguish the fixed rate type (MCS have 0x80 set). 		 * So to deal with this the caller communicates whether to 		 * check MCS or legacy rate using the flags and we use the 		 * type of any fixed rate to avoid applying an MCS to a 		 * legacy rate and vice versa. 		 */
if|if
condition|(
name|ucastrate
operator|&
literal|0x80
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOFRATE
condition|)
name|flags
operator|&=
operator|~
name|IEEE80211_F_DOFRATE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ucastrate
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOFMCS
condition|)
name|flags
operator|&=
operator|~
name|IEEE80211_F_DOFMCS
expr_stmt|;
block|}
comment|/* NB: required to make MCS match below work */
name|ucastrate
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
block|}
name|fixedrate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
comment|/* 	 * XXX we are called to process both MCS and legacy rates; 	 * we must use the appropriate basic rate set or chaos will 	 * ensue; for now callers that want MCS must supply 	 * IEEE80211_F_DOBRS; at some point we'll need to split this 	 * function so there are two variants, one for MCS and one 	 * for legacy rates. 	 */
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOBRS
condition|)
name|srs
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_rateset
operator|*
operator|)
name|ieee80211_get_suphtrates
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
else|else
name|srs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOSORT
condition|)
block|{
comment|/* 			 * Sort rates. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|IEEE80211_RV
argument_list|(
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
argument_list|)
operator|>
name|IEEE80211_RV
argument_list|(
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|r
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
block|}
block|}
block|}
name|r
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|badrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check for fixed rate. 		 */
if|if
condition|(
name|r
operator|==
name|ucastrate
condition|)
name|fixedrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check against supported rates. 		 */
name|rix
operator|=
name|findrix
argument_list|(
name|srs
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DONEGO
condition|)
block|{
if|if
condition|(
name|rix
operator|<
literal|0
condition|)
block|{
comment|/* 				 * A rate in the node's rate set is not 				 * supported.  If this is a basic rate and we 				 * are operating as a STA then this is an error. 				 * Otherwise we just discard/ignore the rate. 				 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_JOIN
operator|)
operator|&&
operator|(
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
condition|)
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_JOIN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Overwrite with the supported rate 				 * value so any basic rate bit is set. 				 */
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|srs
operator|->
name|rs_rates
index|[
name|rix
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_DODEL
operator|)
operator|&&
name|rix
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Delete unacceptable rates. 			 */
name|nrs
operator|->
name|rs_nrates
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rix
operator|>=
literal|0
condition|)
name|okrate
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|okrate
operator|==
literal|0
operator|||
name|error
operator|!=
literal|0
operator|||
operator|(
operator|(
name|flags
operator|&
operator|(
name|IEEE80211_F_DOFRATE
operator||
name|IEEE80211_F_DOFMCS
operator|)
operator|)
operator|&&
name|fixedrate
operator|!=
name|ucastrate
operator|)
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: flags 0x%x okrate %d error %d fixedrate 0x%x "
literal|"ucastrate %x\n"
argument_list|,
name|__func__
argument_list|,
name|fixedrate
argument_list|,
name|ucastrate
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
name|badrate
operator||
name|IEEE80211_RATE_BASIC
return|;
block|}
else|else
return|return
name|IEEE80211_RV
argument_list|(
name|okrate
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset 11g-related state.  */
end_comment

begin_function
name|void
name|ieee80211_reset_erp
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEPROT
expr_stmt|;
name|ic
operator|->
name|ic_nonerpsta
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_longslotsta
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Short slot time is enabled only when operating in 11g 	 * and not in an IBSS.  We must also honor whether or not 	 * the driver is capable of doing it. 	 */
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|||
operator|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set short preamble and ERP barker-preamble flags. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|||
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHPREAMBLE
operator|)
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the short slot time state and notify the driver.  */
end_comment

begin_function
name|void
name|ieee80211_set_shortslottime
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|onoff
condition|)
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHSLOT
expr_stmt|;
else|else
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHSLOT
expr_stmt|;
comment|/* notify driver */
if|if
condition|(
name|ic
operator|->
name|ic_updateslot
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_updateslot
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the specified rate set supports ERP.  * NB: the rate set is assumed to be sorted.  */
end_comment

begin_function
name|int
name|ieee80211_iserp_rateset
parameter_list|(
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|rates
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|12
block|,
literal|24
block|,
literal|48
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|<
name|nitems
argument_list|(
name|rates
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nitems
argument_list|(
name|rates
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|rates
index|[
name|i
index|]
operator|==
name|r
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|r
operator|>
name|rates
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
name|next
label|:
empty_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Mark the basic rates for the rate table based on the  * operating mode.  For real 11g we mark all the 11b rates  * and 6, 12, and 24 OFDM.  For 11b compatibility we mark only  * 11b rates.  There's also a pseudo 11a-mode used to mark only  * the basic OFDM rates.  */
end_comment

begin_function
specifier|static
name|void
name|setbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
name|int
name|add
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|basic
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
block|{
literal|2
block|,
literal|4
block|}
block|}
block|,
comment|/* NB: mixed b/g */
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|6
block|,
literal|12
block|,
literal|24
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|3
block|,
literal|6
block|,
literal|12
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
comment|/* NB: mixed b/g */
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
comment|/* NB: mixed b/g */
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|add
condition|)
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|basic
index|[
name|mode
index|]
operator|.
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|basic
index|[
name|mode
index|]
operator|.
name|rs_rates
index|[
name|j
index|]
operator|==
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
condition|)
block|{
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator||=
name|IEEE80211_RATE_BASIC
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set the basic rates in a rate set.  */
end_comment

begin_function
name|void
name|ieee80211_setbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
name|setbasicrates
argument_list|(
name|rs
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add basic rates to a rate set.  */
end_comment

begin_function
name|void
name|ieee80211_addbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
name|setbasicrates
argument_list|(
name|rs
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * WME protocol support.  *  * The default 11a/b/g/n parameters come from the WiFi Alliance WMM  * System Interopability Test Plan (v1.4, Appendix F) and the 802.11n  * Draft 2.0 Test Plan (Appendix D).  *  * Static/Dynamic Turbo mode settings come from Atheros.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|phyParamType
block|{
name|uint8_t
name|aifsn
decl_stmt|;
name|uint8_t
name|logcwmin
decl_stmt|;
name|uint8_t
name|logcwmax
decl_stmt|;
name|uint16_t
name|txopLimit
decl_stmt|;
name|uint8_t
name|acm
decl_stmt|;
block|}
name|paramType
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_BE
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_BK
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_VI
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_VO
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_BE
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_VI
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|188
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_VO
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|102
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|_setifsparams
parameter_list|(
name|struct
name|wmeParams
modifier|*
name|wmep
parameter_list|,
specifier|const
name|paramType
modifier|*
name|phy
parameter_list|)
block|{
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|phy
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|phy
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|phy
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|phy
operator|->
name|txopLimit
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setwmeparams
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|,
name|int
name|ac
parameter_list|,
name|struct
name|wmeParams
modifier|*
name|wmep
parameter_list|,
specifier|const
name|paramType
modifier|*
name|phy
parameter_list|)
block|{
name|wmep
operator|->
name|wmep_acm
operator|=
name|phy
operator|->
name|acm
expr_stmt|;
name|_setifsparams
argument_list|(
name|wmep
argument_list|,
name|phy
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"set %s (%s) [acm %u aifsn %u logcwmin %u logcwmax %u txop %u]\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|ac
index|]
argument_list|,
name|type
argument_list|,
name|wmep
operator|->
name|wmep_acm
argument_list|,
name|wmep
operator|->
name|wmep_aifsn
argument_list|,
name|wmep
operator|->
name|wmep_logcwmin
argument_list|,
name|wmep
operator|->
name|wmep_logcwmax
argument_list|,
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_wme_initparams_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
specifier|const
name|paramType
modifier|*
name|pPhyParam
decl_stmt|,
modifier|*
name|pBssPhyParam
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
operator|)
operator|==
literal|0
operator|||
name|ic
operator|->
name|ic_nrunning
operator|>
literal|1
condition|)
return|return;
comment|/* 	 * Clear the wme cap_info field so a qoscount from a previous 	 * vap doesn't confuse later code which only parses the beacon 	 * field and updates hardware when said field changes. 	 * Otherwise the hardware is programmed with defaults, not what 	 * the beacon actually announces. 	 */
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_info
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Select mode; we can be called early in which case we 	 * always use auto mode.  We know we'll be called when 	 * entering the RUN state with bsschan setup properly 	 * so state will eventually get set correctly 	 */
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|WME_AC_BK
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_BK
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|phyParamForAC_BK
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_VI
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_VI
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_VI
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_VO
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_VO
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_VO
index|[
name|mode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_BE
case|:
default|default:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_BE
index|[
name|mode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_BE
index|[
name|mode
index|]
expr_stmt|;
break|break;
block|}
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|setwmeparams
argument_list|(
name|vap
argument_list|,
literal|"chan"
argument_list|,
name|i
argument_list|,
name|wmep
argument_list|,
name|pPhyParam
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|setwmeparams
argument_list|(
name|vap
argument_list|,
literal|"chan"
argument_list|,
name|i
argument_list|,
name|wmep
argument_list|,
name|pBssPhyParam
argument_list|)
expr_stmt|;
block|}
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|setwmeparams
argument_list|(
name|vap
argument_list|,
literal|"bss "
argument_list|,
name|i
argument_list|,
name|wmep
argument_list|,
name|pBssPhyParam
argument_list|)
expr_stmt|;
block|}
comment|/* NB: check ic_bss to avoid NULL deref on initial attach */
if|if
condition|(
name|vap
operator|->
name|iv_bss
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Calculate aggressive mode switching threshold based 		 * on beacon interval.  This doesn't need locking since 		 * we're only called before entering the RUN state at 		 * which point we start sending beacon frames. 		 */
name|wme
operator|->
name|wme_hipri_switch_thresh
operator|=
operator|(
name|HIGH_PRI_SWITCH_THRESH
operator|*
name|vap
operator|->
name|iv_bss
operator|->
name|ni_intval
operator|)
operator|/
literal|100
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator|&=
operator|~
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_wme_initparams
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_initparams_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for ourself and the BSS.  */
end_comment

begin_function
name|void
name|ieee80211_wme_updateparams_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
specifier|static
specifier|const
name|paramType
name|aggrParam
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
block|{
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
block|{
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
comment|/* XXXcheck*/
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
comment|/* XXXcheck*/
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
comment|/* XXXcheck*/
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|,
literal|0
block|}
block|,
comment|/* XXXcheck*/
block|}
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|chanp
decl_stmt|,
modifier|*
name|bssp
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|do_aggrmode
init|=
literal|0
decl_stmt|;
comment|/* 	 * Set up the channel access parameters for the physical 	 * device.  First populate the configured settings. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|wmep
operator|->
name|wmep_logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|wmep
operator|->
name|wmep_logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|wmep
operator|->
name|wmep_logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|wmep
operator|->
name|wmep_logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
block|}
comment|/* 	 * Select mode; we can be called early in which case we 	 * always use auto mode.  We know we'll be called when 	 * entering the RUN state with bsschan setup properly 	 * so state will eventually get set correctly 	 */
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
else|else
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
comment|/* 	 * This implements aggressive mode as found in certain 	 * vendors' AP's.  When there is significant high 	 * priority (VI/VO) traffic in the BSS throttle back BE 	 * traffic by using conservative parameters.  Otherwise 	 * BE uses aggressive params to optimize performance of 	 * legacy/non-QoS traffic. 	 */
comment|/* Hostap? Only if aggressive mode is enabled */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
operator|)
operator|!=
literal|0
condition|)
name|do_aggrmode
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Station? Only if we're in a non-QoS BSS. 	 */
elseif|else
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
operator|)
condition|)
name|do_aggrmode
operator|=
literal|1
expr_stmt|;
comment|/* 	 * IBSS? Only if we we have WME enabled. 	 */
elseif|else
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
operator|)
condition|)
name|do_aggrmode
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If WME is disabled on this VAP, default to aggressive mode 	 * regardless of the configuration. 	 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|==
literal|0
condition|)
name|do_aggrmode
operator|=
literal|1
expr_stmt|;
comment|/* XXX WDS? */
comment|/* XXX MBSS? */
if|if
condition|(
name|do_aggrmode
condition|)
block|{
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|bssp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|bssp
operator|->
name|wmep_aifsn
operator|=
name|aggrParam
index|[
name|mode
index|]
operator|.
name|aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|bssp
operator|->
name|wmep_logcwmin
operator|=
name|aggrParam
index|[
name|mode
index|]
operator|.
name|logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|bssp
operator|->
name|wmep_logcwmax
operator|=
name|aggrParam
index|[
name|mode
index|]
operator|.
name|logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|bssp
operator|->
name|wmep_txopLimit
operator|=
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_BURST
operator|)
condition|?
name|aggrParam
index|[
name|mode
index|]
operator|.
name|txopLimit
else|:
literal|0
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"update %s (chan+bss) [acm %u aifsn %u logcwmin %u "
literal|"logcwmax %u txop %u]\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BE
index|]
argument_list|,
name|chanp
operator|->
name|wmep_acm
argument_list|,
name|chanp
operator|->
name|wmep_aifsn
argument_list|,
name|chanp
operator|->
name|wmep_logcwmin
argument_list|,
name|chanp
operator|->
name|wmep_logcwmax
argument_list|,
name|chanp
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Change the contention window based on the number of associated 	 * stations.  If the number of associated stations is 1 and 	 * aggressive mode is enabled, lower the contention window even 	 * further. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|ic
operator|->
name|ic_sta_assoc
operator|<
literal|2
operator|&&
operator|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|uint8_t
name|logCwMin
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
literal|4
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
literal|4
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_VHT_2GHZ
index|]
operator|=
literal|3
block|,
index|[
name|IEEE80211_MODE_VHT_5GHZ
index|]
operator|=
literal|3
block|, 		}
decl_stmt|;
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|bssp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|bssp
operator|->
name|wmep_logcwmin
operator|=
name|logCwMin
index|[
name|mode
index|]
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"update %s (chan+bss) logcwmin %u\n"
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BE
index|]
argument_list|,
name|chanp
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Arrange for the beacon update. 	 * 	 * XXX what about MBSS, WDS? 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
comment|/* 		 * Arrange for a beacon update and bump the parameter 		 * set number so associated stations load the new values. 		 */
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
operator|=
operator|(
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
operator|+
literal|1
operator|)
operator|&
name|WME_QOSINFO_COUNT
expr_stmt|;
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_WME
argument_list|)
expr_stmt|;
block|}
comment|/* schedule the deferred WME update */
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_wme_task
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: WME params updated, cap_info 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|?
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_info
else|:
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_wme_updateparams
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
condition|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_wme_vap_getparams
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|chanAccParams
modifier|*
name|wp
parameter_list|)
block|{
name|memcpy
argument_list|(
name|wp
argument_list|,
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_wme_ic_getparams
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|chanAccParams
modifier|*
name|wp
parameter_list|)
block|{
name|memcpy
argument_list|(
name|wp
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|wp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parent_updown
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|ic
operator|->
name|ic_parent
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_mcast
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|ic
operator|->
name|ic_update_mcast
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_promisc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|ic
operator|->
name|ic_update_promisc
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_channel
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|ic
operator|->
name|ic_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_chan_change
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_chw
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
comment|/* 	 * XXX should we defer the channel width _config_ update until now? 	 */
name|ic
operator|->
name|ic_update_chw
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Deferred WME update.  *  * In preparation for per-VAP WME configuration, call the VAP  * method if the VAP requires it.  Otherwise, just call the  * older global method.  There isn't a per-VAP WME configuration  * just yet so for now just use the global configuration.  */
end_comment

begin_function
specifier|static
name|void
name|vap_update_wme
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_wme_update
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_wme_update
argument_list|(
name|vap
argument_list|,
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
argument_list|)
expr_stmt|;
else|else
name|ic
operator|->
name|ic_wme
operator|.
name|wme_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|restart_vaps
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|ieee80211_suspend_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_resume_all
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Block until the parent is in a known state.  This is  * used after any operations that dispatch a task (e.g.  * to auto-configure the parent device up/down).  */
end_comment

begin_function
name|void
name|ieee80211_waitfor_parent
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|taskqueue_block
argument_list|(
name|ic
operator|->
name|ic_tq
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_mcast_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_promisc_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_chan_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_bmiss_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_chw_task
argument_list|)
expr_stmt|;
name|taskqueue_unblock
argument_list|(
name|ic
operator|->
name|ic_tq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see whether the current channel needs reset.  *  * Some devices don't handle being given an invalid channel  * in their operating mode very well (eg wpi(4) will throw a  * firmware exception.)  *  * Return 0 if we're ok, 1 if the channel needs to be reset.  *  * See PR kern/202502.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_start_check_reset_chan
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|&&
name|IEEE80211_IS_CHAN_NOADHOC
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|)
operator|||
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|IEEE80211_IS_CHAN_NOHOSTAP
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reset the curchan to a known good state.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_start_reset_chan
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start a vap running.  If this is the first vap to be  * set running on the underlying device then we  * automatically bring the device up.  */
end_comment

begin_function
name|void
name|ieee80211_start_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"start running, %d vaps running\n"
argument_list|,
name|ic
operator|->
name|ic_nrunning
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Mark us running.  Note that it's ok to do this first; 		 * if we need to bring the parent device up we defer that 		 * to avoid dropping the com lock.  We expect the device 		 * to respond to being marked up by calling back into us 		 * through ieee80211_start_all at which point we'll come 		 * back in here and complete the work. 		 */
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* 		 * We are not running; if this we are the first vap 		 * to be brought up auto-up the parent if necessary. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_nrunning
operator|++
operator|==
literal|0
condition|)
block|{
comment|/* reset the channel to a known good channel */
if|if
condition|(
name|ieee80211_start_check_reset_chan
argument_list|(
name|vap
argument_list|)
condition|)
name|ieee80211_start_reset_chan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s: up parent %s\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * If the parent is up and running, then kick the 	 * 802.11 state machine as appropriate. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_roaming
operator|!=
name|IEEE80211_ROAMING_MANUAL
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX bypasses scan too easily; disable for now */
comment|/* 			 * Try to be intelligent about clocking the state 			 * machine.  If we're currently in RUN state then 			 * we should be able to apply any new state/parameters 			 * simply by re-associating.  Otherwise we need to 			 * re-scan to select an appropriate ap. 			 */
block|if (vap->iv_state>= IEEE80211_S_RUN) 				ieee80211_new_state_locked(vap, 				    IEEE80211_S_ASSOC, 1); 			else
endif|#
directive|endif
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * For monitor+wds mode there's nothing to do but 			 * start running.  Otherwise if this is the first 			 * vap to be brought up, start a scan which may be 			 * preempted if the station is locked to a particular 			 * channel. 			 */
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_REINIT
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
else|else
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Start a single vap.  */
end_comment

begin_function
name|void
name|ieee80211_init
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|ieee80211_start_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start all runnable vap's on a device.  */
end_comment

begin_function
name|void
name|ieee80211_start_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
comment|/* NB: avoid recursion */
name|ieee80211_start_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop a vap.  We force it down using the state machine  * then mark it's ifnet not running.  If this is the last  * vap running on the underlying device then we close it  * too to insure it will be properly initialized when the  * next vap is brought up.  */
end_comment

begin_function
name|void
name|ieee80211_stop_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"stop running, %d vaps running\n"
argument_list|,
name|ic
operator|->
name|ic_nrunning
argument_list|)
expr_stmt|;
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_RUNNING
condition|)
block|{
name|ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_RUNNING
expr_stmt|;
comment|/* mark us stopped */
if|if
condition|(
operator|--
name|ic
operator|->
name|ic_nrunning
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"down parent %s\n"
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_parent_task
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_stop
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop all vap's running on a device.  */
end_comment

begin_function
name|void
name|ieee80211_stop_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
comment|/* NB: avoid recursion */
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_waitfor_parent
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop all vap's running on a device and arrange  * for those that were running to be resumed.  */
end_comment

begin_function
name|void
name|ieee80211_suspend_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
block|{
comment|/* NB: avoid recursion */
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_RESUME
expr_stmt|;
name|ieee80211_stop_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_waitfor_parent
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start all vap's marked for resume.  */
end_comment

begin_function
name|void
name|ieee80211_resume_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
operator|!
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_RESUME
operator|)
condition|)
block|{
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_RESUME
expr_stmt|;
name|ieee80211_start_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Restart all vap's running on a device.  */
end_comment

begin_function
name|void
name|ieee80211_restart_all
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* 	 * NB: do not use ieee80211_runtask here, we will 	 * block& drain net80211 taskqueue. 	 */
name|taskqueue_enqueue
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ic
operator|->
name|ic_restart_task
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_beacon_miss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Process in a taskq, the handler may reenter the driver */
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_bmiss_task
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|beacon_miss
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
comment|/* 		 * We only pass events through for sta vap's in RUN+ state; 		 * may be too restrictive but for now this saves all the 		 * handlers duplicating these checks. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_bmiss
operator|!=
name|NULL
condition|)
name|vap
operator|->
name|iv_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|beacon_swmiss
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* XXX Call multiple times if npending> zero? */
name|vap
operator|->
name|iv_bmiss
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Software beacon miss handling.  Check if any beacons  * were received in the last period.  If not post a  * beacon miss; otherwise reset the counter.  */
end_comment

begin_function
name|void
name|ieee80211_swbmiss
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"wrong state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
block|{
comment|/* 		 * If scanning just ignore and reset state.  If we get a 		 * bmiss after coming out of scan because we haven't had 		 * time to receive a beacon then we should probe the AP 		 * before posting a real bmiss (unless iv_bmiss_max has 		 * been artifiically lowered).  A cleaner solution might 		 * be to disable the timer on scan start/end but to handle 		 * case of multiple sta vap's we'd need to disable the 		 * timers of all affected vap's. 		 */
name|vap
operator|->
name|iv_swbmiss_count
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_swbmiss_count
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_bmiss
operator|!=
name|NULL
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_swbmiss_task
argument_list|)
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_swbmiss_count
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|,
name|vap
operator|->
name|iv_swbmiss_period
argument_list|,
name|ieee80211_swbmiss
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start an 802.11h channel switch.  We record the parameters,  * mark the operation pending, notify each vap through the  * beacon update mechanism so it can update the beacon frame  * contents, and then switch vap's to CSA state to block outbound  * traffic.  Devices that handle CSA directly can use the state  * switch to do the right thing so long as they call  * ieee80211_csa_completeswitch when it's time to complete the  * channel change.  Devices that depend on the net80211 layer can  * use ieee80211_beacon_update to handle the countdown and the  * channel switch.  */
end_comment

begin_function
name|void
name|ieee80211_csa_startswitch
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_csa_newchan
operator|=
name|c
expr_stmt|;
name|ic
operator|->
name|ic_csa_mode
operator|=
name|mode
expr_stmt|;
name|ic
operator|->
name|ic_csa_count
operator|=
name|count
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_CSAPENDING
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_CSA
argument_list|)
expr_stmt|;
comment|/* switch to CSA state to block outbound traffic */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_CSA
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|ieee80211_notify_csa
argument_list|(
name|ic
argument_list|,
name|c
argument_list|,
name|mode
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete the channel switch by transitioning all CSA VAPs to RUN.  * This is called by both the completion and cancellation functions  * so each VAP is placed back in the RUN state and can thus transmit.  */
end_comment

begin_function
specifier|static
name|void
name|csa_completeswitch
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|ic
operator|->
name|ic_csa_newchan
operator|=
name|NULL
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_CSAPENDING
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CSA
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete an 802.11h channel switch started by ieee80211_csa_startswitch.  * We clear state and move all vap's in CSA state to RUN state  * so they can again transmit.  *  * Although this may not be completely correct, update the BSS channel  * for each VAP to the newly configured channel. The setcurchan sets  * the current operating channel for the interface (so the radio does  * switch over) but the VAP BSS isn't updated, leading to incorrectly  * reported information via ioctl.  */
end_comment

begin_function
name|void
name|ieee80211_csa_completeswitch
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_CSAPENDING
argument_list|,
operator|(
literal|"csa not pending"
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_setcurchan
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_csa_newchan
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CSA
condition|)
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|csa_completeswitch
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cancel an 802.11h channel switch started by ieee80211_csa_startswitch.  * We clear state and move all vap's in CSA state to RUN state  * so they can again transmit.  */
end_comment

begin_function
name|void
name|ieee80211_csa_cancelswitch
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|csa_completeswitch
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Complete a DFS CAC started by ieee80211_dfs_cac_start.  * We clear state and move all vap's in CAC state to RUN state.  */
end_comment

begin_function
name|void
name|ieee80211_cac_completeswitch
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap0
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Complete CAC state change for lead vap first; then 	 * clock all the other vap's waiting. 	 */
name|KASSERT
argument_list|(
name|vap0
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
argument_list|,
operator|(
literal|"wrong state %d"
operator|,
name|vap0
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_new_state_locked
argument_list|(
name|vap0
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
operator|&&
name|vap
operator|!=
name|vap0
condition|)
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Force all vap's other than the specified vap to the INIT state  * and mark them as waiting for a scan to complete.  These vaps  * will be brought up when the scan completes and the scanning vap  * reaches RUN state by wakeupwaiting.  */
end_comment

begin_function
specifier|static
name|void
name|markwaiting
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap0
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * A vap list entry can not disappear since we are running on the 	 * taskqueue and a vap destroy will queue and drain another state 	 * change task. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|==
name|vap0
condition|)
continue|continue;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* NB: iv_newstate may drop the lock */
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_INIT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Wakeup all vap's waiting for a scan to complete.  This is the  * companion to markwaiting (above) and is used to coordinate  * multiple vaps scanning.  * This is called from the state taskqueue.  */
end_comment

begin_function
specifier|static
name|void
name|wakeupwaiting
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap0
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * A vap list entry can not disappear since we are running on the 	 * taskqueue and a vap destroy will queue and drain another state 	 * change task. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|==
name|vap0
condition|)
continue|continue;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SCANWAIT
condition|)
block|{
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
comment|/* NB: sta's cannot go INIT->RUN */
comment|/* NB: iv_newstate may drop the lock */
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|?
name|IEEE80211_S_SCAN
else|:
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Handle post state change work common to all operating modes.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_newstate_cb
parameter_list|(
name|void
modifier|*
name|xvap
parameter_list|,
name|int
name|npending
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|xvap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|enum
name|ieee80211_state
name|nstate
decl_stmt|,
name|ostate
decl_stmt|;
name|int
name|arg
decl_stmt|,
name|rc
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|nstate
operator|=
name|vap
operator|->
name|iv_nstate
expr_stmt|;
name|arg
operator|=
name|vap
operator|->
name|iv_nstate_arg
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_REINIT
condition|)
block|{
comment|/* 		 * We have been requested to drop back to the INIT before 		 * proceeding to the new state. 		 */
comment|/* Deny any state changes while we are here. */
name|vap
operator|->
name|iv_nstate
operator|=
name|IEEE80211_S_INIT
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s arg %d\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_nstate
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_nstate
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
operator|(
name|IEEE80211_FEXT_REINIT
operator||
name|IEEE80211_FEXT_STATEWAIT
operator|)
expr_stmt|;
comment|/* enqueue new state transition after cancel_scan() task */
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|ostate
operator|=
name|vap
operator|->
name|iv_state
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
operator|&&
name|ostate
operator|!=
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 		 * SCAN was forced; e.g. on beacon miss.  Force other running 		 * vap's to INIT state and mark them as waiting for the scan to 		 * complete.  This insures they don't interfere with our 		 * scanning.  Since we are single threaded the vaps can not 		 * transition again while we are executing. 		 * 		 * XXX not always right, assumes ap follows sta 		 */
name|markwaiting
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s arg %d\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|rc
operator|=
name|vap
operator|->
name|iv_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_STATEWAIT
expr_stmt|;
if|if
condition|(
name|rc
operator|!=
literal|0
condition|)
block|{
comment|/* State transition failed */
name|KASSERT
argument_list|(
name|rc
operator|!=
name|EINPROGRESS
argument_list|,
operator|(
literal|"iv_newstate was deferred"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nstate
operator|!=
name|IEEE80211_S_INIT
argument_list|,
operator|(
literal|"INIT state change failed"
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s returned error %d\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|rc
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* No actual transition, skip post processing */
if|if
condition|(
name|ostate
operator|==
name|nstate
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* 		 * OACTIVE may be set on the vap if the upper layer 		 * tried to transmit (e.g. IPv6 NDP) before we reach 		 * RUN state.  Clear it and restart xmit. 		 * 		 * Note this can also happen as a result of SLEEP->RUN 		 * (i.e. coming out of power save mode). 		 */
name|vap
operator|->
name|iv_ifp
operator|->
name|if_drv_flags
operator|&=
operator|~
name|IFF_DRV_OACTIVE
expr_stmt|;
comment|/* 		 * XXX TODO Kick-start a VAP queue - this should be a method! 		 */
comment|/* bring up any vaps waiting on us */
name|wakeupwaiting
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 		 * Flush the scan cache if we did the last scan (XXX?) 		 * and flush any frames on send queues from this vap. 		 * Note the mgt q is used only for legacy drivers and 		 * will go away shortly. 		 */
name|ieee80211_scan_flush
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 		 * XXX TODO: ic/vap queue flush 		 */
block|}
name|done
label|:
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public interface for initiating a state machine change.  * This routine single-threads the request and coordinates  * the scheduling of multiple vaps for the purpose of selecting  * an operating channel.  Specifically the following scenarios  * are handled:  * o only one vap can be selecting a channel so on transition to  *   SCAN state if another vap is already scanning then  *   mark the caller for later processing and return without  *   doing anything (XXX? expectations by caller of synchronous operation)  * o only one vap can be doing CAC of a channel so on transition to  *   CAC state if another vap is already scanning for radar then  *   mark the caller for later processing and return without  *   doing anything (XXX? expectations by caller of synchronous operation)  * o if another vap is already running when a request is made  *   to SCAN then an operating channel has been chosen; bypass  *   the scan and just join the channel  *  * Note that the state change call is done through the iv_newstate  * method pointer so any driver routine gets invoked.  The driver  * will normally call back into operating mode-specific  * ieee80211_newstate routines (below) unless it needs to completely  * bypass the state machine (e.g. because the firmware has it's  * own idea how things should work).  Bypassing the net80211 layer  * is usually a mistake and indicates lack of proper integration  * with the net80211 layer.  */
end_comment

begin_function
name|int
name|ieee80211_new_state_locked
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vp
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
decl_stmt|;
name|int
name|nrunning
decl_stmt|,
name|nscanning
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_STATEWAIT
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_nstate
operator|==
name|IEEE80211_S_INIT
operator|||
operator|(
operator|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_INIT
operator|||
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_REINIT
operator|)
operator|)
operator|&&
name|vap
operator|->
name|iv_nstate
operator|==
name|IEEE80211_S_SCAN
operator|&&
name|nstate
operator|>
name|IEEE80211_S_SCAN
operator|)
condition|)
block|{
comment|/* 			 * XXX The vap is being stopped/started, 			 * do not allow any other state changes 			 * until this is completed. 			 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s (%s) transition discarded\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_nstate
index|]
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|vap
operator|->
name|iv_nstate
condition|)
block|{
if|#
directive|if
literal|0
comment|/* Warn if the previous state hasn't completed. */
block|IEEE80211_DPRINTF(vap, IEEE80211_MSG_STATE, 			    "%s: pending %s -> %s transition lost\n", __func__, 			    ieee80211_state_name[vap->iv_state], 			    ieee80211_state_name[vap->iv_nstate]);
else|#
directive|else
comment|/* XXX temporarily enable to identify issues */
name|if_printf
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
literal|"%s: pending %s -> %s transition lost\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_nstate
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|nrunning
operator|=
name|nscanning
operator|=
literal|0
expr_stmt|;
comment|/* XXX can track this state instead of calculating */
name|TAILQ_FOREACH
argument_list|(
argument|vp
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vp
operator|!=
name|vap
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
name|nrunning
operator|++
expr_stmt|;
comment|/* XXX doesn't handle bg scan */
comment|/* NB: CAC+AUTH+ASSOC treated like SCAN */
elseif|else
if|if
condition|(
name|vp
operator|->
name|iv_state
operator|>
name|IEEE80211_S_INIT
condition|)
name|nscanning
operator|++
expr_stmt|;
block|}
block|}
name|ostate
operator|=
name|vap
operator|->
name|iv_state
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s (nrunning %d nscanning %d)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|nrunning
argument_list|,
name|nscanning
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_SCAN
case|:
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* 			 * INIT -> SCAN happens on initial bringup. 			 */
name|KASSERT
argument_list|(
operator|!
operator|(
name|nscanning
operator|&&
name|nrunning
operator|)
argument_list|,
operator|(
literal|"%d scanning and %d running"
operator|,
name|nscanning
operator|,
name|nrunning
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nscanning
condition|)
block|{
comment|/* 				 * Someone is scanning, defer our state 				 * change until the work has completed. 				 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: defer %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|nrunning
condition|)
block|{
comment|/* 				 * Someone is operating; just join the channel 				 * they have chosen. 				 */
comment|/* XXX kill arg? */
comment|/* XXX check each opmode, adhoc? */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|nstate
operator|=
name|IEEE80211_S_SCAN
expr_stmt|;
else|else
name|nstate
operator|=
name|IEEE80211_S_RUN
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|nstate
operator|!=
name|IEEE80211_S_SCAN
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: override, now %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_WDSLEGACY
operator|)
operator|&&
name|nscanning
condition|)
block|{
comment|/* 			 * Legacy WDS with someone else scanning; don't 			 * go online until that completes as we should 			 * follow the other vap to the channel they choose. 			 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: defer %s -> %s (legacy WDS)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DFS
operator|)
operator|&&
operator|!
name|IEEE80211_IS_CHAN_CACDONE
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
comment|/* 			 * This is a DFS channel, transition to CAC state 			 * instead of RUN.  This allows us to initiate 			 * Channel Availability Check (CAC) as specified 			 * by 11h/DFS. 			 */
name|nstate
operator|=
name|IEEE80211_S_CAC
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: override %s -> %s (DFS)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_INIT
case|:
comment|/* cancel any scan in progress */
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* XXX don't believe this */
comment|/* INIT -> INIT. nothing to do */
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_SCANWAIT
expr_stmt|;
block|}
comment|/* fall thru... */
default|default:
break|break;
block|}
comment|/* defer the state change to a thread */
name|vap
operator|->
name|iv_nstate
operator|=
name|nstate
expr_stmt|;
name|vap
operator|->
name|iv_nstate_arg
operator|=
name|arg
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_STATEWAIT
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_nstate_task
argument_list|)
expr_stmt|;
return|return
name|EINPROGRESS
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_new_state
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|rc
operator|=
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

end_unit

