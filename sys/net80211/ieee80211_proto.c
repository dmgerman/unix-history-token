begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_comment
comment|/* XXX for ether_sprintf */
end_comment

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_comment
comment|/* XXX tunables */
end_comment

begin_define
define|#
directive|define
name|AGGRESSIVE_MODE_SWITCH_HYSTERESIS
value|3
end_define

begin_comment
comment|/* pkts / 100ms */
end_comment

begin_define
define|#
directive|define
name|HIGH_PRI_SWITCH_THRESH
value|10
end_define

begin_comment
comment|/* pkts / 100ms */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_RATE2MBS
parameter_list|(
name|r
parameter_list|)
value|(((r)& IEEE80211_RATE_VAL) / 2)
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_mgt_subtype_name
index|[]
init|=
block|{
literal|"assoc_req"
block|,
literal|"assoc_resp"
block|,
literal|"reassoc_req"
block|,
literal|"reassoc_resp"
block|,
literal|"probe_req"
block|,
literal|"probe_resp"
block|,
literal|"reserved#6"
block|,
literal|"reserved#7"
block|,
literal|"beacon"
block|,
literal|"atim"
block|,
literal|"disassoc"
block|,
literal|"auth"
block|,
literal|"deauth"
block|,
literal|"reserved#13"
block|,
literal|"reserved#14"
block|,
literal|"reserved#15"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_ctl_subtype_name
index|[]
init|=
block|{
literal|"reserved#0"
block|,
literal|"reserved#1"
block|,
literal|"reserved#2"
block|,
literal|"reserved#3"
block|,
literal|"reserved#3"
block|,
literal|"reserved#5"
block|,
literal|"reserved#6"
block|,
literal|"reserved#7"
block|,
literal|"reserved#8"
block|,
literal|"reserved#9"
block|,
literal|"ps_poll"
block|,
literal|"rts"
block|,
literal|"cts"
block|,
literal|"ack"
block|,
literal|"cf_end"
block|,
literal|"cf_end_ack"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_state_name
index|[
name|IEEE80211_S_MAX
index|]
init|=
block|{
literal|"INIT"
block|,
comment|/* IEEE80211_S_INIT */
literal|"SCAN"
block|,
comment|/* IEEE80211_S_SCAN */
literal|"AUTH"
block|,
comment|/* IEEE80211_S_AUTH */
literal|"ASSOC"
block|,
comment|/* IEEE80211_S_ASSOC */
literal|"RUN"
comment|/* IEEE80211_S_RUN */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_wme_acnames
index|[]
init|=
block|{
literal|"WME_AC_BE"
block|,
literal|"WME_AC_BK"
block|,
literal|"WME_AC_VI"
block|,
literal|"WME_AC_VO"
block|,
literal|"WME_UPSD"
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ieee80211_newstate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ieee80211_proto_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
comment|/* XXX room for crypto  */
name|ifp
operator|->
name|if_hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe_addr4
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_rtsthreshold
operator|=
name|IEEE80211_RTS_DEFAULT
expr_stmt|;
name|ic
operator|->
name|ic_fragthreshold
operator|=
name|IEEE80211_FRAG_DEFAULT
expr_stmt|;
name|ic
operator|->
name|ic_fixed_rate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
name|ic
operator|->
name|ic_bmiss_max
operator|=
name|IEEE80211_BMISS_MAX
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|ic
operator|->
name|ic_swbmiss
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_mcast_rate
operator|=
name|IEEE80211_MCAST_RATE_DEFAULT
expr_stmt|;
name|ic
operator|->
name|ic_protmode
operator|=
name|IEEE80211_PROT_CTSONLY
expr_stmt|;
name|ic
operator|->
name|ic_roaming
operator|=
name|IEEE80211_ROAMING_AUTO
expr_stmt|;
name|ic
operator|->
name|ic_wme
operator|.
name|wme_hipri_switch_hysteresis
operator|=
name|AGGRESSIVE_MODE_SWITCH_HYSTERESIS
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
operator|.
name|ifq_mtx
argument_list|,
name|ifp
operator|->
name|if_xname
argument_list|,
literal|"mgmt send q"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
comment|/* protocol state change handler */
name|ic
operator|->
name|ic_newstate
operator|=
name|ieee80211_newstate
expr_stmt|;
comment|/* initialize management frame handlers */
name|ic
operator|->
name|ic_recv_mgmt
operator|=
name|ieee80211_recv_mgmt
expr_stmt|;
name|ic
operator|->
name|ic_send_mgmt
operator|=
name|ieee80211_send_mgmt
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_proto_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* 	 * This should not be needed as we detach when reseting 	 * the state but be conservative here since the 	 * authenticator may do things like spawn kernel threads. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_detach
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_drain_ifq
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
operator|.
name|ifq_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Detach any ACL'ator. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_acl
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_acl
operator|->
name|iac_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simple-minded authenticator module support.  */
end_comment

begin_define
define|#
directive|define
name|IEEE80211_AUTH_MAX
value|(IEEE80211_AUTH_WPA+1)
end_define

begin_comment
comment|/* XXX well-known names */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|auth_modnames
index|[
name|IEEE80211_AUTH_MAX
index|]
init|=
block|{
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_NONE */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_OPEN */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_SHARED */
literal|"wlan_xauth"
block|,
comment|/* IEEE80211_AUTH_8021X	 */
literal|"wlan_internal"
block|,
comment|/* IEEE80211_AUTH_AUTO */
literal|"wlan_xauth"
block|,
comment|/* IEEE80211_AUTH_WPA */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|authenticators
index|[
name|IEEE80211_AUTH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_authenticator
name|auth_internal
init|=
block|{
operator|.
name|ia_name
operator|=
literal|"wlan_internal"
block|,
operator|.
name|ia_attach
operator|=
name|NULL
block|,
operator|.
name|ia_detach
operator|=
name|NULL
block|,
operator|.
name|ia_node_join
operator|=
name|NULL
block|,
operator|.
name|ia_node_leave
operator|=
name|NULL
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Setup internal authenticators once; they are never unregistered.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_auth_setup
parameter_list|(
name|void
parameter_list|)
block|{
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_OPEN
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_SHARED
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
name|ieee80211_authenticator_register
argument_list|(
name|IEEE80211_AUTH_AUTO
argument_list|,
operator|&
name|auth_internal
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_auth
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_auth_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|ieee80211_authenticator_get
parameter_list|(
name|int
name|auth
parameter_list|)
block|{
if|if
condition|(
name|auth
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|authenticators
index|[
name|auth
index|]
operator|==
name|NULL
condition|)
name|ieee80211_load_module
argument_list|(
name|auth_modnames
index|[
name|auth
index|]
argument_list|)
expr_stmt|;
return|return
name|authenticators
index|[
name|auth
index|]
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_authenticator_register
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|struct
name|ieee80211_authenticator
modifier|*
name|auth
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return;
name|authenticators
index|[
name|type
index|]
operator|=
name|auth
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_authenticator_unregister
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|>=
name|IEEE80211_AUTH_MAX
condition|)
return|return;
name|authenticators
index|[
name|type
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Very simple-minded ACL module support.  */
end_comment

begin_comment
comment|/* XXX just one for now */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|acl
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ieee80211_aclator_register
parameter_list|(
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|iac
parameter_list|)
block|{
name|printf
argument_list|(
literal|"wlan: %s acl policy registered\n"
argument_list|,
name|iac
operator|->
name|iac_name
argument_list|)
expr_stmt|;
name|acl
operator|=
name|iac
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_aclator_unregister
parameter_list|(
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|iac
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|iac
condition|)
name|acl
operator|=
name|NULL
expr_stmt|;
name|printf
argument_list|(
literal|"wlan: %s acl policy unregistered\n"
argument_list|,
name|iac
operator|->
name|iac_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ieee80211_aclator
modifier|*
name|ieee80211_aclator_get
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
name|ieee80211_load_module
argument_list|(
literal|"wlan_acl"
argument_list|)
expr_stmt|;
return|return
name|acl
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|acl
operator|->
name|iac_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|?
name|acl
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_print_essid
parameter_list|(
specifier|const
name|u_int8_t
modifier|*
name|essid
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|const
name|u_int8_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|len
operator|>
name|IEEE80211_NWID_LEN
condition|)
name|len
operator|=
name|IEEE80211_NWID_LEN
expr_stmt|;
comment|/* determine printable or not */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|' '
operator|||
operator|*
name|p
operator|>
literal|0x7e
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|len
condition|)
block|{
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%c"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\""
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"0x"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|p
operator|=
name|essid
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
operator|,
name|p
operator|++
control|)
name|printf
argument_list|(
literal|"%02x"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_dump_pkt
parameter_list|(
specifier|const
name|u_int8_t
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|rate
parameter_list|,
name|int
name|rssi
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wh
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_frame
operator|*
operator|)
name|buf
expr_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
name|printf
argument_list|(
literal|"NODS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
name|printf
argument_list|(
literal|"TODS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|printf
argument_list|(
literal|"FRDS %s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
name|printf
argument_list|(
literal|"DSDS %s"
argument_list|,
name|ether_sprintf
argument_list|(
operator|(
specifier|const
name|u_int8_t
operator|*
operator|)
operator|&
name|wh
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"->%s)"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
condition|)
block|{
case|case
name|IEEE80211_FC0_TYPE_DATA
case|:
name|printf
argument_list|(
literal|" data"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_TYPE_MGT
case|:
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|" type#%d"
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_WEP
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|" WEP [IV"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_WEP_IVLEN
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|" %.02x"
argument_list|,
name|buf
index|[
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" KID %u]"
argument_list|,
name|buf
index|[
sizeof|sizeof
argument_list|(
operator|*
name|wh
argument_list|)
operator|+
name|i
index|]
operator|>>
literal|6
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rate
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" %dM"
argument_list|,
name|rate
operator|/
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|>=
literal|0
condition|)
name|printf
argument_list|(
literal|" +%d"
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%02x"
argument_list|,
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|findrix
parameter_list|(
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|int
name|r
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|r
condition|)
return|return
name|i
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_fix_rate
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
define|#
directive|define
name|RV
parameter_list|(
name|v
parameter_list|)
value|((v)& IEEE80211_RATE_VAL)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rix
decl_stmt|,
name|error
decl_stmt|;
name|int
name|okrate
decl_stmt|,
name|badrate
decl_stmt|,
name|fixedrate
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|srs
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|nrs
decl_stmt|;
name|u_int8_t
name|r
decl_stmt|;
comment|/* 	 * If the fixed rate check was requested but no 	 * fixed has been defined then just remove it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_DOFRATE
operator|)
operator|&&
name|ic
operator|->
name|ic_fixed_rate
operator|==
name|IEEE80211_FIXED_RATE_NONE
condition|)
name|flags
operator|&=
operator|~
name|IEEE80211_F_DOFRATE
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|okrate
operator|=
name|badrate
operator|=
name|fixedrate
operator|=
literal|0
expr_stmt|;
name|srs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|nrs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
control|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOSORT
condition|)
block|{
comment|/* 			 * Sort rates. 			 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|RV
argument_list|(
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
argument_list|)
operator|>
name|RV
argument_list|(
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
argument_list|)
condition|)
block|{
name|r
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
block|}
block|}
block|}
name|r
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|badrate
operator|=
name|r
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DOFRATE
condition|)
block|{
comment|/* 			 * Check any fixed rate is included.  			 */
if|if
condition|(
name|r
operator|==
name|RV
argument_list|(
name|srs
operator|->
name|rs_rates
index|[
name|ic
operator|->
name|ic_fixed_rate
index|]
argument_list|)
condition|)
name|fixedrate
operator|=
name|r
expr_stmt|;
block|}
comment|/* 		 * Check against supported rates. 		 */
name|rix
operator|=
name|findrix
argument_list|(
name|srs
argument_list|,
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_DONEGO
condition|)
block|{
if|if
condition|(
name|rix
operator|<
literal|0
condition|)
block|{
comment|/* 				 * A rate in the node's rate set is not 				 * supported.  If this is a basic rate and we 				 * are operating as a STA then this is an error. 				 * Otherwise we just discard/ignore the rate. 				 */
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_JOIN
operator|)
operator|&&
operator|(
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
condition|)
name|error
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_JOIN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Overwrite with the supported rate 				 * value so any basic rate bit is set. 				 */
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|=
name|srs
operator|->
name|rs_rates
index|[
name|rix
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_F_DODEL
operator|)
operator|&&
name|rix
operator|<
literal|0
condition|)
block|{
comment|/* 			 * Delete unacceptable rates. 			 */
name|nrs
operator|->
name|rs_nrates
operator|--
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|nrs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|nrs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|rix
operator|>=
literal|0
condition|)
name|okrate
operator|=
name|nrs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|okrate
operator|==
literal|0
operator|||
name|error
operator|!=
literal|0
operator|||
operator|(
operator|(
name|flags
operator|&
name|IEEE80211_F_DOFRATE
operator|)
operator|&&
name|fixedrate
operator|==
literal|0
operator|)
condition|)
return|return
name|badrate
operator||
name|IEEE80211_RATE_BASIC
return|;
else|else
return|return
name|RV
argument_list|(
name|okrate
argument_list|)
return|;
undef|#
directive|undef
name|RV
block|}
end_function

begin_comment
comment|/*  * Reset 11g-related state.  */
end_comment

begin_function
name|void
name|ieee80211_reset_erp
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEPROT
expr_stmt|;
name|ic
operator|->
name|ic_nonerpsta
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_longslotsta
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Short slot time is enabled only when operating in 11g 	 * and not in an IBSS.  We must also honor whether or not 	 * the driver is capable of doing it. 	 */
name|ieee80211_set_shortslottime
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|||
operator|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set short preamble and ERP barker-preamble flags. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11A
operator|||
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHPREAMBLE
operator|)
condition|)
block|{
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
else|else
block|{
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHPREAMBLE
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_USEBARKER
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the short slot time state and notify the driver.  */
end_comment

begin_function
name|void
name|ieee80211_set_shortslottime
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|onoff
parameter_list|)
block|{
if|if
condition|(
name|onoff
condition|)
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_SHSLOT
expr_stmt|;
else|else
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SHSLOT
expr_stmt|;
comment|/* notify driver */
if|if
condition|(
name|ic
operator|->
name|ic_updateslot
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_updateslot
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check if the specified rate set supports ERP.  * NB: the rate set is assumed to be sorted.  */
end_comment

begin_function
name|int
name|ieee80211_iserp_rateset
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
specifier|static
specifier|const
name|int
name|rates
index|[]
init|=
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|12
block|,
literal|24
block|,
literal|48
block|}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|<
name|N
argument_list|(
name|rates
argument_list|)
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|N
argument_list|(
name|rates
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|rates
index|[
name|i
index|]
operator|==
name|r
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|r
operator|>
name|rates
index|[
name|i
index|]
condition|)
return|return
literal|0
return|;
block|}
return|return
literal|0
return|;
name|next
label|:
empty_stmt|;
block|}
return|return
literal|1
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Mark the basic rates for the 11g rate table based on the  * operating mode.  For real 11g we mark all the 11b rates  * and 6, 12, and 24 OFDM.  For 11b compatibility we mark only  * 11b rates.  There's also a pseudo 11a-mode used to mark only  * the basic OFDM rates.  */
end_comment

begin_function
name|void
name|ieee80211_set11gbasicrates
parameter_list|(
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|basic
index|[]
init|=
block|{
block|{
literal|0
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|3
block|,
block|{
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|2
block|,
block|{
literal|2
block|,
literal|4
block|}
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|4
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|}
block|}
block|,
comment|/* IEEE80211_MODE_11G (mixed b/g) */
block|{
literal|0
block|}
block|,
comment|/* IEEE80211_MODE_FH */
comment|/* IEEE80211_MODE_PUREG (not yet) */
block|{
literal|7
block|,
block|{
literal|2
block|,
literal|4
block|,
literal|11
block|,
literal|22
block|,
literal|12
block|,
literal|24
block|,
literal|48
block|}
block|}
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|basic
index|[
name|mode
index|]
operator|.
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|basic
index|[
name|mode
index|]
operator|.
name|rs_rates
index|[
name|j
index|]
operator|==
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
condition|)
block|{
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator||=
name|IEEE80211_RATE_BASIC
expr_stmt|;
break|break;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * WME protocol support.  The following parameters come from the spec.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|phyParamType
block|{
name|u_int8_t
name|aifsn
decl_stmt|;
name|u_int8_t
name|logcwmin
decl_stmt|;
name|u_int8_t
name|logcwmax
decl_stmt|;
name|u_int16_t
name|txopLimit
decl_stmt|;
name|u_int8_t
name|acm
decl_stmt|;
block|}
name|paramType
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_BE
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|3
block|,
literal|5
block|,
literal|7
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|3
block|,
literal|4
block|,
literal|6
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|3
block|,
literal|5
block|,
literal|7
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|2
block|,
literal|3
block|,
literal|5
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_BK
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|7
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|7
block|,
literal|4
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|7
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|7
block|,
literal|3
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_VI
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|188
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|1
block|,
literal|4
block|,
literal|5
block|,
literal|188
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|phyParamForAC_VO
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|102
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|102
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_BE
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|3
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|3
block|,
literal|4
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|3
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|2
block|,
literal|3
block|,
literal|10
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_VI
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|188
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|188
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|94
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|phyParamType
name|bssPhyParamForAC_VO
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|102
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|102
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|47
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|ieee80211_wme_initparams
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
specifier|const
name|paramType
modifier|*
name|pPhyParam
decl_stmt|,
modifier|*
name|pBssPhyParam
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
operator|)
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|WME_AC_BK
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_BK
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|phyParamForAC_BK
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_VI
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_VI
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_VI
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_VO
case|:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_VO
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_VO
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
break|break;
case|case
name|WME_AC_BE
case|:
default|default:
name|pPhyParam
operator|=
operator|&
name|phyParamForAC_BE
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
name|pBssPhyParam
operator|=
operator|&
name|bssPhyParamForAC_BE
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
break|break;
block|}
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|wmep
operator|->
name|wmep_acm
operator|=
name|pPhyParam
operator|->
name|acm
expr_stmt|;
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|pPhyParam
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|pPhyParam
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|pPhyParam
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|pPhyParam
operator|->
name|txopLimit
expr_stmt|;
block|}
else|else
block|{
name|wmep
operator|->
name|wmep_acm
operator|=
name|pBssPhyParam
operator|->
name|acm
expr_stmt|;
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|pBssPhyParam
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|pBssPhyParam
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|pBssPhyParam
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|pBssPhyParam
operator|->
name|txopLimit
expr_stmt|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s chan [acm %u aifsn %u log2(cwmin) %u "
literal|"log2(cwmax) %u txpoLimit %u]\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|,
name|wmep
operator|->
name|wmep_acm
argument_list|,
name|wmep
operator|->
name|wmep_aifsn
argument_list|,
name|wmep
operator|->
name|wmep_logcwmin
argument_list|,
name|wmep
operator|->
name|wmep_logcwmax
argument_list|,
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|->
name|wmep_acm
operator|=
name|pBssPhyParam
operator|->
name|acm
expr_stmt|;
name|wmep
operator|->
name|wmep_aifsn
operator|=
name|pBssPhyParam
operator|->
name|aifsn
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmin
operator|=
name|pBssPhyParam
operator|->
name|logcwmin
expr_stmt|;
name|wmep
operator|->
name|wmep_logcwmax
operator|=
name|pBssPhyParam
operator|->
name|logcwmax
expr_stmt|;
name|wmep
operator|->
name|wmep_txopLimit
operator|=
name|pBssPhyParam
operator|->
name|txopLimit
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s  bss [acm %u aifsn %u log2(cwmin) %u "
literal|"log2(cwmax) %u txpoLimit %u]\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|i
index|]
argument_list|,
name|wmep
operator|->
name|wmep_acm
argument_list|,
name|wmep
operator|->
name|wmep_aifsn
argument_list|,
name|wmep
operator|->
name|wmep_logcwmin
argument_list|,
name|wmep
operator|->
name|wmep_logcwmax
argument_list|,
name|wmep
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
comment|/* NB: check ic_bss to avoid NULL deref on initial attach */
if|if
condition|(
name|ic
operator|->
name|ic_bss
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Calculate agressive mode switching threshold based 		 * on beacon interval.  This doesn't need locking since 		 * we're only called before entering the RUN state at 		 * which point we start sending beacon frames. 		 */
name|wme
operator|->
name|wme_hipri_switch_thresh
operator|=
operator|(
name|HIGH_PRI_SWITCH_THRESH
operator|*
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
operator|)
operator|/
literal|100
expr_stmt|;
name|ieee80211_wme_updateparams
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Update WME parameters for ourself and the BSS.  */
end_comment

begin_function
name|void
name|ieee80211_wme_updateparams_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
specifier|static
specifier|const
name|paramType
name|phyParam
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_AUTO */
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_11A */
block|{
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_11B */
block|{
literal|2
block|,
literal|4
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_11G */
block|{
literal|2
block|,
literal|5
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_FH */
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_A */
block|{
literal|1
block|,
literal|3
block|,
literal|10
block|,
literal|64
block|}
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
specifier|const
name|struct
name|wmeParams
modifier|*
name|wmep
decl_stmt|;
name|struct
name|wmeParams
modifier|*
name|chanp
decl_stmt|,
modifier|*
name|bssp
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* set up the channel access parameters for the physical device */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|wmep
operator|->
name|wmep_logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|wmep
operator|->
name|wmep_logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|wmep
operator|=
operator|&
name|wme
operator|->
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|wmep
operator|->
name|wmep_aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|wmep
operator|->
name|wmep_logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|wmep
operator|->
name|wmep_logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|wmep
operator|->
name|wmep_txopLimit
expr_stmt|;
block|}
comment|/* 	 * This implements agressive mode as found in certain 	 * vendors' AP's.  When there is significant high 	 * priority (VI/VO) traffic in the BSS throttle back BE 	 * traffic by using conservative parameters.  Otherwise 	 * BE uses agressive params to optimize performance of 	 * legacy/non-QoS traffic. 	 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|==
literal|0
condition|)
block|{
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|bssp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_aifsn
operator|=
name|bssp
operator|->
name|wmep_aifsn
operator|=
name|phyParam
index|[
name|ic
operator|->
name|ic_curmode
index|]
operator|.
name|aifsn
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|bssp
operator|->
name|wmep_logcwmin
operator|=
name|phyParam
index|[
name|ic
operator|->
name|ic_curmode
index|]
operator|.
name|logcwmin
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmax
operator|=
name|bssp
operator|->
name|wmep_logcwmax
operator|=
name|phyParam
index|[
name|ic
operator|->
name|ic_curmode
index|]
operator|.
name|logcwmax
expr_stmt|;
name|chanp
operator|->
name|wmep_txopLimit
operator|=
name|bssp
operator|->
name|wmep_txopLimit
operator|=
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_BURST
operator|)
condition|?
name|phyParam
index|[
name|ic
operator|->
name|ic_curmode
index|]
operator|.
name|txopLimit
else|:
literal|0
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s [acm %u aifsn %u log2(cwmin) %u "
literal|"log2(cwmax) %u txpoLimit %u]\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BE
index|]
argument_list|,
name|chanp
operator|->
name|wmep_acm
argument_list|,
name|chanp
operator|->
name|wmep_aifsn
argument_list|,
name|chanp
operator|->
name|wmep_logcwmin
argument_list|,
name|chanp
operator|->
name|wmep_logcwmax
argument_list|,
name|chanp
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
name|ic
operator|->
name|ic_sta_assoc
operator|<
literal|2
operator|&&
operator|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
operator|)
operator|!=
literal|0
condition|)
block|{
specifier|static
specifier|const
name|u_int8_t
name|logCwMin
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
literal|3
block|,
comment|/* IEEE80211_MODE_AUTO */
literal|3
block|,
comment|/* IEEE80211_MODE_11A */
literal|4
block|,
comment|/* IEEE80211_MODE_11B */
literal|3
block|,
comment|/* IEEE80211_MODE_11G */
literal|4
block|,
comment|/* IEEE80211_MODE_FH */
literal|3
block|,
comment|/* IEEE80211_MODE_TURBO_A */
literal|3
block|,
comment|/* IEEE80211_MODE_TURBO_G */
block|}
decl_stmt|;
name|chanp
operator|=
operator|&
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|bssp
operator|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
expr_stmt|;
name|chanp
operator|->
name|wmep_logcwmin
operator|=
name|bssp
operator|->
name|wmep_logcwmin
operator|=
name|logCwMin
index|[
name|ic
operator|->
name|ic_curmode
index|]
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: %s log2(cwmin) %u\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_wme_acnames
index|[
name|WME_AC_BE
index|]
argument_list|,
name|chanp
operator|->
name|wmep_logcwmin
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* XXX ibss? */
comment|/* 		 * Arrange for a beacon update and bump the parameter 		 * set number so associated stations load the new values. 		 */
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
operator|=
operator|(
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
operator|+
literal|1
operator|)
operator|&
name|WME_QOSINFO_COUNT
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator||=
name|IEEE80211_F_WMEUPDATE
expr_stmt|;
block|}
name|wme
operator|->
name|wme_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: WME params updated, cap_info 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|?
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_info
else|:
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_wme_updateparams
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
condition|)
block|{
name|IEEE80211_BEACON_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_BEACON_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_beacon_miss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
block|{
comment|/* XXX check ic_curchan != ic_bsschan? */
return|return;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s\n"
argument_list|,
literal|"beacon miss"
argument_list|)
expr_stmt|;
comment|/* 	 * Our handling is only meaningful for stations that are 	 * associated; any other conditions else will be handled 	 * through different means (e.g. the tx timeout on mgt frames). 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
operator|||
name|ic
operator|->
name|ic_state
operator|!=
name|IEEE80211_S_RUN
condition|)
return|return;
if|if
condition|(
operator|++
name|ic
operator|->
name|ic_bmiss_count
operator|<
name|ic
operator|->
name|ic_bmiss_max
condition|)
block|{
comment|/* 		 * Send a directed probe req before falling back to a scan; 		 * if we receive a response ic_bmiss_count will be reset. 		 * Some cards mistakenly report beacon miss so this avoids 		 * the expensive scan if the ap is still there. 		 */
name|ieee80211_send_probereq
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_esslen
argument_list|,
name|ic
operator|->
name|ic_opt_ie
argument_list|,
name|ic
operator|->
name|ic_opt_ie_len
argument_list|)
expr_stmt|;
return|return;
block|}
name|ic
operator|->
name|ic_bmiss_count
operator|=
literal|0
expr_stmt|;
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Software beacon miss handling.  Check if any beacons  * were received in the last period.  If not post a  * beacon miss; otherwise reset the counter.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_swbmiss
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_swbmiss_count
operator|==
literal|0
condition|)
block|{
name|ieee80211_beacon_miss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_bmiss_count
operator|==
literal|0
condition|)
comment|/* don't re-arm timer */
return|return;
block|}
else|else
name|ic
operator|->
name|ic_swbmiss_count
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_swbmiss
argument_list|,
name|ic
operator|->
name|ic_swbmiss_period
argument_list|,
name|ieee80211_swbmiss
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_disassoc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DISASSOC
argument_list|,
name|IEEE80211_REASON_ASSOC_LEAVE
argument_list|)
expr_stmt|;
name|ieee80211_node_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sta_deauth
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg
decl_stmt|;
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|,
name|IEEE80211_REASON_ASSOC_LEAVE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee80211_newstate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
decl_stmt|;
name|ostate
operator|=
name|ic
operator|->
name|ic_state
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_state
operator|=
name|nstate
expr_stmt|;
comment|/* state transition */
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
comment|/* NB: no reference held */
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
condition|)
name|callout_stop
argument_list|(
operator|&
name|ic
operator|->
name|ic_swbmiss
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nstate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
break|break;
case|case
name|IEEE80211_S_RUN
case|:
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DISASSOC
argument_list|,
name|IEEE80211_REASON_ASSOC_LEAVE
argument_list|)
expr_stmt|;
name|ieee80211_sta_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|sta_disassoc
argument_list|,
name|ic
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_DEAUTH
argument_list|,
name|IEEE80211_REASON_AUTH_LEAVE
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|sta_deauth
argument_list|,
name|ic
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
name|ieee80211_cancel_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
break|break;
block|}
if|if
condition|(
name|ostate
operator|!=
name|IEEE80211_S_INIT
condition|)
block|{
comment|/* NB: optimize INIT -> INIT case */
name|ic
operator|->
name|ic_mgt_timer
operator|=
literal|0
expr_stmt|;
name|ieee80211_drain_ifq
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|)
expr_stmt|;
name|ieee80211_reset_bss
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_detach
operator|!=
name|NULL
condition|)
name|ic
operator|->
name|ic_auth
operator|->
name|ia_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|)
operator|&&
name|ic
operator|->
name|ic_des_chan
operator|!=
name|IEEE80211_CHAN_ANYC
condition|)
block|{
comment|/* 				 * AP operation and we already have a channel; 				 * bypass the scan and startup immediately. 				 */
name|ieee80211_create_ibss
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_des_chan
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ieee80211_begin_scan
argument_list|(
name|ic
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
comment|/* 			 * Scan next. If doing an active scan probe 			 * for the requested ap (if any). 			 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_ASCAN
condition|)
name|ieee80211_probe_curchan
argument_list|(
name|ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
comment|/* beacon miss */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"no recent beacons from %s; rescanning\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|ieee80211_sta_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_SIBSS
expr_stmt|;
comment|/* XXX */
comment|/* FALLTHRU */
case|case
name|IEEE80211_S_AUTH
case|:
case|case
name|IEEE80211_S_ASSOC
case|:
comment|/* timeout restart scan */
name|ni
operator|=
name|ieee80211_find_node
argument_list|(
operator|&
name|ic
operator|->
name|ic_scan
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|->
name|ni_fails
operator|++
expr_stmt|;
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_roaming
operator|==
name|IEEE80211_ROAMING_AUTO
condition|)
name|ieee80211_begin_scan
argument_list|(
name|ic
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
case|case
name|IEEE80211_S_SCAN
case|:
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_AUTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
case|case
name|IEEE80211_S_ASSOC
case|:
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
comment|/* ??? */
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_AUTH
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
comment|/* ignore and retry scan on timeout */
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
switch|switch
condition|(
name|arg
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_AUTH
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_state
operator|=
name|ostate
expr_stmt|;
comment|/* stay RUN */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
name|ieee80211_sta_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_roaming
operator|==
name|IEEE80211_ROAMING_AUTO
condition|)
block|{
comment|/* try to reauth */
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_AUTH
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_ASSOC
case|:
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
case|case
name|IEEE80211_S_SCAN
case|:
case|case
name|IEEE80211_S_ASSOC
case|:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"%s: invalid transition\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_AUTH
case|:
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_S_RUN
case|:
name|ieee80211_sta_leave
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_roaming
operator|==
name|IEEE80211_ROAMING_AUTO
condition|)
block|{
name|IEEE80211_SEND_MGMT
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
break|break;
case|case
name|IEEE80211_S_RUN
case|:
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|)
block|{
comment|/* XXX validate prerequisites */
block|}
switch|switch
condition|(
name|ostate
condition|)
block|{
case|case
name|IEEE80211_S_INIT
case|:
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
break|break;
comment|/* fall thru... */
case|case
name|IEEE80211_S_AUTH
case|:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"%s: invalid transition\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* fall thru... */
case|case
name|IEEE80211_S_RUN
case|:
break|break;
case|case
name|IEEE80211_S_SCAN
case|:
comment|/* adhoc/hostap mode */
case|case
name|IEEE80211_S_ASSOC
case|:
comment|/* infra mode */
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_txrate
operator|<
name|ni
operator|->
name|ni_rates
operator|.
name|rs_nrates
argument_list|,
operator|(
literal|"%s: bogus xmit rate %u setup\n"
operator|,
name|__func__
operator|,
name|ni
operator|->
name|ni_txrate
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_debug
argument_list|(
name|ic
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"associated "
argument_list|)
expr_stmt|;
else|else
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"synchronized "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"with %s ssid "
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_bssid
argument_list|)
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" channel %d start %uMb\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|IEEE80211_RATE2MBS
argument_list|(
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|ni
operator|->
name|ni_txrate
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|ic
operator|->
name|ic_mgt_timer
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ieee80211_notify_node_join
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|arg
operator|==
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
argument_list|)
expr_stmt|;
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
comment|/* XXX not authorized yet */
break|break;
block|}
if|if
condition|(
name|ostate
operator|!=
name|IEEE80211_S_RUN
operator|&&
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
operator|)
condition|)
block|{
comment|/* 			 * Start s/w beacon miss timer for devices w/o 			 * hardware support.  We fudge a bit here since 			 * we're doing this in software. 			 */
name|ic
operator|->
name|ic_swbmiss_period
operator|=
name|IEEE80211_TU_TO_TICKS
argument_list|(
literal|2
operator|*
name|ic
operator|->
name|ic_bmissthreshold
operator|*
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_swbmiss_count
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_swbmiss
argument_list|,
name|ic
operator|->
name|ic_swbmiss_period
argument_list|,
name|ieee80211_swbmiss
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Start/stop the authenticator when operating as an 		 * AP.  We delay until here to allow configuration to 		 * happen out of order. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
comment|/* XXX IBSS/AHDEMO */
name|ic
operator|->
name|ic_auth
operator|->
name|ia_attach
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX check failure */
name|ic
operator|->
name|ic_auth
operator|->
name|ia_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_auth
operator|->
name|ia_detach
operator|!=
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_auth
operator|->
name|ia_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * When 802.1x is not in use mark the port authorized 		 * at this point so traffic can flow. 		 */
if|if
condition|(
name|ni
operator|->
name|ni_authmode
operator|!=
name|IEEE80211_AUTH_8021X
condition|)
name|ieee80211_node_authorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 		 * Enable inactivity processing. 		 * XXX 		 */
name|ic
operator|->
name|ic_scan
operator|.
name|nt_inact_timer
operator|=
name|IEEE80211_INACT_WAIT
expr_stmt|;
name|ic
operator|->
name|ic_sta
operator|.
name|nt_inact_timer
operator|=
name|IEEE80211_INACT_WAIT
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

