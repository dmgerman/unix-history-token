begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ETHER_HEADER_COPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|memcpy(dst, src, sizeof(struct ether_header))
end_define

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|ieee80211_encap_fastframe
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m1
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh1
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m2
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_fragment
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
name|hdrsize
parameter_list|,
name|u_int
name|ciphdrsize
parameter_list|,
name|u_int
name|mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_tx_mgt_cb
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_comment
comment|/*  * Decide if an outbound management frame should be  * printed when debugging is enabled.  This filters some  * of the less interesting frames that come frequently  * (e.g. beacons).  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|doprint
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
return|return
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set the direction field and address fields of an outgoing  * non-QoS frame.  Note this should be called early on in  * constructing a frame as it sets i_fc[1]; other bits can  * then be or'd in.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_send_setup
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|uint8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|WH4
parameter_list|(
name|wh
parameter_list|)
value|((struct ieee80211_frame_addr4 *)wh)
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|da
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_DSTODS
expr_stmt|;
comment|/* XXX cheat, bssid holds RA */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|WH4
argument_list|(
name|wh
argument_list|)
operator|->
name|i_addr4
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* NB: to quiet compiler */
break|break;
block|}
block|}
else|else
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NB: use non-QoS tid */
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|++
expr_stmt|;
undef|#
directive|undef
name|WH4
block|}
end_function

begin_comment
comment|/*  * Send a management frame to the specified node.  The node pointer  * must have a reference as the pointer will be passed to the driver  * and potentially held for a long time.  If the frame is successfully  * dispatched to the driver, then it is responsible for freeing the  * reference (and potentially free'ing up any associated storage).  */
end_comment

begin_function
name|int
name|ieee80211_mgmt_output
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Yech, hack alert!  We want to pass the node down to the 	 * driver's start routine.  If we don't do so then the start 	 * routine must immediately look it up again and that can 	 * cause a lock order reversal if, for example, this frame 	 * is being sent because the station is being timedout and 	 * the frame being sent is a DEAUTH message.  We could stick 	 * this in an m_tag and tack that on to the mbuf.  However 	 * that's rather expensive to do for every frame so instead 	 * we stuff it in the rcvif field since outbound frames do 	 * not (presently) use this. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
argument_list|,
operator|(
literal|"rcvif not null"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|wh
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|type
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_LINK0
operator|)
operator|!=
literal|0
operator|&&
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_LINK0
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
literal|"[%s] encrypting frame (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_WEP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
comment|/* avoid printing too many frames */
if|if
condition|(
operator|(
name|ieee80211_msg_debug
argument_list|(
name|ic
argument_list|)
operator|&&
name|doprint
argument_list|(
name|ic
argument_list|,
name|type
argument_list|)
operator|)
operator|||
name|ieee80211_msg_dumppkts
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[%s] send %s on channel %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Raw packet transmit stub for legacy drivers.  * Send the packet through the mgt q so we bypass  * the normal encapsulation work.  */
end_comment

begin_function
name|int
name|ieee80211_raw_xmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_opackets
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * 802.11 output routine. This is (currently) used only to  * connect bpf write calls to the 802.11 layer for injecting  * raw 802.11 frames.  Note we locate the ieee80211com from  * the ifnet using a spare field setup at attach time.  This  * will go away when the virtual ap support comes in.  */
end_comment

begin_function
name|int
name|ieee80211_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|rtentry
modifier|*
name|rt0
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|do { error = (e); goto bad;} while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_spare2
decl_stmt|;
comment|/* XXX */
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Hand to the 802.3 code if not tagged as 	 * a raw 802.11 frame. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_IEEE80211
condition|)
return|return
name|ether_output
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|rt0
argument_list|)
return|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_check_ifnet_transmit
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|senderr
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
comment|/* XXX bypass bridge, pfil, carp, etc. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_ack
argument_list|)
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* locate destination node */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|ni
operator|=
name|ieee80211_find_txnode
argument_list|(
name|ic
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ni
operator|=
name|ieee80211_find_txnode
argument_list|(
name|ic
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Permit packets w/ bpf params through regardless 		 * (see below about sa_len). 		 */
if|if
condition|(
name|dst
operator|->
name|sa_len
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|ic
operator|->
name|ic_bss
argument_list|)
expr_stmt|;
block|}
comment|/* XXX ctrl frames should go through */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PWR_SAV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Station in power save mode; pass the frame 		 * to the 802.11 layer and continue.  We'll get 		 * the frame back when the time is right. 		 */
name|ieee80211_pwrsave
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|reclaim
goto|;
block|}
comment|/* calculate priority so drivers can find the tx queue */
comment|/* XXX assumes an 802.3 frame */
if|if
condition|(
name|ieee80211_classify
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * NB: DLT_IEEE802_11_RADIO identifies the parameters are 	 * present by setting the sa_len field of the sockaddr (yes, 	 * this is a hack). 	 * NB: we assume sa_data is suitably aligned to cast. 	 */
return|return
name|ic
operator|->
name|ic_raw_xmit
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_bpf_params
operator|*
operator|)
operator|(
name|dst
operator|->
name|sa_len
condition|?
name|dst
operator|->
name|sa_data
else|:
name|NULL
operator|)
argument_list|)
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|reclaim
label|:
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Send a null data frame to the specified node.  *  * NB: the caller is assumed to have setup a node reference  *     for use; this is necessary to deal with a race condition  *     when probing for inactive stations.  */
end_comment

begin_function
name|int
name|ieee80211_send_nulldata
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX debug msg */
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|wh
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
operator||
name|IEEE80211_FC0_SUBTYPE_NODATA
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
comment|/* NB: power management bit is never sent by an AP */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_PWR_MGT
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"[%s] send null data frame on channel %u, pwr mgt %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PWR_MGT
condition|?
literal|"ena"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* cheat */
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Assign priority to a frame based on any vlan tag assigned  * to the station and/or any Diffserv setting in an IP header.  * Finally, if an ACM policy is setup (in station mode) it's  * applied.  */
end_comment

begin_function
name|int
name|ieee80211_classify
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|int
name|v_wme_ac
decl_stmt|,
name|d_wme_ac
decl_stmt|,
name|ac
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
name|WME_AC_BE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*  	 * If node has a vlan tag then all traffic 	 * to it must have a matching tag. 	 */
name|v_wme_ac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_vlan
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_novlantag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|EVL_VLANOFTAG
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
operator|!=
name|EVL_VLANOFTAG
argument_list|(
name|ni
operator|->
name|ni_vlan
argument_list|)
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_vlanmismatch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* map vlan priority to AC */
switch|switch
condition|(
name|EVL_PRIOFTAG
argument_list|(
name|ni
operator|->
name|ni_vlan
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|v_wme_ac
operator|=
name|WME_AC_BK
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|3
case|:
name|v_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|v_wme_ac
operator|=
name|WME_AC_VI
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|v_wme_ac
operator|=
name|WME_AC_VO
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|INET
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|)
decl_stmt|;
comment|/* 		 * IP frame, map the TOS field. 		 */
switch|switch
condition|(
name|ip
operator|->
name|ip_tos
condition|)
block|{
case|case
literal|0x08
case|:
case|case
literal|0x20
case|:
name|d_wme_ac
operator|=
name|WME_AC_BK
expr_stmt|;
comment|/* background */
break|break;
case|case
literal|0x28
case|:
case|case
literal|0xa0
case|:
name|d_wme_ac
operator|=
name|WME_AC_VI
expr_stmt|;
comment|/* video */
break|break;
case|case
literal|0x30
case|:
comment|/* voice */
case|case
literal|0xe0
case|:
case|case
literal|0x88
case|:
comment|/* XXX UPSD */
case|case
literal|0xb8
case|:
name|d_wme_ac
operator|=
name|WME_AC_VO
expr_stmt|;
break|break;
default|default:
name|d_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* INET */
name|d_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
block|}
endif|#
directive|endif
comment|/* 	 * Use highest priority AC. 	 */
if|if
condition|(
name|v_wme_ac
operator|>
name|d_wme_ac
condition|)
name|ac
operator|=
name|v_wme_ac
expr_stmt|;
else|else
name|ac
operator|=
name|d_wme_ac
expr_stmt|;
comment|/* 	 * Apply ACM policy. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
specifier|static
specifier|const
name|int
name|acmap
index|[
literal|4
index|]
init|=
block|{
name|WME_AC_BK
block|,
comment|/* WME_AC_BE */
name|WME_AC_BK
block|,
comment|/* WME_AC_BK */
name|WME_AC_BE
block|,
comment|/* WME_AC_VI */
name|WME_AC_VI
block|,
comment|/* WME_AC_VO */
block|}
decl_stmt|;
while|while
condition|(
name|ac
operator|!=
name|WME_AC_BK
operator|&&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_acm
condition|)
name|ac
operator|=
name|acmap
index|[
name|ac
index|]
expr_stmt|;
block|}
name|done
label|:
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Insure there is sufficient contiguous space to encapsulate the  * 802.11 data frame.  If room isn't already there, arrange for it.  * Drivers and cipher modules assume we have done the necessary work  * and fail rudely if they don't find the space they need.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ieee80211_mbuf_adjust
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|hdrsize
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|TO_BE_RECLAIMED
value|(sizeof(struct ether_header) - sizeof(struct llc))
name|int
name|needed_space
init|=
name|ic
operator|->
name|ic_headroom
operator|+
name|hdrsize
decl_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX belongs in crypto code? */
name|needed_space
operator|+=
name|key
operator|->
name|wk_cipher
operator|->
name|ic_header
expr_stmt|;
comment|/* XXX frags */
comment|/* 		 * When crypto is being done in the host we must insure 		 * the data are writable for the cipher routines; clone 		 * a writable mbuf chain. 		 * XXX handle SWMIC specially 		 */
if|if
condition|(
name|key
operator|->
name|wk_flags
operator|&
operator|(
name|IEEE80211_KEY_SWCRYPT
operator||
name|IEEE80211_KEY_SWMIC
operator|)
condition|)
block|{
name|m
operator|=
name|m_unshare
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: cannot get writable mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
comment|/* XXX new stat */
return|return
name|NULL
return|;
block|}
block|}
block|}
comment|/* 	 * We know we are called just before stripping an Ethernet 	 * header and prepending an LLC header.  This means we know 	 * there will be 	 *	sizeof(struct ether_header) - sizeof(struct llc) 	 * bytes recovered to which we need additional space for the 	 * 802.11 header and any crypto header. 	 */
comment|/* XXX check trailing space and copy instead? */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|needed_space
operator|-
name|TO_BE_RECLAIMED
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: cannot expand storage\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KASSERT
argument_list|(
name|needed_space
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"not enough room, need %u got %zu\n"
operator|,
name|needed_space
operator|,
name|MHLEN
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Setup new mbuf to have leading space to prepend the 		 * 802.11 header and any crypto header bits that are 		 * required (the latter are added when the driver calls 		 * back to ieee80211_crypto_encap to do crypto encapsulation). 		 */
comment|/* NB: must be first 'cuz it clobbers m_data */
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* NB: m_gethdr does not set */
name|n
operator|->
name|m_data
operator|+=
name|needed_space
expr_stmt|;
comment|/* 		 * Pull up Ethernet header to create the expected layout. 		 * We could use m_pullup but that's overkill (i.e. we don't 		 * need the actual data) and it cannot fail so do it inline 		 * for speed. 		 */
comment|/* NB: struct ether_header is known to be contiguous */
name|n
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* 		 * Replace the head of the chain. 		 */
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
return|return
name|m
return|;
undef|#
directive|undef
name|TO_BE_RECLAIMED
block|}
end_function

begin_comment
comment|/*  * Return the transmit key to use in sending a unicast frame.  * If a unicast key is set we use that.  When no unicast key is set  * we fall back to the default transmit key.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ieee80211_key
operator|*
name|ieee80211_crypto_getucastkey
argument_list|(
argument|struct ieee80211com *ic
argument_list|,
argument|struct ieee80211_node *ni
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_def_txkey
operator|==
name|IEEE80211_KEYIX_NONE
operator|||
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
operator|&
name|ni
operator|->
name|ni_ucastkey
return|;
block|}
end_else

begin_comment
unit|}
comment|/*  * Return the transmit key to use in sending a multicast frame.  * Multicast traffic always uses the group key which is installed as  * the default tx key.  */
end_comment

begin_function
unit|static
name|__inline
name|struct
name|ieee80211_key
modifier|*
name|ieee80211_crypto_getmcastkey
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_def_txkey
operator|==
name|IEEE80211_KEYIX_NONE
operator|||
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an outbound data frame.  The mbuf chain is updated.  * If an error is encountered NULL is returned.  The caller is required  * to provide a node reference and pullup the ethernet header in the  * first mbuf.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_encap
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|key
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|int
name|hdrsize
decl_stmt|,
name|datalen
decl_stmt|,
name|addqos
decl_stmt|,
name|txfrag
decl_stmt|,
name|isff
decl_stmt|;
comment|/* 	 * Copy existing Ethernet header to a safe place.  The 	 * rest of the code assumes it's ok to strip it when 	 * reorganizing state for the final encapsulation. 	 */
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|eh
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Insure space for additional headers.  First identify 	 * transmit key to use in calculating any buffer adjustments 	 * required.  This is also used below to do privacy 	 * encapsulation work.  Then calculate the 802.11 header 	 * size and any padding required by the driver. 	 * 	 * Note key may be NULL if we fall back to the default 	 * transmit key and that is not set.  In that case the 	 * buffer may not be expanded as needed by the cipher 	 * routines, but they will/should discard it. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
condition|)
name|key
operator|=
name|ieee80211_crypto_getucastkey
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
else|else
name|key
operator|=
name|ieee80211_crypto_getmcastkey
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
operator|&&
name|eh
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] no default transmit key (%s) deftxkey %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_def_txkey
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nodefkey
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
name|key
operator|=
name|NULL
expr_stmt|;
comment|/* XXX 4-address format */
comment|/* 	 * XXX Some ap's don't handle QoS-encapsulated EAPOL 	 * frames so suppress use.  This may be an issue if other 	 * ap's require all data frames to be QoS-encapsulated 	 * once negotiated in which case we'll need to make this 	 * configurable. 	 */
name|addqos
operator|=
operator|(
name|ni
operator|->
name|ni_flags
operator|&
operator|(
name|IEEE80211_NODE_QOS
operator||
name|IEEE80211_NODE_HT
operator|)
operator|)
operator|&&
name|eh
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addqos
condition|)
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe
argument_list|)
expr_stmt|;
else|else
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DATAPAD
condition|)
name|hdrsize
operator|=
name|roundup
argument_list|(
name|hdrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|isff
operator|=
name|m
operator|->
name|m_flags
operator|&
name|M_FF
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|struct
name|ether_header
name|eh2
decl_stmt|;
comment|/* 		 * Fast frame encapsulation.  There must be two packets 		 * chained with m_nextpkt.  We do header adjustment for 		 * each, add the tunnel encapsulation, and then concatenate 		 * the mbuf chains to form a single frame for transmission. 		 */
name|m2
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: only one frame\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Include fast frame headers in adjusting header 		 * layout; this allocates space according to what 		 * ieee80211_encap_fastframe will do. 		 */
name|m
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|ic
argument_list|,
name|hdrsize
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|key
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 		 * Copy second frame's Ethernet header out of line 		 * and adjust for encapsulation headers.  Note that 		 * we make room for padding in case there isn't room 		 * at the end of first frame. 		 */
name|KASSERT
argument_list|(
name|m2
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh2
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|ic
argument_list|,
name|ATH_FF_MAX_HDR_PAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|m2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
goto|goto
name|bad
goto|;
block|}
name|m
operator|=
name|ieee80211_encap_fastframe
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
operator|&
name|eh
argument_list|,
name|m2
argument_list|,
operator|&
name|eh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
comment|/* 		 * Normal frame. 		 */
name|m
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|ic
argument_list|,
name|hdrsize
argument_list|,
name|key
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
goto|goto
name|bad
goto|;
block|}
comment|/* NB: this could be optimized 'cuz of ieee80211_mbuf_adjust */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|.
name|ether_type
expr_stmt|;
block|}
name|datalen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* NB: w/o 802.11 header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hdrsize
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
comment|/* 		 * NB: always use the bssid from ic_bss as the 		 *     neighbor's may be stale after an ibss merge 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
case|case
name|IEEE80211_M_WDS
case|:
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MORE_DATA
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
if|if
condition|(
name|addqos
condition|)
block|{
name|struct
name|ieee80211_qosframe
modifier|*
name|qwh
init|=
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|tid
decl_stmt|;
name|ac
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* map from access class/queue to 11e header priorty value */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|=
name|tid
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
comment|/* 		 * Check if A-MPDU tx aggregation is setup or if we 		 * should try to enable it.  The sta must be associated 		 * with HT and A-MPDU enabled for use.  On the first 		 * frame that goes out We issue an ADDBA request and 		 * wait for a reply.  The frame being encapsulated 		 * will go out w/o using A-MPDU, or possibly it might 		 * be collected by the driver and held/retransmit. 		 * ieee80211_ampdu_request handles staggering requests 		 * in case the receiver NAK's us or we are otherwise 		 * unable to establish a BA stream. 		 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_AMPDU_TX
operator|)
condition|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
decl_stmt|;
if|if
condition|(
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
comment|/* 				 * Operational, mark frame for aggregation. 				 */
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator||=
name|IEEE80211_QOS_ACKPOLICY_BA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_AMPDU_REQUESTED
argument_list|(
name|tap
argument_list|)
condition|)
block|{
comment|/* 				 * Not negotiated yet, request service. 				 */
name|ieee80211_ampdu_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXX works even when BA marked above */
if|if
condition|(
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator||=
name|IEEE80211_QOS_ACKPOLICY_NOACK
expr_stmt|;
name|qwh
operator|->
name|i_qos
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|qwh
operator|->
name|i_fc
index|[
literal|0
index|]
operator||=
name|IEEE80211_FC0_SUBTYPE_QOS
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|++
expr_stmt|;
block|}
comment|/* check if xmit fragmentation is required */
name|txfrag
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|ic
operator|->
name|ic_fragthreshold
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|&&
operator|!
name|isff
operator|)
expr_stmt|;
comment|/* NB: don't fragment ff's */
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * IEEE 802.1X: send EAPOL frames always in the clear. 		 * WPA/WPA2: encrypt EAPOL keys when pairwise keys are set. 		 */
if|if
condition|(
name|eh
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
operator|||
operator|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|?
operator|!
name|IEEE80211_KEY_UNDEFINED
argument_list|(
name|key
argument_list|)
else|:
operator|!
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
operator|)
operator|)
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_WEP
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_crypto_enmic
argument_list|(
name|ic
argument_list|,
name|key
argument_list|,
name|m
argument_list|,
name|txfrag
argument_list|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"[%s] enmic failed, discard frame\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_enmicfail
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
comment|/* 	 * NB: frag flags may leak from above; they should only 	 *     be set on return to the caller if we fragment at 	 *     the 802.11 layer. 	 */
name|m
operator|->
name|m_flags
operator|&=
operator|~
operator|(
name|M_FRAG
operator||
name|M_FIRSTFRAG
operator|)
expr_stmt|;
if|if
condition|(
name|txfrag
operator|&&
operator|!
name|ieee80211_fragment
argument_list|(
name|ic
argument_list|,
name|m
argument_list|,
name|hdrsize
argument_list|,
name|key
operator|!=
name|NULL
condition|?
name|key
operator|->
name|wk_cipher
operator|->
name|ic_header
else|:
literal|0
argument_list|,
name|ic
operator|->
name|ic_fragthreshold
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mcast
argument_list|)
expr_stmt|;
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_ucast
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_ADD
argument_list|(
name|ni
argument_list|,
name|tx_bytes
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
name|m
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Do Ethernet-LLC encapsulation for each payload in a fast frame  * tunnel encapsulation.  The frame is assumed to have an Ethernet  * header at the front that must be stripped before prepending the  * LLC followed by the Ethernet header passed in (with an Ethernet  * type that specifies the payload size).  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ieee80211_encap1
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|)
block|{
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|uint16_t
name|payload
decl_stmt|;
comment|/* XXX optimize by combining m_adj+M_PREPEND */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|payload
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* NB: w/o Ethernet header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for ether_header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ETHER_HEADER_COPY
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|eh
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|payload
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Do fast frame tunnel encapsulation.  The two frames and  * Ethernet headers are supplied.  The caller is assumed to  * have arrange for space in the mbuf chains for encapsulating  * headers (to avoid major mbuf fragmentation).  *  * The encapsulated frame is returned or NULL if there is a  * problem (should not happen).  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ieee80211_encap_fastframe
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m1
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh1
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m2
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh2
parameter_list|)
block|{
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pad
decl_stmt|;
comment|/* 	 * First, each frame gets a standard encapsulation. 	 */
name|m1
operator|=
name|ieee80211_encap1
argument_list|(
name|ic
argument_list|,
name|m1
argument_list|,
name|eh1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|m2
operator|=
name|ieee80211_encap1
argument_list|(
name|ic
argument_list|,
name|m2
argument_list|,
name|eh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* 	 * Pad leading frame to a 4-byte boundary.  If there 	 * is space at the end of the first frame, put it 	 * there; otherwise prepend to the front of the second 	 * frame.  We know doing the second will always work 	 * because we reserve space above.  We prefer appending 	 * as this typically has better DMA alignment properties. 	 */
for|for
control|(
name|m
operator|=
name|m1
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|pad
operator|=
name|roundup2
argument_list|(
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|4
argument_list|)
operator|-
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pad
condition|)
block|{
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|pad
condition|)
block|{
comment|/* prepend to second */
name|m2
operator|->
name|m_data
operator|-=
name|pad
expr_stmt|;
name|m2
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
block|}
else|else
block|{
comment|/* append to first */
name|m
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
block|}
block|}
comment|/* 	 * Now, stick 'em together and prepend the tunnel headers; 	 * first the Atheros tunnel header (all zero for now) and 	 * then a special fast frame LLC. 	 * 	 * XXX optimize by prepending together 	 */
name|m
operator|->
name|m_next
operator|=
name|m2
expr_stmt|;
comment|/* NB: last mbuf from above */
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m1
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for tunnel header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for llc header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|llc
operator|=
name|mtod
argument_list|(
name|m1
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_1
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_2
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|htons
argument_list|(
name|ATH_FF_ETH_TYPE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ff_encap
operator|++
expr_stmt|;
return|return
name|m1
return|;
block|}
end_function

begin_comment
comment|/*  * Fragment the frame according to the specified mtu.  * The size of the 802.11 header (w/o padding) is provided  * so we don't need to recalculate it.  We create a new  * mbuf for each fragment and chain it through m_nextpkt;  * we might be able to optimize this by reusing the original  * packet's mbufs but that is significantly more complicated.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_fragment
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
name|hdrsize
parameter_list|,
name|u_int
name|ciphdrsize
parameter_list|,
name|u_int
name|mtu
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|,
modifier|*
name|whf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|u_int
name|totalhdrsize
decl_stmt|,
name|fragno
decl_stmt|,
name|fragsize
decl_stmt|,
name|off
decl_stmt|,
name|remainder
decl_stmt|,
name|payload
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf already chained?"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|mtu
argument_list|,
operator|(
literal|"pktlen %u mtu %u"
operator|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|mtu
operator|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: mark the first frag; it will be propagated below */
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_FRAG
expr_stmt|;
name|totalhdrsize
operator|=
name|hdrsize
operator|+
name|ciphdrsize
expr_stmt|;
name|fragno
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|mtu
operator|-
name|ciphdrsize
expr_stmt|;
name|remainder
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|off
expr_stmt|;
name|prev
operator|=
name|m0
expr_stmt|;
do|do
block|{
name|fragsize
operator|=
name|totalhdrsize
operator|+
name|remainder
expr_stmt|;
if|if
condition|(
name|fragsize
operator|>
name|mtu
condition|)
name|fragsize
operator|=
name|mtu
expr_stmt|;
name|KASSERT
argument_list|(
name|fragsize
operator|<
name|MCLBYTES
argument_list|,
operator|(
literal|"fragment size %u too big!"
operator|,
name|fragsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragsize
operator|>
name|MHLEN
condition|)
name|m
operator|=
name|m_getcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* leave room to prepend any cipher header */
name|m_align
argument_list|(
name|m
argument_list|,
name|fragsize
operator|-
name|ciphdrsize
argument_list|)
expr_stmt|;
comment|/* 		 * Form the header in the fragment.  Note that since 		 * we mark the first fragment with the MORE_FRAG bit 		 * it automatically is propagated to each fragment; we 		 * need only clear it on the last fragment (done below). 		 */
name|whf
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|whf
argument_list|,
name|wh
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|whf
operator|->
name|i_seq
index|[
literal|0
index|]
operator||=
name|htole16
argument_list|(
operator|(
name|fragno
operator|&
name|IEEE80211_SEQ_FRAG_MASK
operator|)
operator|<<
name|IEEE80211_SEQ_FRAG_SHIFT
argument_list|)
expr_stmt|;
name|fragno
operator|++
expr_stmt|;
name|payload
operator|=
name|fragsize
operator|-
name|totalhdrsize
expr_stmt|;
comment|/* NB: destination is known to be contiguous */
name|m_copydata
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
name|payload
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrsize
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|hdrsize
operator|+
name|payload
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|hdrsize
operator|+
name|payload
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FRAG
expr_stmt|;
comment|/* chain up the fragment */
name|prev
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
comment|/* deduct fragment just formed */
name|remainder
operator|-=
name|payload
expr_stmt|;
name|off
operator|+=
name|payload
expr_stmt|;
block|}
do|while
condition|(
name|remainder
operator|!=
literal|0
condition|)
do|;
name|whf
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_FC1_MORE_FRAG
expr_stmt|;
comment|/* strip first mbuf now that everything has been copied */
name|m_adj
argument_list|(
name|m0
argument_list|,
operator|-
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|mtu
operator|-
name|ciphdrsize
operator|)
operator|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_FIRSTFRAG
operator||
name|M_FRAG
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_fragframes
operator|++
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_frags
operator|+=
name|fragno
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
comment|/* reclaim fragments but leave original frame for caller to free */
for|for
control|(
name|m
operator|=
name|m0
operator|->
name|m_nextpkt
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|next
control|)
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* XXX paranoid */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a supported rates element id to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_rates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|nrates
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|nrates
return|;
block|}
end_function

begin_comment
comment|/*  * Add an extended supported rates element id to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_xrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
comment|/* 	 * Add an extended supported rates element if operating in 11g mode. 	 */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|int
name|nrates
init|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*   * Add an ssid elemet to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_ssid
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ssid
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Add an erp element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_erp
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|uint8_t
name|erp
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_ERP
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
name|erp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|!=
literal|0
condition|)
name|erp
operator||=
name|IEEE80211_ERP_NON_ERP_PRESENT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|)
name|erp
operator||=
name|IEEE80211_ERP_USE_PROTECTION
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEBARKER
condition|)
name|erp
operator||=
name|IEEE80211_ERP_LONG_PREAMBLE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|erp
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_setup_wpa_ie
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
define|#
directive|define
name|WPA_OUI_BYTES
value|0x00, 0x50, 0xf2
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
define|#
directive|define
name|ADDSELECTOR
parameter_list|(
name|frm
parameter_list|,
name|sel
parameter_list|)
value|do {		\ 	memcpy(frm, sel, 4);			\ 	frm += 4;				\ } while (0)
specifier|static
specifier|const
name|uint8_t
name|oui
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_OUI_TYPE
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|cipher_suite
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_WEP40
block|}
block|,
comment|/* NB: 40-bit */
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_TKIP
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* XXX WRAP */
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_CCMP
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* XXX CKIP */
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_NULL
block|}
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|wep104_suite
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_WEP104
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|key_mgt_unspec
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_ASE_8021X_UNSPEC
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|key_mgt_psk
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_ASE_8021X_PSK
block|}
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rsnparms
modifier|*
name|rsn
init|=
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
decl_stmt|;
name|uint8_t
modifier|*
name|frm
init|=
name|ie
decl_stmt|;
name|uint8_t
modifier|*
name|selcnt
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* length filled in below */
name|memcpy
argument_list|(
name|frm
argument_list|,
name|oui
argument_list|,
sizeof|sizeof
argument_list|(
name|oui
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WPA OUI */
name|frm
operator|+=
sizeof|sizeof
argument_list|(
name|oui
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|WPA_VERSION
argument_list|)
expr_stmt|;
comment|/* XXX filter out CKIP */
comment|/* multicast cipher */
if|if
condition|(
name|rsn
operator|->
name|rsn_mcastcipher
operator|==
name|IEEE80211_CIPHER_WEP
operator|&&
name|rsn
operator|->
name|rsn_mcastkeylen
operator|>=
literal|13
condition|)
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|wep104_suite
argument_list|)
expr_stmt|;
else|else
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|rsn
operator|->
name|rsn_mcastcipher
index|]
argument_list|)
expr_stmt|;
comment|/* unicast cipher list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_CCM
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_AES_CCM
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_TKIP
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_TKIP
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* authenticator selector list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_UNSPEC
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_unspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_PSK
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_psk
argument_list|)
expr_stmt|;
block|}
comment|/* optional capabilities */
if|if
condition|(
name|rsn
operator|->
name|rsn_caps
operator|!=
literal|0
operator|&&
name|rsn
operator|->
name|rsn_caps
operator|!=
name|RSN_CAP_PREAUTH
condition|)
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|rsn
operator|->
name|rsn_caps
argument_list|)
expr_stmt|;
comment|/* calculate element length */
name|ie
index|[
literal|1
index|]
operator|=
name|frm
operator|-
name|ie
operator|-
literal|2
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
argument_list|,
operator|(
literal|"WPA IE too big, %u> %zu"
operator|,
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|ADDSELECTOR
undef|#
directive|undef
name|WPA_OUI_BYTES
block|}
end_function

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_setup_rsn_ie
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
define|#
directive|define
name|RSN_OUI_BYTES
value|0x00, 0x0f, 0xac
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
define|#
directive|define
name|ADDSELECTOR
parameter_list|(
name|frm
parameter_list|,
name|sel
parameter_list|)
value|do {		\ 	memcpy(frm, sel, 4);			\ 	frm += 4;				\ } while (0)
specifier|static
specifier|const
name|uint8_t
name|cipher_suite
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_WEP40
block|}
block|,
comment|/* NB: 40-bit */
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_TKIP
block|}
block|,
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_WRAP
block|}
block|,
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_CCMP
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* XXX CKIP */
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_NULL
block|}
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|wep104_suite
index|[
literal|4
index|]
init|=
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_WEP104
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|key_mgt_unspec
index|[
literal|4
index|]
init|=
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_ASE_8021X_UNSPEC
block|}
decl_stmt|;
specifier|static
specifier|const
name|uint8_t
name|key_mgt_psk
index|[
literal|4
index|]
init|=
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_ASE_8021X_PSK
block|}
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rsnparms
modifier|*
name|rsn
init|=
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
decl_stmt|;
name|uint8_t
modifier|*
name|frm
init|=
name|ie
decl_stmt|;
name|uint8_t
modifier|*
name|selcnt
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RSN
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* length filled in below */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|RSN_VERSION
argument_list|)
expr_stmt|;
comment|/* XXX filter out CKIP */
comment|/* multicast cipher */
if|if
condition|(
name|rsn
operator|->
name|rsn_mcastcipher
operator|==
name|IEEE80211_CIPHER_WEP
operator|&&
name|rsn
operator|->
name|rsn_mcastkeylen
operator|>=
literal|13
condition|)
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|wep104_suite
argument_list|)
expr_stmt|;
else|else
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|rsn
operator|->
name|rsn_mcastcipher
index|]
argument_list|)
expr_stmt|;
comment|/* unicast cipher list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_CCM
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_AES_CCM
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_TKIP
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_TKIP
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* authenticator selector list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_UNSPEC
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_unspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_PSK
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_psk
argument_list|)
expr_stmt|;
block|}
comment|/* optional capabilities */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|rsn
operator|->
name|rsn_caps
argument_list|)
expr_stmt|;
comment|/* XXX PMKID */
comment|/* calculate element length */
name|ie
index|[
literal|1
index|]
operator|=
name|frm
operator|-
name|ie
operator|-
literal|2
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
argument_list|,
operator|(
literal|"RSN IE too big, %u> %zu"
operator|,
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSELECTOR
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|RSN_OUI_BYTES
block|}
end_function

begin_comment
comment|/*  * Add a WPA/RSN element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_wpa
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
argument_list|,
operator|(
literal|"no WPA/RSN!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA2
condition|)
name|frm
operator|=
name|ieee80211_setup_rsn_ie
argument_list|(
name|ic
argument_list|,
name|frm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA1
condition|)
name|frm
operator|=
name|ieee80211_setup_wpa_ie
argument_list|(
name|ic
argument_list|,
name|frm
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WME_OUI_BYTES
value|0x00, 0x50, 0xf2
end_define

begin_comment
comment|/*  * Add a WME information element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_wme_info
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_wme_info
name|info
init|=
block|{
operator|.
name|wme_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|wme_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|)
operator|-
literal|2
block|,
operator|.
name|wme_oui
operator|=
block|{
name|WME_OUI_BYTES
block|}
block|,
operator|.
name|wme_type
operator|=
name|WME_OUI_TYPE
block|,
operator|.
name|wme_subtype
operator|=
name|WME_INFO_OUI_SUBTYPE
block|,
operator|.
name|wme_version
operator|=
name|WME_VERSION
block|,
operator|.
name|wme_info
operator|=
literal|0
block|, 	}
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a WME parameters element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_wme_param
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
parameter_list|)
block|{
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
comment|/* NB: this works 'cuz a param has an info at the front */
specifier|static
specifier|const
name|struct
name|ieee80211_wme_info
name|param
init|=
block|{
operator|.
name|wme_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|wme_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
operator|-
literal|2
block|,
operator|.
name|wme_oui
operator|=
block|{
name|WME_OUI_BYTES
block|}
block|,
operator|.
name|wme_type
operator|=
name|WME_OUI_TYPE
block|,
operator|.
name|wme_subtype
operator|=
name|WME_PARAM_OUI_SUBTYPE
block|,
operator|.
name|wme_version
operator|=
name|WME_VERSION
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|,
name|wme_info
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
expr_stmt|;
comment|/* AC info */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* reserved field */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|ac
init|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|SM
argument_list|(
name|i
argument_list|,
name|WME_PARAM_ACI
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_acm
argument_list|,
name|WME_PARAM_ACM
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_aifsn
argument_list|,
name|WME_PARAM_AIFSN
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|SM
argument_list|(
name|ac
operator|->
name|wmep_logcwmax
argument_list|,
name|WME_PARAM_LOGCWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_logcwmin
argument_list|,
name|WME_PARAM_LOGCWMIN
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ac
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
return|return
name|frm
return|;
undef|#
directive|undef
name|SM
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_undef
undef|#
directive|undef
name|WME_OUI_BYTES
end_undef

begin_define
define|#
directive|define
name|ATH_OUI_BYTES
value|0x00, 0x03, 0x7f
end_define

begin_comment
comment|/*  * Add a WME information element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_ath
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|uint8_t
name|caps
parameter_list|,
name|uint16_t
name|defkeyix
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_ath_ie
name|info
init|=
block|{
operator|.
name|ath_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|ath_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
operator|-
literal|2
block|,
operator|.
name|ath_oui
operator|=
block|{
name|ATH_OUI_BYTES
block|}
block|,
operator|.
name|ath_oui_type
operator|=
name|ATH_OUI_TYPE
block|,
operator|.
name|ath_oui_subtype
operator|=
name|ATH_OUI_SUBTYPE
block|,
operator|.
name|ath_version
operator|=
name|ATH_OUI_VERSION
block|, 	}
decl_stmt|;
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
init|=
operator|(
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|ath
operator|->
name|ath_capability
operator|=
name|caps
expr_stmt|;
name|ath
operator|->
name|ath_defkeyix
index|[
literal|0
index|]
operator|=
operator|(
name|defkeyix
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ath
operator|->
name|ath_defkeyix
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|defkeyix
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ATH_OUI_BYTES
end_undef

begin_comment
comment|/*  * Send a probe request frame with the specified ssid  * and any optional information element data.  */
end_comment

begin_function
name|int
name|ieee80211_send_probereq
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ssid
parameter_list|,
name|size_t
name|ssidlen
parameter_list|,
specifier|const
name|void
modifier|*
name|optie
parameter_list|,
name|size_t
name|optielen
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * prreq frame format 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[tlv] extended supported rates 	 *	[tlv] user-specified ie's 	 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
operator|(
name|optie
operator|!=
name|NULL
condition|?
name|optielen
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|optie
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|frm
argument_list|,
name|optie
argument_list|,
name|optielen
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|optielen
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
argument_list|,
operator|(
literal|"rcvif not null"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|wh
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
argument_list|,
name|sa
argument_list|,
name|da
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
comment|/* XXX power management? */
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_probereq
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"[%s] send probe req on channel %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_start
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate capability information for mgt frames.  */
end_comment

begin_function
specifier|static
name|uint16_t
name|getcapinfo
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|uint16_t
name|capinfo
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"station mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
else|else
name|capinfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
return|return
name|capinfo
return|;
block|}
end_function

begin_comment
comment|/*  * Send a management frame.  The node is for the destination (or ic_bss  * when in station mode).  Nodes other than ic_bss have their reference  * count bumped to reflect our use for an indeterminant time.  */
end_comment

begin_function
name|int
name|ieee80211_send_mgmt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|int
name|has_challenge
decl_stmt|,
name|is_shared_key
decl_stmt|,
name|ret
decl_stmt|,
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
comment|/* 		 * probe response frame format 		 *	[8] time stamp 		 *	[2] beacon interval 		 *	[2] cabability information 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] parameter set (FH/DS) 		 *	[tlv] parameter set (IBSS) 		 *	[tlv] extended rate phy (ERP) 		 *	[tlv] extended supported rates 		 *	[tlv] WPA 		 *	[tlv] WME (optional) 		 *	[tlv] HT capabilities 		 *	[tlv] HT information 		 *	[tlv] Vendor OUI HT capabilities (optional) 		 *	[tlv] Vendor OUI HT information (optional) 		 *	[tlv] Atheros capabilities 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
literal|8
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|7
comment|/* max(7,3) */
operator|+
literal|6
operator|+
literal|3
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
comment|/* XXX !WPA1+WPA2 fits w/o a cluster */
operator|+
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|?
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
else|:
literal|0
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
comment|/* XXX check for cluster requirement */
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
literal|4
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* timestamp should be filled later */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_FHPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|5
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_fhdwell
operator|&
literal|0x00ff
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
operator|(
name|ni
operator|->
name|ni_fhdwell
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_FH_CHANSET
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_FH_CHANPAT
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_fhindex
expr_stmt|;
block|}
else|else
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_DSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|)
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_erp
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_HTCOMPAT
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ni
operator|->
name|ni_ath_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_ath
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_ath_flags
argument_list|,
name|ni
operator|->
name|ni_ath_defkeyix
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
name|status
operator|=
name|arg
operator|>>
literal|16
expr_stmt|;
name|arg
operator|&=
literal|0xffff
expr_stmt|;
name|has_challenge
operator|=
operator|(
operator|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_CHALLENGE
operator|||
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_RESPONSE
operator|)
operator|&&
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* 		 * Deduce whether we're doing open authentication or 		 * shared key authentication.  We do the latter if 		 * we're in the middle of a shared key authentication 		 * handshake or if we're initiating an authentication 		 * request and configured to use shared key. 		 */
name|is_shared_key
operator|=
name|has_challenge
operator|||
name|arg
operator|>=
name|IEEE80211_AUTH_SHARED_RESPONSE
operator|||
operator|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_REQUEST
operator|&&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
operator|==
name|IEEE80211_AUTH_SHARED
operator|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
operator|(
name|has_challenge
operator|&&
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|?
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|IEEE80211_CHALLENGE_LEN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|is_shared_key
operator|)
condition|?
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_SHARED
argument_list|)
else|:
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_OPEN
argument_list|)
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* sequence number */
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|2
index|]
operator|=
name|htole16
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* status */
if|if
condition|(
name|has_challenge
operator|&&
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|3
index|]
operator|=
name|htole16
argument_list|(
operator|(
name|IEEE80211_CHALLENGE_LEN
operator|<<
literal|8
operator|)
operator||
name|IEEE80211_ELEMID_CHALLENGE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|4
index|]
argument_list|,
name|ni
operator|->
name|ni_challenge
argument_list|,
name|IEEE80211_CHALLENGE_LEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|IEEE80211_CHALLENGE_LEN
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_RESPONSE
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
literal|"[%s] request encrypt frame (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_LINK0
expr_stmt|;
comment|/* WEP-encrypt, please */
block|}
block|}
else|else
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
comment|/* XXX not right for shared key */
if|if
condition|(
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_auth
argument_list|)
expr_stmt|;
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_auth_fail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ieee80211_add_callback
argument_list|(
name|m
argument_list|,
name|ieee80211_tx_mgt_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ic
operator|->
name|ic_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
literal|"[%s] send station deauthenticate (reason %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_deauth
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_SET
argument_list|(
name|ni
argument_list|,
name|tx_deauth_code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ieee80211_node_unauthorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* port closed */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
case|:
comment|/* 		 * asreq frame format 		 *	[2] capability information 		 *	[2] listen interval 		 *	[6*] current AP address (reassoc only) 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 *	[tlv] WME 		 *	[tlv] HT capabilities 		 *	[tlv] Vendor OUI HT capabilities (optional) 		 *	[tlv] Atheros capabilities (if negotiated) 		 *	[tlv] user-specified ie's 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|IEEE80211_ADDR_LEN
operator|+
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|)
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
operator|+
operator|(
name|ic
operator|->
name|ic_opt_ie
operator|!=
name|NULL
condition|?
name|ic
operator|->
name|ic_opt_ie_len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
comment|/* 		 * NB: Some 11a AP's reject the request when 		 *     short premable is set. 		 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
operator|!=
literal|0
argument_list|,
operator|(
literal|"beacon interval is zero!"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|howmany
argument_list|(
name|ic
operator|->
name|ic_lintval
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
argument_list|)
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_wme_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_wme_info
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_HTCOMPAT
condition|)
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_ath
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|==
literal|0
operator|&&
name|ni
operator|->
name|ni_authmode
operator|!=
name|IEEE80211_AUTH_8021X
operator|&&
name|ic
operator|->
name|ic_def_txkey
operator|!=
name|IEEE80211_KEYIX_NONE
condition|?
name|ic
operator|->
name|ic_def_txkey
else|:
literal|0x7fff
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opt_ie
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_opt_ie
argument_list|,
name|ic
operator|->
name|ic_opt_ie_len
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ic
operator|->
name|ic_opt_ie_len
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_add_callback
argument_list|(
name|m
argument_list|,
name|ieee80211_tx_mgt_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|ic
operator|->
name|ic_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_RESP
case|:
comment|/* 		 * asresp frame format 		 *	[2] capability information 		 *	[2] status 		 *	[2] association ID 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 *	[tlv] WME (if enabled and STA enabled) 		 *	[tlv] HT capabilities (standard or vendor OUI) 		 *	[tlv] HT information (standard or vendor OUI) 		 *	[tlv] Atheros capabilities (if enabled and STA enabled) 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* status */
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_assoc
argument_list|)
expr_stmt|;
block|}
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_assoc_fail
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_wme_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
block|{
comment|/* NB: respond according to what we received */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HTCOMPAT
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_ath
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_ath_defkeyix
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DISASSOC
case|:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] send station disassociate (reason %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_disassoc
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_SET
argument_list|(
name|ni
argument_list|,
name|tx_disassoc_code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"[%s] invalid mgmt frame type %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|,
name|is_tx_unknownmgt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|ret
operator|=
name|ieee80211_mgmt_output
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
literal|0
return|;
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|senderr
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_tx_mgt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|!=
name|IEEE80211_S_INIT
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NB: it's safe to specify a timeout as the reason here; 		 *     it'll only be used in the right state. 		 */
name|ieee80211_new_state
argument_list|(
name|ic
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
name|IEEE80211_SCAN_FAIL_TIMEOUT
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_tx_mgt_cb
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
init|=
operator|(
expr|enum
name|ieee80211_state
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Frame transmit completed; arrange timer callback.  If 	 * transmit was successfuly we wait for response.  Otherwise 	 * we arrange an immediate callback instead of doing the 	 * callback directly since we don't know what state the driver 	 * is in (e.g. what locks it is holding).  This work should 	 * not be too time-critical and not happen too often so the 	 * added overhead is acceptable. 	 * 	 * XXX what happens if !acked but response shows up before callback? 	 */
if|if
condition|(
name|ic
operator|->
name|ic_state
operator|==
name|ostate
condition|)
name|callout_reset
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtsend
argument_list|,
name|status
operator|==
literal|0
condition|?
name|IEEE80211_TRANS_WAIT
operator|*
name|hz
else|:
literal|0
argument_list|,
name|ieee80211_tx_mgt_timeout
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a beacon frame and fillin the appropriate bits.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_beacon_alloc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
comment|/* 	 * beacon frame format 	 *	[8] time stamp 	 *	[2] beacon interval 	 *	[2] cabability information 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[3] parameter set (DS) 	 *	[tlv] parameter set (IBSS/TIM) 	 *	[tlv] country code 	 *	[tlv] extended rate phy (ERP) 	 *	[tlv] extended supported rates 	 *	[tlv] WME parameters 	 *	[tlv] WPA/RSN parameters 	 *	[tlv] HT capabilities 	 *	[tlv] HT information 	 *	[tlv] Vendor OUI HT capabilities (optional) 	 *	[tlv] Vendor OUI HT information (optional) 	 * XXX Vendor-specific OIDs (e.g. Atheros) 	 * NB: we allocate the max space required for the TIM bitmap. 	 */
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
name|pktlen
operator|=
literal|8
comment|/* time stamp */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* beacon interval */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* capabilities */
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_esslen
comment|/* ssid */
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
comment|/* supported rates */
operator|+
literal|2
operator|+
literal|1
comment|/* DS parameters */
operator|+
literal|2
operator|+
literal|4
operator|+
name|ic
operator|->
name|ic_tim_len
comment|/* DTIM/IBSSPARMS */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_country_ie
argument_list|)
comment|/* country code */
operator|+
literal|2
operator|+
literal|1
comment|/* ERP */
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
condition|?
comment|/* WME */
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WPA
condition|?
comment|/* WPA 1+2 */
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
else|:
literal|0
operator|)
comment|/* XXX conditional? */
operator|+
literal|4
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
comment|/* HT caps */
operator|+
literal|4
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
comment|/* HT info */
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"%s: cannot get buf; size %u\n"
argument_list|,
name|__func__
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* XXX timestamp is set by hardware/driver */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_caps
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|frm
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_HIDESSID
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
block|}
else|else
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_DSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
block|}
name|bo
operator|->
name|bo_tim
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
name|bo
operator|->
name|bo_tim_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|struct
name|ieee80211_tim_ie
modifier|*
name|tie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|tie
operator|->
name|tim_ie
operator|=
name|IEEE80211_ELEMID_TIM
expr_stmt|;
name|tie
operator|->
name|tim_len
operator|=
literal|4
expr_stmt|;
comment|/* length */
name|tie
operator|->
name|tim_count
operator|=
literal|0
expr_stmt|;
comment|/* DTIM count */
name|tie
operator|->
name|tim_period
operator|=
name|ic
operator|->
name|ic_dtim_period
expr_stmt|;
comment|/* DTIM period */
name|tie
operator|->
name|tim_bitctl
operator|=
literal|0
expr_stmt|;
comment|/* bitmap control */
name|tie
operator|->
name|tim_bitmap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Partial Virtual Bitmap */
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_tim_ie
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_tim_len
operator|=
literal|1
expr_stmt|;
block|}
name|bo
operator|->
name|bo_trailer
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DOTH
condition|)
name|frm
operator|=
name|ieee80211_add_countryie
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|,
name|ic
operator|->
name|ic_countrycode
argument_list|,
name|ic
operator|->
name|ic_location
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|bo
operator|->
name|bo_wme
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_WMEUPDATE
expr_stmt|;
block|}
else|else
name|bo
operator|->
name|bo_wme
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|)
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
name|bo
operator|->
name|bo_erp
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_erp
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
else|else
name|bo
operator|->
name|bo_erp
operator|=
name|NULL
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_htinfo
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_HTCOMPAT
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bo
operator|->
name|bo_htinfo
operator|=
name|NULL
expr_stmt|;
name|bo
operator|->
name|bo_trailer_len
operator|=
name|frm
operator|-
name|bo
operator|->
name|bo_trailer
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no space for 802.11 header?"
operator|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_BEACON
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
literal|0
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Update the dynamic parts of a beacon frame based on the current state.  */
end_comment

begin_function
name|int
name|ieee80211_beacon_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|mcast
parameter_list|)
block|{
name|int
name|len_changed
init|=
literal|0
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|IEEE80211_BEACON_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* XXX faster to recalculate entirely or just changes? */
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
operator|*
name|bo
operator|->
name|bo_caps
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
comment|/* 		 * Check for agressive mode change.  When there is 		 * significant high priority traffic in the BSS 		 * throttle back BE traffic by using conservative 		 * parameters.  Otherwise BE uses agressive params 		 * to optimize performance of legacy/non-QoS traffic. 		 */
if|if
condition|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
condition|)
block|{
if|if
condition|(
name|wme
operator|->
name|wme_hipri_traffic
operator|>
name|wme
operator|->
name|wme_hipri_switch_thresh
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: traffic %u, disable aggressive mode\n"
argument_list|,
name|__func__
argument_list|,
name|wme
operator|->
name|wme_hipri_traffic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator|&=
operator|~
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_hipri_traffic
operator|=
name|wme
operator|->
name|wme_hipri_switch_hysteresis
expr_stmt|;
block|}
else|else
name|wme
operator|->
name|wme_hipri_traffic
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wme
operator|->
name|wme_hipri_traffic
operator|<=
name|wme
operator|->
name|wme_hipri_switch_thresh
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: traffic %u, enable aggressive mode\n"
argument_list|,
name|__func__
argument_list|,
name|wme
operator|->
name|wme_hipri_traffic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator||=
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_hipri_traffic
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|wme
operator|->
name|wme_hipri_traffic
operator|=
name|wme
operator|->
name|wme_hipri_switch_hysteresis
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WMEUPDATE
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_add_wme_param
argument_list|(
name|bo
operator|->
name|bo_wme
argument_list|,
name|wme
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_WMEUPDATE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|ht
init|=
operator|(
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|bo
operator|->
name|bo_htinfo
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
else|else
name|ht
operator|->
name|hi_byte1
operator|&=
operator|~
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* NB: no IBSS support*/
name|struct
name|ieee80211_tim_ie
modifier|*
name|tie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|bo
operator|->
name|bo_tim
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_TIMUPDATE
condition|)
block|{
name|u_int
name|timlen
decl_stmt|,
name|timoff
decl_stmt|,
name|i
decl_stmt|;
comment|/*  			 * ATIM/DTIM needs updating.  If it fits in the 			 * current space allocated then just copy in the 			 * new bits.  Otherwise we need to move any trailing 			 * data to make room.  Note that we know there is 			 * contiguous space because ieee80211_beacon_allocate 			 * insures there is space in the mbuf to write a 			 * maximal-size virtual bitmap (based on ic_max_aid). 			 */
comment|/* 			 * Calculate the bitmap size and offset, copy any 			 * trailer out of the way, and then copy in the 			 * new bitmap and update the information element. 			 * Note that the tim bitmap must contain at least 			 * one byte and any offset must be even. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_ps_pending
operator|!=
literal|0
condition|)
block|{
name|timoff
operator|=
literal|128
expr_stmt|;
comment|/* impossibly large */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_tim_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ic
operator|->
name|ic_tim_bitmap
index|[
name|i
index|]
condition|)
block|{
name|timoff
operator|=
name|i
operator|&
operator|~
literal|1
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|timoff
operator|!=
literal|128
argument_list|,
operator|(
literal|"tim bitmap empty!"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ic
operator|->
name|ic_tim_len
operator|-
literal|1
init|;
name|i
operator|>=
name|timoff
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|ic
operator|->
name|ic_tim_bitmap
index|[
name|i
index|]
condition|)
break|break;
name|timlen
operator|=
literal|1
operator|+
operator|(
name|i
operator|-
name|timoff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|timoff
operator|=
literal|0
expr_stmt|;
name|timlen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|timlen
operator|!=
name|bo
operator|->
name|bo_tim_len
condition|)
block|{
comment|/* copy up/down trailer */
name|int
name|adjust
init|=
name|tie
operator|->
name|tim_bitmap
operator|+
name|timlen
operator|-
name|bo
operator|->
name|bo_trailer
decl_stmt|;
name|ovbcopy
argument_list|(
name|bo
operator|->
name|bo_trailer
argument_list|,
name|bo
operator|->
name|bo_trailer
operator|+
name|adjust
argument_list|,
name|bo
operator|->
name|bo_trailer_len
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_trailer
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_wme
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_erp
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_htinfo
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_tim_len
operator|=
name|timlen
expr_stmt|;
comment|/* update information element */
name|tie
operator|->
name|tim_len
operator|=
literal|3
operator|+
name|timlen
expr_stmt|;
name|tie
operator|->
name|tim_bitctl
operator|=
name|timoff
expr_stmt|;
name|len_changed
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tie
operator|->
name|tim_bitmap
argument_list|,
name|ic
operator|->
name|ic_tim_bitmap
operator|+
name|timoff
argument_list|,
name|bo
operator|->
name|bo_tim_len
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_TIMUPDATE
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"%s: TIM updated, pending %u, off %u, len %u\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_ps_pending
argument_list|,
name|timoff
argument_list|,
name|timlen
argument_list|)
expr_stmt|;
block|}
comment|/* count down DTIM period */
if|if
condition|(
name|tie
operator|->
name|tim_count
operator|==
literal|0
condition|)
name|tie
operator|->
name|tim_count
operator|=
name|tie
operator|->
name|tim_period
operator|-
literal|1
expr_stmt|;
else|else
name|tie
operator|->
name|tim_count
operator|--
expr_stmt|;
comment|/* update state for buffered multicast frames on DTIM */
if|if
condition|(
name|mcast
operator|&&
name|tie
operator|->
name|tim_count
operator|==
literal|0
condition|)
name|tie
operator|->
name|tim_bitctl
operator||=
literal|1
expr_stmt|;
else|else
name|tie
operator|->
name|tim_bitctl
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_ERPUPDATE
condition|)
block|{
comment|/* 			 * ERP element needs updating. 			 */
operator|(
name|void
operator|)
name|ieee80211_add_erp
argument_list|(
name|bo
operator|->
name|bo_erp
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_ERPUPDATE
expr_stmt|;
block|}
block|}
name|IEEE80211_BEACON_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|len_changed
return|;
block|}
end_function

end_unit

