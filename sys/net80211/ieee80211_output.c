begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_comment
comment|/*  * Decide if an outbound management frame should be  * printed when debugging is enabled.  This filters some  * of the less interesting frames that come frequently  * (e.g. beacons).  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|doprint
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
return|return
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Set the direction field and address fields of an outgoing  * non-QoS frame.  Note this should be called early on in  * constructing a frame as it sets i_fc[1]; other bits can  * then be or'd in.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_send_setup
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|u_int8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|u_int8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|u_int8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|WH4
parameter_list|(
name|wh
parameter_list|)
value|((struct ieee80211_frame_addr4 *)wh)
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|da
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* NB: to quiet compiler */
break|break;
block|}
block|}
else|else
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NB: use non-QoS tid */
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
literal|0
index|]
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseqs
index|[
literal|0
index|]
operator|++
expr_stmt|;
undef|#
directive|undef
name|WH4
block|}
end_function

begin_comment
comment|/*  * Send a management frame to the specified node.  The node pointer  * must have a reference as the pointer will be passed to the driver  * and potentially held for a long time.  If the frame is successfully  * dispatched to the driver, then it is responsible for freeing the  * reference (and potentially free'ing up any associated storage).  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_mgmt_output
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|timer
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Yech, hack alert!  We want to pass the node down to the 	 * driver's start routine.  If we don't do so then the start 	 * routine must immediately look it up again and that can 	 * cause a lock order reversal if, for example, this frame 	 * is being sent because the station is being timedout and 	 * the frame being sent is a DEAUTH message.  We could stick 	 * this in an m_tag and tack that on to the mbuf.  However 	 * that's rather expensive to do for every frame so instead 	 * we stuff it in the rcvif field since outbound frames do 	 * not (presently) use this. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
argument_list|,
operator|(
literal|"rcvif not null"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|wh
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|type
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_LINK0
operator|)
operator|!=
literal|0
operator|&&
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_LINK0
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
literal|"[%s] encrypting frame (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_WEP
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
comment|/* avoid printing too many frames */
if|if
condition|(
operator|(
name|ieee80211_msg_debug
argument_list|(
name|ic
argument_list|)
operator|&&
name|doprint
argument_list|(
name|ic
argument_list|,
name|type
argument_list|)
operator|)
operator|||
name|ieee80211_msg_dumppkts
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[%s] send %s on channel %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|timer
condition|)
block|{
comment|/* 		 * Set the mgt frame timeout. 		 */
name|ic
operator|->
name|ic_mgt_timer
operator|=
name|timer
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
block|}
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Send a null data frame to the specified node.  *  * NB: the caller is assumed to have setup a node reference  *     for use; this is necessary to deal with a race condition  *     when probing for inactive stations.  */
end_comment

begin_function
name|int
name|ieee80211_send_nulldata
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|,
name|MT_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX debug msg */
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|wh
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
operator||
name|IEEE80211_FC0_SUBTYPE_NODATA
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
comment|/* NB: power management bit is never sent by an AP */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
operator|)
operator|&&
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_PWR_MGT
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"[%s] send null data frame on channel %u, pwr mgt %s\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PWR_MGT
condition|?
literal|"ena"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* cheat */
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*   * Assign priority to a frame based on any vlan tag assigned  * to the station and/or any Diffserv setting in an IP header.  * Finally, if an ACM policy is setup (in station mode) it's  * applied.  */
end_comment

begin_function
name|int
name|ieee80211_classify
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|int
name|v_wme_ac
decl_stmt|,
name|d_wme_ac
decl_stmt|,
name|ac
decl_stmt|;
ifdef|#
directive|ifdef
name|INET
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
name|WME_AC_BE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*  	 * If node has a vlan tag then all traffic 	 * to it must have a matching tag. 	 */
name|v_wme_ac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_vlan
operator|!=
literal|0
condition|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
init|=
name|VLAN_OUTPUT_TAG
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
name|m
argument_list|)
decl_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_novlantag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|EVL_VLANOFTAG
argument_list|(
name|VLAN_TAG_VALUE
argument_list|(
name|mtag
argument_list|)
argument_list|)
operator|!=
name|EVL_VLANOFTAG
argument_list|(
name|ni
operator|->
name|ni_vlan
argument_list|)
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_vlanmismatch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* map vlan priority to AC */
switch|switch
condition|(
name|EVL_PRIOFTAG
argument_list|(
name|ni
operator|->
name|ni_vlan
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
case|case
literal|2
case|:
name|v_wme_ac
operator|=
name|WME_AC_BK
expr_stmt|;
break|break;
case|case
literal|0
case|:
case|case
literal|3
case|:
name|v_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
break|break;
case|case
literal|4
case|:
case|case
literal|5
case|:
name|v_wme_ac
operator|=
name|WME_AC_VI
expr_stmt|;
break|break;
case|case
literal|6
case|:
case|case
literal|7
case|:
name|v_wme_ac
operator|=
name|WME_AC_VO
expr_stmt|;
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|INET
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|ip
modifier|*
name|ip
init|=
operator|(
expr|struct
name|ip
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|eh
argument_list|)
operator|)
decl_stmt|;
comment|/* 		 * IP frame, map the TOS field. 		 */
switch|switch
condition|(
name|ip
operator|->
name|ip_tos
condition|)
block|{
case|case
literal|0x08
case|:
case|case
literal|0x20
case|:
name|d_wme_ac
operator|=
name|WME_AC_BK
expr_stmt|;
comment|/* background */
break|break;
case|case
literal|0x28
case|:
case|case
literal|0xa0
case|:
name|d_wme_ac
operator|=
name|WME_AC_VI
expr_stmt|;
comment|/* video */
break|break;
case|case
literal|0x30
case|:
comment|/* voice */
case|case
literal|0xe0
case|:
case|case
literal|0x88
case|:
comment|/* XXX UPSD */
case|case
literal|0xb8
case|:
name|d_wme_ac
operator|=
name|WME_AC_VO
expr_stmt|;
break|break;
default|default:
name|d_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* INET */
name|d_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
ifdef|#
directive|ifdef
name|INET
block|}
endif|#
directive|endif
comment|/* 	 * Use highest priority AC. 	 */
if|if
condition|(
name|v_wme_ac
operator|>
name|d_wme_ac
condition|)
name|ac
operator|=
name|v_wme_ac
expr_stmt|;
else|else
name|ac
operator|=
name|d_wme_ac
expr_stmt|;
comment|/* 	 * Apply ACM policy. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
specifier|static
specifier|const
name|int
name|acmap
index|[
literal|4
index|]
init|=
block|{
name|WME_AC_BK
block|,
comment|/* WME_AC_BE */
name|WME_AC_BK
block|,
comment|/* WME_AC_BK */
name|WME_AC_BE
block|,
comment|/* WME_AC_VI */
name|WME_AC_VI
block|,
comment|/* WME_AC_VO */
block|}
decl_stmt|;
while|while
condition|(
name|ac
operator|!=
name|WME_AC_BK
operator|&&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_acm
condition|)
name|ac
operator|=
name|acmap
index|[
name|ac
index|]
expr_stmt|;
block|}
name|done
label|:
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Insure there is sufficient contiguous space to encapsulate the  * 802.11 data frame.  If room isn't already there, arrange for it.  * Drivers and cipher modules assume we have done the necessary work  * and fail rudely if they don't find the space they need.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ieee80211_mbuf_adjust
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|hdrsize
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|TO_BE_RECLAIMED
value|(sizeof(struct ether_header) - sizeof(struct llc))
name|int
name|needed_space
init|=
name|hdrsize
decl_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX belongs in crypto code? */
name|needed_space
operator|+=
name|key
operator|->
name|wk_cipher
operator|->
name|ic_header
expr_stmt|;
comment|/* XXX frags */
comment|/* 		 * When crypto is being done in the host we must insure 		 * the data are writable for the cipher routines; clone 		 * a writable mbuf chain. 		 * XXX handle SWMIC specially 		 */
if|if
condition|(
name|key
operator|->
name|wk_flags
operator|&
operator|(
name|IEEE80211_KEY_SWCRYPT
operator||
name|IEEE80211_KEY_SWMIC
operator|)
condition|)
block|{
name|m
operator|=
name|m_unshare
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: cannot get writable mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
comment|/* XXX new stat */
return|return
name|NULL
return|;
block|}
block|}
block|}
comment|/* 	 * We know we are called just before stripping an Ethernet 	 * header and prepending an LLC header.  This means we know 	 * there will be 	 *	sizeof(struct ether_header) - sizeof(struct llc) 	 * bytes recovered to which we need additional space for the 	 * 802.11 header and any crypto header. 	 */
comment|/* XXX check trailing space and copy instead? */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|needed_space
operator|-
name|TO_BE_RECLAIMED
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: cannot expand storage\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KASSERT
argument_list|(
name|needed_space
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"not enough room, need %u got %zu\n"
operator|,
name|needed_space
operator|,
name|MHLEN
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Setup new mbuf to have leading space to prepend the 		 * 802.11 header and any crypto header bits that are 		 * required (the latter are added when the driver calls 		 * back to ieee80211_crypto_encap to do crypto encapsulation). 		 */
comment|/* NB: must be first 'cuz it clobbers m_data */
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* NB: m_gethdr does not set */
name|n
operator|->
name|m_data
operator|+=
name|needed_space
expr_stmt|;
comment|/* 		 * Pull up Ethernet header to create the expected layout. 		 * We could use m_pullup but that's overkill (i.e. we don't 		 * need the actual data) and it cannot fail so do it inline 		 * for speed. 		 */
comment|/* NB: struct ether_header is known to be contiguous */
name|n
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* 		 * Replace the head of the chain. 		 */
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
return|return
name|m
return|;
undef|#
directive|undef
name|TO_BE_RECLAIMED
block|}
end_function

begin_define
define|#
directive|define
name|KEY_UNDEFINED
parameter_list|(
name|k
parameter_list|)
value|((k).wk_cipher ==&ieee80211_cipher_none)
end_define

begin_comment
comment|/*  * Return the transmit key to use in sending a unicast frame.  * If a unicast key is set we use that.  When no unicast key is set  * we fall back to the default transmit key.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ieee80211_key
operator|*
name|ieee80211_crypto_getucastkey
argument_list|(
argument|struct ieee80211com *ic
argument_list|,
argument|struct ieee80211_node *ni
argument_list|)
block|{
if|if
condition|(
name|KEY_UNDEFINED
argument_list|(
name|ni
operator|->
name|ni_ucastkey
argument_list|)
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_def_txkey
operator|==
name|IEEE80211_KEYIX_NONE
operator|||
name|KEY_UNDEFINED
argument_list|(
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
operator|&
name|ni
operator|->
name|ni_ucastkey
return|;
block|}
end_else

begin_comment
unit|}
comment|/*  * Return the transmit key to use in sending a multicast frame.  * Multicast traffic always uses the group key which is installed as  * the default tx key.  */
end_comment

begin_function
unit|static
name|__inline
name|struct
name|ieee80211_key
modifier|*
name|ieee80211_crypto_getmcastkey
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_def_txkey
operator|==
name|IEEE80211_KEYIX_NONE
operator|||
name|KEY_UNDEFINED
argument_list|(
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|ic
operator|->
name|ic_nw_keys
index|[
name|ic
operator|->
name|ic_def_txkey
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an outbound data frame.  The mbuf chain is updated.  * If an error is encountered NULL is returned.  The caller is required  * to provide a node reference and pullup the ethernet header in the  * first mbuf.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_encap
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|key
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|int
name|hdrsize
decl_stmt|,
name|datalen
decl_stmt|,
name|addqos
decl_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|eh
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Insure space for additional headers.  First identify 	 * transmit key to use in calculating any buffer adjustments 	 * required.  This is also used below to do privacy 	 * encapsulation work.  Then calculate the 802.11 header 	 * size and any padding required by the driver. 	 * 	 * Note key may be NULL if we fall back to the default 	 * transmit key and that is not set.  In that case the 	 * buffer may not be expanded as needed by the cipher 	 * routines, but they will/should discard it. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
operator|||
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
condition|)
name|key
operator|=
name|ieee80211_crypto_getucastkey
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
else|else
name|key
operator|=
name|ieee80211_crypto_getmcastkey
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
operator|&&
name|eh
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] no default transmit key (%s) deftxkey %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_def_txkey
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nodefkey
operator|++
expr_stmt|;
block|}
block|}
else|else
name|key
operator|=
name|NULL
expr_stmt|;
comment|/* XXX 4-address format */
comment|/* 	 * XXX Some ap's don't handle QoS-encapsulated EAPOL 	 * frames so suppress use.  This may be an issue if other 	 * ap's require all data frames to be QoS-encapsulated 	 * once negotiated in which case we'll need to make this 	 * configurable. 	 */
name|addqos
operator|=
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|&&
name|eh
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
expr_stmt|;
if|if
condition|(
name|addqos
condition|)
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe
argument_list|)
expr_stmt|;
else|else
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DATAPAD
condition|)
name|hdrsize
operator|=
name|roundup
argument_list|(
name|hdrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|ic
argument_list|,
name|hdrsize
argument_list|,
name|key
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
goto|goto
name|bad
goto|;
block|}
comment|/* NB: this could be optimized because of ieee80211_mbuf_adjust */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|.
name|ether_type
expr_stmt|;
name|datalen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* NB: w/o 802.11 header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hdrsize
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
comment|/* 		 * NB: always use the bssid from ic_bss as the 		 *     neighbor's may be stale after an ibss merge 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MORE_DATA
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
if|if
condition|(
name|addqos
condition|)
block|{
name|struct
name|ieee80211_qosframe
modifier|*
name|qwh
init|=
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
decl_stmt|;
name|int
name|ac
decl_stmt|,
name|tid
decl_stmt|;
name|ac
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* map from access class/queue to 11e header priorty value */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|=
name|tid
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator||=
literal|1
operator|<<
name|IEEE80211_QOS_ACKPOLICY_S
expr_stmt|;
name|qwh
operator|->
name|i_qos
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|qwh
operator|->
name|i_fc
index|[
literal|0
index|]
operator||=
name|IEEE80211_FC0_SUBTYPE_QOS
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseqs
index|[
literal|0
index|]
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseqs
index|[
literal|0
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * IEEE 802.1X: send EAPOL frames always in the clear. 		 * WPA/WPA2: encrypt EAPOL keys when pairwise keys are set. 		 */
if|if
condition|(
name|eh
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
operator|||
operator|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|?
operator|!
name|KEY_UNDEFINED
argument_list|(
operator|*
name|key
argument_list|)
else|:
operator|!
name|KEY_UNDEFINED
argument_list|(
name|ni
operator|->
name|ni_ucastkey
argument_list|)
operator|)
operator|)
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_WEP
expr_stmt|;
comment|/* XXX do fragmentation */
if|if
condition|(
operator|!
name|ieee80211_crypto_enmic
argument_list|(
name|ic
argument_list|,
name|key
argument_list|,
name|m
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"[%s] enmic failed, discard frame\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_enmicfail
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mcast
argument_list|)
expr_stmt|;
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_ucast
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_ADD
argument_list|(
name|ni
argument_list|,
name|tx_bytes
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
name|m
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Add a supported rates element id to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_rates
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|nrates
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|nrates
return|;
block|}
end_function

begin_comment
comment|/*  * Add an extended supported rates element id to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_xrates
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
comment|/* 	 * Add an extended supported rates element if operating in 11g mode. 	 */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|int
name|nrates
init|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*   * Add an ssid elemet to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_ssid
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ssid
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Add an erp element to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_erp
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|u_int8_t
name|erp
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_ERP
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
name|erp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|!=
literal|0
condition|)
name|erp
operator||=
name|IEEE80211_ERP_NON_ERP_PRESENT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|)
name|erp
operator||=
name|IEEE80211_ERP_USE_PROTECTION
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEBARKER
condition|)
name|erp
operator||=
name|IEEE80211_ERP_LONG_PREAMBLE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|erp
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_setup_wpa_ie
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|u_int8_t
modifier|*
name|ie
parameter_list|)
block|{
define|#
directive|define
name|WPA_OUI_BYTES
value|0x00, 0x50, 0xf2
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
define|#
directive|define
name|ADDSELECTOR
parameter_list|(
name|frm
parameter_list|,
name|sel
parameter_list|)
value|do {		\ 	memcpy(frm, sel, 4);			\ 	frm += 4;				\ } while (0)
specifier|static
specifier|const
name|u_int8_t
name|oui
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_OUI_TYPE
block|}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|cipher_suite
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_WEP40
block|}
block|,
comment|/* NB: 40-bit */
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_TKIP
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* XXX WRAP */
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_CCMP
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* XXX CKIP */
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_NULL
block|}
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|wep104_suite
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_CSE_WEP104
block|}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|key_mgt_unspec
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_ASE_8021X_UNSPEC
block|}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|key_mgt_psk
index|[
literal|4
index|]
init|=
block|{
name|WPA_OUI_BYTES
block|,
name|WPA_ASE_8021X_PSK
block|}
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rsnparms
modifier|*
name|rsn
init|=
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
init|=
name|ie
decl_stmt|;
name|u_int8_t
modifier|*
name|selcnt
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* length filled in below */
name|memcpy
argument_list|(
name|frm
argument_list|,
name|oui
argument_list|,
sizeof|sizeof
argument_list|(
name|oui
argument_list|)
argument_list|)
expr_stmt|;
comment|/* WPA OUI */
name|frm
operator|+=
sizeof|sizeof
argument_list|(
name|oui
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|WPA_VERSION
argument_list|)
expr_stmt|;
comment|/* XXX filter out CKIP */
comment|/* multicast cipher */
if|if
condition|(
name|rsn
operator|->
name|rsn_mcastcipher
operator|==
name|IEEE80211_CIPHER_WEP
operator|&&
name|rsn
operator|->
name|rsn_mcastkeylen
operator|>=
literal|13
condition|)
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|wep104_suite
argument_list|)
expr_stmt|;
else|else
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|rsn
operator|->
name|rsn_mcastcipher
index|]
argument_list|)
expr_stmt|;
comment|/* unicast cipher list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_CCM
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_AES_CCM
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_TKIP
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_TKIP
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* authenticator selector list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_UNSPEC
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_unspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_PSK
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_psk
argument_list|)
expr_stmt|;
block|}
comment|/* optional capabilities */
if|if
condition|(
name|rsn
operator|->
name|rsn_caps
operator|!=
literal|0
operator|&&
name|rsn
operator|->
name|rsn_caps
operator|!=
name|RSN_CAP_PREAUTH
condition|)
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|rsn
operator|->
name|rsn_caps
argument_list|)
expr_stmt|;
comment|/* calculate element length */
name|ie
index|[
literal|1
index|]
operator|=
name|frm
operator|-
name|ie
operator|-
literal|2
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
argument_list|,
operator|(
literal|"WPA IE too big, %u> %zu"
operator|,
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|ADDSELECTOR
undef|#
directive|undef
name|WPA_OUI_BYTES
block|}
end_function

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_setup_rsn_ie
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|u_int8_t
modifier|*
name|ie
parameter_list|)
block|{
define|#
directive|define
name|RSN_OUI_BYTES
value|0x00, 0x0f, 0xac
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
define|#
directive|define
name|ADDSELECTOR
parameter_list|(
name|frm
parameter_list|,
name|sel
parameter_list|)
value|do {		\ 	memcpy(frm, sel, 4);			\ 	frm += 4;				\ } while (0)
specifier|static
specifier|const
name|u_int8_t
name|cipher_suite
index|[]
index|[
literal|4
index|]
init|=
block|{
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_WEP40
block|}
block|,
comment|/* NB: 40-bit */
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_TKIP
block|}
block|,
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_WRAP
block|}
block|,
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_CCMP
block|}
block|,
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|,
literal|0x00
block|}
block|,
comment|/* XXX CKIP */
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_NULL
block|}
block|, 	}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|wep104_suite
index|[
literal|4
index|]
init|=
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_CSE_WEP104
block|}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|key_mgt_unspec
index|[
literal|4
index|]
init|=
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_ASE_8021X_UNSPEC
block|}
decl_stmt|;
specifier|static
specifier|const
name|u_int8_t
name|key_mgt_psk
index|[
literal|4
index|]
init|=
block|{
name|RSN_OUI_BYTES
block|,
name|RSN_ASE_8021X_PSK
block|}
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rsnparms
modifier|*
name|rsn
init|=
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rsn
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
init|=
name|ie
decl_stmt|;
name|u_int8_t
modifier|*
name|selcnt
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RSN
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* length filled in below */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|RSN_VERSION
argument_list|)
expr_stmt|;
comment|/* XXX filter out CKIP */
comment|/* multicast cipher */
if|if
condition|(
name|rsn
operator|->
name|rsn_mcastcipher
operator|==
name|IEEE80211_CIPHER_WEP
operator|&&
name|rsn
operator|->
name|rsn_mcastkeylen
operator|>=
literal|13
condition|)
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|wep104_suite
argument_list|)
expr_stmt|;
else|else
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|rsn
operator|->
name|rsn_mcastcipher
index|]
argument_list|)
expr_stmt|;
comment|/* unicast cipher list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_AES_CCM
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_AES_CCM
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_ucastcipherset
operator|&
operator|(
literal|1
operator|<<
name|IEEE80211_CIPHER_TKIP
operator|)
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|cipher_suite
index|[
name|IEEE80211_CIPHER_TKIP
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* authenticator selector list */
name|selcnt
operator|=
name|frm
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* selector count */
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_UNSPEC
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_unspec
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rsn
operator|->
name|rsn_keymgmtset
operator|&
name|WPA_ASE_8021X_PSK
condition|)
block|{
name|selcnt
index|[
literal|0
index|]
operator|++
expr_stmt|;
name|ADDSELECTOR
argument_list|(
name|frm
argument_list|,
name|key_mgt_psk
argument_list|)
expr_stmt|;
block|}
comment|/* optional capabilities */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|rsn
operator|->
name|rsn_caps
argument_list|)
expr_stmt|;
comment|/* XXX PMKID */
comment|/* calculate element length */
name|ie
index|[
literal|1
index|]
operator|=
name|frm
operator|-
name|ie
operator|-
literal|2
expr_stmt|;
name|KASSERT
argument_list|(
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|<=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
argument_list|,
operator|(
literal|"RSN IE too big, %u> %zu"
operator|,
name|ie
index|[
literal|1
index|]
operator|+
literal|2
operator|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSELECTOR
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|RSN_OUI_BYTES
block|}
end_function

begin_comment
comment|/*  * Add a WPA/RSN element to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_wpa
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
argument_list|,
operator|(
literal|"no WPA/RSN!"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA2
condition|)
name|frm
operator|=
name|ieee80211_setup_rsn_ie
argument_list|(
name|ic
argument_list|,
name|frm
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA1
condition|)
name|frm
operator|=
name|ieee80211_setup_wpa_ie
argument_list|(
name|ic
argument_list|,
name|frm
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WME_OUI_BYTES
value|0x00, 0x50, 0xf2
end_define

begin_comment
comment|/*  * Add a WME information element to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_wme_info
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_wme_info
name|info
init|=
block|{
operator|.
name|wme_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|wme_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|)
operator|-
literal|2
block|,
operator|.
name|wme_oui
operator|=
block|{
name|WME_OUI_BYTES
block|}
block|,
operator|.
name|wme_type
operator|=
name|WME_OUI_TYPE
block|,
operator|.
name|wme_subtype
operator|=
name|WME_INFO_OUI_SUBTYPE
block|,
operator|.
name|wme_version
operator|=
name|WME_VERSION
block|,
operator|.
name|wme_info
operator|=
literal|0
block|, 	}
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a WME parameters element to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_wme_param
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
parameter_list|)
block|{
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
comment|/* NB: this works 'cuz a param has an info at the front */
specifier|static
specifier|const
name|struct
name|ieee80211_wme_info
name|param
init|=
block|{
operator|.
name|wme_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|wme_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
operator|-
literal|2
block|,
operator|.
name|wme_oui
operator|=
block|{
name|WME_OUI_BYTES
block|}
block|,
operator|.
name|wme_type
operator|=
name|WME_OUI_TYPE
block|,
operator|.
name|wme_subtype
operator|=
name|WME_PARAM_OUI_SUBTYPE
block|,
operator|.
name|wme_version
operator|=
name|WME_VERSION
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|,
name|wme_info
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
expr_stmt|;
comment|/* AC info */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* reserved field */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|ac
init|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|SM
argument_list|(
name|i
argument_list|,
name|WME_PARAM_ACI
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_acm
argument_list|,
name|WME_PARAM_ACM
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_aifsn
argument_list|,
name|WME_PARAM_AIFSN
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|SM
argument_list|(
name|ac
operator|->
name|wmep_logcwmax
argument_list|,
name|WME_PARAM_LOGCWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_logcwmin
argument_list|,
name|WME_PARAM_LOGCWMIN
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ac
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
return|return
name|frm
return|;
undef|#
directive|undef
name|SM
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_undef
undef|#
directive|undef
name|WME_OUI_BYTES
end_undef

begin_comment
comment|/*  * Send a probe request frame with the specified ssid  * and any optional information element data.  */
end_comment

begin_function
name|int
name|ieee80211_send_probereq
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|u_int8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|u_int8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|u_int8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ssid
parameter_list|,
name|size_t
name|ssidlen
parameter_list|,
specifier|const
name|void
modifier|*
name|optie
parameter_list|,
name|size_t
name|optielen
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
decl_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * prreq frame format 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[tlv] extended supported rates 	 *	[tlv] user-specified ie's 	 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
operator|(
name|optie
operator|!=
name|NULL
condition|?
name|optielen
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|optie
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|frm
argument_list|,
name|optie
argument_list|,
name|optielen
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|optielen
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
argument_list|,
operator|(
literal|"rcvif not null"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|wh
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
argument_list|,
name|sa
argument_list|,
name|da
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
comment|/* XXX power management? */
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_probereq
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"[%s] send probe req on channel %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|if_start
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate capability information for mgt frames.  */
end_comment

begin_function
specifier|static
name|u_int16_t
name|getcapinfo
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|u_int16_t
name|capinfo
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"station mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
else|else
name|capinfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
return|return
name|capinfo
return|;
block|}
end_function

begin_comment
comment|/*  * Send a management frame.  The node is for the destination (or ic_bss  * when in station mode).  Nodes other than ic_bss have their reference  * count bumped to reflect our use for an indeterminant time.  */
end_comment

begin_function
name|int
name|ieee80211_send_mgmt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
decl_stmt|;
name|u_int16_t
name|capinfo
decl_stmt|;
name|int
name|has_challenge
decl_stmt|,
name|is_shared_key
decl_stmt|,
name|ret
decl_stmt|,
name|timer
decl_stmt|,
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|timer
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
comment|/* 		 * probe response frame format 		 *	[8] time stamp 		 *	[2] beacon interval 		 *	[2] cabability information 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] parameter set (FH/DS) 		 *	[tlv] parameter set (IBSS) 		 *	[tlv] extended rate phy (ERP) 		 *	[tlv] extended supported rates 		 *	[tlv] WPA 		 *	[tlv] WME (optional) 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
literal|8
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|7
comment|/* max(7,3) */
operator|+
literal|6
operator|+
literal|3
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
comment|/* XXX !WPA1+WPA2 fits w/o a cluster */
operator|+
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|?
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
else|:
literal|0
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* timestamp should be filled later */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_phytype
operator|==
name|IEEE80211_T_FH
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_FHPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|5
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_fhdwell
operator|&
literal|0x00ff
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
operator|(
name|ni
operator|->
name|ni_fhdwell
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_FH_CHANSET
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_FH_CHANPAT
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_fhindex
expr_stmt|;
block|}
else|else
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_DSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|)
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|frm
operator|=
name|ieee80211_add_erp
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
name|status
operator|=
name|arg
operator|>>
literal|16
expr_stmt|;
name|arg
operator|&=
literal|0xffff
expr_stmt|;
name|has_challenge
operator|=
operator|(
operator|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_CHALLENGE
operator|||
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_RESPONSE
operator|)
operator|&&
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* 		 * Deduce whether we're doing open authentication or 		 * shared key authentication.  We do the latter if 		 * we're in the middle of a shared key authentication 		 * handshake or if we're initiating an authentication 		 * request and configured to use shared key. 		 */
name|is_shared_key
operator|=
name|has_challenge
operator|||
name|arg
operator|>=
name|IEEE80211_AUTH_SHARED_RESPONSE
operator|||
operator|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_REQUEST
operator|&&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_authmode
operator|==
name|IEEE80211_AUTH_SHARED
operator|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
operator|(
name|has_challenge
operator|&&
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|?
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
name|IEEE80211_CHALLENGE_LEN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|is_shared_key
operator|)
condition|?
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_SHARED
argument_list|)
else|:
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_OPEN
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* sequence number */
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|2
index|]
operator|=
name|htole16
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* status */
if|if
condition|(
name|has_challenge
operator|&&
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|3
index|]
operator|=
name|htole16
argument_list|(
operator|(
name|IEEE80211_CHALLENGE_LEN
operator|<<
literal|8
operator|)
operator||
name|IEEE80211_ELEMID_CHALLENGE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|4
index|]
argument_list|,
name|ni
operator|->
name|ni_challenge
argument_list|,
name|IEEE80211_CHALLENGE_LEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
name|IEEE80211_CHALLENGE_LEN
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_RESPONSE
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
literal|"[%s] request encrypt frame (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_LINK0
expr_stmt|;
comment|/* WEP-encrypt, please */
block|}
block|}
else|else
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
comment|/* XXX not right for shared key */
if|if
condition|(
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_auth
argument_list|)
expr_stmt|;
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_auth_fail
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|timer
operator|=
name|IEEE80211_TRANS_WAIT
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
literal|"[%s] send station deauthenticate (reason %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_deauth
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_SET
argument_list|(
name|ni
argument_list|,
name|tx_deauth_code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ieee80211_node_unauthorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* port closed */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
case|:
comment|/* 		 * asreq frame format 		 *	[2] capability information 		 *	[2] listen interval 		 *	[6*] current AP address (reassoc only) 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 *	[tlv] WME 		 *	[tlv] user-specified ie's 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
name|IEEE80211_ADDR_LEN
operator|+
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|)
operator|+
operator|(
name|ic
operator|->
name|ic_opt_ie
operator|!=
name|NULL
condition|?
name|ic
operator|->
name|ic_opt_ie_len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
comment|/* 		 * NB: Some 11a AP's reject the request when 		 *     short premable is set. 		 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_lintval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_wme_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_wme_info
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opt_ie
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_opt_ie
argument_list|,
name|ic
operator|->
name|ic_opt_ie_len
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ic
operator|->
name|ic_opt_ie_len
expr_stmt|;
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|timer
operator|=
name|IEEE80211_TRANS_WAIT
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_RESP
case|:
comment|/* 		 * asreq frame format 		 *	[2] capability information 		 *	[2] status 		 *	[2] association ID 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 *	[tlv] WME (if enabled and STA enabled) 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* status */
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_assoc
argument_list|)
expr_stmt|;
block|}
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_assoc_fail
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_wme_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DISASSOC
case|:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
literal|"[%s] send station disassociate (reason %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_disassoc
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_SET
argument_list|(
name|ni
argument_list|,
name|tx_disassoc_code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"[%s] invalid mgmt frame type %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|,
name|is_tx_unknownmgt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|ret
operator|=
name|ieee80211_mgmt_output
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|type
argument_list|,
name|timer
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Allocate a beacon frame and fillin the appropriate bits.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_beacon_alloc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
decl_stmt|,
modifier|*
name|efrm
decl_stmt|;
name|u_int16_t
name|capinfo
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
comment|/* 	 * beacon frame format 	 *	[8] time stamp 	 *	[2] beacon interval 	 *	[2] cabability information 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[3] parameter set (DS) 	 *	[tlv] parameter set (IBSS/TIM) 	 *	[tlv] extended rate phy (ERP) 	 *	[tlv] extended supported rates 	 *	[tlv] WME parameters 	 *	[tlv] WPA/RSN parameters 	 * XXX Vendor-specific OIDs (e.g. Atheros) 	 * NB: we allocate the max space required for the TIM bitmap. 	 */
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_rates
expr_stmt|;
name|pktlen
operator|=
literal|8
comment|/* time stamp */
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
comment|/* beacon interval */
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
comment|/* capabilities */
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_esslen
comment|/* ssid */
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
comment|/* supported rates */
operator|+
literal|2
operator|+
literal|1
comment|/* DS parameters */
operator|+
literal|2
operator|+
literal|4
operator|+
name|ic
operator|->
name|ic_tim_len
comment|/* DTIM/IBSSPARMS */
operator|+
literal|2
operator|+
literal|1
comment|/* ERP */
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WME
condition|?
comment|/* WME */
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
else|:
literal|0
operator|)
operator|+
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_WPA
condition|?
comment|/* WPA 1+2 */
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"%s: cannot get buf; size %u\n"
argument_list|,
name|__func__
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* XXX timestamp is set by hardware/driver */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_caps
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_HIDESSID
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
block|}
else|else
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|!=
name|IEEE80211_MODE_FH
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_DSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
block|}
name|bo
operator|->
name|bo_tim
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
name|bo
operator|->
name|bo_tim_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
name|struct
name|ieee80211_tim_ie
modifier|*
name|tie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|tie
operator|->
name|tim_ie
operator|=
name|IEEE80211_ELEMID_TIM
expr_stmt|;
name|tie
operator|->
name|tim_len
operator|=
literal|4
expr_stmt|;
comment|/* length */
name|tie
operator|->
name|tim_count
operator|=
literal|0
expr_stmt|;
comment|/* DTIM count */
name|tie
operator|->
name|tim_period
operator|=
name|ic
operator|->
name|ic_dtim_period
expr_stmt|;
comment|/* DTIM period */
name|tie
operator|->
name|tim_bitctl
operator|=
literal|0
expr_stmt|;
comment|/* bitmap control */
name|tie
operator|->
name|tim_bitmap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Partial Virtual Bitmap */
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_tim_ie
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_tim_len
operator|=
literal|1
expr_stmt|;
block|}
name|bo
operator|->
name|bo_trailer
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|bo
operator|->
name|bo_wme
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_WMEUPDATE
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WPA
condition|)
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_curmode
operator|==
name|IEEE80211_MODE_11G
condition|)
block|{
name|bo
operator|->
name|bo_erp
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_erp
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
name|efrm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_trailer_len
operator|=
name|efrm
operator|-
name|bo
operator|->
name|bo_trailer
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|efrm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no space for 802.11 header?"
operator|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_BEACON
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
literal|0
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Update the dynamic parts of a beacon frame based on the current state.  */
end_comment

begin_function
name|int
name|ieee80211_beacon_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|mcast
parameter_list|)
block|{
name|int
name|len_changed
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|capinfo
decl_stmt|;
name|IEEE80211_BEACON_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* XXX faster to recalculate entirely or just changes? */
name|capinfo
operator|=
name|getcapinfo
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
operator|*
name|bo
operator|->
name|bo_caps
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
comment|/* 		 * Check for agressive mode change.  When there is 		 * significant high priority traffic in the BSS 		 * throttle back BE traffic by using conservative 		 * parameters.  Otherwise BE uses agressive params 		 * to optimize performance of legacy/non-QoS traffic. 		 */
if|if
condition|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
condition|)
block|{
if|if
condition|(
name|wme
operator|->
name|wme_hipri_traffic
operator|>
name|wme
operator|->
name|wme_hipri_switch_thresh
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: traffic %u, disable aggressive mode\n"
argument_list|,
name|__func__
argument_list|,
name|wme
operator|->
name|wme_hipri_traffic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator|&=
operator|~
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_hipri_traffic
operator|=
name|wme
operator|->
name|wme_hipri_switch_hysteresis
expr_stmt|;
block|}
else|else
name|wme
operator|->
name|wme_hipri_traffic
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wme
operator|->
name|wme_hipri_traffic
operator|<=
name|wme
operator|->
name|wme_hipri_switch_thresh
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: traffic %u, enable aggressive mode\n"
argument_list|,
name|__func__
argument_list|,
name|wme
operator|->
name|wme_hipri_traffic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator||=
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_hipri_traffic
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|wme
operator|->
name|wme_hipri_traffic
operator|=
name|wme
operator|->
name|wme_hipri_switch_hysteresis
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WMEUPDATE
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_add_wme_param
argument_list|(
name|bo
operator|->
name|bo_wme
argument_list|,
name|wme
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_WMEUPDATE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* NB: no IBSS support*/
name|struct
name|ieee80211_tim_ie
modifier|*
name|tie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|bo
operator|->
name|bo_tim
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_TIMUPDATE
condition|)
block|{
name|u_int
name|timlen
decl_stmt|,
name|timoff
decl_stmt|,
name|i
decl_stmt|;
comment|/*  			 * ATIM/DTIM needs updating.  If it fits in the 			 * current space allocated then just copy in the 			 * new bits.  Otherwise we need to move any trailing 			 * data to make room.  Note that we know there is 			 * contiguous space because ieee80211_beacon_allocate 			 * insures there is space in the mbuf to write a 			 * maximal-size virtual bitmap (based on ic_max_aid). 			 */
comment|/* 			 * Calculate the bitmap size and offset, copy any 			 * trailer out of the way, and then copy in the 			 * new bitmap and update the information element. 			 * Note that the tim bitmap must contain at least 			 * one byte and any offset must be even. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_ps_pending
operator|!=
literal|0
condition|)
block|{
name|timoff
operator|=
literal|128
expr_stmt|;
comment|/* impossibly large */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_tim_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ic
operator|->
name|ic_tim_bitmap
index|[
name|i
index|]
condition|)
block|{
name|timoff
operator|=
name|i
operator|&
operator|~
literal|1
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|timoff
operator|!=
literal|128
argument_list|,
operator|(
literal|"tim bitmap empty!"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ic
operator|->
name|ic_tim_len
operator|-
literal|1
init|;
name|i
operator|>=
name|timoff
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|ic
operator|->
name|ic_tim_bitmap
index|[
name|i
index|]
condition|)
break|break;
name|timlen
operator|=
literal|1
operator|+
operator|(
name|i
operator|-
name|timoff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|timoff
operator|=
literal|0
expr_stmt|;
name|timlen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|timlen
operator|!=
name|bo
operator|->
name|bo_tim_len
condition|)
block|{
comment|/* copy up/down trailer */
name|int
name|adjust
init|=
name|tie
operator|->
name|tim_bitmap
operator|+
name|timlen
operator|-
name|bo
operator|->
name|bo_trailer
decl_stmt|;
name|ovbcopy
argument_list|(
name|bo
operator|->
name|bo_trailer
argument_list|,
name|bo
operator|->
name|bo_trailer
operator|+
name|adjust
argument_list|,
name|bo
operator|->
name|bo_trailer_len
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_trailer
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_wme
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_erp
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_tim_len
operator|=
name|timlen
expr_stmt|;
comment|/* update information element */
name|tie
operator|->
name|tim_len
operator|=
literal|3
operator|+
name|timlen
expr_stmt|;
name|tie
operator|->
name|tim_bitctl
operator|=
name|timoff
expr_stmt|;
name|len_changed
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tie
operator|->
name|tim_bitmap
argument_list|,
name|ic
operator|->
name|ic_tim_bitmap
operator|+
name|timoff
argument_list|,
name|bo
operator|->
name|bo_tim_len
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|IEEE80211_F_TIMUPDATE
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"%s: TIM updated, pending %u, off %u, len %u\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_ps_pending
argument_list|,
name|timoff
argument_list|,
name|timlen
argument_list|)
expr_stmt|;
block|}
comment|/* count down DTIM period */
if|if
condition|(
name|tie
operator|->
name|tim_count
operator|==
literal|0
condition|)
name|tie
operator|->
name|tim_count
operator|=
name|tie
operator|->
name|tim_period
operator|-
literal|1
expr_stmt|;
else|else
name|tie
operator|->
name|tim_count
operator|--
expr_stmt|;
comment|/* update state for buffered multicast frames on DTIM */
if|if
condition|(
name|mcast
operator|&&
name|tie
operator|->
name|tim_count
operator|==
literal|0
condition|)
name|tie
operator|->
name|tim_bitctl
operator||=
literal|1
expr_stmt|;
else|else
name|tie
operator|->
name|tim_bitctl
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_ERPUPDATE
condition|)
block|{
comment|/* 			 * ERP element needs updating. 			 */
operator|(
name|void
operator|)
name|ieee80211_add_erp
argument_list|(
name|bo
operator|->
name|bo_erp
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_ERPUPDATE
expr_stmt|;
block|}
block|}
name|IEEE80211_BEACON_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|len_changed
return|;
block|}
end_function

begin_comment
comment|/*  * Save an outbound packet for a node in power-save sleep state.  * The new packet is placed on the node's saved queue, and the TIM  * is changed, if necessary.  */
end_comment

begin_function
name|void
name|ieee80211_pwrsave
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|qlen
decl_stmt|,
name|age
decl_stmt|;
name|IEEE80211_NODE_SAVEQ_LOCK
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IF_QFULL
argument_list|(
operator|&
name|ni
operator|->
name|ni_savedq
argument_list|)
condition|)
block|{
name|_IF_DROP
argument_list|(
operator|&
name|ni
operator|->
name|ni_savedq
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_UNLOCK
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"[%s] pwr save q overflow, drops %d (size %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ni
operator|->
name|ni_savedq
operator|.
name|ifq_drops
argument_list|,
name|IEEE80211_PS_MAX_QUEUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_dumppkts
argument_list|(
name|ic
argument_list|)
condition|)
name|ieee80211_dump_pkt
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|m
operator|->
name|m_len
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Tag the frame with it's expiry time and insert 	 * it in the queue.  The aging interval is 4 times 	 * the listen interval specified by the station.  	 * Frames that sit around too long are reclaimed 	 * using this information. 	 */
comment|/* XXX handle overflow? */
name|age
operator|=
operator|(
operator|(
name|ni
operator|->
name|ni_intval
operator|*
name|ic
operator|->
name|ic_bintval
operator|)
operator|<<
literal|2
operator|)
operator|/
literal|1024
expr_stmt|;
comment|/* TU -> secs */
name|_IEEE80211_NODE_SAVEQ_ENQUEUE
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|qlen
argument_list|,
name|age
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_SAVEQ_UNLOCK
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"[%s] save frame with age %d, %u now queued\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|age
argument_list|,
name|qlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlen
operator|==
literal|1
condition|)
name|ic
operator|->
name|ic_set_tim
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

