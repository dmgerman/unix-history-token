begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_vlan_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_wds.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_mesh.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|INET
argument_list|)
operator|||
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<security/mac/mac_framework.h>
end_include

begin_define
define|#
directive|define
name|ETHER_HEADER_COPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|memcpy(dst, src, sizeof(struct ether_header))
end_define

begin_comment
comment|/* unalligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_WRITE_2
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|do {				\ 	((uint8_t *)(p))[0] = (v)& 0xff;		\ 	((uint8_t *)(p))[1] = ((v)>> 8)& 0xff;	\ } while (0)
end_define

begin_define
define|#
directive|define
name|LE_WRITE_4
parameter_list|(
name|p
parameter_list|,
name|v
parameter_list|)
value|do {				\ 	((uint8_t *)(p))[0] = (v)& 0xff;		\ 	((uint8_t *)(p))[1] = ((v)>> 8)& 0xff;	\ 	((uint8_t *)(p))[2] = ((v)>> 16)& 0xff;	\ 	((uint8_t *)(p))[3] = ((v)>> 24)& 0xff;	\ } while (0)
end_define

begin_function_decl
specifier|static
name|int
name|ieee80211_fragment
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|u_int
name|hdrsize
parameter_list|,
name|u_int
name|ciphdrsize
parameter_list|,
name|u_int
name|mtu
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_tx_mgt_cb
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_comment
comment|/*  * Decide if an outbound management frame should be  * printed when debugging is enabled.  This filters some  * of the less interesting frames that come frequently  * (e.g. beacons).  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|doprint
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|subtype
parameter_list|)
block|{
switch|switch
condition|(
name|subtype
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
return|return
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Transmit a frame to the given destination on the given VAP.  *  * It's up to the caller to figure out the details of who this  * is going to and resolving the node.  *  * This routine takes care of queuing it for power save,  * A-MPDU state stuff, fast-frames state stuff, encapsulation  * if required, then passing it up to the driver layer.  *  * This routine (for now) consumes the mbuf and frees the node  * reference; it ideally will return a TX status which reflects  * whether the mbuf was consumed or not, so the caller can  * free the mbuf (if appropriate) and the node reference (again,  * if appropriate.)  */
end_comment

begin_function
name|int
name|ieee80211_vap_pkt_send_dest
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|mcast
decl_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PWR_SAV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Station in power save mode; pass the frame 		 * to the 802.11 layer and continue.  We'll get 		 * the frame back when the time is right. 		 * XXX lose WDS vap linkage? 		 */
if|if
condition|(
name|ieee80211_pwrsave
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 		 * We queued it fine, so tell the upper layer 		 * that we consumed it. 		 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* calculate priority so drivers can find the tx queue */
if|if
condition|(
name|ieee80211_classify
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"classification failure"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_classify
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX better status? */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Stash the node pointer.  Note that we do this after 	 * any call to ieee80211_dwds_mcast because that code 	 * uses any existing value for rcvif to identify the 	 * interface it (might have been) received on. 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|mcast
operator|=
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_MCAST
operator||
name|M_BCAST
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|BPF_MTAP
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 802.3 tx */
comment|/* 	 * Check if A-MPDU tx aggregation is setup or if we 	 * should try to enable it.  The sta must be associated 	 * with HT and A-MPDU enabled for use.  When the policy 	 * routine decides we should enable A-MPDU we issue an 	 * ADDBA request and wait for a reply.  The frame being 	 * encapsulated will go out w/o using A-MPDU, or possibly 	 * it might be collected by the driver and held/retransmit. 	 * The default ic_ampdu_enable routine handles staggering 	 * ADDBA requests in case the receiver NAK's us or we are 	 * otherwise unable to establish a BA stream. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AMPDU_TX
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_AMPDU_TX
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
decl_stmt|;
name|ieee80211_txampdu_count_packet
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
comment|/* 			 * Operational, mark frame for aggregation. 			 * 			 * XXX do tx aggregation here 			 */
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU_MPDU
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_AMPDU_REQUESTED
argument_list|(
name|tap
argument_list|)
operator|&&
name|ic
operator|->
name|ic_ampdu_enable
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
condition|)
block|{
comment|/* 			 * Not negotiated yet, request service. 			 */
name|ieee80211_ampdu_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
comment|/* XXX hold frame for reply? */
block|}
block|}
comment|/* 	 * XXX If we aren't doing AMPDU TX then we /could/ do 	 * fast-frames encapsulation, however right now this 	 * output logic doesn't handle that case. 	 * 	 * So we'll be limited to "fast-frames" xmit for non-11n STA 	 * and "no fast frames" xmit for 11n STAs. 	 * It'd be nice to eventually test fast-frames out by 	 * gracefully falling from failing A-MPDU transmission 	 * (driver says no, fail to negotiate it with peer) to 	 * using fast-frames. 	 * 	 * Note: we can actually put A-MSDU's inside an A-MPDU, 	 * so hopefully we can figure out how to make that particular 	 * combination work right. 	 */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
elseif|else
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_FF
argument_list|)
condition|)
block|{
name|m
operator|=
name|ieee80211_ff_check
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: any ni ref held on stageq */
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_SUPERG */
comment|/* 	 * Grab the TX lock - serialise the TX process from this 	 * point (where TX state is being checked/modified) 	 * through to driver queue. 	 */
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * XXX make the encap and transmit code a separate function 	 * so things like the FF (and later A-MSDU) path can just call 	 * it for flushed frames. 	 */
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_8023ENCAP
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Encapsulate the packet in prep for transmission. 		 */
name|m
operator|=
name|ieee80211_encap
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: stat+msg handled in ieee80211_encap */
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|ieee80211_parent_xmitpkt
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 	 * Unlock at this point - no need to hold it across 	 * ieee80211_free_node() (ie, the comlock) 	 */
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_lastdata
operator|=
name|ticks
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send the given mbuf through the given vap.  *  * This consumes the mbuf regardless of whether the transmit  * was successful or not.  *  * This does none of the initial checks that ieee80211_start()  * does (eg CAC timeout, interface wakeup) - the caller must  * do this first.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_start_pkt
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|IS_DWDS
parameter_list|(
name|vap
parameter_list|)
define|\
value|(vap->iv_opmode == IEEE80211_M_WDS&& \ 	 (vap->iv_flags_ext& IEEE80211_FEXT_WDSLEGACY) == 0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ether_header
modifier|*
name|eh
decl_stmt|;
comment|/* 	 * Cancel any background scan. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
condition|)
name|ieee80211_cancel_anyscan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/*  	 * Find the node for the destination so we can do 	 * things like power save and fast frames aggregation. 	 * 	 * NB: past this point various code assumes the first 	 *     mbuf has the 802.3 header present (and contiguous). 	 */
name|ni
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"discard frame, %s\n"
argument_list|,
literal|"m_pullup failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
comment|/* XXX */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|eh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|ETHER_IS_MULTICAST
argument_list|(
name|eh
operator|->
name|ether_dhost
argument_list|)
condition|)
block|{
if|if
condition|(
name|IS_DWDS
argument_list|(
name|vap
argument_list|)
condition|)
block|{
comment|/* 			 * Only unicast frames from the above go out 			 * DWDS vaps; multicast frames are handled by 			 * dispatching the frame as it comes through 			 * the AP vap (see below). 			 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WDS
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|"mcast"
argument_list|,
literal|"%s"
argument_list|,
literal|"on DWDS"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_dwds_mcast
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX better status? */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
block|{
comment|/* 			 * Spam DWDS vap's w/ multicast traffic. 			 */
comment|/* XXX only if dwds in use? */
name|ieee80211_dwds_mcast
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_MBSS
condition|)
block|{
endif|#
directive|endif
name|ni
operator|=
name|ieee80211_find_txnode
argument_list|(
name|vap
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_find_txnode does stat+msg */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX better status? */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
if|if
condition|(
name|ni
operator|->
name|ni_associd
operator|==
literal|0
operator|&&
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_ASSOCID
operator|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|NULL
argument_list|,
literal|"sta not associated (type 0x%04x)"
argument_list|,
name|htons
argument_list|(
name|eh
operator|->
name|ether_type
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_notassoc
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX better status? */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|eh
operator|->
name|ether_shost
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
condition|)
block|{
comment|/* 			 * Proxy station only if configured. 			 */
if|if
condition|(
operator|!
name|ieee80211_mesh_isproxyena
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
operator||
name|IEEE80211_MSG_MESH
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"proxy not enabled"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_mesh_notproxy
operator|++
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* XXX better status? */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"forward frame from DS SA(%6D), DA(%6D)\n"
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|,
literal|":"
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
name|ieee80211_mesh_proxy_check
argument_list|(
name|vap
argument_list|,
name|eh
operator|->
name|ether_shost
argument_list|)
expr_stmt|;
block|}
name|ni
operator|=
name|ieee80211_mesh_discover
argument_list|(
name|vap
argument_list|,
name|eh
operator|->
name|ether_dhost
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * NB: ieee80211_mesh_discover holds/disposes 			 * frame (e.g. queueing on path discovery). 			 */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* XXX better status? */
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/* 	 * We've resolved the sender, so attempt to transmit it. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_SLEEP
condition|)
block|{
comment|/* 		 * In power save; queue frame and then  wakeup device 		 * for transmit. 		 */
name|ic
operator|->
name|ic_lastdata
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|ieee80211_pwrsave
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_new_state
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_RUN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ieee80211_vap_pkt_send_dest
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|ni
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
undef|#
directive|undef
name|IS_DWDS
block|}
end_function

begin_comment
comment|/*  * Start method for vap's.  All packets from the stack come  * through here.  We handle common processing of the packets  * before dispatching them to the underlying device.  *  * if_transmit() requires that the mbuf be consumed by this call  * regardless of the return condition.  */
end_comment

begin_function
name|int
name|ieee80211_vap_transmit
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
comment|/* 	 * No data frames go out unless we're running. 	 * Note in particular this covers CAC and CSA 	 * states (though maybe we should check muting 	 * for CSA). 	 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_SLEEP
condition|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* re-check under the com lock to avoid races */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|&&
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_SLEEP
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: ignore queue, in %s state\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_drv_flags
operator||=
name|IFF_DRV_OACTIVE
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENETDOWN
operator|)
return|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sanitize mbuf flags for net80211 use.  We cannot 	 * clear M_PWR_SAV or M_MORE_DATA because these may 	 * be set for frames that are re-submitted from the 	 * power save queue. 	 * 	 * NB: This must be done before ieee80211_classify as 	 *     it marks EAPOL in frames with M_EAPOL. 	 */
name|m
operator|->
name|m_flags
operator|&=
operator|~
operator|(
name|M_80211_TX
operator|-
name|M_PWR_SAV
operator|-
name|M_MORE_DATA
operator|)
expr_stmt|;
comment|/* 	 * Bump to the packet transmission path. 	 * The mbuf will be consumed here. 	 */
return|return
operator|(
name|ieee80211_start_pkt
argument_list|(
name|vap
argument_list|,
name|m
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_vap_qflush
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
comment|/* Empty for now */
block|}
end_function

begin_comment
comment|/*  * 802.11 raw output routine.  *  * XXX TODO: this (and other send routines) should correctly  * XXX keep the pwr mgmt bit set if it decides to call into the  * XXX driver to send a frame whilst the state is SLEEP.  *  * Otherwise the peer may decide that we're awake and flood us  * with traffic we are still too asleep to receive!  */
end_comment

begin_function
name|int
name|ieee80211_raw_output
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Set node - the caller has taken a reference, so ensure 	 * that the mbuf has the same node value that 	 * it would if it were going via the normal path. 	 */
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
comment|/* 	 * Attempt to add bpf transmit parameters. 	 * 	 * For now it's ok to fail; the raw_xmit api still takes 	 * them as an option. 	 * 	 * Later on when ic_raw_xmit() has params removed, 	 * they'll have to be added - so fail the transmit if 	 * they can't be. 	 */
if|if
condition|(
name|params
condition|)
operator|(
name|void
operator|)
name|ieee80211_add_xmit_params
argument_list|(
name|m
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|error
operator|=
name|ic
operator|->
name|ic_raw_xmit
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|if_inc_counter
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * 802.11 output routine. This is (currently) used only to  * connect bpf write calls to the 802.11 layer for injecting  * raw 802.11 frames.  */
end_comment

begin_function
name|int
name|ieee80211_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|,
name|struct
name|route
modifier|*
name|ro
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|e
parameter_list|)
value|do { error = (e); goto bad;} while (0)
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|NULL
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_drv_flags
operator|&
name|IFF_DRV_OACTIVE
condition|)
block|{
comment|/* 		 * Short-circuit requests if the vap is marked OACTIVE 		 * as this can happen because a packet came down through 		 * ieee80211_start before the vap entered RUN state in 		 * which case it's ok to just drop the frame.  This 		 * should not be necessary but callers of if_output don't 		 * check OACTIVE. 		 */
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
block|}
name|vap
operator|=
name|ifp
operator|->
name|if_softc
expr_stmt|;
name|ic
operator|=
name|vap
operator|->
name|iv_ic
expr_stmt|;
comment|/* 	 * Hand to the 802.3 code if not tagged as 	 * a raw 802.11 frame. 	 */
if|if
condition|(
name|dst
operator|->
name|sa_family
operator|!=
name|AF_IEEE80211
condition|)
return|return
name|vap
operator|->
name|iv_output
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|,
name|dst
argument_list|,
name|ro
argument_list|)
return|;
ifdef|#
directive|ifdef
name|MAC
name|error
operator|=
name|mac_ifnet_check_transmit
argument_list|(
name|ifp
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|senderr
argument_list|(
name|error
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_MONITOR
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IFNET_IS_UP_RUNNING
argument_list|(
name|ifp
argument_list|)
condition|)
name|senderr
argument_list|(
name|ENETDOWN
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
operator||
name|IEEE80211_MSG_DOTH
argument_list|,
literal|"block %s frame in CAC state\n"
argument_list|,
literal|"raw data"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_SCAN
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX bypass bridge, pfil, carp, etc. */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_ack
argument_list|)
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_VERSION_MASK
operator|)
operator|!=
name|IEEE80211_FC0_VERSION_0
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* locate destination node */
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|ni
operator|=
name|ieee80211_find_txnode
argument_list|(
name|vap
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ni
operator|=
name|ieee80211_find_txnode
argument_list|(
name|vap
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
break|break;
default|default:
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
block|}
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Permit packets w/ bpf params through regardless 		 * (see below about sa_len). 		 */
if|if
condition|(
name|dst
operator|->
name|sa_len
operator|==
literal|0
condition|)
name|senderr
argument_list|(
name|EHOSTUNREACH
argument_list|)
expr_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Sanitize mbuf for net80211 flags leaked from above. 	 * 	 * NB: This must be done before ieee80211_classify as 	 *     it marks EAPOL in frames with M_EAPOL. 	 */
name|m
operator|->
name|m_flags
operator|&=
operator|~
name|M_80211_TX
expr_stmt|;
comment|/* calculate priority so drivers can find the tx queue */
comment|/* XXX assumes an 802.3 frame */
if|if
condition|(
name|ieee80211_classify
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
condition|)
name|senderr
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
comment|/* XXX */
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mcast
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
block|}
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_ucast
argument_list|)
expr_stmt|;
comment|/* NB: ieee80211_encap does not include 802.11 header */
name|IEEE80211_NODE_STAT_ADD
argument_list|(
name|ni
argument_list|,
name|tx_bytes
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * NB: DLT_IEEE802_11_RADIO identifies the parameters are 	 * present by setting the sa_len field of the sockaddr (yes, 	 * this is a hack). 	 * NB: we assume sa_data is suitably aligned to cast. 	 */
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_bpf_params
operator|*
operator|)
operator|(
name|dst
operator|->
name|sa_len
condition|?
name|dst
operator|->
name|sa_data
else|:
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|error
return|;
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Set the direction field and address fields of an outgoing  * frame.  Note this should be called early on in constructing  * a frame as it sets i_fc[1]; other bits can then be or'd in.  */
end_comment

begin_function
name|void
name|ieee80211_send_setup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|tid
parameter_list|,
specifier|const
name|uint8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
define|#
directive|define
name|WH4
parameter_list|(
name|wh
parameter_list|)
value|((struct ieee80211_frame_addr4 *)wh)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|IEEE80211_TX_LOCK_ASSERT
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|type
operator|&
name|IEEE80211_FC0_TYPE_MASK
operator|)
operator|==
name|IEEE80211_FC0_TYPE_DATA
condition|)
block|{
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|da
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_DSTODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|WH4
argument_list|(
name|wh
argument_list|)
operator|->
name|i_addr4
argument_list|,
name|sa
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MBSS
case|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|da
argument_list|)
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
comment|/* XXX next hop */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_DSTODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|WH4
argument_list|(
name|wh
argument_list|)
operator|->
name|i_addr4
argument_list|,
name|sa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
comment|/* NB: to quiet compiler */
break|break;
block|}
block|}
else|else
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|da
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|sa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|sa
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_dur
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
name|tid
operator|!=
name|IEEE80211_NONQOS_TID
operator|&&
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU_MPDU
expr_stmt|;
else|else
block|{
if|if
condition|(
name|IEEE80211_HAS_SEQ
argument_list|(
name|type
operator|&
name|IEEE80211_FC0_TYPE_MASK
argument_list|,
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
argument_list|)
condition|)
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|++
expr_stmt|;
else|else
name|seqno
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|M_SEQNO_SET
argument_list|(
name|m
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
undef|#
directive|undef
name|WH4
block|}
end_function

begin_comment
comment|/*  * Send a management frame to the specified node.  The node pointer  * must have a reference as the pointer will be passed to the driver  * and potentially held for a long time.  If the frame is successfully  * dispatched to the driver, then it is responsible for freeing the  * reference (and potentially free'ing up any associated storage);  * otherwise deal with reclaiming any reference (on error).  */
end_comment

begin_function
name|int
name|ieee80211_mgmt_output
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|ieee80211_bpf_params
modifier|*
name|params
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
operator||
name|IEEE80211_MSG_DOTH
argument_list|,
name|ni
argument_list|,
literal|"block %s frame in CAC state"
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|type
argument_list|,
name|IEEE80211_NONQOS_TID
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|->
name|ibp_flags
operator|&
name|IEEE80211_BPF_CRYPTO
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|,
literal|"encrypting frame (%s)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_PROTECTED
expr_stmt|;
block|}
name|m
operator|->
name|m_flags
operator||=
name|M_ENCAP
expr_stmt|;
comment|/* mark encapsulated */
name|KASSERT
argument_list|(
name|type
operator|!=
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
argument_list|,
operator|(
literal|"probe response?"
operator|)
argument_list|)
expr_stmt|;
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|params
operator|->
name|ibp_pri
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
comment|/* avoid printing too many frames */
if|if
condition|(
operator|(
name|ieee80211_msg_debug
argument_list|(
name|vap
argument_list|)
operator|&&
name|doprint
argument_list|(
name|vap
argument_list|,
name|type
argument_list|)
operator|)
operator|||
name|ieee80211_msg_dumppkts
argument_list|(
name|vap
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"[%s] send %s on channel %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a null data frame to the specified node.  If the station  * is setup for QoS then a QoS Null Data frame is constructed.  * If this is a WDS station then a 4-address frame is constructed.  *  * NB: the caller is assumed to have setup a node reference  *     for use; this is necessary to deal with a race condition  *     when probing for inactive stations.  Like ieee80211_mgmt_output  *     we must cleanup any node reference on error;  however we  *     can safely just unref it as we know it will never be the  *     last reference to the node.  */
end_comment

begin_function
name|int
name|ieee80211_send_nulldata
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
operator||
name|IEEE80211_MSG_DOTH
argument_list|,
name|ni
argument_list|,
literal|"block %s frame in CAC state"
argument_list|,
literal|"null data"
argument_list|)
expr_stmt|;
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
operator|(
name|IEEE80211_NODE_QOS
operator||
name|IEEE80211_NODE_HT
operator|)
condition|)
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe
argument_list|)
expr_stmt|;
else|else
name|hdrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
comment|/* NB: only WDS vap's get 4-address frames */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
condition|)
name|hdrlen
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DATAPAD
condition|)
name|hdrlen
operator|=
name|roundup
argument_list|(
name|hdrlen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
name|hdrlen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX debug msg */
name|ieee80211_unref_node
argument_list|(
operator|&
name|ni
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|KASSERT
argument_list|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
name|hdrlen
argument_list|,
operator|(
literal|"leading space %zd"
operator|,
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: cannot happen */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: a little lie */
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|)
block|{
specifier|const
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|WME_AC_BE
argument_list|)
decl_stmt|;
name|uint8_t
modifier|*
name|qos
decl_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
operator||
name|IEEE80211_FC0_SUBTYPE_QOS_NULL
argument_list|,
name|tid
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
condition|)
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
else|else
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
name|qos
index|[
literal|0
index|]
operator|=
name|tid
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|WME_AC_BE
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|qos
index|[
literal|0
index|]
operator||=
name|IEEE80211_QOS_ACKPOLICY_NOACK
expr_stmt|;
name|qos
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ieee80211_send_setup
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_TYPE_DATA
operator||
name|IEEE80211_FC0_SUBTYPE_NODATA
argument_list|,
name|IEEE80211_NONQOS_TID
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_WDS
condition|)
block|{
comment|/* NB: power management bit is never sent by an AP */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_PWR_MGT
operator|)
operator|&&
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_PWR_MGT
expr_stmt|;
block|}
name|m
operator|->
name|m_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|hdrlen
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_ENCAP
expr_stmt|;
comment|/* mark encapsulated */
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|WME_AC_BE
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
name|ni
argument_list|,
literal|"send %snull data frame on channel %u, pwr mgt %s"
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|?
literal|"QoS "
else|:
literal|""
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_PWR_MGT
condition|?
literal|"ena"
else|:
literal|"dis"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * Assign priority to a frame based on any vlan tag assigned  * to the station and/or any Diffserv setting in an IP header.  * Finally, if an ACM policy is setup (in station mode) it's  * applied.  */
end_comment

begin_function
name|int
name|ieee80211_classify
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
decl_stmt|;
name|int
name|v_wme_ac
decl_stmt|,
name|d_wme_ac
decl_stmt|,
name|ac
decl_stmt|;
comment|/* 	 * Always promote PAE/EAPOL frames to high priority. 	 */
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_PAE
argument_list|)
condition|)
block|{
comment|/* NB: mark so others don't need to check header */
name|m
operator|->
name|m_flags
operator||=
name|M_EAPOL
expr_stmt|;
name|ac
operator|=
name|WME_AC_VO
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * Non-qos traffic goes to BE. 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
operator|)
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
name|WME_AC_BE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/*  	 * If node has a vlan tag then all traffic 	 * to it must have a matching tag. 	 */
name|v_wme_ac
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_vlan
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_VLANTAG
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_novlantag
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|EVL_VLANOFTAG
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|ether_vtag
argument_list|)
operator|!=
name|EVL_VLANOFTAG
argument_list|(
name|ni
operator|->
name|ni_vlan
argument_list|)
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_vlanmismatch
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* map vlan priority to AC */
name|v_wme_ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|EVL_PRIOFTAG
argument_list|(
name|ni
operator|->
name|ni_vlan
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* XXX m_copydata may be too slow for fast path */
ifdef|#
directive|ifdef
name|INET
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IP
argument_list|)
condition|)
block|{
name|uint8_t
name|tos
decl_stmt|;
comment|/* 		 * IP frame, map the DSCP bits from the TOS field. 		 */
comment|/* NB: ip header may not be in first mbuf */
name|m_copydata
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip
argument_list|,
name|ip_tos
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|tos
argument_list|)
argument_list|,
operator|&
name|tos
argument_list|)
expr_stmt|;
name|tos
operator|>>=
literal|5
expr_stmt|;
comment|/* NB: ECN + low 3 bits of DSCP */
name|d_wme_ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* INET */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|eh
operator|->
name|ether_type
operator|==
name|htons
argument_list|(
name|ETHERTYPE_IPV6
argument_list|)
condition|)
block|{
name|uint32_t
name|flow
decl_stmt|;
name|uint8_t
name|tos
decl_stmt|;
comment|/* 		 * IPv6 frame, map the DSCP bits from the traffic class field. 		 */
name|m_copydata
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|+
name|offsetof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|,
name|ip6_flow
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|flow
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|flow
argument_list|)
expr_stmt|;
name|tos
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|ntohl
argument_list|(
name|flow
argument_list|)
operator|>>
literal|20
argument_list|)
expr_stmt|;
name|tos
operator|>>=
literal|5
expr_stmt|;
comment|/* NB: ECN + low 3 bits of DSCP */
name|d_wme_ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* INET6 */
name|d_wme_ac
operator|=
name|WME_AC_BE
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET
block|}
endif|#
directive|endif
comment|/* 	 * Use highest priority AC. 	 */
if|if
condition|(
name|v_wme_ac
operator|>
name|d_wme_ac
condition|)
name|ac
operator|=
name|v_wme_ac
expr_stmt|;
else|else
name|ac
operator|=
name|d_wme_ac
expr_stmt|;
comment|/* 	 * Apply ACM policy. 	 */
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
specifier|static
specifier|const
name|int
name|acmap
index|[
literal|4
index|]
init|=
block|{
name|WME_AC_BK
block|,
comment|/* WME_AC_BE */
name|WME_AC_BK
block|,
comment|/* WME_AC_BK */
name|WME_AC_BE
block|,
comment|/* WME_AC_VI */
name|WME_AC_VI
block|,
comment|/* WME_AC_VO */
block|}
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
while|while
condition|(
name|ac
operator|!=
name|WME_AC_BK
operator|&&
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeBssChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_acm
condition|)
name|ac
operator|=
name|acmap
index|[
name|ac
index|]
expr_stmt|;
block|}
name|done
label|:
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|ac
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Insure there is sufficient contiguous space to encapsulate the  * 802.11 data frame.  If room isn't already there, arrange for it.  * Drivers and cipher modules assume we have done the necessary work  * and fail rudely if they don't find the space they need.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_mbuf_adjust
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|hdrsize
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|TO_BE_RECLAIMED
value|(sizeof(struct ether_header) - sizeof(struct llc))
name|int
name|needed_space
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_headroom
operator|+
name|hdrsize
decl_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX belongs in crypto code? */
name|needed_space
operator|+=
name|key
operator|->
name|wk_cipher
operator|->
name|ic_header
expr_stmt|;
comment|/* XXX frags */
comment|/* 		 * When crypto is being done in the host we must insure 		 * the data are writable for the cipher routines; clone 		 * a writable mbuf chain. 		 * XXX handle SWMIC specially 		 */
if|if
condition|(
name|key
operator|->
name|wk_flags
operator|&
operator|(
name|IEEE80211_KEY_SWENCRYPT
operator||
name|IEEE80211_KEY_SWENMIC
operator|)
condition|)
block|{
name|m
operator|=
name|m_unshare
argument_list|(
name|m
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: cannot get writable mbuf\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
comment|/* XXX new stat */
return|return
name|NULL
return|;
block|}
block|}
block|}
comment|/* 	 * We know we are called just before stripping an Ethernet 	 * header and prepending an LLC header.  This means we know 	 * there will be 	 *	sizeof(struct ether_header) - sizeof(struct llc) 	 * bytes recovered to which we need additional space for the 	 * 802.11 header and any crypto header. 	 */
comment|/* XXX check trailing space and copy instead? */
if|if
condition|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|needed_space
operator|-
name|TO_BE_RECLAIMED
condition|)
block|{
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|m
operator|->
name|m_type
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
literal|"%s: cannot expand storage\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|KASSERT
argument_list|(
name|needed_space
operator|<=
name|MHLEN
argument_list|,
operator|(
literal|"not enough room, need %u got %d\n"
operator|,
name|needed_space
operator|,
name|MHLEN
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Setup new mbuf to have leading space to prepend the 		 * 802.11 header and any crypto header bits that are 		 * required (the latter are added when the driver calls 		 * back to ieee80211_crypto_encap to do crypto encapsulation). 		 */
comment|/* NB: must be first 'cuz it clobbers m_data */
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
literal|0
expr_stmt|;
comment|/* NB: m_gethdr does not set */
name|n
operator|->
name|m_data
operator|+=
name|needed_space
expr_stmt|;
comment|/* 		 * Pull up Ethernet header to create the expected layout. 		 * We could use m_pullup but that's overkill (i.e. we don't 		 * need the actual data) and it cannot fail so do it inline 		 * for speed. 		 */
comment|/* NB: struct ether_header is known to be contiguous */
name|n
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|-=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
expr_stmt|;
comment|/* 		 * Replace the head of the chain. 		 */
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
return|return
name|m
return|;
undef|#
directive|undef
name|TO_BE_RECLAIMED
block|}
end_function

begin_comment
comment|/*  * Return the transmit key to use in sending a unicast frame.  * If a unicast key is set we use that.  When no unicast key is set  * we fall back to the default transmit key.  */
end_comment

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|ieee80211_key
operator|*
name|ieee80211_crypto_getucastkey
argument_list|(
argument|struct ieee80211vap *vap
argument_list|,
argument|struct ieee80211_node *ni
argument_list|)
block|{
if|if
condition|(
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_def_txkey
operator|==
name|IEEE80211_KEYIX_NONE
operator|||
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
return|return
operator|&
name|ni
operator|->
name|ni_ucastkey
return|;
block|}
end_else

begin_comment
unit|}
comment|/*  * Return the transmit key to use in sending a multicast frame.  * Multicast traffic always uses the group key which is installed as  * the default tx key.  */
end_comment

begin_function
unit|static
name|__inline
name|struct
name|ieee80211_key
modifier|*
name|ieee80211_crypto_getmcastkey
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_def_txkey
operator|==
name|IEEE80211_KEYIX_NONE
operator|||
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
argument_list|)
condition|)
return|return
name|NULL
return|;
return|return
operator|&
name|vap
operator|->
name|iv_nw_keys
index|[
name|vap
operator|->
name|iv_def_txkey
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an outbound data frame.  The mbuf chain is updated.  * If an error is encountered NULL is returned.  The caller is required  * to provide a node reference and pullup the ethernet header in the  * first mbuf.  *  * NB: Packet is assumed to be processed by ieee80211_classify which  *     marked EAPOL frames w/ M_EAPOL.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_encap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|WH4
parameter_list|(
name|wh
parameter_list|)
value|((struct ieee80211_frame_addr4 *)(wh))
define|#
directive|define
name|MC01
parameter_list|(
name|mc
parameter_list|)
value|((struct ieee80211_meshcntl_ae01 *)mc)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|ieee80211_meshcntl_ae10
modifier|*
name|mc
decl_stmt|;
name|struct
name|ieee80211_mesh_route
modifier|*
name|rt
init|=
name|NULL
decl_stmt|;
name|int
name|dir
init|=
operator|-
literal|1
decl_stmt|;
endif|#
directive|endif
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_key
modifier|*
name|key
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|int
name|hdrsize
decl_stmt|,
name|hdrspace
decl_stmt|,
name|datalen
decl_stmt|,
name|addqos
decl_stmt|,
name|txfrag
decl_stmt|,
name|is4addr
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|int
name|meshhdrsize
decl_stmt|,
name|meshae
decl_stmt|;
name|uint8_t
modifier|*
name|qos
decl_stmt|;
name|IEEE80211_TX_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Copy existing Ethernet header to a safe place.  The 	 * rest of the code assumes it's ok to strip it when 	 * reorganizing state for the final encapsulation. 	 */
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|ETHER_HEADER_COPY
argument_list|(
operator|&
name|eh
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Insure space for additional headers.  First identify 	 * transmit key to use in calculating any buffer adjustments 	 * required.  This is also used below to do privacy 	 * encapsulation work.  Then calculate the 802.11 header 	 * size and any padding required by the driver. 	 * 	 * Note key may be NULL if we fall back to the default 	 * transmit key and that is not set.  In that case the 	 * buffer may not be expanded as needed by the cipher 	 * routines, but they will/should discard it. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|||
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
operator|||
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_WDSLEGACY
operator|)
operator|)
condition|)
name|key
operator|=
name|ieee80211_crypto_getucastkey
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
else|else
name|key
operator|=
name|ieee80211_crypto_getmcastkey
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|,
literal|"no default transmit key (%s) deftxkey %u"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_def_txkey
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nodefkey
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
else|else
name|key
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * XXX Some ap's don't handle QoS-encapsulated EAPOL 	 * frames so suppress use.  This may be an issue if other 	 * ap's require all data frames to be QoS-encapsulated 	 * once negotiated in which case we'll need to make this 	 * configurable. 	 * NB: mesh data frames are QoS. 	 */
name|addqos
operator|=
operator|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
operator|(
name|IEEE80211_NODE_QOS
operator||
name|IEEE80211_NODE_HT
operator|)
operator|)
operator|||
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
operator|)
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|addqos
condition|)
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_qosframe
argument_list|)
expr_stmt|;
else|else
name|hdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* 		 * Mesh data frames are encapsulated according to the 		 * rules of Section 11B.8.5 (p.139 of D3.0 spec). 		 * o Group Addressed data (aka multicast) originating 		 *   at the local sta are sent w/ 3-address format and 		 *   address extension mode 00 		 * o Individually Addressed data (aka unicast) originating 		 *   at the local sta are sent w/ 4-address format and 		 *   address extension mode 00 		 * o Group Addressed data forwarded from a non-mesh sta are 		 *   sent w/ 3-address format and address extension mode 01 		 * o Individually Address data from another sta are sent 		 *   w/ 4-address format and address extension mode 10 		 */
name|is4addr
operator|=
literal|0
expr_stmt|;
comment|/* NB: don't use, disable */
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
condition|)
block|{
name|rt
operator|=
name|ieee80211_mesh_rt_find
argument_list|(
name|vap
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"route is NULL"
operator|)
argument_list|)
expr_stmt|;
name|dir
operator|=
name|IEEE80211_FC1_DIR_DSTODS
expr_stmt|;
name|hdrsize
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
if|if
condition|(
name|rt
operator|->
name|rt_flags
operator|&
name|IEEE80211_MESHRT_FLAGS_PROXY
condition|)
block|{
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|rt
operator|->
name|rt_mesh_gate
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_MESH
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|,
literal|"%s"
argument_list|,
literal|"trying to send to ourself"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|meshae
operator|=
name|IEEE80211_MESH_AE_10
expr_stmt|;
name|meshhdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl_ae10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|meshae
operator|=
name|IEEE80211_MESH_AE_00
expr_stmt|;
name|meshhdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|dir
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|eh
operator|.
name|ether_shost
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
condition|)
block|{
comment|/* proxy group */
name|meshae
operator|=
name|IEEE80211_MESH_AE_01
expr_stmt|;
name|meshhdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl_ae01
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* group */
name|meshae
operator|=
name|IEEE80211_MESH_AE_00
expr_stmt|;
name|meshhdrsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshcntl
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* 		 * 4-address frames need to be generated for: 		 * o packets sent through a WDS vap (IEEE80211_M_WDS) 		 * o packets sent through a vap marked for relaying 		 *   (e.g. a station operating with dynamic WDS) 		 */
name|is4addr
operator|=
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_WDS
operator|||
operator|(
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_4ADDR
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|eh
operator|.
name|ether_shost
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is4addr
condition|)
name|hdrsize
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
name|meshhdrsize
operator|=
name|meshae
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
block|}
endif|#
directive|endif
comment|/* 	 * Honor driver DATAPAD requirement. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DATAPAD
condition|)
name|hdrspace
operator|=
name|roundup
argument_list|(
name|hdrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hdrspace
operator|=
name|hdrsize
expr_stmt|;
if|if
condition|(
name|__predict_true
argument_list|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_FF
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* 		 * Normal frame. 		 */
name|m
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|vap
argument_list|,
name|hdrspace
operator|+
name|meshhdrsize
argument_list|,
name|key
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
goto|goto
name|bad
goto|;
block|}
comment|/* NB: this could be optimized 'cuz of ieee80211_mbuf_adjust */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|.
name|ether_type
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
comment|/* 		 * Aggregated frame. 		 */
name|m
operator|=
name|ieee80211_ff_encap
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|hdrspace
operator|+
name|meshhdrsize
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
endif|#
directive|endif
goto|goto
name|bad
goto|;
block|}
name|datalen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* NB: w/o 802.11 header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|hdrspace
operator|+
name|meshhdrsize
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
name|qos
operator|=
name|NULL
expr_stmt|;
comment|/* NB: quiet compiler */
if|if
condition|(
name|is4addr
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_DSTODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|WH4
argument_list|(
name|wh
argument_list|)
operator|->
name|i_addr4
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
block|}
else|else
switch|switch
condition|(
name|vap
operator|->
name|iv_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
comment|/* 		 * NB: always use the bssid from iv_bss as the 		 *     neighbor's may be stale after an ibss merge 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
case|case
name|IEEE80211_M_MBSS
case|:
comment|/* NB: offset by hdrspace to deal with DATAPAD */
name|mc
operator|=
operator|(
expr|struct
name|ieee80211_meshcntl_ae10
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrspace
operator|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|dir
expr_stmt|;
switch|switch
condition|(
name|meshae
condition|)
block|{
case|case
name|IEEE80211_MESH_AE_00
case|:
comment|/* no proxy */
name|mc
operator|->
name|mc_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|IEEE80211_FC1_DIR_DSTODS
condition|)
block|{
comment|/* ucast */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|WH4
argument_list|(
name|wh
argument_list|)
operator|->
name|i_addr4
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dir
operator|==
name|IEEE80211_FC1_DIR_FROMDS
condition|)
block|{
comment|/* mcast */
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
block|}
break|break;
case|case
name|IEEE80211_MESH_AE_01
case|:
comment|/* mcast, proxy */
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_flags
operator|=
literal|1
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|MC01
argument_list|(
name|mc
argument_list|)
operator|->
name|mc_addr4
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
break|break;
case|case
name|IEEE80211_MESH_AE_10
case|:
comment|/* ucast, proxy */
name|KASSERT
argument_list|(
name|rt
operator|!=
name|NULL
argument_list|,
operator|(
literal|"route is NULL"
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|rt
operator|->
name|rt_nexthop
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|rt
operator|->
name|rt_mesh_gate
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|WH4
argument_list|(
name|wh
argument_list|)
operator|->
name|i_addr4
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_flags
operator|=
name|IEEE80211_MESH_AE_10
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|mc
operator|->
name|mc_addr5
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|mc
operator|->
name|mc_addr6
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
break|break;
default|default:
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"meshae %d"
operator|,
name|meshae
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|mc
operator|->
name|mc_ttl
operator|=
name|ms
operator|->
name|ms_ttl
expr_stmt|;
name|ms
operator|->
name|ms_seq
operator|++
expr_stmt|;
name|LE_WRITE_4
argument_list|(
name|mc
operator|->
name|mc_seq
argument_list|,
name|ms
operator|->
name|ms_seq
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|IEEE80211_M_WDS
case|:
comment|/* NB: is4addr should always be true */
default|default:
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MORE_DATA
condition|)
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_DATA
expr_stmt|;
if|if
condition|(
name|addqos
condition|)
block|{
name|int
name|ac
decl_stmt|,
name|tid
decl_stmt|;
if|if
condition|(
name|is4addr
condition|)
block|{
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
comment|/* NB: mesh case handled earlier */
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_MBSS
condition|)
name|qos
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
expr_stmt|;
name|ac
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* map from access class/queue to 11e header priorty value */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|ac
argument_list|)
expr_stmt|;
name|qos
index|[
literal|0
index|]
operator|=
name|tid
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_wme
operator|.
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_noackPolicy
condition|)
name|qos
index|[
literal|0
index|]
operator||=
name|IEEE80211_QOS_ACKPOLICY_NOACK
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|qos
index|[
literal|1
index|]
operator|=
name|IEEE80211_QOS_MC
expr_stmt|;
else|else
endif|#
directive|endif
name|qos
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator||=
name|IEEE80211_FC0_SUBTYPE_QOS
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_AMPDU_MPDU
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * NB: don't assign a sequence # to potential 			 * aggregates; we expect this happens at the 			 * point the frame comes off any aggregation q 			 * as otherwise we may introduce holes in the 			 * BA sequence space and/or make window accouting 			 * more difficult. 			 * 			 * XXX may want to control this with a driver 			 * capability; this may also change when we pull 			 * aggregation up into net80211 			 */
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
operator|++
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|M_SEQNO_SET
argument_list|(
name|m
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|++
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|M_SEQNO_SET
argument_list|(
name|m
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
block|}
comment|/* check if xmit fragmentation is required */
name|txfrag
operator|=
operator|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|vap
operator|->
name|iv_fragthreshold
operator|&&
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TXFRAG
operator|)
operator|&&
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_FF
operator||
name|M_AMPDU_MPDU
operator|)
operator|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * IEEE 802.1X: send EAPOL frames always in the clear. 		 * WPA/WPA2: encrypt EAPOL keys when pairwise keys are set. 		 */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_EAPOL
operator|)
operator|==
literal|0
operator|||
operator|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|?
operator|!
name|IEEE80211_KEY_UNDEFINED
argument_list|(
name|key
argument_list|)
else|:
operator|!
name|IEEE80211_KEY_UNDEFINED
argument_list|(
operator|&
name|ni
operator|->
name|ni_ucastkey
argument_list|)
operator|)
operator|)
condition|)
block|{
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_PROTECTED
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_crypto_enmic
argument_list|(
name|vap
argument_list|,
name|key
argument_list|,
name|m
argument_list|,
name|txfrag
argument_list|)
condition|)
block|{
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|,
literal|"%s"
argument_list|,
literal|"enmic failed, discard frame"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_crypto_enmicfail
operator|++
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
block|}
block|}
if|if
condition|(
name|txfrag
operator|&&
operator|!
name|ieee80211_fragment
argument_list|(
name|vap
argument_list|,
name|m
argument_list|,
name|hdrsize
argument_list|,
name|key
operator|!=
name|NULL
condition|?
name|key
operator|->
name|wk_cipher
operator|->
name|ic_header
else|:
literal|0
argument_list|,
name|vap
operator|->
name|iv_fragthreshold
argument_list|)
condition|)
goto|goto
name|bad
goto|;
name|m
operator|->
name|m_flags
operator||=
name|M_ENCAP
expr_stmt|;
comment|/* mark encapsulated */
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|)
condition|)
block|{
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mcast
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_MCAST
expr_stmt|;
block|}
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_ucast
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_ADD
argument_list|(
name|ni
argument_list|,
name|tx_bytes
argument_list|,
name|datalen
argument_list|)
expr_stmt|;
return|return
name|m
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
undef|#
directive|undef
name|WH4
undef|#
directive|undef
name|MC01
block|}
end_function

begin_function
name|void
name|ieee80211_free_mbuf
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return;
do|do
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|m
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Fragment the frame according to the specified mtu.  * The size of the 802.11 header (w/o padding) is provided  * so we don't need to recalculate it.  We create a new  * mbuf for each fragment and chain it through m_nextpkt;  * we might be able to optimize this by reusing the original  * packet's mbufs but that is significantly more complicated.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_fragment
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
name|hdrsize
parameter_list|,
name|u_int
name|ciphdrsize
parameter_list|,
name|u_int
name|mtu
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|,
modifier|*
name|whf
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|u_int
name|totalhdrsize
decl_stmt|,
name|fragno
decl_stmt|,
name|fragsize
decl_stmt|,
name|off
decl_stmt|,
name|remainder
decl_stmt|,
name|payload
decl_stmt|;
name|u_int
name|hdrspace
decl_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_nextpkt
operator|==
name|NULL
argument_list|,
operator|(
literal|"mbuf already chained?"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|>
name|mtu
argument_list|,
operator|(
literal|"pktlen %u mtu %u"
operator|,
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|,
name|mtu
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Honor driver DATAPAD requirement. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DATAPAD
condition|)
name|hdrspace
operator|=
name|roundup
argument_list|(
name|hdrsize
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|hdrspace
operator|=
name|hdrsize
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: mark the first frag; it will be propagated below */
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator||=
name|IEEE80211_FC1_MORE_FRAG
expr_stmt|;
name|totalhdrsize
operator|=
name|hdrspace
operator|+
name|ciphdrsize
expr_stmt|;
name|fragno
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|mtu
operator|-
name|ciphdrsize
expr_stmt|;
name|remainder
operator|=
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|off
expr_stmt|;
name|prev
operator|=
name|m0
expr_stmt|;
do|do
block|{
name|fragsize
operator|=
name|totalhdrsize
operator|+
name|remainder
expr_stmt|;
if|if
condition|(
name|fragsize
operator|>
name|mtu
condition|)
name|fragsize
operator|=
name|mtu
expr_stmt|;
comment|/* XXX fragsize can be>2048! */
name|KASSERT
argument_list|(
name|fragsize
operator|<
name|MCLBYTES
argument_list|,
operator|(
literal|"fragment size %u too big!"
operator|,
name|fragsize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fragsize
operator|>
name|MHLEN
condition|)
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* leave room to prepend any cipher header */
name|m_align
argument_list|(
name|m
argument_list|,
name|fragsize
operator|-
name|ciphdrsize
argument_list|)
expr_stmt|;
comment|/* 		 * Form the header in the fragment.  Note that since 		 * we mark the first fragment with the MORE_FRAG bit 		 * it automatically is propagated to each fragment; we 		 * need only clear it on the last fragment (done below). 		 * NB: frag 1+ dont have Mesh Control field present. 		 */
name|whf
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|whf
argument_list|,
name|wh
argument_list|,
name|hdrsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|whf
operator|)
operator|->
name|i_qos
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_QOS_MC
expr_stmt|;
else|else
operator|(
operator|(
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|whf
operator|)
operator|->
name|i_qos
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_QOS_MC
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|whf
operator|->
name|i_seq
index|[
literal|0
index|]
operator||=
name|htole16
argument_list|(
operator|(
name|fragno
operator|&
name|IEEE80211_SEQ_FRAG_MASK
operator|)
operator|<<
name|IEEE80211_SEQ_FRAG_SHIFT
argument_list|)
expr_stmt|;
name|fragno
operator|++
expr_stmt|;
name|payload
operator|=
name|fragsize
operator|-
name|totalhdrsize
expr_stmt|;
comment|/* NB: destination is known to be contiguous */
name|m_copydata
argument_list|(
name|m0
argument_list|,
name|off
argument_list|,
name|payload
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrspace
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|hdrspace
operator|+
name|payload
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|hdrspace
operator|+
name|payload
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_FRAG
expr_stmt|;
comment|/* chain up the fragment */
name|prev
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|prev
operator|=
name|m
expr_stmt|;
comment|/* deduct fragment just formed */
name|remainder
operator|-=
name|payload
expr_stmt|;
name|off
operator|+=
name|payload
expr_stmt|;
block|}
do|while
condition|(
name|remainder
operator|!=
literal|0
condition|)
do|;
comment|/* set the last fragment */
name|m
operator|->
name|m_flags
operator||=
name|M_LASTFRAG
expr_stmt|;
name|whf
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&=
operator|~
name|IEEE80211_FC1_MORE_FRAG
expr_stmt|;
comment|/* strip first mbuf now that everything has been copied */
name|m_adj
argument_list|(
name|m0
argument_list|,
operator|-
operator|(
name|m0
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|mtu
operator|-
name|ciphdrsize
operator|)
operator|)
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_flags
operator||=
name|M_FIRSTFRAG
operator||
name|M_FRAG
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_fragframes
operator|++
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_frags
operator|+=
name|fragno
operator|-
literal|1
expr_stmt|;
return|return
literal|1
return|;
name|bad
label|:
comment|/* reclaim fragments but leave original frame for caller to free */
name|ieee80211_free_mbuf
argument_list|(
name|m0
operator|->
name|m_nextpkt
argument_list|)
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Add a supported rates element id to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_rates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|nrates
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|nrates
return|;
block|}
end_function

begin_comment
comment|/*  * Add an extended supported rates element id to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_xrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
comment|/* 	 * Add an extended supported rates element if operating in 11g mode. 	 */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|int
name|nrates
init|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*   * Add an ssid element to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_ssid
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ssid
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Add an erp element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_erp
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|uint8_t
name|erp
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_ERP
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
name|erp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_nonerpsta
operator|!=
literal|0
condition|)
name|erp
operator||=
name|IEEE80211_ERP_NON_ERP_PRESENT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEPROT
condition|)
name|erp
operator||=
name|IEEE80211_ERP_USE_PROTECTION
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_USEBARKER
condition|)
name|erp
operator||=
name|IEEE80211_ERP_LONG_PREAMBLE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|erp
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Add a CFParams element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_cfparms
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {	\ 	LE_WRITE_2(frm, v);	\ 	frm += 2;		\ } while (0)
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_CFPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|6
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* CFP count */
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
comment|/* CFP period */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* CFP MaxDuration (TU) */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* CFP CurRemaining (TU) */
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
modifier|*
name|add_appie
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_appie
modifier|*
name|ie
parameter_list|)
block|{
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ie
operator|->
name|ie_data
argument_list|,
name|ie
operator|->
name|ie_len
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|ie
operator|->
name|ie_len
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint8_t
modifier|*
name|add_ie
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ie
argument_list|,
literal|2
operator|+
name|ie
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
literal|2
operator|+
name|ie
index|[
literal|1
index|]
return|;
block|}
end_function

begin_define
define|#
directive|define
name|WME_OUI_BYTES
value|0x00, 0x50, 0xf2
end_define

begin_comment
comment|/*  * Add a WME information element to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_wme_info
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_wme_info
name|info
init|=
block|{
operator|.
name|wme_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|wme_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|)
operator|-
literal|2
block|,
operator|.
name|wme_oui
operator|=
block|{
name|WME_OUI_BYTES
block|}
block|,
operator|.
name|wme_type
operator|=
name|WME_OUI_TYPE
block|,
operator|.
name|wme_subtype
operator|=
name|WME_INFO_OUI_SUBTYPE
block|,
operator|.
name|wme_version
operator|=
name|WME_VERSION
block|,
operator|.
name|wme_info
operator|=
literal|0
block|, 	}
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a WME parameters element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_wme_param
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
parameter_list|)
block|{
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {	\ 	LE_WRITE_2(frm, v);	\ 	frm += 2;		\ } while (0)
comment|/* NB: this works 'cuz a param has an info at the front */
specifier|static
specifier|const
name|struct
name|ieee80211_wme_info
name|param
init|=
block|{
operator|.
name|wme_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|wme_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
operator|-
literal|2
block|,
operator|.
name|wme_oui
operator|=
block|{
name|WME_OUI_BYTES
block|}
block|,
operator|.
name|wme_type
operator|=
name|WME_OUI_TYPE
block|,
operator|.
name|wme_subtype
operator|=
name|WME_PARAM_OUI_SUBTYPE
block|,
operator|.
name|wme_version
operator|=
name|WME_VERSION
block|, 	}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|,
name|wme_info
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_info
expr_stmt|;
comment|/* AC info */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* reserved field */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|struct
name|wmeParams
modifier|*
name|ac
init|=
operator|&
name|wme
operator|->
name|wme_bssChanParams
operator|.
name|cap_wmeParams
index|[
name|i
index|]
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|SM
argument_list|(
name|i
argument_list|,
name|WME_PARAM_ACI
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_acm
argument_list|,
name|WME_PARAM_ACM
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_aifsn
argument_list|,
name|WME_PARAM_AIFSN
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|SM
argument_list|(
name|ac
operator|->
name|wmep_logcwmax
argument_list|,
name|WME_PARAM_LOGCWMAX
argument_list|)
operator||
name|SM
argument_list|(
name|ac
operator|->
name|wmep_logcwmin
argument_list|,
name|WME_PARAM_LOGCWMIN
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ac
operator|->
name|wmep_txopLimit
argument_list|)
expr_stmt|;
block|}
return|return
name|frm
return|;
undef|#
directive|undef
name|SM
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_undef
undef|#
directive|undef
name|WME_OUI_BYTES
end_undef

begin_comment
comment|/*  * Add an 11h Power Constraint element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_powerconstraint
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
init|=
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
decl_stmt|;
comment|/* XXX per-vap tx power limit? */
name|int8_t
name|limit
init|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_txpowlimit
operator|/
literal|2
decl_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_PWRCNSTR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
name|c
operator|->
name|ic_maxregpower
operator|>
name|limit
condition|?
name|c
operator|->
name|ic_maxregpower
operator|-
name|limit
else|:
literal|0
expr_stmt|;
return|return
name|frm
operator|+
literal|3
return|;
block|}
end_function

begin_comment
comment|/*  * Add an 11h Power Capability element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_powercapability
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_PWRCAP
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
name|c
operator|->
name|ic_minpower
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
name|c
operator|->
name|ic_maxpower
expr_stmt|;
return|return
name|frm
operator|+
literal|4
return|;
block|}
end_function

begin_comment
comment|/*  * Add an 11h Supported Channels element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_supportedchannels
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|ielen
init|=
literal|26
decl_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_SUPPCHAN
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
name|ielen
expr_stmt|;
comment|/* XXX not correct */
name|memcpy
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ic
operator|->
name|ic_chan_avail
argument_list|,
name|ielen
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
literal|2
operator|+
name|ielen
return|;
block|}
end_function

begin_comment
comment|/*  * Add an 11h Quiet time element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_quiet
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_quiet_ie
modifier|*
name|quiet
init|=
operator|(
expr|struct
name|ieee80211_quiet_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|quiet
operator|->
name|quiet_ie
operator|=
name|IEEE80211_ELEMID_QUIET
expr_stmt|;
name|quiet
operator|->
name|len
operator|=
literal|6
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_quiet_count_value
operator|==
literal|1
condition|)
name|vap
operator|->
name|iv_quiet_count_value
operator|=
name|vap
operator|->
name|iv_quiet_count
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_quiet_count_value
operator|>
literal|1
condition|)
name|vap
operator|->
name|iv_quiet_count_value
operator|--
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_quiet_count_value
operator|==
literal|0
condition|)
block|{
comment|/* value 0 is reserved as per 802.11h standerd */
name|vap
operator|->
name|iv_quiet_count_value
operator|=
literal|1
expr_stmt|;
block|}
name|quiet
operator|->
name|tbttcount
operator|=
name|vap
operator|->
name|iv_quiet_count_value
expr_stmt|;
name|quiet
operator|->
name|period
operator|=
name|vap
operator|->
name|iv_quiet_period
expr_stmt|;
name|quiet
operator|->
name|duration
operator|=
name|htole16
argument_list|(
name|vap
operator|->
name|iv_quiet_duration
argument_list|)
expr_stmt|;
name|quiet
operator|->
name|offset
operator|=
name|htole16
argument_list|(
name|vap
operator|->
name|iv_quiet_offset
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|quiet
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an 11h Channel Switch Announcement element to a frame.  * Note that we use the per-vap CSA count to adjust the global  * counter so we can use this routine to form probe response  * frames and get the current count.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_csa
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_csa_ie
modifier|*
name|csa
init|=
operator|(
expr|struct
name|ieee80211_csa_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|csa
operator|->
name|csa_ie
operator|=
name|IEEE80211_ELEMID_CSA
expr_stmt|;
name|csa
operator|->
name|csa_len
operator|=
literal|3
expr_stmt|;
name|csa
operator|->
name|csa_mode
operator|=
literal|1
expr_stmt|;
comment|/* XXX force quiet on channel */
name|csa
operator|->
name|csa_newchan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_csa_newchan
argument_list|)
expr_stmt|;
name|csa
operator|->
name|csa_count
operator|=
name|ic
operator|->
name|ic_csa_count
operator|-
name|vap
operator|->
name|iv_csa_count
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an 11h country information element to a frame.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_countryie
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_countryie
operator|==
name|NULL
operator|||
name|ic
operator|->
name|ic_countryie_chan
operator|!=
name|ic
operator|->
name|ic_bsschan
condition|)
block|{
comment|/* 		 * Handle lazy construction of ie.  This is done on 		 * first use and after a channel change that requires 		 * re-calculation. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_countryie
operator|!=
name|NULL
condition|)
name|IEEE80211_FREE
argument_list|(
name|ic
operator|->
name|ic_countryie
argument_list|,
name|M_80211_NODE_IE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_countryie
operator|=
name|ieee80211_alloc_countryie
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_countryie
operator|==
name|NULL
condition|)
return|return
name|frm
return|;
name|ic
operator|->
name|ic_countryie_chan
operator|=
name|ic
operator|->
name|ic_bsschan
expr_stmt|;
block|}
return|return
name|add_appie
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_countryie
argument_list|)
return|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_wpa
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WPA1
operator|&&
name|vap
operator|->
name|iv_wpa_ie
operator|!=
name|NULL
condition|)
return|return
operator|(
name|add_ie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_wpa_ie
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* XXX else complain? */
return|return
operator|(
name|frm
operator|)
return|;
block|}
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_rsn
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WPA2
operator|&&
name|vap
operator|->
name|iv_rsn_ie
operator|!=
name|NULL
condition|)
return|return
operator|(
name|add_ie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_rsn_ie
argument_list|)
operator|)
return|;
else|else
block|{
comment|/* XXX else complain? */
return|return
operator|(
name|frm
operator|)
return|;
block|}
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_qos
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_QOS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_QOS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|frm
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a probe request frame with the specified ssid  * and any optional information element data.  */
end_comment

begin_function
name|int
name|ieee80211_send_probereq
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
name|sa
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ssid
parameter_list|,
name|size_t
name|ssidlen
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_txparam
modifier|*
name|tp
decl_stmt|;
name|struct
name|ieee80211_bpf_params
name|params
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|ni
argument_list|,
literal|"block %s frame in CAC state"
argument_list|,
literal|"probe request"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* 	 * prreq frame format 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[tlv] RSN (optional) 	 *	[tlv] extended supported rates 	 *	[tlv] WPA (optional) 	 *	[tlv] user-specified ie's 	 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|+
operator|(
name|vap
operator|->
name|iv_appie_probereq
operator|!=
name|NULL
condition|?
name|vap
operator|->
name|iv_appie_probereq
operator|->
name|ie_len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|ssidlen
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rsn
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_appie_probereq
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|add_appie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_appie_probereq
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
operator|(
literal|"leading space %zd"
operator|,
name|M_LEADINGSPACE
argument_list|(
name|m
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* NB: cannot happen */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
argument_list|,
name|IEEE80211_NONQOS_TID
argument_list|,
name|sa
argument_list|,
name|da
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
comment|/* XXX power management? */
name|m
operator|->
name|m_flags
operator||=
name|M_ENCAP
expr_stmt|;
comment|/* mark encapsulated */
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|WME_AC_BE
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_probereq
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"send probe req on channel %u bssid %s ssid \"%.*s\"\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|bssid
argument_list|)
argument_list|,
name|ssidlen
argument_list|,
name|ssid
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|ibp_pri
operator|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|tp
operator|=
operator|&
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
index|]
expr_stmt|;
name|params
operator|.
name|ibp_rate0
operator|=
name|tp
operator|->
name|mgmtrate
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_MULTICAST
argument_list|(
name|da
argument_list|)
condition|)
block|{
name|params
operator|.
name|ibp_flags
operator||=
name|IEEE80211_BPF_NOACK
expr_stmt|;
name|params
operator|.
name|ibp_try0
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|params
operator|.
name|ibp_try0
operator|=
name|tp
operator|->
name|maxretry
expr_stmt|;
name|params
operator|.
name|ibp_power
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate capability information for mgt frames.  */
end_comment

begin_function
name|uint16_t
name|ieee80211_getcapinfo
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"station mode"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
else|else
name|capinfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|chan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|chan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
operator|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SPECTRUM_MGMT
expr_stmt|;
return|return
name|capinfo
return|;
block|}
end_function

begin_comment
comment|/*  * Send a management frame.  The node is for the destination (or ic_bss  * when in station mode).  Nodes other than ic_bss have their reference  * count bumped to reflect our use for an indeterminant time.  */
end_comment

begin_function
name|int
name|ieee80211_send_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
define|#
directive|define
name|HTFLAGS
value|(IEEE80211_NODE_HT | IEEE80211_NODE_HTCOMPAT)
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { vap->iv_stats._v++; ret = _x; goto bad; } while (0)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|bss
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|ieee80211_bpf_params
name|params
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|int
name|has_challenge
decl_stmt|,
name|is_shared_key
decl_stmt|,
name|ret
decl_stmt|,
name|status
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
name|status
operator|=
name|arg
operator|>>
literal|16
expr_stmt|;
name|arg
operator|&=
literal|0xffff
expr_stmt|;
name|has_challenge
operator|=
operator|(
operator|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_CHALLENGE
operator|||
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_RESPONSE
operator|)
operator|&&
name|ni
operator|->
name|ni_challenge
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* 		 * Deduce whether we're doing open authentication or 		 * shared key authentication.  We do the latter if 		 * we're in the middle of a shared key authentication 		 * handshake or if we're initiating an authentication 		 * request and configured to use shared key. 		 */
name|is_shared_key
operator|=
name|has_challenge
operator|||
name|arg
operator|>=
name|IEEE80211_AUTH_SHARED_RESPONSE
operator|||
operator|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_REQUEST
operator|&&
name|bss
operator|->
name|ni_authmode
operator|==
name|IEEE80211_AUTH_SHARED
operator|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
operator|(
name|has_challenge
operator|&&
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|?
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|IEEE80211_CHALLENGE_LEN
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|0
index|]
operator|=
operator|(
name|is_shared_key
operator|)
condition|?
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_SHARED
argument_list|)
else|:
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_OPEN
argument_list|)
expr_stmt|;
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* sequence number */
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|2
index|]
operator|=
name|htole16
argument_list|(
name|status
argument_list|)
expr_stmt|;
comment|/* status */
if|if
condition|(
name|has_challenge
operator|&&
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|3
index|]
operator|=
name|htole16
argument_list|(
operator|(
name|IEEE80211_CHALLENGE_LEN
operator|<<
literal|8
operator|)
operator||
name|IEEE80211_ELEMID_CHALLENGE
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|4
index|]
argument_list|,
name|ni
operator|->
name|ni_challenge
argument_list|,
name|IEEE80211_CHALLENGE_LEN
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|IEEE80211_CHALLENGE_LEN
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_AUTH_SHARED_RESPONSE
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
name|ni
argument_list|,
literal|"request encrypt frame (%s)"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* mark frame for encryption */
name|params
operator|.
name|ibp_flags
operator||=
name|IEEE80211_BPF_CRYPTO
expr_stmt|;
block|}
block|}
else|else
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
comment|/* XXX not right for shared key */
if|if
condition|(
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_auth
argument_list|)
expr_stmt|;
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_auth_fail
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|ieee80211_add_callback
argument_list|(
name|m
argument_list|,
name|ieee80211_tx_mgt_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_AUTH
argument_list|,
name|ni
argument_list|,
literal|"send station deauthenticate (reason %d)"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_deauth
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_SET
argument_list|(
name|ni
argument_list|,
name|tx_deauth_code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|ieee80211_node_unauthorize
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* port closed */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
case|:
comment|/* 		 * asreq frame format 		 *	[2] capability information 		 *	[2] listen interval 		 *	[6*] current AP address (reassoc only) 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 *	[4] power capability (optional) 		 *	[28] supported channels (optional) 		 *	[tlv] HT capabilities 		 *	[tlv] WME (optional) 		 *	[tlv] Vendor OUI HT capabilities (optional) 		 *	[tlv] Atheros capabilities (if negotiated) 		 *	[tlv] AppIE's (optional) 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
name|IEEE80211_ADDR_LEN
operator|+
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
literal|4
operator|+
literal|2
operator|+
literal|26
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_info
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
endif|#
directive|endif
operator|+
operator|(
name|vap
operator|->
name|iv_appie_wpa
operator|!=
name|NULL
condition|?
name|vap
operator|->
name|iv_appie_wpa
operator|->
name|ie_len
else|:
literal|0
operator|)
operator|+
operator|(
name|vap
operator|->
name|iv_appie_assocreq
operator|!=
name|NULL
condition|?
name|vap
operator|->
name|iv_appie_assocreq
operator|->
name|ie_len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
comment|/* 		 * NB: Some 11a AP's reject the request when 		 *     short premable is set. 		 */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
operator|)
operator|&&
name|IEEE80211_IS_CHAN_2GHZ
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_SHSLOT
operator|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_capinfo
operator|&
name|IEEE80211_CAPINFO_SPECTRUM_MGMT
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
operator|)
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SPECTRUM_MGMT
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|KASSERT
argument_list|(
name|bss
operator|->
name|ni_intval
operator|!=
literal|0
argument_list|,
operator|(
literal|"beacon interval is zero!"
operator|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|howmany
argument_list|(
name|ic
operator|->
name|ic_lintval
argument_list|,
name|bss
operator|->
name|ni_intval
argument_list|)
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|frm
argument_list|,
name|bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rsn
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|capinfo
operator|&
name|IEEE80211_CAPINFO_SPECTRUM_MGMT
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_powercapability
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_supportedchannels
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Check the channel - we may be using an 11n NIC with an 		 * 11n capable station, but we're configured to be an 11b 		 * channel. 		 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HT
operator|)
operator|&&
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|htcap_ie
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|htcap_ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_HTCAP
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|wme_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_wme_info
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
comment|/* 		 * Same deal - only send HT info if we're on an 11n 		 * capable channel. 		 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HT
operator|)
operator|&&
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|htcap_ie
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|htcap_ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_ath
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
argument_list|,
operator|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|==
literal|0
operator|&&
name|ni
operator|->
name|ni_authmode
operator|!=
name|IEEE80211_AUTH_8021X
operator|)
condition|?
name|vap
operator|->
name|iv_def_txkey
else|:
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_SUPERG */
if|if
condition|(
name|vap
operator|->
name|iv_appie_assocreq
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|add_appie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_appie_assocreq
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_add_callback
argument_list|(
name|m
argument_list|,
name|ieee80211_tx_mgt_cb
argument_list|,
operator|(
name|void
operator|*
operator|)
name|vap
operator|->
name|iv_state
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_RESP
case|:
comment|/* 		 * asresp frame format 		 *	[2] capability information 		 *	[2] status 		 *	[2] association ID 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 *	[tlv] HT capabilities (standard, if STA enabled) 		 *	[tlv] HT information (standard, if STA enabled) 		 *	[tlv] WME (if configured and STA enabled) 		 *	[tlv] HT capabilities (vendor OUI, if STA enabled) 		 *	[tlv] HT information (vendor OUI, if STA enabled) 		 *	[tlv] Atheros capabilities (if STA enabled) 		 *	[tlv] AppIE's (optional) 		 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
endif|#
directive|endif
operator|+
operator|(
name|vap
operator|->
name|iv_appie_assocresp
operator|!=
name|NULL
condition|?
name|vap
operator|->
name|iv_appie_assocresp
operator|->
name|ie_len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|ieee80211_getcapinfo
argument_list|(
name|vap
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* status */
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_assoc
argument_list|)
expr_stmt|;
block|}
else|else
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_assoc_fail
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
comment|/* NB: respond according to what we received */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|HTFLAGS
operator|)
operator|==
name|IEEE80211_NODE_HT
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|wme_ie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|HTFLAGS
operator|)
operator|==
name|HTFLAGS
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_ath
argument_list|(
name|frm
argument_list|,
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_F_ATHEROS
argument_list|)
argument_list|,
operator|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|==
literal|0
operator|&&
name|ni
operator|->
name|ni_authmode
operator|!=
name|IEEE80211_AUTH_8021X
operator|)
condition|?
name|vap
operator|->
name|iv_def_txkey
else|:
name|IEEE80211_KEYIX_NONE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_SUPERG */
if|if
condition|(
name|vap
operator|->
name|iv_appie_assocresp
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|add_appie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_appie_assocresp
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DISASSOC
case|:
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ASSOC
argument_list|,
name|ni
argument_list|,
literal|"send station disassociate (reason %d)"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_disassoc
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT_SET
argument_list|(
name|ni
argument_list|,
name|tx_disassoc_code
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
argument_list|,
literal|"invalid mgmt frame type %u"
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|,
name|is_tx_unknownmgt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* NB: force non-ProbeResp frames to the highest queue */
name|params
operator|.
name|ibp_pri
operator|=
name|WME_AC_VO
expr_stmt|;
name|params
operator|.
name|ibp_rate0
operator|=
name|bss
operator|->
name|ni_txparms
operator|->
name|mgmtrate
expr_stmt|;
comment|/* NB: we know all frames are unicast */
name|params
operator|.
name|ibp_try0
operator|=
name|bss
operator|->
name|ni_txparms
operator|->
name|maxretry
expr_stmt|;
name|params
operator|.
name|ibp_power
operator|=
name|bss
operator|->
name|ni_txpower
expr_stmt|;
return|return
name|ieee80211_mgmt_output
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|type
argument_list|,
operator|&
name|params
argument_list|)
return|;
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|senderr
undef|#
directive|undef
name|HTFLAGS
block|}
end_function

begin_comment
comment|/*  * Return an mbuf with a probe response frame in it.  * Space is left to prepend and 802.11 header at the  * front but it's left to the caller to fill in.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_alloc_proberesp
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|bss
parameter_list|,
name|int
name|legacy
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|bss
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|bss
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
comment|/* 	 * probe response frame format 	 *	[8] time stamp 	 *	[2] beacon interval 	 *	[2] cabability information 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[tlv] parameter set (FH/DS) 	 *	[tlv] parameter set (IBSS) 	 *	[tlv] country (optional) 	 *	[3] power control (optional) 	 *	[5] channel switch announcement (CSA) (optional) 	 *	[tlv] extended rate phy (ERP) 	 *	[tlv] extended supported rates 	 *	[tlv] RSN (optional) 	 *	[tlv] HT capabilities 	 *	[tlv] HT information 	 *	[tlv] WPA (optional) 	 *	[tlv] WME (optional) 	 *	[tlv] Vendor OUI HT capabilities (optional) 	 *	[tlv] Vendor OUI HT information (optional) 	 *	[tlv] Atheros capabilities 	 *	[tlv] AppIE's (optional) 	 *	[tlv] Mesh ID (MBSS) 	 *	[tlv] Mesh Conf (MBSS) 	 */
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
literal|8
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_NWID_LEN
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|7
comment|/* max(7,3) */
operator|+
name|IEEE80211_COUNTRY_MAX_SIZE
operator|+
literal|3
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_csa_ie
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_quiet_ie
argument_list|)
operator|+
literal|3
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|+
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
operator|+
literal|2
operator|+
name|IEEE80211_MESHID_LEN
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshconf_ie
argument_list|)
endif|#
directive|endif
operator|+
operator|(
name|vap
operator|->
name|iv_appie_proberesp
operator|!=
name|NULL
condition|?
name|vap
operator|->
name|iv_appie_proberesp
operator|->
name|ie_len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* timestamp should be filled later */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|bss
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|capinfo
operator|=
name|ieee80211_getcapinfo
argument_list|(
name|vap
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|bss
operator|->
name|ni_essid
argument_list|,
name|bss
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|rs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|bss
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_FHPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|5
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|bss
operator|->
name|ni_fhdwell
operator|&
literal|0x00ff
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
operator|(
name|bss
operator|->
name|ni_fhdwell
operator|>>
literal|8
operator|)
operator|&
literal|0x00ff
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_FH_CHANSET
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_FH_CHANPAT
argument_list|(
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|bss
operator|->
name|ni_fhindex
expr_stmt|;
block|}
else|else
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_DSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|bss
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
block|}
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
operator|)
operator|||
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DOTD
operator|)
condition|)
name|frm
operator|=
name|ieee80211_add_countryie
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|bss
operator|->
name|ni_chan
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_powerconstraint
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_CSAPENDING
condition|)
name|frm
operator|=
name|ieee80211_add_csa
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DFS
operator|)
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_quiet
condition|)
name|frm
operator|=
name|ieee80211_add_quiet
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|bss
operator|->
name|ni_chan
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_erp
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rsn
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * NB: legacy 11b clients do not get certain ie's. 	 *     The caller identifies such clients by passing 	 *     a token in legacy to us.  Could expand this to be 	 *     any legacy client for stuff like HT ie's. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|bss
operator|->
name|ni_chan
argument_list|)
operator|&&
name|legacy
operator|!=
name|IEEE80211_SEND_LEGACY_11B
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|bss
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo
argument_list|(
name|frm
argument_list|,
name|bss
argument_list|)
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
condition|)
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|bss
operator|->
name|ni_chan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HTCOMPAT
operator|)
operator|&&
name|legacy
operator|!=
name|IEEE80211_SEND_LEGACY_11B
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|bss
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo_vendor
argument_list|(
name|frm
argument_list|,
name|bss
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_ATHEROS
operator|)
operator|&&
name|legacy
operator|!=
name|IEEE80211_SEND_LEGACY_11B
condition|)
name|frm
operator|=
name|ieee80211_add_athcaps
argument_list|(
name|frm
argument_list|,
name|bss
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vap
operator|->
name|iv_appie_proberesp
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|add_appie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_appie_proberesp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_meshid
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshconf
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Send a probe response frame to the specified mac address.  * This does not go through the normal mgt frame api so we  * can specify the destination address and re-use the bss node  * for the sta reference.  */
end_comment

begin_function
name|int
name|ieee80211_send_proberesp
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|da
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|legacy
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|bss
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_CAC
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_OUTPUT
argument_list|,
name|bss
argument_list|,
literal|"block %s frame in CAC state"
argument_list|,
literal|"probe response"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_badstate
operator|++
expr_stmt|;
return|return
name|EIO
return|;
comment|/* XXX */
block|}
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|bss
argument_list|,
name|ether_sprintf
argument_list|(
name|bss
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|bss
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|bss
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_alloc_proberesp
argument_list|(
name|bss
argument_list|,
name|legacy
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|ieee80211_free_node
argument_list|(
name|bss
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no room for header"
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ieee80211_send_setup
argument_list|(
name|bss
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
argument_list|,
name|IEEE80211_NONQOS_TID
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|da
argument_list|,
name|bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
comment|/* XXX power management? */
name|m
operator|->
name|m_flags
operator||=
name|M_ENCAP
expr_stmt|;
comment|/* mark encapsulated */
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|WME_AC_BE
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"send probe resp on channel %u to %s%s\n"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|,
name|ether_sprintf
argument_list|(
name|da
argument_list|)
argument_list|,
name|legacy
condition|?
literal|"<legacy>"
else|:
literal|""
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|bss
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|bss
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and build a RTS (Request To Send) control frame.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_alloc_rts
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
name|ra
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|ta
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint16_t
name|dur
parameter_list|)
block|{
name|struct
name|ieee80211_frame_rts
modifier|*
name|rts
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* XXX honor ic_headroom */
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rts
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_rts
operator|*
argument_list|)
expr_stmt|;
name|rts
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_RTS
expr_stmt|;
name|rts
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|rts
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rts
operator|->
name|i_ra
argument_list|,
name|ra
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|rts
operator|->
name|i_ta
argument_list|,
name|ta
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_rts
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate and build a CTS (Clear To Send) control frame.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_alloc_cts
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
name|ra
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|uint16_t
name|dur
parameter_list|)
block|{
name|struct
name|ieee80211_frame_cts
modifier|*
name|cts
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
comment|/* XXX honor ic_headroom */
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|cts
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_cts
operator|*
argument_list|)
expr_stmt|;
name|cts
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_CTS
expr_stmt|;
name|cts
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|cts
operator|->
name|i_dur
operator|=
name|htole16
argument_list|(
name|dur
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|cts
operator|->
name|i_ra
argument_list|,
name|ra
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_cts
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_tx_mgt_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_INIT
operator|&&
operator|(
name|vap
operator|->
name|iv_ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NB: it's safe to specify a timeout as the reason here; 		 *     it'll only be used in the right state. 		 */
name|ieee80211_new_state_locked
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
name|IEEE80211_SCAN_FAIL_TIMEOUT
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the callback set on net80211-sourced transmitted  * authentication request frames.  *  * This does a couple of things:  *  * + If the frame transmitted was a success, it schedules a future  *   event which will transition the interface to scan.  *   If a state transition _then_ occurs before that event occurs,  *   said state transition will cancel this callout.  *  * + If the frame transmit was a failure, it immediately schedules  *   the transition back to scan.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_tx_mgt_cb
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
init|=
operator|(
expr|enum
name|ieee80211_state
operator|)
name|arg
decl_stmt|;
comment|/* 	 * Frame transmit completed; arrange timer callback.  If 	 * transmit was successfuly we wait for response.  Otherwise 	 * we arrange an immediate callback instead of doing the 	 * callback directly since we don't know what state the driver 	 * is in (e.g. what locks it is holding).  This work should 	 * not be too time-critical and not happen too often so the 	 * added overhead is acceptable. 	 * 	 * XXX what happens if !acked but response shows up before callback? 	 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|ostate
condition|)
block|{
name|callout_reset
argument_list|(
operator|&
name|vap
operator|->
name|iv_mgtsend
argument_list|,
name|status
operator|==
literal|0
condition|?
name|IEEE80211_TRANS_WAIT
operator|*
name|hz
else|:
literal|0
argument_list|,
name|ieee80211_tx_mgt_timeout
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_beacon_construct
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
init|=
operator|&
name|vap
operator|->
name|iv_bcn_off
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_rateset
modifier|*
name|rs
init|=
operator|&
name|ni
operator|->
name|ni_rates
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
comment|/* 	 * beacon frame format 	 *	[8] time stamp 	 *	[2] beacon interval 	 *	[2] cabability information 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[3] parameter set (DS) 	 *	[8] CF parameter set (optional) 	 *	[tlv] parameter set (IBSS/TIM) 	 *	[tlv] country (optional) 	 *	[3] power control (optional) 	 *	[5] channel switch announcement (CSA) (optional) 	 *	[tlv] extended rate phy (ERP) 	 *	[tlv] extended supported rates 	 *	[tlv] RSN parameters 	 *	[tlv] HT capabilities 	 *	[tlv] HT information 	 * XXX Vendor-specific OIDs (e.g. Atheros) 	 *	[tlv] WPA parameters 	 *	[tlv] WME parameters 	 *	[tlv] Vendor OUI HT capabilities (optional) 	 *	[tlv] Vendor OUI HT information (optional) 	 *	[tlv] Atheros capabilities (optional) 	 *	[tlv] TDMA parameters (optional) 	 *	[tlv] Mesh ID (MBSS) 	 *	[tlv] Mesh Conf (MBSS) 	 *	[tlv] application data (optional) 	 */
name|memset
argument_list|(
name|bo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bo
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* XXX timestamp is set by hardware/driver */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|capinfo
operator|=
name|ieee80211_getcapinfo
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_caps
operator|=
operator|(
name|uint16_t
operator|*
operator|)
name|frm
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_HIDESSID
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|ni
operator|->
name|ni_esslen
expr_stmt|;
block|}
else|else
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_DSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PCF
condition|)
block|{
name|bo
operator|->
name|bo_cfp
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_cfparms
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
name|bo
operator|->
name|bo_tim
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
name|bo
operator|->
name|bo_tim_len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* TIM IE is the same for Mesh and Hostap */
name|struct
name|ieee80211_tim_ie
modifier|*
name|tie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|tie
operator|->
name|tim_ie
operator|=
name|IEEE80211_ELEMID_TIM
expr_stmt|;
name|tie
operator|->
name|tim_len
operator|=
literal|4
expr_stmt|;
comment|/* length */
name|tie
operator|->
name|tim_count
operator|=
literal|0
expr_stmt|;
comment|/* DTIM count */
name|tie
operator|->
name|tim_period
operator|=
name|vap
operator|->
name|iv_dtim_period
expr_stmt|;
comment|/* DTIM period */
name|tie
operator|->
name|tim_bitctl
operator|=
literal|0
expr_stmt|;
comment|/* bitmap control */
name|tie
operator|->
name|tim_bitmap
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Partial Virtual Bitmap */
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_tim_ie
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_tim_len
operator|=
literal|1
expr_stmt|;
block|}
name|bo
operator|->
name|bo_tim_trailer
operator|=
name|frm
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
operator|)
operator|||
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DOTD
operator|)
condition|)
name|frm
operator|=
name|ieee80211_add_countryie
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|frm
operator|=
name|ieee80211_add_powerconstraint
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_csa
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_CSAPENDING
condition|)
name|frm
operator|=
name|ieee80211_add_csa
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
else|else
name|bo
operator|->
name|bo_csa
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DOTH
condition|)
block|{
name|bo
operator|->
name|bo_quiet
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DFS
operator|)
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_quiet
condition|)
name|frm
operator|=
name|ieee80211_add_quiet
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|bo
operator|->
name|bo_quiet
operator|=
name|frm
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|bo
operator|->
name|bo_erp
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_erp
argument_list|(
name|frm
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rsn
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_htinfo
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_wpa
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|bo
operator|->
name|bo_wme
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_wme_param
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_wme
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HTCOMPAT
operator|)
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_htcap_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_htinfo_vendor
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_ATHEROS
condition|)
block|{
name|bo
operator|->
name|bo_ath
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_athcaps
argument_list|(
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
name|bo
operator|->
name|bo_tdma
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_tdma
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|vap
operator|->
name|iv_appie_beacon
operator|!=
name|NULL
condition|)
block|{
name|bo
operator|->
name|bo_appie
operator|=
name|frm
expr_stmt|;
name|bo
operator|->
name|bo_appie_len
operator|=
name|vap
operator|->
name|iv_appie_beacon
operator|->
name|ie_len
expr_stmt|;
name|frm
operator|=
name|add_appie
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_appie_beacon
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
name|frm
operator|=
name|ieee80211_add_meshid
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_meshconf
operator|=
name|frm
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_meshconf
argument_list|(
name|frm
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bo
operator|->
name|bo_tim_trailer_len
operator|=
name|frm
operator|-
name|bo
operator|->
name|bo_tim_trailer
expr_stmt|;
name|bo
operator|->
name|bo_csa_trailer_len
operator|=
name|frm
operator|-
name|bo
operator|->
name|bo_csa
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a beacon frame and fillin the appropriate bits.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_beacon_alloc
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pktlen
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
comment|/* 	 * beacon frame format 	 *	[8] time stamp 	 *	[2] beacon interval 	 *	[2] cabability information 	 *	[tlv] ssid 	 *	[tlv] supported rates 	 *	[3] parameter set (DS) 	 *	[8] CF parameter set (optional) 	 *	[tlv] parameter set (IBSS/TIM) 	 *	[tlv] country (optional) 	 *	[3] power control (optional) 	 *	[5] channel switch announcement (CSA) (optional) 	 *	[tlv] extended rate phy (ERP) 	 *	[tlv] extended supported rates 	 *	[tlv] RSN parameters 	 *	[tlv] HT capabilities 	 *	[tlv] HT information 	 *	[tlv] Vendor OUI HT capabilities (optional) 	 *	[tlv] Vendor OUI HT information (optional) 	 * XXX Vendor-specific OIDs (e.g. Atheros) 	 *	[tlv] WPA parameters 	 *	[tlv] WME parameters 	 *	[tlv] TDMA parameters (optional) 	 *	[tlv] Mesh ID (MBSS) 	 *	[tlv] Mesh Conf (MBSS) 	 *	[tlv] application data (optional) 	 * NB: we allocate the max space required for the TIM bitmap. 	 * XXX how big is this? 	 */
name|pktlen
operator|=
literal|8
comment|/* time stamp */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* beacon interval */
operator|+
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* capabilities */
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_esslen
comment|/* ssid */
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
comment|/* supported rates */
operator|+
literal|2
operator|+
literal|1
comment|/* DS parameters */
operator|+
literal|2
operator|+
literal|6
comment|/* CF parameters */
operator|+
literal|2
operator|+
literal|4
operator|+
name|vap
operator|->
name|iv_tim_len
comment|/* DTIM/IBSSPARMS */
operator|+
name|IEEE80211_COUNTRY_MAX_SIZE
comment|/* country */
operator|+
literal|2
operator|+
literal|1
comment|/* power control */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_csa_ie
argument_list|)
comment|/* CSA */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_quiet_ie
argument_list|)
comment|/* Quiet */
operator|+
literal|2
operator|+
literal|1
comment|/* ERP */
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
operator|+
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_WPA
condition|?
comment|/* WPA 1+2 */
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_wpa
argument_list|)
else|:
literal|0
operator|)
comment|/* XXX conditional? */
operator|+
literal|4
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
comment|/* HT caps */
operator|+
literal|4
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
comment|/* HT info */
operator|+
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_WME
condition|?
comment|/* WME */
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_wme_param
argument_list|)
else|:
literal|0
operator|)
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
comment|/* ATH */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
operator|+
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|?
comment|/* TDMA */
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_tdma_param
argument_list|)
else|:
literal|0
operator|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_meshidlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_meshconf_ie
argument_list|)
endif|#
directive|endif
operator|+
name|IEEE80211_MAX_APPIE
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
literal|"%s: cannot get buf; size %u\n"
argument_list|,
name|__func__
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ieee80211_beacon_construct
argument_list|(
name|m
argument_list|,
name|frm
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|!=
name|NULL
argument_list|,
operator|(
literal|"no space for 802.11 header?"
operator|)
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|IEEE80211_FC0_SUBTYPE_BEACON
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ifp
operator|->
name|if_broadcastaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
literal|0
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Update the dynamic parts of a beacon frame based on the current state.  */
end_comment

begin_function
name|int
name|ieee80211_beacon_update
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|mcast
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
init|=
operator|&
name|vap
operator|->
name|iv_bcn_off
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|len_changed
init|=
literal|0
decl_stmt|;
name|uint16_t
name|capinfo
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Handle 11h channel change when we've reached the count. 	 * We must recalculate the beacon frame contents to account 	 * for the new channel.  Note we do this only for the first 	 * vap that reaches this point; subsequent vaps just update 	 * their beacon state to reflect the recalculated channel. 	 */
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_CSA
argument_list|)
operator|&&
name|vap
operator|->
name|iv_csa_count
operator|==
name|ic
operator|->
name|ic_csa_count
condition|)
block|{
name|vap
operator|->
name|iv_csa_count
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Effect channel change before reconstructing the beacon 		 * frame contents as many places reference ni_chan. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_csa_newchan
operator|!=
name|NULL
condition|)
name|ieee80211_csa_completeswitch
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 		 * NB: ieee80211_beacon_construct clears all pending 		 * updates in bo_flags so we don't need to explicitly 		 * clear IEEE80211_BEACON_CSA. 		 */
name|ieee80211_beacon_construct
argument_list|(
name|m
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX do WME aggressive mode processing? */
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* just assume length changed */
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|seqno
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|IEEE80211_NONQOS_TID
index|]
operator|++
expr_stmt|;
operator|*
operator|(
name|uint16_t
operator|*
operator|)
operator|&
name|wh
operator|->
name|i_seq
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|seqno
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|M_SEQNO_SET
argument_list|(
name|m
argument_list|,
name|seqno
argument_list|)
expr_stmt|;
comment|/* XXX faster to recalculate entirely or just changes? */
name|capinfo
operator|=
name|ieee80211_getcapinfo
argument_list|(
name|vap
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
operator|*
name|bo
operator|->
name|bo_caps
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
condition|)
block|{
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
comment|/* 		 * Check for agressive mode change.  When there is 		 * significant high priority traffic in the BSS 		 * throttle back BE traffic by using conservative 		 * parameters.  Otherwise BE uses agressive params 		 * to optimize performance of legacy/non-QoS traffic. 		 */
if|if
condition|(
name|wme
operator|->
name|wme_flags
operator|&
name|WME_F_AGGRMODE
condition|)
block|{
if|if
condition|(
name|wme
operator|->
name|wme_hipri_traffic
operator|>
name|wme
operator|->
name|wme_hipri_switch_thresh
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: traffic %u, disable aggressive mode\n"
argument_list|,
name|__func__
argument_list|,
name|wme
operator|->
name|wme_hipri_traffic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator|&=
operator|~
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_hipri_traffic
operator|=
name|wme
operator|->
name|wme_hipri_switch_hysteresis
expr_stmt|;
block|}
else|else
name|wme
operator|->
name|wme_hipri_traffic
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|wme
operator|->
name|wme_hipri_traffic
operator|<=
name|wme
operator|->
name|wme_hipri_switch_thresh
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_WME
argument_list|,
literal|"%s: traffic %u, enable aggressive mode\n"
argument_list|,
name|__func__
argument_list|,
name|wme
operator|->
name|wme_hipri_traffic
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_flags
operator||=
name|WME_F_AGGRMODE
expr_stmt|;
name|ieee80211_wme_updateparams_locked
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|wme
operator|->
name|wme_hipri_traffic
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|wme
operator|->
name|wme_hipri_traffic
operator|=
name|wme
operator|->
name|wme_hipri_switch_hysteresis
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_WME
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_add_wme_param
argument_list|(
name|bo
operator|->
name|bo_wme
argument_list|,
name|wme
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_WME
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_HTINFO
argument_list|)
condition|)
block|{
name|ieee80211_ht_update_beacon
argument_list|(
name|vap
argument_list|,
name|bo
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_HTINFO
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
comment|/* 		 * NB: the beacon is potentially updated every TBTT. 		 */
name|ieee80211_tdma_update_beacon
argument_list|(
name|vap
argument_list|,
name|bo
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
name|ieee80211_mesh_update_beacon
argument_list|(
name|vap
argument_list|,
name|bo
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
comment|/* NB: no IBSS support*/
name|struct
name|ieee80211_tim_ie
modifier|*
name|tie
init|=
operator|(
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|bo
operator|->
name|bo_tim
decl_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_TIM
argument_list|)
condition|)
block|{
name|u_int
name|timlen
decl_stmt|,
name|timoff
decl_stmt|,
name|i
decl_stmt|;
comment|/*  			 * ATIM/DTIM needs updating.  If it fits in the 			 * current space allocated then just copy in the 			 * new bits.  Otherwise we need to move any trailing 			 * data to make room.  Note that we know there is 			 * contiguous space because ieee80211_beacon_allocate 			 * insures there is space in the mbuf to write a 			 * maximal-size virtual bitmap (based on iv_max_aid). 			 */
comment|/* 			 * Calculate the bitmap size and offset, copy any 			 * trailer out of the way, and then copy in the 			 * new bitmap and update the information element. 			 * Note that the tim bitmap must contain at least 			 * one byte and any offset must be even. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_ps_pending
operator|!=
literal|0
condition|)
block|{
name|timoff
operator|=
literal|128
expr_stmt|;
comment|/* impossibly large */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vap
operator|->
name|iv_tim_len
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vap
operator|->
name|iv_tim_bitmap
index|[
name|i
index|]
condition|)
block|{
name|timoff
operator|=
name|i
operator|&
operator|~
literal|1
expr_stmt|;
break|break;
block|}
name|KASSERT
argument_list|(
name|timoff
operator|!=
literal|128
argument_list|,
operator|(
literal|"tim bitmap empty!"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|vap
operator|->
name|iv_tim_len
operator|-
literal|1
init|;
name|i
operator|>=
name|timoff
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|vap
operator|->
name|iv_tim_bitmap
index|[
name|i
index|]
condition|)
break|break;
name|timlen
operator|=
literal|1
operator|+
operator|(
name|i
operator|-
name|timoff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|timoff
operator|=
literal|0
expr_stmt|;
name|timlen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|timlen
operator|!=
name|bo
operator|->
name|bo_tim_len
condition|)
block|{
comment|/* copy up/down trailer */
name|int
name|adjust
init|=
name|tie
operator|->
name|tim_bitmap
operator|+
name|timlen
operator|-
name|bo
operator|->
name|bo_tim_trailer
decl_stmt|;
name|ovbcopy
argument_list|(
name|bo
operator|->
name|bo_tim_trailer
argument_list|,
name|bo
operator|->
name|bo_tim_trailer
operator|+
name|adjust
argument_list|,
name|bo
operator|->
name|bo_tim_trailer_len
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_tim_trailer
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_erp
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_htinfo
operator|+=
name|adjust
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|bo
operator|->
name|bo_ath
operator|+=
name|adjust
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|bo
operator|->
name|bo_tdma
operator|+=
name|adjust
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
name|bo
operator|->
name|bo_meshconf
operator|+=
name|adjust
expr_stmt|;
endif|#
directive|endif
name|bo
operator|->
name|bo_appie
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_wme
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_csa
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_quiet
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_tim_len
operator|=
name|timlen
expr_stmt|;
comment|/* update information element */
name|tie
operator|->
name|tim_len
operator|=
literal|3
operator|+
name|timlen
expr_stmt|;
name|tie
operator|->
name|tim_bitctl
operator|=
name|timoff
expr_stmt|;
name|len_changed
operator|=
literal|1
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tie
operator|->
name|tim_bitmap
argument_list|,
name|vap
operator|->
name|iv_tim_bitmap
operator|+
name|timoff
argument_list|,
name|bo
operator|->
name|bo_tim_len
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_TIM
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_POWER
argument_list|,
literal|"%s: TIM updated, pending %u, off %u, len %u\n"
argument_list|,
name|__func__
argument_list|,
name|vap
operator|->
name|iv_ps_pending
argument_list|,
name|timoff
argument_list|,
name|timlen
argument_list|)
expr_stmt|;
block|}
comment|/* count down DTIM period */
if|if
condition|(
name|tie
operator|->
name|tim_count
operator|==
literal|0
condition|)
name|tie
operator|->
name|tim_count
operator|=
name|tie
operator|->
name|tim_period
operator|-
literal|1
expr_stmt|;
else|else
name|tie
operator|->
name|tim_count
operator|--
expr_stmt|;
comment|/* update state for buffered multicast frames on DTIM */
if|if
condition|(
name|mcast
operator|&&
name|tie
operator|->
name|tim_count
operator|==
literal|0
condition|)
name|tie
operator|->
name|tim_bitctl
operator||=
literal|1
expr_stmt|;
else|else
name|tie
operator|->
name|tim_bitctl
operator|&=
operator|~
literal|1
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_CSA
argument_list|)
condition|)
block|{
name|struct
name|ieee80211_csa_ie
modifier|*
name|csa
init|=
operator|(
expr|struct
name|ieee80211_csa_ie
operator|*
operator|)
name|bo
operator|->
name|bo_csa
decl_stmt|;
comment|/* 			 * Insert or update CSA ie.  If we're just starting 			 * to count down to the channel switch then we need 			 * to insert the CSA ie.  Otherwise we just need to 			 * drop the count.  The actual change happens above 			 * when the vap's count reaches the target count. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_csa_count
operator|==
literal|0
condition|)
block|{
name|memmove
argument_list|(
operator|&
name|csa
index|[
literal|1
index|]
argument_list|,
name|csa
argument_list|,
name|bo
operator|->
name|bo_csa_trailer_len
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_erp
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_htinfo
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_wme
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|bo
operator|->
name|bo_ath
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|bo
operator|->
name|bo_tdma
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
name|bo
operator|->
name|bo_meshconf
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bo
operator|->
name|bo_appie
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_csa_trailer_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_quiet
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_tim_trailer_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|csa
argument_list|)
expr_stmt|;
name|ieee80211_add_csa
argument_list|(
name|bo
operator|->
name|bo_csa
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
else|else
name|csa
operator|->
name|csa_count
operator|--
expr_stmt|;
name|vap
operator|->
name|iv_csa_count
operator|++
expr_stmt|;
comment|/* NB: don't clear IEEE80211_BEACON_CSA */
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_DFS
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DFS
operator|)
condition|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_quiet
condition|)
name|ieee80211_add_quiet
argument_list|(
name|bo
operator|->
name|bo_quiet
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_ERP
argument_list|)
condition|)
block|{
comment|/* 			 * ERP element needs updating. 			 */
operator|(
name|void
operator|)
name|ieee80211_add_erp
argument_list|(
name|bo
operator|->
name|bo_erp
argument_list|,
name|ic
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_ERP
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_ATH
argument_list|)
condition|)
block|{
name|ieee80211_add_athcaps
argument_list|(
name|bo
operator|->
name|bo_ath
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_ATH
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_APPIE
argument_list|)
condition|)
block|{
specifier|const
name|struct
name|ieee80211_appie
modifier|*
name|aie
init|=
name|vap
operator|->
name|iv_appie_beacon
decl_stmt|;
name|int
name|aielen
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|aielen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aie
operator|!=
name|NULL
condition|)
name|aielen
operator|+=
name|aie
operator|->
name|ie_len
expr_stmt|;
if|if
condition|(
name|aielen
operator|!=
name|bo
operator|->
name|bo_appie_len
condition|)
block|{
comment|/* copy up/down trailer */
name|int
name|adjust
init|=
name|aielen
operator|-
name|bo
operator|->
name|bo_appie_len
decl_stmt|;
name|ovbcopy
argument_list|(
name|bo
operator|->
name|bo_tim_trailer
argument_list|,
name|bo
operator|->
name|bo_tim_trailer
operator|+
name|adjust
argument_list|,
name|bo
operator|->
name|bo_tim_trailer_len
argument_list|)
expr_stmt|;
name|bo
operator|->
name|bo_tim_trailer
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_appie
operator|+=
name|adjust
expr_stmt|;
name|bo
operator|->
name|bo_appie_len
operator|=
name|aielen
expr_stmt|;
name|len_changed
operator|=
literal|1
expr_stmt|;
block|}
name|frm
operator|=
name|bo
operator|->
name|bo_appie
expr_stmt|;
if|if
condition|(
name|aie
operator|!=
name|NULL
condition|)
name|frm
operator|=
name|add_appie
argument_list|(
name|frm
argument_list|,
name|aie
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_APPIE
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|len_changed
return|;
block|}
end_function

begin_comment
comment|/*  * Do Ethernet-LLC encapsulation for each payload in a fast frame  * tunnel encapsulation.  The frame is assumed to have an Ethernet  * header at the front that must be stripped before prepending the  * LLC followed by the Ethernet header passed in (with an Ethernet  * type that specifies the payload size).  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_ff_encap1
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|)
block|{
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|uint16_t
name|payload
decl_stmt|;
comment|/* XXX optimize by combining m_adj+M_PREPEND */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|payload
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* NB: w/o Ethernet header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for ether_header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ETHER_HEADER_COPY
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|eh
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|payload
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Complete an mbuf transmission.  *  * For now, this simply processes a completed frame after the  * driver has completed it's transmission and/or retransmission.  * It assumes the frame is an 802.11 encapsulated frame.  *  * Later on it will grow to become the exit path for a given frame  * from the driver and, depending upon how it's been encapsulated  * and already transmitted, it may end up doing A-MPDU retransmission,  * power save requeuing, etc.  *  * In order for the above to work, the driver entry point to this  * must not hold any driver locks.  Thus, the driver needs to delay  * any actual mbuf completion until it can release said locks.  *  * This frees the mbuf and if the mbuf has a node reference,  * the node reference will be freed.  */
end_comment

begin_function
name|void
name|ieee80211_tx_complete
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|status
parameter_list|)
block|{
if|if
condition|(
name|ni
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ni
operator|->
name|ni_vap
operator|->
name|iv_ifp
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OBYTES
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|)
expr_stmt|;
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_MCAST
condition|)
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OMCASTS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OERRORS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|m_flags
operator|&
name|M_TXCB
condition|)
name|ieee80211_process_callback
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

