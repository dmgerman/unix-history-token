begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002, 2003 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/bus.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_arp.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/if_ether.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Send a management frame to the specified node.  The node pointer  * must have a reference as the pointer will be passed to the driver  * and potentially held for a long time.  If the frame is successfully  * dispatched to the driver, then it is responsible for freeing the  * reference (and potentially free'ing up any associated storage).  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_mgmt_output
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|(
name|void
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Yech, hack alert!  We want to pass the node down to the 	 * driver's start routine.  If we don't do so then the start 	 * routine must immediately look it up again and that can 	 * cause a lock order reversal if, for example, this frame 	 * is being sent because the station is being timedout and 	 * the frame being sent is a DEAUTH message.  We could stick 	 * this in an m_tag and tack that on to the mbuf.  However 	 * that's rather expensive to do for every frame so instead 	 * we stuff it in the rcvif field since outbound frames do 	 * not (presently) use this. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
name|NULL
argument_list|,
operator|(
literal|"rcvif not null"
operator|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_MGT
operator||
name|type
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseq
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseq
operator|++
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
block|{
comment|/* avoid to print too many frames */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
name|ieee80211_debug
operator|>
literal|1
operator|||
endif|#
directive|endif
operator|(
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|!=
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"sending %s to %s on channel %u\n"
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
operator|(
name|type
operator|&
name|IEEE80211_FC0_SUBTYPE_MASK
operator|)
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_timer
operator|=
literal|1
expr_stmt|;
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Encapsulate an outbound data frame.  The mbuf chain is updated and  * a reference to the destination node is returned.  If an error is  * encountered NULL is returned and the node reference will also be NULL.  *   * NB: The caller is responsible for free'ing a returned node reference.  *     The convention is ic_bss is not reference counted; the caller must  *     maintain that.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_encap
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
modifier|*
name|pni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
operator|(
name|void
operator|*
operator|)
name|ifp
decl_stmt|;
name|struct
name|ether_header
name|eh
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|NULL
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
condition|)
block|{
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX statistic */
goto|goto
name|bad
goto|;
block|}
block|}
name|memcpy
argument_list|(
operator|&
name|eh
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_STA
condition|)
block|{
name|ni
operator|=
name|ieee80211_find_node
argument_list|(
name|ic
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * When not in station mode the 			 * destination address should always be 			 * in the node table unless this is a 			 * multicast/broadcast frame. 			 */
if|if
condition|(
operator|!
name|IEEE80211_IS_MULTICAST
argument_list|(
name|eh
operator|.
name|ether_dhost
argument_list|)
condition|)
block|{
comment|/* ic->ic_stats.st_tx_nonode++; XXX statistic */
goto|goto
name|bad
goto|;
block|}
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
block|}
block|}
else|else
name|ni
operator|=
name|ic
operator|->
name|ic_bss
expr_stmt|;
name|ni
operator|->
name|ni_inact
operator|=
literal|0
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|.
name|ether_type
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_DATA
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_dur
operator|=
literal|0
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_txseq
operator|<<
name|IEEE80211_SEQ_SEQ_SHIFT
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_txseq
operator|++
expr_stmt|;
switch|switch
condition|(
name|ic
operator|->
name|ic_opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_TODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
case|case
name|IEEE80211_M_AHDEMO
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_NODS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
name|IEEE80211_FC1_DIR_FROMDS
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|eh
operator|.
name|ether_dhost
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|eh
operator|.
name|ether_shost
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
goto|goto
name|bad
goto|;
block|}
operator|*
name|pni
operator|=
name|ni
expr_stmt|;
return|return
name|m
return|;
name|bad
label|:
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|&&
name|ni
operator|!=
name|ic
operator|->
name|ic_bss
condition|)
name|ieee80211_free_node
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
operator|*
name|pni
operator|=
name|NULL
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Add a supported rates element id to a frame.  */
end_comment

begin_function
name|u_int8_t
modifier|*
name|ieee80211_add_rates
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|nrates
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_RATES
expr_stmt|;
name|nrates
operator|=
name|rs
operator|->
name|rs_nrates
expr_stmt|;
if|if
condition|(
name|nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
name|nrates
operator|=
name|IEEE80211_RATE_SIZE
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|nrates
return|;
block|}
end_function

begin_comment
comment|/*  * Add an extended supported rates element id to a frame.  */
end_comment

begin_function
name|u_int8_t
modifier|*
name|ieee80211_add_xrates
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
parameter_list|)
block|{
comment|/* 	 * Add an extended supported rates element if operating in 11g mode. 	 */
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|>
name|IEEE80211_RATE_SIZE
condition|)
block|{
name|int
name|nrates
init|=
name|rs
operator|->
name|rs_nrates
operator|-
name|IEEE80211_RATE_SIZE
decl_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_XRATES
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|nrates
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|rs
operator|->
name|rs_rates
operator|+
name|IEEE80211_RATE_SIZE
argument_list|,
name|nrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|nrates
expr_stmt|;
block|}
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*   * Add an ssid elemet to a frame.  */
end_comment

begin_function
specifier|static
name|u_int8_t
modifier|*
name|ieee80211_add_ssid
parameter_list|(
name|u_int8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ssid
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_SSID
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|len
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
name|ssid
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|frm
operator|+
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ieee80211_getmbuf
parameter_list|(
name|int
name|flags
parameter_list|,
name|int
name|type
parameter_list|,
name|u_int
name|pktlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|KASSERT
argument_list|(
name|pktlen
operator|<=
name|MCLBYTES
argument_list|,
operator|(
literal|"802.11 packet too large: %u"
operator|,
name|pktlen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktlen
operator|<=
name|MHLEN
condition|)
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|flags
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|m
operator|=
name|m_getcl
argument_list|(
name|flags
argument_list|,
name|type
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Send a management frame.  The node is for the destination (or ic_bss  * when in station mode).  Nodes other than ic_bss have their reference  * count bumped to reflect our use for an indeterminant time.  */
end_comment

begin_function
name|int
name|ieee80211_send_mgmt
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|)
value|do { ret = _x; goto bad; } while (0)
name|struct
name|ifnet
modifier|*
name|ifp
init|=
operator|&
name|ic
operator|->
name|ic_if
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int8_t
modifier|*
name|frm
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|u_int16_t
name|capinfo
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|timer
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
if|if
condition|(
name|ni
operator|!=
name|ic
operator|->
name|ic_bss
condition|)
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|timer
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_REQ
case|:
comment|/* 		 * prreq frame format 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 */
name|m
operator|=
name|ieee80211_getmbuf
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|2
operator|+
name|ic
operator|->
name|ic_des_esslen
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|frm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_des_essid
argument_list|,
name|ic
operator|->
name|ic_des_esslen
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|timer
operator|=
name|IEEE80211_TRANS_WAIT
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_PROBE_RESP
case|:
comment|/* 		 * probe response frame format 		 *	[8] time stamp 		 *	[2] beacon interval 		 *	[2] cabability information 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] parameter set (IBSS) 		 *	[tlv] extended supported rates 		 */
name|m
operator|=
name|ieee80211_getmbuf
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
literal|8
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_esslen
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|6
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|frm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* timestamp should be filled later */
name|frm
operator|+=
literal|8
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_bss
operator|->
name|ni_intval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|capinfo
operator|=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
else|else
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_essid
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_IBSSPARMS
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|2
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* TODO: ATIM window */
block|}
else|else
block|{
comment|/* IEEE80211_M_HOSTAP */
comment|/* TODO: TIM */
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_ELEMID_TIM
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
literal|4
expr_stmt|;
comment|/* length */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* DTIM count */
operator|*
name|frm
operator|++
operator|=
literal|1
expr_stmt|;
comment|/* DTIM period */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* bitmap control */
operator|*
name|frm
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* Partial Virtual Bitmap (variable length) */
block|}
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ic
operator|->
name|ic_bss
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_AUTH
case|:
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
literal|2
operator|*
literal|3
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|6
expr_stmt|;
name|frm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
comment|/* TODO: shared key auth */
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|0
index|]
operator|=
name|htole16
argument_list|(
name|IEEE80211_AUTH_ALG_OPEN
argument_list|)
expr_stmt|;
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|1
index|]
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* sequence number */
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|)
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* status */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|timer
operator|=
name|IEEE80211_TRANS_WAIT
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DEAUTH
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"station %s deauthenticate (reason %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|2
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_REQ
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
case|:
comment|/* 		 * asreq frame format 		 *	[2] capability information 		 *	[2] listen interval 		 *	[6*] current AP address (reassoc only) 		 *	[tlv] ssid 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 */
name|m
operator|=
name|ieee80211_getmbuf
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
sizeof|sizeof
argument_list|(
name|capinfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
name|IEEE80211_ADDR_LEN
operator|+
literal|2
operator|+
name|ni
operator|->
name|ni_esslen
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|frm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|capinfo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_IBSS
expr_stmt|;
else|else
comment|/* IEEE80211_M_STA */
name|capinfo
operator||=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHPREAMBLE
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_PREAMBLE
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SHSLOT
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_SHORT_SLOTTIME
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ic
operator|->
name|ic_lintval
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|IEEE80211_FC0_SUBTYPE_REASSOC_REQ
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|frm
argument_list|,
name|ic
operator|->
name|ic_bss
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|IEEE80211_ADDR_LEN
expr_stmt|;
block|}
name|frm
operator|=
name|ieee80211_add_ssid
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_essid
argument_list|,
name|ni
operator|->
name|ni_esslen
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|timer
operator|=
name|IEEE80211_TRANS_WAIT
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_ASSOC_RESP
case|:
case|case
name|IEEE80211_FC0_SUBTYPE_REASSOC_RESP
case|:
comment|/* 		 * asreq frame format 		 *	[2] capability information 		 *	[2] status 		 *	[2] association ID 		 *	[tlv] supported rates 		 *	[tlv] extended supported rates 		 */
name|m
operator|=
name|ieee80211_getmbuf
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
sizeof|sizeof
argument_list|(
name|capinfo
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|+
literal|2
operator|+
name|IEEE80211_RATE_SIZE
operator|+
literal|2
operator|+
operator|(
name|IEEE80211_RATE_MAXSIZE
operator|-
name|IEEE80211_RATE_SIZE
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_data
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
expr_stmt|;
name|frm
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|capinfo
operator|=
name|IEEE80211_CAPINFO_ESS
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_WEPON
condition|)
name|capinfo
operator||=
name|IEEE80211_CAPINFO_PRIVACY
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|capinfo
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* status */
name|frm
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|arg
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
operator|*
operator|(
name|u_int16_t
operator|*
operator|)
name|frm
operator|=
name|htole16
argument_list|(
name|ni
operator|->
name|ni_associd
argument_list|)
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_rates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|frm
operator|=
name|ieee80211_add_xrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_rates
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC0_SUBTYPE_DISASSOC
case|:
if|if
condition|(
name|ifp
operator|->
name|if_flags
operator|&
name|IFF_DEBUG
condition|)
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"station %s disassociate (reason %d)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|MGETHDR
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
literal|2
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int16_t
operator|*
argument_list|)
operator|=
name|htole16
argument_list|(
name|arg
argument_list|)
expr_stmt|;
comment|/* reason */
break|break;
default|default:
name|IEEE80211_DPRINTF
argument_list|(
operator|(
literal|"%s: invalid mgmt frame type %u\n"
operator|,
name|__func__
operator|,
name|type
operator|)
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|ret
operator|=
name|ieee80211_mgmt_output
argument_list|(
name|ifp
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|timer
condition|)
name|ic
operator|->
name|ic_mgt_timer
operator|=
name|timer
expr_stmt|;
block|}
else|else
block|{
name|bad
label|:
if|if
condition|(
name|ni
operator|!=
name|ic
operator|->
name|ic_bss
condition|)
comment|/* remove ref we added */
name|ieee80211_free_node
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
undef|#
directive|undef
name|senderr
block|}
end_function

end_unit

