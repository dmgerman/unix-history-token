begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 WEP crypto support.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_function_decl
specifier|static
name|void
modifier|*
name|wep_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wep_detach
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wep_setkey
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wep_encap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|uint8_t
name|keyid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wep_decap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
name|hdrlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wep_enmic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wep_demic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_cipher
name|wep
init|=
block|{
operator|.
name|ic_name
operator|=
literal|"WEP"
block|,
operator|.
name|ic_cipher
operator|=
name|IEEE80211_CIPHER_WEP
block|,
operator|.
name|ic_header
operator|=
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
block|,
operator|.
name|ic_trailer
operator|=
name|IEEE80211_WEP_CRCLEN
block|,
operator|.
name|ic_miclen
operator|=
literal|0
block|,
operator|.
name|ic_attach
operator|=
name|wep_attach
block|,
operator|.
name|ic_detach
operator|=
name|wep_detach
block|,
operator|.
name|ic_setkey
operator|=
name|wep_setkey
block|,
operator|.
name|ic_encap
operator|=
name|wep_encap
block|,
operator|.
name|ic_decap
operator|=
name|wep_decap
block|,
operator|.
name|ic_enmic
operator|=
name|wep_enmic
block|,
operator|.
name|ic_demic
operator|=
name|wep_demic
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|wep_encrypt
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
name|hdrlen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|wep_decrypt
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
name|hdrlen
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|wep_ctx
block|{
name|struct
name|ieee80211com
modifier|*
name|wc_ic
decl_stmt|;
comment|/* for diagnostics */
name|uint32_t
name|wc_iv
decl_stmt|;
comment|/* initial vector for crypto */
block|}
struct|;
end_struct

begin_comment
comment|/* number of references from net80211 layer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrefs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|wep_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|wep_ctx
modifier|*
name|ctx
decl_stmt|;
name|MALLOC
argument_list|(
name|ctx
argument_list|,
expr|struct
name|wep_ctx
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wep_ctx
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_nomem
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|wc_ic
operator|=
name|ic
expr_stmt|;
name|get_random_bytes
argument_list|(
operator|&
name|ctx
operator|->
name|wc_iv
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
operator|->
name|wc_iv
argument_list|)
argument_list|)
expr_stmt|;
name|nrefs
operator|++
expr_stmt|;
comment|/* NB: we assume caller locking */
return|return
name|ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wep_detach
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|wep_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
name|FREE
argument_list|(
name|ctx
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nrefs
operator|>
literal|0
argument_list|,
operator|(
literal|"imbalanced attach/detach"
operator|)
argument_list|)
expr_stmt|;
name|nrefs
operator|--
expr_stmt|;
comment|/* NB: we assume caller locking */
block|}
end_function

begin_function
specifier|static
name|int
name|wep_setkey
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
return|return
name|k
operator|->
name|wk_keylen
operator|>=
literal|40
operator|/
name|NBBY
return|;
block|}
end_function

begin_comment
comment|/*  * Add privacy headers appropriate for the specified key.  */
end_comment

begin_function
specifier|static
name|int
name|wep_encap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|uint8_t
name|keyid
parameter_list|)
block|{
name|struct
name|wep_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ctx
operator|->
name|wc_ic
decl_stmt|;
name|uint32_t
name|iv
decl_stmt|;
name|uint8_t
modifier|*
name|ivp
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|hdrlen
operator|=
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy down 802.11 header and add the IV + KeyID. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|wep
operator|.
name|ic_header
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ivp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|ovbcopy
argument_list|(
name|ivp
operator|+
name|wep
operator|.
name|ic_header
argument_list|,
name|ivp
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|ivp
operator|+=
name|hdrlen
expr_stmt|;
comment|/* 	 * XXX 	 * IV must not duplicate during the lifetime of the key. 	 * But no mechanism to renew keys is defined in IEEE 802.11 	 * for WEP.  And the IV may be duplicated at other stations 	 * because the session key itself is shared.  So we use a 	 * pseudo random IV for now, though it is not the right way. 	 * 	 * NB: Rather than use a strictly random IV we select a 	 * random one to start and then increment the value for 	 * each frame.  This is an explicit tradeoff between 	 * overhead and security.  Given the basic insecurity of 	 * WEP this seems worthwhile. 	 */
comment|/* 	 * Skip 'bad' IVs from Fluhrer/Mantin/Shamir: 	 * (B, 255, N) with 3<= B< 16 and 0<= N<= 255 	 */
name|iv
operator|=
name|ctx
operator|->
name|wc_iv
expr_stmt|;
if|if
condition|(
operator|(
name|iv
operator|&
literal|0xff00
operator|)
operator|==
literal|0xff00
condition|)
block|{
name|int
name|B
init|=
operator|(
name|iv
operator|&
literal|0xff0000
operator|)
operator|>>
literal|16
decl_stmt|;
if|if
condition|(
literal|3
operator|<=
name|B
operator|&&
name|B
operator|<
literal|16
condition|)
name|iv
operator|+=
literal|0x0100
expr_stmt|;
block|}
name|ctx
operator|->
name|wc_iv
operator|=
name|iv
operator|+
literal|1
expr_stmt|;
comment|/* 	 * NB: Preserve byte order of IV for packet 	 *     sniffers; it doesn't matter otherwise. 	 */
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
name|ivp
index|[
literal|0
index|]
operator|=
name|iv
operator|>>
literal|0
expr_stmt|;
name|ivp
index|[
literal|1
index|]
operator|=
name|iv
operator|>>
literal|8
expr_stmt|;
name|ivp
index|[
literal|2
index|]
operator|=
name|iv
operator|>>
literal|16
expr_stmt|;
else|#
directive|else
name|ivp
index|[
literal|2
index|]
operator|=
name|iv
operator|>>
literal|0
expr_stmt|;
name|ivp
index|[
literal|1
index|]
operator|=
name|iv
operator|>>
literal|8
expr_stmt|;
name|ivp
index|[
literal|0
index|]
operator|=
name|iv
operator|>>
literal|16
expr_stmt|;
endif|#
directive|endif
name|ivp
index|[
literal|3
index|]
operator|=
name|keyid
expr_stmt|;
comment|/* 	 * Finally, do software encrypt if neeed. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|&&
operator|!
name|wep_encrypt
argument_list|(
name|k
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Add MIC to the frame as needed.  */
end_comment

begin_function
specifier|static
name|int
name|wep_enmic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|force
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Validate and strip privacy headers (and trailer) for a  * received frame.  If necessary, decrypt the frame using  * the specified key.  */
end_comment

begin_function
specifier|static
name|int
name|wep_decap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
name|struct
name|wep_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the device handled the decrypt in hardware. 	 * If so we just strip the header; otherwise we need to 	 * handle the decrypt in software. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|&&
operator|!
name|wep_decrypt
argument_list|(
name|k
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|)
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ctx
operator|->
name|wc_ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] WEP ICV mismatch on decrypt\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|wc_ic
operator|->
name|ic_stats
operator|.
name|is_rx_wepfail
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Copy up 802.11 header and strip crypto bits. 	 */
name|ovbcopy
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|wep
operator|.
name|ic_header
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|wep
operator|.
name|ic_header
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|wep
operator|.
name|ic_trailer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Verify and strip MIC from the frame.  */
end_comment

begin_function
specifier|static
name|int
name|wep_demic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|skb
parameter_list|,
name|int
name|force
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|crc32_table
index|[
literal|256
index|]
init|=
block|{
literal|0x00000000L
block|,
literal|0x77073096L
block|,
literal|0xee0e612cL
block|,
literal|0x990951baL
block|,
literal|0x076dc419L
block|,
literal|0x706af48fL
block|,
literal|0xe963a535L
block|,
literal|0x9e6495a3L
block|,
literal|0x0edb8832L
block|,
literal|0x79dcb8a4L
block|,
literal|0xe0d5e91eL
block|,
literal|0x97d2d988L
block|,
literal|0x09b64c2bL
block|,
literal|0x7eb17cbdL
block|,
literal|0xe7b82d07L
block|,
literal|0x90bf1d91L
block|,
literal|0x1db71064L
block|,
literal|0x6ab020f2L
block|,
literal|0xf3b97148L
block|,
literal|0x84be41deL
block|,
literal|0x1adad47dL
block|,
literal|0x6ddde4ebL
block|,
literal|0xf4d4b551L
block|,
literal|0x83d385c7L
block|,
literal|0x136c9856L
block|,
literal|0x646ba8c0L
block|,
literal|0xfd62f97aL
block|,
literal|0x8a65c9ecL
block|,
literal|0x14015c4fL
block|,
literal|0x63066cd9L
block|,
literal|0xfa0f3d63L
block|,
literal|0x8d080df5L
block|,
literal|0x3b6e20c8L
block|,
literal|0x4c69105eL
block|,
literal|0xd56041e4L
block|,
literal|0xa2677172L
block|,
literal|0x3c03e4d1L
block|,
literal|0x4b04d447L
block|,
literal|0xd20d85fdL
block|,
literal|0xa50ab56bL
block|,
literal|0x35b5a8faL
block|,
literal|0x42b2986cL
block|,
literal|0xdbbbc9d6L
block|,
literal|0xacbcf940L
block|,
literal|0x32d86ce3L
block|,
literal|0x45df5c75L
block|,
literal|0xdcd60dcfL
block|,
literal|0xabd13d59L
block|,
literal|0x26d930acL
block|,
literal|0x51de003aL
block|,
literal|0xc8d75180L
block|,
literal|0xbfd06116L
block|,
literal|0x21b4f4b5L
block|,
literal|0x56b3c423L
block|,
literal|0xcfba9599L
block|,
literal|0xb8bda50fL
block|,
literal|0x2802b89eL
block|,
literal|0x5f058808L
block|,
literal|0xc60cd9b2L
block|,
literal|0xb10be924L
block|,
literal|0x2f6f7c87L
block|,
literal|0x58684c11L
block|,
literal|0xc1611dabL
block|,
literal|0xb6662d3dL
block|,
literal|0x76dc4190L
block|,
literal|0x01db7106L
block|,
literal|0x98d220bcL
block|,
literal|0xefd5102aL
block|,
literal|0x71b18589L
block|,
literal|0x06b6b51fL
block|,
literal|0x9fbfe4a5L
block|,
literal|0xe8b8d433L
block|,
literal|0x7807c9a2L
block|,
literal|0x0f00f934L
block|,
literal|0x9609a88eL
block|,
literal|0xe10e9818L
block|,
literal|0x7f6a0dbbL
block|,
literal|0x086d3d2dL
block|,
literal|0x91646c97L
block|,
literal|0xe6635c01L
block|,
literal|0x6b6b51f4L
block|,
literal|0x1c6c6162L
block|,
literal|0x856530d8L
block|,
literal|0xf262004eL
block|,
literal|0x6c0695edL
block|,
literal|0x1b01a57bL
block|,
literal|0x8208f4c1L
block|,
literal|0xf50fc457L
block|,
literal|0x65b0d9c6L
block|,
literal|0x12b7e950L
block|,
literal|0x8bbeb8eaL
block|,
literal|0xfcb9887cL
block|,
literal|0x62dd1ddfL
block|,
literal|0x15da2d49L
block|,
literal|0x8cd37cf3L
block|,
literal|0xfbd44c65L
block|,
literal|0x4db26158L
block|,
literal|0x3ab551ceL
block|,
literal|0xa3bc0074L
block|,
literal|0xd4bb30e2L
block|,
literal|0x4adfa541L
block|,
literal|0x3dd895d7L
block|,
literal|0xa4d1c46dL
block|,
literal|0xd3d6f4fbL
block|,
literal|0x4369e96aL
block|,
literal|0x346ed9fcL
block|,
literal|0xad678846L
block|,
literal|0xda60b8d0L
block|,
literal|0x44042d73L
block|,
literal|0x33031de5L
block|,
literal|0xaa0a4c5fL
block|,
literal|0xdd0d7cc9L
block|,
literal|0x5005713cL
block|,
literal|0x270241aaL
block|,
literal|0xbe0b1010L
block|,
literal|0xc90c2086L
block|,
literal|0x5768b525L
block|,
literal|0x206f85b3L
block|,
literal|0xb966d409L
block|,
literal|0xce61e49fL
block|,
literal|0x5edef90eL
block|,
literal|0x29d9c998L
block|,
literal|0xb0d09822L
block|,
literal|0xc7d7a8b4L
block|,
literal|0x59b33d17L
block|,
literal|0x2eb40d81L
block|,
literal|0xb7bd5c3bL
block|,
literal|0xc0ba6cadL
block|,
literal|0xedb88320L
block|,
literal|0x9abfb3b6L
block|,
literal|0x03b6e20cL
block|,
literal|0x74b1d29aL
block|,
literal|0xead54739L
block|,
literal|0x9dd277afL
block|,
literal|0x04db2615L
block|,
literal|0x73dc1683L
block|,
literal|0xe3630b12L
block|,
literal|0x94643b84L
block|,
literal|0x0d6d6a3eL
block|,
literal|0x7a6a5aa8L
block|,
literal|0xe40ecf0bL
block|,
literal|0x9309ff9dL
block|,
literal|0x0a00ae27L
block|,
literal|0x7d079eb1L
block|,
literal|0xf00f9344L
block|,
literal|0x8708a3d2L
block|,
literal|0x1e01f268L
block|,
literal|0x6906c2feL
block|,
literal|0xf762575dL
block|,
literal|0x806567cbL
block|,
literal|0x196c3671L
block|,
literal|0x6e6b06e7L
block|,
literal|0xfed41b76L
block|,
literal|0x89d32be0L
block|,
literal|0x10da7a5aL
block|,
literal|0x67dd4accL
block|,
literal|0xf9b9df6fL
block|,
literal|0x8ebeeff9L
block|,
literal|0x17b7be43L
block|,
literal|0x60b08ed5L
block|,
literal|0xd6d6a3e8L
block|,
literal|0xa1d1937eL
block|,
literal|0x38d8c2c4L
block|,
literal|0x4fdff252L
block|,
literal|0xd1bb67f1L
block|,
literal|0xa6bc5767L
block|,
literal|0x3fb506ddL
block|,
literal|0x48b2364bL
block|,
literal|0xd80d2bdaL
block|,
literal|0xaf0a1b4cL
block|,
literal|0x36034af6L
block|,
literal|0x41047a60L
block|,
literal|0xdf60efc3L
block|,
literal|0xa867df55L
block|,
literal|0x316e8eefL
block|,
literal|0x4669be79L
block|,
literal|0xcb61b38cL
block|,
literal|0xbc66831aL
block|,
literal|0x256fd2a0L
block|,
literal|0x5268e236L
block|,
literal|0xcc0c7795L
block|,
literal|0xbb0b4703L
block|,
literal|0x220216b9L
block|,
literal|0x5505262fL
block|,
literal|0xc5ba3bbeL
block|,
literal|0xb2bd0b28L
block|,
literal|0x2bb45a92L
block|,
literal|0x5cb36a04L
block|,
literal|0xc2d7ffa7L
block|,
literal|0xb5d0cf31L
block|,
literal|0x2cd99e8bL
block|,
literal|0x5bdeae1dL
block|,
literal|0x9b64c2b0L
block|,
literal|0xec63f226L
block|,
literal|0x756aa39cL
block|,
literal|0x026d930aL
block|,
literal|0x9c0906a9L
block|,
literal|0xeb0e363fL
block|,
literal|0x72076785L
block|,
literal|0x05005713L
block|,
literal|0x95bf4a82L
block|,
literal|0xe2b87a14L
block|,
literal|0x7bb12baeL
block|,
literal|0x0cb61b38L
block|,
literal|0x92d28e9bL
block|,
literal|0xe5d5be0dL
block|,
literal|0x7cdcefb7L
block|,
literal|0x0bdbdf21L
block|,
literal|0x86d3d2d4L
block|,
literal|0xf1d4e242L
block|,
literal|0x68ddb3f8L
block|,
literal|0x1fda836eL
block|,
literal|0x81be16cdL
block|,
literal|0xf6b9265bL
block|,
literal|0x6fb077e1L
block|,
literal|0x18b74777L
block|,
literal|0x88085ae6L
block|,
literal|0xff0f6a70L
block|,
literal|0x66063bcaL
block|,
literal|0x11010b5cL
block|,
literal|0x8f659effL
block|,
literal|0xf862ae69L
block|,
literal|0x616bffd3L
block|,
literal|0x166ccf45L
block|,
literal|0xa00ae278L
block|,
literal|0xd70dd2eeL
block|,
literal|0x4e048354L
block|,
literal|0x3903b3c2L
block|,
literal|0xa7672661L
block|,
literal|0xd06016f7L
block|,
literal|0x4969474dL
block|,
literal|0x3e6e77dbL
block|,
literal|0xaed16a4aL
block|,
literal|0xd9d65adcL
block|,
literal|0x40df0b66L
block|,
literal|0x37d83bf0L
block|,
literal|0xa9bcae53L
block|,
literal|0xdebb9ec5L
block|,
literal|0x47b2cf7fL
block|,
literal|0x30b5ffe9L
block|,
literal|0xbdbdf21cL
block|,
literal|0xcabac28aL
block|,
literal|0x53b39330L
block|,
literal|0x24b4a3a6L
block|,
literal|0xbad03605L
block|,
literal|0xcdd70693L
block|,
literal|0x54de5729L
block|,
literal|0x23d967bfL
block|,
literal|0xb3667a2eL
block|,
literal|0xc4614ab8L
block|,
literal|0x5d681b02L
block|,
literal|0x2a6f2b94L
block|,
literal|0xb40bbe37L
block|,
literal|0xc30c8ea1L
block|,
literal|0x5a05df1bL
block|,
literal|0x2d02ef8dL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|wep_encrypt
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
define|#
directive|define
name|S_SWAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { uint8_t t = S[a]; S[a] = S[b]; S[b] = t; } while(0)
name|struct
name|wep_ctx
modifier|*
name|ctx
init|=
name|key
operator|->
name|wk_private
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|uint8_t
name|rc4key
index|[
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_KEYBUF_SIZE
index|]
decl_stmt|;
name|uint8_t
name|icv
index|[
name|IEEE80211_WEP_CRCLEN
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|crc
decl_stmt|;
name|size_t
name|buflen
decl_stmt|,
name|data_len
decl_stmt|;
name|uint8_t
name|S
index|[
literal|256
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|pos
decl_stmt|;
name|u_int
name|off
decl_stmt|,
name|keylen
decl_stmt|;
name|ctx
operator|->
name|wc_ic
operator|->
name|ic_stats
operator|.
name|is_crypto_wep
operator|++
expr_stmt|;
comment|/* NB: this assumes the header was pulled up */
name|memcpy
argument_list|(
name|rc4key
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrlen
argument_list|,
name|IEEE80211_WEP_IVLEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rc4key
operator|+
name|IEEE80211_WEP_IVLEN
argument_list|,
name|key
operator|->
name|wk_key
argument_list|,
name|key
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
comment|/* Setup RC4 state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|S
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|keylen
operator|=
name|key
operator|->
name|wk_keylen
operator|+
name|IEEE80211_WEP_IVLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|+
name|rc4key
index|[
name|i
operator|%
name|keylen
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|off
operator|=
name|hdrlen
operator|+
name|wep
operator|.
name|ic_header
expr_stmt|;
name|data_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|off
expr_stmt|;
comment|/* Compute CRC32 over unencrypted data and apply RC4 to data */
name|crc
operator|=
operator|~
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
operator|-
name|off
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|buflen
operator|>
name|data_len
condition|)
name|buflen
operator|=
name|data_len
expr_stmt|;
name|data_len
operator|-=
name|buflen
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|buflen
condition|;
name|k
operator|++
control|)
block|{
name|crc
operator|=
name|crc32_table
index|[
operator|(
name|crc
operator|^
operator|*
name|pos
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|^=
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|->
name|m_next
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|data_len
operator|!=
literal|0
condition|)
block|{
comment|/* out of data */
name|IEEE80211_DPRINTF
argument_list|(
name|ctx
operator|->
name|wc_ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] out of data for WEP (data_len %zu)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
operator|->
name|i_addr2
argument_list|)
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
comment|/* Append little-endian CRC32 and encrypt it to produce ICV */
name|icv
index|[
literal|0
index|]
operator|=
name|crc
expr_stmt|;
name|icv
index|[
literal|1
index|]
operator|=
name|crc
operator|>>
literal|8
expr_stmt|;
name|icv
index|[
literal|2
index|]
operator|=
name|crc
operator|>>
literal|16
expr_stmt|;
name|icv
index|[
literal|3
index|]
operator|=
name|crc
operator|>>
literal|24
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IEEE80211_WEP_CRCLEN
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|icv
index|[
name|k
index|]
operator|^=
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
block|}
return|return
name|m_append
argument_list|(
name|m0
argument_list|,
name|IEEE80211_WEP_CRCLEN
argument_list|,
name|icv
argument_list|)
return|;
undef|#
directive|undef
name|S_SWAP
block|}
end_function

begin_function
specifier|static
name|int
name|wep_decrypt
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
define|#
directive|define
name|S_SWAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { uint8_t t = S[a]; S[a] = S[b]; S[b] = t; } while(0)
name|struct
name|wep_ctx
modifier|*
name|ctx
init|=
name|key
operator|->
name|wk_private
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|m0
decl_stmt|;
name|uint8_t
name|rc4key
index|[
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_KEYBUF_SIZE
index|]
decl_stmt|;
name|uint8_t
name|icv
index|[
name|IEEE80211_WEP_CRCLEN
index|]
decl_stmt|;
name|uint32_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|crc
decl_stmt|;
name|size_t
name|buflen
decl_stmt|,
name|data_len
decl_stmt|;
name|uint8_t
name|S
index|[
literal|256
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|pos
decl_stmt|;
name|u_int
name|off
decl_stmt|,
name|keylen
decl_stmt|;
name|ctx
operator|->
name|wc_ic
operator|->
name|ic_stats
operator|.
name|is_crypto_wep
operator|++
expr_stmt|;
comment|/* NB: this assumes the header was pulled up */
name|memcpy
argument_list|(
name|rc4key
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrlen
argument_list|,
name|IEEE80211_WEP_IVLEN
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rc4key
operator|+
name|IEEE80211_WEP_IVLEN
argument_list|,
name|key
operator|->
name|wk_key
argument_list|,
name|key
operator|->
name|wk_keylen
argument_list|)
expr_stmt|;
comment|/* Setup RC4 state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|S
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
name|keylen
operator|=
name|key
operator|->
name|wk_keylen
operator|+
name|IEEE80211_WEP_IVLEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|+
name|rc4key
index|[
name|i
operator|%
name|keylen
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
name|off
operator|=
name|hdrlen
operator|+
name|wep
operator|.
name|ic_header
expr_stmt|;
name|data_len
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|off
operator|+
name|wep
operator|.
name|ic_trailer
operator|)
operator|,
comment|/* Compute CRC32 over unencrypted data and apply RC4 to data */
name|crc
operator|=
operator|~
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
operator|-
name|off
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|buflen
operator|>
name|data_len
condition|)
name|buflen
operator|=
name|data_len
expr_stmt|;
name|data_len
operator|-=
name|buflen
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|buflen
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|^=
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
name|crc
operator|=
name|crc32_table
index|[
operator|(
name|crc
operator|^
operator|*
name|pos
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|data_len
operator|!=
literal|0
condition|)
block|{
comment|/* out of data */
name|IEEE80211_DPRINTF
argument_list|(
name|ctx
operator|->
name|wc_ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] out of data for WEP (data_len %zu)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
operator|->
name|i_addr2
argument_list|)
argument_list|,
name|data_len
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
break|break;
block|}
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
comment|/* Encrypt little-endian CRC32 and verify that it matches with 	 * received ICV */
name|icv
index|[
literal|0
index|]
operator|=
name|crc
expr_stmt|;
name|icv
index|[
literal|1
index|]
operator|=
name|crc
operator|>>
literal|8
expr_stmt|;
name|icv
index|[
literal|2
index|]
operator|=
name|crc
operator|>>
literal|16
expr_stmt|;
name|icv
index|[
literal|3
index|]
operator|=
name|crc
operator|>>
literal|24
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IEEE80211_WEP_CRCLEN
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
comment|/* XXX assumes ICV is contiguous in mbuf */
if|if
condition|(
operator|(
name|icv
index|[
name|k
index|]
operator|^
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
operator|)
operator|!=
operator|*
name|pos
operator|++
condition|)
block|{
comment|/* ICV mismatch - drop frame */
return|return
literal|0
return|;
block|}
block|}
return|return
literal|1
return|;
undef|#
directive|undef
name|S_SWAP
block|}
end_function

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_expr_stmt
name|IEEE80211_CRYPTO_MODULE
argument_list|(
name|wep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

