begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2009 Sam Leffler, Errno Consulting  * Copyright (c) 2007-2009 Intel Corporation  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11 TDMA mode support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_tdma.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_SLOTLEN_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_SLOTLEN_DEFAULT
value|10*1000
end_define

begin_comment
comment|/* 10ms */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_SLOTCNT_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_SLOTCNT_DEFAULT
value|2
end_define

begin_comment
comment|/* 2x (pt-to-pt) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_BINTVAL_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_BINTVAL_DEFAULT
value|5
end_define

begin_comment
comment|/* 5x ~= 100TU beacon intvl */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_11B_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_11B_DEFAULT
value|2*11
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_11G_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_11G_DEFAULT
value|2*24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_11A_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_11A_DEFAULT
value|2*24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_TURBO_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_TURBO_DEFAULT
value|2*24
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_HALF_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_HALF_DEFAULT
value|2*12
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_QUARTER_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_QUARTER_DEFAULT
value|2*6
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_11NA_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_11NA_DEFAULT
value|(4 | IEEE80211_RATE_MCS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|TDMA_TXRATE_11NG_DEFAULT
end_ifndef

begin_define
define|#
directive|define
name|TDMA_TXRATE_11NG_DEFAULT
value|(4 | IEEE80211_RATE_MCS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|TDMA_VERSION_VALID
parameter_list|(
name|_version
parameter_list|)
define|\
value|(TDMA_VERSION_V2<= (_version)&& (_version)<= TDMA_VERSION)
end_define

begin_define
define|#
directive|define
name|TDMA_SLOTCNT_VALID
parameter_list|(
name|_slotcnt
parameter_list|)
define|\
value|(2<= (_slotcnt)&& (_slotcnt)<= TDMA_MAXSLOTS)
end_define

begin_comment
comment|/* XXX magic constants */
end_comment

begin_define
define|#
directive|define
name|TDMA_SLOTLEN_VALID
parameter_list|(
name|_slotlen
parameter_list|)
define|\
value|(2*100<= (_slotlen)&& (unsigned)(_slotlen)<= 0xfffff)
end_define

begin_comment
comment|/* XXX probably should set a max */
end_comment

begin_define
define|#
directive|define
name|TDMA_BINTVAL_VALID
parameter_list|(
name|_bintval
parameter_list|)
value|(1<= (_bintval))
end_define

begin_comment
comment|/*  * This code is not prepared to handle more than 2 slots.  */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|TDMA_MAXSLOTS
operator|==
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|void
name|tdma_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tdma_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
name|enum
name|ieee80211_state
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tdma_beacon_miss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tdma_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tdma_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|pickslot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tdma_process_params
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ie
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|settxparms
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
name|int
name|rate
parameter_list|)
block|{
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
operator|.
name|ucastrate
operator|=
name|rate
expr_stmt|;
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
operator|.
name|mcastrate
operator|=
name|rate
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setackpolicy
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|noack
parameter_list|)
block|{
name|struct
name|ieee80211_wme_state
modifier|*
name|wme
init|=
operator|&
name|ic
operator|->
name|ic_wme
decl_stmt|;
name|int
name|ac
decl_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|wme
operator|->
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_noackPolicy
operator|=
name|noack
expr_stmt|;
name|wme
operator|->
name|wme_wmeChanParams
operator|.
name|cap_wmeParams
index|[
name|ac
index|]
operator|.
name|wmep_noackPolicy
operator|=
name|noack
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_tdma_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not a tdma vap, caps 0x%x"
operator|,
name|vap
operator|->
name|iv_caps
operator|)
argument_list|)
expr_stmt|;
name|ts
operator|=
operator|(
expr|struct
name|ieee80211_tdma_state
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_tdma_state
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot allocate TDMA state block\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* NB: fall back to adhdemo mode */
name|vap
operator|->
name|iv_caps
operator|&=
operator|~
name|IEEE80211_C_TDMA
expr_stmt|;
return|return;
block|}
comment|/* NB: default configuration is passive so no beacons */
name|ts
operator|->
name|tdma_version
operator|=
name|TDMA_VERSION
expr_stmt|;
name|ts
operator|->
name|tdma_slotlen
operator|=
name|TDMA_SLOTLEN_DEFAULT
expr_stmt|;
name|ts
operator|->
name|tdma_slotcnt
operator|=
name|TDMA_SLOTCNT_DEFAULT
expr_stmt|;
name|ts
operator|->
name|tdma_bintval
operator|=
name|TDMA_BINTVAL_DEFAULT
expr_stmt|;
name|ts
operator|->
name|tdma_slot
operator|=
literal|1
expr_stmt|;
comment|/* passive operation */
comment|/* setup default fixed rates */
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_11A
argument_list|,
name|TDMA_TXRATE_11A_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_11B
argument_list|,
name|TDMA_TXRATE_11B_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_11G
argument_list|,
name|TDMA_TXRATE_11G_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_TURBO_A
argument_list|,
name|TDMA_TXRATE_TURBO_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_TURBO_G
argument_list|,
name|TDMA_TXRATE_TURBO_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_STURBO_A
argument_list|,
name|TDMA_TXRATE_TURBO_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|,
name|TDMA_TXRATE_11NA_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|,
name|TDMA_TXRATE_11NG_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_HALF
argument_list|,
name|TDMA_TXRATE_HALF_DEFAULT
argument_list|)
expr_stmt|;
name|settxparms
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MODE_QUARTER
argument_list|,
name|TDMA_TXRATE_QUARTER_DEFAULT
argument_list|)
expr_stmt|;
name|setackpolicy
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* disable ACK's */
name|ts
operator|->
name|tdma_opdetach
operator|=
name|vap
operator|->
name|iv_opdetach
expr_stmt|;
name|vap
operator|->
name|iv_opdetach
operator|=
name|tdma_vdetach
expr_stmt|;
name|ts
operator|->
name|tdma_newstate
operator|=
name|vap
operator|->
name|iv_newstate
expr_stmt|;
name|vap
operator|->
name|iv_newstate
operator|=
name|tdma_newstate
expr_stmt|;
name|vap
operator|->
name|iv_bmiss
operator|=
name|tdma_beacon_miss
expr_stmt|;
name|ts
operator|->
name|tdma_recv_mgmt
operator|=
name|vap
operator|->
name|iv_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_recv_mgmt
operator|=
name|tdma_recv_mgmt
expr_stmt|;
name|vap
operator|->
name|iv_tdma
operator|=
name|ts
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tdma_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
if|if
condition|(
name|ts
operator|==
name|NULL
condition|)
block|{
comment|/* NB: should not have touched any ic state */
return|return;
block|}
name|ts
operator|->
name|tdma_opdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vap
operator|->
name|iv_tdma
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_tdma
operator|=
name|NULL
expr_stmt|;
name|setackpolicy
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* enable ACK's */
block|}
end_function

begin_function
specifier|static
name|void
name|sta_leave
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|==
name|vap
operator|&&
name|ni
operator|!=
name|vap
operator|->
name|iv_bss
condition|)
name|ieee80211_node_leave
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TDMA state machine handler.  */
end_comment

begin_function
specifier|static
name|int
name|tdma_newstate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|enum
name|ieee80211_state
name|nstate
parameter_list|,
name|int
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|enum
name|ieee80211_state
name|ostate
decl_stmt|;
name|int
name|status
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ostate
operator|=
name|vap
operator|->
name|iv_state
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s -> %s (%d)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_state_name
index|[
name|ostate
index|]
argument_list|,
name|ieee80211_state_name
index|[
name|nstate
index|]
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
condition|)
name|callout_stop
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|)
expr_stmt|;
if|if
condition|(
name|nstate
operator|==
name|IEEE80211_S_SCAN
operator|&&
operator|(
name|ostate
operator|==
name|IEEE80211_S_INIT
operator|||
name|ostate
operator|==
name|IEEE80211_S_RUN
operator|)
operator|&&
name|ts
operator|->
name|tdma_slot
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Override adhoc behaviour when operating as a slave; 		 * we need to scan even if the channel is locked. 		 */
name|vap
operator|->
name|iv_state
operator|=
name|nstate
expr_stmt|;
comment|/* state transition */
name|ieee80211_cancel_scan
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* background scan */
if|if
condition|(
name|ostate
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
comment|/* purge station table; entries are stale */
name|ieee80211_iterate_nodes
argument_list|(
operator|&
name|ic
operator|->
name|ic_sta
argument_list|,
name|sta_leave
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SCANREQ
condition|)
block|{
name|ieee80211_check_scan
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_scanreq_flags
argument_list|,
name|vap
operator|->
name|iv_scanreq_duration
argument_list|,
name|vap
operator|->
name|iv_scanreq_mindwell
argument_list|,
name|vap
operator|->
name|iv_scanreq_maxdwell
argument_list|,
name|vap
operator|->
name|iv_scanreq_nssid
argument_list|,
name|vap
operator|->
name|iv_scanreq_ssid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_SCANREQ
expr_stmt|;
block|}
else|else
name|ieee80211_check_scan_current
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|status
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|status
operator|=
name|ts
operator|->
name|tdma_newstate
argument_list|(
name|vap
argument_list|,
name|nstate
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|==
literal|0
operator|&&
name|nstate
operator|==
name|IEEE80211_S_RUN
operator|&&
name|ostate
operator|!=
name|IEEE80211_S_RUN
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_SWBMISS
operator|)
operator|&&
name|ts
operator|->
name|tdma_slot
operator|!=
literal|0
operator|&&
name|vap
operator|->
name|iv_des_chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
block|{
comment|/* 		 * Start s/w beacon miss timer for slave devices w/o 		 * hardware support.  Note we do this only if we're 		 * not locked to a channel (i.e. roam to follow the 		 * master). The 2x is a fudge for our doing this in 		 * software. 		 */
name|vap
operator|->
name|iv_swbmiss_period
operator|=
name|IEEE80211_TU_TO_TICKS
argument_list|(
literal|2
operator|*
name|vap
operator|->
name|iv_bmissthreshold
operator|*
name|ts
operator|->
name|tdma_bintval
operator|*
operator|(
operator|(
name|ts
operator|->
name|tdma_slotcnt
operator|*
name|ts
operator|->
name|tdma_slotlen
operator|)
operator|/
literal|1024
operator|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_swbmiss_count
operator|=
literal|0
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|,
name|vap
operator|->
name|iv_swbmiss_period
argument_list|,
name|ieee80211_swbmiss
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tdma_beacon_miss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|vap
operator|->
name|iv_ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"scanning"
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
argument_list|,
operator|(
literal|"wrong state %d"
operator|,
name|vap
operator|->
name|iv_state
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
operator||
name|IEEE80211_MSG_TDMA
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"beacon miss, mode %u state %s\n"
argument_list|,
name|vap
operator|->
name|iv_opmode
argument_list|,
name|ieee80211_state_name
index|[
name|vap
operator|->
name|iv_state
index|]
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|vap
operator|->
name|iv_swbmiss
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts
operator|->
name|tdma_peer
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX? can this be null? */
name|ieee80211_notify_node_leave
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|ts
operator|->
name|tdma_peer
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * Treat beacon miss like an associate failure wrt the 		 * scan policy; this forces the entry in the scan cache 		 * to be ignored after several tries. 		 */
name|ieee80211_scan_assoc_fail
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_macaddr
argument_list|,
name|IEEE80211_STATUS_TIMEOUT
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|ts->tdma_inuse = 0;
comment|/* clear slot usage */
endif|#
directive|endif
name|ieee80211_new_state
argument_list|(
name|vap
argument_list|,
name|IEEE80211_S_SCAN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tdma_recv_mgmt
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
if|if
condition|(
name|subtype
operator|==
name|IEEE80211_FC0_SUBTYPE_BEACON
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_SCAN
operator|)
operator|==
literal|0
condition|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_scanparams
name|scan
decl_stmt|;
if|if
condition|(
name|ieee80211_parse_beacon
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|,
operator|&
name|scan
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|scan
operator|.
name|tdma
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * TDMA stations must beacon a TDMA ie; ignore 			 * any other station. 			 * XXX detect overlapping bss and change channel 			 */
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ELEMID
operator||
name|IEEE80211_MSG_INPUT
argument_list|,
name|wh
argument_list|,
name|ieee80211_mgt_subtype_name
index|[
name|subtype
operator|>>
name|IEEE80211_FC0_SUBTYPE_SHIFT
index|]
argument_list|,
literal|"%s"
argument_list|,
literal|"no TDMA ie"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
condition|)
block|{
comment|/* 			 * Fake up a node for this newly 			 * discovered member of the IBSS. 			 */
name|ni
operator|=
name|ieee80211_add_neighbor
argument_list|(
name|vap
argument_list|,
name|wh
argument_list|,
operator|&
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
block|{
comment|/* NB: stat kept for alloc failure */
return|return;
block|}
block|}
comment|/* 		 * Check for state updates. 		 */
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|wh
operator|->
name|i_addr3
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
condition|)
block|{
comment|/* 			 * Count frame now that we know it's to be processed. 			 */
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_beacon
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_beacons
argument_list|)
expr_stmt|;
comment|/* 			 * Record tsf of last beacon.  NB: this must be 			 * done before calling tdma_process_params 			 * as deeper routines reference it. 			 */
name|memcpy
argument_list|(
operator|&
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|,
name|scan
operator|.
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Count beacon frame for s/w bmiss handling. 			 */
name|vap
operator|->
name|iv_swbmiss_count
operator|++
expr_stmt|;
comment|/* 			 * Process tdma ie.  The contents are used to sync 			 * the slot timing, reconfigure the bss, etc. 			 */
operator|(
name|void
operator|)
name|tdma_process_params
argument_list|(
name|ni
argument_list|,
name|scan
operator|.
name|tdma
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|,
name|wh
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * NB: defer remaining work to the adhoc code; this causes 		 *     2x parsing of the frame but should happen infrequently 		 */
block|}
name|ts
operator|->
name|tdma_recv_mgmt
argument_list|(
name|ni
argument_list|,
name|m0
argument_list|,
name|subtype
argument_list|,
name|rssi
argument_list|,
name|nf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update TDMA state on receipt of a beacon frame with  * a TDMA information element.  The sender's identity  * is provided so we can track who our peer is.  If pickslot  * is non-zero we scan the slot allocation state in the ie  * to locate a free slot for our use.  */
end_comment

begin_function
specifier|static
name|int
name|tdma_update
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|pickslot
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|int
name|slot
decl_stmt|,
name|slotlen
decl_stmt|,
name|update
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not a tdma vap, caps 0x%x"
operator|,
name|vap
operator|->
name|iv_caps
operator|)
argument_list|)
expr_stmt|;
name|update
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tdma
operator|->
name|tdma_slotcnt
operator|!=
name|ts
operator|->
name|tdma_slotcnt
condition|)
block|{
if|if
condition|(
operator|!
name|TDMA_SLOTCNT_VALID
argument_list|(
name|tdma
operator|->
name|tdma_slotcnt
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|ts
operator|->
name|tdma_lastprint
argument_list|,
operator|&
name|ts
operator|->
name|tdma_fails
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: bad slot cnt %u\n"
argument_list|,
name|__func__
argument_list|,
name|tdma
operator|->
name|tdma_slotcnt
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|update
operator||=
name|TDMA_UPDATE_SLOTCNT
expr_stmt|;
block|}
name|slotlen
operator|=
name|le16toh
argument_list|(
name|tdma
operator|->
name|tdma_slotlen
argument_list|)
operator|*
literal|100
expr_stmt|;
if|if
condition|(
name|slotlen
operator|!=
name|ts
operator|->
name|tdma_slotlen
condition|)
block|{
if|if
condition|(
operator|!
name|TDMA_SLOTLEN_VALID
argument_list|(
name|slotlen
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|ts
operator|->
name|tdma_lastprint
argument_list|,
operator|&
name|ts
operator|->
name|tdma_fails
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: bad slot len %u\n"
argument_list|,
name|__func__
argument_list|,
name|slotlen
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|update
operator||=
name|TDMA_UPDATE_SLOTLEN
expr_stmt|;
block|}
if|if
condition|(
name|tdma
operator|->
name|tdma_bintval
operator|!=
name|ts
operator|->
name|tdma_bintval
condition|)
block|{
if|if
condition|(
operator|!
name|TDMA_BINTVAL_VALID
argument_list|(
name|tdma
operator|->
name|tdma_bintval
argument_list|)
condition|)
block|{
if|if
condition|(
name|ppsratecheck
argument_list|(
operator|&
name|ts
operator|->
name|tdma_lastprint
argument_list|,
operator|&
name|ts
operator|->
name|tdma_fails
argument_list|,
literal|1
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s: bad beacon interval %u\n"
argument_list|,
name|__func__
argument_list|,
name|tdma
operator|->
name|tdma_bintval
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|update
operator||=
name|TDMA_UPDATE_BINTVAL
expr_stmt|;
block|}
name|slot
operator|=
name|ts
operator|->
name|tdma_slot
expr_stmt|;
if|if
condition|(
name|pickslot
condition|)
block|{
comment|/* 		 * Pick unoccupied slot.  Note we never choose slot 0. 		 */
for|for
control|(
name|slot
operator|=
name|tdma
operator|->
name|tdma_slotcnt
operator|-
literal|1
init|;
name|slot
operator|>
literal|0
condition|;
name|slot
operator|--
control|)
if|if
condition|(
name|isclr
argument_list|(
name|tdma
operator|->
name|tdma_inuse
argument_list|,
name|slot
argument_list|)
condition|)
break|break;
if|if
condition|(
name|slot
operator|<=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s: no free slot, slotcnt %u inuse: 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|tdma
operator|->
name|tdma_slotcnt
argument_list|,
name|tdma
operator|->
name|tdma_inuse
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* XXX need to do something better */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|slot
operator|!=
name|ts
operator|->
name|tdma_slot
condition|)
name|update
operator||=
name|TDMA_UPDATE_SLOT
expr_stmt|;
block|}
if|if
condition|(
name|ni
operator|!=
name|ts
operator|->
name|tdma_peer
condition|)
block|{
comment|/* update everything */
name|update
operator|=
name|TDMA_UPDATE_SLOT
operator||
name|TDMA_UPDATE_SLOTCNT
operator||
name|TDMA_UPDATE_SLOTLEN
operator||
name|TDMA_UPDATE_BINTVAL
expr_stmt|;
block|}
if|if
condition|(
name|update
condition|)
block|{
comment|/* 		 * New/changed parameters; update runtime state. 		 */
comment|/* XXX overwrites user parameters */
if|if
condition|(
name|update
operator|&
name|TDMA_UPDATE_SLOTCNT
condition|)
name|ts
operator|->
name|tdma_slotcnt
operator|=
name|tdma
operator|->
name|tdma_slotcnt
expr_stmt|;
if|if
condition|(
name|update
operator|&
name|TDMA_UPDATE_SLOTLEN
condition|)
name|ts
operator|->
name|tdma_slotlen
operator|=
name|slotlen
expr_stmt|;
if|if
condition|(
name|update
operator|&
name|TDMA_UPDATE_SLOT
condition|)
name|ts
operator|->
name|tdma_slot
operator|=
name|slot
expr_stmt|;
if|if
condition|(
name|update
operator|&
name|TDMA_UPDATE_BINTVAL
condition|)
name|ts
operator|->
name|tdma_bintval
operator|=
name|tdma
operator|->
name|tdma_bintval
expr_stmt|;
comment|/* mark beacon to be updated before next xmit */
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_TDMA
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_TDMA
argument_list|,
literal|"%s: slot %u slotcnt %u slotlen %u us bintval %u\n"
argument_list|,
name|__func__
argument_list|,
name|ts
operator|->
name|tdma_slot
argument_list|,
name|ts
operator|->
name|tdma_slotcnt
argument_list|,
name|ts
operator|->
name|tdma_slotlen
argument_list|,
name|ts
operator|->
name|tdma_bintval
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Notify driver.  Note we can be called before 	 * entering RUN state if we scanned and are 	 * joining an existing bss.  In that case do not 	 * call the driver because not all necessary state 	 * has been setup.  The next beacon will dtrt. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
name|vap
operator|->
name|iv_ic
operator|->
name|ic_tdma_update
argument_list|(
name|ni
argument_list|,
name|tdma
argument_list|,
name|update
argument_list|)
expr_stmt|;
comment|/* 	 * Dispatch join event on first beacon from new master. 	 */
if|if
condition|(
name|ts
operator|->
name|tdma_peer
operator|!=
name|ni
condition|)
block|{
if|if
condition|(
name|ts
operator|->
name|tdma_peer
operator|!=
name|NULL
condition|)
name|ieee80211_notify_node_leave
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|ieee80211_notify_node_join
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* NB: no reference, we just use the address */
name|ts
operator|->
name|tdma_peer
operator|=
name|ni
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Process received TDMA parameters.  */
end_comment

begin_function
specifier|static
name|int
name|tdma_process_params
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|u_int8_t
modifier|*
name|ie
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|nf
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_tdma_param
operator|*
operator|)
name|ie
decl_stmt|;
name|u_int
name|len
init|=
name|ie
index|[
literal|1
index|]
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not a tdma vap, caps 0x%x"
operator|,
name|vap
operator|->
name|iv_caps
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
operator|*
name|tdma
argument_list|)
operator|-
literal|2
condition|)
block|{
name|IEEE80211_DISCARD_IE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ELEMID
operator||
name|IEEE80211_MSG_TDMA
argument_list|,
name|wh
argument_list|,
literal|"tdma"
argument_list|,
literal|"too short, len %u"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|IEEE80211_REASON_IE_INVALID
return|;
block|}
if|if
condition|(
name|tdma
operator|->
name|tdma_version
operator|!=
name|ts
operator|->
name|tdma_version
condition|)
block|{
name|IEEE80211_DISCARD_IE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ELEMID
operator||
name|IEEE80211_MSG_TDMA
argument_list|,
name|wh
argument_list|,
literal|"tdma"
argument_list|,
literal|"bad version %u (ours %u)"
argument_list|,
name|tdma
operator|->
name|tdma_version
argument_list|,
name|ts
operator|->
name|tdma_version
argument_list|)
expr_stmt|;
return|return
name|IEEE80211_REASON_IE_INVALID
return|;
block|}
comment|/* 	 * NB: ideally we'd check against tdma_slotcnt, but that 	 * would require extra effort so do this easy check that 	 * covers the work below; more stringent checks are done 	 * before we make more extensive use of the ie contents. 	 */
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|>=
name|TDMA_MAXSLOTS
condition|)
block|{
name|IEEE80211_DISCARD_IE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ELEMID
operator||
name|IEEE80211_MSG_TDMA
argument_list|,
name|wh
argument_list|,
literal|"tdma"
argument_list|,
literal|"invalid slot %u"
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
expr_stmt|;
return|return
name|IEEE80211_REASON_IE_INVALID
return|;
block|}
comment|/* 	 * Can reach here while scanning, update 	 * operational state only in RUN state. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
block|{
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|!=
name|ts
operator|->
name|tdma_slot
operator|&&
name|isclr
argument_list|(
name|ts
operator|->
name|tdma_inuse
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_TDMA
argument_list|,
name|ni
argument_list|,
literal|"discovered in slot %u"
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|ts
operator|->
name|tdma_inuse
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
expr_stmt|;
comment|/* XXX dispatch event only when operating as master */
if|if
condition|(
name|ts
operator|->
name|tdma_slot
operator|==
literal|0
condition|)
name|ieee80211_notify_node_join
argument_list|(
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|setbit
argument_list|(
name|ts
operator|->
name|tdma_active
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|==
name|ts
operator|->
name|tdma_slot
operator|-
literal|1
condition|)
block|{
comment|/* 			 * Slave tsf synchronization to station 			 * just before us in the schedule. The driver 			 * is responsible for copying the timestamp 			 * of the received beacon into our beacon 			 * frame so the sender can calculate round 			 * trip time.  We cannot do that here because 			 * we don't know how to update our beacon frame. 			 */
operator|(
name|void
operator|)
name|tdma_update
argument_list|(
name|vap
argument_list|,
name|tdma
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX reschedule swbmiss timer on parameter change */
block|}
elseif|else
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|==
name|ts
operator|->
name|tdma_slot
operator|+
literal|1
condition|)
block|{
name|uint64_t
name|tstamp
decl_stmt|;
if|#
directive|if
literal|0
block|uint32_t rstamp = (uint32_t) le64toh(rs->tsf); 			int32_t rtt;
endif|#
directive|endif
comment|/* 			 * Use returned timstamp to calculate the 			 * roundtrip time. 			 */
name|memcpy
argument_list|(
operator|&
name|tstamp
argument_list|,
name|tdma
operator|->
name|tdma_tstamp
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
comment|/* XXX use only 15 bits of rstamp */
block|rtt = rstamp - (le64toh(tstamp)& 0x7fff); 			if (rtt< 0) 				rtt += 0x7fff;
comment|/* XXX hack to quiet normal use */
block|IEEE80211_DPRINTF(vap, IEEE80211_MSG_DOT1X, 			    "tdma rtt %5u [rstamp %5u tstamp %llu]\n", 			    rtt, rstamp, 			    (unsigned long long) le64toh(tstamp));
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|==
name|ts
operator|->
name|tdma_slot
operator|&&
name|le64toh
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
operator|>
name|vap
operator|->
name|iv_bss
operator|->
name|ni_tstamp
operator|.
name|tsf
condition|)
block|{
comment|/* 			 * Station using the same slot as us and has 			 * been around longer than us; we must move. 			 * Note this can happen if stations do not 			 * see each other while scanning. 			 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_TDMA
argument_list|,
literal|"slot %u collision rxtsf %llu tsf %llu\n"
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|le64toh
argument_list|(
name|ni
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_tstamp
operator|.
name|tsf
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|ts
operator|->
name|tdma_inuse
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tdma_update
argument_list|(
name|vap
argument_list|,
name|tdma
argument_list|,
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_tdma_getslot
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not a tdma vap, caps 0x%x"
operator|,
name|vap
operator|->
name|iv_caps
operator|)
argument_list|)
expr_stmt|;
return|return
name|ts
operator|->
name|tdma_slot
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a TDMA ie on station join and use it to setup node state.  */
end_comment

begin_function
name|void
name|ieee80211_parse_tdma
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_tdma_param
operator|*
operator|)
name|ie
decl_stmt|;
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
comment|/* 		 * Adopt TDMA configuration when joining an 		 * existing network. 		 */
name|setbit
argument_list|(
name|ts
operator|->
name|tdma_inuse
argument_list|,
name|tdma
operator|->
name|tdma_slot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tdma_update
argument_list|(
name|vap
argument_list|,
name|tdma
argument_list|,
name|ni
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Propagate capabilities based on the local 		 * configuration and the remote station's advertised 		 * capabilities. In particular this permits us to 		 * enable use of QoS to disable ACK's. 		 */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WME
operator|)
operator|&&
name|ni
operator|->
name|ni_ies
operator|.
name|wme_ie
operator|!=
name|NULL
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_QOS
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|TDMA_OUI_BYTES
value|0x00, 0x03, 0x7f
end_define

begin_comment
comment|/*  * Add a TDMA parameters element to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_tdma
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
specifier|static
specifier|const
name|struct
name|ieee80211_tdma_param
name|param
init|=
block|{
operator|.
name|tdma_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|tdma_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_tdma_param
argument_list|)
operator|-
literal|2
block|,
operator|.
name|tdma_oui
operator|=
block|{
name|TDMA_OUI_BYTES
block|}
block|,
operator|.
name|tdma_type
operator|=
name|TDMA_OUI_TYPE
block|,
operator|.
name|tdma_subtype
operator|=
name|TDMA_SUBTYPE_PARAM
block|,
operator|.
name|tdma_version
operator|=
name|TDMA_VERSION
block|, 	}
decl_stmt|;
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|uint16_t
name|slotlen
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not a tdma vap, caps 0x%x"
operator|,
name|vap
operator|->
name|iv_caps
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|param
argument_list|,
sizeof|sizeof
argument_list|(
name|param
argument_list|)
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_tdma_param
argument_list|,
name|tdma_slot
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ts
operator|->
name|tdma_slot
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ts
operator|->
name|tdma_slotcnt
expr_stmt|;
comment|/* NB: convert units to fit in 16-bits */
name|slotlen
operator|=
name|ts
operator|->
name|tdma_slotlen
operator|/
literal|100
expr_stmt|;
comment|/* 100us units */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|slotlen
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ts
operator|->
name|tdma_bintval
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|ts
operator|->
name|tdma_inuse
index|[
literal|0
index|]
expr_stmt|;
name|frm
operator|+=
literal|10
expr_stmt|;
comment|/* pad+timestamp */
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_undef
undef|#
directive|undef
name|TDMA_OUI_BYTES
end_undef

begin_comment
comment|/*  * Update TDMA state at TBTT.  */
end_comment

begin_function
name|void
name|ieee80211_tdma_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not a tdma vap, caps 0x%x"
operator|,
name|vap
operator|->
name|iv_caps
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_TDMA
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|ieee80211_add_tdma
argument_list|(
name|bo
operator|->
name|bo_tdma
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|clrbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_TDMA
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ts
operator|->
name|tdma_slot
operator|!=
literal|0
condition|)
comment|/* only on master */
return|return;
if|if
condition|(
name|ts
operator|->
name|tdma_count
operator|<=
literal|0
condition|)
block|{
comment|/* 		 * Time to update the mask of active/inuse stations. 		 * We track stations that we've received a beacon 		 * frame from and update this mask periodically. 		 * This allows us to miss a few beacons before marking 		 * a slot free for re-use. 		 */
name|ts
operator|->
name|tdma_inuse
index|[
literal|0
index|]
operator|=
name|ts
operator|->
name|tdma_active
index|[
literal|0
index|]
expr_stmt|;
name|ts
operator|->
name|tdma_active
index|[
literal|0
index|]
operator|=
literal|0x01
expr_stmt|;
comment|/* update next time 'round */
comment|/* XXX use notify framework */
name|setbit
argument_list|(
name|bo
operator|->
name|bo_flags
argument_list|,
name|IEEE80211_BEACON_TDMA
argument_list|)
expr_stmt|;
comment|/* NB: use s/w beacon miss threshold; may be too high */
name|ts
operator|->
name|tdma_count
operator|=
name|vap
operator|->
name|iv_bmissthreshold
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|ts
operator|->
name|tdma_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tdma_ioctl_get80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_TDMA_SLOT
case|:
name|ireq
operator|->
name|i_val
operator|=
name|ts
operator|->
name|tdma_slot
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_TDMA_SLOTCNT
case|:
name|ireq
operator|->
name|i_val
operator|=
name|ts
operator|->
name|tdma_slotcnt
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_TDMA_SLOTLEN
case|:
name|ireq
operator|->
name|i_val
operator|=
name|ts
operator|->
name|tdma_slotlen
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_TDMA_BINTERVAL
case|:
name|ireq
operator|->
name|i_val
operator|=
name|ts
operator|->
name|tdma_bintval
expr_stmt|;
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_GET
argument_list|(
name|tdma
argument_list|,
name|tdma_ioctl_get80211
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|tdma_ioctl_set80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_TDMA_SLOT
case|:
if|if
condition|(
operator|!
operator|(
literal|0
operator|<=
name|ireq
operator|->
name|i_val
operator|&&
name|ireq
operator|->
name|i_val
operator|<=
name|ts
operator|->
name|tdma_slotcnt
operator|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|!=
name|ts
operator|->
name|tdma_slot
condition|)
block|{
name|ts
operator|->
name|tdma_slot
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
break|break;
case|case
name|IEEE80211_IOC_TDMA_SLOTCNT
case|:
if|if
condition|(
operator|!
name|TDMA_SLOTCNT_VALID
argument_list|(
name|ireq
operator|->
name|i_val
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|!=
name|ts
operator|->
name|tdma_slotcnt
condition|)
block|{
name|ts
operator|->
name|tdma_slotcnt
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
break|break;
case|case
name|IEEE80211_IOC_TDMA_SLOTLEN
case|:
comment|/* 		 * XXX 		 * 150 insures at least 1/8 TU 		 * 0xfffff is the max duration for bursting 		 * (implict by way of 16-bit data type for i_val) 		 */
if|if
condition|(
operator|!
name|TDMA_SLOTLEN_VALID
argument_list|(
name|ireq
operator|->
name|i_val
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|!=
name|ts
operator|->
name|tdma_slotlen
condition|)
block|{
name|ts
operator|->
name|tdma_slotlen
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
break|break;
case|case
name|IEEE80211_IOC_TDMA_BINTERVAL
case|:
if|if
condition|(
operator|!
name|TDMA_BINTVAL_VALID
argument_list|(
name|ireq
operator|->
name|i_val
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|ireq
operator|->
name|i_val
operator|!=
name|ts
operator|->
name|tdma_bintval
condition|)
block|{
name|ts
operator|->
name|tdma_bintval
operator|=
name|ireq
operator|->
name|i_val
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
name|restart
label|:
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_TDMA
argument_list|)
expr_stmt|;
return|return
name|ERESTART
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_SET
argument_list|(
name|tdma
argument_list|,
name|tdma_ioctl_set80211
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

end_unit

