begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Atsushi Onoe  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 generic handler  */
end_comment

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sbuf.h>
end_include

begin_include
include|#
directive|include
file|<machine/stdarg.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net80211/ieee80211_ratectl.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|ieee80211_phymode_name
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
literal|"auto"
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
literal|"11a"
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
literal|"11b"
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
literal|"11g"
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
literal|"FH"
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
literal|"turboA"
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
literal|"turboG"
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
literal|"sturboA"
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
literal|"half"
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
literal|"quarter"
block|,
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
literal|"11na"
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
literal|"11ng"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* map ieee80211_opmode to the corresponding capability bit */
end_comment

begin_decl_stmt
specifier|const
name|int
name|ieee80211_opcap
index|[
name|IEEE80211_OPMODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_M_IBSS
index|]
operator|=
name|IEEE80211_C_IBSS
block|,
index|[
name|IEEE80211_M_WDS
index|]
operator|=
name|IEEE80211_C_WDS
block|,
index|[
name|IEEE80211_M_STA
index|]
operator|=
name|IEEE80211_C_STA
block|,
index|[
name|IEEE80211_M_AHDEMO
index|]
operator|=
name|IEEE80211_C_AHDEMO
block|,
index|[
name|IEEE80211_M_HOSTAP
index|]
operator|=
name|IEEE80211_C_HOSTAP
block|,
index|[
name|IEEE80211_M_MONITOR
index|]
operator|=
name|IEEE80211_C_MONITOR
block|,
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
index|[
name|IEEE80211_M_MBSS
index|]
operator|=
name|IEEE80211_C_MBSS
block|,
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|uint8_t
name|ieee80211broadcastaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
init|=
block|{
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|,
literal|0xff
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|ieee80211_syncflag_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_syncflag_ht_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_syncflag_ext_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_media_setup
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ifmedia
modifier|*
name|media
parameter_list|,
name|int
name|caps
parameter_list|,
name|int
name|addsta
parameter_list|,
name|ifm_change_cb_t
name|media_change
parameter_list|,
name|ifm_stat_cb_t
name|media_stat
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|media_status
parameter_list|(
name|enum
name|ieee80211_opmode
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|ieee80211_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
parameter_list|,
name|ift_counter
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_VAP
argument_list|,
literal|"80211vap"
argument_list|,
literal|"802.11 vap state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Default supported rates for 802.11 operation (in IEEE .5Mb units).  */
end_comment

begin_define
define|#
directive|define
name|B
parameter_list|(
name|r
parameter_list|)
value|((r) | IEEE80211_RATE_BASIC)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|ieee80211_rateset_11a
init|=
block|{
literal|8
block|,
block|{
name|B
argument_list|(
literal|12
argument_list|)
block|,
literal|18
block|,
name|B
argument_list|(
literal|24
argument_list|)
block|,
literal|36
block|,
name|B
argument_list|(
literal|48
argument_list|)
block|,
literal|72
block|,
literal|96
block|,
literal|108
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|ieee80211_rateset_half
init|=
block|{
literal|8
block|,
block|{
name|B
argument_list|(
literal|6
argument_list|)
block|,
literal|9
block|,
name|B
argument_list|(
literal|12
argument_list|)
block|,
literal|18
block|,
name|B
argument_list|(
literal|24
argument_list|)
block|,
literal|36
block|,
literal|48
block|,
literal|54
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|ieee80211_rateset_quarter
init|=
block|{
literal|8
block|,
block|{
name|B
argument_list|(
literal|3
argument_list|)
block|,
literal|4
block|,
name|B
argument_list|(
literal|6
argument_list|)
block|,
literal|9
block|,
name|B
argument_list|(
literal|12
argument_list|)
block|,
literal|18
block|,
literal|24
block|,
literal|27
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|ieee80211_rateset_11b
init|=
block|{
literal|4
block|,
block|{
name|B
argument_list|(
literal|2
argument_list|)
block|,
name|B
argument_list|(
literal|4
argument_list|)
block|,
name|B
argument_list|(
literal|11
argument_list|)
block|,
name|B
argument_list|(
literal|22
argument_list|)
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NB: OFDM rates are handled specially based on mode */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_rateset
name|ieee80211_rateset_11g
init|=
block|{
literal|12
block|,
block|{
name|B
argument_list|(
literal|2
argument_list|)
block|,
name|B
argument_list|(
literal|4
argument_list|)
block|,
name|B
argument_list|(
literal|11
argument_list|)
block|,
name|B
argument_list|(
literal|22
argument_list|)
block|,
literal|12
block|,
literal|18
block|,
literal|24
block|,
literal|36
block|,
literal|48
block|,
literal|72
block|,
literal|96
block|,
literal|108
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|B
end_undef

begin_comment
comment|/*  * Fill in 802.11 available channel set, mark  * all available channels as active, and pick  * a default channel if not already specified.  */
end_comment

begin_function
name|void
name|ieee80211_chan_init
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|DEFAULTRATES
parameter_list|(
name|m
parameter_list|,
name|def
parameter_list|)
value|do { \ 	if (ic->ic_sup_rates[m].rs_nrates == 0) \ 		ic->ic_sup_rates[m] = def; \ } while (0)
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
literal|0
operator|<
name|ic
operator|->
name|ic_nchans
operator|&&
name|ic
operator|->
name|ic_nchans
operator|<=
name|IEEE80211_CHAN_MAX
argument_list|,
operator|(
literal|"invalid number of channels specified: %u"
operator|,
name|ic
operator|->
name|ic_nchans
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ic
operator|->
name|ic_chan_avail
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_chan_avail
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|)
argument_list|)
expr_stmt|;
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_AUTO
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|c
operator|->
name|ic_flags
operator|!=
literal|0
argument_list|,
operator|(
literal|"channel with no flags"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Help drivers that work only with frequencies by filling 		 * in IEEE channel #'s if not already calculated.  Note this 		 * mimics similar work done in ieee80211_setregdomain when 		 * changing regulatory state. 		 */
if|if
condition|(
name|c
operator|->
name|ic_ieee
operator|==
literal|0
condition|)
name|c
operator|->
name|ic_ieee
operator|=
name|ieee80211_mhz2ieee
argument_list|(
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|->
name|ic_extieee
operator|==
literal|0
condition|)
name|c
operator|->
name|ic_extieee
operator|=
name|ieee80211_mhz2ieee
argument_list|(
name|c
operator|->
name|ic_freq
operator|+
operator|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|c
argument_list|)
condition|?
literal|20
else|:
operator|-
literal|20
operator|)
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
comment|/* default max tx power to max regulatory */
if|if
condition|(
name|c
operator|->
name|ic_maxpower
operator|==
literal|0
condition|)
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|c
operator|->
name|ic_maxregpower
expr_stmt|;
name|setbit
argument_list|(
name|ic
operator|->
name|ic_chan_avail
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|)
expr_stmt|;
comment|/* 		 * Identify mode capabilities. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_FH
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108A
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_TURBO_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_TURBO_G
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ST
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_STURBO_A
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_HALF
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_QUARTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HTA
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HTG
argument_list|(
name|c
argument_list|)
condition|)
name|setbit
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
block|}
comment|/* initialize candidate channels to all available */
name|memcpy
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ic
operator|->
name|ic_chan_avail
argument_list|,
sizeof|sizeof
argument_list|(
name|ic
operator|->
name|ic_chan_avail
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sort channel table to allow lookup optimizations */
name|ieee80211_sort_channels
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|)
expr_stmt|;
comment|/* invalidate any previous state */
name|ic
operator|->
name|ic_bsschan
operator|=
name|IEEE80211_CHAN_ANYC
expr_stmt|;
name|ic
operator|->
name|ic_prevchan
operator|=
name|NULL
expr_stmt|;
name|ic
operator|->
name|ic_csa_newchan
operator|=
name|NULL
expr_stmt|;
comment|/* arbitrarily pick the first channel */
name|ic
operator|->
name|ic_curchan
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
literal|0
index|]
expr_stmt|;
name|ic
operator|->
name|ic_rt
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* fillin well-known rate sets if driver has not specified */
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_11B
argument_list|,
name|ieee80211_rateset_11b
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_11G
argument_list|,
name|ieee80211_rateset_11g
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_11A
argument_list|,
name|ieee80211_rateset_11a
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_TURBO_A
argument_list|,
name|ieee80211_rateset_11a
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_TURBO_G
argument_list|,
name|ieee80211_rateset_11g
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_STURBO_A
argument_list|,
name|ieee80211_rateset_11a
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_HALF
argument_list|,
name|ieee80211_rateset_half
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_QUARTER
argument_list|,
name|ieee80211_rateset_quarter
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_11NA
argument_list|,
name|ieee80211_rateset_11a
argument_list|)
expr_stmt|;
name|DEFAULTRATES
argument_list|(
name|IEEE80211_MODE_11NG
argument_list|,
name|ieee80211_rateset_11g
argument_list|)
expr_stmt|;
comment|/* 	 * Setup required information to fill the mcsset field, if driver did 	 * not. Assume a 2T2R setup for historic reasons. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_rxstream
operator|==
literal|0
condition|)
name|ic
operator|->
name|ic_rxstream
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|==
literal|0
condition|)
name|ic
operator|->
name|ic_txstream
operator|=
literal|2
expr_stmt|;
comment|/* 	 * Set auto mode to reset active channel state and any desired channel. 	 */
operator|(
name|void
operator|)
name|ieee80211_setmode
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_AUTO
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|DEFAULTRATES
block|}
end_function

begin_function
specifier|static
name|void
name|null_update_mcast
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"need multicast update callback\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|null_update_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"need promiscuous mode update callback\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|null_update_chw
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s: need callback\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ic_printf
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|retval
operator|=
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|retval
operator|+=
name|vprintf
argument_list|(
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|LIST_HEAD
argument_list|(
argument_list|,
argument|ieee80211com
argument_list|)
name|ic_head
operator|=
name|LIST_HEAD_INITIALIZER
argument_list|(
name|ic_head
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|mtx
name|ic_list_mtx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|MTX_SYSINIT
argument_list|(
name|ic_list
argument_list|,
operator|&
name|ic_list_mtx
argument_list|,
literal|"ieee80211com list"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|sysctl_ieee80211coms
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|sbuf
name|sb
decl_stmt|;
name|char
modifier|*
name|sp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_wire_old_buffer
argument_list|(
name|req
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sbuf_new_for_sysctl
argument_list|(
operator|&
name|sb
argument_list|,
name|NULL
argument_list|,
literal|8
argument_list|,
name|req
argument_list|)
expr_stmt|;
name|sbuf_clear_flags
argument_list|(
operator|&
name|sb
argument_list|,
name|SBUF_INCLUDENUL
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|""
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ic
argument_list|,
argument|&ic_head
argument_list|,
argument|ic_next
argument_list|)
block|{
name|sbuf_printf
argument_list|(
operator|&
name|sb
argument_list|,
literal|"%s%s"
argument_list|,
name|sp
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|sp
operator|=
literal|" "
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
name|error
operator|=
name|sbuf_finish
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
name|sbuf_delete
argument_list|(
operator|&
name|sb
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|devices
argument_list|,
name|CTLTYPE_STRING
operator||
name|CTLFLAG_RD
operator||
name|CTLFLAG_MPSAFE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sysctl_ieee80211coms
argument_list|,
literal|"A"
argument_list|,
literal|"names of available 802.11 devices"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Attach/setup the common net80211 state.  Called by  * the driver on attach to prior to creating any vap's.  */
end_comment

begin_function
name|void
name|ieee80211_ifattach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK_INIT
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|IEEE80211_TX_LOCK_INIT
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
expr_stmt|;
comment|/* Create a taskqueue for all state changes */
name|ic
operator|->
name|ic_tq
operator|=
name|taskqueue_create
argument_list|(
literal|"ic_taskq"
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|,
name|taskqueue_thread_enqueue
argument_list|,
operator|&
name|ic
operator|->
name|ic_tq
argument_list|)
expr_stmt|;
name|taskqueue_start_threads
argument_list|(
operator|&
name|ic
operator|->
name|ic_tq
argument_list|,
literal|1
argument_list|,
name|PI_NET
argument_list|,
literal|"%s net80211 taskq"
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ierrors
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_oerrors
operator|=
name|counter_u64_alloc
argument_list|(
name|M_WAITOK
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in 802.11 available channel set, mark all 	 * available channels as active, and pick a default 	 * channel if not already specified. 	 */
name|ieee80211_chan_init
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_update_mcast
operator|=
name|null_update_mcast
expr_stmt|;
name|ic
operator|->
name|ic_update_promisc
operator|=
name|null_update_promisc
expr_stmt|;
name|ic
operator|->
name|ic_update_chw
operator|=
name|null_update_chw
expr_stmt|;
name|ic
operator|->
name|ic_hash_key
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|ic
operator|->
name|ic_bintval
operator|=
name|IEEE80211_BINTVAL_DEFAULT
expr_stmt|;
name|ic
operator|->
name|ic_lintval
operator|=
name|ic
operator|->
name|ic_bintval
expr_stmt|;
name|ic
operator|->
name|ic_txpowlimit
operator|=
name|IEEE80211_TXPOWER_MAX
expr_stmt|;
name|ieee80211_crypto_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_node_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_power_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_proto_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_superg_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_ht_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_scan_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_regdomain_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_dfs_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_sysctl_attach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|ic_head
argument_list|,
name|ic
argument_list|,
name|ic_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Detach net80211 state on device detach.  Tear down  * all vap's and reclaim all common state prior to the  * device state going away.  Note we may call back into  * driver; it must be prepared for this.  */
end_comment

begin_function
name|void
name|ieee80211_ifdetach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|ic
argument_list|,
name|ic_next
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
name|taskqueue_drain
argument_list|(
name|taskqueue_thread
argument_list|,
operator|&
name|ic
operator|->
name|ic_restart_task
argument_list|)
expr_stmt|;
comment|/* 	 * The VAP is responsible for setting and clearing 	 * the VIMAGE context. 	 */
while|while
condition|(
operator|(
name|vap
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ieee80211_vap_destroy
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_waitfor_parent
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_sysctl_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_dfs_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_regdomain_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_scan_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_superg_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_ht_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* NB: must be called before ieee80211_node_detach */
name|ieee80211_proto_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_crypto_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_power_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_node_detach
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|counter_u64_free
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|)
expr_stmt|;
name|counter_u64_free
argument_list|(
name|ic
operator|->
name|ic_oerrors
argument_list|)
expr_stmt|;
name|taskqueue_free
argument_list|(
name|ic
operator|->
name|ic_tq
argument_list|)
expr_stmt|;
name|IEEE80211_TX_LOCK_DESTROY
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK_DESTROY
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|ieee80211com
modifier|*
name|ieee80211_find_com
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|ic
argument_list|,
argument|&ic_head
argument_list|,
argument|ic_next
argument_list|)
if|if
condition|(
name|strcmp
argument_list|(
name|ic
operator|->
name|ic_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|ic_list_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ic
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default reset method for use with the ioctl support.  This  * method is invoked after any state change in the 802.11  * layer that should be propagated to the hardware but not  * require re-initialization of the 802.11 state machine (e.g  * rescanning for an ap).  We always return ENETRESET which  * should cause the driver to re-initialize the device. Drivers  * can override this method to implement more optimized support.  */
end_comment

begin_function
specifier|static
name|int
name|default_reset
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|u_long
name|cmd
parameter_list|)
block|{
return|return
name|ENETRESET
return|;
block|}
end_function

begin_comment
comment|/*  * Add underlying device errors to vap errors.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|ieee80211_get_counter
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|ift_counter
name|cnt
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|uint64_t
name|rv
decl_stmt|;
name|rv
operator|=
name|if_get_counter_default
argument_list|(
name|ifp
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cnt
condition|)
block|{
case|case
name|IFCOUNTER_OERRORS
case|:
name|rv
operator|+=
name|counter_u64_fetch
argument_list|(
name|ic
operator|->
name|ic_oerrors
argument_list|)
expr_stmt|;
break|break;
case|case
name|IFCOUNTER_IERRORS
case|:
name|rv
operator|+=
name|counter_u64_fetch
argument_list|(
name|ic
operator|->
name|ic_ierrors
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prepare a vap for use.  Drivers use this call to  * setup net80211 state in new vap's prior attaching  * them with ieee80211_vap_attach (below).  */
end_comment

begin_function
name|int
name|ieee80211_vap_setup
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|char
name|name
index|[
name|IFNAMSIZ
index|]
parameter_list|,
name|int
name|unit
parameter_list|,
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|ifp
operator|=
name|if_alloc
argument_list|(
name|IFT_ETHER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s: unable to allocate ifnet\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|if_initname
argument_list|(
name|ifp
argument_list|,
name|name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
name|ifp
operator|->
name|if_softc
operator|=
name|vap
expr_stmt|;
comment|/* back pointer */
name|ifp
operator|->
name|if_flags
operator|=
name|IFF_SIMPLEX
operator||
name|IFF_BROADCAST
operator||
name|IFF_MULTICAST
expr_stmt|;
name|ifp
operator|->
name|if_transmit
operator|=
name|ieee80211_vap_transmit
expr_stmt|;
name|ifp
operator|->
name|if_qflush
operator|=
name|ieee80211_vap_qflush
expr_stmt|;
name|ifp
operator|->
name|if_ioctl
operator|=
name|ieee80211_ioctl
expr_stmt|;
name|ifp
operator|->
name|if_init
operator|=
name|ieee80211_init
expr_stmt|;
name|ifp
operator|->
name|if_get_counter
operator|=
name|ieee80211_get_counter
expr_stmt|;
name|vap
operator|->
name|iv_ifp
operator|=
name|ifp
expr_stmt|;
name|vap
operator|->
name|iv_ic
operator|=
name|ic
expr_stmt|;
name|vap
operator|->
name|iv_flags
operator|=
name|ic
operator|->
name|ic_flags
expr_stmt|;
comment|/* propagate common flags */
name|vap
operator|->
name|iv_flags_ext
operator|=
name|ic
operator|->
name|ic_flags_ext
expr_stmt|;
name|vap
operator|->
name|iv_flags_ven
operator|=
name|ic
operator|->
name|ic_flags_ven
expr_stmt|;
name|vap
operator|->
name|iv_caps
operator|=
name|ic
operator|->
name|ic_caps
operator|&
operator|~
name|IEEE80211_C_OPMODE
expr_stmt|;
name|vap
operator|->
name|iv_htcaps
operator|=
name|ic
operator|->
name|ic_htcaps
expr_stmt|;
name|vap
operator|->
name|iv_htextcaps
operator|=
name|ic
operator|->
name|ic_htextcaps
expr_stmt|;
name|vap
operator|->
name|iv_opmode
operator|=
name|opmode
expr_stmt|;
name|vap
operator|->
name|iv_caps
operator||=
name|ieee80211_opcap
index|[
name|opmode
index|]
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|ic
operator|->
name|ic_macaddr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_WDS
case|:
comment|/* 		 * WDS links must specify the bssid of the far end. 		 * For legacy operation this is a static relationship. 		 * For non-legacy operation the station must associate 		 * and be authorized to pass traffic.  Plumbing the 		 * vap to the proper node happens when the vap 		 * transitions to RUN state. 		 */
name|IEEE80211_ADDR_COPY
argument_list|(
name|vap
operator|->
name|iv_des_bssid
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_DESBSSID
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_WDSLEGACY
condition|)
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_WDSLEGACY
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
case|case
name|IEEE80211_M_AHDEMO
case|:
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_TDMA
condition|)
block|{
comment|/* NB: checked before clone operation allowed */
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_TDMA
argument_list|,
operator|(
literal|"not TDMA capable, ic_caps 0x%x"
operator|,
name|ic
operator|->
name|ic_caps
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * Propagate TDMA capability to mark vap; this 			 * cannot be removed and is used to distinguish 			 * regular ahdemo operation from ahdemo+tdma. 			 */
name|vap
operator|->
name|iv_caps
operator||=
name|IEEE80211_C_TDMA
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
break|break;
block|}
comment|/* auto-enable s/w beacon miss support */
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CLONE_NOBEACONS
condition|)
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_SWBMISS
expr_stmt|;
comment|/* auto-generated or user supplied MAC address */
if|if
condition|(
name|flags
operator|&
operator|(
name|IEEE80211_CLONE_BSSID
operator||
name|IEEE80211_CLONE_MACADDR
operator|)
condition|)
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_UNIQMAC
expr_stmt|;
comment|/* 	 * Enable various functionality by default if we're 	 * capable; the driver can override us if it knows better. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_WME
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_WME
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_BURST
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_BURST
expr_stmt|;
comment|/* NB: bg scanning only makes sense for station mode right now */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_BGSCAN
operator|)
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_BGSCAN
expr_stmt|;
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_DOTH
expr_stmt|;
comment|/* XXX no cap, just ena */
comment|/* NB: DFS support only makes sense for ap mode right now */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
operator|&&
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_DFS
operator|)
condition|)
name|vap
operator|->
name|iv_flags_ext
operator||=
name|IEEE80211_FEXT_DFS
expr_stmt|;
name|vap
operator|->
name|iv_des_chan
operator|=
name|IEEE80211_CHAN_ANYC
expr_stmt|;
comment|/* any channel is ok */
name|vap
operator|->
name|iv_bmissthreshold
operator|=
name|IEEE80211_HWBMISS_DEFAULT
expr_stmt|;
name|vap
operator|->
name|iv_dtim_period
operator|=
name|IEEE80211_DTIM_DEFAULT
expr_stmt|;
comment|/* 	 * Install a default reset method for the ioctl support; 	 * the driver can override this. 	 */
name|vap
operator|->
name|iv_reset
operator|=
name|default_reset
expr_stmt|;
name|ieee80211_sysctl_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_crypto_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_node_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_power_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_proto_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_superg_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_ht_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_scan_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_regdomain_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_vattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_ratectl_set
argument_list|(
name|vap
argument_list|,
name|IEEE80211_RATECTL_NONE
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Activate a vap.  State should have been prepared with a  * call to ieee80211_vap_setup and by the driver.  On return  * from this call the vap is ready for use.  */
end_comment

begin_function
name|int
name|ieee80211_vap_attach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|ifm_change_cb_t
name|media_change
parameter_list|,
name|ifm_stat_cb_t
name|media_stat
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifmediareq
name|imr
decl_stmt|;
name|int
name|maxrate
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s parent %s flags 0x%x flags_ext 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_opmode_name
index|[
name|vap
operator|->
name|iv_opmode
index|]
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
name|vap
operator|->
name|iv_flags_ext
argument_list|)
expr_stmt|;
comment|/* 	 * Do late attach work that cannot happen until after 	 * the driver has had a chance to override defaults. 	 */
name|ieee80211_node_latevattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_power_latevattach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|maxrate
operator|=
name|ieee80211_media_setup
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_media
argument_list|,
name|vap
operator|->
name|iv_caps
argument_list|,
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
name|media_change
argument_list|,
name|media_stat
argument_list|)
expr_stmt|;
name|ieee80211_media_status
argument_list|(
name|ifp
argument_list|,
operator|&
name|imr
argument_list|)
expr_stmt|;
comment|/* NB: strip explicit mode; we're actually in autoselect */
name|ifmedia_set
argument_list|(
operator|&
name|vap
operator|->
name|iv_media
argument_list|,
name|imr
operator|.
name|ifm_active
operator|&
operator|~
operator|(
name|IFM_MMASK
operator||
name|IFM_IEEE80211_TURBO
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxrate
condition|)
name|ifp
operator|->
name|if_baudrate
operator|=
name|IF_Mbps
argument_list|(
name|maxrate
argument_list|)
expr_stmt|;
name|ether_ifattach
argument_list|(
name|ifp
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* hook output method setup by ether_ifattach */
name|vap
operator|->
name|iv_output
operator|=
name|ifp
operator|->
name|if_output
expr_stmt|;
name|ifp
operator|->
name|if_output
operator|=
name|ieee80211_output
expr_stmt|;
comment|/* NB: if_mtu set by ether_ifattach to ETHERMTU */
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|,
name|vap
argument_list|,
name|iv_next
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_WME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_TURBOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_PCF
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_BURST
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_ht_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_FHT_HT
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_ht_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_FHT_USEHT40
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*   * Tear down vap state and reclaim the ifnet.  * The driver is assumed to have prepared for  * this; e.g. by turning off interrupts for the  * underlying device.  */
end_comment

begin_function
name|void
name|ieee80211_vap_detach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_STATE
argument_list|,
literal|"%s: %s parent %s\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_opmode_name
index|[
name|vap
operator|->
name|iv_opmode
index|]
argument_list|,
name|ic
operator|->
name|ic_name
argument_list|)
expr_stmt|;
comment|/* NB: bpfdetach is called by ether_ifdetach and claims all taps */
name|ether_ifdetach
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|ieee80211_stop
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* 	 * Flush any deferred vap tasks. 	 */
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_nstate_task
argument_list|)
expr_stmt|;
name|ieee80211_draintask
argument_list|(
name|ic
argument_list|,
operator|&
name|vap
operator|->
name|iv_swbmiss_task
argument_list|)
expr_stmt|;
comment|/* XXX band-aid until ifnet handles this for us */
name|taskqueue_drain
argument_list|(
name|taskqueue_swi
argument_list|,
operator|&
name|ifp
operator|->
name|if_linktask
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_INIT
argument_list|,
operator|(
literal|"vap still running"
operator|)
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|ic
operator|->
name|ic_vaps
argument_list|,
name|vap
argument_list|,
name|iv_next
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_WME
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_TURBOP
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_PCF
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_F_BURST
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_ht_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_FHT_HT
argument_list|)
expr_stmt|;
name|ieee80211_syncflag_ht_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_FHT_USEHT40
argument_list|)
expr_stmt|;
comment|/* NB: this handles the bpfdetach done below */
name|ieee80211_syncflag_ext_locked
argument_list|(
name|ic
argument_list|,
name|IEEE80211_FEXT_BPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_ifflags
operator|&
name|IFF_PROMISC
condition|)
name|ieee80211_promisc
argument_list|(
name|vap
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_ifflags
operator|&
name|IFF_ALLMULTI
condition|)
name|ieee80211_allmulti
argument_list|(
name|vap
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ifmedia_removeall
argument_list|(
operator|&
name|vap
operator|->
name|iv_media
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_regdomain_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_scan_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
name|ieee80211_superg_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ieee80211_ht_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
comment|/* NB: must be before ieee80211_node_vdetach */
name|ieee80211_proto_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_crypto_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_power_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_node_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|ieee80211_sysctl_vdetach
argument_list|(
name|vap
argument_list|)
expr_stmt|;
name|if_free
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Count number of vaps in promisc, and issue promisc on  * parent respectively.  */
end_comment

begin_function
name|void
name|ieee80211_promisc
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
operator|++
name|ic
operator|->
name|ic_promisc
operator|==
literal|1
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_promisc_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_promisc
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: ic %p not promisc"
operator|,
name|__func__
operator|,
name|ic
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ic
operator|->
name|ic_promisc
operator|==
literal|0
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_promisc_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Count number of vaps in allmulti, and issue allmulti on  * parent respectively.  */
end_comment

begin_function
name|void
name|ieee80211_allmulti
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|bool
name|on
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|on
condition|)
block|{
if|if
condition|(
operator|++
name|ic
operator|->
name|ic_allmulti
operator|==
literal|1
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_mcast_task
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_allmulti
operator|>
literal|0
argument_list|,
operator|(
literal|"%s: ic %p not allmulti"
operator|,
name|__func__
operator|,
name|ic
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ic
operator|->
name|ic_allmulti
operator|==
literal|0
condition|)
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_mcast_task
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Synchronize flag bit state in the com structure  * according to the state of all vap's.  This is used,  * for example, to handle state changes via ioctls.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_syncflag_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|flag
condition|)
block|{
name|bit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bit
condition|)
name|ic
operator|->
name|ic_flags
operator||=
name|flag
expr_stmt|;
else|else
name|ic
operator|->
name|ic_flags
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_syncflag
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
block|{
name|flag
operator|=
operator|-
name|flag
expr_stmt|;
name|vap
operator|->
name|iv_flags
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags
operator||=
name|flag
expr_stmt|;
name|ieee80211_syncflag_locked
argument_list|(
name|ic
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Synchronize flags_ht bit state in the com structure  * according to the state of all vap's.  This is used,  * for example, to handle state changes via ioctls.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_syncflag_ht_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|flag
condition|)
block|{
name|bit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bit
condition|)
name|ic
operator|->
name|ic_flags_ht
operator||=
name|flag
expr_stmt|;
else|else
name|ic
operator|->
name|ic_flags_ht
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_syncflag_ht
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
block|{
name|flag
operator|=
operator|-
name|flag
expr_stmt|;
name|vap
operator|->
name|iv_flags_ht
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags_ht
operator||=
name|flag
expr_stmt|;
name|ieee80211_syncflag_ht_locked
argument_list|(
name|ic
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Synchronize flags_ext bit state in the com structure  * according to the state of all vap's.  This is used,  * for example, to handle state changes via ioctls.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_syncflag_ext_locked
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|bit
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|flag
condition|)
block|{
name|bit
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bit
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|flag
expr_stmt|;
else|else
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_syncflag_ext
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|<
literal|0
condition|)
block|{
name|flag
operator|=
operator|-
name|flag
expr_stmt|;
name|vap
operator|->
name|iv_flags_ext
operator|&=
operator|~
name|flag
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags_ext
operator||=
name|flag
expr_stmt|;
name|ieee80211_syncflag_ext_locked
argument_list|(
name|ic
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mapgsm
parameter_list|(
name|u_int
name|freq
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|freq
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_QUARTER
condition|)
name|freq
operator|+=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_HALF
condition|)
name|freq
operator|+=
literal|10
expr_stmt|;
else|else
name|freq
operator|+=
literal|20
expr_stmt|;
comment|/* NB: there is no 907/20 wide but leave room */
return|return
operator|(
name|freq
operator|-
literal|906
operator|*
literal|10
operator|)
operator|/
literal|5
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|mappsb
parameter_list|(
name|u_int
name|freq
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
return|return
literal|37
operator|+
operator|(
operator|(
name|freq
operator|*
literal|10
operator|)
operator|+
operator|(
operator|(
name|freq
operator|%
literal|5
operator|)
operator|==
literal|2
condition|?
literal|5
else|:
literal|0
operator|)
operator|-
literal|49400
operator|)
operator|/
literal|5
return|;
block|}
end_function

begin_comment
comment|/*  * Convert MHz frequency to IEEE channel number.  */
end_comment

begin_function
name|int
name|ieee80211_mhz2ieee
parameter_list|(
name|u_int
name|freq
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
define|#
directive|define
name|IS_FREQ_IN_PSB
parameter_list|(
name|_freq
parameter_list|)
value|((_freq)> 4940&& (_freq)< 4990)
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_GSM
condition|)
return|return
name|mapgsm
argument_list|(
name|freq
argument_list|,
name|flags
argument_list|)
return|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_2GHZ
condition|)
block|{
comment|/* 2GHz band */
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
return|return
literal|14
return|;
if|if
condition|(
name|freq
operator|<
literal|2484
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|freq
operator|-
literal|2407
operator|)
operator|/
literal|5
return|;
else|else
return|return
literal|15
operator|+
operator|(
operator|(
name|freq
operator|-
literal|2512
operator|)
operator|/
literal|20
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_5GHZ
condition|)
block|{
comment|/* 5Ghz band */
if|if
condition|(
name|freq
operator|<=
literal|5000
condition|)
block|{
comment|/* XXX check regdomain? */
if|if
condition|(
name|IS_FREQ_IN_PSB
argument_list|(
name|freq
argument_list|)
condition|)
return|return
name|mappsb
argument_list|(
name|freq
argument_list|,
name|flags
argument_list|)
return|;
return|return
operator|(
name|freq
operator|-
literal|4000
operator|)
operator|/
literal|5
return|;
block|}
else|else
return|return
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
return|;
block|}
else|else
block|{
comment|/* either, guess */
if|if
condition|(
name|freq
operator|==
literal|2484
condition|)
return|return
literal|14
return|;
if|if
condition|(
name|freq
operator|<
literal|2484
condition|)
block|{
if|if
condition|(
literal|907
operator|<=
name|freq
operator|&&
name|freq
operator|<=
literal|922
condition|)
return|return
name|mapgsm
argument_list|(
name|freq
argument_list|,
name|flags
argument_list|)
return|;
return|return
operator|(
operator|(
name|int
operator|)
name|freq
operator|-
literal|2407
operator|)
operator|/
literal|5
return|;
block|}
if|if
condition|(
name|freq
operator|<
literal|5000
condition|)
block|{
if|if
condition|(
name|IS_FREQ_IN_PSB
argument_list|(
name|freq
argument_list|)
condition|)
return|return
name|mappsb
argument_list|(
name|freq
argument_list|,
name|flags
argument_list|)
return|;
elseif|else
if|if
condition|(
name|freq
operator|>
literal|4900
condition|)
return|return
operator|(
name|freq
operator|-
literal|4000
operator|)
operator|/
literal|5
return|;
else|else
return|return
literal|15
operator|+
operator|(
operator|(
name|freq
operator|-
literal|2512
operator|)
operator|/
literal|20
operator|)
return|;
block|}
return|return
operator|(
name|freq
operator|-
literal|5000
operator|)
operator|/
literal|5
return|;
block|}
undef|#
directive|undef
name|IS_FREQ_IN_PSB
block|}
end_function

begin_comment
comment|/*  * Convert channel to IEEE channel number.  */
end_comment

begin_function
name|int
name|ieee80211_chan2ieee
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"invalid channel (NULL)\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* XXX */
block|}
return|return
operator|(
name|c
operator|==
name|IEEE80211_CHAN_ANYC
condition|?
name|IEEE80211_CHAN_ANY
else|:
name|c
operator|->
name|ic_ieee
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert IEEE channel number to MHz frequency.  */
end_comment

begin_function
name|u_int
name|ieee80211_ieee2mhz
parameter_list|(
name|u_int
name|chan
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_GSM
condition|)
return|return
literal|907
operator|+
literal|5
operator|*
operator|(
name|chan
operator|/
literal|10
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_2GHZ
condition|)
block|{
comment|/* 2GHz band */
if|if
condition|(
name|chan
operator|==
literal|14
condition|)
return|return
literal|2484
return|;
if|if
condition|(
name|chan
operator|<
literal|14
condition|)
return|return
literal|2407
operator|+
name|chan
operator|*
literal|5
return|;
else|else
return|return
literal|2512
operator|+
operator|(
operator|(
name|chan
operator|-
literal|15
operator|)
operator|*
literal|20
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|IEEE80211_CHAN_5GHZ
condition|)
block|{
comment|/* 5Ghz band */
if|if
condition|(
name|flags
operator|&
operator|(
name|IEEE80211_CHAN_HALF
operator||
name|IEEE80211_CHAN_QUARTER
operator|)
condition|)
block|{
name|chan
operator|-=
literal|37
expr_stmt|;
return|return
literal|4940
operator|+
name|chan
operator|*
literal|5
operator|+
operator|(
name|chan
operator|%
literal|5
condition|?
literal|2
else|:
literal|0
operator|)
return|;
block|}
return|return
literal|5000
operator|+
operator|(
name|chan
operator|*
literal|5
operator|)
return|;
block|}
else|else
block|{
comment|/* either, guess */
comment|/* XXX can't distinguish PSB+GSM channels */
if|if
condition|(
name|chan
operator|==
literal|14
condition|)
return|return
literal|2484
return|;
if|if
condition|(
name|chan
operator|<
literal|14
condition|)
comment|/* 0-13 */
return|return
literal|2407
operator|+
name|chan
operator|*
literal|5
return|;
if|if
condition|(
name|chan
operator|<
literal|27
condition|)
comment|/* 15-26 */
return|return
literal|2512
operator|+
operator|(
operator|(
name|chan
operator|-
literal|15
operator|)
operator|*
literal|20
operator|)
return|;
return|return
literal|5000
operator|+
operator|(
name|chan
operator|*
literal|5
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|set_extchan
parameter_list|(
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
comment|/* 	 * IEEE Std 802.11-2012, page 1738, subclause 20.3.15.4: 	 * "the secondary channel number shall be 'N + [1,-1] * 4' 	 */
if|if
condition|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_HT40U
condition|)
name|c
operator|->
name|ic_extieee
operator|=
name|c
operator|->
name|ic_ieee
operator|+
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_HT40D
condition|)
name|c
operator|->
name|ic_extieee
operator|=
name|c
operator|->
name|ic_ieee
operator|-
literal|4
expr_stmt|;
else|else
name|c
operator|->
name|ic_extieee
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|addchan
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint8_t
name|ieee
parameter_list|,
name|uint16_t
name|freq
parameter_list|,
name|int8_t
name|maxregpower
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|c
operator|=
operator|&
name|chans
index|[
operator|(
operator|*
name|nchans
operator|)
operator|++
index|]
expr_stmt|;
name|c
operator|->
name|ic_ieee
operator|=
name|ieee
expr_stmt|;
name|c
operator|->
name|ic_freq
operator|=
name|freq
operator|!=
literal|0
condition|?
name|freq
else|:
name|ieee80211_ieee2mhz
argument_list|(
name|ieee
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|c
operator|->
name|ic_maxregpower
operator|=
name|maxregpower
expr_stmt|;
name|c
operator|->
name|ic_maxpower
operator|=
literal|2
operator|*
name|maxregpower
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|flags
expr_stmt|;
name|set_extchan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|copychan_prev
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|KASSERT
argument_list|(
operator|*
name|nchans
operator|>
literal|0
argument_list|,
operator|(
literal|"channel list is empty\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nchans
operator|>=
name|maxchans
condition|)
return|return
operator|(
name|ENOBUFS
operator|)
return|;
name|c
operator|=
operator|&
name|chans
index|[
operator|(
operator|*
name|nchans
operator|)
operator|++
index|]
expr_stmt|;
name|c
index|[
literal|0
index|]
operator|=
name|c
index|[
operator|-
literal|1
index|]
expr_stmt|;
name|c
operator|->
name|ic_flags
operator|=
name|flags
expr_stmt|;
name|set_extchan
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getflags_2ghz
parameter_list|(
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|,
name|uint32_t
name|flags
index|[]
parameter_list|,
name|int
name|ht40
parameter_list|)
block|{
name|int
name|nmodes
decl_stmt|;
name|nmodes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
condition|)
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_B
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
condition|)
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_G
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT20
expr_stmt|;
if|if
condition|(
name|ht40
condition|)
block|{
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT40U
expr_stmt|;
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_G
operator||
name|IEEE80211_CHAN_HT40D
expr_stmt|;
block|}
name|flags
index|[
name|nmodes
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getflags_5ghz
parameter_list|(
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|,
name|uint32_t
name|flags
index|[]
parameter_list|,
name|int
name|ht40
parameter_list|)
block|{
name|int
name|nmodes
decl_stmt|;
name|nmodes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
condition|)
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_A
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
condition|)
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT20
expr_stmt|;
if|if
condition|(
name|ht40
condition|)
block|{
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT40U
expr_stmt|;
name|flags
index|[
name|nmodes
operator|++
index|]
operator|=
name|IEEE80211_CHAN_A
operator||
name|IEEE80211_CHAN_HT40D
expr_stmt|;
block|}
name|flags
index|[
name|nmodes
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getflags
parameter_list|(
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|,
name|uint32_t
name|flags
index|[]
parameter_list|,
name|int
name|ht40
parameter_list|)
block|{
name|flags
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11A
argument_list|)
operator|||
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
condition|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11B
argument_list|)
operator|||
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11G
argument_list|)
operator|||
name|isset
argument_list|(
name|bands
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
return|return;
name|getflags_5ghz
argument_list|(
name|bands
argument_list|,
name|flags
argument_list|,
name|ht40
argument_list|)
expr_stmt|;
block|}
else|else
name|getflags_2ghz
argument_list|(
name|bands
argument_list|,
name|flags
argument_list|,
name|ht40
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add one 20 MHz channel into specified channel list.  */
end_comment

begin_function
name|int
name|ieee80211_add_channel
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint8_t
name|ieee
parameter_list|,
name|uint16_t
name|freq
parameter_list|,
name|int8_t
name|maxregpower
parameter_list|,
name|uint32_t
name|chan_flags
parameter_list|,
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|)
block|{
name|uint32_t
name|flags
index|[
name|IEEE80211_MODE_MAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|error
decl_stmt|;
name|getflags
argument_list|(
name|bands
argument_list|,
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: no correct mode provided\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|addchan
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ieee
argument_list|,
name|freq
argument_list|,
name|maxregpower
argument_list|,
name|flags
index|[
literal|0
index|]
operator||
name|chan_flags
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|flags
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|error
operator|=
name|copychan_prev
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|flags
index|[
name|i
index|]
operator||
name|chan_flags
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|findchannel
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|nchans
parameter_list|,
name|uint16_t
name|freq
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|flags
operator|&=
name|IEEE80211_CHAN_ALLTURBO
expr_stmt|;
comment|/* brute force search */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|chans
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBO
operator|)
operator|==
name|flags
condition|)
return|return
name|c
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Add 40 MHz channel pair into specified channel list.  */
end_comment

begin_function
name|int
name|ieee80211_add_channel_ht40
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
name|uint8_t
name|ieee
parameter_list|,
name|int8_t
name|maxregpower
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|cent
decl_stmt|,
modifier|*
name|extc
decl_stmt|;
name|uint16_t
name|freq
decl_stmt|;
name|int
name|error
decl_stmt|;
name|freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|ieee
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Each entry defines an HT40 channel pair; find the 	 * center channel, then the extension channel above. 	 */
name|flags
operator||=
name|IEEE80211_CHAN_HT20
expr_stmt|;
name|cent
operator|=
name|findchannel
argument_list|(
name|chans
argument_list|,
operator|*
name|nchans
argument_list|,
name|freq
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|cent
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|extc
operator|=
name|findchannel
argument_list|(
name|chans
argument_list|,
operator|*
name|nchans
argument_list|,
name|freq
operator|+
literal|20
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|extc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
name|flags
operator|&=
operator|~
name|IEEE80211_CHAN_HT
expr_stmt|;
name|error
operator|=
name|addchan
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|cent
operator|->
name|ic_ieee
argument_list|,
name|cent
operator|->
name|ic_freq
argument_list|,
name|maxregpower
argument_list|,
name|flags
operator||
name|IEEE80211_CHAN_HT40U
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|addchan
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|extc
operator|->
name|ic_ieee
argument_list|,
name|extc
operator|->
name|ic_freq
argument_list|,
name|maxregpower
argument_list|,
name|flags
operator||
name|IEEE80211_CHAN_HT40D
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adds channels into specified channel list (ieee[] array must be sorted).  * Channels are already sorted.  */
end_comment

begin_function
specifier|static
name|int
name|add_chanlist
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
specifier|const
name|uint8_t
name|ieee
index|[]
parameter_list|,
name|int
name|nieee
parameter_list|,
name|uint32_t
name|flags
index|[]
parameter_list|)
block|{
name|uint16_t
name|freq
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|error
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nieee
condition|;
name|i
operator|++
control|)
block|{
name|freq
operator|=
name|ieee80211_ieee2mhz
argument_list|(
name|ieee
index|[
name|i
index|]
argument_list|,
name|flags
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|flags
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|flags
index|[
name|j
index|]
operator|&
name|IEEE80211_CHAN_HT40D
condition|)
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|ieee
index|[
name|i
index|]
operator|<
name|ieee
index|[
literal|0
index|]
operator|+
literal|4
operator|||
name|freq
operator|-
literal|20
operator|!=
name|ieee80211_ieee2mhz
argument_list|(
name|ieee
index|[
name|i
index|]
operator|-
literal|4
argument_list|,
name|flags
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|flags
index|[
name|j
index|]
operator|&
name|IEEE80211_CHAN_HT40U
condition|)
if|if
condition|(
name|i
operator|==
name|nieee
operator|-
literal|1
operator|||
name|ieee
index|[
name|i
index|]
operator|+
literal|4
operator|>
name|ieee
index|[
name|nieee
operator|-
literal|1
index|]
operator|||
name|freq
operator|+
literal|20
operator|!=
name|ieee80211_ieee2mhz
argument_list|(
name|ieee
index|[
name|i
index|]
operator|+
literal|4
argument_list|,
name|flags
index|[
name|j
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|addchan
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ieee
index|[
name|i
index|]
argument_list|,
name|freq
argument_list|,
literal|0
argument_list|,
name|flags
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|copychan_prev
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|flags
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_add_channel_list_2ghz
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
specifier|const
name|uint8_t
name|ieee
index|[]
parameter_list|,
name|int
name|nieee
parameter_list|,
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|,
name|int
name|ht40
parameter_list|)
block|{
name|uint32_t
name|flags
index|[
name|IEEE80211_MODE_MAX
index|]
decl_stmt|;
name|getflags_2ghz
argument_list|(
name|bands
argument_list|,
name|flags
argument_list|,
name|ht40
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: no correct mode provided\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|add_chanlist
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ieee
argument_list|,
name|nieee
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_add_channel_list_5ghz
parameter_list|(
name|struct
name|ieee80211_channel
name|chans
index|[]
parameter_list|,
name|int
name|maxchans
parameter_list|,
name|int
modifier|*
name|nchans
parameter_list|,
specifier|const
name|uint8_t
name|ieee
index|[]
parameter_list|,
name|int
name|nieee
parameter_list|,
specifier|const
name|uint8_t
name|bands
index|[]
parameter_list|,
name|int
name|ht40
parameter_list|)
block|{
name|uint32_t
name|flags
index|[
name|IEEE80211_MODE_MAX
index|]
decl_stmt|;
name|getflags_5ghz
argument_list|(
name|bands
argument_list|,
name|flags
argument_list|,
name|ht40
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|flags
index|[
literal|0
index|]
operator|!=
literal|0
argument_list|,
operator|(
literal|"%s: no correct mode provided\n"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|add_chanlist
argument_list|(
name|chans
argument_list|,
name|maxchans
argument_list|,
name|nchans
argument_list|,
name|ieee
argument_list|,
name|nieee
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate a channel given a frequency+flags.  We cache  * the previous lookup to optimize switching between two  * channels--as happens with dynamic turbo.  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_find_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|freq
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|flags
operator|&=
name|IEEE80211_CHAN_ALLTURBO
expr_stmt|;
name|c
operator|=
name|ic
operator|->
name|ic_prevchan
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBO
operator|)
operator|==
name|flags
condition|)
return|return
name|c
return|;
comment|/* brute force search */
return|return
operator|(
name|findchannel
argument_list|(
name|ic
operator|->
name|ic_channels
argument_list|,
name|ic
operator|->
name|ic_nchans
argument_list|,
name|freq
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Locate a channel given a channel number+flags.  We cache  * the previous lookup to optimize switching between two  * channels--as happens with dynamic turbo.  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_find_channel_byieee
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|ieee
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|flags
operator|&=
name|IEEE80211_CHAN_ALLTURBO
expr_stmt|;
name|c
operator|=
name|ic
operator|->
name|ic_prevchan
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|->
name|ic_ieee
operator|==
name|ieee
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBO
operator|)
operator|==
name|flags
condition|)
return|return
name|c
return|;
comment|/* brute force search */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_ieee
operator|==
name|ieee
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBO
operator|)
operator|==
name|flags
condition|)
return|return
name|c
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup a channel suitable for the given rx status.  *  * This is used to find a channel for a frame (eg beacon, probe  * response) based purely on the received PHY information.  *  * For now it tries to do it based on R_FREQ / R_IEEE.  * This is enough for 11bg and 11a (and thus 11ng/11na)  * but it will not be enough for GSM, PSB channels and the  * like.  It also doesn't know about legacy-turbog and  * legacy-turbo modes, which some offload NICs actually  * support in weird ways.  *  * Takes the ic and rxstatus; returns the channel or NULL  * if not found.  *  * XXX TODO: Add support for that when the need arises.  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_lookup_channel_rxstatus
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_rx_stats
modifier|*
name|rxs
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|rxs
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Strictly speaking we only use freq for now, 	 * however later on we may wish to just store 	 * the ieee for verification. 	 */
if|if
condition|(
operator|(
name|rxs
operator|->
name|r_flags
operator|&
name|IEEE80211_R_FREQ
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|rxs
operator|->
name|r_flags
operator|&
name|IEEE80211_R_IEEE
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * If the rx status contains a valid ieee/freq, then 	 * ensure we populate the correct channel information 	 * in rxchan before passing it up to the scan infrastructure. 	 * Offload NICs will pass up beacons from all channels 	 * during background scans. 	 */
comment|/* Determine a band */
comment|/* XXX should be done by the driver? */
if|if
condition|(
name|rxs
operator|->
name|c_freq
operator|<
literal|3000
condition|)
block|{
name|flags
operator|=
name|IEEE80211_CHAN_G
expr_stmt|;
block|}
else|else
block|{
name|flags
operator|=
name|IEEE80211_CHAN_A
expr_stmt|;
block|}
comment|/* Channel lookup */
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|rxs
operator|->
name|c_freq
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
argument_list|,
literal|"%s: freq=%d, ieee=%d, flags=0x%08x; c=%p\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|rxs
operator|->
name|c_freq
argument_list|,
operator|(
name|int
operator|)
name|rxs
operator|->
name|c_ieee
argument_list|,
name|flags
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|addmedia
parameter_list|(
name|struct
name|ifmedia
modifier|*
name|media
parameter_list|,
name|int
name|caps
parameter_list|,
name|int
name|addsta
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|mword
parameter_list|)
block|{
define|#
directive|define
name|ADD
parameter_list|(
name|_ic
parameter_list|,
name|_s
parameter_list|,
name|_o
parameter_list|)
define|\
value|ifmedia_add(media, \ 		IFM_MAKEWORD(IFM_IEEE80211, (_s), (_o), 0), 0, NULL)
specifier|static
specifier|const
name|u_int
name|mopts
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
name|IFM_AUTO
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
name|IFM_IEEE80211_11A
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
name|IFM_IEEE80211_11B
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
name|IFM_IEEE80211_11G
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
name|IFM_IEEE80211_FH
block|,
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
name|IFM_IEEE80211_11A
operator||
name|IFM_IEEE80211_TURBO
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
name|IFM_IEEE80211_11G
operator||
name|IFM_IEEE80211_TURBO
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
name|IFM_IEEE80211_11A
operator||
name|IFM_IEEE80211_TURBO
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
name|IFM_IEEE80211_11A
block|,
comment|/* XXX */
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
name|IFM_IEEE80211_11A
block|,
comment|/* XXX */
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
name|IFM_IEEE80211_11NA
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
name|IFM_IEEE80211_11NG
block|, 	}
decl_stmt|;
name|u_int
name|mopt
decl_stmt|;
name|mopt
operator|=
name|mopts
index|[
name|mode
index|]
expr_stmt|;
if|if
condition|(
name|addsta
condition|)
name|ADD
argument_list|(
name|ic
argument_list|,
name|mword
argument_list|,
name|mopt
argument_list|)
expr_stmt|;
comment|/* STA mode has no cap */
if|if
condition|(
name|caps
operator|&
name|IEEE80211_C_IBSS
condition|)
name|ADD
argument_list|(
name|media
argument_list|,
name|mword
argument_list|,
name|mopt
operator||
name|IFM_IEEE80211_ADHOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|IEEE80211_C_HOSTAP
condition|)
name|ADD
argument_list|(
name|media
argument_list|,
name|mword
argument_list|,
name|mopt
operator||
name|IFM_IEEE80211_HOSTAP
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|IEEE80211_C_AHDEMO
condition|)
name|ADD
argument_list|(
name|media
argument_list|,
name|mword
argument_list|,
name|mopt
operator||
name|IFM_IEEE80211_ADHOC
operator||
name|IFM_FLAG0
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|IEEE80211_C_MONITOR
condition|)
name|ADD
argument_list|(
name|media
argument_list|,
name|mword
argument_list|,
name|mopt
operator||
name|IFM_IEEE80211_MONITOR
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|IEEE80211_C_WDS
condition|)
name|ADD
argument_list|(
name|media
argument_list|,
name|mword
argument_list|,
name|mopt
operator||
name|IFM_IEEE80211_WDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|IEEE80211_C_MBSS
condition|)
name|ADD
argument_list|(
name|media
argument_list|,
name|mword
argument_list|,
name|mopt
operator||
name|IFM_IEEE80211_MBSS
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ADD
block|}
end_function

begin_comment
comment|/*  * Setup the media data structures according to the channel and  * rate tables.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_media_setup
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ifmedia
modifier|*
name|media
parameter_list|,
name|int
name|caps
parameter_list|,
name|int
name|addsta
parameter_list|,
name|ifm_change_cb_t
name|media_change
parameter_list|,
name|ifm_stat_cb_t
name|media_stat
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rate
decl_stmt|,
name|maxrate
decl_stmt|,
name|mword
decl_stmt|,
name|r
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
name|struct
name|ieee80211_rateset
name|allrates
decl_stmt|;
comment|/* 	 * Fill in media characteristics. 	 */
name|ifmedia_init
argument_list|(
name|media
argument_list|,
literal|0
argument_list|,
name|media_change
argument_list|,
name|media_stat
argument_list|)
expr_stmt|;
name|maxrate
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Add media for legacy operating modes. 	 */
name|memset
argument_list|(
operator|&
name|allrates
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|allrates
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|mode
operator|=
name|IEEE80211_MODE_AUTO
init|;
name|mode
operator|<
name|IEEE80211_MODE_11NA
condition|;
name|mode
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|addmedia
argument_list|(
name|media
argument_list|,
name|caps
argument_list|,
name|addsta
argument_list|,
name|mode
argument_list|,
name|IFM_AUTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_AUTO
condition|)
continue|continue;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|rate
operator|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
expr_stmt|;
name|mword
operator|=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|rate
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mword
operator|==
literal|0
condition|)
continue|continue;
name|addmedia
argument_list|(
name|media
argument_list|,
name|caps
argument_list|,
name|addsta
argument_list|,
name|mode
argument_list|,
name|mword
argument_list|)
expr_stmt|;
comment|/* 			 * Add legacy rate to the collection of all rates. 			 */
name|r
operator|=
name|rate
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|allrates
operator|.
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|allrates
operator|.
name|rs_rates
index|[
name|j
index|]
operator|==
name|r
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|allrates
operator|.
name|rs_nrates
condition|)
block|{
comment|/* unique, add to the set */
name|allrates
operator|.
name|rs_rates
index|[
name|j
index|]
operator|=
name|r
expr_stmt|;
name|allrates
operator|.
name|rs_nrates
operator|++
expr_stmt|;
block|}
name|rate
operator|=
operator|(
name|rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|rate
operator|>
name|maxrate
condition|)
name|maxrate
operator|=
name|rate
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|allrates
operator|.
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|mword
operator|=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|allrates
operator|.
name|rs_rates
index|[
name|i
index|]
argument_list|,
name|IEEE80211_MODE_AUTO
argument_list|)
expr_stmt|;
if|if
condition|(
name|mword
operator|==
literal|0
condition|)
continue|continue;
comment|/* NB: remove media options from mword */
name|addmedia
argument_list|(
name|media
argument_list|,
name|caps
argument_list|,
name|addsta
argument_list|,
name|IEEE80211_MODE_AUTO
argument_list|,
name|IFM_SUBTYPE
argument_list|(
name|mword
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add HT/11n media.  Note that we do not have enough 	 * bits in the media subtype to express the MCS so we 	 * use a "placeholder" media subtype and any fixed MCS 	 * must be specified with a different mechanism. 	 */
for|for
control|(
init|;
name|mode
operator|<=
name|IEEE80211_MODE_11NG
condition|;
name|mode
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|addmedia
argument_list|(
name|media
argument_list|,
name|caps
argument_list|,
name|addsta
argument_list|,
name|mode
argument_list|,
name|IFM_AUTO
argument_list|)
expr_stmt|;
name|addmedia
argument_list|(
name|media
argument_list|,
name|caps
argument_list|,
name|addsta
argument_list|,
name|mode
argument_list|,
name|IFM_IEEE80211_MCS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
operator|||
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
block|{
name|addmedia
argument_list|(
name|media
argument_list|,
name|caps
argument_list|,
name|addsta
argument_list|,
name|IEEE80211_MODE_AUTO
argument_list|,
name|IFM_IEEE80211_MCS
argument_list|)
expr_stmt|;
name|i
operator|=
name|ic
operator|->
name|ic_txstream
operator|*
literal|8
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI40
operator|)
condition|)
name|rate
operator|=
name|ieee80211_htrates
index|[
name|i
index|]
operator|.
name|ht40_rate_400ns
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
condition|)
name|rate
operator|=
name|ieee80211_htrates
index|[
name|i
index|]
operator|.
name|ht40_rate_800ns
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI20
operator|)
condition|)
name|rate
operator|=
name|ieee80211_htrates
index|[
name|i
index|]
operator|.
name|ht20_rate_400ns
expr_stmt|;
else|else
name|rate
operator|=
name|ieee80211_htrates
index|[
name|i
index|]
operator|.
name|ht20_rate_800ns
expr_stmt|;
if|if
condition|(
name|rate
operator|>
name|maxrate
condition|)
name|maxrate
operator|=
name|rate
expr_stmt|;
block|}
return|return
name|maxrate
return|;
block|}
end_function

begin_comment
comment|/* XXX inline or eliminate? */
end_comment

begin_function
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|ieee80211_get_suprates
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
comment|/* XXX does this work for 11ng basic rates? */
return|return
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|ieee80211_chan2mode
argument_list|(
name|c
argument_list|)
index|]
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rate
decl_stmt|,
name|mword
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|rs
decl_stmt|;
comment|/* NB: skip AUTO since it has no rates */
for|for
control|(
name|mode
operator|=
name|IEEE80211_MODE_AUTO
operator|+
literal|1
init|;
name|mode
operator|<
name|IEEE80211_MODE_11NA
condition|;
name|mode
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|mode
argument_list|)
condition|)
continue|continue;
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s rates: "
argument_list|,
name|ieee80211_phymode_name
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
name|rs
operator|=
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|mword
operator|=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|mword
operator|==
literal|0
condition|)
continue|continue;
name|rate
operator|=
name|ieee80211_media2rate
argument_list|(
name|mword
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d%sMbps"
argument_list|,
operator|(
name|i
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|rate
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|rate
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|?
literal|".5"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ieee80211_ht_announce
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_announce_channels
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|char
name|type
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cw
decl_stmt|;
name|printf
argument_list|(
literal|"Chan  Freq  CW  RegPwr  MinPwr  MaxPwr\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ST
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'S'
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_108A
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'T'
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'G'
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'n'
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'a'
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'g'
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
condition|)
name|type
operator|=
literal|'b'
expr_stmt|;
else|else
name|type
operator|=
literal|'f'
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|c
argument_list|)
condition|)
name|cw
operator|=
literal|40
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|c
argument_list|)
condition|)
name|cw
operator|=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|c
argument_list|)
condition|)
name|cw
operator|=
literal|5
expr_stmt|;
else|else
name|cw
operator|=
literal|20
expr_stmt|;
name|printf
argument_list|(
literal|"%4d  %4d%c %2d%c %6d  %4d.%d  %4d.%d\n"
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|type
argument_list|,
name|cw
argument_list|,
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|c
argument_list|)
condition|?
literal|'+'
else|:
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|c
argument_list|)
condition|?
literal|'-'
else|:
literal|' '
argument_list|,
name|c
operator|->
name|ic_maxregpower
argument_list|,
name|c
operator|->
name|ic_minpower
operator|/
literal|2
argument_list|,
name|c
operator|->
name|ic_minpower
operator|&
literal|1
condition|?
literal|5
else|:
literal|0
argument_list|,
name|c
operator|->
name|ic_maxpower
operator|/
literal|2
argument_list|,
name|c
operator|->
name|ic_maxpower
operator|&
literal|1
condition|?
literal|5
else|:
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|media2mode
parameter_list|(
specifier|const
name|struct
name|ifmedia_entry
modifier|*
name|ime
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|uint16_t
modifier|*
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|IFM_MODE
argument_list|(
name|ime
operator|->
name|ifm_media
argument_list|)
condition|)
block|{
case|case
name|IFM_IEEE80211_11A
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_11A
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_11B
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_11B
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_11G
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_11G
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_FH
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_FH
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_11NA
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_11NA
expr_stmt|;
break|break;
case|case
name|IFM_IEEE80211_11NG
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_11NG
expr_stmt|;
break|break;
case|case
name|IFM_AUTO
case|:
operator|*
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
break|break;
default|default:
return|return
literal|0
return|;
block|}
comment|/* 	 * Turbo mode is an ``option''. 	 * XXX does not apply to AUTO 	 */
if|if
condition|(
name|ime
operator|->
name|ifm_media
operator|&
name|IFM_IEEE80211_TURBO
condition|)
block|{
if|if
condition|(
operator|*
name|mode
operator|==
name|IEEE80211_MODE_11A
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|IEEE80211_F_TURBOP
condition|)
operator|*
name|mode
operator|=
name|IEEE80211_MODE_TURBO_A
expr_stmt|;
else|else
operator|*
name|mode
operator|=
name|IEEE80211_MODE_STURBO_A
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|mode
operator|==
name|IEEE80211_MODE_11G
condition|)
operator|*
name|mode
operator|=
name|IEEE80211_MODE_TURBO_G
expr_stmt|;
else|else
return|return
literal|0
return|;
block|}
comment|/* XXX HT40 +/- */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Handle a media change request on the vap interface.  */
end_comment

begin_function
name|int
name|ieee80211_media_change
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ifmedia_entry
modifier|*
name|ime
init|=
name|vap
operator|->
name|iv_media
operator|.
name|ifm_cur
decl_stmt|;
name|uint16_t
name|newmode
decl_stmt|;
if|if
condition|(
operator|!
name|media2mode
argument_list|(
name|ime
argument_list|,
name|vap
operator|->
name|iv_flags
argument_list|,
operator|&
name|newmode
argument_list|)
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|vap
operator|->
name|iv_des_mode
operator|!=
name|newmode
condition|)
block|{
name|vap
operator|->
name|iv_des_mode
operator|=
name|newmode
expr_stmt|;
comment|/* XXX kick state machine if up+running */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Common code to calculate the media status word  * from the operating mode and channel state.  */
end_comment

begin_function
specifier|static
name|int
name|media_status
parameter_list|(
name|enum
name|ieee80211_opmode
name|opmode
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|status
operator|=
name|IFM_IEEE80211
expr_stmt|;
switch|switch
condition|(
name|opmode
condition|)
block|{
case|case
name|IEEE80211_M_STA
case|:
break|break;
case|case
name|IEEE80211_M_IBSS
case|:
name|status
operator||=
name|IFM_IEEE80211_ADHOC
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_HOSTAP
case|:
name|status
operator||=
name|IFM_IEEE80211_HOSTAP
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MONITOR
case|:
name|status
operator||=
name|IFM_IEEE80211_MONITOR
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_AHDEMO
case|:
name|status
operator||=
name|IFM_IEEE80211_ADHOC
operator||
name|IFM_FLAG0
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_WDS
case|:
name|status
operator||=
name|IFM_IEEE80211_WDS
expr_stmt|;
break|break;
case|case
name|IEEE80211_M_MBSS
case|:
name|status
operator||=
name|IFM_IEEE80211_MBSS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_HTA
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|status
operator||=
name|IFM_IEEE80211_11NA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HTG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|status
operator||=
name|IFM_IEEE80211_11NG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|status
operator||=
name|IFM_IEEE80211_11A
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|status
operator||=
name|IFM_IEEE80211_11B
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|status
operator||=
name|IFM_IEEE80211_11G
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|status
operator||=
name|IFM_IEEE80211_FH
expr_stmt|;
block|}
comment|/* XXX else complain? */
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
name|status
operator||=
name|IFM_IEEE80211_TURBO
expr_stmt|;
if|#
directive|if
literal|0
block|if (IEEE80211_IS_CHAN_HT20(chan)) 		status |= IFM_IEEE80211_HT20; 	if (IEEE80211_IS_CHAN_HT40(chan)) 		status |= IFM_IEEE80211_HT40;
endif|#
directive|endif
return|return
name|status
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_media_status
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|struct
name|ifmediareq
modifier|*
name|imr
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|imr
operator|->
name|ifm_status
operator|=
name|IFM_AVALID
expr_stmt|;
comment|/* 	 * NB: use the current channel's mode to lock down a xmit 	 * rate only when running; otherwise we may have a mismatch 	 * in which case the rate will not be convertible. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
operator|||
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_SLEEP
condition|)
block|{
name|imr
operator|->
name|ifm_status
operator||=
name|IFM_ACTIVE
expr_stmt|;
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
block|}
else|else
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
name|imr
operator|->
name|ifm_active
operator|=
name|media_status
argument_list|(
name|vap
operator|->
name|iv_opmode
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate a current rate if possible. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
operator|.
name|ucastrate
operator|!=
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
comment|/* 		 * A fixed rate is set, report that. 		 */
name|imr
operator|->
name|ifm_active
operator||=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
operator|.
name|ucastrate
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
comment|/* 		 * In station mode report the current transmit rate. 		 */
name|imr
operator|->
name|ifm_active
operator||=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|vap
operator|->
name|iv_bss
operator|->
name|ni_txrate
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
else|else
name|imr
operator|->
name|ifm_active
operator||=
name|IFM_AUTO
expr_stmt|;
if|if
condition|(
name|imr
operator|->
name|ifm_status
operator|&
name|IFM_ACTIVE
condition|)
name|imr
operator|->
name|ifm_current
operator|=
name|imr
operator|->
name|ifm_active
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the current phy mode and recalculate the active channel  * set based on the available channels for this mode.  Also  * select a new default/current channel if the current one is  * inappropriate for this mode.  */
end_comment

begin_function
name|int
name|ieee80211_setmode
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
comment|/* 	 * Adjust basic rates in 11b/11g supported rate set. 	 * Note that if operating on a hal/quarter rate channel 	 * this is a noop as those rates sets are different 	 * and used instead. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11G
operator|||
name|mode
operator|==
name|IEEE80211_MODE_11B
condition|)
name|ieee80211_setbasicrates
argument_list|(
operator|&
name|ic
operator|->
name|ic_sup_rates
index|[
name|mode
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_curmode
operator|=
name|mode
expr_stmt|;
name|ieee80211_reset_erp
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* reset ERP state */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Return the phy mode for with the specified channel.  */
end_comment

begin_function
name|enum
name|ieee80211_phymode
name|ieee80211_chan2mode
parameter_list|(
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HTA
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_11NA
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HTG
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_11NG
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_TURBO_G
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ST
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_STURBO_A
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_TURBO_A
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HALF
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_HALF
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_QUARTER
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_QUARTER
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_11A
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_11G
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_11B
return|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_FHSS
argument_list|(
name|chan
argument_list|)
condition|)
return|return
name|IEEE80211_MODE_FH
return|;
comment|/* NB: should not get here */
name|printf
argument_list|(
literal|"%s: cannot map channel to mode; freq %u flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|IEEE80211_MODE_11B
return|;
block|}
end_function

begin_struct
struct|struct
name|ratemedia
block|{
name|u_int
name|match
decl_stmt|;
comment|/* rate + mode */
name|u_int
name|media
decl_stmt|;
comment|/* if_media rate */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|findmedia
parameter_list|(
specifier|const
name|struct
name|ratemedia
name|rates
index|[]
parameter_list|,
name|int
name|n
parameter_list|,
name|u_int
name|match
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|rates
index|[
name|i
index|]
operator|.
name|match
operator|==
name|match
condition|)
return|return
name|rates
index|[
name|i
index|]
operator|.
name|media
return|;
return|return
name|IFM_AUTO
return|;
block|}
end_function

begin_comment
comment|/*  * Convert IEEE80211 rate value to ifmedia subtype.  * Rate is either a legacy rate in units of 0.5Mbps  * or an MCS index.  */
end_comment

begin_function
name|int
name|ieee80211_rate2media
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|rate
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ratemedia
name|rates
index|[]
init|=
block|{
block|{
literal|2
operator||
name|IFM_IEEE80211_FH
block|,
name|IFM_IEEE80211_FH1
block|}
block|,
block|{
literal|4
operator||
name|IFM_IEEE80211_FH
block|,
name|IFM_IEEE80211_FH2
block|}
block|,
block|{
literal|2
operator||
name|IFM_IEEE80211_11B
block|,
name|IFM_IEEE80211_DS1
block|}
block|,
block|{
literal|4
operator||
name|IFM_IEEE80211_11B
block|,
name|IFM_IEEE80211_DS2
block|}
block|,
block|{
literal|11
operator||
name|IFM_IEEE80211_11B
block|,
name|IFM_IEEE80211_DS5
block|}
block|,
block|{
literal|22
operator||
name|IFM_IEEE80211_11B
block|,
name|IFM_IEEE80211_DS11
block|}
block|,
block|{
literal|44
operator||
name|IFM_IEEE80211_11B
block|,
name|IFM_IEEE80211_DS22
block|}
block|,
block|{
literal|12
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM6
block|}
block|,
block|{
literal|18
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM9
block|}
block|,
block|{
literal|24
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM12
block|}
block|,
block|{
literal|36
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM18
block|}
block|,
block|{
literal|48
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM24
block|}
block|,
block|{
literal|72
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM36
block|}
block|,
block|{
literal|96
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM48
block|}
block|,
block|{
literal|108
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM54
block|}
block|,
block|{
literal|2
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_DS1
block|}
block|,
block|{
literal|4
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_DS2
block|}
block|,
block|{
literal|11
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_DS5
block|}
block|,
block|{
literal|22
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_DS11
block|}
block|,
block|{
literal|12
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM6
block|}
block|,
block|{
literal|18
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM9
block|}
block|,
block|{
literal|24
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM12
block|}
block|,
block|{
literal|36
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM18
block|}
block|,
block|{
literal|48
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM24
block|}
block|,
block|{
literal|72
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM36
block|}
block|,
block|{
literal|96
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM48
block|}
block|,
block|{
literal|108
operator||
name|IFM_IEEE80211_11G
block|,
name|IFM_IEEE80211_OFDM54
block|}
block|,
block|{
literal|6
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM3
block|}
block|,
block|{
literal|9
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM4
block|}
block|,
block|{
literal|54
operator||
name|IFM_IEEE80211_11A
block|,
name|IFM_IEEE80211_OFDM27
block|}
block|,
comment|/* NB: OFDM72 doesn't really exist so we don't handle it */
block|}
decl_stmt|;
specifier|static
specifier|const
name|struct
name|ratemedia
name|htrates
index|[]
init|=
block|{
block|{
literal|0
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|1
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|2
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|3
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|4
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|5
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|6
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|7
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|8
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|9
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|10
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|11
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|12
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|13
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|14
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|15
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|16
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|17
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|18
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|19
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|20
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|21
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|22
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|23
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|24
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|25
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|26
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|27
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|28
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|29
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|30
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|31
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|32
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|33
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|34
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|35
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|36
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|37
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|38
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|39
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|40
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|41
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|42
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|43
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|44
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|45
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|46
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|47
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|48
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|49
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|50
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|51
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|52
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|53
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|54
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|55
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|56
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|57
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|58
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|59
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|60
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|61
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|62
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|63
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|64
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|65
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|66
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|67
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|68
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|69
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|70
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|71
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|72
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|73
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|74
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|75
block|,
name|IFM_IEEE80211_MCS
block|}
block|,
block|{
literal|76
block|,
name|IFM_IEEE80211_MCS
block|}
block|, 	}
decl_stmt|;
name|int
name|m
decl_stmt|;
comment|/* 	 * Check 11n rates first for match as an MCS. 	 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11NA
condition|)
block|{
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
name|rate
operator|&=
operator|~
name|IEEE80211_RATE_MCS
expr_stmt|;
name|m
operator|=
name|findmedia
argument_list|(
name|htrates
argument_list|,
name|nitems
argument_list|(
name|htrates
argument_list|)
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|IFM_AUTO
condition|)
return|return
name|m
operator||
name|IFM_IEEE80211_11NA
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11NG
condition|)
block|{
comment|/* NB: 12 is ambiguous, it will be treated as an MCS */
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_MCS
condition|)
block|{
name|rate
operator|&=
operator|~
name|IEEE80211_RATE_MCS
expr_stmt|;
name|m
operator|=
name|findmedia
argument_list|(
name|htrates
argument_list|,
name|nitems
argument_list|(
name|htrates
argument_list|)
argument_list|,
name|rate
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|IFM_AUTO
condition|)
return|return
name|m
operator||
name|IFM_IEEE80211_11NG
return|;
block|}
block|}
name|rate
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|IEEE80211_MODE_11A
case|:
case|case
name|IEEE80211_MODE_HALF
case|:
comment|/* XXX good 'nuf */
case|case
name|IEEE80211_MODE_QUARTER
case|:
case|case
name|IEEE80211_MODE_11NA
case|:
case|case
name|IEEE80211_MODE_TURBO_A
case|:
case|case
name|IEEE80211_MODE_STURBO_A
case|:
return|return
name|findmedia
argument_list|(
name|rates
argument_list|,
name|nitems
argument_list|(
name|rates
argument_list|)
argument_list|,
name|rate
operator||
name|IFM_IEEE80211_11A
argument_list|)
return|;
case|case
name|IEEE80211_MODE_11B
case|:
return|return
name|findmedia
argument_list|(
name|rates
argument_list|,
name|nitems
argument_list|(
name|rates
argument_list|)
argument_list|,
name|rate
operator||
name|IFM_IEEE80211_11B
argument_list|)
return|;
case|case
name|IEEE80211_MODE_FH
case|:
return|return
name|findmedia
argument_list|(
name|rates
argument_list|,
name|nitems
argument_list|(
name|rates
argument_list|)
argument_list|,
name|rate
operator||
name|IFM_IEEE80211_FH
argument_list|)
return|;
case|case
name|IEEE80211_MODE_AUTO
case|:
comment|/* NB: ic may be NULL for some drivers */
if|if
condition|(
name|ic
operator|!=
name|NULL
operator|&&
name|ic
operator|->
name|ic_phytype
operator|==
name|IEEE80211_T_FH
condition|)
return|return
name|findmedia
argument_list|(
name|rates
argument_list|,
name|nitems
argument_list|(
name|rates
argument_list|)
argument_list|,
name|rate
operator||
name|IFM_IEEE80211_FH
argument_list|)
return|;
comment|/* NB: hack, 11g matches both 11b+11a rates */
comment|/* fall thru... */
case|case
name|IEEE80211_MODE_11G
case|:
case|case
name|IEEE80211_MODE_11NG
case|:
case|case
name|IEEE80211_MODE_TURBO_G
case|:
return|return
name|findmedia
argument_list|(
name|rates
argument_list|,
name|nitems
argument_list|(
name|rates
argument_list|)
argument_list|,
name|rate
operator||
name|IFM_IEEE80211_11G
argument_list|)
return|;
block|}
return|return
name|IFM_AUTO
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_media2rate
parameter_list|(
name|int
name|mword
parameter_list|)
block|{
specifier|static
specifier|const
name|int
name|ieeerates
index|[]
init|=
block|{
operator|-
literal|1
block|,
comment|/* IFM_AUTO */
literal|0
block|,
comment|/* IFM_MANUAL */
literal|0
block|,
comment|/* IFM_NONE */
literal|2
block|,
comment|/* IFM_IEEE80211_FH1 */
literal|4
block|,
comment|/* IFM_IEEE80211_FH2 */
literal|2
block|,
comment|/* IFM_IEEE80211_DS1 */
literal|4
block|,
comment|/* IFM_IEEE80211_DS2 */
literal|11
block|,
comment|/* IFM_IEEE80211_DS5 */
literal|22
block|,
comment|/* IFM_IEEE80211_DS11 */
literal|44
block|,
comment|/* IFM_IEEE80211_DS22 */
literal|12
block|,
comment|/* IFM_IEEE80211_OFDM6 */
literal|18
block|,
comment|/* IFM_IEEE80211_OFDM9 */
literal|24
block|,
comment|/* IFM_IEEE80211_OFDM12 */
literal|36
block|,
comment|/* IFM_IEEE80211_OFDM18 */
literal|48
block|,
comment|/* IFM_IEEE80211_OFDM24 */
literal|72
block|,
comment|/* IFM_IEEE80211_OFDM36 */
literal|96
block|,
comment|/* IFM_IEEE80211_OFDM48 */
literal|108
block|,
comment|/* IFM_IEEE80211_OFDM54 */
literal|144
block|,
comment|/* IFM_IEEE80211_OFDM72 */
literal|0
block|,
comment|/* IFM_IEEE80211_DS354k */
literal|0
block|,
comment|/* IFM_IEEE80211_DS512k */
literal|6
block|,
comment|/* IFM_IEEE80211_OFDM3 */
literal|9
block|,
comment|/* IFM_IEEE80211_OFDM4 */
literal|54
block|,
comment|/* IFM_IEEE80211_OFDM27 */
operator|-
literal|1
block|,
comment|/* IFM_IEEE80211_MCS */
block|}
decl_stmt|;
return|return
name|IFM_SUBTYPE
argument_list|(
name|mword
argument_list|)
operator|<
name|nitems
argument_list|(
name|ieeerates
argument_list|)
condition|?
name|ieeerates
index|[
name|IFM_SUBTYPE
argument_list|(
name|mword
argument_list|)
index|]
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * The following hash function is adapted from "Hash Functions" by Bob Jenkins  * ("Algorithm Alley", Dr. Dobbs Journal, September 1997).  */
end_comment

begin_define
define|#
directive|define
name|mix
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|do {									\ 	a -= b; a -= c; a ^= (c>> 13);					\ 	b -= c; b -= a; b ^= (a<< 8);					\ 	c -= a; c -= b; c ^= (b>> 13);					\ 	a -= b; a -= c; a ^= (c>> 12);					\ 	b -= c; b -= a; b ^= (a<< 16);					\ 	c -= a; c -= b; c ^= (b>> 5);					\ 	a -= b; a -= c; a ^= (c>> 3);					\ 	b -= c; b -= a; b ^= (a<< 10);					\ 	c -= a; c -= b; c ^= (b>> 15);					\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_function
name|uint32_t
name|ieee80211_mac_hash
parameter_list|(
specifier|const
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|uint8_t
name|addr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|uint32_t
name|a
init|=
literal|0x9e3779b9
decl_stmt|,
name|b
init|=
literal|0x9e3779b9
decl_stmt|,
name|c
init|=
name|ic
operator|->
name|ic_hash_key
decl_stmt|;
name|b
operator|+=
name|addr
index|[
literal|5
index|]
operator|<<
literal|8
expr_stmt|;
name|b
operator|+=
name|addr
index|[
literal|4
index|]
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|3
index|]
operator|<<
literal|24
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|2
index|]
operator|<<
literal|16
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|1
index|]
operator|<<
literal|8
expr_stmt|;
name|a
operator|+=
name|addr
index|[
literal|0
index|]
expr_stmt|;
name|mix
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
name|c
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|mix
end_undef

begin_function
name|char
name|ieee80211_channel_type_char
parameter_list|(
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_ST
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'S'
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108A
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'T'
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_108G
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'G'
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'n'
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_A
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'a'
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'g'
return|;
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|'b'
return|;
return|return
literal|'f'
return|;
block|}
end_function

end_unit

