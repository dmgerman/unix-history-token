begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_phy.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_define
define|#
directive|define
name|ETHER_HEADER_COPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|memcpy(dst, src, sizeof(struct ether_header))
end_define

begin_function
name|void
name|ieee80211_superg_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_superg_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_superg_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_FF
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_FF
expr_stmt|;
comment|/* NB: we only implement sta mode */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TURBOP
operator|)
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_TURBOP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_superg_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|ATH_OUI_BYTES
value|0x00, 0x03, 0x7f
end_define

begin_comment
comment|/*  * Add a WME information element to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_ath
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|uint8_t
name|caps
parameter_list|,
name|uint16_t
name|defkeyix
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_ath_ie
name|info
init|=
block|{
operator|.
name|ath_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|ath_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
operator|-
literal|2
block|,
operator|.
name|ath_oui
operator|=
block|{
name|ATH_OUI_BYTES
block|}
block|,
operator|.
name|ath_oui_type
operator|=
name|ATH_OUI_TYPE
block|,
operator|.
name|ath_oui_subtype
operator|=
name|ATH_OUI_SUBTYPE
block|,
operator|.
name|ath_version
operator|=
name|ATH_OUI_VERSION
block|, 	}
decl_stmt|;
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
init|=
operator|(
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|ath
operator|->
name|ath_capability
operator|=
name|caps
expr_stmt|;
name|ath
operator|->
name|ath_defkeyix
index|[
literal|0
index|]
operator|=
operator|(
name|defkeyix
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ath
operator|->
name|ath_defkeyix
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|defkeyix
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ATH_OUI_BYTES
end_undef

begin_function
name|void
name|ieee80211_parse_ath
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|ie
decl_stmt|;
name|ni
operator|->
name|ni_ath_flags
operator|=
name|ath
operator|->
name|ath_capability
expr_stmt|;
name|ni
operator|->
name|ni_ath_defkeyix
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|ath
operator|->
name|ath_defkeyix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieee80211_parse_athparams
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
decl_stmt|;
name|u_int
name|len
init|=
name|frm
index|[
literal|1
index|]
decl_stmt|;
name|int
name|capschanged
decl_stmt|;
name|uint16_t
name|defkeyix
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
operator|-
literal|2
condition|)
block|{
name|IEEE80211_DISCARD_IE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ELEMID
operator||
name|IEEE80211_MSG_SUPERG
argument_list|,
name|wh
argument_list|,
literal|"Atheros"
argument_list|,
literal|"too short, len %u"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ath
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|frm
expr_stmt|;
name|capschanged
operator|=
operator|(
name|ni
operator|->
name|ni_ath_flags
operator|!=
name|ath
operator|->
name|ath_capability
operator|)
expr_stmt|;
name|defkeyix
operator|=
name|LE_READ_2
argument_list|(
name|ath
operator|->
name|ath_defkeyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|capschanged
operator|||
name|defkeyix
operator|!=
name|ni
operator|->
name|ni_ath_defkeyix
condition|)
block|{
name|ni
operator|->
name|ni_ath_flags
operator|=
name|ath
operator|->
name|ath_capability
expr_stmt|;
name|ni
operator|->
name|ni_ath_defkeyix
operator|=
name|defkeyix
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
name|ni
argument_list|,
literal|"ath ie change: new caps 0x%x defkeyix 0x%x"
argument_list|,
name|ni
operator|->
name|ni_ath_flags
argument_list|,
name|ni
operator|->
name|ni_ath_defkeyix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|ATHEROS_CAP_TURBO_PRIME
argument_list|)
condition|)
block|{
name|uint16_t
name|curflags
decl_stmt|,
name|newflags
decl_stmt|;
comment|/* 		 * Check for turbo mode switch.  Calculate flags 		 * for the new mode and effect the switch. 		 */
name|newflags
operator|=
name|curflags
operator|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_bsschan
operator|->
name|ic_flags
expr_stmt|;
comment|/* NB: BOOST is not in ic_flags, so get it from the ie */
if|if
condition|(
name|ath
operator|->
name|ath_capability
operator|&
name|ATHEROS_CAP_BOOST
condition|)
name|newflags
operator||=
name|IEEE80211_CHAN_TURBO
expr_stmt|;
else|else
name|newflags
operator|&=
operator|~
name|IEEE80211_CHAN_TURBO
expr_stmt|;
if|if
condition|(
name|newflags
operator|!=
name|curflags
condition|)
name|ieee80211_dturbo_switch
argument_list|(
name|vap
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
block|}
return|return
name|capschanged
return|;
block|}
end_function

begin_comment
comment|/*  * Decap the encapsulated frame pair and dispatch the first  * for delivery.  The second frame is returned for delivery  * via the normal path.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_ff_decap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|FF_LLC_SIZE
value|(sizeof(struct ether_header) + sizeof(struct llc))
define|#
directive|define
name|MS
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|(((x)& f)>> f##_S)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|uint32_t
name|ath
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|framelen
decl_stmt|;
comment|/* NB: we assume caller does this check for us */
name|KASSERT
argument_list|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_FF
argument_list|)
argument_list|,
operator|(
literal|"ff not negotiated"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for fast-frame tunnel encapsulation. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|3
operator|*
name|FF_LLC_SIZE
condition|)
return|return
name|m
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|FF_LLC_SIZE
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|FF_LLC_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"m_pullup(llc) failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|llc
operator|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ATH_FF_ETH_TYPE
argument_list|)
condition|)
return|return
name|m
return|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|FF_LLC_SIZE
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ath
argument_list|)
expr_stmt|;
if|if
condition|(
name|MS
argument_list|(
name|ath
argument_list|,
name|ATH_FF_PROTO
argument_list|)
operator|!=
name|ATH_FF_PROTO_L2TUNNEL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"unsupport tunnel protocol, header 0x%x"
argument_list|,
name|ath
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_badhdr
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* NB: skip header and alignment padding */
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|2
argument_list|,
literal|4
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_decap
operator|++
expr_stmt|;
comment|/* 	 * Decap the first frame, bust it apart from the 	 * second and deliver; then decap the second frame 	 * and return it to the caller for normal delivery. 	 */
name|m
operator|=
name|ieee80211_decap1
argument_list|(
name|m
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"first decap failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|framelen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"unable to split encapsulated frames"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_split
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* NB: must reclaim */
return|return
name|NULL
return|;
block|}
comment|/* XXX not right for WDS */
name|vap
operator|->
name|iv_deliver_data
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 1st of pair */
comment|/* 	 * Decap second frame. 	 */
name|m_adj
argument_list|(
name|n
argument_list|,
name|roundup2
argument_list|(
name|framelen
argument_list|,
literal|4
argument_list|)
operator|-
name|framelen
argument_list|)
expr_stmt|;
comment|/* padding */
name|n
operator|=
name|ieee80211_decap1
argument_list|(
name|n
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"second decap failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_tooshort
operator|++
expr_stmt|;
block|}
comment|/* XXX verify framelen against mbuf contents */
return|return
name|n
return|;
comment|/* 2nd delivered by caller */
undef|#
directive|undef
name|MS
undef|#
directive|undef
name|FF_LLC_SIZE
block|}
end_function

begin_comment
comment|/*  * Do Ethernet-LLC encapsulation for each payload in a fast frame  * tunnel encapsulation.  The frame is assumed to have an Ethernet  * header at the front that must be stripped before prepending the  * LLC followed by the Ethernet header passed in (with an Ethernet  * type that specifies the payload size).  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|ff_encap1
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
specifier|const
name|struct
name|ether_header
modifier|*
name|eh
parameter_list|)
block|{
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|uint16_t
name|payload
decl_stmt|;
comment|/* XXX optimize by combining m_adj+M_PREPEND */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|)
expr_stmt|;
name|llc
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|eh
operator|->
name|ether_type
expr_stmt|;
name|payload
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
comment|/* NB: w/o Ethernet header */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for ether_header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ETHER_HEADER_COPY
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|eh
argument_list|)
expr_stmt|;
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_type
operator|=
name|htons
argument_list|(
name|payload
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Fast frame encapsulation.  There must be two packets  * chained with m_nextpkt.  We do header adjustment for  * each, add the tunnel encapsulation, and then concatenate  * the mbuf chains to form a single frame for transmission.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_ff_encap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m1
parameter_list|,
name|int
name|hdrspace
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|struct
name|ether_header
name|eh1
decl_stmt|,
name|eh2
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|m2
operator|=
name|m1
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: only one frame\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m1
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Include fast frame headers in adjusting header 	 * layout; this allocates space according to what 	 * ff_encap will do. 	 */
name|m1
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|vap
argument_list|,
name|hdrspace
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|key
argument_list|,
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Copy second frame's Ethernet header out of line 	 * and adjust for encapsulation headers.  Note that 	 * we make room for padding in case there isn't room 	 * at the end of first frame. 	 */
name|KASSERT
argument_list|(
name|m2
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh2
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|ETHER_HEADER_COPY
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|vap
argument_list|,
name|ATH_FF_MAX_HDR_PAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|m2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Now do tunnel encapsulation.  First, each 	 * frame gets a standard encapsulation. 	 */
name|m1
operator|=
name|ff_encap1
argument_list|(
name|vap
argument_list|,
name|m1
argument_list|,
operator|&
name|eh1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|m2
operator|=
name|ff_encap1
argument_list|(
name|vap
argument_list|,
name|m2
argument_list|,
operator|&
name|eh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Pad leading frame to a 4-byte boundary.  If there 	 * is space at the end of the first frame, put it 	 * there; otherwise prepend to the front of the second 	 * frame.  We know doing the second will always work 	 * because we reserve space above.  We prefer appending 	 * as this typically has better DMA alignment properties. 	 */
for|for
control|(
name|m
operator|=
name|m1
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|pad
operator|=
name|roundup2
argument_list|(
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|4
argument_list|)
operator|-
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pad
condition|)
block|{
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|pad
condition|)
block|{
comment|/* prepend to second */
name|m2
operator|->
name|m_data
operator|-=
name|pad
expr_stmt|;
name|m2
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
block|}
else|else
block|{
comment|/* append to first */
name|m
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
block|}
block|}
comment|/* 	 * Now, stick 'em together and prepend the tunnel headers; 	 * first the Atheros tunnel header (all zero for now) and 	 * then a special fast frame LLC. 	 * 	 * XXX optimize by prepending together 	 */
name|m
operator|->
name|m_next
operator|=
name|m2
expr_stmt|;
comment|/* NB: last mbuf from above */
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m1
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for tunnel header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_DONTWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for llc header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|llc
operator|=
name|mtod
argument_list|(
name|m1
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_1
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_2
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|htons
argument_list|(
name|ATH_FF_ETH_TYPE
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_encap
operator|++
expr_stmt|;
return|return
name|m1
return|;
name|bad
label|:
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Switch between turbo and non-turbo operating modes.  * Use the specified channel flags to locate the new  * channel, update 802.11 state, and then call back into  * the driver to effect the change.  */
end_comment

begin_function
name|void
name|ieee80211_dturbo_switch
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
comment|/* XXX should not happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no channel with freq %u flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
return|return;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: %s -> %s (freq %u flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_phymode_name
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
index|]
argument_list|,
name|ieee80211_phymode_name
index|[
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
index|]
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bsschan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_prevchan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* NB: do not need to reset ERP state 'cuz we're in sta mode */
block|}
end_function

begin_comment
comment|/*  * Return the current ``state'' of an Atheros capbility.  * If associated in station mode report the negotiated  * setting. Otherwise report the current setting.  */
end_comment

begin_function
specifier|static
name|int
name|getathcap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
return|return
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|,
name|cap
argument_list|)
operator|!=
literal|0
return|;
else|else
return|return
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|cap
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|superg_ioctl_get80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_FF
case|:
name|ireq
operator|->
name|i_val
operator|=
name|getathcap
argument_list|(
name|vap
argument_list|,
name|IEEE80211_F_FF
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_TURBOP
case|:
name|ireq
operator|->
name|i_val
operator|=
name|getathcap
argument_list|(
name|vap
argument_list|,
name|IEEE80211_F_TURBOP
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_GET
argument_list|(
name|superg
argument_list|,
name|superg_ioctl_get80211
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|superg_ioctl_set80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_FF
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_FF
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_FF
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags
operator|&=
operator|~
name|IEEE80211_F_FF
expr_stmt|;
return|return
name|ERESTART
return|;
case|case
name|IEEE80211_IOC_TURBOP
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TURBOP
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_TURBOP
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags
operator|&=
operator|~
name|IEEE80211_F_TURBOP
expr_stmt|;
return|return
name|ENETRESET
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_SET
argument_list|(
name|superg
argument_list|,
name|superg_ioctl_set80211
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

