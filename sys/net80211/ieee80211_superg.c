begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_SUPERG
end_ifdef

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_llc.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_phy.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_superg.h>
end_include

begin_comment
comment|/*  * Atheros fast-frame encapsulation format.  * FF max payload:  * 802.2 + FFHDR + HPAD + 802.3 + 802.2 + 1500 + SPAD + 802.3 + 802.2 + 1500:  *   8   +   4   +  4   +   14  +   8   + 1500 +  6   +   14  +   8   + 1500  * = 3066  */
end_comment

begin_comment
comment|/* fast frame header is 32-bits */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_PROTO
value|0x0000003f
end_define

begin_comment
comment|/* protocol */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_PROTO_S
value|0
end_define

begin_define
define|#
directive|define
name|ATH_FF_FTYPE
value|0x000000c0
end_define

begin_comment
comment|/* frame type */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_FTYPE_S
value|6
end_define

begin_define
define|#
directive|define
name|ATH_FF_HLEN32
value|0x00000300
end_define

begin_comment
comment|/* optional hdr length */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_HLEN32_S
value|8
end_define

begin_define
define|#
directive|define
name|ATH_FF_SEQNUM
value|0x001ffc00
end_define

begin_comment
comment|/* sequence number */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_SEQNUM_S
value|10
end_define

begin_define
define|#
directive|define
name|ATH_FF_OFFSET
value|0xffe00000
end_define

begin_comment
comment|/* offset to 2nd payload */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_OFFSET_S
value|21
end_define

begin_define
define|#
directive|define
name|ATH_FF_MAX_HDR_PAD
value|4
end_define

begin_define
define|#
directive|define
name|ATH_FF_MAX_SEP_PAD
value|6
end_define

begin_define
define|#
directive|define
name|ATH_FF_MAX_HDR
value|30
end_define

begin_define
define|#
directive|define
name|ATH_FF_PROTO_L2TUNNEL
value|0
end_define

begin_comment
comment|/* L2 tunnel protocol */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_ETH_TYPE
value|0x88bd
end_define

begin_comment
comment|/* Ether type for encapsulated frames */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_SNAP_ORGCODE_0
value|0x00
end_define

begin_define
define|#
directive|define
name|ATH_FF_SNAP_ORGCODE_1
value|0x03
end_define

begin_define
define|#
directive|define
name|ATH_FF_SNAP_ORGCODE_2
value|0x7f
end_define

begin_define
define|#
directive|define
name|ATH_FF_TXQMIN
value|2
end_define

begin_comment
comment|/* min txq depth for staging */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_TXQMAX
value|50
end_define

begin_comment
comment|/* maximum # of queued frames allowed */
end_comment

begin_define
define|#
directive|define
name|ATH_FF_STAGEMAX
value|5
end_define

begin_comment
comment|/* max waiting period for staged frame*/
end_comment

begin_define
define|#
directive|define
name|ETHER_HEADER_COPY
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|)
define|\
value|memcpy(dst, src, sizeof(struct ether_header))
end_define

begin_decl_stmt
specifier|static
name|int
name|ieee80211_ffppsmin
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pps threshold for ff aggregation */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|ffppsmin
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_ffppsmin
argument_list|,
literal|0
argument_list|,
literal|"min packet rate before fast-frame staging"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_ffagemax
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max time frames held on stage q */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|ffagemax
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_ffagemax
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"max hold time for fast-frame staging (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_superg_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_superg
modifier|*
name|sg
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_FF
condition|)
block|{
name|sg
operator|=
operator|(
expr|struct
name|ieee80211_superg
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_superg
argument_list|)
argument_list|,
name|M_80211_VAP
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|sg
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s: cannot allocate SuperG state block\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|ic
operator|->
name|ic_superg
operator|=
name|sg
expr_stmt|;
block|}
name|ieee80211_ffagemax
operator|=
name|msecs_to_ticks
argument_list|(
literal|150
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_superg_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_superg
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ic
operator|->
name|ic_superg
argument_list|,
name|M_80211_VAP
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_superg
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_superg_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_superg
operator|==
name|NULL
condition|)
comment|/* NB: can't do fast-frames w/o state */
name|vap
operator|->
name|iv_caps
operator|&=
operator|~
name|IEEE80211_C_FF
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_FF
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_FF
expr_stmt|;
comment|/* NB: we only implement sta mode */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TURBOP
operator|)
condition|)
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_TURBOP
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_superg_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{ }
end_function

begin_define
define|#
directive|define
name|ATH_OUI_BYTES
value|0x00, 0x03, 0x7f
end_define

begin_comment
comment|/*  * Add a WME information element to a frame.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_ath
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|uint8_t
name|caps
parameter_list|,
name|ieee80211_keyix
name|defkeyix
parameter_list|)
block|{
specifier|static
specifier|const
name|struct
name|ieee80211_ath_ie
name|info
init|=
block|{
operator|.
name|ath_id
operator|=
name|IEEE80211_ELEMID_VENDOR
block|,
operator|.
name|ath_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
operator|-
literal|2
block|,
operator|.
name|ath_oui
operator|=
block|{
name|ATH_OUI_BYTES
block|}
block|,
operator|.
name|ath_oui_type
operator|=
name|ATH_OUI_TYPE
block|,
operator|.
name|ath_oui_subtype
operator|=
name|ATH_OUI_SUBTYPE
block|,
operator|.
name|ath_version
operator|=
name|ATH_OUI_VERSION
block|, 	}
decl_stmt|;
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
init|=
operator|(
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|frm
decl_stmt|;
name|memcpy
argument_list|(
name|frm
argument_list|,
operator|&
name|info
argument_list|,
sizeof|sizeof
argument_list|(
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|ath
operator|->
name|ath_capability
operator|=
name|caps
expr_stmt|;
if|if
condition|(
name|defkeyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
block|{
name|ath
operator|->
name|ath_defkeyix
index|[
literal|0
index|]
operator|=
operator|(
name|defkeyix
operator|&
literal|0xff
operator|)
expr_stmt|;
name|ath
operator|->
name|ath_defkeyix
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|defkeyix
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ath
operator|->
name|ath_defkeyix
index|[
literal|0
index|]
operator|=
literal|0xff
expr_stmt|;
name|ath
operator|->
name|ath_defkeyix
index|[
literal|1
index|]
operator|=
literal|0x7f
expr_stmt|;
block|}
return|return
name|frm
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|ATH_OUI_BYTES
end_undef

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_athcaps
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_node
modifier|*
name|bss
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|bss
operator|->
name|ni_vap
decl_stmt|;
return|return
name|ieee80211_add_ath
argument_list|(
name|frm
argument_list|,
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_ATHEROS
argument_list|,
operator|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_WPA
operator|)
operator|==
literal|0
operator|&&
name|bss
operator|->
name|ni_authmode
operator|!=
name|IEEE80211_AUTH_8021X
operator|)
condition|?
name|vap
operator|->
name|iv_def_txkey
else|:
name|IEEE80211_KEYIX_NONE
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_parse_ath
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|ie
decl_stmt|;
name|ni
operator|->
name|ni_ath_flags
operator|=
name|ath
operator|->
name|ath_capability
expr_stmt|;
name|ni
operator|->
name|ni_ath_defkeyix
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|ath
operator|->
name|ath_defkeyix
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieee80211_parse_athparams
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ath_ie
modifier|*
name|ath
decl_stmt|;
name|u_int
name|len
init|=
name|frm
index|[
literal|1
index|]
decl_stmt|;
name|int
name|capschanged
decl_stmt|;
name|uint16_t
name|defkeyix
decl_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ath_ie
argument_list|)
operator|-
literal|2
condition|)
block|{
name|IEEE80211_DISCARD_IE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ELEMID
operator||
name|IEEE80211_MSG_SUPERG
argument_list|,
name|wh
argument_list|,
literal|"Atheros"
argument_list|,
literal|"too short, len %u"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ath
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ath_ie
operator|*
operator|)
name|frm
expr_stmt|;
name|capschanged
operator|=
operator|(
name|ni
operator|->
name|ni_ath_flags
operator|!=
name|ath
operator|->
name|ath_capability
operator|)
expr_stmt|;
name|defkeyix
operator|=
name|LE_READ_2
argument_list|(
name|ath
operator|->
name|ath_defkeyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|capschanged
operator|||
name|defkeyix
operator|!=
name|ni
operator|->
name|ni_ath_defkeyix
condition|)
block|{
name|ni
operator|->
name|ni_ath_flags
operator|=
name|ath
operator|->
name|ath_capability
expr_stmt|;
name|ni
operator|->
name|ni_ath_defkeyix
operator|=
name|defkeyix
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
name|ni
argument_list|,
literal|"ath ie change: new caps 0x%x defkeyix 0x%x"
argument_list|,
name|ni
operator|->
name|ni_ath_flags
argument_list|,
name|ni
operator|->
name|ni_ath_defkeyix
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|ATHEROS_CAP_TURBO_PRIME
argument_list|)
condition|)
block|{
name|uint16_t
name|curflags
decl_stmt|,
name|newflags
decl_stmt|;
comment|/* 		 * Check for turbo mode switch.  Calculate flags 		 * for the new mode and effect the switch. 		 */
name|newflags
operator|=
name|curflags
operator|=
name|vap
operator|->
name|iv_ic
operator|->
name|ic_bsschan
operator|->
name|ic_flags
expr_stmt|;
comment|/* NB: BOOST is not in ic_flags, so get it from the ie */
if|if
condition|(
name|ath
operator|->
name|ath_capability
operator|&
name|ATHEROS_CAP_BOOST
condition|)
name|newflags
operator||=
name|IEEE80211_CHAN_TURBO
expr_stmt|;
else|else
name|newflags
operator|&=
operator|~
name|IEEE80211_CHAN_TURBO
expr_stmt|;
if|if
condition|(
name|newflags
operator|!=
name|curflags
condition|)
name|ieee80211_dturbo_switch
argument_list|(
name|vap
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
block|}
return|return
name|capschanged
return|;
block|}
end_function

begin_comment
comment|/*  * Decap the encapsulated frame pair and dispatch the first  * for delivery.  The second frame is returned for delivery  * via the normal path.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_ff_decap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|FF_LLC_SIZE
value|(sizeof(struct ether_header) + sizeof(struct llc))
define|#
directive|define
name|MS
parameter_list|(
name|x
parameter_list|,
name|f
parameter_list|)
value|(((x)& f)>> f##_S)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|uint32_t
name|ath
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|int
name|framelen
decl_stmt|;
comment|/* NB: we assume caller does this check for us */
name|KASSERT
argument_list|(
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|IEEE80211_NODE_FF
argument_list|)
argument_list|,
operator|(
literal|"ff not negotiated"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for fast-frame tunnel encapsulation. 	 */
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|<
literal|3
operator|*
name|FF_LLC_SIZE
condition|)
return|return
name|m
return|;
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|FF_LLC_SIZE
operator|&&
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|FF_LLC_SIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"m_pullup(llc) failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|llc
operator|=
operator|(
expr|struct
name|llc
operator|*
operator|)
operator|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|!=
name|htons
argument_list|(
name|ATH_FF_ETH_TYPE
argument_list|)
condition|)
return|return
name|m
return|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|FF_LLC_SIZE
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|ath
argument_list|)
expr_stmt|;
if|if
condition|(
name|MS
argument_list|(
name|ath
argument_list|,
name|ATH_FF_PROTO
argument_list|)
operator|!=
name|ATH_FF_PROTO_L2TUNNEL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"unsupport tunnel protocol, header 0x%x"
argument_list|,
name|ath
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_badhdr
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* NB: skip header and alignment padding */
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup
argument_list|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
literal|2
argument_list|,
literal|4
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_decap
operator|++
expr_stmt|;
comment|/* 	 * Decap the first frame, bust it apart from the 	 * second and deliver; then decap the second frame 	 * and return it to the caller for normal delivery. 	 */
name|m
operator|=
name|ieee80211_decap1
argument_list|(
name|m
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"first decap failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|n
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|framelen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"unable to split encapsulated frames"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_split
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* NB: must reclaim */
return|return
name|NULL
return|;
block|}
comment|/* XXX not right for WDS */
name|vap
operator|->
name|iv_deliver_data
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 1st of pair */
comment|/* 	 * Decap second frame. 	 */
name|m_adj
argument_list|(
name|n
argument_list|,
name|roundup2
argument_list|(
name|framelen
argument_list|,
literal|4
argument_list|)
operator|-
name|framelen
argument_list|)
expr_stmt|;
comment|/* padding */
name|n
operator|=
name|ieee80211_decap1
argument_list|(
name|n
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"fast-frame"
argument_list|,
literal|"%s"
argument_list|,
literal|"second decap failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_tooshort
operator|++
expr_stmt|;
block|}
comment|/* XXX verify framelen against mbuf contents */
return|return
name|n
return|;
comment|/* 2nd delivered by caller */
undef|#
directive|undef
name|MS
undef|#
directive|undef
name|FF_LLC_SIZE
block|}
end_function

begin_comment
comment|/*  * Fast frame encapsulation.  There must be two packets  * chained with m_nextpkt.  We do header adjustment for  * each, add the tunnel encapsulation, and then concatenate  * the mbuf chains to form a single frame for transmission.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_ff_encap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m1
parameter_list|,
name|int
name|hdrspace
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m2
decl_stmt|;
name|struct
name|ether_header
name|eh1
decl_stmt|,
name|eh2
decl_stmt|;
name|struct
name|llc
modifier|*
name|llc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|pad
decl_stmt|;
name|m2
operator|=
name|m1
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: only one frame\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|m1
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Include fast frame headers in adjusting header layout. 	 */
name|KASSERT
argument_list|(
name|m1
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh1
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|ETHER_HEADER_COPY
argument_list|(
operator|&
name|eh1
argument_list|,
name|mtod
argument_list|(
name|m1
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m1
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|vap
argument_list|,
name|hdrspace
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|key
argument_list|,
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Copy second frame's Ethernet header out of line 	 * and adjust for encapsulation headers.  Note that 	 * we make room for padding in case there isn't room 	 * at the end of first frame. 	 */
name|KASSERT
argument_list|(
name|m2
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|eh2
argument_list|)
argument_list|,
operator|(
literal|"no ethernet header!"
operator|)
argument_list|)
expr_stmt|;
name|ETHER_HEADER_COPY
argument_list|(
operator|&
name|eh2
argument_list|,
name|mtod
argument_list|(
name|m2
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|m2
operator|=
name|ieee80211_mbuf_adjust
argument_list|(
name|vap
argument_list|,
name|ATH_FF_MAX_HDR_PAD
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|m2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
block|{
comment|/* NB: ieee80211_mbuf_adjust handles msgs+statistics */
goto|goto
name|bad
goto|;
block|}
comment|/* 	 * Now do tunnel encapsulation.  First, each 	 * frame gets a standard encapsulation. 	 */
name|m1
operator|=
name|ieee80211_ff_encap1
argument_list|(
name|vap
argument_list|,
name|m1
argument_list|,
operator|&
name|eh1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
name|m2
operator|=
name|ieee80211_ff_encap1
argument_list|(
name|vap
argument_list|,
name|m2
argument_list|,
operator|&
name|eh2
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|==
name|NULL
condition|)
goto|goto
name|bad
goto|;
comment|/* 	 * Pad leading frame to a 4-byte boundary.  If there 	 * is space at the end of the first frame, put it 	 * there; otherwise prepend to the front of the second 	 * frame.  We know doing the second will always work 	 * because we reserve space above.  We prefer appending 	 * as this typically has better DMA alignment properties. 	 */
for|for
control|(
name|m
operator|=
name|m1
init|;
name|m
operator|->
name|m_next
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_next
control|)
empty_stmt|;
name|pad
operator|=
name|roundup2
argument_list|(
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
argument_list|,
literal|4
argument_list|)
operator|-
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|pad
condition|)
block|{
if|if
condition|(
name|M_TRAILINGSPACE
argument_list|(
name|m
argument_list|)
operator|<
name|pad
condition|)
block|{
comment|/* prepend to second */
name|m2
operator|->
name|m_data
operator|-=
name|pad
expr_stmt|;
name|m2
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
block|}
else|else
block|{
comment|/* append to first */
name|m
operator|->
name|m_len
operator|+=
name|pad
expr_stmt|;
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|pad
expr_stmt|;
block|}
block|}
comment|/* 	 * Now, stick 'em together and prepend the tunnel headers; 	 * first the Atheros tunnel header (all zero for now) and 	 * then a special fast frame LLC. 	 * 	 * XXX optimize by prepending together 	 */
name|m
operator|->
name|m_next
operator|=
name|m2
expr_stmt|;
comment|/* NB: last mbuf from above */
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+=
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m1
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for tunnel header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|memset
argument_list|(
name|mtod
argument_list|(
name|m1
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|M_PREPEND
argument_list|(
name|m1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|llc
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m1
operator|==
name|NULL
condition|)
block|{
comment|/* XXX cannot happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no space for llc header\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|llc
operator|=
name|mtod
argument_list|(
name|m1
argument_list|,
expr|struct
name|llc
operator|*
argument_list|)
expr_stmt|;
name|llc
operator|->
name|llc_dsap
operator|=
name|llc
operator|->
name|llc_ssap
operator|=
name|LLC_SNAP_LSAP
expr_stmt|;
name|llc
operator|->
name|llc_control
operator|=
name|LLC_UI
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|0
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_0
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|1
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_1
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|org_code
index|[
literal|2
index|]
operator|=
name|ATH_FF_SNAP_ORGCODE_2
expr_stmt|;
name|llc
operator|->
name|llc_snap
operator|.
name|ether_type
operator|=
name|htons
argument_list|(
name|ATH_FF_ETH_TYPE
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_encap
operator|++
expr_stmt|;
return|return
name|m1
return|;
name|bad
label|:
if|if
condition|(
name|m1
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m2
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m2
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ff_transmit
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IEEE80211_TX_LOCK_ASSERT
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
comment|/* encap and xmit */
name|m
operator|=
name|ieee80211_encap
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|error
operator|=
name|ieee80211_parent_xmitpkt
argument_list|(
name|ic
argument_list|,
name|m
argument_list|)
expr_stmt|;
empty_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* NB: IFQ_HANDOFF reclaims mbuf */
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|if_inc_counter
argument_list|(
name|ifp
argument_list|,
name|IFCOUNTER_OPACKETS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush frames to device; note we re-use the linked list  * the frames were stored on and use the sentinel (unchanged)  * which may be non-NULL.  */
end_comment

begin_function
specifier|static
name|void
name|ff_flush
parameter_list|(
name|struct
name|mbuf
modifier|*
name|head
parameter_list|,
name|struct
name|mbuf
modifier|*
name|last
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
for|for
control|(
name|m
operator|=
name|head
init|;
name|m
operator|!=
name|last
condition|;
name|m
operator|=
name|next
control|)
block|{
name|next
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|vap
operator|=
name|ni
operator|->
name|ni_vap
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
name|ni
argument_list|,
literal|"%s: flush frame, age %u"
argument_list|,
name|__func__
argument_list|,
name|M_AGE_GET
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ff_flush
operator|++
expr_stmt|;
name|ff_transmit
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Age frames on the staging queue.  *  * This is called without the comlock held, but it does all its work  * behind the comlock.  Because of this, it's possible that the  * staging queue will be serviced between the function which called  * it and now; thus simply checking that the queue has work in it  * may fail.  *  * See PR kern/174283 for more details.  */
end_comment

begin_function
name|void
name|ieee80211_ff_age
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_stageq
modifier|*
name|sq
parameter_list|,
name|int
name|quanta
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|#
directive|if
literal|0
block|KASSERT(sq->head != NULL, ("stageq empty"));
endif|#
directive|endif
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|head
operator|=
name|sq
operator|->
name|head
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|sq
operator|->
name|head
operator|)
operator|!=
name|NULL
operator|&&
name|M_AGE_GET
argument_list|(
name|m
argument_list|)
operator|<
name|quanta
condition|)
block|{
name|int
name|tid
init|=
name|WME_AC_TO_TID
argument_list|(
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
argument_list|)
decl_stmt|;
comment|/* clear tap ref to frame */
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|KASSERT
argument_list|(
name|tap
operator|->
name|txa_private
operator|==
name|m
argument_list|,
operator|(
literal|"staging queue empty"
operator|)
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|sq
operator|->
name|depth
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|sq
operator|->
name|tail
operator|=
name|NULL
expr_stmt|;
else|else
name|M_AGE_SUB
argument_list|(
name|m
argument_list|,
name|quanta
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ff_flush
argument_list|(
name|head
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stageq_add
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_stageq
modifier|*
name|sq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|int
name|age
init|=
name|ieee80211_ffagemax
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|tail
operator|!=
name|NULL
condition|)
block|{
name|sq
operator|->
name|tail
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|age
operator|-=
name|M_AGE_GET
argument_list|(
name|sq
operator|->
name|head
argument_list|)
expr_stmt|;
block|}
else|else
name|sq
operator|->
name|head
operator|=
name|m
expr_stmt|;
name|KASSERT
argument_list|(
name|age
operator|>=
literal|0
argument_list|,
operator|(
literal|"age %d"
operator|,
name|age
operator|)
argument_list|)
expr_stmt|;
name|M_AGE_SET
argument_list|(
name|m
argument_list|,
name|age
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|sq
operator|->
name|tail
operator|=
name|m
expr_stmt|;
name|sq
operator|->
name|depth
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stageq_remove
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_stageq
modifier|*
name|sq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|mstaged
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|mprev
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|mprev
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|m
operator|=
name|sq
operator|->
name|head
init|;
name|m
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
block|{
if|if
condition|(
name|m
operator|==
name|mstaged
condition|)
block|{
if|if
condition|(
name|mprev
operator|==
name|NULL
condition|)
name|sq
operator|->
name|head
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|mprev
operator|->
name|m_nextpkt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|sq
operator|->
name|tail
operator|==
name|m
condition|)
name|sq
operator|->
name|tail
operator|=
name|mprev
expr_stmt|;
name|sq
operator|->
name|depth
operator|--
expr_stmt|;
return|return;
block|}
name|mprev
operator|=
name|m
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%s: packet not found\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint32_t
name|ff_approx_txtime
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m1
parameter_list|,
specifier|const
name|struct
name|mbuf
modifier|*
name|m2
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|uint32_t
name|framelen
decl_stmt|;
comment|/* 	 * Approximate the frame length to be transmitted. A swag to add 	 * the following maximal values to the skb payload: 	 *   - 32: 802.11 encap + CRC 	 *   - 24: encryption overhead (if wep bit) 	 *   - 4 + 6: fast-frame header and padding 	 *   - 16: 2 LLC FF tunnel headers 	 *   - 14: 1 802.3 FF tunnel header (mbuf already accounts for 2nd) 	 */
name|framelen
operator|=
name|m1
operator|->
name|m_pkthdr
operator|.
name|len
operator|+
literal|32
operator|+
name|ATH_FF_MAX_HDR_PAD
operator|+
name|ATH_FF_MAX_SEP_PAD
operator|+
name|ATH_FF_MAX_HDR
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
name|framelen
operator|+=
literal|24
expr_stmt|;
if|if
condition|(
name|m2
operator|!=
name|NULL
condition|)
name|framelen
operator|+=
name|m2
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
return|return
name|ieee80211_compute_duration
argument_list|(
name|ic
operator|->
name|ic_rt
argument_list|,
name|framelen
argument_list|,
name|ni
operator|->
name|ni_txrate
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the supplied frame can be partnered with an existing  * or pending frame.  Return a reference to any frame that should be  * sent on return; otherwise return NULL.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_ff_check
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_superg
modifier|*
name|sg
init|=
name|ic
operator|->
name|ic_superg
decl_stmt|;
specifier|const
name|int
name|pri
init|=
name|M_WME_GETAC
argument_list|(
name|m
argument_list|)
decl_stmt|;
name|struct
name|ieee80211_stageq
modifier|*
name|sq
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|mstaged
decl_stmt|;
name|uint32_t
name|txtime
decl_stmt|,
name|limit
decl_stmt|;
name|IEEE80211_TX_UNLOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Check if the supplied frame can be aggregated. 	 * 	 * NB: we allow EAPOL frames to be aggregated with other ucast traffic. 	 *     Do 802.1x EAPOL frames proceed in the clear? Then they couldn't 	 *     be aggregated with other types of frames when encryption is on? 	 */
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|WME_AC_TO_TID
argument_list|(
name|pri
argument_list|)
index|]
expr_stmt|;
name|mstaged
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
comment|/* NB: we reuse AMPDU state */
name|ieee80211_txampdu_count_packet
argument_list|(
name|tap
argument_list|)
expr_stmt|;
comment|/* 	 * When not in station mode never aggregate a multicast 	 * frame; this insures, for example, that a combined frame 	 * does not require multiple encryption keys. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_STA
operator|&&
name|ETHER_IS_MULTICAST
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ether_header
operator|*
argument_list|)
operator|->
name|ether_dhost
argument_list|)
condition|)
block|{
comment|/* XXX flush staged frame? */
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
comment|/* 	 * If there is no frame to combine with and the pps is 	 * too low; then do not attempt to aggregate this frame. 	 */
if|if
condition|(
name|mstaged
operator|==
name|NULL
operator|&&
name|ieee80211_txampdu_getpps
argument_list|(
name|tap
argument_list|)
operator|<
name|ieee80211_ffppsmin
condition|)
block|{
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
name|sq
operator|=
operator|&
name|sg
operator|->
name|ff_stageq
index|[
name|pri
index|]
expr_stmt|;
comment|/* 	 * Check the txop limit to insure the aggregate fits. 	 */
name|limit
operator|=
name|IEEE80211_TXOP_TO_US
argument_list|(
name|ic
operator|->
name|ic_wme
operator|.
name|wme_chanParams
operator|.
name|cap_wmeParams
index|[
name|pri
index|]
operator|.
name|wmep_txopLimit
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit
operator|!=
literal|0
operator|&&
operator|(
name|txtime
operator|=
name|ff_approx_txtime
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|mstaged
argument_list|)
operator|)
operator|>
name|limit
condition|)
block|{
comment|/* 		 * Aggregate too long, return to the caller for direct 		 * transmission.  In addition, flush any pending frame 		 * before sending this one. 		 */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: txtime %u exceeds txop limit %u\n"
argument_list|,
name|__func__
argument_list|,
name|txtime
argument_list|,
name|limit
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mstaged
operator|!=
name|NULL
condition|)
name|stageq_remove
argument_list|(
name|ic
argument_list|,
name|sq
argument_list|,
name|mstaged
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|mstaged
operator|!=
name|NULL
condition|)
block|{
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
name|ni
argument_list|,
literal|"%s: flush staged frame"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* encap and xmit */
name|ff_transmit
argument_list|(
name|ni
argument_list|,
name|mstaged
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
comment|/* NB: original frame */
block|}
comment|/* 	 * An aggregation candidate.  If there's a frame to partner 	 * with then combine and return for processing.  Otherwise 	 * save this frame and wait for a partner to show up (or 	 * the frame to be flushed).  Note that staged frames also 	 * hold their node reference. 	 */
if|if
condition|(
name|mstaged
operator|!=
name|NULL
condition|)
block|{
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
name|stageq_remove
argument_list|(
name|ic
argument_list|,
name|sq
argument_list|,
name|mstaged
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
name|ni
argument_list|,
literal|"%s: aggregate fast-frame"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 		 * Release the node reference; we only need 		 * the one already in mstaged. 		 */
name|KASSERT
argument_list|(
name|mstaged
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|==
operator|(
name|void
operator|*
operator|)
name|ni
argument_list|,
operator|(
literal|"rcvif %p ni %p"
operator|,
name|mstaged
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|,
name|ni
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
name|mstaged
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|mstaged
operator|->
name|m_flags
operator||=
name|M_FF
expr_stmt|;
comment|/* NB: mark for encap work */
block|}
else|else
block|{
name|KASSERT
argument_list|(
name|tap
operator|->
name|txa_private
operator|==
name|NULL
argument_list|,
operator|(
literal|"txa_private %p"
operator|,
name|tap
operator|->
name|txa_private
operator|)
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_private
operator|=
name|m
expr_stmt|;
name|stageq_add
argument_list|(
name|ic
argument_list|,
name|sq
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
name|ni
argument_list|,
literal|"%s: stage frame, %u queued"
argument_list|,
name|__func__
argument_list|,
name|sq
operator|->
name|depth
argument_list|)
expr_stmt|;
comment|/* NB: mstaged is NULL */
block|}
return|return
name|mstaged
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_ff_node_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
comment|/* 	 * Clean FF state on re-associate.  This handles the case 	 * where a station leaves w/o notifying us and then returns 	 * before node is reaped for inactivity. 	 */
name|ieee80211_ff_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_ff_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_superg
modifier|*
name|sg
init|=
name|ic
operator|->
name|ic_superg
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
name|next_m
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|head
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|WME_NUM_TID
condition|;
name|tid
operator|++
control|)
block|{
name|int
name|ac
init|=
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
decl_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|m
operator|=
name|tap
operator|->
name|txa_private
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|tap
operator|->
name|txa_private
operator|=
name|NULL
expr_stmt|;
name|stageq_remove
argument_list|(
name|ic
argument_list|,
operator|&
name|sg
operator|->
name|ff_stageq
index|[
name|ac
index|]
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|head
expr_stmt|;
name|head
operator|=
name|m
expr_stmt|;
block|}
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* 	 * Free mbufs, taking care to not dereference the mbuf after 	 * we free it (hence grabbing m_nextpkt before we free it.) 	 */
name|m
operator|=
name|head
expr_stmt|;
while|while
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|next_m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|next_m
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Switch between turbo and non-turbo operating modes.  * Use the specified channel flags to locate the new  * channel, update 802.11 state, and then call back into  * the driver to effect the change.  */
end_comment

begin_function
name|void
name|ieee80211_dturbo_switch
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|newflags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|chan
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
block|{
comment|/* XXX should not happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: no channel with freq %u flags 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ic
operator|->
name|ic_bsschan
operator|->
name|ic_freq
argument_list|,
name|newflags
argument_list|)
expr_stmt|;
return|return;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SUPERG
argument_list|,
literal|"%s: %s -> %s (freq %u flags 0x%x)\n"
argument_list|,
name|__func__
argument_list|,
name|ieee80211_phymode_name
index|[
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
index|]
argument_list|,
name|ieee80211_phymode_name
index|[
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
index|]
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bsschan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_prevchan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|ic
operator|->
name|ic_curchan
operator|=
name|chan
expr_stmt|;
name|ic
operator|->
name|ic_rt
operator|=
name|ieee80211_get_ratetable
argument_list|(
name|chan
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_set_channel
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_radiotap_chan_change
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* NB: do not need to reset ERP state 'cuz we're in sta mode */
block|}
end_function

begin_comment
comment|/*  * Return the current ``state'' of an Atheros capbility.  * If associated in station mode report the negotiated  * setting. Otherwise report the current setting.  */
end_comment

begin_function
specifier|static
name|int
name|getathcap
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|cap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
operator|&&
name|vap
operator|->
name|iv_state
operator|==
name|IEEE80211_S_RUN
condition|)
return|return
name|IEEE80211_ATH_CAP
argument_list|(
name|vap
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|,
name|cap
argument_list|)
operator|!=
literal|0
return|;
else|else
return|return
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|cap
operator|)
operator|!=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|superg_ioctl_get80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_FF
case|:
name|ireq
operator|->
name|i_val
operator|=
name|getathcap
argument_list|(
name|vap
argument_list|,
name|IEEE80211_F_FF
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_IOC_TURBOP
case|:
name|ireq
operator|->
name|i_val
operator|=
name|getathcap
argument_list|(
name|vap
argument_list|,
name|IEEE80211_F_TURBOP
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_GET
argument_list|(
name|superg
argument_list|,
name|superg_ioctl_get80211
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|int
name|superg_ioctl_set80211
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211req
modifier|*
name|ireq
parameter_list|)
block|{
switch|switch
condition|(
name|ireq
operator|->
name|i_type
condition|)
block|{
case|case
name|IEEE80211_IOC_FF
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_FF
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_FF
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags
operator|&=
operator|~
name|IEEE80211_F_FF
expr_stmt|;
return|return
name|ENETRESET
return|;
case|case
name|IEEE80211_IOC_TURBOP
case|:
if|if
condition|(
name|ireq
operator|->
name|i_val
condition|)
block|{
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TURBOP
operator|)
operator|==
literal|0
condition|)
return|return
name|EOPNOTSUPP
return|;
name|vap
operator|->
name|iv_flags
operator||=
name|IEEE80211_F_TURBOP
expr_stmt|;
block|}
else|else
name|vap
operator|->
name|iv_flags
operator|&=
operator|~
name|IEEE80211_F_TURBOP
expr_stmt|;
return|return
name|ENETRESET
return|;
default|default:
return|return
name|ENOSYS
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_expr_stmt
name|IEEE80211_IOCTL_SET
argument_list|(
name|superg
argument_list|,
name|superg_ioctl_set80211
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_SUPERG */
end_comment

end_unit

