begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 station scanning support.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/*  * Parameters for managing cache entries:  *  * o a station with STA_FAILS_MAX failures is not considered  *   when picking a candidate  * o a station that hasn't had an update in STA_PURGE_SCANS  *   (background) scans is discarded  * o after STA_FAILS_AGE seconds we clear the failure count  */
end_comment

begin_define
define|#
directive|define
name|STA_FAILS_MAX
value|2
end_define

begin_comment
comment|/* assoc failures before ignored */
end_comment

begin_define
define|#
directive|define
name|STA_FAILS_AGE
value|(2*60)
end_define

begin_comment
comment|/* time before clearing fails (secs) */
end_comment

begin_define
define|#
directive|define
name|STA_PURGE_SCANS
value|2
end_define

begin_comment
comment|/* age for purging entries (scans) */
end_comment

begin_comment
comment|/* XXX tunable */
end_comment

begin_define
define|#
directive|define
name|STA_RSSI_MIN
value|8
end_define

begin_comment
comment|/* min acceptable rssi */
end_comment

begin_define
define|#
directive|define
name|STA_RSSI_MAX
value|40
end_define

begin_comment
comment|/* max rssi for comparison */
end_comment

begin_define
define|#
directive|define
name|RSSI_LPF_LEN
value|10
end_define

begin_define
define|#
directive|define
name|RSSI_DUMMY_MARKER
value|0x127
end_define

begin_define
define|#
directive|define
name|RSSI_EP_MULTIPLIER
value|(1<<7)
end_define

begin_comment
comment|/* pow2 to optimize out * and / */
end_comment

begin_define
define|#
directive|define
name|RSSI_IN
parameter_list|(
name|x
parameter_list|)
value|((x) * RSSI_EP_MULTIPLIER)
end_define

begin_define
define|#
directive|define
name|LPF_RSSI
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|len
parameter_list|)
define|\
value|((x != RSSI_DUMMY_MARKER) ? (((x) * ((len) - 1) + (y)) / (len)) : (y))
end_define

begin_define
define|#
directive|define
name|RSSI_LPF
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|do {						\     if ((y)>= -20)							\     	x = LPF_RSSI((x), RSSI_IN((y)), RSSI_LPF_LEN);			\ } while (0)
end_define

begin_define
define|#
directive|define
name|EP_RND
parameter_list|(
name|x
parameter_list|,
name|mul
parameter_list|)
define|\
value|((((x)%(mul))>= ((mul)/2)) ? howmany(x, mul) : (x)/(mul))
end_define

begin_define
define|#
directive|define
name|RSSI_GET
parameter_list|(
name|x
parameter_list|)
value|EP_RND(x, RSSI_EP_MULTIPLIER)
end_define

begin_struct
struct|struct
name|sta_entry
block|{
name|struct
name|ieee80211_scan_entry
name|base
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|sta_entry
argument_list|)
name|se_list
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|sta_entry
argument_list|)
name|se_hash
expr_stmt|;
name|uint8_t
name|se_fails
decl_stmt|;
comment|/* failure to associate count */
name|uint8_t
name|se_seen
decl_stmt|;
comment|/* seen during current scan */
name|uint8_t
name|se_notseen
decl_stmt|;
comment|/* not seen in previous scans */
name|uint8_t
name|se_flags
decl_stmt|;
name|uint32_t
name|se_avgrssi
decl_stmt|;
comment|/* LPF rssi state */
name|unsigned
name|long
name|se_lastupdate
decl_stmt|;
comment|/* time of last update */
name|unsigned
name|long
name|se_lastfail
decl_stmt|;
comment|/* time of last failure */
name|unsigned
name|long
name|se_lastassoc
decl_stmt|;
comment|/* time of last association */
name|u_int
name|se_scangen
decl_stmt|;
comment|/* iterator scan gen# */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STA_HASHSIZE
value|32
end_define

begin_comment
comment|/* simple hash is enough for variation of macaddr */
end_comment

begin_define
define|#
directive|define
name|STA_HASH
parameter_list|(
name|addr
parameter_list|)
define|\
value|(((const uint8_t *)(addr))[IEEE80211_ADDR_LEN - 1] % STA_HASHSIZE)
end_define

begin_struct
struct|struct
name|sta_table
block|{
name|struct
name|mtx
name|st_lock
decl_stmt|;
comment|/* on scan table */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|sta_entry
argument_list|)
name|st_entry
expr_stmt|;
comment|/* all entries */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sta_entry
argument_list|)
name|st_hash
index|[
name|STA_HASHSIZE
index|]
expr_stmt|;
name|struct
name|mtx
name|st_scanlock
decl_stmt|;
comment|/* on st_scangen */
name|u_int
name|st_scangen
decl_stmt|;
comment|/* gen# for iterator */
name|int
name|st_newscan
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|sta_flush_table
parameter_list|(
name|struct
name|sta_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * match_bss returns a bitmask describing if an entry is suitable  * for use.  If non-zero the entry was deemed not suitable and it's  * contents explains why.  The following flags are or'd to to this  * mask and can be used to figure out why the entry was rejected.  */
end_comment

begin_define
define|#
directive|define
name|MATCH_CHANNEL
value|0x001
end_define

begin_comment
comment|/* channel mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_CAPINFO
value|0x002
end_define

begin_comment
comment|/* capabilities mismatch, e.g. no ess */
end_comment

begin_define
define|#
directive|define
name|MATCH_PRIVACY
value|0x004
end_define

begin_comment
comment|/* privacy mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_RATE
value|0x008
end_define

begin_comment
comment|/* rate set mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_SSID
value|0x010
end_define

begin_comment
comment|/* ssid mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_BSSID
value|0x020
end_define

begin_comment
comment|/* bssid mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_FAILS
value|0x040
end_define

begin_comment
comment|/* too many failed auth attempts */
end_comment

begin_define
define|#
directive|define
name|MATCH_NOTSEEN
value|0x080
end_define

begin_comment
comment|/* not seen in recent scans */
end_comment

begin_define
define|#
directive|define
name|MATCH_RSSI
value|0x100
end_define

begin_comment
comment|/* rssi deemed too low to use */
end_comment

begin_function_decl
specifier|static
name|int
name|match_bss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|struct
name|sta_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* number of references from net80211 layer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrefs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attach prior to any scanning work.  */
end_comment

begin_function
specifier|static
name|int
name|sta_attach
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
decl_stmt|;
name|MALLOC
argument_list|(
name|st
argument_list|,
expr|struct
name|sta_table
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sta_table
argument_list|)
argument_list|,
name|M_80211_SCAN
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|mtx_init
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|,
literal|"scantable"
argument_list|,
literal|"802.11 scan table"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|,
literal|"scangen"
argument_list|,
literal|"802.11 scangen"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_priv
operator|=
name|st
expr_stmt|;
name|nrefs
operator|++
expr_stmt|;
comment|/* NB: we assume caller locking */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup any private state.  */
end_comment

begin_function
specifier|static
name|int
name|sta_detach
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
block|{
name|sta_flush_table
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|st
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nrefs
operator|>
literal|0
argument_list|,
operator|(
literal|"imbalanced attach/detach"
operator|)
argument_list|)
expr_stmt|;
name|nrefs
operator|--
expr_stmt|;
comment|/* NB: we assume caller locking */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all per-scan state.  */
end_comment

begin_function
specifier|static
name|int
name|sta_flush
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|sta_flush_table
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all entries in the scan cache.  */
end_comment

begin_function
specifier|static
name|void
name|sta_flush_table
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|,
argument|next
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|se
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|saveie
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|iep
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
if|if
condition|(
name|ie
operator|==
name|NULL
condition|)
operator|*
name|iep
operator|=
name|NULL
expr_stmt|;
else|else
name|ieee80211_saveie
argument_list|(
name|iep
argument_list|,
name|ie
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a beacon or probe response frame; create an  * entry in the scan cache or update any previous entry.  */
end_comment

begin_function
specifier|static
name|int
name|sta_add
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|noise
parameter_list|,
name|int
name|rstamp
parameter_list|)
block|{
define|#
directive|define
name|ISPROBE
parameter_list|(
name|_st
parameter_list|)
value|((_st) == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
define|#
directive|define
name|PICK1ST
parameter_list|(
name|_ss
parameter_list|)
define|\
value|((ss->ss_flags& (IEEE80211_SCAN_PICK1ST | IEEE80211_SCAN_GOTPICK)) == \ 	IEEE80211_SCAN_PICK1ST)
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|macaddr
init|=
name|wh
operator|->
name|i_addr2
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ss
operator|->
name|ss_ic
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|struct
name|ieee80211_scan_entry
modifier|*
name|ise
decl_stmt|;
name|int
name|hash
decl_stmt|,
name|offchan
decl_stmt|;
name|hash
operator|=
name|STA_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_hash[hash]
argument_list|,
argument|se_hash
argument_list|)
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|se
operator|->
name|base
operator|.
name|se_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|MALLOC
argument_list|(
name|se
argument_list|,
expr|struct
name|sta_entry
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sta_entry
argument_list|)
argument_list|,
name|M_80211_SCAN
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|se
operator|->
name|se_scangen
operator|=
name|st
operator|->
name|st_scangen
operator|-
literal|1
expr_stmt|;
name|se
operator|->
name|se_avgrssi
operator|=
name|RSSI_DUMMY_MARKER
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|se
operator|->
name|base
operator|.
name|se_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|st
operator|->
name|st_hash
index|[
name|hash
index|]
argument_list|,
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|found
label|:
name|ise
operator|=
operator|&
name|se
operator|->
name|base
expr_stmt|;
comment|/* XXX ap beaconing multiple ssid w/ same bssid */
if|if
condition|(
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|ISPROBE
argument_list|(
name|subtype
argument_list|)
operator|||
name|ise
operator|->
name|se_ssid
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|memcpy
argument_list|(
name|ise
operator|->
name|se_ssid
argument_list|,
name|sp
operator|->
name|ssid
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|rates
index|[
literal|1
index|]
operator|<=
name|IEEE80211_RATE_MAXSIZE
argument_list|,
operator|(
literal|"rate set too large: %u"
operator|,
name|sp
operator|->
name|rates
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ise
operator|->
name|se_rates
argument_list|,
name|sp
operator|->
name|rates
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|rates
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|xrates
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX validate xrates[1] */
name|KASSERT
argument_list|(
name|sp
operator|->
name|xrates
index|[
literal|1
index|]
operator|+
name|sp
operator|->
name|rates
index|[
literal|1
index|]
operator|<=
name|IEEE80211_RATE_MAXSIZE
argument_list|,
operator|(
literal|"xrate set too large: %u"
operator|,
name|sp
operator|->
name|xrates
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ise
operator|->
name|se_xrates
argument_list|,
name|sp
operator|->
name|xrates
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|xrates
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ise
operator|->
name|se_xrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ise
operator|->
name|se_bssid
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
name|offchan
operator|=
operator|(
name|IEEE80211_CHAN2IEEE
argument_list|(
name|sp
operator|->
name|curchan
argument_list|)
operator|!=
name|sp
operator|->
name|bchan
operator|&&
name|ic
operator|->
name|ic_phytype
operator|!=
name|IEEE80211_T_FH
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|offchan
condition|)
block|{
comment|/* 		 * Record rssi data using extended precision LPF filter. 		 * 		 * NB: use only on-channel data to insure we get a good 		 *     estimate of the signal we'll see when associated. 		 */
name|RSSI_LPF
argument_list|(
name|se
operator|->
name|se_avgrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|ise
operator|->
name|se_rssi
operator|=
name|RSSI_GET
argument_list|(
name|se
operator|->
name|se_avgrssi
argument_list|)
expr_stmt|;
name|ise
operator|->
name|se_noise
operator|=
name|noise
expr_stmt|;
block|}
name|ise
operator|->
name|se_rstamp
operator|=
name|rstamp
expr_stmt|;
name|memcpy
argument_list|(
name|ise
operator|->
name|se_tstamp
operator|.
name|data
argument_list|,
name|sp
operator|->
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ise
operator|->
name|se_tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|ise
operator|->
name|se_intval
operator|=
name|sp
operator|->
name|bintval
expr_stmt|;
name|ise
operator|->
name|se_capinfo
operator|=
name|sp
operator|->
name|capinfo
expr_stmt|;
comment|/* 	 * Beware of overriding se_chan for frames seen 	 * off-channel; this can cause us to attempt an 	 * assocation on the wrong channel. 	 */
if|if
condition|(
name|ise
operator|->
name|se_chan
operator|==
name|NULL
operator|||
operator|!
name|offchan
condition|)
block|{
comment|/* 		 * NB: this is not right when the frame is received 		 * off-channel but se_chan is assumed set by code 		 * elsewhere so we must assign something; the scan 		 * entry should be ignored because the rssi will be 		 * zero (because the frames are received off-channel). 		 * 		 * We could locate the correct channel using sp->chan 		 * but it's not clear we should join an ap that we 		 * never see on-channel during a scan. 		 */
name|ise
operator|->
name|se_chan
operator|=
name|sp
operator|->
name|curchan
expr_stmt|;
block|}
name|ise
operator|->
name|se_fhdwell
operator|=
name|sp
operator|->
name|fhdwell
expr_stmt|;
name|ise
operator|->
name|se_fhindex
operator|=
name|sp
operator|->
name|fhindex
expr_stmt|;
name|ise
operator|->
name|se_erp
operator|=
name|sp
operator|->
name|erp
expr_stmt|;
name|ise
operator|->
name|se_timoff
operator|=
name|sp
operator|->
name|timoff
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tim
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|ieee80211_tim_ie
modifier|*
name|tim
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|sp
operator|->
name|tim
decl_stmt|;
name|ise
operator|->
name|se_dtimperiod
operator|=
name|tim
operator|->
name|tim_period
expr_stmt|;
block|}
name|saveie
argument_list|(
operator|&
name|ise
operator|->
name|se_wme_ie
argument_list|,
name|sp
operator|->
name|wme
argument_list|)
expr_stmt|;
name|saveie
argument_list|(
operator|&
name|ise
operator|->
name|se_wpa_ie
argument_list|,
name|sp
operator|->
name|wpa
argument_list|)
expr_stmt|;
name|saveie
argument_list|(
operator|&
name|ise
operator|->
name|se_rsn_ie
argument_list|,
name|sp
operator|->
name|rsn
argument_list|)
expr_stmt|;
name|saveie
argument_list|(
operator|&
name|ise
operator|->
name|se_ath_ie
argument_list|,
name|sp
operator|->
name|ath
argument_list|)
expr_stmt|;
name|saveie
argument_list|(
operator|&
name|ise
operator|->
name|se_htcap_ie
argument_list|,
name|sp
operator|->
name|htcap
argument_list|)
expr_stmt|;
name|saveie
argument_list|(
operator|&
name|ise
operator|->
name|se_htinfo_ie
argument_list|,
name|sp
operator|->
name|htinfo
argument_list|)
expr_stmt|;
comment|/* clear failure count after STA_FAIL_AGE passes */
if|if
condition|(
name|se
operator|->
name|se_fails
operator|&&
operator|(
name|ticks
operator|-
name|se
operator|->
name|se_lastfail
operator|)
operator|>
name|STA_FAILS_AGE
operator|*
name|hz
condition|)
block|{
name|se
operator|->
name|se_fails
operator|=
literal|0
expr_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
name|macaddr
argument_list|,
literal|"%s: fails %u"
argument_list|,
name|__func__
argument_list|,
name|se
operator|->
name|se_fails
argument_list|)
expr_stmt|;
block|}
name|se
operator|->
name|se_lastupdate
operator|=
name|ticks
expr_stmt|;
comment|/* update time */
name|se
operator|->
name|se_seen
operator|=
literal|1
expr_stmt|;
name|se
operator|->
name|se_notseen
operator|=
literal|0
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If looking for a quick choice and nothing's 	 * been found check here. 	 */
if|if
condition|(
name|PICK1ST
argument_list|(
name|ss
argument_list|)
operator|&&
name|match_bss
argument_list|(
name|ic
argument_list|,
name|ss
argument_list|,
name|se
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_flags
operator||=
name|IEEE80211_SCAN_GOTPICK
expr_stmt|;
return|return
literal|1
return|;
undef|#
directive|undef
name|PICK1ST
undef|#
directive|undef
name|ISPROBE
block|}
end_function

begin_comment
comment|/*  * Check if a channel is excluded by user request.  */
end_comment

begin_function
specifier|static
name|int
name|isexcluded
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|)
operator|||
operator|(
name|ic
operator|->
name|ic_des_chan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
name|c
operator|->
name|ic_freq
operator|!=
name|ic
operator|->
name|ic_des_chan
operator|->
name|ic_freq
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|find11gchannel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* 	 * The normal ordering in the channel list is b channel 	 * immediately followed by g so optimize the search for 	 * this.  We'll still do a full search just in case. 	 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|chanflags
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
name|IEEE80211_CHAN_B
block|,
comment|/* IEEE80211_MODE_AUTO */
name|IEEE80211_CHAN_A
block|,
comment|/* IEEE80211_MODE_11A */
name|IEEE80211_CHAN_B
block|,
comment|/* IEEE80211_MODE_11B */
name|IEEE80211_CHAN_G
block|,
comment|/* IEEE80211_MODE_11G */
name|IEEE80211_CHAN_FHSS
block|,
comment|/* IEEE80211_MODE_FH */
name|IEEE80211_CHAN_A
block|,
comment|/* IEEE80211_MODE_TURBO_A (check base channel)*/
name|IEEE80211_CHAN_G
block|,
comment|/* IEEE80211_MODE_TURBO_G */
name|IEEE80211_CHAN_ST
block|,
comment|/* IEEE80211_MODE_STURBO_A */
name|IEEE80211_CHAN_A
block|,
comment|/* IEEE80211_MODE_11NA (check legacy) */
name|IEEE80211_CHAN_G
block|,
comment|/* IEEE80211_MODE_11NG (check legacy) */
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_channels
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
specifier|const
name|uint16_t
name|freq
index|[]
parameter_list|,
name|int
name|nfreq
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|,
modifier|*
name|cg
decl_stmt|;
name|u_int
name|modeflags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|mode
operator|<
name|N
argument_list|(
name|chanflags
argument_list|)
argument_list|,
operator|(
literal|"Unexpected mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
name|modeflags
operator|=
name|chanflags
index|[
name|mode
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfreq
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_last
operator|>=
name|IEEE80211_SCAN_MAX
condition|)
break|break;
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|freq
index|[
name|i
index|]
argument_list|,
name|modeflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|isexcluded
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_AUTO
condition|)
block|{
comment|/* 			 * XXX special-case 11b/g channels so we select 			 *     the g channel if both are present or there 			 *     are only g channels. 			 */
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|cg
operator|=
name|find11gchannel
argument_list|(
name|ic
argument_list|,
name|i
argument_list|,
name|freq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|cg
operator|!=
name|NULL
condition|)
name|c
operator|=
name|cg
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
continue|continue;
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl1
index|[]
init|=
comment|/* 8 FCC channel: 52, 56, 60, 64, 36, 40, 44, 48 */
block|{
literal|5260
block|,
literal|5280
block|,
literal|5300
block|,
literal|5320
block|,
literal|5180
block|,
literal|5200
block|,
literal|5220
block|,
literal|5240
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl2
index|[]
init|=
comment|/* 4 MKK channels: 34, 38, 42, 46 */
block|{
literal|5170
block|,
literal|5190
block|,
literal|5210
block|,
literal|5230
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl3
index|[]
init|=
comment|/* 2.4Ghz ch: 1,6,11,7,13 */
block|{
literal|2412
block|,
literal|2437
block|,
literal|2462
block|,
literal|2442
block|,
literal|2472
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl4
index|[]
init|=
comment|/* 5 FCC channel: 149, 153, 161, 165 */
block|{
literal|5745
block|,
literal|5765
block|,
literal|5785
block|,
literal|5805
block|,
literal|5825
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl7
index|[]
init|=
comment|/* 11 ETSI channel: 100,104,108,112,116,120,124,128,132,136,140 */
block|{
literal|5500
block|,
literal|5520
block|,
literal|5540
block|,
literal|5560
block|,
literal|5580
block|,
literal|5600
block|,
literal|5620
block|,
literal|5640
block|,
literal|5660
block|,
literal|5680
block|,
literal|5700
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl8
index|[]
init|=
comment|/* 2.4Ghz ch: 2,3,4,5,8,9,10,12 */
block|{
literal|2417
block|,
literal|2422
block|,
literal|2427
block|,
literal|2432
block|,
literal|2447
block|,
literal|2452
block|,
literal|2457
block|,
literal|2467
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl9
index|[]
init|=
comment|/* 2.4Ghz ch: 14 */
block|{
literal|2484
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl10
index|[]
init|=
comment|/* Added Korean channels 2312-2372 */
block|{
literal|2312
block|,
literal|2317
block|,
literal|2322
block|,
literal|2327
block|,
literal|2332
block|,
literal|2337
block|,
literal|2342
block|,
literal|2347
block|,
literal|2352
block|,
literal|2357
block|,
literal|2362
block|,
literal|2367
block|,
literal|2372
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl11
index|[]
init|=
comment|/* Added Japan channels in 4.9/5.0 spectrum */
block|{
literal|5040
block|,
literal|5060
block|,
literal|5080
block|,
literal|4920
block|,
literal|4940
block|,
literal|4960
block|,
literal|4980
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TURBO_SCAN
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl5
index|[]
init|=
comment|/* 3 static turbo channels */
block|{
literal|5210
block|,
literal|5250
block|,
literal|5290
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl6
index|[]
init|=
comment|/* 2 static turbo channels */
block|{
literal|5760
block|,
literal|5800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl6x
index|[]
init|=
comment|/* 4 FCC3 turbo channels */
block|{
literal|5540
block|,
literal|5580
block|,
literal|5620
block|,
literal|5660
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl12
index|[]
init|=
comment|/* 2.4Ghz Turbo channel 6 */
block|{
literal|2437
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl13
index|[]
init|=
comment|/* dynamic Turbo channels */
block|{
literal|5200
block|,
literal|5240
block|,
literal|5280
block|,
literal|5765
block|,
literal|5805
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_TURBO_SCAN */
end_comment

begin_struct
struct|struct
name|scanlist
block|{
name|uint16_t
name|mode
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|X
parameter_list|(
name|a
parameter_list|)
value|.count = sizeof(a)/sizeof(a[0]), .list = a
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|scanlist
name|staScanTable
index|[]
init|=
block|{
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl3
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl1
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl2
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl8
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl9
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl4
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|ATH_TURBO_SCAN
block|{
name|IEEE80211_MODE_STURBO_A
block|,
name|X
argument_list|(
argument|rcl5
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_STURBO_A
block|,
name|X
argument_list|(
argument|rcl6
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_TURBO_A
block|,
name|X
argument_list|(
argument|rcl6x
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_TURBO_A
block|,
name|X
argument_list|(
argument|rcl13
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* ATH_TURBO_SCAN */
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl7
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl10
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl11
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|ATH_TURBO_SCAN
block|{
name|IEEE80211_MODE_TURBO_G
block|,
name|X
argument_list|(
argument|rcl12
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* ATH_TURBO_SCAN */
block|{
operator|.
name|list
operator|=
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|checktable
parameter_list|(
specifier|const
name|struct
name|scanlist
modifier|*
name|scan
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
name|scan
operator|->
name|list
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scan
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|scan
operator|->
name|list
index|[
name|i
index|]
operator|==
name|c
operator|->
name|ic_freq
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start a station-mode scan by populating the channel list.  */
end_comment

begin_function
specifier|static
name|int
name|sta_start
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
specifier|const
name|struct
name|scanlist
modifier|*
name|scan
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use the table of ordered channels to construct the list 	 * of channels for scanning.  Any channels in the ordered 	 * list not in the master list will be discarded. 	 */
for|for
control|(
name|scan
operator|=
name|staScanTable
init|;
name|scan
operator|->
name|list
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
name|mode
operator|=
name|scan
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
condition|)
block|{
comment|/* 			 * If a desired mode was specified, scan only  			 * channels that satisfy that constraint. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|mode
condition|)
block|{
comment|/* 				 * The scan table marks 2.4Ghz channels as b 				 * so if the desired mode is 11g, then use 				 * the 11b channel list but upgrade the mode. 				 */
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_11G
operator|||
name|mode
operator|!=
name|IEEE80211_MODE_11B
condition|)
continue|continue;
name|mode
operator|=
name|IEEE80211_MODE_11G
expr_stmt|;
comment|/* upgrade */
block|}
block|}
else|else
block|{
comment|/* 			 * This lets add_channels upgrade an 11b channel 			 * to 11g if available. 			 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11B
condition|)
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_F_XR
comment|/* XR does not operate on turbo channels */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_XR
operator|)
operator|&&
operator|(
name|mode
operator|==
name|IEEE80211_MODE_TURBO_A
operator|||
name|mode
operator|==
name|IEEE80211_MODE_TURBO_G
operator|||
name|mode
operator|==
name|IEEE80211_MODE_STURBO_A
operator|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 		 * Add the list of the channels; any that are not 		 * in the master channel list will be discarded. 		 */
name|add_channels
argument_list|(
name|ic
argument_list|,
name|ss
argument_list|,
name|mode
argument_list|,
name|scan
operator|->
name|list
argument_list|,
name|scan
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the channels from the ic (from HAL) that are not present 	 * in the staScanTable. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_last
operator|>=
name|IEEE80211_SCAN_MAX
condition|)
break|break;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Ignore dynamic turbo channels; we scan them 		 * in normal mode (i.e. not boosted).  Likewise 		 * for HT channels, they get scanned using 		 * legacy rates. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_DTURBO
argument_list|(
name|c
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If a desired mode was specified, scan only  		 * channels that satisfy that constraint. 		 */
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
operator|&&
name|ic
operator|->
name|ic_des_mode
operator|!=
name|ieee80211_chan2mode
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Skip channels excluded by user request. 		 */
if|if
condition|(
name|isexcluded
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Add the channel unless it is listed in the 		 * fixed scan order tables.  This insures we 		 * don't sweep back in channels we filtered out 		 * above. 		 */
if|if
condition|(
name|checktable
argument_list|(
name|staScanTable
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
comment|/* Add channel to scanning list. */
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
name|ss
operator|->
name|ss_next
operator|=
literal|0
expr_stmt|;
comment|/* XXX tunables */
name|ss
operator|->
name|ss_mindwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* 20ms */
name|ss
operator|->
name|ss_maxdwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_scan
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"scan set "
argument_list|)
expr_stmt|;
name|ieee80211_scan_dump_channels
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dwell min %ld max %ld\n"
argument_list|,
name|ss
operator|->
name|ss_mindwell
argument_list|,
name|ss
operator|->
name|ss_maxdwell
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_DEBUG */
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Restart a bg scan.  */
end_comment

begin_function
specifier|static
name|int
name|sta_restart
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Cancel an ongoing scan.  */
end_comment

begin_function
specifier|static
name|int
name|sta_cancel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|maxrate
parameter_list|(
specifier|const
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
parameter_list|)
block|{
name|uint8_t
name|rmax
decl_stmt|,
name|r
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rmax
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|se
operator|->
name|se_rates
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|se
operator|->
name|se_rates
index|[
literal|2
operator|+
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|rmax
condition|)
name|rmax
operator|=
name|r
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|se
operator|->
name|se_xrates
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|se
operator|->
name|se_xrates
index|[
literal|2
operator|+
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|rmax
condition|)
name|rmax
operator|=
name|r
expr_stmt|;
block|}
return|return
name|rmax
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the capabilities of two entries and decide which is  * more desirable (return>0 if a is considered better).  Note  * that we assume compatibility/usability has already been checked  * so we don't need to (e.g. validate whether privacy is supported).  * Used to select the best scan candidate for association in a BSS.  */
end_comment

begin_function
specifier|static
name|int
name|sta_compare
parameter_list|(
specifier|const
name|struct
name|sta_entry
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|sta_entry
modifier|*
name|b
parameter_list|)
block|{
define|#
directive|define
name|PREFER
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|,
name|_what
parameter_list|)
value|do {			\ 	if (((_a) ^ (_b))& (_what))			\ 		return ((_a)& (_what)) ? 1 : -1;	\ } while (0)
name|uint8_t
name|maxa
decl_stmt|,
name|maxb
decl_stmt|;
name|int8_t
name|rssia
decl_stmt|,
name|rssib
decl_stmt|;
name|int
name|weight
decl_stmt|;
comment|/* privacy support */
name|PREFER
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_capinfo
argument_list|,
name|b
operator|->
name|base
operator|.
name|se_capinfo
argument_list|,
name|IEEE80211_CAPINFO_PRIVACY
argument_list|)
expr_stmt|;
comment|/* compare count of previous failures */
name|weight
operator|=
name|b
operator|->
name|se_fails
operator|-
name|a
operator|->
name|se_fails
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|weight
argument_list|)
operator|>
literal|1
condition|)
return|return
name|weight
return|;
comment|/* 	 * Compare rssi.  If the two are considered equivalent 	 * then fallback to other criteria.  We threshold the 	 * comparisons to avoid selecting an ap purely by rssi 	 * when both values may be good but one ap is otherwise 	 * more desirable (e.g. an 11b-only ap with stronger 	 * signal than an 11g ap). 	 */
name|rssia
operator|=
name|MIN
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_rssi
argument_list|,
name|STA_RSSI_MAX
argument_list|)
expr_stmt|;
name|rssib
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|base
operator|.
name|se_rssi
argument_list|,
name|STA_RSSI_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|rssib
operator|-
name|rssia
argument_list|)
operator|<
literal|5
condition|)
block|{
comment|/* best/max rate preferred if signal level close enough XXX */
name|maxa
operator|=
name|maxrate
argument_list|(
operator|&
name|a
operator|->
name|base
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|maxrate
argument_list|(
operator|&
name|b
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxa
operator|!=
name|maxb
condition|)
return|return
name|maxa
operator|-
name|maxb
return|;
comment|/* XXX use freq for channel preference */
comment|/* for now just prefer 5Ghz band to all other bands */
if|if
condition|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_chan
argument_list|)
operator|&&
operator|!
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|b
operator|->
name|base
operator|.
name|se_chan
argument_list|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_chan
argument_list|)
operator|&&
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|b
operator|->
name|base
operator|.
name|se_chan
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* all things being equal, use signal level */
return|return
name|a
operator|->
name|base
operator|.
name|se_rssi
operator|-
name|b
operator|->
name|base
operator|.
name|se_rssi
return|;
undef|#
directive|undef
name|PREFER
block|}
end_function

begin_comment
comment|/*  * Check rate set suitability and return the best supported rate.  */
end_comment

begin_function
specifier|static
name|int
name|check_rate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
parameter_list|)
block|{
define|#
directive|define
name|RV
parameter_list|(
name|v
parameter_list|)
value|((v)& IEEE80211_RATE_VAL)
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|srs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nrs
decl_stmt|,
name|r
decl_stmt|,
name|okrate
decl_stmt|,
name|badrate
decl_stmt|,
name|fixedrate
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|rs
decl_stmt|;
name|okrate
operator|=
name|badrate
operator|=
name|fixedrate
operator|=
literal|0
expr_stmt|;
name|srs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|se
operator|->
name|se_chan
argument_list|)
expr_stmt|;
name|nrs
operator|=
name|se
operator|->
name|se_rates
index|[
literal|1
index|]
expr_stmt|;
name|rs
operator|=
name|se
operator|->
name|se_rates
operator|+
literal|2
expr_stmt|;
name|fixedrate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
name|again
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrs
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|RV
argument_list|(
name|rs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|badrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check any fixed rate is included.  		 */
if|if
condition|(
name|r
operator|==
name|ic
operator|->
name|ic_fixed_rate
condition|)
name|fixedrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check against our supported rates. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|r
operator|==
name|RV
argument_list|(
name|srs
operator|->
name|rs_rates
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|>
name|okrate
condition|)
comment|/* NB: track max */
name|okrate
operator|=
name|r
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|srs
operator|->
name|rs_nrates
operator|&&
operator|(
name|rs
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
condition|)
block|{
comment|/* 			 * Don't try joining a BSS, if we don't support 			 * one of its basic rates. 			 */
name|okrate
operator|=
literal|0
expr_stmt|;
goto|goto
name|back
goto|;
block|}
block|}
if|if
condition|(
name|rs
operator|==
name|se
operator|->
name|se_rates
operator|+
literal|2
condition|)
block|{
comment|/* scan xrates too; sort of an algol68-style for loop */
name|nrs
operator|=
name|se
operator|->
name|se_xrates
index|[
literal|1
index|]
expr_stmt|;
name|rs
operator|=
name|se
operator|->
name|se_xrates
operator|+
literal|2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|back
label|:
if|if
condition|(
name|okrate
operator|==
literal|0
operator|||
name|ic
operator|->
name|ic_fixed_rate
operator|!=
name|fixedrate
condition|)
return|return
name|badrate
operator||
name|IEEE80211_RATE_BASIC
return|;
else|else
return|return
name|RV
argument_list|(
name|okrate
argument_list|)
return|;
undef|#
directive|undef
name|RV
block|}
end_function

begin_function
specifier|static
name|int
name|match_ssid
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|,
name|int
name|nssid
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_ssid
name|ssids
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nssid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ie
index|[
literal|1
index|]
operator|==
name|ssids
index|[
name|i
index|]
operator|.
name|len
operator|&&
name|memcmp
argument_list|(
name|ie
operator|+
literal|2
argument_list|,
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|ie
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Test a scan candidate for suitability/compatibility.  */
end_comment

begin_function
specifier|static
name|int
name|match_bss
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|sta_entry
modifier|*
name|se0
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
init|=
operator|&
name|se0
operator|->
name|base
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|se
operator|->
name|se_chan
argument_list|)
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_CHANNEL
expr_stmt|;
comment|/* 	 * NB: normally the desired mode is used to construct 	 * the channel list, but it's possible for the scan 	 * cache to include entries for stations outside this 	 * list so we check the desired mode here to weed them 	 * out. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
operator|&&
operator|(
name|se
operator|->
name|se_chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBO
operator|)
operator|!=
name|chanflags
index|[
name|ic
operator|->
name|ic_des_mode
index|]
condition|)
name|fail
operator||=
name|MATCH_CHANNEL
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
name|MATCH_CAPINFO
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
name|MATCH_CAPINFO
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
name|MATCH_PRIVACY
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
name|fail
operator||=
name|MATCH_PRIVACY
expr_stmt|;
block|}
name|rate
operator|=
name|check_rate
argument_list|(
name|ic
argument_list|,
name|se
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
name|fail
operator||=
name|MATCH_RATE
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_nssid
operator|!=
literal|0
operator|&&
operator|!
name|match_ssid
argument_list|(
name|se
operator|->
name|se_ssid
argument_list|,
name|ss
operator|->
name|ss_nssid
argument_list|,
name|ss
operator|->
name|ss_ssid
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_SSID
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|ic
operator|->
name|ic_des_bssid
argument_list|,
name|se
operator|->
name|se_bssid
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_BSSID
expr_stmt|;
if|if
condition|(
name|se0
operator|->
name|se_fails
operator|>=
name|STA_FAILS_MAX
condition|)
name|fail
operator||=
name|MATCH_FAILS
expr_stmt|;
comment|/* NB: entries may be present awaiting purge, skip */
if|if
condition|(
name|se0
operator|->
name|se_notseen
operator|>=
name|STA_PURGE_SCANS
condition|)
name|fail
operator||=
name|MATCH_NOTSEEN
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_rssi
operator|<
name|STA_RSSI_MIN
condition|)
name|fail
operator||=
name|MATCH_RSSI
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg
argument_list|(
name|ic
argument_list|,
name|debug
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" %c %s"
argument_list|,
name|fail
operator|&
name|MATCH_FAILS
condition|?
literal|'='
else|:
name|fail
operator|&
name|MATCH_NOTSEEN
condition|?
literal|'^'
else|:
name|fail
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|ether_sprintf
argument_list|(
name|se
operator|->
name|se_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s%c"
argument_list|,
name|ether_sprintf
argument_list|(
name|se
operator|->
name|se_bssid
argument_list|)
argument_list|,
name|fail
operator|&
name|MATCH_BSSID
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d%c"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|se
operator|->
name|se_chan
argument_list|)
argument_list|,
name|fail
operator|&
name|MATCH_CHANNEL
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %+4d%c"
argument_list|,
name|se
operator|->
name|se_rssi
argument_list|,
name|fail
operator|&
name|MATCH_RSSI
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %2dM%c"
argument_list|,
operator|(
name|rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
name|fail
operator|&
name|MATCH_RATE
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s%c"
argument_list|,
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
condition|?
literal|"ess"
else|:
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
condition|?
literal|"ibss"
else|:
literal|"????"
argument_list|,
name|fail
operator|&
name|MATCH_CAPINFO
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s%c "
argument_list|,
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
condition|?
literal|"wep"
else|:
literal|"no"
argument_list|,
name|fail
operator|&
name|MATCH_PRIVACY
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|se
operator|->
name|se_ssid
operator|+
literal|2
argument_list|,
name|se
operator|->
name|se_ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fail
operator|&
name|MATCH_SSID
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fail
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_update_notseen
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
comment|/* 		 * If seen the reset and don't bump the count; 		 * otherwise bump the ``not seen'' count.  Note 		 * that this insures that stations for which we 		 * see frames while not scanning but not during 		 * this scan will not be penalized. 		 */
if|if
condition|(
name|se
operator|->
name|se_seen
condition|)
name|se
operator|->
name|se_seen
operator|=
literal|0
expr_stmt|;
else|else
name|se
operator|->
name|se_notseen
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_dec_fails
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
if|if
condition|(
name|se
operator|->
name|se_fails
condition|)
name|se
operator|->
name|se_fails
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sta_entry
modifier|*
name|select_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|selbs
init|=
name|NULL
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|debug
argument_list|,
literal|" %s\n"
argument_list|,
literal|"macaddr          bssid         chan  rssi  rate flag  wep  essid"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
if|if
condition|(
name|match_bss
argument_list|(
name|ic
argument_list|,
name|ss
argument_list|,
name|se
argument_list|,
name|debug
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
name|selbs
operator|=
name|se
expr_stmt|;
elseif|else
if|if
condition|(
name|sta_compare
argument_list|(
name|se
argument_list|,
name|selbs
argument_list|)
operator|>
literal|0
condition|)
name|selbs
operator|=
name|se
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
name|selbs
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an ap or ibss network to join or find a channel  * to use to start an ibss network.  */
end_comment

begin_function
specifier|static
name|int
name|sta_pick_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|selbs
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_newscan
condition|)
block|{
name|sta_update_notseen
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOPICK
condition|)
block|{
comment|/* 		 * Manual/background scan, don't select+join the 		 * bss, just return.  The scanning framework will 		 * handle notification that this has completed. 		 */
name|ss
operator|->
name|ss_flags
operator|&=
operator|~
name|IEEE80211_SCAN_NOPICK
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Automatic sequencing; look for a candidate and 	 * if found join the network. 	 */
comment|/* NB: unlocked read should be ok */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no scan candidate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|notfound
label|:
comment|/* 		 * If nothing suitable was found decrement 		 * the failure counts so entries will be 		 * reconsidered the next time around.  We 		 * really want to do this only for sta's 		 * where we've previously had some success. 		 */
name|sta_dec_fails
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* restart scan */
block|}
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|selbs
operator|==
name|NULL
operator|||
operator|!
name|ieee80211_sta_join
argument_list|(
name|ic
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
condition|)
goto|goto
name|notfound
goto|;
return|return
literal|1
return|;
comment|/* terminate scan */
block|}
end_function

begin_comment
comment|/*  * Lookup an entry in the scan cache.  We assume we're  * called from the bottom half or such that we don't need  * to block the bottom half so that it's safe to return  * a reference to an entry w/o holding the lock on the table.  */
end_comment

begin_function
specifier|static
name|struct
name|sta_entry
modifier|*
name|sta_lookup
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|int
name|hash
init|=
name|STA_HASH
argument_list|(
name|macaddr
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_hash[hash]
argument_list|,
argument|se_hash
argument_list|)
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|se
operator|->
name|base
operator|.
name|se_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
name|se
return|;
comment|/* NB: unlocked */
block|}
end_function

begin_function
specifier|static
name|void
name|sta_roam_check
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|ic
operator|->
name|ic_bss
decl_stmt|;
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|selbs
decl_stmt|;
name|uint8_t
name|roamRate
decl_stmt|,
name|curRate
decl_stmt|;
name|int8_t
name|roamRssi
decl_stmt|,
name|curRssi
decl_stmt|;
name|se
operator|=
name|sta_lookup
argument_list|(
name|st
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
block|{
comment|/* XXX something is wrong */
return|return;
block|}
comment|/* XXX do we need 11g too? */
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
name|roamRate
operator|=
name|ic
operator|->
name|ic_roam
operator|.
name|rate11b
expr_stmt|;
name|roamRssi
operator|=
name|ic
operator|->
name|ic_roam
operator|.
name|rssi11b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
block|{
name|roamRate
operator|=
name|ic
operator|->
name|ic_roam
operator|.
name|rate11bOnly
expr_stmt|;
name|roamRssi
operator|=
name|ic
operator|->
name|ic_roam
operator|.
name|rssi11bOnly
expr_stmt|;
block|}
else|else
block|{
name|roamRate
operator|=
name|ic
operator|->
name|ic_roam
operator|.
name|rate11a
expr_stmt|;
name|roamRssi
operator|=
name|ic
operator|->
name|ic_roam
operator|.
name|rssi11a
expr_stmt|;
block|}
comment|/* NB: the most up to date rssi is in the node, not the scan cache */
name|curRssi
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_fixed_rate
operator|==
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
name|curRate
operator|=
name|ni
operator|->
name|ni_rates
operator|.
name|rs_rates
index|[
name|ni
operator|->
name|ni_txrate
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ROAM
argument_list|,
literal|"%s: currssi %d currate %u roamrssi %d roamrate %u\n"
argument_list|,
name|__func__
argument_list|,
name|curRssi
argument_list|,
name|curRate
argument_list|,
name|roamRssi
argument_list|,
name|roamRate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curRate
operator|=
name|roamRate
expr_stmt|;
comment|/* NB: insure compare below fails */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ROAM
argument_list|,
literal|"%s: currssi %d roamrssi %d\n"
argument_list|,
name|__func__
argument_list|,
name|curRssi
argument_list|,
name|roamRssi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if a new ap should be used and switch. 	 * XXX deauth current ap 	 */
if|if
condition|(
name|curRate
operator|<
name|roamRate
operator|||
name|curRssi
operator|<
name|roamRssi
condition|)
block|{
if|if
condition|(
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastscan
operator|+
name|ic
operator|->
name|ic_scanvalid
argument_list|)
condition|)
block|{
comment|/* 			 * Scan cache contents are too old; force a scan now 			 * if possible so we have current state to make a 			 * decision with.  We don't kick off a bg scan if 			 * we're using dynamic turbo and boosted or if the 			 * channel is busy. 			 * XXX force immediate switch on scan complete 			 */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_DTURBO
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastdata
operator|+
name|ic
operator|->
name|ic_bgscanidle
argument_list|)
condition|)
name|ieee80211_bg_scan
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return;
block|}
name|se
operator|->
name|base
operator|.
name|se_rssi
operator|=
name|curRssi
expr_stmt|;
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|ic
argument_list|,
name|IEEE80211_MSG_ROAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|selbs
operator|!=
name|NULL
operator|&&
name|selbs
operator|!=
name|se
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ROAM
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s: ROAM: curRate %u, roamRate %u, "
literal|"curRssi %d, roamRssi %d\n"
argument_list|,
name|__func__
argument_list|,
name|curRate
argument_list|,
name|roamRate
argument_list|,
name|curRssi
argument_list|,
name|roamRssi
argument_list|)
expr_stmt|;
name|ieee80211_sta_join
argument_list|(
name|ic
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Age entries in the scan cache.  * XXX also do roaming since it's convenient  */
end_comment

begin_function
specifier|static
name|void
name|sta_age
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ss
operator|->
name|ss_ic
decl_stmt|;
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_notseen
operator|>
name|STA_PURGE_SCANS
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|se
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If rate control is enabled check periodically to see if 	 * we should roam from our current connection to one that 	 * might be better.  This only applies when we're operating 	 * in sta mode and automatic roaming is set. 	 * XXX defer if busy 	 * XXX repeater station 	 * XXX do when !bgscan? 	 */
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_roaming
operator|==
name|IEEE80211_ROAMING_AUTO
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_BGSCAN
operator|)
operator|&&
name|ic
operator|->
name|ic_state
operator|>=
name|IEEE80211_S_RUN
condition|)
comment|/* XXX vap is implicit */
name|sta_roam_check
argument_list|(
name|ss
argument_list|,
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the entries in the scan cache, invoking  * the callback function on each one.  */
end_comment

begin_function
specifier|static
name|void
name|sta_iterate
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|ieee80211_scan_iter_func
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|)
expr_stmt|;
name|gen
operator|=
name|st
operator|->
name|st_scangen
operator|++
expr_stmt|;
name|restart
label|:
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_scangen
operator|!=
name|gen
condition|)
block|{
name|se
operator|->
name|se_scangen
operator|=
name|gen
expr_stmt|;
comment|/* update public state */
name|se
operator|->
name|base
operator|.
name|se_age
operator|=
name|ticks
operator|-
name|se
operator|->
name|se_lastupdate
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|arg
argument_list|,
operator|&
name|se
operator|->
name|base
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_assoc_fail
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|se
operator|=
name|sta_lookup
argument_list|(
name|st
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|!=
name|NULL
condition|)
block|{
name|se
operator|->
name|se_fails
operator|++
expr_stmt|;
name|se
operator|->
name|se_lastfail
operator|=
name|ticks
expr_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|ss
operator|->
name|ss_ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
name|macaddr
argument_list|,
literal|"%s: reason %u fails %u"
argument_list|,
name|__func__
argument_list|,
name|reason
argument_list|,
name|se
operator|->
name|se_fails
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sta_assoc_success
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|se
operator|=
name|sta_lookup
argument_list|(
name|st
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
block|se->se_fails = 0; 		IEEE80211_NOTE_MAC(ss->ss_ic, IEEE80211_MSG_SCAN, 		    macaddr, "%s: fails %u", 		    __func__, se->se_fails);
endif|#
directive|endif
name|se
operator|->
name|se_lastassoc
operator|=
name|ticks
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|sta_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|sta_attach
block|,
operator|.
name|scan_detach
operator|=
name|sta_detach
block|,
operator|.
name|scan_start
operator|=
name|sta_start
block|,
operator|.
name|scan_restart
operator|=
name|sta_restart
block|,
operator|.
name|scan_cancel
operator|=
name|sta_cancel
block|,
operator|.
name|scan_end
operator|=
name|sta_pick_bss
block|,
operator|.
name|scan_flush
operator|=
name|sta_flush
block|,
operator|.
name|scan_add
operator|=
name|sta_add
block|,
operator|.
name|scan_age
operator|=
name|sta_age
block|,
operator|.
name|scan_iterate
operator|=
name|sta_iterate
block|,
operator|.
name|scan_assoc_fail
operator|=
name|sta_assoc_fail
block|,
operator|.
name|scan_assoc_success
operator|=
name|sta_assoc_success
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Adhoc mode-specific support.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhocWorld
index|[]
init|=
comment|/* 36, 40, 44, 48 */
block|{
literal|5180
block|,
literal|5200
block|,
literal|5220
block|,
literal|5240
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhocFcc3
index|[]
init|=
comment|/* 36, 40, 44, 48 145, 149, 153, 157, 161, 165 */
block|{
literal|5180
block|,
literal|5200
block|,
literal|5220
block|,
literal|5240
block|,
literal|5725
block|,
literal|5745
block|,
literal|5765
block|,
literal|5785
block|,
literal|5805
block|,
literal|5825
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhocMkk
index|[]
init|=
comment|/* 34, 38, 42, 46 */
block|{
literal|5170
block|,
literal|5190
block|,
literal|5210
block|,
literal|5230
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhoc11b
index|[]
init|=
comment|/* 10, 11 */
block|{
literal|2457
block|,
literal|2462
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|scanlist
name|adhocScanTable
index|[]
init|=
block|{
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|adhoc11b
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|adhocWorld
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|adhocFcc3
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|adhocMkk
argument_list|)
block|}
block|,
block|{
operator|.
name|list
operator|=
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_comment
comment|/*  * Start an adhoc-mode scan by populating the channel list.  */
end_comment

begin_function
specifier|static
name|int
name|adhoc_start
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a)/sizeof(a[0]))
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
specifier|const
name|struct
name|scanlist
modifier|*
name|scan
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use the table of ordered channels to construct the list 	 * of channels for scanning.  Any channels in the ordered 	 * list not in the master list will be discarded. 	 */
for|for
control|(
name|scan
operator|=
name|adhocScanTable
init|;
name|scan
operator|->
name|list
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
name|mode
operator|=
name|scan
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
condition|)
block|{
comment|/* 			 * If a desired mode was specified, scan only  			 * channels that satisfy that constraint. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|mode
condition|)
block|{
comment|/* 				 * The scan table marks 2.4Ghz channels as b 				 * so if the desired mode is 11g, then use 				 * the 11b channel list but upgrade the mode. 				 */
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_11G
operator|||
name|mode
operator|!=
name|IEEE80211_MODE_11B
condition|)
continue|continue;
name|mode
operator|=
name|IEEE80211_MODE_11G
expr_stmt|;
comment|/* upgrade */
block|}
block|}
else|else
block|{
comment|/* 			 * This lets add_channels upgrade an 11b channel 			 * to 11g if available. 			 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11B
condition|)
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_F_XR
comment|/* XR does not operate on turbo channels */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_XR
operator|)
operator|&&
operator|(
name|mode
operator|==
name|IEEE80211_MODE_TURBO_A
operator|||
name|mode
operator|==
name|IEEE80211_MODE_TURBO_G
operator|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 		 * Add the list of the channels; any that are not 		 * in the master channel list will be discarded. 		 */
name|add_channels
argument_list|(
name|ic
argument_list|,
name|ss
argument_list|,
name|mode
argument_list|,
name|scan
operator|->
name|list
argument_list|,
name|scan
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
name|ss
operator|->
name|ss_next
operator|=
literal|0
expr_stmt|;
comment|/* XXX tunables */
name|ss
operator|->
name|ss_mindwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
name|ss
operator|->
name|ss_maxdwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_scan
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"scan set "
argument_list|)
expr_stmt|;
name|ieee80211_scan_dump_channels
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dwell min %ld max %ld\n"
argument_list|,
name|ss
operator|->
name|ss_mindwell
argument_list|,
name|ss
operator|->
name|ss_maxdwell
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_DEBUG */
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
undef|#
directive|undef
name|N
block|}
end_function

begin_comment
comment|/*  * Select a channel to start an adhoc network on.  * The channel list was populated with appropriate  * channels so select one that looks least occupied.  * XXX need regulatory domain constraints  */
end_comment

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|adhoc_pick_channel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|,
modifier|*
name|bestchan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bestrssi
decl_stmt|,
name|maxrssi
decl_stmt|;
name|bestchan
operator|=
name|NULL
expr_stmt|;
name|bestrssi
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|ss_last
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ss
operator|->
name|ss_chans
index|[
name|i
index|]
expr_stmt|;
name|maxrssi
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|base
operator|.
name|se_chan
operator|!=
name|c
condition|)
continue|continue;
if|if
condition|(
name|se
operator|->
name|base
operator|.
name|se_rssi
operator|>
name|maxrssi
condition|)
name|maxrssi
operator|=
name|se
operator|->
name|base
operator|.
name|se_rssi
expr_stmt|;
block|}
if|if
condition|(
name|bestchan
operator|==
name|NULL
operator|||
name|maxrssi
operator|<
name|bestrssi
condition|)
name|bestchan
operator|=
name|c
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
name|bestchan
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an ibss network to join or find a channel  * to use to start an ibss network.  */
end_comment

begin_function
specifier|static
name|int
name|adhoc_pick_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|selbs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_AHDEMO
argument_list|,
operator|(
literal|"wrong opmode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_newscan
condition|)
block|{
name|sta_update_notseen
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOPICK
condition|)
block|{
comment|/* 		 * Manual/background scan, don't select+join the 		 * bss, just return.  The scanning framework will 		 * handle notification that this has completed. 		 */
name|ss
operator|->
name|ss_flags
operator|&=
operator|~
name|IEEE80211_SCAN_NOPICK
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Automatic sequencing; look for a candidate and 	 * if found join the network. 	 */
comment|/* NB: unlocked read should be ok */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no scan candidate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|notfound
label|:
if|if
condition|(
name|ic
operator|->
name|ic_des_nssid
condition|)
block|{
comment|/* 			 * No existing adhoc network to join and we have 			 * an ssid; start one up.  If no channel was 			 * specified, try to select a channel. 			 */
if|if
condition|(
name|ic
operator|->
name|ic_des_chan
operator|==
name|IEEE80211_CHAN_ANYC
condition|)
name|chan
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|adhoc_pick_channel
argument_list|(
name|ss
argument_list|)
argument_list|,
name|ic
operator|->
name|ic_flags_ext
argument_list|)
expr_stmt|;
else|else
name|chan
operator|=
name|ic
operator|->
name|ic_des_chan
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_create_ibss
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * If nothing suitable was found decrement 		 * the failure counts so entries will be 		 * reconsidered the next time around.  We 		 * really want to do this only for sta's 		 * where we've previously had some success. 		 */
name|sta_dec_fails
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* restart scan */
block|}
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|selbs
operator|==
name|NULL
operator|||
operator|!
name|ieee80211_sta_join
argument_list|(
name|ic
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
condition|)
goto|goto
name|notfound
goto|;
return|return
literal|1
return|;
comment|/* terminate scan */
block|}
end_function

begin_comment
comment|/*  * Age entries in the scan cache.  */
end_comment

begin_function
specifier|static
name|void
name|adhoc_age
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_notseen
operator|>
name|STA_PURGE_SCANS
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|se
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|adhoc_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|sta_attach
block|,
operator|.
name|scan_detach
operator|=
name|sta_detach
block|,
operator|.
name|scan_start
operator|=
name|adhoc_start
block|,
operator|.
name|scan_restart
operator|=
name|sta_restart
block|,
operator|.
name|scan_cancel
operator|=
name|sta_cancel
block|,
operator|.
name|scan_end
operator|=
name|adhoc_pick_bss
block|,
operator|.
name|scan_flush
operator|=
name|sta_flush
block|,
operator|.
name|scan_add
operator|=
name|sta_add
block|,
operator|.
name|scan_age
operator|=
name|adhoc_age
block|,
operator|.
name|scan_iterate
operator|=
name|sta_iterate
block|,
operator|.
name|scan_assoc_fail
operator|=
name|sta_assoc_fail
block|,
operator|.
name|scan_assoc_success
operator|=
name|sta_assoc_success
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_function
specifier|static
name|int
name|wlan_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|ieee80211_scanner_register
argument_list|(
name|IEEE80211_M_STA
argument_list|,
operator|&
name|sta_default
argument_list|)
expr_stmt|;
name|ieee80211_scanner_register
argument_list|(
name|IEEE80211_M_IBSS
argument_list|,
operator|&
name|adhoc_default
argument_list|)
expr_stmt|;
name|ieee80211_scanner_register
argument_list|(
name|IEEE80211_M_AHDEMO
argument_list|,
operator|&
name|adhoc_default
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_QUIESCE
case|:
if|if
condition|(
name|nrefs
condition|)
block|{
name|printf
argument_list|(
literal|"wlan_scan_sta: still in use (%u dynamic refs)\n"
argument_list|,
name|nrefs
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|type
operator|==
name|MOD_UNLOAD
condition|)
block|{
name|ieee80211_scanner_unregister_all
argument_list|(
operator|&
name|sta_default
argument_list|)
expr_stmt|;
name|ieee80211_scanner_unregister_all
argument_list|(
operator|&
name|adhoc_default
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|wlan_mod
init|=
block|{
literal|"wlan_scan_sta"
block|,
name|wlan_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|wlan_scan_sta
argument_list|,
name|wlan_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wlan_scan_sta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wlan_scan_sta
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

