begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 station scanning support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_regdomain.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_tdma.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
end_ifdef

begin_include
include|#
directive|include
file|<net80211/ieee80211_mesh.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_comment
comment|/*  * Parameters for managing cache entries:  *  * o a station with STA_FAILS_MAX failures is not considered  *   when picking a candidate  * o a station that hasn't had an update in STA_PURGE_SCANS  *   (background) scans is discarded  * o after STA_FAILS_AGE seconds we clear the failure count  */
end_comment

begin_define
define|#
directive|define
name|STA_FAILS_MAX
value|2
end_define

begin_comment
comment|/* assoc failures before ignored */
end_comment

begin_define
define|#
directive|define
name|STA_FAILS_AGE
value|(2*60)
end_define

begin_comment
comment|/* time before clearing fails (secs) */
end_comment

begin_define
define|#
directive|define
name|STA_PURGE_SCANS
value|2
end_define

begin_comment
comment|/* age for purging entries (scans) */
end_comment

begin_comment
comment|/* XXX tunable */
end_comment

begin_define
define|#
directive|define
name|STA_RSSI_MIN
value|8
end_define

begin_comment
comment|/* min acceptable rssi */
end_comment

begin_define
define|#
directive|define
name|STA_RSSI_MAX
value|40
end_define

begin_comment
comment|/* max rssi for comparison */
end_comment

begin_struct
struct|struct
name|sta_entry
block|{
name|struct
name|ieee80211_scan_entry
name|base
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|sta_entry
argument_list|)
name|se_list
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|sta_entry
argument_list|)
name|se_hash
expr_stmt|;
name|uint8_t
name|se_fails
decl_stmt|;
comment|/* failure to associate count */
name|uint8_t
name|se_seen
decl_stmt|;
comment|/* seen during current scan */
name|uint8_t
name|se_notseen
decl_stmt|;
comment|/* not seen in previous scans */
name|uint8_t
name|se_flags
decl_stmt|;
define|#
directive|define
name|STA_DEMOTE11B
value|0x01
comment|/* match w/ demoted 11b chan */
name|uint32_t
name|se_avgrssi
decl_stmt|;
comment|/* LPF rssi state */
name|unsigned
name|long
name|se_lastupdate
decl_stmt|;
comment|/* time of last update */
name|unsigned
name|long
name|se_lastfail
decl_stmt|;
comment|/* time of last failure */
name|unsigned
name|long
name|se_lastassoc
decl_stmt|;
comment|/* time of last association */
name|u_int
name|se_scangen
decl_stmt|;
comment|/* iterator scan gen# */
name|u_int
name|se_countrygen
decl_stmt|;
comment|/* gen# of last cc notify */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|STA_HASHSIZE
value|32
end_define

begin_comment
comment|/* simple hash is enough for variation of macaddr */
end_comment

begin_define
define|#
directive|define
name|STA_HASH
parameter_list|(
name|addr
parameter_list|)
define|\
value|(((const uint8_t *)(addr))[IEEE80211_ADDR_LEN - 1] % STA_HASHSIZE)
end_define

begin_define
define|#
directive|define
name|MAX_IEEE_CHAN
value|256
end_define

begin_comment
comment|/* max acceptable IEEE chan # */
end_comment

begin_expr_stmt
name|CTASSERT
argument_list|(
name|MAX_IEEE_CHAN
operator|>=
literal|256
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|sta_table
block|{
name|struct
name|mtx
name|st_lock
decl_stmt|;
comment|/* on scan table */
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|sta_entry
argument_list|)
name|st_entry
expr_stmt|;
comment|/* all entries */
name|LIST_HEAD
argument_list|(
argument_list|,
argument|sta_entry
argument_list|)
name|st_hash
index|[
name|STA_HASHSIZE
index|]
expr_stmt|;
name|struct
name|mtx
name|st_scanlock
decl_stmt|;
comment|/* on st_scaniter */
name|u_int
name|st_scaniter
decl_stmt|;
comment|/* gen# for iterator */
name|u_int
name|st_scangen
decl_stmt|;
comment|/* scan generation # */
name|int
name|st_newscan
decl_stmt|;
comment|/* ap-related state */
name|int
name|st_maxrssi
index|[
name|MAX_IEEE_CHAN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|sta_flush_table
parameter_list|(
name|struct
name|sta_table
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * match_bss returns a bitmask describing if an entry is suitable  * for use.  If non-zero the entry was deemed not suitable and it's  * contents explains why.  The following flags are or'd to to this  * mask and can be used to figure out why the entry was rejected.  */
end_comment

begin_define
define|#
directive|define
name|MATCH_CHANNEL
value|0x00001
end_define

begin_comment
comment|/* channel mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_CAPINFO
value|0x00002
end_define

begin_comment
comment|/* capabilities mismatch, e.g. no ess */
end_comment

begin_define
define|#
directive|define
name|MATCH_PRIVACY
value|0x00004
end_define

begin_comment
comment|/* privacy mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_RATE
value|0x00008
end_define

begin_comment
comment|/* rate set mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_SSID
value|0x00010
end_define

begin_comment
comment|/* ssid mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_BSSID
value|0x00020
end_define

begin_comment
comment|/* bssid mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_FAILS
value|0x00040
end_define

begin_comment
comment|/* too many failed auth attempts */
end_comment

begin_define
define|#
directive|define
name|MATCH_NOTSEEN
value|0x00080
end_define

begin_comment
comment|/* not seen in recent scans */
end_comment

begin_define
define|#
directive|define
name|MATCH_RSSI
value|0x00100
end_define

begin_comment
comment|/* rssi deemed too low to use */
end_comment

begin_define
define|#
directive|define
name|MATCH_CC
value|0x00200
end_define

begin_comment
comment|/* country code mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_TDMA_NOIE
value|0x00400
end_define

begin_comment
comment|/* no TDMA ie */
end_comment

begin_define
define|#
directive|define
name|MATCH_TDMA_NOTMASTER
value|0x00800
end_define

begin_comment
comment|/* not TDMA master */
end_comment

begin_define
define|#
directive|define
name|MATCH_TDMA_NOSLOT
value|0x01000
end_define

begin_comment
comment|/* all TDMA slots occupied */
end_comment

begin_define
define|#
directive|define
name|MATCH_TDMA_LOCAL
value|0x02000
end_define

begin_comment
comment|/* local address */
end_comment

begin_define
define|#
directive|define
name|MATCH_TDMA_VERSION
value|0x04000
end_define

begin_comment
comment|/* protocol version mismatch */
end_comment

begin_define
define|#
directive|define
name|MATCH_MESH_NOID
value|0x10000
end_define

begin_comment
comment|/* no MESHID ie */
end_comment

begin_define
define|#
directive|define
name|MATCH_MESHID
value|0x20000
end_define

begin_comment
comment|/* meshid mismatch */
end_comment

begin_function_decl
specifier|static
name|int
name|match_bss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|,
name|struct
name|sta_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|adhoc_age
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|__inline
name|int
name|isocmp
parameter_list|(
specifier|const
name|uint8_t
name|cc1
index|[]
parameter_list|,
specifier|const
name|uint8_t
name|cc2
index|[]
parameter_list|)
block|{
return|return
operator|(
name|cc1
index|[
literal|0
index|]
operator|==
name|cc2
index|[
literal|0
index|]
operator|&&
name|cc1
index|[
literal|1
index|]
operator|==
name|cc2
index|[
literal|1
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/* number of references from net80211 layer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrefs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_expr_stmt
name|IEEE80211_SCANNER_MODULE
argument_list|(
name|sta
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Attach prior to any scanning work.  */
end_comment

begin_function
specifier|static
name|int
name|sta_attach
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
decl_stmt|;
name|st
operator|=
operator|(
expr|struct
name|sta_table
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sta_table
argument_list|)
argument_list|,
name|M_80211_SCAN
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|mtx_init
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|,
literal|"scantable"
argument_list|,
literal|"802.11 scan table"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|mtx_init
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|,
literal|"scangen"
argument_list|,
literal|"802.11 scangen"
argument_list|,
name|MTX_DEF
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_priv
operator|=
name|st
expr_stmt|;
name|nrefs
operator|++
expr_stmt|;
comment|/* NB: we assume caller locking */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup any private state.  */
end_comment

begin_function
specifier|static
name|int
name|sta_detach
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
if|if
condition|(
name|st
operator|!=
name|NULL
condition|)
block|{
name|sta_flush_table
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|mtx_destroy
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|st
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nrefs
operator|>
literal|0
argument_list|,
operator|(
literal|"imbalanced attach/detach"
operator|)
argument_list|)
expr_stmt|;
name|nrefs
operator|--
expr_stmt|;
comment|/* NB: we assume caller locking */
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all per-scan state.  */
end_comment

begin_function
specifier|static
name|int
name|sta_flush
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|sta_flush_table
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all entries in the scan cache.  */
end_comment

begin_function
specifier|static
name|void
name|sta_flush_table
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|,
argument|next
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|ieee80211_ies_cleanup
argument_list|(
operator|&
name|se
operator|->
name|base
operator|.
name|se_ies
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|se
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|st
operator|->
name|st_maxrssi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|->
name|st_maxrssi
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a beacon or probe response frame; create an  * entry in the scan cache or update any previous entry.  */
end_comment

begin_function
specifier|static
name|int
name|sta_add
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|noise
parameter_list|)
block|{
define|#
directive|define
name|ISPROBE
parameter_list|(
name|_st
parameter_list|)
value|((_st) == IEEE80211_FC0_SUBTYPE_PROBE_RESP)
define|#
directive|define
name|PICK1ST
parameter_list|(
name|_ss
parameter_list|)
define|\
value|((ss->ss_flags& (IEEE80211_SCAN_PICK1ST | IEEE80211_SCAN_GOTPICK)) == \ 	IEEE80211_SCAN_PICK1ST)
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|macaddr
init|=
name|wh
operator|->
name|i_addr2
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|struct
name|ieee80211_scan_entry
modifier|*
name|ise
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|hash
operator|=
name|STA_HASH
argument_list|(
name|macaddr
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_hash[hash]
argument_list|,
argument|se_hash
argument_list|)
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|se
operator|->
name|base
operator|.
name|se_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
goto|goto
name|found
goto|;
name|se
operator|=
operator|(
expr|struct
name|sta_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sta_entry
argument_list|)
argument_list|,
name|M_80211_SCAN
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
block|{
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|se
operator|->
name|se_scangen
operator|=
name|st
operator|->
name|st_scaniter
operator|-
literal|1
expr_stmt|;
name|se
operator|->
name|se_avgrssi
operator|=
name|IEEE80211_RSSI_DUMMY_MARKER
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|se
operator|->
name|base
operator|.
name|se_macaddr
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|st
operator|->
name|st_hash
index|[
name|hash
index|]
argument_list|,
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|found
label|:
name|ise
operator|=
operator|&
name|se
operator|->
name|base
expr_stmt|;
comment|/* XXX ap beaconing multiple ssid w/ same bssid */
if|if
condition|(
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
operator|!=
literal|0
operator|&&
operator|(
name|ISPROBE
argument_list|(
name|subtype
argument_list|)
operator|||
name|ise
operator|->
name|se_ssid
index|[
literal|1
index|]
operator|==
literal|0
operator|)
condition|)
name|memcpy
argument_list|(
name|ise
operator|->
name|se_ssid
argument_list|,
name|sp
operator|->
name|ssid
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|sp
operator|->
name|rates
index|[
literal|1
index|]
operator|<=
name|IEEE80211_RATE_MAXSIZE
argument_list|,
operator|(
literal|"rate set too large: %u"
operator|,
name|sp
operator|->
name|rates
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ise
operator|->
name|se_rates
argument_list|,
name|sp
operator|->
name|rates
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|rates
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|xrates
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX validate xrates[1] */
name|KASSERT
argument_list|(
name|sp
operator|->
name|xrates
index|[
literal|1
index|]
operator|<=
name|IEEE80211_RATE_MAXSIZE
argument_list|,
operator|(
literal|"xrate set too large: %u"
operator|,
name|sp
operator|->
name|xrates
index|[
literal|1
index|]
operator|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ise
operator|->
name|se_xrates
argument_list|,
name|sp
operator|->
name|xrates
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|xrates
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|ise
operator|->
name|se_xrates
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|ise
operator|->
name|se_bssid
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|status
operator|&
name|IEEE80211_BPARSE_OFFCHAN
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Record rssi data using extended precision LPF filter. 		 * 		 * NB: use only on-channel data to insure we get a good 		 *     estimate of the signal we'll see when associated. 		 */
name|IEEE80211_RSSI_LPF
argument_list|(
name|se
operator|->
name|se_avgrssi
argument_list|,
name|rssi
argument_list|)
expr_stmt|;
name|ise
operator|->
name|se_rssi
operator|=
name|IEEE80211_RSSI_GET
argument_list|(
name|se
operator|->
name|se_avgrssi
argument_list|)
expr_stmt|;
name|ise
operator|->
name|se_noise
operator|=
name|noise
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|ise
operator|->
name|se_tstamp
operator|.
name|data
argument_list|,
name|sp
operator|->
name|tstamp
argument_list|,
sizeof|sizeof
argument_list|(
name|ise
operator|->
name|se_tstamp
argument_list|)
argument_list|)
expr_stmt|;
name|ise
operator|->
name|se_intval
operator|=
name|sp
operator|->
name|bintval
expr_stmt|;
name|ise
operator|->
name|se_capinfo
operator|=
name|sp
operator|->
name|capinfo
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
if|if
condition|(
name|sp
operator|->
name|meshid
operator|!=
name|NULL
operator|&&
name|sp
operator|->
name|meshid
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|memcpy
argument_list|(
name|ise
operator|->
name|se_meshid
argument_list|,
name|sp
operator|->
name|meshid
argument_list|,
literal|2
operator|+
name|sp
operator|->
name|meshid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Beware of overriding se_chan for frames seen 	 * off-channel; this can cause us to attempt an 	 * association on the wrong channel. 	 */
if|if
condition|(
name|sp
operator|->
name|status
operator|&
name|IEEE80211_BPARSE_OFFCHAN
condition|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
comment|/* 		 * Off-channel, locate the home/bss channel for the sta 		 * using the value broadcast in the DSPARMS ie.  We know 		 * sp->chan has this value because it's used to calculate 		 * IEEE80211_BPARSE_OFFCHAN. 		 */
name|c
operator|=
name|ieee80211_find_channel_byieee
argument_list|(
name|ic
argument_list|,
name|sp
operator|->
name|chan
argument_list|,
name|ic
operator|->
name|ic_curchan
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
block|{
name|ise
operator|->
name|se_chan
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ise
operator|->
name|se_chan
operator|==
name|NULL
condition|)
block|{
comment|/* should not happen, pick something */
name|ise
operator|->
name|se_chan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
block|}
block|}
else|else
name|ise
operator|->
name|se_chan
operator|=
name|ic
operator|->
name|ic_curchan
expr_stmt|;
name|ise
operator|->
name|se_fhdwell
operator|=
name|sp
operator|->
name|fhdwell
expr_stmt|;
name|ise
operator|->
name|se_fhindex
operator|=
name|sp
operator|->
name|fhindex
expr_stmt|;
name|ise
operator|->
name|se_erp
operator|=
name|sp
operator|->
name|erp
expr_stmt|;
name|ise
operator|->
name|se_timoff
operator|=
name|sp
operator|->
name|timoff
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|tim
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|ieee80211_tim_ie
modifier|*
name|tim
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_tim_ie
operator|*
operator|)
name|sp
operator|->
name|tim
decl_stmt|;
name|ise
operator|->
name|se_dtimperiod
operator|=
name|tim
operator|->
name|tim_period
expr_stmt|;
block|}
if|if
condition|(
name|sp
operator|->
name|country
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|struct
name|ieee80211_country_ie
modifier|*
name|cie
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_country_ie
operator|*
operator|)
name|sp
operator|->
name|country
decl_stmt|;
comment|/* 		 * If 11d is enabled and we're attempting to join a bss 		 * that advertises it's country code then compare our 		 * current settings to what we fetched from the country ie. 		 * If our country code is unspecified or different then 		 * dispatch an event to user space that identifies the 		 * country code so our regdomain config can be changed. 		 */
comment|/* XXX only for STA mode? */
if|if
condition|(
operator|(
name|IEEE80211_IS_CHAN_11D
argument_list|(
name|ise
operator|->
name|se_chan
argument_list|)
operator|||
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DOTD
operator|)
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|==
name|CTRY_DEFAULT
operator|||
operator|!
name|isocmp
argument_list|(
name|cie
operator|->
name|cc
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
argument_list|)
operator|)
condition|)
block|{
comment|/* only issue one notify event per scan */
if|if
condition|(
name|se
operator|->
name|se_countrygen
operator|!=
name|st
operator|->
name|st_scangen
condition|)
block|{
name|ieee80211_notify_country
argument_list|(
name|vap
argument_list|,
name|ise
operator|->
name|se_bssid
argument_list|,
name|cie
operator|->
name|cc
argument_list|)
expr_stmt|;
name|se
operator|->
name|se_countrygen
operator|=
name|st
operator|->
name|st_scangen
expr_stmt|;
block|}
block|}
name|ise
operator|->
name|se_cc
index|[
literal|0
index|]
operator|=
name|cie
operator|->
name|cc
index|[
literal|0
index|]
expr_stmt|;
name|ise
operator|->
name|se_cc
index|[
literal|1
index|]
operator|=
name|cie
operator|->
name|cc
index|[
literal|1
index|]
expr_stmt|;
block|}
comment|/* NB: no need to setup ie ptrs; they are not (currently) used */
operator|(
name|void
operator|)
name|ieee80211_ies_init
argument_list|(
operator|&
name|ise
operator|->
name|se_ies
argument_list|,
name|sp
operator|->
name|ies
argument_list|,
name|sp
operator|->
name|ies_len
argument_list|)
expr_stmt|;
comment|/* clear failure count after STA_FAIL_AGE passes */
if|if
condition|(
name|se
operator|->
name|se_fails
operator|&&
operator|(
name|ticks
operator|-
name|se
operator|->
name|se_lastfail
operator|)
operator|>
name|STA_FAILS_AGE
operator|*
name|hz
condition|)
block|{
name|se
operator|->
name|se_fails
operator|=
literal|0
expr_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
name|macaddr
argument_list|,
literal|"%s: fails %u"
argument_list|,
name|__func__
argument_list|,
name|se
operator|->
name|se_fails
argument_list|)
expr_stmt|;
block|}
name|se
operator|->
name|se_lastupdate
operator|=
name|ticks
expr_stmt|;
comment|/* update time */
name|se
operator|->
name|se_seen
operator|=
literal|1
expr_stmt|;
name|se
operator|->
name|se_notseen
operator|=
literal|0
expr_stmt|;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|sp
operator|->
name|bchan
argument_list|)
operator|==
literal|1
argument_list|,
operator|(
literal|"bchan size"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rssi
operator|>
name|st
operator|->
name|st_maxrssi
index|[
name|sp
operator|->
name|bchan
index|]
condition|)
name|st
operator|->
name|st_maxrssi
index|[
name|sp
operator|->
name|bchan
index|]
operator|=
name|rssi
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If looking for a quick choice and nothing's 	 * been found check here. 	 */
if|if
condition|(
name|PICK1ST
argument_list|(
name|ss
argument_list|)
operator|&&
name|match_bss
argument_list|(
name|vap
argument_list|,
name|ss
argument_list|,
name|se
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_flags
operator||=
name|IEEE80211_SCAN_GOTPICK
expr_stmt|;
return|return
literal|1
return|;
undef|#
directive|undef
name|PICK1ST
undef|#
directive|undef
name|ISPROBE
block|}
end_function

begin_comment
comment|/*  * Check if a channel is excluded by user request.  */
end_comment

begin_function
specifier|static
name|int
name|isexcluded
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|(
name|isclr
argument_list|(
name|vap
operator|->
name|iv_ic
operator|->
name|ic_chan_active
argument_list|,
name|c
operator|->
name|ic_ieee
argument_list|)
operator|||
operator|(
name|vap
operator|->
name|iv_des_chan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
name|c
operator|->
name|ic_freq
operator|!=
name|vap
operator|->
name|iv_des_chan
operator|->
name|ic_freq
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|find11gchannel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* 	 * The normal ordering in the channel list is b channel 	 * immediately followed by g so optimize the search for 	 * this.  We'll still do a full search just in case. 	 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|IEEE80211_IS_CHAN_G
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|IEEE80211_IS_CHAN_G
argument_list|(
name|c
argument_list|)
condition|)
return|return
name|c
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|chanflags
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
index|[
name|IEEE80211_MODE_AUTO
index|]
operator|=
name|IEEE80211_CHAN_B
block|,
index|[
name|IEEE80211_MODE_11A
index|]
operator|=
name|IEEE80211_CHAN_A
block|,
index|[
name|IEEE80211_MODE_11B
index|]
operator|=
name|IEEE80211_CHAN_B
block|,
index|[
name|IEEE80211_MODE_11G
index|]
operator|=
name|IEEE80211_CHAN_G
block|,
index|[
name|IEEE80211_MODE_FH
index|]
operator|=
name|IEEE80211_CHAN_FHSS
block|,
comment|/* check base channel */
index|[
name|IEEE80211_MODE_TURBO_A
index|]
operator|=
name|IEEE80211_CHAN_A
block|,
index|[
name|IEEE80211_MODE_TURBO_G
index|]
operator|=
name|IEEE80211_CHAN_G
block|,
index|[
name|IEEE80211_MODE_STURBO_A
index|]
operator|=
name|IEEE80211_CHAN_ST
block|,
index|[
name|IEEE80211_MODE_HALF
index|]
operator|=
name|IEEE80211_CHAN_HALF
block|,
index|[
name|IEEE80211_MODE_QUARTER
index|]
operator|=
name|IEEE80211_CHAN_QUARTER
block|,
comment|/* check legacy */
index|[
name|IEEE80211_MODE_11NA
index|]
operator|=
name|IEEE80211_CHAN_A
block|,
index|[
name|IEEE80211_MODE_11NG
index|]
operator|=
name|IEEE80211_CHAN_G
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|add_channels
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
specifier|const
name|uint16_t
name|freq
index|[]
parameter_list|,
name|int
name|nfreq
parameter_list|)
block|{
define|#
directive|define
name|N
parameter_list|(
name|a
parameter_list|)
value|(sizeof(a) / sizeof(a[0]))
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|,
modifier|*
name|cg
decl_stmt|;
name|u_int
name|modeflags
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|mode
operator|<
name|N
argument_list|(
name|chanflags
argument_list|)
argument_list|,
operator|(
literal|"Unexpected mode %u"
operator|,
name|mode
operator|)
argument_list|)
expr_stmt|;
name|modeflags
operator|=
name|chanflags
index|[
name|mode
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfreq
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_last
operator|>=
name|IEEE80211_SCAN_MAX
condition|)
break|break;
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|freq
index|[
name|i
index|]
argument_list|,
name|modeflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|||
name|isexcluded
argument_list|(
name|vap
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_AUTO
condition|)
block|{
comment|/* 			 * XXX special-case 11b/g channels so we select 			 *     the g channel if both are present. 			 */
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|cg
operator|=
name|find11gchannel
argument_list|(
name|ic
argument_list|,
name|i
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|c
operator|=
name|cg
expr_stmt|;
block|}
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
undef|#
directive|undef
name|N
block|}
end_function

begin_struct
struct|struct
name|scanlist
block|{
name|uint16_t
name|mode
decl_stmt|;
name|uint16_t
name|count
decl_stmt|;
specifier|const
name|uint16_t
modifier|*
name|list
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|checktable
parameter_list|(
specifier|const
name|struct
name|scanlist
modifier|*
name|scan
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
init|;
name|scan
operator|->
name|list
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|scan
operator|->
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|scan
operator|->
name|list
index|[
name|i
index|]
operator|==
name|c
operator|->
name|ic_freq
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|onscanlist
parameter_list|(
specifier|const
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|ss_last
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ss
operator|->
name|ss_chans
index|[
name|i
index|]
operator|==
name|c
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sweepchannels
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|scanlist
name|table
index|[]
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_last
operator|>=
name|IEEE80211_SCAN_MAX
condition|)
break|break;
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
comment|/* 		 * Ignore dynamic turbo channels; we scan them 		 * in normal mode (i.e. not boosted).  Likewise 		 * for HT channels, they get scanned using 		 * legacy rates. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_DTURBO
argument_list|(
name|c
argument_list|)
operator|||
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* 		 * If a desired mode was specified, scan only  		 * channels that satisfy that constraint. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
operator|&&
name|vap
operator|->
name|iv_des_mode
operator|!=
name|ieee80211_chan2mode
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Skip channels excluded by user request. 		 */
if|if
condition|(
name|isexcluded
argument_list|(
name|vap
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
comment|/* 		 * Add the channel unless it is listed in the 		 * fixed scan order tables.  This insures we 		 * don't sweep back in channels we filtered out 		 * above. 		 */
if|if
condition|(
name|checktable
argument_list|(
name|table
argument_list|,
name|c
argument_list|)
condition|)
continue|continue;
comment|/* Add channel to scanning list. */
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
comment|/* 	 * Explicitly add any desired channel if: 	 * - not already on the scan list 	 * - allowed by any desired mode constraint 	 * - there is space in the scan list 	 * This allows the channel to be used when the filtering 	 * mechanisms would otherwise elide it (e.g HT, turbo). 	 */
name|c
operator|=
name|vap
operator|->
name|iv_des_chan
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
operator|!
name|onscanlist
argument_list|(
name|ss
argument_list|,
name|c
argument_list|)
operator|&&
operator|(
name|vap
operator|->
name|iv_des_mode
operator|==
name|IEEE80211_MODE_AUTO
operator|||
name|vap
operator|->
name|iv_des_mode
operator|==
name|ieee80211_chan2mode
argument_list|(
name|c
argument_list|)
operator|)
operator|&&
name|ss
operator|->
name|ss_last
operator|<
name|IEEE80211_SCAN_MAX
condition|)
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|makescanlist
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|scanlist
name|table
index|[]
parameter_list|)
block|{
specifier|const
name|struct
name|scanlist
modifier|*
name|scan
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use the table of ordered channels to construct the list 	 * of channels for scanning.  Any channels in the ordered 	 * list not in the master list will be discarded. 	 */
for|for
control|(
name|scan
operator|=
name|table
init|;
name|scan
operator|->
name|list
operator|!=
name|NULL
condition|;
name|scan
operator|++
control|)
block|{
name|mode
operator|=
name|scan
operator|->
name|mode
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
condition|)
block|{
comment|/* 			 * If a desired mode was specified, scan only  			 * channels that satisfy that constraint. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_des_mode
operator|!=
name|mode
condition|)
block|{
comment|/* 				 * The scan table marks 2.4Ghz channels as b 				 * so if the desired mode is 11g, then use 				 * the 11b channel list but upgrade the mode. 				 */
if|if
condition|(
name|vap
operator|->
name|iv_des_mode
operator|!=
name|IEEE80211_MODE_11G
operator|||
name|mode
operator|!=
name|IEEE80211_MODE_11B
condition|)
continue|continue;
name|mode
operator|=
name|IEEE80211_MODE_11G
expr_stmt|;
comment|/* upgrade */
block|}
block|}
else|else
block|{
comment|/* 			 * This lets add_channels upgrade an 11b channel 			 * to 11g if available. 			 */
if|if
condition|(
name|mode
operator|==
name|IEEE80211_MODE_11B
condition|)
name|mode
operator|=
name|IEEE80211_MODE_AUTO
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|IEEE80211_F_XR
comment|/* XR does not operate on turbo channels */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_XR
operator|)
operator|&&
operator|(
name|mode
operator|==
name|IEEE80211_MODE_TURBO_A
operator|||
name|mode
operator|==
name|IEEE80211_MODE_TURBO_G
operator|||
name|mode
operator|==
name|IEEE80211_MODE_STURBO_A
operator|)
condition|)
continue|continue;
endif|#
directive|endif
comment|/* 		 * Add the list of the channels; any that are not 		 * in the master channel list will be discarded. 		 */
name|add_channels
argument_list|(
name|vap
argument_list|,
name|ss
argument_list|,
name|mode
argument_list|,
name|scan
operator|->
name|list
argument_list|,
name|scan
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the channels from the ic that are not present 	 * in the table. 	 */
name|sweepchannels
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|table
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl1
index|[]
init|=
comment|/* 8 FCC channel: 52, 56, 60, 64, 36, 40, 44, 48 */
block|{
literal|5260
block|,
literal|5280
block|,
literal|5300
block|,
literal|5320
block|,
literal|5180
block|,
literal|5200
block|,
literal|5220
block|,
literal|5240
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl2
index|[]
init|=
comment|/* 4 MKK channels: 34, 38, 42, 46 */
block|{
literal|5170
block|,
literal|5190
block|,
literal|5210
block|,
literal|5230
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl3
index|[]
init|=
comment|/* 2.4Ghz ch: 1,6,11,7,13 */
block|{
literal|2412
block|,
literal|2437
block|,
literal|2462
block|,
literal|2442
block|,
literal|2472
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl4
index|[]
init|=
comment|/* 5 FCC channel: 149, 153, 161, 165 */
block|{
literal|5745
block|,
literal|5765
block|,
literal|5785
block|,
literal|5805
block|,
literal|5825
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl7
index|[]
init|=
comment|/* 11 ETSI channel: 100,104,108,112,116,120,124,128,132,136,140 */
block|{
literal|5500
block|,
literal|5520
block|,
literal|5540
block|,
literal|5560
block|,
literal|5580
block|,
literal|5600
block|,
literal|5620
block|,
literal|5640
block|,
literal|5660
block|,
literal|5680
block|,
literal|5700
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl8
index|[]
init|=
comment|/* 2.4Ghz ch: 2,3,4,5,8,9,10,12 */
block|{
literal|2417
block|,
literal|2422
block|,
literal|2427
block|,
literal|2432
block|,
literal|2447
block|,
literal|2452
block|,
literal|2457
block|,
literal|2467
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl9
index|[]
init|=
comment|/* 2.4Ghz ch: 14 */
block|{
literal|2484
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl10
index|[]
init|=
comment|/* Added Korean channels 2312-2372 */
block|{
literal|2312
block|,
literal|2317
block|,
literal|2322
block|,
literal|2327
block|,
literal|2332
block|,
literal|2337
block|,
literal|2342
block|,
literal|2347
block|,
literal|2352
block|,
literal|2357
block|,
literal|2362
block|,
literal|2367
block|,
literal|2372
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl11
index|[]
init|=
comment|/* Added Japan channels in 4.9/5.0 spectrum */
block|{
literal|5040
block|,
literal|5060
block|,
literal|5080
block|,
literal|4920
block|,
literal|4940
block|,
literal|4960
block|,
literal|4980
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ATH_TURBO_SCAN
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl5
index|[]
init|=
comment|/* 3 static turbo channels */
block|{
literal|5210
block|,
literal|5250
block|,
literal|5290
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl6
index|[]
init|=
comment|/* 2 static turbo channels */
block|{
literal|5760
block|,
literal|5800
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl6x
index|[]
init|=
comment|/* 4 FCC3 turbo channels */
block|{
literal|5540
block|,
literal|5580
block|,
literal|5620
block|,
literal|5660
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl12
index|[]
init|=
comment|/* 2.4Ghz Turbo channel 6 */
block|{
literal|2437
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|rcl13
index|[]
init|=
comment|/* dynamic Turbo channels */
block|{
literal|5200
block|,
literal|5240
block|,
literal|5280
block|,
literal|5765
block|,
literal|5805
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ATH_TURBO_SCAN */
end_comment

begin_define
define|#
directive|define
name|X
parameter_list|(
name|a
parameter_list|)
value|.count = sizeof(a)/sizeof(a[0]), .list = a
end_define

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|scanlist
name|staScanTable
index|[]
init|=
block|{
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl3
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl1
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl2
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl8
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl9
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl4
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|ATH_TURBO_SCAN
block|{
name|IEEE80211_MODE_STURBO_A
block|,
name|X
argument_list|(
argument|rcl5
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_STURBO_A
block|,
name|X
argument_list|(
argument|rcl6
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_TURBO_A
block|,
name|X
argument_list|(
argument|rcl6x
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_TURBO_A
block|,
name|X
argument_list|(
argument|rcl13
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* ATH_TURBO_SCAN */
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl7
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|rcl10
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|rcl11
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|ATH_TURBO_SCAN
block|{
name|IEEE80211_MODE_TURBO_G
block|,
name|X
argument_list|(
argument|rcl12
argument_list|)
block|}
block|,
endif|#
directive|endif
comment|/* ATH_TURBO_SCAN */
block|{
operator|.
name|list
operator|=
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Start a station-mode scan by populating the channel list.  */
end_comment

begin_function
specifier|static
name|int
name|sta_start
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|makescanlist
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|staScanTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_mindwell
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_mindwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/* 20ms */
if|if
condition|(
name|ss
operator|->
name|ss_maxdwell
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_maxdwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
name|st
operator|->
name|st_scangen
operator|++
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Restart a scan, typically a bg scan but can  * also be a fg scan that came up empty.  */
end_comment

begin_function
specifier|static
name|int
name|sta_restart
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Cancel an ongoing scan.  */
end_comment

begin_function
specifier|static
name|int
name|sta_cancel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* unalligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((uint16_t)					\ 	 ((((const uint8_t *)(p))[0]      ) |		\ 	  (((const uint8_t *)(p))[1]<<  8)))
end_define

begin_comment
comment|/*  * Demote any supplied 11g channel to 11b.  There should  * always be an 11b channel but we check anyway...  */
end_comment

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|demote11b
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|chan
argument_list|)
operator|&&
name|vap
operator|->
name|iv_des_mode
operator|==
name|IEEE80211_MODE_AUTO
condition|)
block|{
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
operator|(
name|chan
operator|->
name|ic_flags
operator|&
operator|~
operator|(
name|IEEE80211_CHAN_PUREG
operator||
name|IEEE80211_CHAN_G
operator|)
operator|)
operator||
name|IEEE80211_CHAN_B
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
return|return
name|chan
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|maxrate
parameter_list|(
specifier|const
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ie_htcap
modifier|*
name|htcap
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htcap
operator|*
operator|)
name|se
operator|->
name|se_ies
operator|.
name|htcap_ie
decl_stmt|;
name|int
name|rmax
decl_stmt|,
name|r
decl_stmt|,
name|i
decl_stmt|;
name|uint16_t
name|caps
decl_stmt|;
name|rmax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|htcap
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * HT station; inspect supported MCS and then adjust 		 * rate by channel width.  Could also include short GI 		 * in this if we want to be extra accurate. 		 */
comment|/* XXX assumes MCS15 is max */
for|for
control|(
name|i
operator|=
literal|15
init|;
name|i
operator|>=
literal|0
operator|&&
name|isclr
argument_list|(
name|htcap
operator|->
name|hc_mcsset
argument_list|,
name|i
argument_list|)
condition|;
name|i
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|caps
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|htcap
operator|->
name|hc_cap
argument_list|)
expr_stmt|;
comment|/* XXX short/long GI */
if|if
condition|(
name|caps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
condition|)
name|rmax
operator|=
name|ieee80211_htrates
index|[
name|i
index|]
operator|.
name|ht40_rate_400ns
expr_stmt|;
else|else
name|rmax
operator|=
name|ieee80211_htrates
index|[
name|i
index|]
operator|.
name|ht40_rate_800ns
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|se
operator|->
name|se_rates
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|se
operator|->
name|se_rates
index|[
literal|2
operator|+
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|rmax
condition|)
name|rmax
operator|=
name|r
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|se
operator|->
name|se_xrates
index|[
literal|1
index|]
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|se
operator|->
name|se_xrates
index|[
literal|2
operator|+
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
expr_stmt|;
if|if
condition|(
name|r
operator|>
name|rmax
condition|)
name|rmax
operator|=
name|r
expr_stmt|;
block|}
return|return
name|rmax
return|;
block|}
end_function

begin_comment
comment|/*  * Compare the capabilities of two entries and decide which is  * more desirable (return>0 if a is considered better).  Note  * that we assume compatibility/usability has already been checked  * so we don't need to (e.g. validate whether privacy is supported).  * Used to select the best scan candidate for association in a BSS.  */
end_comment

begin_function
specifier|static
name|int
name|sta_compare
parameter_list|(
specifier|const
name|struct
name|sta_entry
modifier|*
name|a
parameter_list|,
specifier|const
name|struct
name|sta_entry
modifier|*
name|b
parameter_list|)
block|{
define|#
directive|define
name|PREFER
parameter_list|(
name|_a
parameter_list|,
name|_b
parameter_list|,
name|_what
parameter_list|)
value|do {			\ 	if (((_a) ^ (_b))& (_what))			\ 		return ((_a)& (_what)) ? 1 : -1;	\ } while (0)
name|int
name|maxa
decl_stmt|,
name|maxb
decl_stmt|;
name|int8_t
name|rssia
decl_stmt|,
name|rssib
decl_stmt|;
name|int
name|weight
decl_stmt|;
comment|/* privacy support */
name|PREFER
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_capinfo
argument_list|,
name|b
operator|->
name|base
operator|.
name|se_capinfo
argument_list|,
name|IEEE80211_CAPINFO_PRIVACY
argument_list|)
expr_stmt|;
comment|/* compare count of previous failures */
name|weight
operator|=
name|b
operator|->
name|se_fails
operator|-
name|a
operator|->
name|se_fails
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|weight
argument_list|)
operator|>
literal|1
condition|)
return|return
name|weight
return|;
comment|/* 	 * Compare rssi.  If the two are considered equivalent 	 * then fallback to other criteria.  We threshold the 	 * comparisons to avoid selecting an ap purely by rssi 	 * when both values may be good but one ap is otherwise 	 * more desirable (e.g. an 11b-only ap with stronger 	 * signal than an 11g ap). 	 */
name|rssia
operator|=
name|MIN
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_rssi
argument_list|,
name|STA_RSSI_MAX
argument_list|)
expr_stmt|;
name|rssib
operator|=
name|MIN
argument_list|(
name|b
operator|->
name|base
operator|.
name|se_rssi
argument_list|,
name|STA_RSSI_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
name|rssib
operator|-
name|rssia
argument_list|)
operator|<
literal|5
condition|)
block|{
comment|/* best/max rate preferred if signal level close enough XXX */
name|maxa
operator|=
name|maxrate
argument_list|(
operator|&
name|a
operator|->
name|base
argument_list|)
expr_stmt|;
name|maxb
operator|=
name|maxrate
argument_list|(
operator|&
name|b
operator|->
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxa
operator|!=
name|maxb
condition|)
return|return
name|maxa
operator|-
name|maxb
return|;
comment|/* XXX use freq for channel preference */
comment|/* for now just prefer 5Ghz band to all other bands */
name|PREFER
argument_list|(
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|a
operator|->
name|base
operator|.
name|se_chan
argument_list|)
argument_list|,
name|IEEE80211_IS_CHAN_5GHZ
argument_list|(
name|b
operator|->
name|base
operator|.
name|se_chan
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* all things being equal, use signal level */
return|return
name|a
operator|->
name|base
operator|.
name|se_rssi
operator|-
name|b
operator|->
name|base
operator|.
name|se_rssi
return|;
undef|#
directive|undef
name|PREFER
block|}
end_function

begin_comment
comment|/*  * Check rate set suitability and return the best supported rate.  * XXX inspect MCS for HT  */
end_comment

begin_function
specifier|static
name|int
name|check_rate
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
parameter_list|)
block|{
define|#
directive|define
name|RV
parameter_list|(
name|v
parameter_list|)
value|((v)& IEEE80211_RATE_VAL)
specifier|const
name|struct
name|ieee80211_rateset
modifier|*
name|srs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nrs
decl_stmt|,
name|r
decl_stmt|,
name|okrate
decl_stmt|,
name|badrate
decl_stmt|,
name|fixedrate
decl_stmt|,
name|ucastrate
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|rs
decl_stmt|;
name|okrate
operator|=
name|badrate
operator|=
literal|0
expr_stmt|;
name|srs
operator|=
name|ieee80211_get_suprates
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|,
name|chan
argument_list|)
expr_stmt|;
name|nrs
operator|=
name|se
operator|->
name|se_rates
index|[
literal|1
index|]
expr_stmt|;
name|rs
operator|=
name|se
operator|->
name|se_rates
operator|+
literal|2
expr_stmt|;
comment|/* XXX MCS */
name|ucastrate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|ieee80211_chan2mode
argument_list|(
name|chan
argument_list|)
index|]
operator|.
name|ucastrate
expr_stmt|;
name|fixedrate
operator|=
name|IEEE80211_FIXED_RATE_NONE
expr_stmt|;
name|again
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrs
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|RV
argument_list|(
name|rs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|badrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check any fixed rate is included.  		 */
if|if
condition|(
name|r
operator|==
name|ucastrate
condition|)
name|fixedrate
operator|=
name|r
expr_stmt|;
comment|/* 		 * Check against our supported rates. 		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|srs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|r
operator|==
name|RV
argument_list|(
name|srs
operator|->
name|rs_rates
index|[
name|j
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|r
operator|>
name|okrate
condition|)
comment|/* NB: track max */
name|okrate
operator|=
name|r
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|j
operator|==
name|srs
operator|->
name|rs_nrates
operator|&&
operator|(
name|rs
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
condition|)
block|{
comment|/* 			 * Don't try joining a BSS, if we don't support 			 * one of its basic rates. 			 */
name|okrate
operator|=
literal|0
expr_stmt|;
goto|goto
name|back
goto|;
block|}
block|}
if|if
condition|(
name|rs
operator|==
name|se
operator|->
name|se_rates
operator|+
literal|2
condition|)
block|{
comment|/* scan xrates too; sort of an algol68-style for loop */
name|nrs
operator|=
name|se
operator|->
name|se_xrates
index|[
literal|1
index|]
expr_stmt|;
name|rs
operator|=
name|se
operator|->
name|se_xrates
operator|+
literal|2
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|back
label|:
if|if
condition|(
name|okrate
operator|==
literal|0
operator|||
name|ucastrate
operator|!=
name|fixedrate
condition|)
return|return
name|badrate
operator||
name|IEEE80211_RATE_BASIC
return|;
else|else
return|return
name|RV
argument_list|(
name|okrate
argument_list|)
return|;
undef|#
directive|undef
name|RV
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|match_id
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|val
parameter_list|,
name|int
name|len
parameter_list|)
block|{
return|return
operator|(
name|ie
index|[
literal|1
index|]
operator|==
name|len
operator|&&
name|memcmp
argument_list|(
name|ie
operator|+
literal|2
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_ssid
parameter_list|(
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|,
name|int
name|nssid
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_ssid
name|ssids
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nssid
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|match_id
argument_list|(
name|ie
argument_list|,
name|ssids
index|[
name|i
index|]
operator|.
name|ssid
argument_list|,
name|ssids
index|[
name|i
index|]
operator|.
name|len
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
end_ifdef

begin_function
specifier|static
name|int
name|tdma_isfull
parameter_list|(
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
parameter_list|)
block|{
name|int
name|slot
decl_stmt|,
name|slotcnt
decl_stmt|;
name|slotcnt
operator|=
name|tdma
operator|->
name|tdma_slotcnt
expr_stmt|;
for|for
control|(
name|slot
operator|=
name|slotcnt
operator|-
literal|1
init|;
name|slot
operator|>=
literal|0
condition|;
name|slot
operator|--
control|)
if|if
condition|(
name|isclr
argument_list|(
name|tdma
operator|->
name|tdma_inuse
argument_list|,
name|slot
argument_list|)
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_TDMA */
end_comment

begin_comment
comment|/*  * Test a scan candidate for suitability/compatibility.  */
end_comment

begin_function
specifier|static
name|int
name|match_bss
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|sta_entry
modifier|*
name|se0
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_scan_entry
modifier|*
name|se
init|=
operator|&
name|se0
operator|->
name|base
decl_stmt|;
name|uint8_t
name|rate
decl_stmt|;
name|int
name|fail
decl_stmt|;
name|fail
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isclr
argument_list|(
name|ic
operator|->
name|ic_chan_active
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|se
operator|->
name|se_chan
argument_list|)
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_CHANNEL
expr_stmt|;
comment|/* 	 * NB: normally the desired mode is used to construct 	 * the channel list, but it's possible for the scan 	 * cache to include entries for stations outside this 	 * list so we check the desired mode here to weed them 	 * out. 	 */
if|if
condition|(
name|vap
operator|->
name|iv_des_mode
operator|!=
name|IEEE80211_MODE_AUTO
operator|&&
operator|(
name|se
operator|->
name|se_chan
operator|->
name|ic_flags
operator|&
name|IEEE80211_CHAN_ALLTURBO
operator|)
operator|!=
name|chanflags
index|[
name|vap
operator|->
name|iv_des_mode
index|]
condition|)
name|fail
operator||=
name|MATCH_CHANNEL
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
condition|)
block|{
if|if
condition|(
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
name|MATCH_CAPINFO
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
condition|)
block|{
comment|/* 		 * Adhoc demo network setup shouldn't really be scanning 		 * but just in case skip stations operating in IBSS or 		 * BSS mode. 		 */
if|if
condition|(
name|se
operator|->
name|se_capinfo
operator|&
operator|(
name|IEEE80211_CAPINFO_IBSS
operator||
name|IEEE80211_CAPINFO_ESS
operator|)
condition|)
name|fail
operator||=
name|MATCH_CAPINFO
expr_stmt|;
comment|/* 		 * TDMA operation cannot coexist with a normal 802.11 network; 		 * skip if IBSS or ESS capabilities are marked and require 		 * the beacon have a TDMA ie present. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
condition|)
block|{
specifier|const
name|struct
name|ieee80211_tdma_param
modifier|*
name|tdma
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_tdma_param
operator|*
operator|)
name|se
operator|->
name|se_ies
operator|.
name|tdma_ie
decl_stmt|;
specifier|const
name|struct
name|ieee80211_tdma_state
modifier|*
name|ts
init|=
name|vap
operator|->
name|iv_tdma
decl_stmt|;
if|if
condition|(
name|tdma
operator|==
name|NULL
condition|)
name|fail
operator||=
name|MATCH_TDMA_NOIE
expr_stmt|;
elseif|else
if|if
condition|(
name|tdma
operator|->
name|tdma_version
operator|!=
name|ts
operator|->
name|tdma_version
condition|)
name|fail
operator||=
name|MATCH_TDMA_VERSION
expr_stmt|;
elseif|else
if|if
condition|(
name|tdma
operator|->
name|tdma_slot
operator|!=
literal|0
condition|)
name|fail
operator||=
name|MATCH_TDMA_NOTMASTER
expr_stmt|;
elseif|else
if|if
condition|(
name|tdma_isfull
argument_list|(
name|tdma
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_TDMA_NOSLOT
expr_stmt|;
if|#
directive|if
literal|0
block|else if (ieee80211_local_address(se->se_macaddr)) 				fail |= MATCH_TDMA_LOCAL;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* IEEE80211_SUPPORT_TDMA */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
block|}
elseif|else
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
condition|)
block|{
specifier|const
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
comment|/* 		 * Mesh nodes have IBSS& ESS bits in capinfo turned off 		 * and two special ie's that must be present. 		 */
if|if
condition|(
name|se
operator|->
name|se_capinfo
operator|&
operator|(
name|IEEE80211_CAPINFO_IBSS
operator||
name|IEEE80211_CAPINFO_ESS
operator|)
condition|)
name|fail
operator||=
name|MATCH_CAPINFO
expr_stmt|;
elseif|else
if|if
condition|(
name|se
operator|->
name|se_meshid
operator|==
name|NULL
condition|)
name|fail
operator||=
name|MATCH_MESH_NOID
expr_stmt|;
elseif|else
if|if
condition|(
name|ms
operator|->
name|ms_idlen
operator|!=
literal|0
operator|&&
name|match_id
argument_list|(
name|se
operator|->
name|se_meshid
argument_list|,
name|ms
operator|->
name|ms_id
argument_list|,
name|ms
operator|->
name|ms_idlen
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_MESHID
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
if|if
condition|(
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
name|MATCH_CAPINFO
expr_stmt|;
comment|/* 		 * If 11d is enabled and we're attempting to join a bss 		 * that advertises it's country code then compare our 		 * current settings to what we fetched from the country ie. 		 * If our country code is unspecified or different then do 		 * not attempt to join the bss.  We should have already 		 * dispatched an event to user space that identifies the 		 * new country code so our regdomain config should match. 		 */
if|if
condition|(
operator|(
name|IEEE80211_IS_CHAN_11D
argument_list|(
name|se
operator|->
name|se_chan
argument_list|)
operator|||
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_DOTD
operator|)
operator|)
operator|&&
name|se
operator|->
name|se_cc
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|(
name|ic
operator|->
name|ic_regdomain
operator|.
name|country
operator|==
name|CTRY_DEFAULT
operator|||
operator|!
name|isocmp
argument_list|(
name|se
operator|->
name|se_cc
argument_list|,
name|ic
operator|->
name|ic_regdomain
operator|.
name|isocc
argument_list|)
operator|)
condition|)
name|fail
operator||=
name|MATCH_CC
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_PRIVACY
condition|)
block|{
if|if
condition|(
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
operator|==
literal|0
condition|)
name|fail
operator||=
name|MATCH_PRIVACY
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX does this mean privacy is supported or required? */
if|if
condition|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
condition|)
name|fail
operator||=
name|MATCH_PRIVACY
expr_stmt|;
block|}
name|se0
operator|->
name|se_flags
operator|&=
operator|~
name|STA_DEMOTE11B
expr_stmt|;
name|rate
operator|=
name|check_rate
argument_list|(
name|vap
argument_list|,
name|se
operator|->
name|se_chan
argument_list|,
name|se
argument_list|)
expr_stmt|;
if|if
condition|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
condition|)
block|{
name|fail
operator||=
name|MATCH_RATE
expr_stmt|;
comment|/* 		 * An 11b-only ap will give a rate mismatch if there is an 		 * OFDM fixed tx rate for 11g.  Try downgrading the channel 		 * in the scan list to 11b and retry the rate check. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|se
operator|->
name|se_chan
argument_list|)
condition|)
block|{
name|rate
operator|=
name|check_rate
argument_list|(
name|vap
argument_list|,
name|demote11b
argument_list|(
name|vap
argument_list|,
name|se
operator|->
name|se_chan
argument_list|)
argument_list|,
name|se
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rate
operator|&
name|IEEE80211_RATE_BASIC
operator|)
operator|==
literal|0
condition|)
block|{
name|fail
operator|&=
operator|~
name|MATCH_RATE
expr_stmt|;
name|se0
operator|->
name|se_flags
operator||=
name|STA_DEMOTE11B
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|rate
operator|<
literal|2
operator|*
literal|24
condition|)
block|{
comment|/* 		 * This is an 11b-only ap.  Check the desired mode in 		 * case that needs to be honored (mode 11g filters out 		 * 11b-only ap's).  Otherwise force any 11g channel used 		 * in scanning to be demoted. 		 * 		 * NB: we cheat a bit here by looking at the max rate; 		 *     we could/should check the rates. 		 */
if|if
condition|(
operator|!
operator|(
name|vap
operator|->
name|iv_des_mode
operator|==
name|IEEE80211_MODE_AUTO
operator|||
name|vap
operator|->
name|iv_des_mode
operator|==
name|IEEE80211_MODE_11B
operator|)
condition|)
name|fail
operator||=
name|MATCH_RATE
expr_stmt|;
else|else
name|se0
operator|->
name|se_flags
operator||=
name|STA_DEMOTE11B
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_nssid
operator|!=
literal|0
operator|&&
operator|!
name|match_ssid
argument_list|(
name|se
operator|->
name|se_ssid
argument_list|,
name|ss
operator|->
name|ss_nssid
argument_list|,
name|ss
operator|->
name|ss_ssid
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_SSID
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags
operator|&
name|IEEE80211_F_DESBSSID
operator|)
operator|&&
operator|!
name|IEEE80211_ADDR_EQ
argument_list|(
name|vap
operator|->
name|iv_des_bssid
argument_list|,
name|se
operator|->
name|se_bssid
argument_list|)
condition|)
name|fail
operator||=
name|MATCH_BSSID
expr_stmt|;
if|if
condition|(
name|se0
operator|->
name|se_fails
operator|>=
name|STA_FAILS_MAX
condition|)
name|fail
operator||=
name|MATCH_FAILS
expr_stmt|;
if|if
condition|(
name|se0
operator|->
name|se_notseen
operator|>=
name|STA_PURGE_SCANS
condition|)
name|fail
operator||=
name|MATCH_NOTSEEN
expr_stmt|;
if|if
condition|(
name|se
operator|->
name|se_rssi
operator|<
name|STA_RSSI_MIN
condition|)
name|fail
operator||=
name|MATCH_RSSI
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg
argument_list|(
name|vap
argument_list|,
name|debug
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|" %c %s"
argument_list|,
name|fail
operator|&
name|MATCH_FAILS
condition|?
literal|'='
else|:
name|fail
operator|&
name|MATCH_NOTSEEN
condition|?
literal|'^'
else|:
name|fail
operator|&
name|MATCH_CC
condition|?
literal|'$'
else|:
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
name|fail
operator|&
name|MATCH_TDMA_NOIE
condition|?
literal|'&'
else|:
name|fail
operator|&
name|MATCH_TDMA_VERSION
condition|?
literal|'v'
else|:
name|fail
operator|&
name|MATCH_TDMA_NOTMASTER
condition|?
literal|'s'
else|:
name|fail
operator|&
name|MATCH_TDMA_NOSLOT
condition|?
literal|'f'
else|:
name|fail
operator|&
name|MATCH_TDMA_LOCAL
condition|?
literal|'l'
else|:
endif|#
directive|endif
name|fail
operator|&
name|MATCH_MESH_NOID
condition|?
literal|'m'
else|:
name|fail
condition|?
literal|'-'
else|:
literal|'+'
argument_list|,
name|ether_sprintf
argument_list|(
name|se
operator|->
name|se_macaddr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %s%c"
argument_list|,
name|ether_sprintf
argument_list|(
name|se
operator|->
name|se_bssid
argument_list|)
argument_list|,
name|fail
operator|&
name|MATCH_BSSID
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3d%c"
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|se
operator|->
name|se_chan
argument_list|)
argument_list|,
name|fail
operator|&
name|MATCH_CHANNEL
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %+4d%c"
argument_list|,
name|se
operator|->
name|se_rssi
argument_list|,
name|fail
operator|&
name|MATCH_RSSI
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %2dM%c"
argument_list|,
operator|(
name|rate
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|/
literal|2
argument_list|,
name|fail
operator|&
name|MATCH_RATE
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %4s%c"
argument_list|,
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_ESS
operator|)
condition|?
literal|"ess"
else|:
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_IBSS
operator|)
condition|?
literal|"ibss"
else|:
literal|""
argument_list|,
name|fail
operator|&
name|MATCH_CAPINFO
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %3s%c "
argument_list|,
operator|(
name|se
operator|->
name|se_capinfo
operator|&
name|IEEE80211_CAPINFO_PRIVACY
operator|)
condition|?
literal|"wep"
else|:
literal|"no"
argument_list|,
name|fail
operator|&
name|MATCH_PRIVACY
condition|?
literal|'!'
else|:
literal|' '
argument_list|)
expr_stmt|;
name|ieee80211_print_essid
argument_list|(
name|se
operator|->
name|se_ssid
operator|+
literal|2
argument_list|,
name|se
operator|->
name|se_ssid
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|fail
operator|&
operator|(
name|MATCH_SSID
operator||
name|MATCH_MESHID
operator|)
condition|?
literal|"!"
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|fail
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_update_notseen
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
comment|/* 		 * If seen the reset and don't bump the count; 		 * otherwise bump the ``not seen'' count.  Note 		 * that this insures that stations for which we 		 * see frames while not scanning but not during 		 * this scan will not be penalized. 		 */
if|if
condition|(
name|se
operator|->
name|se_seen
condition|)
name|se
operator|->
name|se_seen
operator|=
literal|0
expr_stmt|;
else|else
name|se
operator|->
name|se_notseen
operator|++
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_dec_fails
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
if|if
condition|(
name|se
operator|->
name|se_fails
condition|)
name|se
operator|->
name|se_fails
operator|--
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|sta_entry
modifier|*
name|select_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|selbs
init|=
name|NULL
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|debug
argument_list|,
literal|" %s\n"
argument_list|,
literal|"macaddr          bssid         chan  rssi  rate flag  wep  essid"
argument_list|)
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
name|ieee80211_ies_expand
argument_list|(
operator|&
name|se
operator|->
name|base
operator|.
name|se_ies
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_bss
argument_list|(
name|vap
argument_list|,
name|ss
argument_list|,
name|se
argument_list|,
name|debug
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
name|selbs
operator|=
name|se
expr_stmt|;
elseif|else
if|if
condition|(
name|sta_compare
argument_list|(
name|se
argument_list|,
name|selbs
argument_list|)
operator|>
literal|0
condition|)
name|selbs
operator|=
name|se
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
name|selbs
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an ap or ibss network to join or find a channel  * to use to start an ibss network.  */
end_comment

begin_function
specifier|static
name|int
name|sta_pick_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|selbs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_newscan
condition|)
block|{
name|sta_update_notseen
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOPICK
condition|)
block|{
comment|/* 		 * Manual/background scan, don't select+join the 		 * bss, just return.  The scanning framework will 		 * handle notification that this has completed. 		 */
name|ss
operator|->
name|ss_flags
operator|&=
operator|~
name|IEEE80211_SCAN_NOPICK
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Automatic sequencing; look for a candidate and 	 * if found join the network. 	 */
comment|/* NB: unlocked read should be ok */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no scan candidate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOJOIN
condition|)
return|return
literal|0
return|;
name|notfound
label|:
comment|/* 		 * If nothing suitable was found decrement 		 * the failure counts so entries will be 		 * reconsidered the next time around.  We 		 * really want to do this only for sta's 		 * where we've previously had some success. 		 */
name|sta_dec_fails
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* restart scan */
block|}
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOJOIN
condition|)
return|return
operator|(
name|selbs
operator|!=
name|NULL
operator|)
return|;
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
goto|goto
name|notfound
goto|;
name|chan
operator|=
name|selbs
operator|->
name|base
operator|.
name|se_chan
expr_stmt|;
if|if
condition|(
name|selbs
operator|->
name|se_flags
operator|&
name|STA_DEMOTE11B
condition|)
name|chan
operator|=
name|demote11b
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_sta_join
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
condition|)
goto|goto
name|notfound
goto|;
return|return
literal|1
return|;
comment|/* terminate scan */
block|}
end_function

begin_comment
comment|/*  * Lookup an entry in the scan cache.  We assume we're  * called from the bottom half or such that we don't need  * to block the bottom half so that it's safe to return  * a reference to an entry w/o holding the lock on the table.  */
end_comment

begin_function
specifier|static
name|struct
name|sta_entry
modifier|*
name|sta_lookup
parameter_list|(
name|struct
name|sta_table
modifier|*
name|st
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|int
name|hash
init|=
name|STA_HASH
argument_list|(
name|macaddr
argument_list|)
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_hash[hash]
argument_list|,
argument|se_hash
argument_list|)
if|if
condition|(
name|IEEE80211_ADDR_EQ
argument_list|(
name|se
operator|->
name|base
operator|.
name|se_macaddr
argument_list|,
name|macaddr
argument_list|)
condition|)
break|break;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
name|se
return|;
comment|/* NB: unlocked */
block|}
end_function

begin_function
specifier|static
name|void
name|sta_roam_check
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|vap
operator|->
name|iv_bss
decl_stmt|;
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|enum
name|ieee80211_phymode
name|mode
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|selbs
decl_stmt|;
name|uint8_t
name|roamRate
decl_stmt|,
name|curRate
decl_stmt|,
name|ucastRate
decl_stmt|;
name|int8_t
name|roamRssi
decl_stmt|,
name|curRssi
decl_stmt|;
name|se
operator|=
name|sta_lookup
argument_list|(
name|st
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|==
name|NULL
condition|)
block|{
comment|/* XXX something is wrong */
return|return;
block|}
name|mode
operator|=
name|ieee80211_chan2mode
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
name|roamRate
operator|=
name|vap
operator|->
name|iv_roamparms
index|[
name|mode
index|]
operator|.
name|rate
expr_stmt|;
name|roamRssi
operator|=
name|vap
operator|->
name|iv_roamparms
index|[
name|mode
index|]
operator|.
name|rssi
expr_stmt|;
name|ucastRate
operator|=
name|vap
operator|->
name|iv_txparms
index|[
name|mode
index|]
operator|.
name|ucastrate
expr_stmt|;
comment|/* NB: the most up to date rssi is in the node, not the scan cache */
name|curRssi
operator|=
name|ic
operator|->
name|ic_node_getrssi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucastRate
operator|==
name|IEEE80211_FIXED_RATE_NONE
condition|)
block|{
name|curRate
operator|=
name|ni
operator|->
name|ni_txrate
expr_stmt|;
name|roamRate
operator|&=
name|IEEE80211_RATE_VAL
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ROAM
argument_list|,
literal|"%s: currssi %d currate %u roamrssi %d roamrate %u\n"
argument_list|,
name|__func__
argument_list|,
name|curRssi
argument_list|,
name|curRate
argument_list|,
name|roamRssi
argument_list|,
name|roamRate
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|curRate
operator|=
name|roamRate
expr_stmt|;
comment|/* NB: insure compare below fails */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ROAM
argument_list|,
literal|"%s: currssi %d roamrssi %d\n"
argument_list|,
name|__func__
argument_list|,
name|curRssi
argument_list|,
name|roamRssi
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if a new ap should be used and switch. 	 * XXX deauth current ap 	 */
if|if
condition|(
name|curRate
operator|<
name|roamRate
operator|||
name|curRssi
operator|<
name|roamRssi
condition|)
block|{
if|if
condition|(
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastscan
operator|+
name|vap
operator|->
name|iv_scanvalid
argument_list|)
condition|)
block|{
comment|/* 			 * Scan cache contents are too old; force a scan now 			 * if possible so we have current state to make a 			 * decision with.  We don't kick off a bg scan if 			 * we're using dynamic turbo and boosted or if the 			 * channel is busy. 			 * XXX force immediate switch on scan complete 			 */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_DTURBO
argument_list|(
name|ic
operator|->
name|ic_curchan
argument_list|)
operator|&&
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastdata
operator|+
name|vap
operator|->
name|iv_bgscanidle
argument_list|)
condition|)
name|ieee80211_bg_scan
argument_list|(
name|vap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|se
operator|->
name|base
operator|.
name|se_rssi
operator|=
name|curRssi
expr_stmt|;
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|IEEE80211_MSG_ROAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|selbs
operator|!=
name|NULL
operator|&&
name|selbs
operator|!=
name|se
condition|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ROAM
operator||
name|IEEE80211_MSG_DEBUG
argument_list|,
literal|"%s: ROAM: curRate %u, roamRate %u, "
literal|"curRssi %d, roamRssi %d\n"
argument_list|,
name|__func__
argument_list|,
name|curRate
argument_list|,
name|roamRate
argument_list|,
name|curRssi
argument_list|,
name|roamRssi
argument_list|)
expr_stmt|;
name|chan
operator|=
name|selbs
operator|->
name|base
operator|.
name|se_chan
expr_stmt|;
if|if
condition|(
name|selbs
operator|->
name|se_flags
operator|&
name|STA_DEMOTE11B
condition|)
name|chan
operator|=
name|demote11b
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ieee80211_sta_join
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Age entries in the scan cache.  * XXX also do roaming since it's convenient  */
end_comment

begin_function
specifier|static
name|void
name|sta_age
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ss
operator|->
name|ss_vap
decl_stmt|;
name|adhoc_age
argument_list|(
name|ss
argument_list|)
expr_stmt|;
comment|/* 	 * If rate control is enabled check periodically to see if 	 * we should roam from our current connection to one that 	 * might be better.  This only applies when we're operating 	 * in sta mode and automatic roaming is set. 	 * XXX defer if busy 	 * XXX repeater station 	 * XXX do when !bgscan? 	 */
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
argument_list|,
operator|(
literal|"wrong mode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_roaming
operator|==
name|IEEE80211_ROAMING_AUTO
operator|&&
operator|(
name|vap
operator|->
name|iv_ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_BGSCAN
operator|)
operator|&&
name|vap
operator|->
name|iv_state
operator|>=
name|IEEE80211_S_RUN
condition|)
comment|/* XXX vap is implicit */
name|sta_roam_check
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Iterate over the entries in the scan cache, invoking  * the callback function on each one.  */
end_comment

begin_function
specifier|static
name|void
name|sta_iterate
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|ieee80211_scan_iter_func
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|u_int
name|gen
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|)
expr_stmt|;
name|gen
operator|=
name|st
operator|->
name|st_scaniter
operator|++
expr_stmt|;
name|restart
label|:
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_scangen
operator|!=
name|gen
condition|)
block|{
name|se
operator|->
name|se_scangen
operator|=
name|gen
expr_stmt|;
comment|/* update public state */
name|se
operator|->
name|base
operator|.
name|se_age
operator|=
name|ticks
operator|-
name|se
operator|->
name|se_lastupdate
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|arg
argument_list|,
operator|&
name|se
operator|->
name|base
argument_list|)
expr_stmt|;
goto|goto
name|restart
goto|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_scanlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|sta_assoc_fail
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|se
operator|=
name|sta_lookup
argument_list|(
name|st
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|!=
name|NULL
condition|)
block|{
name|se
operator|->
name|se_fails
operator|++
expr_stmt|;
name|se
operator|->
name|se_lastfail
operator|=
name|ticks
expr_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|ss
operator|->
name|ss_vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
name|macaddr
argument_list|,
literal|"%s: reason %u fails %u"
argument_list|,
name|__func__
argument_list|,
name|reason
argument_list|,
name|se
operator|->
name|se_fails
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|sta_assoc_success
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|se
operator|=
name|sta_lookup
argument_list|(
name|st
argument_list|,
name|macaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|se
operator|!=
name|NULL
condition|)
block|{
if|#
directive|if
literal|0
block|se->se_fails = 0; 		IEEE80211_NOTE_MAC(ss->ss_vap, IEEE80211_MSG_SCAN, 		    macaddr, "%s: fails %u", 		    __func__, se->se_fails);
endif|#
directive|endif
name|se
operator|->
name|se_lastassoc
operator|=
name|ticks
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|sta_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|sta_attach
block|,
operator|.
name|scan_detach
operator|=
name|sta_detach
block|,
operator|.
name|scan_start
operator|=
name|sta_start
block|,
operator|.
name|scan_restart
operator|=
name|sta_restart
block|,
operator|.
name|scan_cancel
operator|=
name|sta_cancel
block|,
operator|.
name|scan_end
operator|=
name|sta_pick_bss
block|,
operator|.
name|scan_flush
operator|=
name|sta_flush
block|,
operator|.
name|scan_add
operator|=
name|sta_add
block|,
operator|.
name|scan_age
operator|=
name|sta_age
block|,
operator|.
name|scan_iterate
operator|=
name|sta_iterate
block|,
operator|.
name|scan_assoc_fail
operator|=
name|sta_assoc_fail
block|,
operator|.
name|scan_assoc_success
operator|=
name|sta_assoc_success
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|IEEE80211_SCANNER_ALG
argument_list|(
name|sta
argument_list|,
name|IEEE80211_M_STA
argument_list|,
name|sta_default
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Adhoc mode-specific support.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhocWorld
index|[]
init|=
comment|/* 36, 40, 44, 48 */
block|{
literal|5180
block|,
literal|5200
block|,
literal|5220
block|,
literal|5240
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhocFcc3
index|[]
init|=
comment|/* 36, 40, 44, 48 145, 149, 153, 157, 161, 165 */
block|{
literal|5180
block|,
literal|5200
block|,
literal|5220
block|,
literal|5240
block|,
literal|5725
block|,
literal|5745
block|,
literal|5765
block|,
literal|5785
block|,
literal|5805
block|,
literal|5825
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhocMkk
index|[]
init|=
comment|/* 34, 38, 42, 46 */
block|{
literal|5170
block|,
literal|5190
block|,
literal|5210
block|,
literal|5230
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|uint16_t
name|adhoc11b
index|[]
init|=
comment|/* 10, 11 */
block|{
literal|2457
block|,
literal|2462
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|scanlist
name|adhocScanTable
index|[]
init|=
block|{
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|adhoc11b
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|adhocWorld
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11A
block|,
name|X
argument_list|(
argument|adhocFcc3
argument_list|)
block|}
block|,
block|{
name|IEEE80211_MODE_11B
block|,
name|X
argument_list|(
argument|adhocMkk
argument_list|)
block|}
block|,
block|{
operator|.
name|list
operator|=
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|X
end_undef

begin_comment
comment|/*  * Start an adhoc-mode scan by populating the channel list.  */
end_comment

begin_function
specifier|static
name|int
name|adhoc_start
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|makescanlist
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|adhocScanTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_mindwell
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_mindwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
if|if
condition|(
name|ss
operator|->
name|ss_maxdwell
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_maxdwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
name|st
operator|->
name|st_scangen
operator|++
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Select a channel to start an adhoc network on.  * The channel list was populated with appropriate  * channels so select one that looks least occupied.  */
end_comment

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|adhoc_pick_channel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|,
modifier|*
name|bestchan
decl_stmt|;
name|int
name|i
decl_stmt|,
name|bestrssi
decl_stmt|,
name|maxrssi
decl_stmt|;
name|bestchan
operator|=
name|NULL
expr_stmt|;
name|bestrssi
operator|=
operator|-
literal|1
expr_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|ss_last
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|ss
operator|->
name|ss_chans
index|[
name|i
index|]
expr_stmt|;
comment|/* never consider a channel with radar */
if|if
condition|(
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* skip channels disallowed by regulatory settings */
if|if
condition|(
name|IEEE80211_IS_CHAN_NOADHOC
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
comment|/* check channel attributes for band compatibility */
if|if
condition|(
name|flags
operator|!=
literal|0
operator|&&
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|flags
operator|)
operator|!=
name|flags
condition|)
continue|continue;
name|maxrssi
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|base
operator|.
name|se_chan
operator|!=
name|c
condition|)
continue|continue;
if|if
condition|(
name|se
operator|->
name|base
operator|.
name|se_rssi
operator|>
name|maxrssi
condition|)
name|maxrssi
operator|=
name|se
operator|->
name|base
operator|.
name|se_rssi
expr_stmt|;
block|}
if|if
condition|(
name|bestchan
operator|==
name|NULL
operator|||
name|maxrssi
operator|<
name|bestrssi
condition|)
name|bestchan
operator|=
name|c
expr_stmt|;
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
return|return
name|bestchan
return|;
block|}
end_function

begin_comment
comment|/*  * Pick an ibss network to join or find a channel  * to use to start an ibss network.  */
end_comment

begin_function
specifier|static
name|int
name|adhoc_pick_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|selbs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_IBSS
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_AHDEMO
operator|||
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
argument_list|,
operator|(
literal|"wrong opmode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_newscan
condition|)
block|{
name|sta_update_notseen
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOPICK
condition|)
block|{
comment|/* 		 * Manual/background scan, don't select+join the 		 * bss, just return.  The scanning framework will 		 * handle notification that this has completed. 		 */
name|ss
operator|->
name|ss_flags
operator|&=
operator|~
name|IEEE80211_SCAN_NOPICK
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Automatic sequencing; look for a candidate and 	 * if found join the network. 	 */
comment|/* NB: unlocked read should be ok */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no scan candidate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOJOIN
condition|)
return|return
literal|0
return|;
name|notfound
label|:
comment|/* NB: never auto-start a tdma network for slot !0 */
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
if|if
condition|(
name|vap
operator|->
name|iv_des_nssid
operator|&&
operator|(
operator|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
operator|||
name|ieee80211_tdma_getslot
argument_list|(
name|vap
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|vap
operator|->
name|iv_des_nssid
condition|)
block|{
endif|#
directive|endif
comment|/* 			 * No existing adhoc network to join and we have 			 * an ssid; start one up.  If no channel was 			 * specified, try to select a channel. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_des_chan
operator|==
name|IEEE80211_CHAN_ANYC
operator|||
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|vap
operator|->
name|iv_des_chan
argument_list|)
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|chan
operator|=
name|adhoc_pick_channel
argument_list|(
name|ss
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|vap
operator|->
name|iv_flags_ht
argument_list|)
expr_stmt|;
block|}
else|else
name|chan
operator|=
name|vap
operator|->
name|iv_des_chan
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_create_ibss
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * If nothing suitable was found decrement 		 * the failure counts so entries will be 		 * reconsidered the next time around.  We 		 * really want to do this only for sta's 		 * where we've previously had some success. 		 */
name|sta_dec_fails
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* restart scan */
block|}
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOJOIN
condition|)
return|return
operator|(
name|selbs
operator|!=
name|NULL
operator|)
return|;
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
goto|goto
name|notfound
goto|;
name|chan
operator|=
name|selbs
operator|->
name|base
operator|.
name|se_chan
expr_stmt|;
if|if
condition|(
name|selbs
operator|->
name|se_flags
operator|&
name|STA_DEMOTE11B
condition|)
name|chan
operator|=
name|demote11b
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_sta_join
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
condition|)
goto|goto
name|notfound
goto|;
return|return
literal|1
return|;
comment|/* terminate scan */
block|}
comment|/*  * Age entries in the scan cache.  */
specifier|static
name|void
name|adhoc_age
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|se
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|mtx_lock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|se
argument_list|,
argument|&st->st_entry
argument_list|,
argument|se_list
argument_list|,
argument|next
argument_list|)
block|{
if|if
condition|(
name|se
operator|->
name|se_notseen
operator|>
name|STA_PURGE_SCANS
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|,
name|se
argument_list|,
name|se_list
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|se
argument_list|,
name|se_hash
argument_list|)
expr_stmt|;
name|ieee80211_ies_cleanup
argument_list|(
operator|&
name|se
operator|->
name|base
operator|.
name|se_ies
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|se
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
block|}
block|}
name|mtx_unlock
argument_list|(
operator|&
name|st
operator|->
name|st_lock
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|adhoc_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|sta_attach
block|,
operator|.
name|scan_detach
operator|=
name|sta_detach
block|,
operator|.
name|scan_start
operator|=
name|adhoc_start
block|,
operator|.
name|scan_restart
operator|=
name|sta_restart
block|,
operator|.
name|scan_cancel
operator|=
name|sta_cancel
block|,
operator|.
name|scan_end
operator|=
name|adhoc_pick_bss
block|,
operator|.
name|scan_flush
operator|=
name|sta_flush
block|,
operator|.
name|scan_pickchan
operator|=
name|adhoc_pick_channel
block|,
operator|.
name|scan_add
operator|=
name|sta_add
block|,
operator|.
name|scan_age
operator|=
name|adhoc_age
block|,
operator|.
name|scan_iterate
operator|=
name|sta_iterate
block|,
operator|.
name|scan_assoc_fail
operator|=
name|sta_assoc_fail
block|,
operator|.
name|scan_assoc_success
operator|=
name|sta_assoc_success
block|, }
decl_stmt|;
name|IEEE80211_SCANNER_ALG
argument_list|(
name|ibss
argument_list|,
name|IEEE80211_M_IBSS
argument_list|,
name|adhoc_default
argument_list|)
expr_stmt|;
name|IEEE80211_SCANNER_ALG
argument_list|(
name|ahdemo
argument_list|,
name|IEEE80211_M_AHDEMO
argument_list|,
name|adhoc_default
argument_list|)
expr_stmt|;
specifier|static
name|void
name|ap_force_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* set interface into promiscuous mode */
name|ifp
operator|->
name|if_flags
operator||=
name|IFF_PROMISC
expr_stmt|;
name|ieee80211_runtask
argument_list|(
name|ic
argument_list|,
operator|&
name|ic
operator|->
name|ic_promisc_task
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|ap_reset_promisc
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_syncifflag_locked
argument_list|(
name|ic
argument_list|,
name|IFF_PROMISC
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
specifier|static
name|int
name|ap_start
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|makescanlist
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|staScanTable
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_mindwell
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_mindwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
if|if
condition|(
name|ss
operator|->
name|ss_maxdwell
operator|==
literal|0
condition|)
name|ss
operator|->
name|ss_maxdwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
name|st
operator|->
name|st_scangen
operator|++
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
name|ap_force_promisc
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Cancel an ongoing scan.  */
specifier|static
name|int
name|ap_cancel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|ap_reset_promisc
argument_list|(
name|vap
operator|->
name|iv_ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*  * Pick a quiet channel to use for ap operation.  */
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|ap_pick_channel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|bestchan
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* XXX select channel more intelligently, e.g. channel spread, power */
comment|/* NB: use scan list order to preserve channel preference */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|ss_last
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|chan
init|=
name|ss
operator|->
name|ss_chans
index|[
name|i
index|]
decl_stmt|;
comment|/* 		 * If the channel is unoccupied the max rssi 		 * should be zero; just take it.  Otherwise 		 * track the channel with the lowest rssi and 		 * use that when all channels appear occupied. 		 */
if|if
condition|(
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|IEEE80211_IS_CHAN_NOHOSTAP
argument_list|(
name|chan
argument_list|)
condition|)
continue|continue;
comment|/* check channel attributes for band compatibility */
if|if
condition|(
name|flags
operator|!=
literal|0
operator|&&
operator|(
name|chan
operator|->
name|ic_flags
operator|&
name|flags
operator|)
operator|!=
name|flags
condition|)
continue|continue;
name|KASSERT
argument_list|(
sizeof|sizeof
argument_list|(
name|chan
operator|->
name|ic_ieee
argument_list|)
operator|==
literal|1
argument_list|,
operator|(
literal|"ic_chan size"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX channel have interference */
if|if
condition|(
name|st
operator|->
name|st_maxrssi
index|[
name|chan
operator|->
name|ic_ieee
index|]
operator|==
literal|0
condition|)
block|{
comment|/* XXX use other considerations */
return|return
name|chan
return|;
block|}
if|if
condition|(
name|bestchan
operator|==
name|NULL
operator|||
name|st
operator|->
name|st_maxrssi
index|[
name|chan
operator|->
name|ic_ieee
index|]
operator|<
name|st
operator|->
name|st_maxrssi
index|[
name|bestchan
operator|->
name|ic_ieee
index|]
condition|)
name|bestchan
operator|=
name|chan
expr_stmt|;
block|}
return|return
name|bestchan
return|;
block|}
comment|/*  * Pick a quiet channel to use for ap operation.  */
specifier|static
name|int
name|ap_end
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|bestchan
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_HOSTAP
argument_list|,
operator|(
literal|"wrong opmode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
name|bestchan
operator|=
name|ap_pick_channel
argument_list|(
name|ss
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestchan
operator|==
name|NULL
condition|)
block|{
comment|/* no suitable channel, should not happen */
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no suitable channel! (should not happen)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX print something? */
return|return
literal|0
return|;
comment|/* restart scan */
block|}
comment|/* 	 * If this is a dynamic turbo channel, start with the unboosted one. 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|bestchan
argument_list|)
condition|)
block|{
name|bestchan
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|bestchan
operator|->
name|ic_freq
argument_list|,
name|bestchan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_TURBO
argument_list|)
expr_stmt|;
if|if
condition|(
name|bestchan
operator|==
name|NULL
condition|)
block|{
comment|/* should never happen ?? */
return|return
literal|0
return|;
block|}
block|}
name|ap_reset_promisc
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
operator|(
name|IEEE80211_SCAN_NOPICK
operator||
name|IEEE80211_SCAN_NOJOIN
operator|)
condition|)
block|{
comment|/* 		 * Manual/background scan, don't select+join the 		 * bss, just return.  The scanning framework will 		 * handle notification that this has completed. 		 */
name|ss
operator|->
name|ss_flags
operator|&=
operator|~
name|IEEE80211_SCAN_NOPICK
expr_stmt|;
return|return
literal|1
return|;
block|}
name|ieee80211_create_ibss
argument_list|(
name|vap
argument_list|,
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|bestchan
argument_list|,
name|vap
operator|->
name|iv_flags_ht
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|ap_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|sta_attach
block|,
operator|.
name|scan_detach
operator|=
name|sta_detach
block|,
operator|.
name|scan_start
operator|=
name|ap_start
block|,
operator|.
name|scan_restart
operator|=
name|sta_restart
block|,
operator|.
name|scan_cancel
operator|=
name|ap_cancel
block|,
operator|.
name|scan_end
operator|=
name|ap_end
block|,
operator|.
name|scan_flush
operator|=
name|sta_flush
block|,
operator|.
name|scan_pickchan
operator|=
name|ap_pick_channel
block|,
operator|.
name|scan_add
operator|=
name|sta_add
block|,
operator|.
name|scan_age
operator|=
name|adhoc_age
block|,
operator|.
name|scan_iterate
operator|=
name|sta_iterate
block|,
operator|.
name|scan_assoc_success
operator|=
name|sta_assoc_success
block|,
operator|.
name|scan_assoc_fail
operator|=
name|sta_assoc_fail
block|, }
decl_stmt|;
name|IEEE80211_SCANNER_ALG
argument_list|(
name|ap
argument_list|,
name|IEEE80211_M_HOSTAP
argument_list|,
name|ap_default
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_MESH
comment|/*  * Pick an mbss network to join or find a channel  * to use to start an mbss network.  */
specifier|static
name|int
name|mesh_pick_bss
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|sta_table
modifier|*
name|st
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|ieee80211_mesh_state
modifier|*
name|ms
init|=
name|vap
operator|->
name|iv_mesh
decl_stmt|;
name|struct
name|sta_entry
modifier|*
name|selbs
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|chan
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MBSS
argument_list|,
operator|(
literal|"wrong opmode %u"
operator|,
name|vap
operator|->
name|iv_opmode
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|st_newscan
condition|)
block|{
name|sta_update_notseen
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOPICK
condition|)
block|{
comment|/* 		 * Manual/background scan, don't select+join the 		 * bss, just return.  The scanning framework will 		 * handle notification that this has completed. 		 */
name|ss
operator|->
name|ss_flags
operator|&=
operator|~
name|IEEE80211_SCAN_NOPICK
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* 	 * Automatic sequencing; look for a candidate and 	 * if found join the network. 	 */
comment|/* NB: unlocked read should be ok */
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|st
operator|->
name|st_entry
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no scan candidate\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOJOIN
condition|)
return|return
literal|0
return|;
name|notfound
label|:
if|if
condition|(
name|ms
operator|->
name|ms_idlen
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * No existing mbss network to join and we have 			 * a meshid; start one up.  If no channel was 			 * specified, try to select a channel. 			 */
if|if
condition|(
name|vap
operator|->
name|iv_des_chan
operator|==
name|IEEE80211_CHAN_ANYC
operator|||
name|IEEE80211_IS_CHAN_RADAR
argument_list|(
name|vap
operator|->
name|iv_des_chan
argument_list|)
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|chan
operator|=
name|adhoc_pick_channel
argument_list|(
name|ss
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|vap
operator|->
name|iv_flags_ht
argument_list|)
expr_stmt|;
block|}
else|else
name|chan
operator|=
name|vap
operator|->
name|iv_des_chan
expr_stmt|;
if|if
condition|(
name|chan
operator|!=
name|NULL
condition|)
block|{
name|ieee80211_create_ibss
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* 		 * If nothing suitable was found decrement 		 * the failure counts so entries will be 		 * reconsidered the next time around.  We 		 * really want to do this only for sta's 		 * where we've previously had some success. 		 */
name|sta_dec_fails
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|st
operator|->
name|st_newscan
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
comment|/* restart scan */
block|}
name|selbs
operator|=
name|select_bss
argument_list|(
name|ss
argument_list|,
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|->
name|ss_flags
operator|&
name|IEEE80211_SCAN_NOJOIN
condition|)
return|return
operator|(
name|selbs
operator|!=
name|NULL
operator|)
return|;
if|if
condition|(
name|selbs
operator|==
name|NULL
condition|)
goto|goto
name|notfound
goto|;
name|chan
operator|=
name|selbs
operator|->
name|base
operator|.
name|se_chan
expr_stmt|;
if|if
condition|(
name|selbs
operator|->
name|se_flags
operator|&
name|STA_DEMOTE11B
condition|)
name|chan
operator|=
name|demote11b
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_sta_join
argument_list|(
name|vap
argument_list|,
name|chan
argument_list|,
operator|&
name|selbs
operator|->
name|base
argument_list|)
condition|)
goto|goto
name|notfound
goto|;
return|return
literal|1
return|;
comment|/* terminate scan */
block|}
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|mesh_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|sta_attach
block|,
operator|.
name|scan_detach
operator|=
name|sta_detach
block|,
operator|.
name|scan_start
operator|=
name|adhoc_start
block|,
operator|.
name|scan_restart
operator|=
name|sta_restart
block|,
operator|.
name|scan_cancel
operator|=
name|sta_cancel
block|,
operator|.
name|scan_end
operator|=
name|mesh_pick_bss
block|,
operator|.
name|scan_flush
operator|=
name|sta_flush
block|,
operator|.
name|scan_pickchan
operator|=
name|adhoc_pick_channel
block|,
operator|.
name|scan_add
operator|=
name|sta_add
block|,
operator|.
name|scan_age
operator|=
name|adhoc_age
block|,
operator|.
name|scan_iterate
operator|=
name|sta_iterate
block|,
operator|.
name|scan_assoc_fail
operator|=
name|sta_assoc_fail
block|,
operator|.
name|scan_assoc_success
operator|=
name|sta_assoc_success
block|, }
decl_stmt|;
name|IEEE80211_SCANNER_ALG
argument_list|(
name|mesh
argument_list|,
name|IEEE80211_M_MBSS
argument_list|,
name|mesh_default
argument_list|)
expr_stmt|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_SUPPORT_MESH */
end_comment

end_unit

