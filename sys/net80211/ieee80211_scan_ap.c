begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 ap scanning support.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_struct
struct|struct
name|ap_state
block|{
name|int
name|as_maxrssi
index|[
name|IEEE80211_CHAN_MAX
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|ap_flush
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* number of references from net80211 layer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrefs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Attach prior to any scanning work.  */
end_comment

begin_function
specifier|static
name|int
name|ap_attach
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|ap_state
modifier|*
name|as
decl_stmt|;
name|MALLOC
argument_list|(
name|as
argument_list|,
expr|struct
name|ap_state
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ap_state
argument_list|)
argument_list|,
name|M_80211_SCAN
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_priv
operator|=
name|as
expr_stmt|;
name|ap_flush
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|nrefs
operator|++
expr_stmt|;
comment|/* NB: we assume caller locking */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup any private state.  */
end_comment

begin_function
specifier|static
name|int
name|ap_detach
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|ap_state
modifier|*
name|as
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
if|if
condition|(
name|as
operator|!=
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|nrefs
operator|>
literal|0
argument_list|,
operator|(
literal|"imbalanced attach/detach"
operator|)
argument_list|)
expr_stmt|;
name|nrefs
operator|--
expr_stmt|;
comment|/* NB: we assume caller locking */
name|FREE
argument_list|(
name|as
argument_list|,
name|M_80211_SCAN
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Flush all per-scan state.  */
end_comment

begin_function
specifier|static
name|int
name|ap_flush
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
name|struct
name|ap_state
modifier|*
name|as
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|memset
argument_list|(
name|as
operator|->
name|as_maxrssi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|as
operator|->
name|as_maxrssi
argument_list|)
argument_list|)
expr_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
comment|/* insure no channel will be picked */
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|find11gchannel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|i
parameter_list|,
name|int
name|freq
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* 	 * The normal ordering in the channel list is b channel 	 * immediately followed by g so optimize the search for 	 * this.  We'll still do a full search just in case. 	 */
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|ic_freq
operator|==
name|freq
operator|&&
name|IEEE80211_IS_CHAN_ANYG
argument_list|(
name|c
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Start an ap scan by populating the channel list.  */
end_comment

begin_function
specifier|static
name|int
name|ap_start
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ss
operator|->
name|ss_last
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|==
name|IEEE80211_MODE_AUTO
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|c
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_F_XR
comment|/* XR is not supported on turbo channels */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_XR
condition|)
continue|continue;
endif|#
directive|endif
comment|/* dynamic channels are scanned in base mode */
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_ST
argument_list|(
name|c
argument_list|)
condition|)
continue|continue;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* HT channels are scanned in legacy */
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Use any 11g channel instead of 11b one. 				 */
if|if
condition|(
name|IEEE80211_IS_CHAN_B
argument_list|(
name|c
argument_list|)
operator|&&
name|find11gchannel
argument_list|(
name|ic
argument_list|,
name|i
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|)
condition|)
continue|continue;
block|}
if|if
condition|(
name|ss
operator|->
name|ss_last
operator|>=
name|IEEE80211_SCAN_MAX
condition|)
break|break;
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|static
specifier|const
name|u_int
name|chanflags
index|[
name|IEEE80211_MODE_MAX
index|]
init|=
block|{
literal|0
block|,
comment|/* IEEE80211_MODE_AUTO */
name|IEEE80211_CHAN_A
block|,
comment|/* IEEE80211_MODE_11A */
name|IEEE80211_CHAN_B
block|,
comment|/* IEEE80211_MODE_11B */
name|IEEE80211_CHAN_G
block|,
comment|/* IEEE80211_MODE_11G */
name|IEEE80211_CHAN_FHSS
block|,
comment|/* IEEE80211_MODE_FH */
name|IEEE80211_CHAN_108A
block|,
comment|/* IEEE80211_MODE_TURBO_A */
name|IEEE80211_CHAN_108G
block|,
comment|/* IEEE80211_MODE_TURBO_G */
name|IEEE80211_CHAN_ST
block|,
comment|/* IEEE80211_MODE_STURBO_A */
name|IEEE80211_CHAN_A
block|,
comment|/* IEEE80211_MODE_11NA */
name|IEEE80211_CHAN_G
block|,
comment|/* IEEE80211_MODE_11NG */
block|}
decl_stmt|;
name|u_int
name|modeflags
decl_stmt|;
name|modeflags
operator|=
name|chanflags
index|[
name|ic
operator|->
name|ic_des_mode
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_TURBOP
operator|)
operator|&&
name|modeflags
operator|!=
name|IEEE80211_CHAN_ST
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_des_mode
operator|==
name|IEEE80211_MODE_11G
condition|)
name|modeflags
operator|=
name|IEEE80211_CHAN_108G
expr_stmt|;
else|else
name|modeflags
operator|=
name|IEEE80211_CHAN_108A
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_nchans
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|&
name|ic
operator|->
name|ic_channels
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|->
name|ic_flags
operator|&
name|modeflags
operator|)
operator|!=
name|modeflags
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|IEEE80211_F_XR
comment|/* XR is not supported on turbo channels */
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|c
argument_list|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_XR
operator|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|ss
operator|->
name|ss_last
operator|>=
name|IEEE80211_SCAN_MAX
condition|)
break|break;
comment|/*  			 * Do not select static turbo channels if 			 * the mode is not static turbo. 			 */
if|if
condition|(
name|IEEE80211_IS_CHAN_STURBO
argument_list|(
name|c
argument_list|)
operator|&&
name|ic
operator|->
name|ic_des_mode
operator|!=
name|IEEE80211_MODE_STURBO_A
condition|)
continue|continue;
name|ss
operator|->
name|ss_chans
index|[
name|ss
operator|->
name|ss_last
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
name|ss
operator|->
name|ss_next
operator|=
literal|0
expr_stmt|;
comment|/* XXX tunables */
name|ss
operator|->
name|ss_mindwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|200
argument_list|)
expr_stmt|;
comment|/* 200ms */
name|ss
operator|->
name|ss_maxdwell
operator|=
name|msecs_to_ticks
argument_list|(
literal|300
argument_list|)
expr_stmt|;
comment|/* 300ms */
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
if|if
condition|(
name|ieee80211_msg_scan
argument_list|(
name|ic
argument_list|)
condition|)
block|{
name|if_printf
argument_list|(
name|ic
operator|->
name|ic_ifp
argument_list|,
literal|"scan set "
argument_list|)
expr_stmt|;
name|ieee80211_scan_dump_channels
argument_list|(
name|ss
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" dwell min %ld max %ld\n"
argument_list|,
name|ss
operator|->
name|ss_mindwell
argument_list|,
name|ss
operator|->
name|ss_maxdwell
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_DEBUG */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Restart a bg scan.  */
end_comment

begin_function
specifier|static
name|int
name|ap_restart
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Cancel an ongoing scan.  */
end_comment

begin_function
specifier|static
name|int
name|ap_cancel
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Record max rssi on channel.  */
end_comment

begin_function
specifier|static
name|int
name|ap_add
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|struct
name|ieee80211_scanparams
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|int
name|subtype
parameter_list|,
name|int
name|rssi
parameter_list|,
name|int
name|noise
parameter_list|,
name|int
name|rstamp
parameter_list|)
block|{
name|struct
name|ap_state
modifier|*
name|as
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ss
operator|->
name|ss_ic
decl_stmt|;
name|int
name|chan
decl_stmt|;
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
comment|/* XXX better quantification of channel use? */
comment|/* XXX count bss's? */
if|if
condition|(
name|rssi
operator|>
name|as
operator|->
name|as_maxrssi
index|[
name|chan
index|]
condition|)
name|as
operator|->
name|as_maxrssi
index|[
name|chan
index|]
operator|=
name|rssi
expr_stmt|;
comment|/* XXX interference, turbo requirements */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Pick a quiet channel to use for ap operation.  */
end_comment

begin_function
specifier|static
name|int
name|ap_end
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ap_state
modifier|*
name|as
init|=
name|ss
operator|->
name|ss_priv
decl_stmt|;
name|int
name|i
decl_stmt|,
name|chan
decl_stmt|,
name|bestchan
decl_stmt|,
name|bestchanix
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_HOSTAP
argument_list|,
operator|(
literal|"wrong opmode %u"
operator|,
name|ic
operator|->
name|ic_opmode
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX select channel more intelligently, e.g. channel spread, power */
name|bestchan
operator|=
operator|-
literal|1
expr_stmt|;
name|bestchanix
operator|=
literal|0
expr_stmt|;
comment|/* NB: silence compiler */
comment|/* NB: use scan list order to preserve channel preference */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ss
operator|->
name|ss_last
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * If the channel is unoccupied the max rssi 		 * should be zero; just take it.  Otherwise 		 * track the channel with the lowest rssi and 		 * use that when all channels appear occupied. 		 */
comment|/* XXX channel have interference? */
name|chan
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ss
operator|->
name|ss_chans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: channel %u rssi %d bestchan %d bestchan rssi %d\n"
argument_list|,
name|__func__
argument_list|,
name|chan
argument_list|,
name|as
operator|->
name|as_maxrssi
index|[
name|chan
index|]
argument_list|,
name|bestchan
argument_list|,
name|bestchan
operator|!=
operator|-
literal|1
condition|?
name|as
operator|->
name|as_maxrssi
index|[
name|bestchan
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|as_maxrssi
index|[
name|chan
index|]
operator|==
literal|0
condition|)
block|{
name|bestchan
operator|=
name|chan
expr_stmt|;
name|bestchanix
operator|=
name|i
expr_stmt|;
comment|/* XXX use other considerations */
break|break;
block|}
if|if
condition|(
name|bestchan
operator|==
operator|-
literal|1
operator|||
name|as
operator|->
name|as_maxrssi
index|[
name|chan
index|]
operator|<
name|as
operator|->
name|as_maxrssi
index|[
name|bestchan
index|]
condition|)
name|bestchan
operator|=
name|chan
expr_stmt|;
block|}
if|if
condition|(
name|bestchan
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* no suitable channel, should not happen */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s: no suitable channel! (should not happen)\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* XXX print something? */
return|return
literal|0
return|;
comment|/* restart scan */
block|}
else|else
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
comment|/* XXX notify all vap's? */
comment|/* 		 * If this is a dynamic turbo frequency, 		 * start with normal mode first. 		 */
name|c
operator|=
name|ss
operator|->
name|ss_chans
index|[
name|bestchanix
index|]
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_TURBO
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|IEEE80211_IS_CHAN_STURBO
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_TURBO
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
block|{
comment|/* should never happen ?? */
return|return
literal|0
return|;
block|}
block|}
name|ieee80211_create_ibss
argument_list|(
name|ic
argument_list|,
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|c
argument_list|,
name|ic
operator|->
name|ic_flags_ext
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ap_age
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|)
block|{
comment|/* XXX is there anything meaningful to do? */
block|}
end_function

begin_function
specifier|static
name|void
name|ap_iterate
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
name|ieee80211_scan_iter_func
modifier|*
name|f
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* NB: nothing meaningful we can do */
block|}
end_function

begin_function
specifier|static
name|void
name|ap_assoc_success
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
comment|/* should not be called */
block|}
end_function

begin_function
specifier|static
name|void
name|ap_assoc_fail
parameter_list|(
name|struct
name|ieee80211_scan_state
modifier|*
name|ss
parameter_list|,
specifier|const
name|uint8_t
name|macaddr
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
comment|/* should not be called */
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_scanner
name|ap_default
init|=
block|{
operator|.
name|scan_name
operator|=
literal|"default"
block|,
operator|.
name|scan_attach
operator|=
name|ap_attach
block|,
operator|.
name|scan_detach
operator|=
name|ap_detach
block|,
operator|.
name|scan_start
operator|=
name|ap_start
block|,
operator|.
name|scan_restart
operator|=
name|ap_restart
block|,
operator|.
name|scan_cancel
operator|=
name|ap_cancel
block|,
operator|.
name|scan_end
operator|=
name|ap_end
block|,
operator|.
name|scan_flush
operator|=
name|ap_flush
block|,
operator|.
name|scan_add
operator|=
name|ap_add
block|,
operator|.
name|scan_age
operator|=
name|ap_age
block|,
operator|.
name|scan_iterate
operator|=
name|ap_iterate
block|,
operator|.
name|scan_assoc_success
operator|=
name|ap_assoc_success
block|,
operator|.
name|scan_assoc_fail
operator|=
name|ap_assoc_fail
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_function
specifier|static
name|int
name|wlan_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|ieee80211_scanner_register
argument_list|(
name|IEEE80211_M_HOSTAP
argument_list|,
operator|&
name|ap_default
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_QUIESCE
case|:
if|if
condition|(
name|nrefs
condition|)
block|{
name|printf
argument_list|(
literal|"wlan_scan_ap: still in use (%u dynamic refs)\n"
argument_list|,
name|nrefs
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|type
operator|==
name|MOD_UNLOAD
condition|)
name|ieee80211_scanner_unregister_all
argument_list|(
operator|&
name|ap_default
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|wlan_mod
init|=
block|{
literal|"wlan_scan_ap"
block|,
name|wlan_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|wlan_scan_ap
argument_list|,
name|wlan_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wlan_scan_ap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wlan_scan_ap
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

