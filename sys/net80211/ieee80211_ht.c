begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2008 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11n protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_action.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_comment
comment|/* define here, used throughout file */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
end_define

begin_decl_stmt
specifier|const
name|struct
name|ieee80211_mcs_rates
name|ieee80211_htrates
index|[
name|IEEE80211_HTRATE_MAXSIZE
index|]
init|=
block|{
block|{
literal|13
block|,
literal|14
block|,
literal|27
block|,
literal|30
block|}
block|,
comment|/* MCS 0 */
block|{
literal|26
block|,
literal|29
block|,
literal|54
block|,
literal|60
block|}
block|,
comment|/* MCS 1 */
block|{
literal|39
block|,
literal|43
block|,
literal|81
block|,
literal|90
block|}
block|,
comment|/* MCS 2 */
block|{
literal|52
block|,
literal|58
block|,
literal|108
block|,
literal|120
block|}
block|,
comment|/* MCS 3 */
block|{
literal|78
block|,
literal|87
block|,
literal|162
block|,
literal|180
block|}
block|,
comment|/* MCS 4 */
block|{
literal|104
block|,
literal|116
block|,
literal|216
block|,
literal|240
block|}
block|,
comment|/* MCS 5 */
block|{
literal|117
block|,
literal|130
block|,
literal|243
block|,
literal|270
block|}
block|,
comment|/* MCS 6 */
block|{
literal|130
block|,
literal|144
block|,
literal|270
block|,
literal|300
block|}
block|,
comment|/* MCS 7 */
block|{
literal|26
block|,
literal|29
block|,
literal|54
block|,
literal|60
block|}
block|,
comment|/* MCS 8 */
block|{
literal|52
block|,
literal|58
block|,
literal|108
block|,
literal|120
block|}
block|,
comment|/* MCS 9 */
block|{
literal|78
block|,
literal|87
block|,
literal|162
block|,
literal|180
block|}
block|,
comment|/* MCS 10 */
block|{
literal|104
block|,
literal|116
block|,
literal|216
block|,
literal|240
block|}
block|,
comment|/* MCS 11 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 12 */
block|{
literal|208
block|,
literal|231
block|,
literal|432
block|,
literal|480
block|}
block|,
comment|/* MCS 13 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 14 */
block|{
literal|260
block|,
literal|289
block|,
literal|540
block|,
literal|600
block|}
block|,
comment|/* MCS 15 */
block|{
literal|39
block|,
literal|43
block|,
literal|81
block|,
literal|90
block|}
block|,
comment|/* MCS 16 */
block|{
literal|78
block|,
literal|87
block|,
literal|162
block|,
literal|180
block|}
block|,
comment|/* MCS 17 */
block|{
literal|117
block|,
literal|130
block|,
literal|243
block|,
literal|270
block|}
block|,
comment|/* MCS 18 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 19 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 20 */
block|{
literal|312
block|,
literal|347
block|,
literal|648
block|,
literal|720
block|}
block|,
comment|/* MCS 21 */
block|{
literal|351
block|,
literal|390
block|,
literal|729
block|,
literal|810
block|}
block|,
comment|/* MCS 22 */
block|{
literal|390
block|,
literal|433
block|,
literal|810
block|,
literal|900
block|}
block|,
comment|/* MCS 23 */
block|{
literal|52
block|,
literal|58
block|,
literal|108
block|,
literal|120
block|}
block|,
comment|/* MCS 24 */
block|{
literal|104
block|,
literal|116
block|,
literal|216
block|,
literal|240
block|}
block|,
comment|/* MCS 25 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 26 */
block|{
literal|208
block|,
literal|231
block|,
literal|432
block|,
literal|480
block|}
block|,
comment|/* MCS 27 */
block|{
literal|312
block|,
literal|347
block|,
literal|648
block|,
literal|720
block|}
block|,
comment|/* MCS 28 */
block|{
literal|416
block|,
literal|462
block|,
literal|864
block|,
literal|960
block|}
block|,
comment|/* MCS 29 */
block|{
literal|468
block|,
literal|520
block|,
literal|972
block|,
literal|1080
block|}
block|,
comment|/* MCS 30 */
block|{
literal|520
block|,
literal|578
block|,
literal|1080
block|,
literal|1200
block|}
block|,
comment|/* MCS 31 */
block|{
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|13
block|}
block|,
comment|/* MCS 32 */
block|{
literal|78
block|,
literal|87
block|,
literal|162
block|,
literal|180
block|}
block|,
comment|/* MCS 33 */
block|{
literal|104
block|,
literal|116
block|,
literal|216
block|,
literal|240
block|}
block|,
comment|/* MCS 34 */
block|{
literal|130
block|,
literal|144
block|,
literal|270
block|,
literal|300
block|}
block|,
comment|/* MCS 35 */
block|{
literal|117
block|,
literal|130
block|,
literal|243
block|,
literal|270
block|}
block|,
comment|/* MCS 36 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 37 */
block|{
literal|195
block|,
literal|217
block|,
literal|405
block|,
literal|450
block|}
block|,
comment|/* MCS 38 */
block|{
literal|104
block|,
literal|116
block|,
literal|216
block|,
literal|240
block|}
block|,
comment|/* MCS 39 */
block|{
literal|130
block|,
literal|144
block|,
literal|270
block|,
literal|300
block|}
block|,
comment|/* MCS 40 */
block|{
literal|130
block|,
literal|144
block|,
literal|270
block|,
literal|300
block|}
block|,
comment|/* MCS 41 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 42 */
block|{
literal|182
block|,
literal|202
block|,
literal|378
block|,
literal|420
block|}
block|,
comment|/* MCS 43 */
block|{
literal|182
block|,
literal|202
block|,
literal|378
block|,
literal|420
block|}
block|,
comment|/* MCS 44 */
block|{
literal|208
block|,
literal|231
block|,
literal|432
block|,
literal|480
block|}
block|,
comment|/* MCS 45 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 46 */
block|{
literal|195
block|,
literal|217
block|,
literal|405
block|,
literal|450
block|}
block|,
comment|/* MCS 47 */
block|{
literal|195
block|,
literal|217
block|,
literal|405
block|,
literal|450
block|}
block|,
comment|/* MCS 48 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 49 */
block|{
literal|273
block|,
literal|303
block|,
literal|567
block|,
literal|630
block|}
block|,
comment|/* MCS 50 */
block|{
literal|273
block|,
literal|303
block|,
literal|567
block|,
literal|630
block|}
block|,
comment|/* MCS 51 */
block|{
literal|312
block|,
literal|347
block|,
literal|648
block|,
literal|720
block|}
block|,
comment|/* MCS 52 */
block|{
literal|130
block|,
literal|144
block|,
literal|270
block|,
literal|300
block|}
block|,
comment|/* MCS 53 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 54 */
block|{
literal|182
block|,
literal|202
block|,
literal|378
block|,
literal|420
block|}
block|,
comment|/* MCS 55 */
block|{
literal|156
block|,
literal|173
block|,
literal|324
block|,
literal|360
block|}
block|,
comment|/* MCS 56 */
block|{
literal|182
block|,
literal|202
block|,
literal|378
block|,
literal|420
block|}
block|,
comment|/* MCS 57 */
block|{
literal|208
block|,
literal|231
block|,
literal|432
block|,
literal|480
block|}
block|,
comment|/* MCS 58 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 59 */
block|{
literal|208
block|,
literal|231
block|,
literal|432
block|,
literal|480
block|}
block|,
comment|/* MCS 60 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 61 */
block|{
literal|260
block|,
literal|289
block|,
literal|540
block|,
literal|600
block|}
block|,
comment|/* MCS 62 */
block|{
literal|260
block|,
literal|289
block|,
literal|540
block|,
literal|600
block|}
block|,
comment|/* MCS 63 */
block|{
literal|286
block|,
literal|318
block|,
literal|594
block|,
literal|660
block|}
block|,
comment|/* MCS 64 */
block|{
literal|195
block|,
literal|217
block|,
literal|405
block|,
literal|450
block|}
block|,
comment|/* MCS 65 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 66 */
block|{
literal|273
block|,
literal|303
block|,
literal|567
block|,
literal|630
block|}
block|,
comment|/* MCS 67 */
block|{
literal|234
block|,
literal|260
block|,
literal|486
block|,
literal|540
block|}
block|,
comment|/* MCS 68 */
block|{
literal|273
block|,
literal|303
block|,
literal|567
block|,
literal|630
block|}
block|,
comment|/* MCS 69 */
block|{
literal|312
block|,
literal|347
block|,
literal|648
block|,
literal|720
block|}
block|,
comment|/* MCS 70 */
block|{
literal|351
block|,
literal|390
block|,
literal|729
block|,
literal|810
block|}
block|,
comment|/* MCS 71 */
block|{
literal|312
block|,
literal|347
block|,
literal|648
block|,
literal|720
block|}
block|,
comment|/* MCS 72 */
block|{
literal|351
block|,
literal|390
block|,
literal|729
block|,
literal|810
block|}
block|,
comment|/* MCS 73 */
block|{
literal|390
block|,
literal|433
block|,
literal|810
block|,
literal|900
block|}
block|,
comment|/* MCS 74 */
block|{
literal|390
block|,
literal|433
block|,
literal|810
block|,
literal|900
block|}
block|,
comment|/* MCS 75 */
block|{
literal|429
block|,
literal|477
block|,
literal|891
block|,
literal|990
block|}
block|,
comment|/* MCS 76 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_ampdu_age
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* threshold for ampdu reorder q (ms) */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|ampdu_age
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_ampdu_age
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"AMPDU max reorder age (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_recv_bar_ena
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|recv_bar
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_recv_bar_ena
argument_list|,
literal|0
argument_list|,
literal|"BAR frame processing (ena/dis)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_addba_timeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timeout for ADDBA response */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|addba_timeout
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_addba_timeout
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"ADDBA request timeout (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_addba_backoff
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backoff after max ADDBA requests */
end_comment

begin_expr_stmt
name|SYSCTL_PROC
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|addba_backoff
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_addba_backoff
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_msecs_ticks
argument_list|,
literal|"I"
argument_list|,
literal|"ADDBA request backoff (ms)"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_addba_maxtries
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max ADDBA requests before backoff */
end_comment

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|addba_maxtries
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_addba_maxtries
argument_list|,
literal|0
argument_list|,
literal|"max ADDBA requests sent before backoff"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|int
name|ieee80211_bar_timeout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* timeout waiting for BAR response */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ieee80211_bar_maxtries
init|=
literal|50
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max BAR requests before DELBA */
end_comment

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|ht_recv_action_ba_addba_request
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|ht_recv_action_ba_addba_response
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|ht_recv_action_ba_delba
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|ht_recv_action_ht_mimopwrsave
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_recv_action_func
name|ht_recv_action_ht_txchwidth
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|ht_send_action_ba_addba
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|ht_send_action_ba_delba
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ieee80211_send_action_func
name|ht_send_action_ht_txchwidth
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|ieee80211_ht_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Setup HT parameters that depends on the clock frequency. 	 */
name|ieee80211_ampdu_age
operator|=
name|msecs_to_ticks
argument_list|(
literal|500
argument_list|)
expr_stmt|;
name|ieee80211_addba_timeout
operator|=
name|msecs_to_ticks
argument_list|(
literal|250
argument_list|)
expr_stmt|;
name|ieee80211_addba_backoff
operator|=
name|msecs_to_ticks
argument_list|(
literal|10
operator|*
literal|1000
argument_list|)
expr_stmt|;
name|ieee80211_bar_timeout
operator|=
name|msecs_to_ticks
argument_list|(
literal|250
argument_list|)
expr_stmt|;
comment|/* 	 * Register action frame handlers. 	 */
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
argument_list|,
name|ht_recv_action_ba_addba_request
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
argument_list|,
name|ht_recv_action_ba_addba_response
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_DELBA
argument_list|,
name|ht_recv_action_ba_delba
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_HT
argument_list|,
name|IEEE80211_ACTION_HT_MIMOPWRSAVE
argument_list|,
name|ht_recv_action_ht_mimopwrsave
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_HT
argument_list|,
name|IEEE80211_ACTION_HT_TXCHWIDTH
argument_list|,
name|ht_recv_action_ht_txchwidth
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
argument_list|,
name|ht_send_action_ba_addba
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
argument_list|,
name|ht_send_action_ba_addba
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_DELBA
argument_list|,
name|ht_send_action_ba_delba
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_HT
argument_list|,
name|IEEE80211_ACTION_HT_TXCHWIDTH
argument_list|,
name|ht_send_action_ht_txchwidth
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_ht
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_ht_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|int
name|ieee80211_ampdu_enable
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|null_addba_response_timeout
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_bar_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ampdu_tx_stop
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bar_stop_timer
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ampdu_rx_start
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|,
name|int
name|baseqctl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ampdu_rx_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ieee80211_ht_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
comment|/* setup default aggregation policy */
name|ic
operator|->
name|ic_recv_action
operator|=
name|ieee80211_recv_action
expr_stmt|;
name|ic
operator|->
name|ic_send_action
operator|=
name|ieee80211_send_action
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_enable
operator|=
name|ieee80211_ampdu_enable
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|ieee80211_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|ieee80211_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_response_timeout
operator|=
name|null_addba_response_timeout
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|ieee80211_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_bar_response
operator|=
name|ieee80211_bar_response
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_rx_start
operator|=
name|ampdu_rx_start
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_rx_stop
operator|=
name|ampdu_rx_stop
expr_stmt|;
name|ic
operator|->
name|ic_htprotmode
operator|=
name|IEEE80211_PROT_RTSCTS
expr_stmt|;
name|ic
operator|->
name|ic_curhtprotmode
operator|=
name|IEEE80211_HTINFO_OPMODE_PURE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_ht_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_ht_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
comment|/* driver can override defaults */
name|vap
operator|->
name|iv_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_8K
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_NA
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_limit
operator|=
name|vap
operator|->
name|iv_ampdu_rxmax
expr_stmt|;
name|vap
operator|->
name|iv_amsdu_limit
operator|=
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_MAXAMSDU
expr_stmt|;
comment|/* tx aggregation traffic thresholds */
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_BK
index|]
operator|=
literal|128
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_BE
index|]
operator|=
literal|64
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_VO
index|]
operator|=
literal|32
expr_stmt|;
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_VI
index|]
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTC_HT
condition|)
block|{
comment|/* 		 * Device is HT capable; enable all HT-related 		 * facilities by default. 		 * XXX these choices may be too aggressive. 		 */
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_HT
operator||
name|IEEE80211_FHT_HTCOMPAT
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_SHORTGI20
expr_stmt|;
comment|/* XXX infer from channel list? */
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
condition|)
block|{
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_USEHT40
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI40
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_SHORTGI40
expr_stmt|;
block|}
comment|/* enable RIFS if capable */
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTC_RIFS
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_RIFS
expr_stmt|;
comment|/* NB: A-MPDU and A-MSDU rx are mandated, these are tx only */
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_AMPDU_RX
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTC_AMPDU
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_AMPDU_TX
expr_stmt|;
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_AMSDU_RX
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTC_AMSDU
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_AMSDU_TX
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_TXSTBC
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_STBC_TX
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_RXSTBC
condition|)
name|vap
operator|->
name|iv_flags_ht
operator||=
name|IEEE80211_FHT_STBC_RX
expr_stmt|;
block|}
comment|/* NB: disable default legacy WDS, too many issues right now */
if|if
condition|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_WDSLEGACY
condition|)
name|vap
operator|->
name|iv_flags_ht
operator|&=
operator|~
name|IEEE80211_FHT_HT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_ht_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|int
name|ht_getrate
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|index
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
name|int
name|ratetype
parameter_list|)
block|{
name|int
name|mword
decl_stmt|,
name|rate
decl_stmt|;
name|mword
operator|=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|index
operator||
name|IEEE80211_RATE_MCS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mword
argument_list|)
operator|!=
name|IFM_IEEE80211_MCS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|ratetype
condition|)
block|{
case|case
literal|0
case|:
name|rate
operator|=
name|ieee80211_htrates
index|[
name|index
index|]
operator|.
name|ht20_rate_800ns
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|rate
operator|=
name|ieee80211_htrates
index|[
name|index
index|]
operator|.
name|ht20_rate_400ns
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|rate
operator|=
name|ieee80211_htrates
index|[
name|index
index|]
operator|.
name|ht40_rate_800ns
expr_stmt|;
break|break;
default|default:
name|rate
operator|=
name|ieee80211_htrates
index|[
name|index
index|]
operator|.
name|ht40_rate_400ns
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rate
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
name|printranges
block|{
name|int
name|minmcs
decl_stmt|;
name|int
name|maxmcs
decl_stmt|;
name|int
name|txstream
decl_stmt|;
name|int
name|ratetype
decl_stmt|;
name|int
name|htcapflags
decl_stmt|;
block|}
name|ranges
index|[]
init|=
block|{
block|{
literal|0
block|,
literal|7
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|8
block|,
literal|15
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|16
block|,
literal|23
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|24
block|,
literal|31
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|}
block|,
block|{
literal|32
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
name|IEEE80211_HTC_TXMCS32
block|}
block|,
block|{
literal|33
block|,
literal|38
block|,
literal|2
block|,
literal|0
block|,
name|IEEE80211_HTC_TXUNEQUAL
block|}
block|,
block|{
literal|39
block|,
literal|52
block|,
literal|3
block|,
literal|0
block|,
name|IEEE80211_HTC_TXUNEQUAL
block|}
block|,
block|{
literal|53
block|,
literal|76
block|,
literal|4
block|,
literal|0
block|,
name|IEEE80211_HTC_TXUNEQUAL
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|void
name|ht_rateprint
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|,
name|int
name|ratetype
parameter_list|)
block|{
name|int
name|minrate
decl_stmt|,
name|maxrate
decl_stmt|;
name|struct
name|printranges
modifier|*
name|range
decl_stmt|;
for|for
control|(
name|range
operator|=
name|ranges
init|;
name|range
operator|->
name|txstream
operator|!=
literal|0
condition|;
name|range
operator|++
control|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|<
name|range
operator|->
name|txstream
condition|)
continue|continue;
if|if
condition|(
name|range
operator|->
name|htcapflags
operator|&&
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|range
operator|->
name|htcapflags
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|ratetype
operator|<
name|range
operator|->
name|ratetype
condition|)
continue|continue;
name|minrate
operator|=
name|ht_getrate
argument_list|(
name|ic
argument_list|,
name|range
operator|->
name|minmcs
argument_list|,
name|mode
argument_list|,
name|ratetype
argument_list|)
expr_stmt|;
name|maxrate
operator|=
name|ht_getrate
argument_list|(
name|ic
argument_list|,
name|range
operator|->
name|maxmcs
argument_list|,
name|mode
argument_list|,
name|ratetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|maxmcs
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"MCS %d-%d: %d%sMbps - %d%sMbps\n"
argument_list|,
name|range
operator|->
name|minmcs
argument_list|,
name|range
operator|->
name|maxmcs
argument_list|,
name|minrate
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|minrate
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|?
literal|".5"
else|:
literal|""
operator|)
argument_list|,
name|maxrate
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|maxrate
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|?
literal|".5"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"MCS %d: %d%sMbps\n"
argument_list|,
name|range
operator|->
name|minmcs
argument_list|,
name|minrate
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|minrate
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|?
literal|".5"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|enum
name|ieee80211_phymode
name|mode
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|modestr
init|=
name|ieee80211_phymode_name
index|[
name|mode
index|]
decl_stmt|;
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s MCS 20MHz\n"
argument_list|,
name|modestr
argument_list|)
expr_stmt|;
name|ht_rateprint
argument_list|(
name|ic
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s MCS 20MHz SGI\n"
argument_list|,
name|modestr
argument_list|)
expr_stmt|;
name|ht_rateprint
argument_list|(
name|ic
argument_list|,
name|mode
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s MCS 40MHz:\n"
argument_list|,
name|modestr
argument_list|)
expr_stmt|;
name|ht_rateprint
argument_list|(
name|ic
argument_list|,
name|mode
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI40
operator|)
condition|)
block|{
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%s MCS 40MHz SGI:\n"
argument_list|,
name|modestr
argument_list|)
expr_stmt|;
name|ht_rateprint
argument_list|(
name|ic
argument_list|,
name|mode
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_ht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
operator|||
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"%dT%dR\n"
argument_list|,
name|ic
operator|->
name|ic_txstream
argument_list|,
name|ic
operator|->
name|ic_rxstream
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
condition|)
name|ht_announce
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
name|ht_announce
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|ieee80211_htrateset
name|htrateset
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|ieee80211_get_suphtrates
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
define|#
directive|define
name|ADDRATE
parameter_list|(
name|x
parameter_list|)
value|do {						\ 	htrateset.rs_rates[htrateset.rs_nrates] = x;			\ 	htrateset.rs_nrates++;						\ } while (0)
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
operator|&
name|htrateset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_htrateset
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_txstream
operator|*
literal|8
condition|;
name|i
operator|++
control|)
name|ADDRATE
argument_list|(
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_TXMCS32
operator|)
condition|)
name|ADDRATE
argument_list|(
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_TXUNEQUAL
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|33
init|;
name|i
operator|<=
literal|38
condition|;
name|i
operator|++
control|)
name|ADDRATE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>=
literal|3
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|39
init|;
name|i
operator|<=
literal|52
condition|;
name|i
operator|++
control|)
name|ADDRATE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|==
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|53
init|;
name|i
operator|<=
literal|76
condition|;
name|i
operator|++
control|)
name|ADDRATE
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|&
name|htrateset
return|;
undef|#
directive|undef
name|ADDRATE
block|}
end_function

begin_comment
comment|/*  * Receive processing.  */
end_comment

begin_comment
comment|/*  * Decap the encapsulated A-MSDU frames and dispatch all but  * the last for delivery.  The last frame is returned for   * delivery via the normal path.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_decap_amsdu
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|framelen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* discard 802.3 header inserted by ieee80211_decap */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_amsdu_decap
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Decap the first frame, bust it apart from the 		 * remainder and deliver.  We leave the last frame 		 * delivery to the caller (for consistency with other 		 * code paths, could also do it here). 		 */
name|m
operator|=
name|ieee80211_decap1
argument_list|(
name|m
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-msdu"
argument_list|,
literal|"%s"
argument_list|,
literal|"decap failed"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_amsdu_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|framelen
condition|)
break|break;
name|n
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|framelen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-msdu"
argument_list|,
literal|"%s"
argument_list|,
literal|"unable to split encapsulated frames"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_amsdu_split
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* NB: must reclaim */
return|return
name|NULL
return|;
block|}
name|vap
operator|->
name|iv_deliver_data
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Remove frame contents; each intermediate frame 		 * is required to be aligned to a 4-byte boundary. 		 */
name|m
operator|=
name|n
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup2
argument_list|(
name|framelen
argument_list|,
literal|4
argument_list|)
operator|-
name|framelen
argument_list|)
expr_stmt|;
comment|/* padding */
block|}
return|return
name|m
return|;
comment|/* last delivered by caller */
block|}
end_function

begin_comment
comment|/*  * Purge all frames in the A-MPDU re-order queue.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_purge
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_qbytes
operator|==
literal|0
operator|&&
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %u data, %u frames on ampdu rx q"
operator|,
name|rap
operator|->
name|rxa_qbytes
operator|,
name|rap
operator|->
name|rxa_qframes
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start A-MPDU rx/re-order processing for the specified TID.  */
end_comment

begin_function
specifier|static
name|int
name|ampdu_rx_start
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|,
name|int
name|baseqctl
parameter_list|)
block|{
name|int
name|bufsiz
init|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
decl_stmt|;
if|if
condition|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
condition|)
block|{
comment|/* 		 * AMPDU previously setup and not terminated with a DELBA, 		 * flush the reorder q's in case anything remains. 		 */
name|ampdu_rx_purge
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|rap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rap
argument_list|)
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_start
operator|=
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_flags
operator||=
name|IEEE80211_AGGR_RUNNING
operator||
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Public function; manually setup the RX ampdu state.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_rx_start_ext
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|tid
parameter_list|,
name|int
name|seq
parameter_list|,
name|int
name|baw
parameter_list|)
block|{
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
comment|/* XXX TODO: sanity check tid, seq, baw */
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
condition|)
block|{
comment|/* 		 * AMPDU previously setup and not terminated with a DELBA, 		 * flush the reorder q's in case anything remains. 		 */
name|ampdu_rx_purge
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|rap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rap
argument_list|)
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_wnd
operator|=
operator|(
name|baw
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|baw
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_start
operator|=
name|seq
expr_stmt|;
name|rap
operator|->
name|rxa_flags
operator||=
name|IEEE80211_AGGR_RUNNING
operator||
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: tid=%d, start=%d, wnd=%d, flags=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
name|tid
argument_list|,
name|seq
argument_list|,
name|rap
operator|->
name|rxa_wnd
argument_list|,
name|rap
operator|->
name|rxa_flags
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Stop A-MPDU rx processing for the specified TID.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|ampdu_rx_purge
argument_list|(
name|rap
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_flags
operator|&=
operator|~
operator|(
name|IEEE80211_AGGR_RUNNING
operator||
name|IEEE80211_AGGR_XCHGPEND
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a frame from the A-MPDU reorder queue.  The  * frame is fed back into ieee80211_input marked with an  * M_AMPDU_MPDU flag so it doesn't come back to us (it also  * permits ieee80211_input to optimize re-processing).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ampdu_dispatch
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU_MPDU
expr_stmt|;
comment|/* bypass normal processing */
comment|/* NB: rssi and noise are ignored w/ M_AMPDU_MPDU set */
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch as many frames as possible from the re-order queue.  * Frames will always be "at the front"; we process all frames  * up to the first empty slot in the window.  On completion we  * cleanup state if there are still pending frames in the current  * BA window.  We assume the frame at slot 0 is already handled  * by the caller; we always start at slot 1.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_dispatch
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* flush run of frames */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If frames remain, copy the mbuf pointers down so 	 * they correspond to the offsets in the new window. 	 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|rap
operator|->
name|rxa_qframes
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|j
operator|-
name|i
index|]
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
expr_stmt|;
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %d frames"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_copy
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
block|}
comment|/* 	 * Adjust the start of the BA window to 	 * reflect the frames just dispatched. 	 */
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_oor
operator|+=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch all frames in the A-MPDU re-order queue.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_flush
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_oor
operator|++
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Dispatch all frames in the A-MPDU re-order queue  * preceding the specified sequence number.  This logic  * handles window moves due to a received MSDU or BAR.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_flush_upto
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|ieee80211_seq
name|winstart
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Flush any complete MSDU's with a sequence number lower 	 * than winstart.  Gaps may exist.  Note that we may actually 	 * dispatch frames past winstart if a run continues; this is 	 * an optimization that avoids having to do a separate pass 	 * to dispatch frames after moving the BA window start. 	 */
name|seqno
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_oor
operator|++
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IEEE80211_SEQ_BA_BEFORE
argument_list|(
name|seqno
argument_list|,
name|winstart
argument_list|)
condition|)
break|break;
block|}
name|seqno
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|seqno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If frames remain, copy the mbuf pointers down so 	 * they correspond to the offsets in the new window. 	 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|rap
operator|->
name|rxa_qframes
decl_stmt|,
name|j
decl_stmt|;
comment|/* NB: this loop assumes i> 0 and/or rxa_m[0] is NULL */
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_m
index|[
literal|0
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"%s: BA window slot 0 occupied"
operator|,
name|__func__
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|j
operator|-
name|i
index|]
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
expr_stmt|;
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: lost %d frames, qframes %d off %d "
literal|"BA win<%d:%d> winstart %d"
operator|,
name|__func__
operator|,
name|n
operator|,
name|rap
operator|->
name|rxa_qframes
operator|,
name|i
operator|,
name|rap
operator|->
name|rxa_start
operator|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
operator|,
name|winstart
operator|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_copy
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
block|}
comment|/* 	 * Move the start of the BA window; we use the 	 * sequence number of the last MSDU that was 	 * passed up the stack+1 or winstart if stopped on 	 * a gap in the reorder buffer. 	 */
name|rap
operator|->
name|rxa_start
operator|=
name|seqno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received QoS data frame for an HT station.  Handle  * A-MPDU reordering: if this frame is received out of order  * and falls within the BA window hold onto it.  Otherwise if  * this frame completes a run, flush any pending frames.  We  * return 1 if the frame is consumed.  A 0 is returned if  * the frame should be processed normally by the caller.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_reorder
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_FC0_QOSDATA
define|\
value|(IEEE80211_FC0_TYPE_DATA|IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_VERSION_0)
define|#
directive|define
name|PROCESS
value|0
comment|/* caller should process frame */
define|#
directive|define
name|CONSUMED
value|1
comment|/* frame consumed, caller does nothing */
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_qosframe
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|ieee80211_seq
name|rxseq
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|int
name|off
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|m
operator|->
name|m_flags
operator|&
operator|(
name|M_AMPDU
operator||
name|M_AMPDU_MPDU
operator|)
operator|)
operator|==
name|M_AMPDU
argument_list|,
operator|(
literal|"!a-mpdu or already re-ordered, flags 0x%x"
operator|,
name|m
operator|->
name|m_flags
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT sta"
operator|)
argument_list|)
expr_stmt|;
comment|/* NB: m_len known to be sufficient */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|!=
name|IEEE80211_FC0_QOSDATA
condition|)
block|{
comment|/* 		 * Not QoS data, shouldn't get here but just 		 * return it to the caller for processing. 		 */
return|return
name|PROCESS
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_DSTODS
argument_list|(
name|wh
argument_list|)
condition|)
name|tid
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
index|[
literal|0
index|]
expr_stmt|;
else|else
name|tid
operator|=
name|wh
operator|->
name|i_qos
index|[
literal|0
index|]
expr_stmt|;
name|tid
operator|&=
name|IEEE80211_QOS_TID
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ADDBA request yet, don't touch. 		 */
return|return
name|PROCESS
return|;
block|}
name|rxseq
operator|=
name|le16toh
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|rxseq
operator|&
name|IEEE80211_SEQ_FRAG_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Fragments are not allowed; toss. 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"A-MPDU"
argument_list|,
literal|"fragment, rxseq 0x%x tid %u%s"
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_RETRY
condition|?
literal|" (retransmit)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_drop
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_drop
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|CONSUMED
return|;
block|}
name|rxseq
operator|>>=
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
name|rap
operator|->
name|rxa_nframes
operator|++
expr_stmt|;
name|again
label|:
if|if
condition|(
name|rxseq
operator|==
name|rap
operator|->
name|rxa_start
condition|)
block|{
comment|/* 		 * First frame in window. 		 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Dispatch as many packets as we can. 			 */
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_m
index|[
literal|0
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"unexpected dup"
operator|)
argument_list|)
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ampdu_rx_dispatch
argument_list|(
name|rap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
return|return
name|CONSUMED
return|;
block|}
else|else
block|{
comment|/* 			 * In order; advance window and notify 			 * caller to dispatch directly. 			 */
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|rxseq
argument_list|)
expr_stmt|;
return|return
name|PROCESS
return|;
block|}
block|}
comment|/* 	 * Frame is out of order; store if in the BA window. 	 */
comment|/* calculate offset in BA window */
name|off
operator|=
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|rap
operator|->
name|rxa_wnd
condition|)
block|{
comment|/* 		 * Common case (hopefully): in the BA window. 		 * Sec 9.10.7.6.2 a) (p.137) 		 */
comment|/*  		 * Check for frames sitting too long in the reorder queue. 		 * This should only ever happen if frames are not delivered 		 * without the sender otherwise notifying us (e.g. with a 		 * BAR to move the window).  Typically this happens because 		 * of vendor bugs that cause the sequence number to jump. 		 * When this happens we get a gap in the reorder queue that 		 * leaves frame sitting on the queue until they get pushed 		 * out due to window moves.  When the vendor does not send 		 * BAR this move only happens due to explicit packet sends 		 * 		 * NB: we only track the time of the oldest frame in the 		 * reorder q; this means that if we flush we might push 		 * frames that still "new"; if this happens then subsequent 		 * frames will result in BA window moves which cost something 		 * but is still better than a big throughput dip. 		 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
comment|/* XXX honor batimeout? */
if|if
condition|(
name|ticks
operator|-
name|rap
operator|->
name|rxa_age
operator|>
name|ieee80211_ampdu_age
condition|)
block|{
comment|/* 				 * Too long since we received the first 				 * frame; flush the reorder buffer. 				 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_age
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
name|ampdu_rx_flush
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|)
expr_stmt|;
block|}
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|rxseq
argument_list|)
expr_stmt|;
return|return
name|PROCESS
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * First frame, start aging timer. 			 */
name|rap
operator|->
name|rxa_age
operator|=
name|ticks
expr_stmt|;
block|}
comment|/* save packet */
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|off
index|]
operator|==
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|off
index|]
operator|=
name|m
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|++
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_reorder
operator|++
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-mpdu duplicate"
argument_list|,
literal|"seqno %u tid %u BA win<%u:%u>"
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_dup
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_dup
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|CONSUMED
return|;
block|}
if|if
condition|(
name|off
operator|<
name|IEEE80211_SEQ_BA_RANGE
condition|)
block|{
comment|/* 		 * Outside the BA window, but within range; 		 * flush the reorder q and move the window. 		 * Sec 9.10.7.6.2 b) (p.138) 		 */
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"move BA win<%u:%u> (%u frames) rxseq %u tid %u"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_move
operator|++
expr_stmt|;
comment|/* 		 * The spec says to flush frames up to but not including: 		 * 	WinStart_B = rxseq - rap->rxa_wnd + 1 		 * Then insert the frame or notify the caller to process 		 * it immediately.  We can safely do this by just starting 		 * over again because we know the frame will now be within 		 * the BA window. 		 */
comment|/* NB: rxa_wnd known to be>0 */
name|ampdu_rx_flush_upto
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
comment|/* 		 * Outside the BA window and out of range; toss. 		 * Sec 9.10.7.6.2 c) (p.138) 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"MPDU"
argument_list|,
literal|"BA win<%u:%u> (%u frames) rxseq %u tid %u%s"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_RETRY
condition|?
literal|" (retransmit)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_drop
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_drop
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|CONSUMED
return|;
block|}
undef|#
directive|undef
name|CONSUMED
undef|#
directive|undef
name|PROCESS
undef|#
directive|undef
name|IEEE80211_FC0_QOSDATA
block|}
end_function

begin_comment
comment|/*  * Process a BAR ctl frame.  Dispatch all frames up to  * the sequence number of the frame.  If this frame is  * out of range it's discarded.  */
end_comment

begin_function
name|void
name|ieee80211_recv_bar
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_frame_bar
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|ieee80211_seq
name|rxseq
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
operator|!
name|ieee80211_recv_bar_ena
condition|)
block|{
if|#
directive|if
literal|0
block|IEEE80211_DISCARD_MAC(vap, IEEE80211_MSG_11N, 		    ni->ni_macaddr, "BAR", "%s", "processing disabled");
endif|#
directive|endif
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_bad
operator|++
expr_stmt|;
return|return;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame_bar
operator|*
argument_list|)
expr_stmt|;
comment|/* XXX check basic BAR */
name|tid
operator|=
name|MS
argument_list|(
name|le16toh
argument_list|(
name|wh
operator|->
name|i_ctl
argument_list|)
argument_list|,
name|IEEE80211_BAR_TID
argument_list|)
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ADDBA request yet, don't touch. 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"BAR"
argument_list|,
literal|"no BA stream, tid %u"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_bad
operator|++
expr_stmt|;
return|return;
block|}
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_rx
operator|++
expr_stmt|;
name|rxseq
operator|=
name|le16toh
argument_list|(
name|wh
operator|->
name|i_seq
argument_list|)
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
if|if
condition|(
name|rxseq
operator|==
name|rap
operator|->
name|rxa_start
condition|)
return|return;
comment|/* calculate offset in BA window */
name|off
operator|=
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|IEEE80211_SEQ_BA_RANGE
condition|)
block|{
comment|/* 		 * Flush the reorder q up to rxseq and move the window. 		 * Sec 9.10.7.6.3 a) (p.138) 		 */
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"BAR moves BA win<%u:%u> (%u frames) rxseq %u tid %u"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_move
operator|++
expr_stmt|;
name|ampdu_rx_flush_upto
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|rxseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|rap
operator|->
name|rxa_wnd
condition|)
block|{
comment|/* 			 * BAR specifies a window start to the right of BA 			 * window; we must move it explicitly since 			 * ampdu_rx_flush_upto will not. 			 */
name|rap
operator|->
name|rxa_start
operator|=
name|rxseq
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Out of range; toss. 		 * Sec 9.10.7.6.3 b) (p.138) 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"BAR"
argument_list|,
literal|"BA win<%u:%u> (%u frames) rxseq %u tid %u%s"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_RETRY
condition|?
literal|" (retransmit)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_oow
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_drop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup HT-specific state in a node.  Called only  * when HT use is negotiated so we don't do extra  * work for temporary and/or legacy sta's.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called (%p)"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
comment|/* 		 * Clean AMPDU state on re-associate.  This handles the case 		 * where a station leaves w/o notifying us and then returns 		 * before node is reaped for inactivity. 		 */
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: calling cleanup (%p)"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|ieee80211_ht_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|WME_NUM_TID
condition|;
name|tid
operator|++
control|)
block|{
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|tap
operator|->
name|txa_tid
operator|=
name|tid
expr_stmt|;
name|tap
operator|->
name|txa_ni
operator|=
name|ni
expr_stmt|;
name|ieee80211_txampdu_init_pps
argument_list|(
name|tap
argument_list|)
expr_stmt|;
comment|/* NB: further initialization deferred */
block|}
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HT
operator||
name|IEEE80211_NODE_AMPDU
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cleanup HT-specific state in a node.  Called only  * when HT use has been marked.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called (%p)"
argument_list|,
name|__func__
argument_list|,
name|ni
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT node"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX optimize this */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_TID
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
condition|)
name|ampdu_tx_stop
argument_list|(
name|tap
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_TID
condition|;
name|i
operator|++
control|)
name|ic
operator|->
name|ic_ampdu_rx_stop
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
literal|0
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_HT_ALL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Age out HT resources for a station.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_age
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT sta"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|WME_NUM_TID
condition|;
name|tid
operator|++
control|)
block|{
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
continue|continue;
comment|/*  		 * Check for frames sitting too long in the reorder queue. 		 * See above for more details on what's happening here. 		 */
comment|/* XXX honor batimeout? */
if|if
condition|(
name|ticks
operator|-
name|rap
operator|->
name|rxa_age
operator|>
name|ieee80211_ampdu_age
condition|)
block|{
comment|/* 			 * Too long since we received the first 			 * frame; flush the reorder buffer. 			 */
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_rx_age
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
name|ampdu_rx_flush
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|findhtchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|htflags
parameter_list|)
block|{
return|return
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
operator|)
operator||
name|htflags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a channel to be HT/non-HT according to the vap's configuration.  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_ht_adjust_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_FHT_HT
condition|)
block|{
comment|/* promote to HT if possible */
if|if
condition|(
name|flags
operator|&
name|IEEE80211_FHT_USEHT40
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* NB: arbitrarily pick ht40+ over ht40- */
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT40U
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT40D
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT20
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* demote to legacy, HT use is disabled */
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
return|return
name|chan
return|;
block|}
end_function

begin_comment
comment|/*  * Setup HT-specific state for a legacy WDS peer.  */
end_comment

begin_function
name|void
name|ieee80211_ht_wds_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|KASSERT
argument_list|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HT
argument_list|,
operator|(
literal|"no HT requested"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check scan cache in case peer has an ap and we have info */
comment|/* 	 * If setup with a legacy channel; locate an HT channel. 	 * Otherwise if the inherited channel (from a companion 	 * AP) is suitable use it so we use the same location 	 * for the extension channel). 	 */
name|ni
operator|->
name|ni_chan
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
name|ieee80211_htchanflags
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI20
condition|)
name|ni
operator|->
name|ni_htcap
operator||=
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|ni
operator|->
name|ni_htcap
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
name|ni
operator|->
name|ni_chw
operator|=
literal|40
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI40
condition|)
name|ni
operator|->
name|ni_htcap
operator||=
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
block|}
else|else
block|{
name|ni
operator|->
name|ni_chw
operator|=
literal|20
expr_stmt|;
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
block|}
name|ni
operator|->
name|ni_htctlchan
operator|=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_ieee
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_RIFS
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_RIFS
expr_stmt|;
comment|/* XXX does it make sense to enable SMPS? */
name|ni
operator|->
name|ni_htopmode
operator|=
literal|0
expr_stmt|;
comment|/* XXX need protection state */
name|ni
operator|->
name|ni_htstbc
operator|=
literal|0
expr_stmt|;
comment|/* XXX need info */
for|for
control|(
name|tid
operator|=
literal|0
init|;
name|tid
operator|<
name|WME_NUM_TID
condition|;
name|tid
operator|++
control|)
block|{
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|tap
operator|->
name|txa_tid
operator|=
name|tid
expr_stmt|;
name|ieee80211_txampdu_init_pps
argument_list|(
name|tap
argument_list|)
expr_stmt|;
block|}
comment|/* NB: AMPDU tx/rx governed by IEEE80211_FHT_AMPDU_{TX,RX} */
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HT
operator||
name|IEEE80211_NODE_AMPDU
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Notify hostap vaps of a change in the HTINFO ie.  */
end_comment

begin_function
specifier|static
name|void
name|htinfo_notify
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
continue|continue;
if|if
condition|(
name|vap
operator|->
name|iv_state
operator|!=
name|IEEE80211_S_RUN
operator|||
operator|!
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|vap
operator|->
name|iv_bss
argument_list|,
literal|"HT bss occupancy change: %d sta, %d ht, "
literal|"%d ht40%s, HT protmode now 0x%x"
argument_list|,
name|ic
operator|->
name|ic_sta_assoc
argument_list|,
name|ic
operator|->
name|ic_ht_sta_assoc
argument_list|,
name|ic
operator|->
name|ic_ht40_sta_assoc
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags_ht
operator|&
name|IEEE80211_FHT_NONHT_PR
operator|)
condition|?
literal|", non-HT sta present"
else|:
literal|""
argument_list|,
name|ic
operator|->
name|ic_curhtprotmode
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|ieee80211_beacon_notify
argument_list|(
name|vap
argument_list|,
name|IEEE80211_BEACON_HTINFO
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Calculate HT protection mode from current  * state and handle updates.  */
end_comment

begin_function
specifier|static
name|void
name|htinfo_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|uint8_t
name|protmode
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_sta_assoc
operator|!=
name|ic
operator|->
name|ic_ht_sta_assoc
condition|)
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_MIXED
operator||
name|IEEE80211_HTINFO_NONHT_PRESENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_flags_ht
operator|&
name|IEEE80211_FHT_NONHT_PR
condition|)
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_PROTOPT
operator||
name|IEEE80211_HTINFO_NONHT_PRESENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_bsschan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
name|ic
operator|->
name|ic_sta_assoc
operator|!=
name|ic
operator|->
name|ic_ht40_sta_assoc
condition|)
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_HT20PR
expr_stmt|;
block|}
else|else
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_PURE
expr_stmt|;
block|}
if|if
condition|(
name|protmode
operator|!=
name|ic
operator|->
name|ic_curhtprotmode
condition|)
block|{
name|ic
operator|->
name|ic_curhtprotmode
operator|=
name|protmode
expr_stmt|;
name|htinfo_notify
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle an HT station joining a BSS.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_join
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
name|ic
operator|->
name|ic_ht_sta_assoc
operator|++
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
condition|)
name|ic
operator|->
name|ic_ht40_sta_assoc
operator|++
expr_stmt|;
block|}
name|htinfo_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle an HT station leaving a BSS.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
name|ic
operator|->
name|ic_ht_sta_assoc
operator|--
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
condition|)
name|ic
operator|->
name|ic_ht40_sta_assoc
operator|--
expr_stmt|;
block|}
name|htinfo_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public version of htinfo_update; used for processing  * beacon frames from overlapping bss.  *  * Caller can specify either IEEE80211_HTINFO_OPMODE_MIXED  * (on receipt of a beacon that advertises MIXED) or  * IEEE80211_HTINFO_OPMODE_PROTOPT (on receipt of a beacon  * from an overlapping legacy bss).  We treat MIXED with  * a higher precedence than PROTOPT (i.e. we will not change  * change PROTOPT -> MIXED; only MIXED -> PROTOPT).  This  * corresponds to how we handle things in htinfo_update.  */
end_comment

begin_function
name|void
name|ieee80211_htprot_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|protmode
parameter_list|)
block|{
define|#
directive|define
name|OPMODE
parameter_list|(
name|x
parameter_list|)
value|SM(x, IEEE80211_HTINFO_OPMODE)
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
comment|/* track non-HT station presence */
name|KASSERT
argument_list|(
name|protmode
operator|&
name|IEEE80211_HTINFO_NONHT_PRESENT
argument_list|,
operator|(
literal|"protmode 0x%x"
operator|,
name|protmode
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_flags_ht
operator||=
name|IEEE80211_FHT_NONHT_PR
expr_stmt|;
name|ic
operator|->
name|ic_lastnonht
operator|=
name|ticks
expr_stmt|;
if|if
condition|(
name|protmode
operator|!=
name|ic
operator|->
name|ic_curhtprotmode
operator|&&
operator|(
name|OPMODE
argument_list|(
name|ic
operator|->
name|ic_curhtprotmode
argument_list|)
operator|!=
name|IEEE80211_HTINFO_OPMODE_MIXED
operator|||
name|OPMODE
argument_list|(
name|protmode
argument_list|)
operator|==
name|IEEE80211_HTINFO_OPMODE_PROTOPT
operator|)
condition|)
block|{
comment|/* push beacon update */
name|ic
operator|->
name|ic_curhtprotmode
operator|=
name|protmode
expr_stmt|;
name|htinfo_notify
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|OPMODE
block|}
end_function

begin_comment
comment|/*  * Time out presence of an overlapping bss with non-HT  * stations.  When operating in hostap mode we listen for  * beacons from other stations and if we identify a non-HT  * station is present we update the opmode field of the  * HTINFO ie.  To identify when all non-HT stations are  * gone we time out this condition.  */
end_comment

begin_function
name|void
name|ieee80211_ht_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ht
operator|&
name|IEEE80211_FHT_NONHT_PR
operator|)
operator|&&
name|ieee80211_time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastnonht
operator|+
name|IEEE80211_NONHT_PRESENT_AGE
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|IEEE80211_NOTE(vap, IEEE80211_MSG_11N, ni, 		    "%s", "time out non-HT STA present on channel");
endif|#
directive|endif
name|ic
operator|->
name|ic_flags_ht
operator|&=
operator|~
name|IEEE80211_FHT_NONHT_PR
expr_stmt|;
name|htinfo_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process an 802.11n HT capabilities ie.  */
end_comment

begin_function
name|void
name|ieee80211_parse_htcap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
block|{
comment|/* 		 * Station used Vendor OUI ie to associate; 		 * mark the node so when we respond we'll use 		 * the Vendor OUI's and not the standard ie's. 		 */
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HTCOMPAT
expr_stmt|;
name|ie
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_HTCOMPAT
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_cap
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htparam
operator|=
name|ie
index|[
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_param
argument_list|)
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|htinfo_parse
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
parameter_list|)
block|{
name|uint16_t
name|w
decl_stmt|;
name|ni
operator|->
name|ni_htctlchan
operator|=
name|htinfo
operator|->
name|hi_ctrlchannel
expr_stmt|;
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|SM
argument_list|(
name|htinfo
operator|->
name|hi_byte1
argument_list|,
name|IEEE80211_HTINFO_2NDCHAN
argument_list|)
expr_stmt|;
name|w
operator|=
name|le16dec
argument_list|(
operator|&
name|htinfo
operator|->
name|hi_byte2
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htopmode
operator|=
name|SM
argument_list|(
name|w
argument_list|,
name|IEEE80211_HTINFO_OPMODE
argument_list|)
expr_stmt|;
name|w
operator|=
name|le16dec
argument_list|(
operator|&
name|htinfo
operator|->
name|hi_byte45
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htstbc
operator|=
name|SM
argument_list|(
name|w
argument_list|,
name|IEEE80211_HTINFO_BASIC_STBCMCS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an 802.11n HT info ie and save useful information  * to the node state.  Note this does not effect any state  * changes such as for channel width change.  */
end_comment

begin_function
name|void
name|ieee80211_parse_htinfo
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htinfo_parse
argument_list|(
name|ni
argument_list|,
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|ie
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle 11n channel switch.  Use the received HT ie's to  * identify the right channel to use.  If we cannot locate it  * in the channel table then fallback to legacy operation.  * Note that we use this information to identify the node's  * channel only; the caller is responsible for insuring any  * required channel change is done (e.g. in sta mode when  * parsing the contents of a beacon frame).  */
end_comment

begin_function
specifier|static
name|int
name|htinfo_update_chw
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|htflags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|int
name|chanflags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|chanflags
operator|=
operator|(
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
operator|)
operator||
name|htflags
expr_stmt|;
if|if
condition|(
name|chanflags
operator|!=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
condition|)
block|{
comment|/* XXX not right for ht40- */
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|,
name|chanflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|&&
operator|(
name|htflags
operator|&
name|IEEE80211_CHAN_HT40
operator|)
condition|)
block|{
comment|/* 			 * No HT40 channel entry in our table; fall back 			 * to HT20 operation.  This should not happen. 			 */
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|IEEE80211_NOTE(ni->ni_vap, 			    IEEE80211_MSG_ASSOC | IEEE80211_MSG_11N, ni, 			    "no HT40 channel (freq %u), falling back to HT20", 			    ni->ni_chan->ic_freq);
endif|#
directive|endif
comment|/* XXX stat */
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|!=
name|ni
operator|->
name|ni_chan
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"switch station to HT%d channel %u/0x%x"
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|?
literal|40
else|:
literal|20
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|c
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
block|}
comment|/* NB: caller responsible for forcing any channel change */
block|}
comment|/* update node's tx channel width */
name|ni
operator|->
name|ni_chw
operator|=
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|?
literal|40
else|:
literal|20
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update 11n MIMO PS state according to received htcap.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|htcap_update_mimo_ps
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint16_t
name|oflags
init|=
name|ni
operator|->
name|ni_flags
decl_stmt|;
switch|switch
condition|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SMPS
condition|)
block|{
case|case
name|IEEE80211_HTCAP_SMPS_DYNAMIC
case|:
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_MIMO_PS
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_MIMO_RTS
expr_stmt|;
break|break;
case|case
name|IEEE80211_HTCAP_SMPS_ENA
case|:
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_MIMO_PS
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_MIMO_RTS
expr_stmt|;
break|break;
case|case
name|IEEE80211_HTCAP_SMPS_OFF
case|:
default|default:
comment|/* disable on rx of reserved value */
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_MIMO_PS
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_MIMO_RTS
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|oflags
operator|^
name|ni
operator|->
name|ni_flags
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update short GI state according to received htcap  * and local settings.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|htcap_update_shortgi
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
operator|(
name|IEEE80211_NODE_SGI20
operator||
name|IEEE80211_NODE_SGI40
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI20
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI20
operator|)
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_SGI20
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_SHORTGI40
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI40
operator|)
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_SGI40
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse and update HT-related state extracted from  * the HT cap and info ie's.  */
end_comment

begin_function
name|int
name|ieee80211_ht_updateparams
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|htcapie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|htinfoie
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
decl_stmt|;
name|int
name|htflags
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ieee80211_parse_htcap
argument_list|(
name|ni
argument_list|,
name|htcapie
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_SMPS
condition|)
name|htcap_update_mimo_ps
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|htcap_update_shortgi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|htinfoie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|htinfoie
operator|+=
literal|4
expr_stmt|;
name|htinfo
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|htinfoie
expr_stmt|;
name|htinfo_parse
argument_list|(
name|ni
argument_list|,
name|htinfo
argument_list|)
expr_stmt|;
name|htflags
operator|=
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HT
operator|)
condition|?
name|IEEE80211_CHAN_HT20
else|:
literal|0
expr_stmt|;
comment|/* NB: honor operating mode constraint */
if|if
condition|(
operator|(
name|htinfo
operator|->
name|hi_byte1
operator|&
name|IEEE80211_HTINFO_TXWIDTH_2040
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_USEHT40
operator|)
condition|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_ht2ndchan
operator|==
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
condition|)
name|htflags
operator|=
name|IEEE80211_CHAN_HT40U
expr_stmt|;
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ht2ndchan
operator|==
name|IEEE80211_HTINFO_2NDCHAN_BELOW
condition|)
name|htflags
operator|=
name|IEEE80211_CHAN_HT40D
expr_stmt|;
block|}
if|if
condition|(
name|htinfo_update_chw
argument_list|(
name|ni
argument_list|,
name|htflags
argument_list|)
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|htinfo
operator|->
name|hi_byte1
operator|&
name|IEEE80211_HTINFO_RIFSMODE_PERM
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_RIFS
operator|)
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_RIFS
expr_stmt|;
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_RIFS
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse and update HT-related state extracted from the HT cap ie  * for a station joining an HT BSS.  */
end_comment

begin_function
name|void
name|ieee80211_ht_updatehtcap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|htcapie
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|int
name|htflags
decl_stmt|;
name|ieee80211_parse_htcap
argument_list|(
name|ni
argument_list|,
name|htcapie
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTCAP_SMPS
condition|)
name|htcap_update_mimo_ps
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|htcap_update_shortgi
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* NB: honor operating mode constraint */
comment|/* XXX 40 MHz intolerant */
name|htflags
operator|=
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_HT
operator|)
condition|?
name|IEEE80211_CHAN_HT20
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_USEHT40
operator|)
condition|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
argument_list|)
condition|)
name|htflags
operator|=
name|IEEE80211_CHAN_HT40U
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|vap
operator|->
name|iv_bss
operator|->
name|ni_chan
argument_list|)
condition|)
name|htflags
operator|=
name|IEEE80211_CHAN_HT40D
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|htinfo_update_chw
argument_list|(
name|ni
argument_list|,
name|htflags
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Install received HT rate set by parsing the HT cap ie.  */
end_comment

begin_function
name|int
name|ieee80211_setup_htrates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ie_htcap
modifier|*
name|htcap
decl_stmt|;
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|maxequalmcs
decl_stmt|,
name|maxunequalmcs
decl_stmt|;
name|maxequalmcs
operator|=
name|ic
operator|->
name|ic_txstream
operator|*
literal|8
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_TXUNEQUAL
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>=
literal|2
condition|)
name|maxunequalmcs
operator|=
literal|38
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>=
literal|3
condition|)
name|maxunequalmcs
operator|=
literal|52
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>=
literal|4
condition|)
name|maxunequalmcs
operator|=
literal|76
expr_stmt|;
block|}
else|else
name|maxunequalmcs
operator|=
literal|0
expr_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
name|memset
argument_list|(
name|rs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htcap
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htcap
operator|*
operator|)
name|ie
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|htcap
operator|->
name|hc_mcsset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|==
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"WARNING, HT rate set too large; only "
literal|"using %u rates"
argument_list|,
name|IEEE80211_HTRATE_MAXSIZE
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_rstoobig
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<=
literal|31
operator|&&
name|i
operator|>
name|maxequalmcs
condition|)
continue|continue;
if|if
condition|(
name|i
operator|==
literal|32
operator|&&
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_TXMCS32
operator|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|i
operator|>
literal|32
operator|&&
name|i
operator|>
name|maxunequalmcs
condition|)
continue|continue;
name|rs
operator|->
name|rs_rates
index|[
name|rs
operator|->
name|rs_nrates
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|(
expr|struct
name|ieee80211_rateset
operator|*
operator|)
name|rs
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark rates in a node's HT rate set as basic according  * to the information in the supplied HT info ie.  */
end_comment

begin_function
name|void
name|ieee80211_setup_basic_htrates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
decl_stmt|;
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htinfo
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|ie
expr_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"WARNING, empty HT rate set"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|htinfo
operator|->
name|hi_basicmcsset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|i
condition|)
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator||=
name|IEEE80211_RATE_BASIC
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ampdu_tx_setup
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|callout_init
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_SETUP
expr_stmt|;
name|tap
operator|->
name|txa_lastsample
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ampdu_tx_stop
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|tap
operator|->
name|txa_ni
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|tap
operator|->
name|txa_ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|tap
operator|->
name|txa_ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
argument_list|,
operator|(
literal|"txa_flags 0x%x tid %d ac %d"
operator|,
name|tap
operator|->
name|txa_flags
operator|,
name|tap
operator|->
name|txa_tid
operator|,
name|TID_TO_WME_AC
argument_list|(
name|tap
operator|->
name|txa_tid
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Stop BA stream if setup so driver has a chance 	 * to reclaim any resources it might have allocated. 	 */
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
comment|/* 	 * Stop any pending BAR transmit. 	 */
name|bar_stop_timer
argument_list|(
name|tap
argument_list|)
expr_stmt|;
comment|/* 	 * Reset packet estimate. 	 */
name|ieee80211_txampdu_init_pps
argument_list|(
name|tap
argument_list|)
expr_stmt|;
comment|/* NB: clearing NAK means we may re-send ADDBA */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
operator|(
name|IEEE80211_AGGR_SETUP
operator||
name|IEEE80211_AGGR_NAK
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ADDBA response timeout.  *  * If software aggregation and per-TID queue management was done here,  * that queue would be unpaused after the ADDBA timeout occurs.  */
end_comment

begin_function
specifier|static
name|void
name|addba_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|tap
operator|->
name|txa_ni
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
comment|/* XXX ? */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|tap
operator|->
name|txa_attempts
operator|++
expr_stmt|;
name|ic
operator|->
name|ic_addba_response_timeout
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addba_start_timeout
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX use CALLOUT_PENDING instead? */
name|callout_reset
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
name|ieee80211_addba_timeout
argument_list|,
name|addba_timeout
argument_list|,
name|tap
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|tap
operator|->
name|txa_nextrequest
operator|=
name|ticks
operator|+
name|ieee80211_addba_timeout
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addba_stop_timeout
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX use CALLOUT_PENDING instead? */
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|null_addba_response_timeout
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{ }
end_function

begin_comment
comment|/*  * Default method for requesting A-MPDU tx aggregation.  * We setup the specified state block and start a timer  * to wait for an ADDBA response frame.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|int
name|bufsiz
decl_stmt|;
comment|/* XXX locking */
name|tap
operator|->
name|txa_token
operator|=
name|dialogtoken
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_IMMEDIATE
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|addba_start_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Called by drivers that wish to request an ADDBA session be  * setup.  This brings it up and starts the request timer.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_tx_request_ext
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
operator|||
name|tid
operator|>
literal|15
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
comment|/* XXX locking */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do deferred setup of state */
name|ampdu_tx_setup
argument_list|(
name|tap
argument_list|)
expr_stmt|;
block|}
comment|/* XXX hack for not doing proper locking */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_NAK
expr_stmt|;
name|addba_start_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by drivers that have marked a session as active.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_tx_request_active_ext
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|tid
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
if|if
condition|(
name|tid
operator|<
literal|0
operator|||
name|tid
operator|>
literal|15
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|1
condition|)
block|{
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
name|tap
operator|->
name|txa_attempts
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* mark tid so we don't try again */
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_NAK
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for processing an A-MPDU tx aggregation  * response.  We shutdown any pending timer and update the  * state block according to the reply.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|int
name|bufsiz
decl_stmt|,
name|tid
decl_stmt|;
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
comment|/* XXX override our request? */
name|tap
operator|->
name|txa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
comment|/* XXX AC/TID */
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
name|tap
operator|->
name|txa_attempts
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* mark tid so we don't try again */
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_NAK
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for stopping A-MPDU tx aggregation.  * Any timer is cleared and we drain any pending frames.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
condition|)
block|{
comment|/* XXX clear aggregation queue */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
block|}
name|tap
operator|->
name|txa_attempts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received action frame using the default aggregation  * policy.  We intercept ADDBA-related frames and use them to  * update our aggregation state.  All other frames are passed up  * for processing by ieee80211_recv_action.  */
end_comment

begin_function
specifier|static
name|int
name|ht_recv_action_ba_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|uint8_t
name|dialogtoken
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|,
name|batimeout
decl_stmt|,
name|baseqctl
decl_stmt|;
name|uint16_t
name|args
index|[
literal|5
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|dialogtoken
operator|=
name|frm
index|[
literal|2
index|]
expr_stmt|;
name|baparamset
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|3
argument_list|)
expr_stmt|;
name|batimeout
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|5
argument_list|)
expr_stmt|;
name|baseqctl
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|7
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv ADDBA request: dialogtoken %u baparamset 0x%x "
literal|"(tid %d bufsiz %d) batimeout %d baseqctl %d:%d"
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
argument_list|,
name|batimeout
argument_list|,
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
argument_list|,
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
argument_list|)
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
comment|/* Send ADDBA response */
name|args
index|[
literal|0
index|]
operator|=
name|dialogtoken
expr_stmt|;
comment|/* 	 * NB: We ack only if the sta associated with HT and 	 * the ap is configured to do AMPDU rx (the latter 	 * violates the 11n spec and is mostly for testing). 	 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AMPDU_RX
operator|)
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_AMPDU_RX
operator|)
condition|)
block|{
comment|/* XXX handle ampdu_rx_start failure */
name|ic
operator|->
name|ic_ampdu_rx_start
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|,
name|baseqctl
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_STATUS_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"reject ADDBA request: %s"
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AMPDU_RX
condition|?
literal|"administratively disabled"
else|:
literal|"not negotiated for station"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_addba_reject
operator|++
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_STATUS_UNSPECIFIED
expr_stmt|;
block|}
comment|/* XXX honor rap flags? */
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|rap
operator|->
name|rxa_wnd
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|args
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ht_recv_action_ba_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|uint8_t
name|dialogtoken
decl_stmt|,
name|policy
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|,
name|batimeout
decl_stmt|,
name|code
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|bufsiz
decl_stmt|;
name|dialogtoken
operator|=
name|frm
index|[
literal|2
index|]
expr_stmt|;
name|code
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|3
argument_list|)
expr_stmt|;
name|baparamset
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|5
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|policy
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_POLICY
argument_list|)
expr_stmt|;
name|batimeout
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|7
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"ADDBA response"
argument_list|,
literal|"no pending ADDBA, tid %d dialogtoken %u "
literal|"code %d"
argument_list|,
name|tid
argument_list|,
name|dialogtoken
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_addba_norequest
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|dialogtoken
operator|!=
name|tap
operator|->
name|txa_token
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"ADDBA response"
argument_list|,
literal|"dialogtoken mismatch: waiting for %d, "
literal|"received %d, tid %d code %d"
argument_list|,
name|tap
operator|->
name|txa_token
argument_list|,
name|dialogtoken
argument_list|,
name|tid
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_addba_badtoken
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* NB: assumes IEEE80211_AGGR_IMMEDIATE is 1 */
if|if
condition|(
name|policy
operator|!=
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_IMMEDIATE
operator|)
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"ADDBA response"
argument_list|,
literal|"policy mismatch: expecting %s, "
literal|"received %s, tid %d code %d"
argument_list|,
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_IMMEDIATE
argument_list|,
name|policy
argument_list|,
name|tid
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_addba_badpolicy
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
if|#
directive|if
literal|0
comment|/* XXX we take MIN in ieee80211_addba_response */
block|if (bufsiz> IEEE80211_AGGR_BAWMAX) { 		IEEE80211_DISCARD_MAC(vap, 		    IEEE80211_MSG_ACTION | IEEE80211_MSG_11N, 		    ni->ni_macaddr, "ADDBA response", 		    "BA window too large: max %d, " 		    "received %d, tid %d code %d", 		    bufsiz, IEEE80211_AGGR_BAWMAX, tid, code); 		vap->iv_stats.is_addba_badbawinsize++; 		return 0; 	}
endif|#
directive|endif
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv ADDBA response: dialogtoken %u code %d "
literal|"baparamset 0x%x (tid %d bufsiz %d) batimeout %d"
argument_list|,
name|dialogtoken
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|bufsiz
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ht_recv_action_ba_delba
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|,
name|code
decl_stmt|;
name|int
name|tid
decl_stmt|;
name|baparamset
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|2
argument_list|)
expr_stmt|;
name|code
operator|=
name|le16dec
argument_list|(
name|frm
operator|+
literal|4
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_DELBAPS_TID
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv DELBA: baparamset 0x%x (tid %d initiator %d) "
literal|"code %d"
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_DELBAPS_INIT
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|baparamset
operator|&
name|IEEE80211_DELBAPS_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_rx_stop
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ht_recv_action_ht_txchwidth
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|int
name|chw
decl_stmt|;
name|chw
operator|=
operator|(
name|frm
index|[
literal|2
index|]
operator|==
name|IEEE80211_A_HT_TXCHWIDTH_2040
operator|)
condition|?
literal|40
else|:
literal|20
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT txchwidth, width %d%s"
argument_list|,
name|__func__
argument_list|,
name|chw
argument_list|,
name|ni
operator|->
name|ni_chw
operator|!=
name|chw
condition|?
literal|"*"
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|chw
operator|!=
name|ni
operator|->
name|ni_chw
condition|)
block|{
name|ni
operator|->
name|ni_chw
operator|=
name|chw
expr_stmt|;
comment|/* XXX notify on change */
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ht_recv_action_ht_mimopwrsave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_action_ht_mimopowersave
modifier|*
name|mps
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_action_ht_mimopowersave
operator|*
operator|)
name|frm
decl_stmt|;
comment|/* XXX check iv_htcaps */
if|if
condition|(
name|mps
operator|->
name|am_control
operator|&
name|IEEE80211_A_HT_MIMOPWRSAVE_ENA
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_MIMO_PS
expr_stmt|;
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_MIMO_PS
expr_stmt|;
if|if
condition|(
name|mps
operator|->
name|am_control
operator|&
name|IEEE80211_A_HT_MIMOPWRSAVE_MODE
condition|)
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_MIMO_RTS
expr_stmt|;
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_MIMO_RTS
expr_stmt|;
comment|/* XXX notify on change */
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT MIMO PS (%s%s)"
argument_list|,
name|__func__
argument_list|,
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_MIMO_PS
operator|)
condition|?
literal|"on"
else|:
literal|"off"
argument_list|,
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_MIMO_RTS
operator|)
condition|?
literal|"+rts"
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit processing.  */
end_comment

begin_comment
comment|/*  * Check if A-MPDU should be requested/enabled for a stream.  * We require a traffic rate above a per-AC threshold and we  * also handle backoff from previous failed attempts.  *  * Drivers may override this method to bring in information  * such as link state conditions in making the decision.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_ampdu_enable
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_avgpps
operator|<
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|TID_TO_WME_AC
argument_list|(
name|tap
operator|->
name|txa_tid
argument_list|)
index|]
condition|)
return|return
literal|0
return|;
comment|/* XXX check rssi? */
if|if
condition|(
name|tap
operator|->
name|txa_attempts
operator|>=
name|ieee80211_addba_maxtries
operator|&&
name|ieee80211_time_after
argument_list|(
name|ticks
argument_list|,
name|tap
operator|->
name|txa_nextrequest
argument_list|)
condition|)
block|{
comment|/* 		 * Don't retry too often; txa_nextrequest is set 		 * to the minimum interval we'll retry after 		 * ieee80211_addba_maxtries failed attempts are made. 		 */
return|return
literal|0
return|;
block|}
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"enable AMPDU on tid %d (%s), avgpps %d pkts %d attempt %d"
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|ieee80211_wme_acnames
index|[
name|TID_TO_WME_AC
argument_list|(
name|tap
operator|->
name|txa_tid
argument_list|)
index|]
argument_list|,
name|tap
operator|->
name|txa_avgpps
argument_list|,
name|tap
operator|->
name|txa_pkts
argument_list|,
name|tap
operator|->
name|txa_attempts
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Request A-MPDU tx aggregation.  Setup local state and  * issue an ADDBA request.  BA use will only happen after  * the other end replies with ADDBA response.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|args
index|[
literal|5
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|dialogtoken
decl_stmt|;
specifier|static
name|int
name|tokens
init|=
literal|0
decl_stmt|;
comment|/* XXX */
comment|/* XXX locking */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do deferred setup of state */
name|ampdu_tx_setup
argument_list|(
name|tap
argument_list|)
expr_stmt|;
block|}
comment|/* XXX hack for not doing proper locking */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_NAK
expr_stmt|;
name|dialogtoken
operator|=
operator|(
name|tokens
operator|+
literal|1
operator|)
operator|%
literal|63
expr_stmt|;
comment|/* XXX */
name|tid
operator|=
name|tap
operator|->
name|txa_tid
expr_stmt|;
name|tap
operator|->
name|txa_start
operator|=
name|ni
operator|->
name|ni_txseqs
index|[
name|tid
index|]
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|dialogtoken
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* NB: status code not used */
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|IEEE80211_AGGR_BAWMAX
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
comment|/* batimeout */
comment|/* NB: do first so there's no race against reply */
if|if
condition|(
operator|!
name|ic
operator|->
name|ic_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
condition|)
block|{
comment|/* unable to setup state, don't make request */
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: could not setup BA stream for TID %d AC %d"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|TID_TO_WME_AC
argument_list|(
name|tap
operator|->
name|txa_tid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* defer next try so we don't slam the driver with requests */
name|tap
operator|->
name|txa_attempts
operator|=
name|ieee80211_addba_maxtries
expr_stmt|;
comment|/* NB: check in case driver wants to override */
if|if
condition|(
name|tap
operator|->
name|txa_nextrequest
operator|<=
name|ticks
condition|)
name|tap
operator|->
name|txa_nextrequest
operator|=
name|ticks
operator|+
name|ieee80211_addba_backoff
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tokens
operator|=
name|dialogtoken
expr_stmt|;
comment|/* allocate token */
comment|/* NB: after calling ic_addba_request so driver can set txa_start */
name|args
index|[
literal|4
index|]
operator|=
name|SM
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
expr_stmt|;
return|return
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate an AMPDU tx stream.  State is reclaimed  * and the peer notified with a DelBA Action frame.  */
end_comment

begin_function
name|void
name|ieee80211_ampdu_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|reason
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|uint16_t
name|args
index|[
literal|4
index|]
decl_stmt|;
comment|/* XXX locking */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_BARPEND
expr_stmt|;
if|if
condition|(
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: stop BA stream for TID %d (reason: %d (%s))"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|reason
argument_list|,
name|ieee80211_reason_to_string
argument_list|(
name|reason
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_stop
operator|++
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|tap
operator|->
name|txa_tid
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_DELBAPS_INIT
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
name|reason
expr_stmt|;
comment|/* XXX reason code */
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_DELBA
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: BA stream for TID %d not running "
literal|"(reason: %d (%s))"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|reason
argument_list|,
name|ieee80211_reason_to_string
argument_list|(
name|reason
argument_list|)
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_stop_failed
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* XXX */
end_comment

begin_function_decl
specifier|static
name|void
name|bar_start_timer
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|bar_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
name|arg
decl_stmt|;
name|struct
name|ieee80211_node
modifier|*
name|ni
init|=
name|tap
operator|->
name|txa_ni
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
argument_list|,
operator|(
literal|"bar/addba collision, flags 0x%x"
operator|,
name|tap
operator|->
name|txa_flags
operator|)
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: tid %u flags 0x%x attempts %d"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|tap
operator|->
name|txa_flags
argument_list|,
name|tap
operator|->
name|txa_attempts
argument_list|)
expr_stmt|;
comment|/* guard against race with bar_tx_complete */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_BARPEND
operator|)
operator|==
literal|0
condition|)
return|return;
comment|/* XXX ? */
if|if
condition|(
name|tap
operator|->
name|txa_attempts
operator|>=
name|ieee80211_bar_maxtries
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|ni
operator|->
name|ni_vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_tx_fail
operator|++
expr_stmt|;
comment|/* 		 * If (at least) the last BAR TX timeout was due to 		 * an ieee80211_send_bar() failures, then we need 		 * to make sure we notify the driver that a BAR 		 * TX did occur and fail.  This gives the driver 		 * a chance to undo any queue pause that may 		 * have occured. 		 */
name|ic
operator|->
name|ic_bar_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ampdu_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|IEEE80211_REASON_TIMEOUT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ni
operator|->
name|ni_vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_tx_retry
operator|++
expr_stmt|;
if|if
condition|(
name|ieee80211_send_bar
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|tap
operator|->
name|txa_seqpending
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: failed to TX, starting timer\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
comment|/* 			 * If ieee80211_send_bar() fails here, the 			 * timer may have stopped and/or the pending 			 * flag may be clear.  Because of this, 			 * fake the BARPEND and reset the timer. 			 * A retransmission attempt will then occur 			 * during the next timeout. 			 */
comment|/* XXX locking */
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_BARPEND
expr_stmt|;
name|bar_start_timer
argument_list|(
name|tap
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|bar_start_timer
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|tap
operator|->
name|txa_ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|tap
operator|->
name|txa_ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|callout_reset
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
name|ieee80211_bar_timeout
argument_list|,
name|bar_timeout
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bar_stop_timer
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|tap
operator|->
name|txa_ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|tap
operator|->
name|txa_ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|callout_stop
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bar_tx_complete
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
name|arg
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: tid %u flags 0x%x pending %d status %d"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|,
name|tap
operator|->
name|txa_flags
argument_list|,
name|callout_pending
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|)
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_tx
operator|++
expr_stmt|;
comment|/* XXX locking */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_BARPEND
operator|)
operator|&&
name|callout_pending
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|)
condition|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
comment|/* ACK'd */
name|bar_stop_timer
argument_list|(
name|tap
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_bar_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* NB: just let timer expire so we pace requests */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_bar_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|tap
operator|->
name|txa_ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|tap
operator|->
name|txa_ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* got ACK */
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"BAR moves BA win<%u:%u> (%u frames) txseq %u tid %u"
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|tap
operator|->
name|txa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|tap
operator|->
name|txa_qframes
argument_list|,
name|tap
operator|->
name|txa_seqpending
argument_list|,
name|tap
operator|->
name|txa_tid
argument_list|)
expr_stmt|;
comment|/* NB: timer already stopped in bar_tx_complete */
name|tap
operator|->
name|txa_start
operator|=
name|tap
operator|->
name|txa_seqpending
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_BARPEND
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit a BAR frame to the specified node.  The  * BAR contents are drawn from the supplied aggregation  * state associated with the node.  *  * NB: we only handle immediate ACK w/ compressed bitmap.  */
end_comment

begin_function
name|int
name|ieee80211_send_bar
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|ieee80211_seq
name|seq
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { vap->iv_stats._v++; ret = _x; goto bad; } while (0)
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_frame_bar
modifier|*
name|bar
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint16_t
name|barctl
decl_stmt|,
name|barseqctl
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|ret
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|tap
operator|->
name|txa_ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|tap
operator|->
name|txa_ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* no ADDBA response, should not happen */
comment|/* XXX stat+msg */
return|return
name|EINVAL
return|;
block|}
comment|/* XXX locking */
name|bar_stop_timer
argument_list|(
name|tap
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ieee80211_add_callback
argument_list|(
name|m
argument_list|,
name|bar_tx_complete
argument_list|,
name|tap
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
comment|/* XXX */
comment|/* NOTREACHED */
block|}
name|bar
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_bar
operator|*
argument_list|)
expr_stmt|;
name|bar
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_BAR
expr_stmt|;
name|bar
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|bar
operator|->
name|i_ra
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|bar
operator|->
name|i_ta
argument_list|,
name|vap
operator|->
name|iv_myaddr
argument_list|)
expr_stmt|;
name|tid
operator|=
name|tap
operator|->
name|txa_tid
expr_stmt|;
name|barctl
operator|=
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_IMMEDIATE
condition|?
literal|0
else|:
name|IEEE80211_BAR_NOACK
operator|)
operator||
name|IEEE80211_BAR_COMP
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAR_TID
argument_list|)
expr_stmt|;
name|barseqctl
operator|=
name|SM
argument_list|(
name|seq
argument_list|,
name|IEEE80211_BAR_SEQ_START
argument_list|)
expr_stmt|;
comment|/* NB: known to have proper alignment */
name|bar
operator|->
name|i_ctl
operator|=
name|htole16
argument_list|(
name|barctl
argument_list|)
expr_stmt|;
name|bar
operator|->
name|i_seq
operator|=
name|htole16
argument_list|(
name|barseqctl
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_bar
argument_list|)
expr_stmt|;
name|M_WME_SETAC
argument_list|(
name|m
argument_list|,
name|WME_AC_VO
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
comment|/* XXX tx_ctl? */
comment|/* XXX locking */
comment|/* init/bump attempts counter */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_BARPEND
operator|)
operator|==
literal|0
condition|)
name|tap
operator|->
name|txa_attempts
operator|=
literal|1
expr_stmt|;
else|else
name|tap
operator|->
name|txa_attempts
operator|++
expr_stmt|;
name|tap
operator|->
name|txa_seqpending
operator|=
name|seq
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_BARPEND
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send BAR: tid %u ctl 0x%x start %u (attempt %d)"
argument_list|,
name|tid
argument_list|,
name|barctl
argument_list|,
name|seq
argument_list|,
name|tap
operator|->
name|txa_attempts
argument_list|)
expr_stmt|;
comment|/* 	 * ic_raw_xmit will free the node reference 	 * regardless of queue/TX success or failure. 	 */
name|IEEE80211_TX_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_raw_output
argument_list|(
name|vap
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|IEEE80211_TX_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send BAR: failed: (ret = %d)\n"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* xmit failed, clear state flag */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_BARPEND
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_tx_fail
operator|++
expr_stmt|;
return|return
name|ret
return|;
block|}
comment|/* XXX hack against tx complete happening before timer is started */
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_BARPEND
condition|)
name|bar_start_timer
argument_list|(
name|tap
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|IEEE80211_NOTE
argument_list|(
name|tap
operator|->
name|txa_ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|tap
operator|->
name|txa_ni
argument_list|,
literal|"%s: bad! ret=%d"
argument_list|,
name|__func__
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_ampdu_bar_tx_fail
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|senderr
block|}
end_function

begin_function
specifier|static
name|int
name|ht_action_output
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211_bpf_params
name|params
decl_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|ibp_pri
operator|=
name|WME_AC_VO
expr_stmt|;
name|params
operator|.
name|ibp_rate0
operator|=
name|ni
operator|->
name|ni_txparms
operator|->
name|mgmtrate
expr_stmt|;
comment|/* NB: we know all frames are unicast */
name|params
operator|.
name|ibp_try0
operator|=
name|ni
operator|->
name|ni_txparms
operator|->
name|maxretry
expr_stmt|;
name|params
operator|.
name|ibp_power
operator|=
name|ni
operator|->
name|ni_txpower
expr_stmt|;
return|return
name|ieee80211_mgmt_output
argument_list|(
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_SUBTYPE_ACTION
argument_list|,
operator|&
name|params
argument_list|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
end_define

begin_comment
comment|/*  * Send an action management frame.  The arguments are stuff  * into a frame without inspection; the caller is assumed to  * prepare them carefully (e.g. based on the aggregation state).  */
end_comment

begin_function
specifier|static
name|int
name|ht_send_action_ba_addba
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
modifier|*
name|args
init|=
name|arg0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send ADDBA %s: dialogtoken %d status %d "
literal|"baparamset 0x%x (tid %d) batimeout 0x%x baseqctl 0x%x"
argument_list|,
operator|(
name|action
operator|==
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
operator|)
condition|?
literal|"request"
else|:
literal|"response"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|MS
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
comment|/* XXX may action payload */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_action_ba_addbaresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* dialog token */
if|if
condition|(
name|action
operator|==
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
condition|)
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* status code */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* baparamset */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* batimeout */
if|if
condition|(
name|action
operator|==
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
condition|)
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* baseqctl */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|ht_action_output
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ht_send_action_ba_delba
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
modifier|*
name|args
init|=
name|arg0
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|baparamset
operator|=
name|SM
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|IEEE80211_DELBAPS_TID
argument_list|)
operator||
name|args
index|[
literal|1
index|]
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send DELBA action: tid %d, initiator %d reason %d (%s)"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|ieee80211_reason_to_string
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
comment|/* XXX may action payload */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_action_ba_addbaresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|baparamset
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* reason code */
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|ht_action_output
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|ht_send_action_ht_txchwidth
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send HT txchwidth: width %d"
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|?
literal|40
else|:
literal|20
argument_list|)
expr_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
comment|/* XXX may action payload */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_action_ba_addbaresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|?
name|IEEE80211_A_HT_TXCHWIDTH_2040
else|:
name|IEEE80211_A_HT_TXCHWIDTH_20
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|ht_action_output
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
return|;
block|}
else|else
block|{
name|vap
operator|->
name|iv_stats
operator|.
name|is_tx_nobuf
operator|++
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|ADDSHORT
end_undef

begin_comment
comment|/*  * Construct the MCS bit mask for inclusion in an HT capabilities  * information element.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_mcsset
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|uint8_t
modifier|*
name|frm
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint8_t
name|txparams
decl_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ic
operator|->
name|ic_rxstream
operator|>
literal|0
operator|&&
name|ic
operator|->
name|ic_rxstream
operator|<=
literal|4
operator|)
argument_list|,
operator|(
literal|"ic_rxstream %d out of range"
operator|,
name|ic
operator|->
name|ic_rxstream
operator|)
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
operator|(
name|ic
operator|->
name|ic_txstream
operator|>
literal|0
operator|&&
name|ic
operator|->
name|ic_txstream
operator|<=
literal|4
operator|)
argument_list|,
operator|(
literal|"ic_txstream %d out of range"
operator|,
name|ic
operator|->
name|ic_txstream
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ic
operator|->
name|ic_rxstream
operator|*
literal|8
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|frm
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_RXMCS32
operator|)
condition|)
name|setbit
argument_list|(
name|frm
argument_list|,
literal|32
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_RXUNEQUAL
condition|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_rxstream
operator|>=
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|33
init|;
name|i
operator|<=
literal|38
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|frm
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_rxstream
operator|>=
literal|3
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|39
init|;
name|i
operator|<=
literal|52
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|frm
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ic
operator|->
name|ic_txstream
operator|>=
literal|4
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|53
init|;
name|i
operator|<=
literal|76
condition|;
name|i
operator|++
control|)
name|setbit
argument_list|(
name|frm
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ic
operator|->
name|ic_rxstream
operator|!=
name|ic
operator|->
name|ic_txstream
condition|)
block|{
name|txparams
operator|=
literal|0x1
expr_stmt|;
comment|/* TX MCS set defined */
name|txparams
operator||=
literal|0x2
expr_stmt|;
comment|/* TX RX MCS not equal */
name|txparams
operator||=
operator|(
name|ic
operator|->
name|ic_txstream
operator|-
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* num TX streams */
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_TXUNEQUAL
condition|)
name|txparams
operator||=
literal|0x16
expr_stmt|;
comment|/* TX unequal modulation sup */
block|}
else|else
name|txparams
operator|=
literal|0
expr_stmt|;
name|frm
index|[
literal|12
index|]
operator|=
name|txparams
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add body of an HTCAP information element.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_htcap_body
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|uint16_t
name|caps
decl_stmt|,
name|extcaps
decl_stmt|;
name|int
name|rxmax
decl_stmt|,
name|density
decl_stmt|;
comment|/* HT capabilities */
name|caps
operator|=
name|vap
operator|->
name|iv_htcaps
operator|&
literal|0xffff
expr_stmt|;
comment|/* 	 * Note channel width depends on whether we are operating as 	 * a sta or not.  When operating as a sta we are generating 	 * a request based on our desired configuration.  Otherwise 	 * we are operational and the channel attributes identify 	 * how we've been setup (which might be different if a fixed 	 * channel is specified). 	 */
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
comment|/* override 20/40 use based on config */
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_USEHT40
condition|)
name|caps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
else|else
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
comment|/* Start by using the advertised settings */
name|rxmax
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_htparam
argument_list|,
name|IEEE80211_HTCAP_MAXRXAMPDU
argument_list|)
expr_stmt|;
name|density
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_htparam
argument_list|,
name|IEEE80211_HTCAP_MPDUDENSITY
argument_list|)
expr_stmt|;
comment|/* Cap at VAP rxmax */
if|if
condition|(
name|rxmax
operator|>
name|vap
operator|->
name|iv_ampdu_rxmax
condition|)
name|rxmax
operator|=
name|vap
operator|->
name|iv_ampdu_rxmax
expr_stmt|;
comment|/* 		 * If the VAP ampdu density value greater, use that. 		 * 		 * (Larger density value == larger minimum gap between A-MPDU 		 * subframes.) 		 */
if|if
condition|(
name|vap
operator|->
name|iv_ampdu_density
operator|>
name|density
condition|)
name|density
operator|=
name|vap
operator|->
name|iv_ampdu_density
expr_stmt|;
comment|/* 		 * NB: Hardware might support HT40 on some but not all 		 * channels. We can't determine this earlier because only 		 * after association the channel is upgraded to HT based 		 * on the negotiated capabilities. 		 */
if|if
condition|(
name|ni
operator|->
name|ni_chan
operator|!=
name|IEEE80211_CHAN_ANYC
operator|&&
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
name|IEEE80211_CHAN_HT40U
argument_list|)
operator|==
name|NULL
operator|&&
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
name|IEEE80211_CHAN_HT40D
argument_list|)
operator|==
name|NULL
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
block|}
else|else
block|{
comment|/* override 20/40 use based on current channel */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|caps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
else|else
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
comment|/* XXX TODO should it start by using advertised settings? */
name|rxmax
operator|=
name|vap
operator|->
name|iv_ampdu_rxmax
expr_stmt|;
name|density
operator|=
name|vap
operator|->
name|iv_ampdu_density
expr_stmt|;
block|}
comment|/* adjust short GI based on channel and config */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI20
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_SHORTGI40
operator|)
operator|==
literal|0
operator|||
operator|(
name|caps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
comment|/* adjust STBC based on receive capabilities */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_STBC_RX
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_RXSTBC
expr_stmt|;
comment|/* XXX TODO: adjust LDPC based on receive capabilities */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|caps
argument_list|)
expr_stmt|;
comment|/* HT parameters */
operator|*
name|frm
operator|=
name|SM
argument_list|(
name|rxmax
argument_list|,
name|IEEE80211_HTCAP_MAXRXAMPDU
argument_list|)
operator||
name|SM
argument_list|(
name|density
argument_list|,
name|IEEE80211_HTCAP_MPDUDENSITY
argument_list|)
expr_stmt|;
name|frm
operator|++
expr_stmt|;
comment|/* pre-zero remainder of ie */
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_mcsset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* supported MCS set */
comment|/* 	 * XXX: For sta mode the rate set should be restricted based 	 * on the AP's capabilities, but ni_htrates isn't setup when 	 * we're called to form an AssocReq frame so for now we're 	 * restricted to the device capabilities. 	 */
name|ieee80211_set_mcsset
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|frm
argument_list|)
expr_stmt|;
name|frm
operator|+=
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_extcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_mcsset
argument_list|)
expr_stmt|;
comment|/* HT extended capabilities */
name|extcaps
operator|=
name|vap
operator|->
name|iv_htextcaps
operator|&
literal|0xffff
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|extcaps
argument_list|)
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_txbf
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_comment
comment|/*  * Add 802.11n HT capabilities information element  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htcap
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_HTCAP
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
literal|2
expr_stmt|;
return|return
name|ieee80211_add_htcap_body
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add Broadcom OUI wrapped standard HTCAP ie; this is  * used for compatibility w/ pre-draft implementations.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htcap_vendor
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|4
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|5
index|]
operator|=
name|BCM_OUI_HTCAP
expr_stmt|;
return|return
name|ieee80211_add_htcap_body
argument_list|(
name|frm
operator|+
literal|6
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct the MCS bit mask of basic rates  * for inclusion in an HT information element.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_basic_htrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
operator|&&
name|r
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
comment|/* NB: this assumes a particular implementation */
name|setbit
argument_list|(
name|frm
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Update the HTINFO ie for a beacon frame.  */
end_comment

begin_function
name|void
name|ieee80211_ht_update_beacon
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|)
block|{
define|#
directive|define
name|PROTMODE
value|(IEEE80211_HTINFO_OPMODE|IEEE80211_HTINFO_NONHT_PRESENT)
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|bsschan
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|ht
init|=
operator|(
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|bo
operator|->
name|bo_htinfo
decl_stmt|;
name|ni
operator|=
name|ieee80211_ref_node
argument_list|(
name|vap
operator|->
name|iv_bss
argument_list|)
expr_stmt|;
name|bsschan
operator|=
name|ni
operator|->
name|ni_chan
expr_stmt|;
comment|/* XXX only update on channel change */
name|ht
operator|->
name|hi_ctrlchannel
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|bsschan
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_RIFS
condition|)
name|ht
operator|->
name|hi_byte1
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PERM
expr_stmt|;
else|else
name|ht
operator|->
name|hi_byte1
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PROH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
else|else
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
comment|/* protection mode */
name|ht
operator|->
name|hi_byte2
operator|=
operator|(
name|ht
operator|->
name|hi_byte2
operator|&
operator|~
name|PROTMODE
operator|)
operator||
name|ic
operator|->
name|ic_curhtprotmode
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* XXX propagate to vendor ie's */
undef|#
directive|undef
name|PROTMODE
block|}
end_function

begin_comment
comment|/*  * Add body of an HTINFO information element.  *  * NB: We don't use struct ieee80211_ie_htinfo because we can  * be called to fillin both a standard ie and a compat ie that  * has a vendor OUI at the front.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_htinfo_body
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
comment|/* pre-zero remainder of ie */
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* primary/control channel center */
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_RIFS
condition|)
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PERM
expr_stmt|;
else|else
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PROH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
else|else
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
name|ic
operator|->
name|ic_curhtprotmode
expr_stmt|;
name|frm
operator|+=
literal|5
expr_stmt|;
comment|/* basic MCS set */
name|ieee80211_set_basic_htrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_htrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|,
name|hi_basicmcsset
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Add 802.11n HT information information element.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htinfo
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_HTINFO
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
expr_stmt|;
return|return
name|ieee80211_add_htinfo_body
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add Broadcom OUI wrapped standard HTINFO ie; this is  * used for compatibility w/ pre-draft implementations.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htinfo_vendor
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|4
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|5
index|]
operator|=
name|BCM_OUI_HTINFO
expr_stmt|;
return|return
name|ieee80211_add_htinfo_body
argument_list|(
name|frm
operator|+
literal|6
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

end_unit

