begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11n protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_comment
comment|/* define here, used throughout file */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
end_define

begin_comment
comment|/* XXX need max array size */
end_comment

begin_decl_stmt
specifier|const
name|int
name|ieee80211_htrates
index|[
literal|16
index|]
init|=
block|{
literal|13
block|,
comment|/* IFM_IEEE80211_MCS0 */
literal|26
block|,
comment|/* IFM_IEEE80211_MCS1 */
literal|39
block|,
comment|/* IFM_IEEE80211_MCS2 */
literal|52
block|,
comment|/* IFM_IEEE80211_MCS3 */
literal|78
block|,
comment|/* IFM_IEEE80211_MCS4 */
literal|104
block|,
comment|/* IFM_IEEE80211_MCS5 */
literal|117
block|,
comment|/* IFM_IEEE80211_MCS6 */
literal|130
block|,
comment|/* IFM_IEEE80211_MCS7 */
literal|26
block|,
comment|/* IFM_IEEE80211_MCS8 */
literal|52
block|,
comment|/* IFM_IEEE80211_MCS9 */
literal|78
block|,
comment|/* IFM_IEEE80211_MCS10 */
literal|104
block|,
comment|/* IFM_IEEE80211_MCS11 */
literal|156
block|,
comment|/* IFM_IEEE80211_MCS12 */
literal|208
block|,
comment|/* IFM_IEEE80211_MCS13 */
literal|234
block|,
comment|/* IFM_IEEE80211_MCS14 */
literal|260
block|,
comment|/* IFM_IEEE80211_MCS15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_htrateset
name|ieee80211_rateset_11n
init|=
block|{
literal|16
block|,
block|{
comment|/* MCS: 6.5   13 19.5   26   39  52 58.5  65  13  26 */
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
comment|/*       39   52   78  104  117, 130 */
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_AMPDU_AGE
end_ifdef

begin_comment
comment|/* XXX public for sysctl hookup */
end_comment

begin_decl_stmt
name|int
name|ieee80211_ampdu_age
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* threshold for ampdu reorder q (ms) */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|ieee80211_recv_bar_ena
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IEEE80211_AGGR_TIMEOUT
value|msecs_to_ticks(250)
end_define

begin_define
define|#
directive|define
name|IEEE80211_AGGR_MINRETRY
value|msecs_to_ticks(10*1000)
end_define

begin_define
define|#
directive|define
name|IEEE80211_AGGR_MAXTRIES
value|3
end_define

begin_function_decl
specifier|static
name|int
name|ieee80211_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_aggr_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ieee80211_ht_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_AMPDU_AGE
if|if
condition|(
name|ieee80211_ampdu_age
operator|==
operator|-
literal|1
condition|)
name|ieee80211_ampdu_age
operator|=
name|msecs_to_ticks
argument_list|(
literal|500
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* setup default aggregation policy */
name|ic
operator|->
name|ic_recv_action
operator|=
name|ieee80211_aggr_recv_action
expr_stmt|;
name|ic
operator|->
name|ic_send_action
operator|=
name|ieee80211_send_action
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|ieee80211_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|ieee80211_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|ieee80211_addba_stop
expr_stmt|;
name|ic
operator|->
name|ic_htprotmode
operator|=
name|IEEE80211_PROT_RTSCTS
expr_stmt|;
name|ic
operator|->
name|ic_curhtprotmode
operator|=
name|IEEE80211_HTINFO_OPMODE_PURE
expr_stmt|;
comment|/* XXX get from driver */
name|ic
operator|->
name|ic_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_8K
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_NA
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_limit
operator|=
name|ic
operator|->
name|ic_ampdu_rxmax
expr_stmt|;
name|ic
operator|->
name|ic_amsdu_limit
operator|=
name|IEEE80211_HTCAP_MAXAMSDU_3839
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_HT
condition|)
block|{
comment|/* 		 * Device is HT capable; enable all HT-related 		 * facilities by default. 		 * XXX these choices may be too aggressive. 		 */
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_HT
operator||
name|IEEE80211_FEXT_HTCOMPAT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_SHORTGI20
expr_stmt|;
comment|/* XXX infer from channel list? */
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
condition|)
block|{
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_USEHT40
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI40
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_SHORTGI40
expr_stmt|;
block|}
comment|/* NB: A-MPDU and A-MSDU rx are mandated, these are tx only */
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMPDU_RX
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_AMPDU
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMPDU_TX
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMSDU_RX
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_AMSDU
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMSDU_TX
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_ht_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rate
decl_stmt|,
name|mword
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s MCS: "
argument_list|,
name|ieee80211_phymode_name
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|mword
operator|=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator||
name|IEEE80211_RATE_MCS
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mword
argument_list|)
operator|!=
name|IFM_IEEE80211_MCS
condition|)
continue|continue;
name|rate
operator|=
name|ieee80211_htrates
index|[
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d%sMbps"
argument_list|,
operator|(
name|i
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|rate
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|rate
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|?
literal|".5"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_ht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
condition|)
name|ht_announce
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|,
operator|&
name|ieee80211_rateset_11n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
name|ht_announce
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|,
operator|&
name|ieee80211_rateset_11n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|ieee80211_get_suphtrates
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
return|return
operator|&
name|ieee80211_rateset_11n
return|;
block|}
end_function

begin_comment
comment|/*  * Receive processing.  */
end_comment

begin_comment
comment|/*  * Decap the encapsulated A-MSDU frames and dispatch all but  * the last for delivery.  The last frame is returned for   * delivery via the normal path.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_decap_amsdu
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|framelen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* discard 802.3 header inserted by ieee80211_decap */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_amsdu_decap
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Decap the first frame, bust it apart from the 		 * remainder and deliver.  We leave the last frame 		 * delivery to the caller (for consistency with other 		 * code paths, could also do it here). 		 */
name|m
operator|=
name|ieee80211_decap1
argument_list|(
name|m
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-msdu"
argument_list|,
literal|"%s"
argument_list|,
literal|"decap failed"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_amsdu_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|==
name|framelen
condition|)
break|break;
name|n
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|framelen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-msdu"
argument_list|,
literal|"%s"
argument_list|,
literal|"unable to split encapsulated frames"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_amsdu_split
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* NB: must reclaim */
return|return
name|NULL
return|;
block|}
name|ieee80211_deliver_data
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Remove frame contents; each intermediate frame 		 * is required to be aligned to a 4-byte boundary. 		 */
name|m
operator|=
name|n
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup2
argument_list|(
name|framelen
argument_list|,
literal|4
argument_list|)
operator|-
name|framelen
argument_list|)
expr_stmt|;
comment|/* padding */
block|}
return|return
name|m
return|;
comment|/* last delivered by caller */
block|}
end_function

begin_comment
comment|/*  * Start A-MPDU rx/re-order processing for the specified TID.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_start
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|int
name|bufsiz
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|memset
argument_list|(
name|rap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rap
argument_list|)
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_start
operator|=
name|start
expr_stmt|;
name|rap
operator|->
name|rxa_flags
operator||=
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Purge all frames in the A-MPDU re-order queue.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_purge
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_qbytes
operator|==
literal|0
operator|&&
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %u data, %u frames on ampdu rx q"
operator|,
name|rap
operator|->
name|rxa_qbytes
operator|,
name|rap
operator|->
name|rxa_qframes
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop A-MPDU rx processing for the specified TID.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_stop
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|rap
operator|->
name|rxa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|ampdu_rx_purge
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a frame from the A-MPDU reorder queue.  The  * frame is fed back into ieee80211_input marked with an  * M_AMPDU flag so it doesn't come back to us (it also  * permits ieee80211_input to optimize re-processing).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ampdu_dispatch
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU
expr_stmt|;
comment|/* bypass normal processing */
comment|/* NB: rssi, noise, and rstamp are ignored w/ M_AMPDU set */
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch as many frames as possible from the re-order queue.  * Frames will always be "at the front"; we process all frames  * up to the first empty slot in the window.  On completion we  * cleanup state if there are still pending frames in the current  * BA window.  We assume the frame at slot 0 is already handled  * by the caller; we always start at slot 1.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_dispatch
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* flush run of frames */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If frames remain, copy the mbuf pointers down so 	 * they correspond to the offsets in the new window. 	 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|rap
operator|->
name|rxa_qframes
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|j
operator|-
name|i
index|]
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
expr_stmt|;
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %d frames"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_copy
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
block|}
comment|/* 	 * Adjust the start of the BA window to 	 * reflect the frames just dispatched. 	 */
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|+=
name|i
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_AMPDU_AGE
end_ifdef

begin_comment
comment|/*  * Dispatch all frames in the A-MPDU re-order queue.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_flush
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|++
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* IEEE80211_AMPDU_AGE */
end_comment

begin_comment
comment|/*  * Dispatch all frames in the A-MPDU re-order queue  * preceding the specified sequence number.  This logic  * handles window moves due to a received MSDU or BAR.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_flush_upto
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|ieee80211_seq
name|winstart
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|ieee80211_seq
name|seqno
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Flush any complete MSDU's with a sequence number lower 	 * than winstart.  Gaps may exist.  Note that we may actually 	 * dispatch frames past winstart if a run continues; this is 	 * an optimization that avoids having to do a separate pass 	 * to dispatch frames after moving the BA window start. 	 */
name|seqno
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|++
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|IEEE80211_SEQ_BA_BEFORE
argument_list|(
name|seqno
argument_list|,
name|winstart
argument_list|)
condition|)
break|break;
block|}
name|seqno
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|seqno
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If frames remain, copy the mbuf pointers down so 	 * they correspond to the offsets in the new window. 	 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|rap
operator|->
name|rxa_qframes
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|j
operator|-
name|i
index|]
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
expr_stmt|;
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"%s: lost %d frames, qframes %d off %d "
literal|"BA win<%d:%d> winstart %d"
operator|,
name|__func__
operator|,
name|n
operator|,
name|rap
operator|->
name|rxa_qframes
operator|,
name|i
operator|,
name|rap
operator|->
name|rxa_start
operator|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
operator|,
name|winstart
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_copy
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
block|}
comment|/* 	 * Move the start of the BA window; we use the 	 * sequence number of the last MSDU that was 	 * passed up the stack+1 or winstart if stopped on 	 * a gap in the reorder buffer. 	 */
name|rap
operator|->
name|rxa_start
operator|=
name|seqno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received QoS data frame for an HT station.  Handle  * A-MPDU reordering: if this frame is received out of order  * and falls within the BA window hold onto it.  Otherwise if  * this frame completes a run, flush any pending frames.  We  * return 1 if the frame is consumed.  A 0 is returned if  * the frame should be processed normally by the caller.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_reorder
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_FC0_QOSDATA
define|\
value|(IEEE80211_FC0_TYPE_DATA|IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_VERSION_0)
define|#
directive|define
name|PROCESS
value|0
comment|/* caller should process frame */
define|#
directive|define
name|CONSUMED
value|1
comment|/* frame consumed, caller does nothing */
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_qosframe
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|ieee80211_seq
name|rxseq
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|int
name|off
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT sta"
operator|)
argument_list|)
expr_stmt|;
comment|/* NB: m_len known to be sufficient */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|==
name|IEEE80211_FC0_QOSDATA
argument_list|,
operator|(
literal|"not QoS data"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
operator|)
operator|==
name|IEEE80211_FC1_DIR_DSTODS
condition|)
name|tid
operator|=
operator|(
operator|(
expr|struct
name|ieee80211_qosframe_addr4
operator|*
operator|)
name|wh
operator|)
operator|->
name|i_qos
index|[
literal|0
index|]
expr_stmt|;
else|else
name|tid
operator|=
name|wh
operator|->
name|i_qos
index|[
literal|0
index|]
expr_stmt|;
name|tid
operator|&=
name|IEEE80211_QOS_TID
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ADDBA request yet, don't touch. 		 */
return|return
name|PROCESS
return|;
block|}
name|rxseq
operator|=
name|le16toh
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
argument_list|)
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
name|rap
operator|->
name|rxa_nframes
operator|++
expr_stmt|;
name|again
label|:
if|if
condition|(
name|rxseq
operator|==
name|rap
operator|->
name|rxa_start
condition|)
block|{
comment|/* 		 * First frame in window. 		 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Dispatch as many packets as we can. 			 */
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_m
index|[
literal|0
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"unexpected dup"
operator|)
argument_list|)
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ampdu_rx_dispatch
argument_list|(
name|rap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
return|return
name|CONSUMED
return|;
block|}
else|else
block|{
comment|/* 			 * In order; advance window and notify 			 * caller to dispatch directly. 			 */
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|rxseq
argument_list|)
expr_stmt|;
return|return
name|PROCESS
return|;
block|}
block|}
comment|/* 	 * Frame is out of order; store if in the BA window. 	 */
comment|/* calculate offset in BA window */
name|off
operator|=
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|rap
operator|->
name|rxa_wnd
condition|)
block|{
comment|/* 		 * Common case (hopefully): in the BA window. 		 * Sec 9.10.7.6 a) (D2.04 p.118 line 47) 		 */
ifdef|#
directive|ifdef
name|IEEE80211_AMPDU_AGE
comment|/*  		 * Check for frames sitting too long in the reorder queue. 		 * This should only ever happen if frames are not delivered 		 * without the sender otherwise notifying us (e.g. with a 		 * BAR to move the window).  Typically this happens because 		 * of vendor bugs that cause the sequence number to jump. 		 * When this happens we get a gap in the reorder queue that 		 * leaves frame sitting on the queue until they get pushed 		 * out due to window moves.  When the vendor does not send 		 * BAR this move only happens due to explicit packet sends 		 * 		 * NB: we only track the time of the oldest frame in the 		 * reorder q; this means that if we flush we might push 		 * frames that still "new"; if this happens then subsequent 		 * frames will result in BA window moves which cost something 		 * but is still better than a big throughput dip. 		 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
comment|/* XXX honor batimeout? */
if|if
condition|(
name|ticks
operator|-
name|rap
operator|->
name|rxa_age
operator|>
name|ieee80211_ampdu_age
condition|)
block|{
comment|/* 				 * Too long since we received the first 				 * frame; flush the reorder buffer. 				 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_age
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
name|ampdu_rx_flush
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|)
expr_stmt|;
block|}
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|rxseq
argument_list|)
expr_stmt|;
return|return
name|PROCESS
return|;
block|}
block|}
else|else
block|{
comment|/* 			 * First frame, start aging timer. 			 */
name|rap
operator|->
name|rxa_age
operator|=
name|ticks
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IEEE80211_AMPDU_AGE */
comment|/* save packet */
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|off
index|]
operator|==
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|off
index|]
operator|=
name|m
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|++
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_reorder
operator|++
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-mpdu duplicate"
argument_list|,
literal|"seqno %u tid %u BA win<%u:%u>"
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_dup
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_dup
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
name|CONSUMED
return|;
block|}
if|if
condition|(
name|off
operator|<
name|IEEE80211_SEQ_BA_RANGE
condition|)
block|{
comment|/* 		 * Outside the BA window, but within range; 		 * flush the reorder q and move the window. 		 * Sec 9.10.7.6 b) (D2.04 p.118 line 60) 		 */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"move BA win<%u:%u> (%u frames) rxseq %u tid %u"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_move
operator|++
expr_stmt|;
comment|/* 		 * The spec says to flush frames up to but not including: 		 * 	WinStart_B = rxseq - rap->rxa_wnd + 1 		 * Then insert the frame or notify the caller to process 		 * it immediately.  We can safely do this by just starting 		 * over again because we know the frame will now be within 		 * the BA window. 		 */
comment|/* NB: rxa_wnd known to be>0 */
name|ampdu_rx_flush_upto
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
comment|/* 		 * Outside the BA window and out of range; toss. 		 * Sec 9.10.7.6 c) (D2.04 p.119 line 16) 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"MSDU"
argument_list|,
literal|"BA win<%u:%u> (%u frames) rxseq %u tid %u%s"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_RETRY
condition|?
literal|" (retransmit)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_drop
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_drop
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|CONSUMED
return|;
block|}
undef|#
directive|undef
name|CONSUMED
undef|#
directive|undef
name|PROCESS
undef|#
directive|undef
name|IEEE80211_FC0_QOSDATA
block|}
end_function

begin_comment
comment|/*  * Process a BAR ctl frame.  Dispatch all frames up to  * the sequence number of the frame.  If this frame is  * out of range it's discarded.  */
end_comment

begin_function
name|void
name|ieee80211_recv_bar
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_frame_bar
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|ieee80211_seq
name|rxseq
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
operator|!
name|ieee80211_recv_bar_ena
condition|)
block|{
if|#
directive|if
literal|0
block|IEEE80211_DISCARD_MAC(ic, IEEE80211_MSG_11N, 		    ni->ni_macaddr, "BAR", "%s", "processing disabled");
endif|#
directive|endif
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_bad
operator|++
expr_stmt|;
return|return;
block|}
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame_bar
operator|*
argument_list|)
expr_stmt|;
comment|/* XXX check basic BAR */
name|tid
operator|=
name|MS
argument_list|(
name|le16toh
argument_list|(
name|wh
operator|->
name|i_ctl
argument_list|)
argument_list|,
name|IEEE80211_BAR_TID
argument_list|)
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ADDBA request yet, don't touch. 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"BAR"
argument_list|,
literal|"no BA stream, tid %u"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_bad
operator|++
expr_stmt|;
return|return;
block|}
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_rx
operator|++
expr_stmt|;
name|rxseq
operator|=
name|le16toh
argument_list|(
name|wh
operator|->
name|i_seq
argument_list|)
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
if|if
condition|(
name|rxseq
operator|==
name|rap
operator|->
name|rxa_start
condition|)
return|return;
comment|/* calculate offset in BA window */
name|off
operator|=
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|<
name|IEEE80211_SEQ_BA_RANGE
condition|)
block|{
comment|/* 		 * Flush the reorder q up to rxseq and move the window. 		 * Sec 9.10.7.6 a) (D2.04 p.119 line 22) 		 */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"BAR moves BA win<%u:%u> (%u frames) rxseq %u tid %u"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_move
operator|++
expr_stmt|;
name|ampdu_rx_flush_upto
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|rxseq
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|rap
operator|->
name|rxa_wnd
condition|)
block|{
comment|/* 			 * BAR specifies a window start to the right of BA 			 * window; we must move it explicitly since 			 * ampdu_rx_flush_upto will not. 			 */
name|rap
operator|->
name|rxa_start
operator|=
name|rxseq
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Out of range; toss. 		 * Sec 9.10.7.6 b) (D2.04 p.119 line 41) 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"BAR"
argument_list|,
literal|"BA win<%u:%u> (%u frames) rxseq %u tid %u%s"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
operator|-
literal|1
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_RETRY
condition|?
literal|" (retransmit)"
else|:
literal|""
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_oow
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_drop
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Setup HT-specific state in a node.  Called only  * when HT use is negotiated so we don't do extra  * work for temporary and/or legacy sta's.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|htcap
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|ac
decl_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
comment|/* 		 * Clean AMPDU state on re-associate.  This handles the case 		 * where a station leaves w/o notifying us and then returns 		 * before node is reaped for inactivity. 		 */
name|ieee80211_ht_node_cleanup
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|ieee80211_parse_htcap
argument_list|(
name|ni
argument_list|,
name|htcap
argument_list|)
expr_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
name|tap
operator|->
name|txa_ac
operator|=
name|ac
expr_stmt|;
comment|/* NB: further initialization deferred */
block|}
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HT
operator||
name|IEEE80211_NODE_AMPDU
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cleanup HT-specific state in a node.  Called only  * when HT use has been marked.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT node"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX optimize this */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
condition|)
block|{
comment|/* 			 * Stop BA stream if setup so driver has a chance 			 * to reclaim any resources it might have allocated. 			 */
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|IEEE80211_TAPQ_DESTROY
argument_list|(
name|tap
argument_list|)
expr_stmt|;
comment|/* NB: clearing NAK means we may re-send ADDBA */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
operator|(
name|IEEE80211_AGGR_SETUP
operator||
name|IEEE80211_AGGR_NAK
operator|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_TID
condition|;
name|i
operator|++
control|)
name|ampdu_rx_stop
argument_list|(
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
literal|0
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
operator|(
name|IEEE80211_NODE_HT
operator||
name|IEEE80211_NODE_HTCOMPAT
operator||
name|IEEE80211_NODE_AMPDU
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|findhtchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|htflags
parameter_list|)
block|{
return|return
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
operator|)
operator||
name|htflags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust a channel to be HT/non-HT according to the vap's configuration.  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_ht_adjust_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|IEEE80211_FEXT_HT
condition|)
block|{
comment|/* promote to HT if possible */
if|if
condition|(
name|flags
operator|&
name|IEEE80211_FEXT_USEHT40
condition|)
block|{
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* NB: arbitrarily pick ht40+ over ht40- */
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT40U
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT40D
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|IEEE80211_IS_CHAN_HT20
argument_list|(
name|chan
argument_list|)
condition|)
block|{
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|chan
argument_list|)
condition|)
block|{
comment|/* demote to legacy, HT use is disabled */
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
block|}
return|return
name|chan
return|;
block|}
end_function

begin_comment
comment|/*  * Setup HT-specific state for a legacy WDS peer.  */
end_comment

begin_function
name|void
name|ieee80211_ht_wds_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|KASSERT
argument_list|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_HT
argument_list|,
operator|(
literal|"no HT requested"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX check scan cache in case peer has an ap and we have info */
comment|/* 	 * If setup with a legacy channel; locate an HT channel. 	 * Otherwise if the inherited channel (from a companion 	 * AP) is suitable use it so we use the same location 	 * for the extension channel). 	 */
name|ni
operator|->
name|ni_chan
operator|=
name|ieee80211_ht_adjust_channel
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
name|ic
operator|->
name|ic_flags_ext
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI20
condition|)
name|ni
operator|->
name|ni_htcap
operator||=
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
block|{
name|ni
operator|->
name|ni_htcap
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
name|ni
operator|->
name|ni_chw
operator|=
literal|40
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|)
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI40
condition|)
name|ni
operator|->
name|ni_htcap
operator||=
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
block|}
else|else
block|{
name|ni
operator|->
name|ni_chw
operator|=
literal|20
expr_stmt|;
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
block|}
name|ni
operator|->
name|ni_htctlchan
operator|=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_ieee
expr_stmt|;
name|ni
operator|->
name|ni_htopmode
operator|=
literal|0
expr_stmt|;
comment|/* XXX need protection state */
name|ni
operator|->
name|ni_htstbc
operator|=
literal|0
expr_stmt|;
comment|/* XXX need info */
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
name|tap
operator|->
name|txa_ac
operator|=
name|ac
expr_stmt|;
block|}
comment|/* NB: AMPDU tx/rx governed by IEEE80211_FEXT_AMPDU_{TX,RX} */
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HT
operator||
name|IEEE80211_NODE_AMPDU
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Notify hostap vaps of a change in the HTINFO ie.  */
end_comment

begin_function
specifier|static
name|void
name|htinfo_notify
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|!=
name|IEEE80211_M_HOSTAP
condition|)
return|return;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ic
operator|->
name|ic_bss
argument_list|,
literal|"HT bss occupancy change: %d sta, %d ht, "
literal|"%d ht40%s, HT protmode now 0x%x"
argument_list|,
name|ic
operator|->
name|ic_sta_assoc
argument_list|,
name|ic
operator|->
name|ic_ht_sta_assoc
argument_list|,
name|ic
operator|->
name|ic_ht40_sta_assoc
argument_list|,
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONHT_PR
operator|)
condition|?
literal|", non-HT sta present"
else|:
literal|""
argument_list|,
name|ic
operator|->
name|ic_curhtprotmode
argument_list|)
expr_stmt|;
name|ieee80211_beacon_notify
argument_list|(
name|ic
argument_list|,
name|IEEE80211_BEACON_HTINFO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate HT protection mode from current  * state and handle updates.  */
end_comment

begin_function
specifier|static
name|void
name|htinfo_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|uint8_t
name|protmode
decl_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONHT_PR
condition|)
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_PROTOPT
operator||
name|IEEE80211_HTINFO_NONHT_PRESENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ic
operator|->
name|ic_sta_assoc
operator|!=
name|ic
operator|->
name|ic_ht_sta_assoc
condition|)
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_MIXED
operator||
name|IEEE80211_HTINFO_NONHT_PRESENT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
name|ic
operator|->
name|ic_sta_assoc
operator|!=
name|ic
operator|->
name|ic_ht40_sta_assoc
condition|)
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_HT20PR
expr_stmt|;
block|}
else|else
block|{
name|protmode
operator|=
name|IEEE80211_HTINFO_OPMODE_PURE
expr_stmt|;
block|}
if|if
condition|(
name|protmode
operator|!=
name|ic
operator|->
name|ic_curhtprotmode
condition|)
block|{
name|ic
operator|->
name|ic_curhtprotmode
operator|=
name|protmode
expr_stmt|;
name|htinfo_notify
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Handle an HT station joining a BSS.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_join
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
name|ic
operator|->
name|ic_ht_sta_assoc
operator|++
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
condition|)
name|ic
operator|->
name|ic_ht40_sta_assoc
operator|++
expr_stmt|;
block|}
name|htinfo_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle an HT station leaving a BSS.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
condition|)
block|{
name|ic
operator|->
name|ic_ht_sta_assoc
operator|--
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_chw
operator|==
literal|40
condition|)
name|ic
operator|->
name|ic_ht40_sta_assoc
operator|--
expr_stmt|;
block|}
name|htinfo_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Public version of htinfo_update; used for processing  * beacon frames from overlapping bss in hostap_recv_mgmt.  */
end_comment

begin_function
name|void
name|ieee80211_htinfo_update
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|protmode
parameter_list|)
block|{
if|if
condition|(
name|protmode
operator|!=
name|ic
operator|->
name|ic_curhtprotmode
condition|)
block|{
name|ic
operator|->
name|ic_curhtprotmode
operator|=
name|protmode
expr_stmt|;
name|htinfo_notify
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Time out presence of an overlapping bss with non-HT  * stations.  When operating in hostap mode we listen for  * beacons from other stations and if we identify a non-HT  * station is present we update the opmode field of the  * HTINFO ie.  To identify when all non-HT stations are  * gone we time out this condition.  */
end_comment

begin_function
name|void
name|ieee80211_ht_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|IEEE80211_LOCK_ASSERT
argument_list|(
name|ic
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_NONHT_PR
operator|)
operator|&&
name|time_after
argument_list|(
name|ticks
argument_list|,
name|ic
operator|->
name|ic_lastnonht
operator|+
name|IEEE80211_NONHT_PRESENT_AGE
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|IEEE80211_NOTE(ic, IEEE80211_MSG_11N, ni, 		    "%s", "time out non-HT STA present on channel");
endif|#
directive|endif
name|ic
operator|->
name|ic_flags_ext
operator|&=
operator|~
name|IEEE80211_FEXT_NONHT_PR
expr_stmt|;
name|htinfo_update
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* unalligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((uint16_t)					\ 	 ((((const uint8_t *)(p))[0]      ) |		\ 	  (((const uint8_t *)(p))[1]<<  8)))
end_define

begin_comment
comment|/*  * Process an 802.11n HT capabilities ie.  */
end_comment

begin_function
name|void
name|ieee80211_parse_htcap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
block|{
comment|/* 		 * Station used Vendor OUI ie to associate; 		 * mark the node so when we respond we'll use 		 * the Vendor OUI's and not the standard ie's. 		 */
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HTCOMPAT
expr_stmt|;
name|ie
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_HTCOMPAT
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
name|LE_READ_2
argument_list|(
name|ie
operator|+
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_cap
argument_list|)
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htparam
operator|=
name|ie
index|[
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_param
argument_list|)
index|]
expr_stmt|;
comment|/* XXX needed or will ieee80211_parse_htinfo always be called? */
name|ni
operator|->
name|ni_chw
operator|=
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_USEHT40
operator|)
condition|?
literal|40
else|:
literal|20
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process an 802.11n HT info ie and update the node state.  * Note that we handle use this information to identify the  * correct channel (HT20, HT40+, HT40-, legacy).  The caller  * is responsible for insuring any required channel change is  * done (e.g. in sta mode when parsing the contents of a  * beacon frame).  */
end_comment

begin_function
name|void
name|ieee80211_parse_htinfo
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
decl_stmt|;
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
name|uint16_t
name|w
decl_stmt|;
name|int
name|htflags
decl_stmt|,
name|chanflags
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htinfo
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|ie
expr_stmt|;
name|ni
operator|->
name|ni_htctlchan
operator|=
name|htinfo
operator|->
name|hi_ctrlchannel
expr_stmt|;
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|SM
argument_list|(
name|htinfo
operator|->
name|hi_byte1
argument_list|,
name|IEEE80211_HTINFO_2NDCHAN
argument_list|)
expr_stmt|;
name|w
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|htinfo
operator|->
name|hi_byte2
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htopmode
operator|=
name|SM
argument_list|(
name|w
argument_list|,
name|IEEE80211_HTINFO_OPMODE
argument_list|)
expr_stmt|;
name|w
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|htinfo
operator|->
name|hi_byte45
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htstbc
operator|=
name|SM
argument_list|(
name|w
argument_list|,
name|IEEE80211_HTINFO_BASIC_STBCMCS
argument_list|)
expr_stmt|;
comment|/* 	 * Handle 11n channel switch.  Use the received HT ie's to 	 * identify the right channel to use.  If we cannot locate it 	 * in the channel table then fallback to legacy operation. 	 */
name|htflags
operator|=
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_HT
operator|)
condition|?
name|IEEE80211_CHAN_HT20
else|:
literal|0
expr_stmt|;
comment|/* NB: honor operating mode constraint */
if|if
condition|(
operator|(
name|htinfo
operator|->
name|hi_byte1
operator|&
name|IEEE80211_HTINFO_TXWIDTH_2040
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_USEHT40
operator|)
condition|)
block|{
if|if
condition|(
name|ni
operator|->
name|ni_ht2ndchan
operator|==
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
condition|)
name|htflags
operator|=
name|IEEE80211_CHAN_HT40U
expr_stmt|;
elseif|else
if|if
condition|(
name|ni
operator|->
name|ni_ht2ndchan
operator|==
name|IEEE80211_HTINFO_2NDCHAN_BELOW
condition|)
name|htflags
operator|=
name|IEEE80211_CHAN_HT40D
expr_stmt|;
block|}
name|chanflags
operator|=
operator|(
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_HT
operator|)
operator||
name|htflags
expr_stmt|;
if|if
condition|(
name|chanflags
operator|!=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_flags
condition|)
block|{
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|,
name|chanflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
operator|&&
name|htflags
operator|!=
name|IEEE80211_CHAN_HT20
condition|)
block|{
comment|/* 			 * No HT40 channel entry in our table; fall back 			 * to HT20 operation.  This should not happen. 			 */
name|c
operator|=
name|findhtchan
argument_list|(
name|ic
argument_list|,
name|ni
operator|->
name|ni_chan
argument_list|,
name|IEEE80211_CHAN_HT20
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"no HT40 channel (freq %u), falling back to HT20"
argument_list|,
name|ni
operator|->
name|ni_chan
operator|->
name|ic_freq
argument_list|)
expr_stmt|;
comment|/* XXX stat */
block|}
if|if
condition|(
name|c
operator|!=
name|NULL
operator|&&
name|c
operator|!=
name|ni
operator|->
name|ni_chan
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_ASSOC
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"switch station to HT%d channel %u/0x%x"
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|c
argument_list|)
condition|?
literal|40
else|:
literal|20
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_chan
operator|=
name|c
expr_stmt|;
block|}
comment|/* NB: caller responsible for forcing any channel change */
block|}
comment|/* update node's tx channel width */
name|ni
operator|->
name|ni_chw
operator|=
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
condition|?
literal|40
else|:
literal|20
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Install received HT rate set by parsing the HT cap ie.  */
end_comment

begin_function
name|int
name|ieee80211_setup_htrates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ie_htcap
modifier|*
name|htcap
decl_stmt|;
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
name|memset
argument_list|(
name|rs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htcap
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htcap
operator|*
operator|)
name|ie
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|htcap
operator|->
name|hc_mcsset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|==
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"WARNING, HT rate set too large; only "
literal|"using %u rates"
argument_list|,
name|IEEE80211_HTRATE_MAXSIZE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_rstoobig
operator|++
expr_stmt|;
break|break;
block|}
name|rs
operator|->
name|rs_rates
index|[
name|rs
operator|->
name|rs_nrates
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|(
expr|struct
name|ieee80211_rateset
operator|*
operator|)
name|rs
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark rates in a node's HT rate set as basic according  * to the information in the supplied HT info ie.  */
end_comment

begin_function
name|void
name|ieee80211_setup_basic_htrates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
decl_stmt|;
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htinfo
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|ie
expr_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"WARNING, empty HT rate set"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|htinfo
operator|->
name|hi_basicmcsset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|i
condition|)
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator||=
name|IEEE80211_RATE_BASIC
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|addba_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
name|arg
decl_stmt|;
comment|/* XXX ? */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|tap
operator|->
name|txa_attempts
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addba_start_timeout
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX use CALLOUT_PENDING instead? */
name|callout_reset
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
name|IEEE80211_AGGR_TIMEOUT
argument_list|,
name|addba_timeout
argument_list|,
name|tap
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|tap
operator|->
name|txa_lastrequest
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addba_stop_timeout
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX use CALLOUT_PENDING instead? */
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Default method for requesting A-MPDU tx aggregation.  * We setup the specified state block and start a timer  * to wait for an ADDBA response frame.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|int
name|bufsiz
decl_stmt|;
comment|/* XXX locking */
name|tap
operator|->
name|txa_token
operator|=
name|dialogtoken
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_IMMEDIATE
expr_stmt|;
name|tap
operator|->
name|txa_start
operator|=
name|tap
operator|->
name|txa_seqstart
operator|=
literal|0
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|addba_start_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for processing an A-MPDU tx aggregation  * response.  We shutdown any pending timer and update the  * state block according to the reply.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|int
name|bufsiz
decl_stmt|;
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
comment|/* XXX override our request? */
name|tap
operator|->
name|txa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
block|}
else|else
block|{
comment|/* mark tid so we don't try again */
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_NAK
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for stopping A-MPDU tx aggregation.  * Any timer is cleared and we drain any pending frames.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
condition|)
block|{
comment|/* clear aggregation queue */
name|ieee80211_drain_ifq
argument_list|(
operator|&
name|tap
operator|->
name|txa_q
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
block|}
name|tap
operator|->
name|txa_attempts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received action frame using the default aggregation  * policy.  We intercept ADDBA-related frames and use them to  * update our aggregation state.  All other frames are passed up  * for processing by ieee80211_recv_action.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_aggr_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_action
modifier|*
name|ia
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|uint8_t
name|dialogtoken
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|,
name|batimeout
decl_stmt|,
name|baseqctl
decl_stmt|,
name|code
decl_stmt|;
name|uint16_t
name|args
index|[
literal|4
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|ac
decl_stmt|,
name|bufsiz
decl_stmt|;
name|ia
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_action
operator|*
operator|)
name|frm
expr_stmt|;
switch|switch
condition|(
name|ia
operator|->
name|ia_category
condition|)
block|{
case|case
name|IEEE80211_ACTION_CAT_BA
case|:
switch|switch
condition|(
name|ia
operator|->
name|ia_action
condition|)
block|{
case|case
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
case|:
name|dialogtoken
operator|=
name|frm
index|[
literal|2
index|]
expr_stmt|;
name|baparamset
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|3
argument_list|)
expr_stmt|;
name|batimeout
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|5
argument_list|)
expr_stmt|;
name|baseqctl
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|7
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv ADDBA request: dialogtoken %u "
literal|"baparamset 0x%x (tid %d bufsiz %d) batimeout %d "
literal|"baseqctl %d:%d"
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|bufsiz
argument_list|,
name|batimeout
argument_list|,
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
argument_list|,
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
argument_list|)
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
comment|/* Send ADDBA response */
name|args
index|[
literal|0
index|]
operator|=
name|dialogtoken
expr_stmt|;
comment|/* 			 * NB: We ack only if the sta associated with HT and 			 * the ap is configured to do AMPDU rx (the latter 			 * violates the 11n spec and is mostly for testing). 			 */
if|if
condition|(
operator|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AMPDU_RX
operator|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_AMPDU_RX
operator|)
condition|)
block|{
name|ampdu_rx_start
argument_list|(
name|rap
argument_list|,
name|bufsiz
argument_list|,
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_STATUS_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"reject ADDBA request: %s"
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_AMPDU_RX
condition|?
literal|"administratively disabled"
else|:
literal|"not negotiated for station"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_addba_reject
operator|++
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_STATUS_UNSPECIFIED
expr_stmt|;
block|}
comment|/* XXX honor rap flags? */
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|rap
operator|->
name|rxa_wnd
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
case|:
name|dialogtoken
operator|=
name|frm
index|[
literal|2
index|]
expr_stmt|;
name|code
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|3
argument_list|)
expr_stmt|;
name|baparamset
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|5
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|batimeout
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|7
argument_list|)
expr_stmt|;
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
operator|~
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"ADDBA response"
argument_list|,
literal|"no pending ADDBA, tid %d dialogtoken %u "
literal|"code %d"
argument_list|,
name|tid
argument_list|,
name|dialogtoken
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_addba_norequest
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dialogtoken
operator|!=
name|tap
operator|->
name|txa_token
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"ADDBA response"
argument_list|,
literal|"dialogtoken mismatch: waiting for %d, "
literal|"received %d, tid %d code %d"
argument_list|,
name|tap
operator|->
name|txa_token
argument_list|,
name|dialogtoken
argument_list|,
name|tid
argument_list|,
name|code
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_addba_badtoken
operator|++
expr_stmt|;
return|return;
block|}
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv ADDBA response: dialogtoken %u code %d "
literal|"baparamset 0x%x (tid %d bufsiz %d) batimeout %d"
argument_list|,
name|dialogtoken
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|bufsiz
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_ACTION_BA_DELBA
case|:
name|baparamset
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|2
argument_list|)
expr_stmt|;
name|code
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|4
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_DELBAPS_TID
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv DELBA: baparamset 0x%x (tid %d initiator %d) "
literal|"code %d"
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_DELBAPS_INIT
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|baparamset
operator|&
name|IEEE80211_DELBAPS_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|ampdu_rx_stop
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
break|break;
block|}
name|ieee80211_recv_action
argument_list|(
name|ni
argument_list|,
name|frm
argument_list|,
name|efrm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received 802.11n action frame.  * Aggregation-related frames are assumed to be handled  * already; we handle any other frames we can, otherwise  * complain about being unsupported (with debugging).  */
end_comment

begin_function
name|void
name|ieee80211_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_action
modifier|*
name|ia
decl_stmt|;
name|int
name|chw
decl_stmt|;
name|ia
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_action
operator|*
operator|)
name|frm
expr_stmt|;
switch|switch
condition|(
name|ia
operator|->
name|ia_category
condition|)
block|{
case|case
name|IEEE80211_ACTION_CAT_BA
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: BA action %d not implemented"
argument_list|,
name|__func__
argument_list|,
name|ia
operator|->
name|ia_action
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
case|case
name|IEEE80211_ACTION_CAT_HT
case|:
switch|switch
condition|(
name|ia
operator|->
name|ia_action
condition|)
block|{
case|case
name|IEEE80211_ACTION_HT_TXCHWIDTH
case|:
name|chw
operator|=
name|frm
index|[
literal|2
index|]
operator|==
name|IEEE80211_A_HT_TXCHWIDTH_2040
condition|?
literal|40
else|:
literal|20
expr_stmt|;
if|if
condition|(
name|chw
operator|!=
name|ni
operator|->
name|ni_chw
condition|)
block|{
name|ni
operator|->
name|ni_chw
operator|=
name|chw
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_CHWUPDATE
expr_stmt|;
block|}
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT txchwidth, width %d (%s)"
argument_list|,
name|__func__
argument_list|,
name|chw
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_CHWUPDATE
condition|?
literal|"new"
else|:
literal|"no change"
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_ACTION_HT_MIMOPWRSAVE
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT MIMO PS"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT action %d not implemented"
argument_list|,
name|__func__
argument_list|,
name|ia
operator|->
name|ia_action
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: category %d not implemented"
argument_list|,
name|__func__
argument_list|,
name|ia
operator|->
name|ia_category
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit processing.  */
end_comment

begin_comment
comment|/*  * Request A-MPDU tx aggregation.  Setup local state and  * issue an ADDBA request.  BA use will only happen after  * the other end replies with ADDBA response.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|args
index|[
literal|4
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|dialogtoken
decl_stmt|;
specifier|static
name|int
name|tokens
init|=
literal|0
decl_stmt|;
comment|/* XXX */
comment|/* XXX locking */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do deferred setup of state */
name|IEEE80211_TAPQ_INIT
argument_list|(
name|tap
argument_list|)
expr_stmt|;
name|callout_init
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_SETUP
expr_stmt|;
block|}
if|if
condition|(
name|tap
operator|->
name|txa_attempts
operator|>=
name|IEEE80211_AGGR_MAXTRIES
operator|&&
operator|(
name|ticks
operator|-
name|tap
operator|->
name|txa_lastrequest
operator|)
operator|<
name|IEEE80211_AGGR_MINRETRY
condition|)
block|{
comment|/* 		 * Don't retry too often; IEEE80211_AGGR_MINRETRY 		 * defines the minimum interval we'll retry after 		 * IEEE80211_AGGR_MAXTRIES failed attempts to 		 * negotiate use. 		 */
return|return
literal|0
return|;
block|}
comment|/* XXX hack for not doing proper locking */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_NAK
expr_stmt|;
name|dialogtoken
operator|=
operator|(
name|tokens
operator|+
literal|1
operator|)
operator|%
literal|63
expr_stmt|;
comment|/* XXX */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|dialogtoken
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|IEEE80211_AGGR_BAWMAX
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* batimeout */
name|args
index|[
literal|3
index|]
operator|=
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
expr_stmt|;
comment|/* NB: do first so there's no race against reply */
if|if
condition|(
operator|!
name|ic
operator|->
name|ic_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* unable to setup state, don't make request */
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: could not setup BA stream for AC %d"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
comment|/* defer next try so we don't slam the driver with requests */
name|tap
operator|->
name|txa_attempts
operator|=
name|IEEE80211_AGGR_MAXTRIES
expr_stmt|;
name|tap
operator|->
name|txa_lastrequest
operator|=
name|ticks
expr_stmt|;
return|return
literal|0
return|;
block|}
name|tokens
operator|=
name|dialogtoken
expr_stmt|;
comment|/* allocate token */
return|return
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Terminate an AMPDU tx stream.  State is reclaimed  * and the peer notified with a DelBA Action frame.  */
end_comment

begin_function
name|void
name|ieee80211_ampdu_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|args
index|[
literal|4
index|]
decl_stmt|;
comment|/* XXX locking */
if|if
condition|(
name|IEEE80211_AMPDU_RUNNING
argument_list|(
name|tap
argument_list|)
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: stop BA stream for AC %d"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_stop
operator|++
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_DELBAPS_INIT
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* XXX reason code */
name|ieee80211_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_DELBA
argument_list|,
name|args
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: BA stream for AC %d not running"
argument_list|,
name|__func__
argument_list|,
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_stop_failed
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit a BAR frame to the specified node.  The  * BAR contents are drawn from the supplied aggregation  * state associated with the node.  */
end_comment

begin_function
name|int
name|ieee80211_send_bar
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|barctl
decl_stmt|,
name|barseqctl
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|ret
decl_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_min
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ba_request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_BAR
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|barctl
operator|=
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_IMMEDIATE
condition|?
name|IEEE80211_BAPS_POLICY_IMMEDIATE
else|:
name|IEEE80211_BAPS_POLICY_DELAYED
operator|)
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|tap
operator|->
name|txa_wnd
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|barseqctl
operator|=
name|SM
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|barctl
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|barseqctl
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
comment|/* XXX tx_ctl? */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
name|ni
argument_list|,
literal|"send bar frame (tid %u start %u) on channel %u"
argument_list|,
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* cheat */
name|if_start
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Send an action management frame.  The arguments are stuff  * into a frame without inspection; the caller is assumed to  * prepare them carefully (e.g. based on the aggregation state).  */
end_comment

begin_function
name|int
name|ieee80211_send_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|uint16_t
name|args
index|[
literal|4
index|]
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
comment|/* XXX may action payload */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_action_ba_addbaresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
switch|switch
condition|(
name|category
condition|)
block|{
case|case
name|IEEE80211_ACTION_CAT_BA
case|:
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send ADDBA request: dialogtoken %d "
literal|"baparamset 0x%x (tid %d) batimeout 0x%x baseqctl 0x%x"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|MS
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* dialog token */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* baparamset */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* batimeout */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* baseqctl */
break|break;
case|case
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send ADDBA response: dialogtoken %d status %d "
literal|"baparamset 0x%x (tid %d) batimeout %d"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|MS
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* dialog token */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* statuscode */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* baparamset */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* batimeout */
break|break;
case|case
name|IEEE80211_ACTION_BA_DELBA
case|:
comment|/* XXX */
name|baparamset
operator|=
name|SM
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|IEEE80211_DELBAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|IEEE80211_DELBAPS_INIT
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|baparamset
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* reason code */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send DELBA action: tid %d, initiator %d reason %d"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|badaction
goto|;
block|}
break|break;
case|case
name|IEEE80211_ACTION_CAT_HT
case|:
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|IEEE80211_ACTION_HT_TXCHWIDTH
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send HT txchwidth: width %d"
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|?
literal|40
else|:
literal|20
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|?
name|IEEE80211_A_HT_TXCHWIDTH_2040
else|:
name|IEEE80211_A_HT_TXCHWIDTH_20
expr_stmt|;
break|break;
default|default:
goto|goto
name|badaction
goto|;
block|}
break|break;
default|default:
name|badaction
label|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: unsupported category %d action %d"
argument_list|,
name|__func__
argument_list|,
name|category
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|,
name|is_tx_unknownmgt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_mgmt_output
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_SUBTYPE_ACTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
literal|0
return|;
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Construct the MCS bit mask for inclusion  * in an HT information element.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_htrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|r
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
comment|/* XXX? */
comment|/* NB: this assumes a particular implementation */
name|setbit
argument_list|(
name|frm
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add body of an HTCAP information element.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_htcap_body
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|caps
decl_stmt|;
name|int
name|rxmax
decl_stmt|,
name|density
decl_stmt|;
comment|/* HT capabilities */
name|caps
operator|=
name|ic
operator|->
name|ic_htcaps
operator|&
literal|0xffff
expr_stmt|;
comment|/* 	 * Note channel width depends on whether we are operating as 	 * a sta or not.  When operating as a sta we are generating 	 * a request based on our desired configuration.  Otherwise 	 * we are operational and the channel attributes identify 	 * how we've been setup (which might be different if a fixed 	 * channel is specified). 	 */
if|if
condition|(
name|ic
operator|->
name|ic_opmode
operator|==
name|IEEE80211_M_STA
condition|)
block|{
comment|/* override 20/40 use based on config */
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_USEHT40
condition|)
name|caps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
else|else
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
comment|/* use advertised setting (XXX locally constraint) */
name|rxmax
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_htparam
argument_list|,
name|IEEE80211_HTCAP_MAXRXAMPDU
argument_list|)
expr_stmt|;
name|density
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_htparam
argument_list|,
name|IEEE80211_HTCAP_MPDUDENSITY
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* override 20/40 use based on current channel */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|caps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
else|else
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
name|rxmax
operator|=
name|ic
operator|->
name|ic_ampdu_rxmax
expr_stmt|;
name|density
operator|=
name|ic
operator|->
name|ic_ampdu_density
expr_stmt|;
block|}
comment|/* adjust short GI based on channel and config */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI20
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI40
operator|)
operator|==
literal|0
operator|||
operator|(
name|caps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|caps
argument_list|)
expr_stmt|;
comment|/* HT parameters */
operator|*
name|frm
operator|=
name|SM
argument_list|(
name|rxmax
argument_list|,
name|IEEE80211_HTCAP_MAXRXAMPDU
argument_list|)
operator||
name|SM
argument_list|(
name|density
argument_list|,
name|IEEE80211_HTCAP_MPDUDENSITY
argument_list|)
expr_stmt|;
name|frm
operator|++
expr_stmt|;
comment|/* pre-zero remainder of ie */
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_mcsset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* supported MCS set */
comment|/* 	 * XXX it would better to get the rate set from ni_htrates 	 * so we can restrict it but for sta mode ni_htrates isn't 	 * setup when we're called to form an AssocReq frame so for 	 * now we're restricted to the default HT rate set. 	 */
name|ieee80211_set_htrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ieee80211_rateset_11n
argument_list|)
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_mcsset
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_comment
comment|/*  * Add 802.11n HT capabilities information element  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htcap
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_HTCAP
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
literal|2
expr_stmt|;
return|return
name|ieee80211_add_htcap_body
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add Broadcom OUI wrapped standard HTCAP ie; this is  * used for compatibility w/ pre-draft implementations.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htcap_vendor
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|4
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|5
index|]
operator|=
name|BCM_OUI_HTCAP
expr_stmt|;
return|return
name|ieee80211_add_htcap_body
argument_list|(
name|frm
operator|+
literal|6
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct the MCS bit mask of basic rates  * for inclusion in an HT information element.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_basic_htrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
operator|&&
name|r
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
comment|/* NB: this assumes a particular implementation */
name|setbit
argument_list|(
name|frm
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Update the HTINFO ie for a beacon frame.  */
end_comment

begin_function
name|void
name|ieee80211_ht_update_beacon
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_beacon_offsets
modifier|*
name|bo
parameter_list|)
block|{
define|#
directive|define
name|PROTMODE
value|(IEEE80211_HTINFO_OPMODE|IEEE80211_HTINFO_NONHT_PRESENT)
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|ht
init|=
operator|(
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|bo
operator|->
name|bo_htinfo
decl_stmt|;
comment|/* XXX only update on channel change */
name|ht
operator|->
name|hi_ctrlchannel
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
name|ht
operator|->
name|hi_byte1
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PROH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
else|else
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|ht
operator|->
name|hi_byte1
operator||=
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
comment|/* protection mode */
name|ht
operator|->
name|hi_byte2
operator|=
operator|(
name|ht
operator|->
name|hi_byte2
operator|&
operator|~
name|PROTMODE
operator|)
operator||
name|ic
operator|->
name|ic_curhtprotmode
expr_stmt|;
comment|/* XXX propagate to vendor ie's */
undef|#
directive|undef
name|PROTMODE
block|}
end_function

begin_comment
comment|/*  * Add body of an HTINFO information element.  *  * NB: We don't use struct ieee80211_ie_htinfo because we can  * be called to fillin both a standard ie and a compat ie that  * has a vendor OUI at the front.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_htinfo_body
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
comment|/* pre-zero remainder of ie */
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* primary/control channel center */
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PROH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
else|else
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
name|ic
operator|->
name|ic_curhtprotmode
expr_stmt|;
name|frm
operator|+=
literal|5
expr_stmt|;
comment|/* basic MCS set */
name|ieee80211_set_basic_htrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_htrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|,
name|hi_basicmcsset
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Add 802.11n HT information information element.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htinfo
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_HTINFO
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
expr_stmt|;
return|return
name|ieee80211_add_htinfo_body
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add Broadcom OUI wrapped standard HTINFO ie; this is  * used for compatibility w/ pre-draft implementations.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htinfo_vendor
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|4
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|5
index|]
operator|=
name|BCM_OUI_HTINFO
expr_stmt|;
return|return
name|ieee80211_add_htinfo_body
argument_list|(
name|frm
operator|+
literal|6
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

end_unit

