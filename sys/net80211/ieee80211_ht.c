begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11n protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_comment
comment|/* define here, used throughout file */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
end_define

begin_comment
comment|/* XXX need max array size */
end_comment

begin_decl_stmt
specifier|const
name|int
name|ieee80211_htrates
index|[
literal|16
index|]
init|=
block|{
literal|13
block|,
comment|/* IFM_IEEE80211_MCS0 */
literal|26
block|,
comment|/* IFM_IEEE80211_MCS1 */
literal|39
block|,
comment|/* IFM_IEEE80211_MCS2 */
literal|52
block|,
comment|/* IFM_IEEE80211_MCS3 */
literal|78
block|,
comment|/* IFM_IEEE80211_MCS4 */
literal|104
block|,
comment|/* IFM_IEEE80211_MCS5 */
literal|117
block|,
comment|/* IFM_IEEE80211_MCS6 */
literal|130
block|,
comment|/* IFM_IEEE80211_MCS7 */
literal|26
block|,
comment|/* IFM_IEEE80211_MCS8 */
literal|52
block|,
comment|/* IFM_IEEE80211_MCS9 */
literal|78
block|,
comment|/* IFM_IEEE80211_MCS10 */
literal|104
block|,
comment|/* IFM_IEEE80211_MCS11 */
literal|156
block|,
comment|/* IFM_IEEE80211_MCS12 */
literal|208
block|,
comment|/* IFM_IEEE80211_MCS13 */
literal|234
block|,
comment|/* IFM_IEEE80211_MCS14 */
literal|260
block|,
comment|/* IFM_IEEE80211_MCS15 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_htrateset
name|ieee80211_rateset_11n
init|=
block|{
literal|16
block|,
block|{
comment|/* MCS: 6.5   13 19.5   26   39  52 58.5  65  13  26 */
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
comment|/*       39   52   78  104  117, 130 */
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|IEEE80211_AGGR_TIMEOUT
value|msecs_to_ticks(250)
end_define

begin_define
define|#
directive|define
name|IEEE80211_AGGR_MINRETRY
value|msecs_to_ticks(10*1000)
end_define

begin_define
define|#
directive|define
name|IEEE80211_AGGR_MAXTRIES
value|3
end_define

begin_function_decl
specifier|static
name|int
name|ieee80211_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ieee80211_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|code
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ieee80211_aggr_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|ieee80211_ht_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|ic
operator|->
name|ic_ampdu_rxmax
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_8K
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_density
operator|=
name|IEEE80211_HTCAP_MPDUDENSITY_NA
expr_stmt|;
name|ic
operator|->
name|ic_ampdu_limit
operator|=
name|ic
operator|->
name|ic_ampdu_rxmax
expr_stmt|;
name|ic
operator|->
name|ic_amsdu_limit
operator|=
name|IEEE80211_HTCAP_MAXAMSDU_3839
expr_stmt|;
comment|/* setup default aggregation policy */
name|ic
operator|->
name|ic_recv_action
operator|=
name|ieee80211_aggr_recv_action
expr_stmt|;
name|ic
operator|->
name|ic_send_action
operator|=
name|ieee80211_send_action
expr_stmt|;
name|ic
operator|->
name|ic_addba_request
operator|=
name|ieee80211_addba_request
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
operator|=
name|ieee80211_addba_response
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
operator|=
name|ieee80211_addba_stop
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
operator|||
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
block|{
comment|/* 		 * There are HT channels in the channel list; enable 		 * all HT-related facilities by default. 		 * XXX these choices may be too aggressive. 		 */
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_HT
operator||
name|IEEE80211_FEXT_HTCOMPAT
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI20
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_SHORTGI20
expr_stmt|;
comment|/* XXX infer from channel list */
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
condition|)
block|{
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_USEHT40
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTCAP_SHORTGI40
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_SHORTGI40
expr_stmt|;
block|}
comment|/* NB: A-MPDU and A-MSDU rx are mandated, these are tx only */
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMPDU_RX
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_AMPDU
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMPDU_TX
expr_stmt|;
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMSDU_RX
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_htcaps
operator|&
name|IEEE80211_HTC_AMSDU
condition|)
name|ic
operator|->
name|ic_flags_ext
operator||=
name|IEEE80211_FEXT_AMSDU_TX
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_ht_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|ht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|mode
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rate
decl_stmt|,
name|mword
decl_stmt|;
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s MCS: "
argument_list|,
name|ieee80211_phymode_name
index|[
name|mode
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|mword
operator|=
name|ieee80211_rate2media
argument_list|(
name|ic
argument_list|,
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|IFM_SUBTYPE
argument_list|(
name|mword
argument_list|)
operator|!=
name|IFM_IEEE80211_MCS
condition|)
continue|continue;
name|rate
operator|=
name|ieee80211_htrates
index|[
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
index|]
expr_stmt|;
name|printf
argument_list|(
literal|"%s%d%sMbps"
argument_list|,
operator|(
name|i
operator|!=
literal|0
condition|?
literal|" "
else|:
literal|""
operator|)
argument_list|,
name|rate
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|rate
operator|&
literal|0x1
operator|)
operator|!=
literal|0
condition|?
literal|".5"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_ht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|)
condition|)
name|ht_announce
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_11NA
argument_list|,
operator|&
name|ieee80211_rateset_11n
argument_list|)
expr_stmt|;
if|if
condition|(
name|isset
argument_list|(
name|ic
operator|->
name|ic_modecaps
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|)
condition|)
name|ht_announce
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MODE_11NG
argument_list|,
operator|&
name|ieee80211_rateset_11n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|ieee80211_get_suphtrates
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
if|if
condition|(
name|IEEE80211_IS_CHAN_HT
argument_list|(
name|c
argument_list|)
condition|)
return|return
operator|&
name|ieee80211_rateset_11n
return|;
comment|/* XXX what's the right thing to do here? */
return|return
operator|(
specifier|const
expr|struct
name|ieee80211_htrateset
operator|*
operator|)
name|ieee80211_get_suprates
argument_list|(
name|ic
argument_list|,
name|c
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Receive processing.  */
end_comment

begin_comment
comment|/*  * Decap the encapsulated A-MSDU frames and dispatch all but  * the last for delivery.  The last frame is returned for   * delivery via the normal path.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_decap_amsdu
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|totallen
decl_stmt|,
name|framelen
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
comment|/* discard 802.3 header inserted by ieee80211_decap */
name|m_adj
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ether_header
argument_list|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_amsdu_decap
operator|++
expr_stmt|;
name|totallen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Decap the first frame, bust it apart from the 		 * remainder and deliver.  We leave the last frame 		 * delivery to the caller (for consistency with other 		 * code paths, could also do it here). 		 */
name|m
operator|=
name|ieee80211_decap1
argument_list|(
name|m
argument_list|,
operator|&
name|framelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-msdu"
argument_list|,
literal|"%s"
argument_list|,
literal|"first decap failed"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_amsdu_tooshort
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|framelen
operator|==
name|totallen
condition|)
break|break;
name|n
operator|=
name|m_split
argument_list|(
name|m
argument_list|,
name|framelen
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-msdu"
argument_list|,
literal|"%s"
argument_list|,
literal|"unable to split encapsulated frames"
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_amsdu_split
operator|++
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
comment|/* NB: must reclaim */
return|return
name|NULL
return|;
block|}
name|ieee80211_deliver_data
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* 		 * Remove frame contents; each intermediate frame 		 * is required to be aligned to a 4-byte boundary. 		 */
name|m
operator|=
name|n
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|roundup2
argument_list|(
name|framelen
argument_list|,
literal|4
argument_list|)
operator|-
name|framelen
argument_list|)
expr_stmt|;
comment|/* padding */
block|}
return|return
name|m
return|;
comment|/* last delivered by caller */
block|}
end_function

begin_comment
comment|/*  * Start A-MPDU rx/re-order processing for the specified TID.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_start
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|int
name|bufsiz
parameter_list|,
name|int
name|start
parameter_list|)
block|{
name|memset
argument_list|(
name|rap
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rap
argument_list|)
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_start
operator|=
name|start
expr_stmt|;
name|rap
operator|->
name|rxa_nxt
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
name|rap
operator|->
name|rxa_flags
operator||=
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Purge all frames in the A-MPDU re-order queue.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_purge
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_qbytes
operator|==
literal|0
operator|&&
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %u data, %u frames on ampdu rx q"
operator|,
name|rap
operator|->
name|rxa_qbytes
operator|,
name|rap
operator|->
name|rxa_qframes
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop A-MPDU rx processing for the specified TID.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_stop
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|)
block|{
name|rap
operator|->
name|rxa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|ampdu_rx_purge
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a frame from the A-MPDU reorder queue.  The  * frame is fed back into ieee80211_input marked with an  * M_AMPDU flag so it doesn't come back to us (it also  * permits ieee80211_input to optimize re-processing).  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|ampdu_dispatch
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
name|m
operator|->
name|m_flags
operator||=
name|M_AMPDU
expr_stmt|;
comment|/* bypass normal processing */
comment|/* NB: rssi, noise, and rstamp are ignored w/ M_AMPDU set */
operator|(
name|void
operator|)
name|ieee80211_input
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|m
argument_list|,
name|ni
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch as many frames as possible from the re-order queue.  * Frames will always be "at the front"; we process all frames  * up to the first empty slot in the window.  On completion we  * cleanup state if there are still pending frames in the current  * BA window.  We assume the frame at slot 0 is already handled  * by the caller; we always start at slot 1.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_dispatch
parameter_list|(
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* flush run of frames */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|--
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Adjust the start of the BA window to 	 * reflect the frames just dispatched. 	 */
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_nxt
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|+=
name|i
expr_stmt|;
comment|/* 	 * If frames remain, copy the mbuf pointers down so 	 * they correspond to the offsets in the new window. 	 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|rap
operator|->
name|rxa_qframes
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|j
operator|-
name|i
index|]
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
expr_stmt|;
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %d frames"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_copy
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Dispatch all frames in the A-MPDU  * re-order queue up to the specified slot.  */
end_comment

begin_function
specifier|static
name|void
name|ampdu_rx_flush
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
parameter_list|,
name|int
name|limit
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|limit
condition|;
name|i
operator|++
control|)
block|{
name|m
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
continue|continue;
name|rap
operator|->
name|rxa_m
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|-=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
condition|)
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Process a received QoS data frame for an HT station.  Handle  * A-MPDU reordering: if this frame is received out of order  * and falls within the BA window hold onto it.  Otherwise if  * this frame completes a run flush any pending frames.  We  * return 1 if the frame is consumed.  A 0 is returned if  * the frame should be processed normally by the caller.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_reorder
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
define|#
directive|define
name|IEEE80211_FC0_QOSDATA
define|\
value|(IEEE80211_FC0_TYPE_DATA|IEEE80211_FC0_SUBTYPE_QOS|IEEE80211_FC0_VERSION_0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_qosframe
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|ieee80211_seq
name|rxseq
decl_stmt|;
name|uint8_t
name|tid
decl_stmt|;
name|int
name|off
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT sta"
operator|)
argument_list|)
expr_stmt|;
comment|/* NB: m_len known to be sufficient */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_qosframe
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|==
name|IEEE80211_FC0_QOSDATA
argument_list|,
operator|(
literal|"not QoS data"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX 4-address frame */
name|tid
operator|=
name|wh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ADDBA request yet, don't touch. 		 */
return|return
literal|0
return|;
block|}
name|rxseq
operator|=
name|le16toh
argument_list|(
operator|*
operator|(
name|uint16_t
operator|*
operator|)
name|wh
operator|->
name|i_seq
argument_list|)
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
if|if
condition|(
name|rxseq
operator|==
name|rap
operator|->
name|rxa_start
condition|)
block|{
comment|/* 		 * First frame in window. 		 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Dispatch as many packets as we can. 			 */
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_m
index|[
literal|0
index|]
operator|==
name|NULL
argument_list|,
operator|(
literal|"unexpected dup"
operator|)
argument_list|)
expr_stmt|;
name|ampdu_dispatch
argument_list|(
name|ni
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ampdu_rx_dispatch
argument_list|(
name|rap
argument_list|,
name|ni
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* NB: consumed */
block|}
else|else
block|{
comment|/* 			 * In order; advance window and notify 			 * caller to dispatch directly. 			 */
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|rxseq
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_nxt
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
return|return
literal|0
return|;
comment|/* NB: process packet */
block|}
block|}
comment|/* 	 * This packet is out of order; store it 	 * if it's in the BA window. 	 */
comment|/* calculate offset in BA window */
name|off
operator|=
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|rap
operator|->
name|rxa_wnd
condition|)
block|{
comment|/* 		 * Outside the window, clear the q and start over. 		 * 		 * NB: this handles the case where rxseq is before 		 *     rxa_start because our max BA window is 64 		 *     and the sequence number range is 4096. 		 */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"flush BA win<%u:%u> (%u frames) rxseq %u tid %u"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
argument_list|)
argument_list|,
name|rap
operator|->
name|rxa_qframes
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
name|ampdu_rx_flush
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|rap
operator|->
name|rxa_wnd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_qbytes
operator|==
literal|0
operator|&&
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %u data, %u frames on ampdu rx q"
operator|,
name|rap
operator|->
name|rxa_qbytes
operator|,
name|rap
operator|->
name|rxa_qframes
operator|)
argument_list|)
expr_stmt|;
block|}
name|rap
operator|->
name|rxa_start
operator|=
name|IEEE80211_SEQ_INC
argument_list|(
name|rxseq
argument_list|)
expr_stmt|;
name|rap
operator|->
name|rxa_nxt
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
return|return
literal|0
return|;
comment|/* NB: process packet */
block|}
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
if|#
directive|if
literal|0
comment|/* XXX honor batimeout? */
block|if (ticks - mn->mn_age[tid]> 50) {
comment|/* 			 * Too long since we received the first frame; flush. 			 */
block|if (rap->rxa_qframes != 0) { 				ic->ic_stats.is_ampdu_rx_oor += 				    rap->rxa_qframes; 				ampdu_rx_flush(ni, rap, rap->rxa_wnd); 			} 			rap->rxa_start = IEEE80211_SEQ_INC(rxseq); 			rap->rxa_nxt = rap->rxa_start; 			return 0;
comment|/* NB: process packet */
block|}
endif|#
directive|endif
name|rap
operator|->
name|rxa_nxt
operator|=
name|rxseq
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * First frame, start aging timer. 		 */
if|#
directive|if
literal|0
block|mn->mn_age[tid] = ticks;
endif|#
directive|endif
block|}
comment|/* save packet */
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|off
index|]
operator|==
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|off
index|]
operator|=
name|m
expr_stmt|;
name|rap
operator|->
name|rxa_qframes
operator|++
expr_stmt|;
name|rap
operator|->
name|rxa_qbytes
operator|+=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"a-mpdu duplicate"
argument_list|,
literal|"seqno %u tid %u BA win<%u:%u>"
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_dup
operator|++
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|rx_dup
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
comment|/* NB: consumed */
undef|#
directive|undef
name|IEEE80211_FC0_QOSDATA
block|}
end_function

begin_comment
comment|/*  * Process a BAR ctl frame.  Dispatch all frames up to  * the sequence number of the frame.  If this frame is  * out of the window it's discarded.  */
end_comment

begin_function
name|void
name|ieee80211_recv_bar
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ieee80211_frame_bar
modifier|*
name|wh
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|ieee80211_seq
name|rxseq
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|off
decl_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m0
argument_list|,
expr|struct
name|ieee80211_frame_bar
operator|*
argument_list|)
expr_stmt|;
comment|/* XXX check basic BAR */
name|tid
operator|=
name|MS
argument_list|(
name|le16toh
argument_list|(
name|wh
operator|->
name|i_ctl
argument_list|)
argument_list|,
name|IEEE80211_BAR_TID
argument_list|)
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|rap
operator|->
name|rxa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No ADDBA request yet, don't touch. 		 */
name|IEEE80211_DISCARD_MAC
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|,
literal|"BAR"
argument_list|,
literal|"no BA stream, tid %u"
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_bad
operator|++
expr_stmt|;
return|return;
block|}
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_rx
operator|++
expr_stmt|;
name|rxseq
operator|=
name|le16toh
argument_list|(
name|wh
operator|->
name|i_seq
argument_list|)
operator|>>
name|IEEE80211_SEQ_SEQ_SHIFT
expr_stmt|;
comment|/* calculate offset in BA window */
name|off
operator|=
name|IEEE80211_SEQ_SUB
argument_list|(
name|rxseq
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>=
name|rap
operator|->
name|rxa_wnd
condition|)
block|{
comment|/* 		 * Outside the window, flush the reorder q if 		 * not pulling the sequence # backward.  The 		 * latter is typically caused by a dropped BA. 		 */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_INPUT
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv BAR outside BA win<%u:%u> rxseq %u tid %u"
argument_list|,
name|rap
operator|->
name|rxa_start
argument_list|,
name|IEEE80211_SEQ_ADD
argument_list|(
name|rap
operator|->
name|rxa_start
argument_list|,
name|rap
operator|->
name|rxa_wnd
argument_list|)
argument_list|,
name|rxseq
argument_list|,
name|tid
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_bar_oow
operator|++
expr_stmt|;
if|if
condition|(
name|rxseq
operator|<
name|rap
operator|->
name|rxa_start
condition|)
block|{
comment|/* XXX stat? */
return|return;
block|}
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
name|ampdu_rx_flush
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|rap
operator|->
name|rxa_wnd
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|rap
operator|->
name|rxa_qbytes
operator|==
literal|0
operator|&&
name|rap
operator|->
name|rxa_qframes
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %u data, %u frames on ampdu rx q"
operator|,
name|rap
operator|->
name|rxa_qbytes
operator|,
name|rap
operator|->
name|rxa_qframes
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Dispatch packets up to rxseq. 		 */
name|ampdu_rx_flush
argument_list|(
name|ni
argument_list|,
name|rap
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_oor
operator|+=
name|off
expr_stmt|;
comment|/* 		 * If frames remain, copy the mbuf pointers down so 		 * they correspond to the offsets in the new window. 		 */
if|if
condition|(
name|rap
operator|->
name|rxa_qframes
operator|!=
literal|0
condition|)
block|{
name|int
name|n
init|=
name|rap
operator|->
name|rxa_qframes
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
name|off
operator|+
literal|1
init|;
name|j
operator|<
name|rap
operator|->
name|rxa_wnd
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
block|{
name|rap
operator|->
name|rxa_m
index|[
name|j
operator|-
name|off
index|]
operator|=
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
expr_stmt|;
name|rap
operator|->
name|rxa_m
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|--
name|n
operator|==
literal|0
condition|)
break|break;
block|}
block|}
name|KASSERT
argument_list|(
name|n
operator|==
literal|0
argument_list|,
operator|(
literal|"lost %d frames"
operator|,
name|n
operator|)
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_ampdu_rx_copy
operator|+=
name|rap
operator|->
name|rxa_qframes
expr_stmt|;
block|}
block|}
name|rap
operator|->
name|rxa_start
operator|=
name|rxseq
expr_stmt|;
name|rap
operator|->
name|rxa_nxt
operator|=
name|rap
operator|->
name|rxa_start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Setup HT-specific state in a node.  Called only  * when HT use is negotiated so we don't do extra  * work for temporary and/or legacy sta's.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|htcap
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|int
name|ac
decl_stmt|;
name|ieee80211_parse_htcap
argument_list|(
name|ni
argument_list|,
name|htcap
argument_list|)
expr_stmt|;
for|for
control|(
name|ac
operator|=
literal|0
init|;
name|ac
operator|<
name|WME_NUM_AC
condition|;
name|ac
operator|++
control|)
block|{
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
name|tap
operator|->
name|txa_ac
operator|=
name|ac
expr_stmt|;
block|}
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HT
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Cleanup HT-specific state in a node.  Called only  * when HT use has been marked.  */
end_comment

begin_function
name|void
name|ieee80211_ht_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|int
name|i
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_HT
argument_list|,
operator|(
literal|"not an HT node"
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX optimize this */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_AC
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|IEEE80211_AMPDU_REQUESTED
argument_list|(
name|tap
argument_list|)
condition|)
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|WME_NUM_TID
condition|;
name|i
operator|++
control|)
name|ampdu_rx_stop
argument_list|(
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
literal|0
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
operator|(
name|IEEE80211_NODE_HT
operator||
name|IEEE80211_NODE_HTCOMPAT
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* unalligned little endian access */
end_comment

begin_define
define|#
directive|define
name|LE_READ_2
parameter_list|(
name|p
parameter_list|)
define|\
value|((uint16_t)					\ 	 ((((const uint8_t *)(p))[0]      ) |		\ 	  (((const uint8_t *)(p))[1]<<  8)))
end_define

begin_comment
comment|/*  * Process an 802.11n HT capabilities ie.  */
end_comment

begin_function
name|void
name|ieee80211_parse_htcap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
block|{
comment|/* 		 * Station used Vendor OUI ie to associate; 		 * mark the node so when we respond we'll use 		 * the Vendor OUI's and not the standard ie's. 		 */
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_HTCOMPAT
expr_stmt|;
name|ie
operator|+=
literal|4
expr_stmt|;
block|}
else|else
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_HTCOMPAT
expr_stmt|;
name|ni
operator|->
name|ni_htcap
operator|=
name|LE_READ_2
argument_list|(
name|ie
operator|+
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_cap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI40
operator|)
operator|==
literal|0
condition|)
name|ni
operator|->
name|ni_htcap
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI20
operator|)
operator|==
literal|0
condition|)
name|ni
operator|->
name|ni_htcap
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
name|ni
operator|->
name|ni_chw
operator|=
operator|(
name|ni
operator|->
name|ni_htcap
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
condition|?
literal|40
else|:
literal|20
expr_stmt|;
name|ni
operator|->
name|ni_htparam
operator|=
name|ie
index|[
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_param
argument_list|)
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|ni->ni_maxampdu = 	    (8*1024)<< MS(ni->ni_htparam, IEEE80211_HTCAP_MAXRXAMPDU); 	ni->ni_mpdudensity = MS(ni->ni_htparam, IEEE80211_HTCAP_MPDUDENSITY);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Process an 802.11n HT info ie.  */
end_comment

begin_function
name|void
name|ieee80211_parse_htinfo
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
decl_stmt|;
name|uint16_t
name|w
decl_stmt|;
name|int
name|chw
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htinfo
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|ie
expr_stmt|;
name|ni
operator|->
name|ni_htctlchan
operator|=
name|htinfo
operator|->
name|hi_ctrlchannel
expr_stmt|;
name|ni
operator|->
name|ni_ht2ndchan
operator|=
name|SM
argument_list|(
name|htinfo
operator|->
name|hi_byte1
argument_list|,
name|IEEE80211_HTINFO_2NDCHAN
argument_list|)
expr_stmt|;
name|w
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|htinfo
operator|->
name|hi_byte2
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htopmode
operator|=
name|SM
argument_list|(
name|w
argument_list|,
name|IEEE80211_HTINFO_OPMODE
argument_list|)
expr_stmt|;
name|w
operator|=
name|LE_READ_2
argument_list|(
operator|&
name|htinfo
operator|->
name|hi_byte45
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_htstbc
operator|=
name|SM
argument_list|(
name|w
argument_list|,
name|IEEE80211_HTINFO_BASIC_STBCMCS
argument_list|)
expr_stmt|;
comment|/* update node's recommended tx channel width */
name|chw
operator|=
operator|(
name|htinfo
operator|->
name|hi_byte1
operator|&
name|IEEE80211_HTINFO_TXWIDTH_2040
operator|)
condition|?
literal|40
else|:
literal|20
expr_stmt|;
if|if
condition|(
name|chw
operator|!=
name|ni
operator|->
name|ni_chw
condition|)
block|{
name|ni
operator|->
name|ni_chw
operator|=
name|chw
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_CHWUPDATE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Install received HT rate set by parsing the HT cap ie.  */
end_comment

begin_function
name|int
name|ieee80211_setup_htrates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_ie_htcap
modifier|*
name|htcap
decl_stmt|;
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
name|memset
argument_list|(
name|rs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ie
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htcap
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htcap
operator|*
operator|)
name|ie
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|htcap
operator|->
name|hc_mcsset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|==
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"WARNING, HT rate set too large; only "
literal|"using %u rates"
argument_list|,
name|IEEE80211_HTRATE_MAXSIZE
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_rstoobig
operator|++
expr_stmt|;
break|break;
block|}
name|rs
operator|->
name|rs_rates
index|[
name|rs
operator|->
name|rs_nrates
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
return|return
name|ieee80211_fix_rate
argument_list|(
name|ni
argument_list|,
operator|(
expr|struct
name|ieee80211_rateset
operator|*
operator|)
name|rs
argument_list|,
name|flags
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark rates in a node's HT rate set as basic according  * to the information in the supplied HT info ie.  */
end_comment

begin_function
name|void
name|ieee80211_setup_basic_htrates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_ie_htinfo
modifier|*
name|htinfo
decl_stmt|;
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|ie
index|[
literal|0
index|]
operator|==
name|IEEE80211_ELEMID_VENDOR
condition|)
name|ie
operator|+=
literal|4
expr_stmt|;
name|htinfo
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_ie_htinfo
operator|*
operator|)
name|ie
expr_stmt|;
name|rs
operator|=
operator|&
name|ni
operator|->
name|ni_htrates
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|rs_nrates
operator|==
literal|0
condition|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_ic
argument_list|,
name|IEEE80211_MSG_XRATE
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"WARNING, empty HT rate set"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isclr
argument_list|(
name|htinfo
operator|->
name|hi_basicmcsset
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator|&
name|IEEE80211_RATE_VAL
operator|)
operator|==
name|i
condition|)
name|rs
operator|->
name|rs_rates
index|[
name|j
index|]
operator||=
name|IEEE80211_RATE_BASIC
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|addba_timeout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
init|=
name|arg
decl_stmt|;
comment|/* XXX ? */
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|tap
operator|->
name|txa_attempts
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addba_start_timeout
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX use CALLOUT_PENDING instead? */
name|callout_reset
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
name|IEEE80211_AGGR_TIMEOUT
argument_list|,
name|addba_timeout
argument_list|,
name|tap
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
name|tap
operator|->
name|txa_lastrequest
operator|=
name|ticks
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addba_stop_timeout
parameter_list|(
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX use CALLOUT_PENDING instead? */
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_XCHGPEND
condition|)
block|{
name|callout_stop
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_XCHGPEND
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Default method for requesting A-MPDU tx aggregation.  * We setup the specified state block and start a timer  * to wait for an ADDBA response frame.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_addba_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|dialogtoken
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|int
name|bufsiz
decl_stmt|;
comment|/* XXX locking */
name|tap
operator|->
name|txa_token
operator|=
name|dialogtoken
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_IMMEDIATE
expr_stmt|;
name|tap
operator|->
name|txa_start
operator|=
name|tap
operator|->
name|txa_seqstart
operator|=
literal|0
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|addba_start_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for processing an A-MPDU tx aggregation  * response.  We shutdown any pending timer and update the  * state block according to the reply.  */
end_comment

begin_function
specifier|static
name|int
name|ieee80211_addba_response
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|,
name|int
name|status
parameter_list|,
name|int
name|baparamset
parameter_list|,
name|int
name|batimeout
parameter_list|)
block|{
name|int
name|bufsiz
decl_stmt|;
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|IEEE80211_STATUS_SUCCESS
condition|)
block|{
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
comment|/* XXX override our request? */
name|tap
operator|->
name|txa_wnd
operator|=
operator|(
name|bufsiz
operator|==
literal|0
operator|)
condition|?
name|IEEE80211_AGGR_BAWMAX
else|:
name|min
argument_list|(
name|bufsiz
argument_list|,
name|IEEE80211_AGGR_BAWMAX
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Default method for stopping A-MPDU tx aggregation.  * Any timer is cleared and we drain any pending frames.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_addba_stop
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
comment|/* XXX locking */
name|addba_stop_timeout
argument_list|(
name|tap
argument_list|)
expr_stmt|;
if|if
condition|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_RUNNING
condition|)
block|{
comment|/* clear aggregation queue */
name|ieee80211_drain_ifq
argument_list|(
operator|&
name|tap
operator|->
name|txa_q
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator|&=
operator|~
name|IEEE80211_AGGR_RUNNING
expr_stmt|;
block|}
name|tap
operator|->
name|txa_attempts
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process a received action frame using the default aggregation  * policy.  We intercept ADDBA-related frames and use them to  * update our aggregation state.  All other frames are passed up  * for processing by ieee80211_recv_action.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_aggr_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_action
modifier|*
name|ia
decl_stmt|;
name|struct
name|ieee80211_rx_ampdu
modifier|*
name|rap
decl_stmt|;
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
decl_stmt|;
name|uint8_t
name|dialogtoken
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|,
name|batimeout
decl_stmt|,
name|baseqctl
decl_stmt|,
name|code
decl_stmt|;
name|uint16_t
name|args
index|[
literal|4
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|ac
decl_stmt|,
name|bufsiz
decl_stmt|;
name|ia
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_action
operator|*
operator|)
name|frm
expr_stmt|;
switch|switch
condition|(
name|ia
operator|->
name|ia_category
condition|)
block|{
case|case
name|IEEE80211_ACTION_CAT_BA
case|:
switch|switch
condition|(
name|ia
operator|->
name|ia_action
condition|)
block|{
case|case
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
case|:
name|dialogtoken
operator|=
name|frm
index|[
literal|2
index|]
expr_stmt|;
name|baparamset
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|3
argument_list|)
expr_stmt|;
name|batimeout
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|5
argument_list|)
expr_stmt|;
name|baseqctl
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|7
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv ADDBA request: dialogtoken %u "
literal|"baparamset 0x%x (tid %d bufsiz %d) batimeout %d "
literal|"baseqctl %d"
argument_list|,
name|dialogtoken
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|bufsiz
argument_list|,
name|batimeout
argument_list|,
name|baseqctl
argument_list|)
expr_stmt|;
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
comment|/* Send ADDBA response */
name|args
index|[
literal|0
index|]
operator|=
name|dialogtoken
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_AMPDU_RX
condition|)
block|{
name|ampdu_rx_start
argument_list|(
name|rap
argument_list|,
name|bufsiz
argument_list|,
name|MS
argument_list|(
name|baseqctl
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
argument_list|)
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_STATUS_SUCCESS
expr_stmt|;
block|}
else|else
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_STATUS_UNSPECIFIED
expr_stmt|;
comment|/* XXX honor rap flags? */
name|args
index|[
literal|2
index|]
operator|=
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|rap
operator|->
name|rxa_wnd
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|args
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
argument_list|,
name|args
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
case|:
name|dialogtoken
operator|=
name|frm
index|[
literal|2
index|]
expr_stmt|;
name|code
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|3
argument_list|)
expr_stmt|;
name|baparamset
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|5
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
expr_stmt|;
name|bufsiz
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|batimeout
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|7
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv ADDBA response: dialogtoken %u code %d "
literal|"baparamset 0x%x (tid %d bufsiz %d) batimeout %d"
argument_list|,
name|dialogtoken
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|bufsiz
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
name|ic
operator|->
name|ic_addba_response
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|code
argument_list|,
name|baparamset
argument_list|,
name|batimeout
argument_list|)
expr_stmt|;
return|return;
case|case
name|IEEE80211_ACTION_BA_DELBA
case|:
name|baparamset
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|2
argument_list|)
expr_stmt|;
name|code
operator|=
name|LE_READ_2
argument_list|(
name|frm
operator|+
literal|4
argument_list|)
expr_stmt|;
name|tid
operator|=
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_DELBAPS_TID
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"recv DELBA: baparamset 0x%x (tid %d initiator %d) "
literal|"code %d"
argument_list|,
name|baparamset
argument_list|,
name|tid
argument_list|,
name|MS
argument_list|(
name|baparamset
argument_list|,
name|IEEE80211_DELBAPS_INIT
argument_list|)
argument_list|,
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|baparamset
operator|&
name|IEEE80211_DELBAPS_INIT
operator|)
operator|==
literal|0
condition|)
block|{
name|ac
operator|=
name|TID_TO_WME_AC
argument_list|(
name|tid
argument_list|)
expr_stmt|;
name|tap
operator|=
operator|&
name|ni
operator|->
name|ni_tx_ampdu
index|[
name|ac
index|]
expr_stmt|;
name|ic
operator|->
name|ic_addba_stop
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rap
operator|=
operator|&
name|ni
operator|->
name|ni_rx_ampdu
index|[
name|tid
index|]
expr_stmt|;
name|ampdu_rx_stop
argument_list|(
name|rap
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
break|break;
block|}
return|return
name|ieee80211_recv_action
argument_list|(
name|ni
argument_list|,
name|frm
argument_list|,
name|efrm
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Process a received 802.11n action frame.  * Aggregation-related frames are assumed to be handled  * already; we handle any other frames we can, otherwise  * complain about being unsupported (with debugging).  */
end_comment

begin_function
name|void
name|ieee80211_recv_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
specifier|const
name|struct
name|ieee80211_action
modifier|*
name|ia
decl_stmt|;
name|int
name|chw
decl_stmt|;
name|ia
operator|=
operator|(
specifier|const
expr|struct
name|ieee80211_action
operator|*
operator|)
name|frm
expr_stmt|;
switch|switch
condition|(
name|ia
operator|->
name|ia_category
condition|)
block|{
case|case
name|IEEE80211_ACTION_CAT_BA
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: BA action %d not implemented"
argument_list|,
name|__func__
argument_list|,
name|ia
operator|->
name|ia_action
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
case|case
name|IEEE80211_ACTION_CAT_HT
case|:
switch|switch
condition|(
name|ia
operator|->
name|ia_action
condition|)
block|{
case|case
name|IEEE80211_ACTION_HT_TXCHWIDTH
case|:
name|chw
operator|=
name|frm
index|[
literal|2
index|]
operator|==
name|IEEE80211_A_HT_TXCHWIDTH_2040
condition|?
literal|40
else|:
literal|20
expr_stmt|;
if|if
condition|(
name|chw
operator|!=
name|ni
operator|->
name|ni_chw
condition|)
block|{
name|ni
operator|->
name|ni_chw
operator|=
name|chw
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_CHWUPDATE
expr_stmt|;
block|}
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT txchwidth. width %d (%s)"
argument_list|,
name|__func__
argument_list|,
name|chw
argument_list|,
name|ni
operator|->
name|ni_flags
operator|&
name|IEEE80211_NODE_CHWUPDATE
condition|?
literal|"new"
else|:
literal|"no change"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: HT action %d not implemented"
argument_list|,
name|__func__
argument_list|,
name|ia
operator|->
name|ia_action
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: category %d not implemented"
argument_list|,
name|__func__
argument_list|,
name|ia
operator|->
name|ia_category
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_rx_mgtdiscard
operator|++
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  * Transmit processing.  */
end_comment

begin_comment
comment|/*  * Request A-MPDU tx aggregation.  Setup local state and  * issue an ADDBA request.  BA use will only happen after  * the other end replies with ADDBA response.  */
end_comment

begin_function
name|int
name|ieee80211_ampdu_request
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|args
index|[
literal|4
index|]
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|dialogtoken
decl_stmt|;
specifier|static
name|int
name|tokens
init|=
literal|0
decl_stmt|;
comment|/* XXX */
comment|/* XXX locking */
if|if
condition|(
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_SETUP
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* do deferred setup of state */
comment|/* XXX tap->txa_q */
name|callout_init
argument_list|(
operator|&
name|tap
operator|->
name|txa_timer
argument_list|,
name|CALLOUT_MPSAFE
argument_list|)
expr_stmt|;
name|tap
operator|->
name|txa_flags
operator||=
name|IEEE80211_AGGR_SETUP
expr_stmt|;
block|}
if|if
condition|(
name|tap
operator|->
name|txa_attempts
operator|>=
name|IEEE80211_AGGR_MAXTRIES
operator|&&
operator|(
name|ticks
operator|-
name|tap
operator|->
name|txa_lastrequest
operator|)
operator|<
name|IEEE80211_AGGR_MINRETRY
condition|)
block|{
comment|/* 		 * Don't retry too often; IEEE80211_AGGR_MINRETRY 		 * defines the minimum interval we'll retry after 		 * IEEE80211_AGGR_MAXTRIES failed attempts to 		 * negotiate use. 		 */
return|return
literal|0
return|;
block|}
name|dialogtoken
operator|=
operator|(
name|tokens
operator|+
literal|1
operator|)
operator|%
literal|63
expr_stmt|;
comment|/* XXX */
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|args
index|[
literal|0
index|]
operator|=
name|dialogtoken
expr_stmt|;
name|args
index|[
literal|1
index|]
operator|=
name|IEEE80211_BAPS_POLICY_IMMEDIATE
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|IEEE80211_AGGR_BAWMAX
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|args
index|[
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* batimeout */
name|args
index|[
literal|3
index|]
operator|=
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
expr_stmt|;
comment|/* NB: do first so there's no race against reply */
if|if
condition|(
operator|!
name|ic
operator|->
name|ic_addba_request
argument_list|(
name|ni
argument_list|,
name|tap
argument_list|,
name|dialogtoken
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
comment|/* unable to setup state, don't make request */
return|return
literal|0
return|;
block|}
name|tokens
operator|=
name|dialogtoken
expr_stmt|;
comment|/* allocate token */
return|return
name|ic
operator|->
name|ic_send_action
argument_list|(
name|ni
argument_list|,
name|IEEE80211_ACTION_CAT_BA
argument_list|,
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
argument_list|,
name|args
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Transmit a BAR frame to the specified node.  The  * BAR contents are drawn from the supplied aggregation  * state associated with the node.  */
end_comment

begin_function
name|int
name|ieee80211_send_bar
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_tx_ampdu
modifier|*
name|tap
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_frame_min
modifier|*
name|wh
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|barctl
decl_stmt|,
name|barseqctl
decl_stmt|;
name|int
name|tid
decl_stmt|,
name|ret
decl_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame_min
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ba_request
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame_min
operator|*
argument_list|)
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|=
name|IEEE80211_FC0_VERSION_0
operator||
name|IEEE80211_FC0_TYPE_CTL
operator||
name|IEEE80211_FC0_SUBTYPE_BAR
expr_stmt|;
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr1
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|,
name|ic
operator|->
name|ic_myaddr
argument_list|)
expr_stmt|;
name|tid
operator|=
name|WME_AC_TO_TID
argument_list|(
name|tap
operator|->
name|txa_ac
argument_list|)
expr_stmt|;
name|barctl
operator|=
operator|(
name|tap
operator|->
name|txa_flags
operator|&
name|IEEE80211_AGGR_IMMEDIATE
condition|?
name|IEEE80211_BAPS_POLICY_IMMEDIATE
else|:
name|IEEE80211_BAPS_POLICY_DELAYED
operator|)
operator||
name|SM
argument_list|(
name|tid
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|tap
operator|->
name|txa_wnd
argument_list|,
name|IEEE80211_BAPS_BUFSIZ
argument_list|)
expr_stmt|;
name|barseqctl
operator|=
name|SM
argument_list|(
name|tap
operator|->
name|txa_start
argument_list|,
name|IEEE80211_BASEQ_START
argument_list|)
operator||
name|SM
argument_list|(
literal|0
argument_list|,
name|IEEE80211_BASEQ_FRAG
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|barctl
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|barseqctl
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|IEEE80211_NODE_STAT
argument_list|(
name|ni
argument_list|,
name|tx_mgmt
argument_list|)
expr_stmt|;
comment|/* XXX tx_ctl? */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_DEBUG
operator||
name|IEEE80211_MSG_DUMPPKTS
argument_list|,
literal|"[%s] send bar frame (tid %u start %u) on channel %u\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|tid
argument_list|,
name|tap
operator|->
name|txa_start
argument_list|,
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
operator|(
name|void
operator|*
operator|)
name|ni
expr_stmt|;
name|IF_ENQUEUE
argument_list|(
operator|&
name|ic
operator|->
name|ic_mgtq
argument_list|,
name|m
argument_list|)
expr_stmt|;
comment|/* cheat */
call|(
modifier|*
name|ifp
operator|->
name|if_start
call|)
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Send an action management frame.  The arguments are stuff  * into a frame without inspection; the caller is assumed to  * prepare them carefully (e.g. based on the aggregation state).  */
end_comment

begin_function
name|int
name|ieee80211_send_action
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|uint16_t
name|args
index|[
literal|4
index|]
parameter_list|)
block|{
define|#
directive|define
name|senderr
parameter_list|(
name|_x
parameter_list|,
name|_v
parameter_list|)
value|do { ic->ic_stats._v++; ret = _x; goto bad; } while (0)
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|uint8_t
modifier|*
name|frm
decl_stmt|;
name|uint16_t
name|baparamset
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"null node"
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Hold a reference on the node so it doesn't go away until after 	 * the xmit is complete all the way in the driver.  On error we 	 * will remove our reference. 	 */
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
literal|"ieee80211_ref_node (%s:%u) %p<%s> refcnt %d\n"
argument_list|,
name|__func__
argument_list|,
name|__LINE__
argument_list|,
name|ni
argument_list|,
name|ether_sprintf
argument_list|(
name|ni
operator|->
name|ni_macaddr
argument_list|)
argument_list|,
name|ieee80211_node_refcnt
argument_list|(
name|ni
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|ieee80211_ref_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|=
name|ieee80211_getmgtframe
argument_list|(
operator|&
name|frm
argument_list|,
name|ic
operator|->
name|ic_headroom
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_frame
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint16_t
argument_list|)
comment|/* action+category */
comment|/* XXX may action payload */
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_action_ba_addbaresponse
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|senderr
argument_list|(
name|ENOMEM
argument_list|,
name|is_tx_nobuf
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|category
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|action
expr_stmt|;
switch|switch
condition|(
name|category
condition|)
block|{
case|case
name|IEEE80211_ACTION_CAT_BA
case|:
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|IEEE80211_ACTION_BA_ADDBA_REQUEST
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send ADDBA request: tid %d, baparamset 0x%x"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* dialog token */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* baparamset */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* batimeout */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* baseqctl */
break|break;
case|case
name|IEEE80211_ACTION_BA_ADDBA_RESPONSE
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send ADDBA response: dialogtoken %d status %d "
literal|"baparamset 0x%x (tid %d) batimeout %d"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|,
name|MS
argument_list|(
name|args
index|[
literal|2
index|]
argument_list|,
name|IEEE80211_BAPS_TID
argument_list|)
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|args
index|[
literal|0
index|]
expr_stmt|;
comment|/* dialog token */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* statuscode */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* baparamset */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
comment|/* batimeout */
break|break;
case|case
name|IEEE80211_ACTION_BA_DELBA
case|:
comment|/* XXX */
name|baparamset
operator|=
name|SM
argument_list|(
name|args
index|[
literal|0
index|]
argument_list|,
name|IEEE80211_DELBAPS_TID
argument_list|)
operator||
name|SM
argument_list|(
name|args
index|[
literal|1
index|]
argument_list|,
name|IEEE80211_DELBAPS_INIT
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|baparamset
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* reason code */
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send DELBA action: tid %d, initiator %d reason %d"
argument_list|,
name|args
index|[
literal|0
index|]
argument_list|,
name|args
index|[
literal|1
index|]
argument_list|,
name|args
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|badaction
goto|;
block|}
break|break;
case|case
name|IEEE80211_ACTION_CAT_HT
case|:
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|IEEE80211_ACTION_HT_TXCHWIDTH
case|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"send HT txchwidth: width %d"
argument_list|,
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|?
literal|40
else|:
literal|20
argument_list|)
expr_stmt|;
operator|*
name|frm
operator|++
operator|=
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|?
name|IEEE80211_A_HT_TXCHWIDTH_2040
else|:
name|IEEE80211_A_HT_TXCHWIDTH_20
expr_stmt|;
break|break;
default|default:
goto|goto
name|badaction
goto|;
block|}
break|break;
default|default:
name|badaction
label|:
name|IEEE80211_NOTE
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_ACTION
operator||
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: unsupported category %d action %d"
argument_list|,
name|__func__
argument_list|,
name|category
argument_list|,
name|action
argument_list|)
expr_stmt|;
name|senderr
argument_list|(
name|EINVAL
argument_list|,
name|is_tx_unknownmgt
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|=
name|m
operator|->
name|m_len
operator|=
name|frm
operator|-
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ieee80211_mgmt_output
argument_list|(
name|ic
argument_list|,
name|ni
argument_list|,
name|m
argument_list|,
name|IEEE80211_FC0_SUBTYPE_ACTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
return|return
literal|0
return|;
name|bad
label|:
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
undef|#
directive|undef
name|ADDSHORT
undef|#
directive|undef
name|senderr
block|}
end_function

begin_comment
comment|/*  * Construct the MCS bit mask for inclusion  * in an HT information element.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_htrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
name|r
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
comment|/* XXX? */
comment|/* NB: this assumes a particular implementation */
name|setbit
argument_list|(
name|frm
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add body of an HTCAP information element.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_htcap_body
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
name|uint16_t
name|caps
decl_stmt|;
comment|/* HT capabilities */
name|caps
operator|=
name|ic
operator|->
name|ic_htcaps
operator|&
literal|0xffff
expr_stmt|;
comment|/* override 20/40 use based on channel and config */
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
operator|&&
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_USEHT40
operator|)
condition|)
name|caps
operator||=
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
else|else
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_CHWIDTH40
expr_stmt|;
comment|/* adjust short GI based on channel and config */
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI20
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI20
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_SHORTGI40
operator|)
operator|==
literal|0
operator|||
operator|(
name|caps
operator|&
name|IEEE80211_HTCAP_CHWIDTH40
operator|)
operator|==
literal|0
condition|)
name|caps
operator|&=
operator|~
name|IEEE80211_HTCAP_SHORTGI40
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|caps
argument_list|)
expr_stmt|;
comment|/* HT parameters */
switch|switch
condition|(
name|ic
operator|->
name|ic_ampdu_rxmax
operator|/
literal|1024
condition|)
block|{
case|case
literal|8
case|:
operator|*
name|frm
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_8K
expr_stmt|;
break|break;
case|case
literal|16
case|:
operator|*
name|frm
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_16K
expr_stmt|;
break|break;
case|case
literal|32
case|:
operator|*
name|frm
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_32K
expr_stmt|;
break|break;
default|default:
operator|*
name|frm
operator|=
name|IEEE80211_HTCAP_MAXRXAMPDU_64K
expr_stmt|;
break|break;
block|}
operator|*
name|frm
operator||=
name|SM
argument_list|(
name|ic
operator|->
name|ic_ampdu_density
argument_list|,
name|IEEE80211_HTCAP_MPDUDENSITY
argument_list|)
expr_stmt|;
name|frm
operator|++
expr_stmt|;
comment|/* pre-zero remainder of ie */
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_mcsset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* supported MCS set */
name|ieee80211_set_htrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_htrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|,
name|hc_mcsset
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
undef|#
directive|undef
name|ADDSHORT
block|}
end_function

begin_comment
comment|/*  * Add 802.11n HT capabilities information element  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htcap
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_HTCAP
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
literal|2
expr_stmt|;
return|return
name|ieee80211_add_htcap_body
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add Broadcom OUI wrapped standard HTCAP ie; this is  * used for compatibility w/ pre-draft implementations.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htcap_vendor
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htcap
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|4
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|5
index|]
operator|=
name|BCM_OUI_HTCAP
expr_stmt|;
return|return
name|ieee80211_add_htcap_body
argument_list|(
name|frm
operator|+
literal|6
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Construct the MCS bit mask of basic rates  * for inclusion in an HT information element.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_set_basic_htrates
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|struct
name|ieee80211_htrateset
modifier|*
name|rs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rs
operator|->
name|rs_nrates
condition|;
name|i
operator|++
control|)
block|{
name|int
name|r
init|=
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_VAL
decl_stmt|;
if|if
condition|(
operator|(
name|rs
operator|->
name|rs_rates
index|[
name|i
index|]
operator|&
name|IEEE80211_RATE_BASIC
operator|)
operator|&&
name|r
operator|<
name|IEEE80211_HTRATE_MAXSIZE
condition|)
block|{
comment|/* NB: this assumes a particular implementation */
name|setbit
argument_list|(
name|frm
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add body of an HTINFO information element.  */
end_comment

begin_function
specifier|static
name|uint8_t
modifier|*
name|ieee80211_add_htinfo_body
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ni
operator|->
name|ni_ic
decl_stmt|;
comment|/* pre-zero remainder of ie */
name|memset
argument_list|(
name|frm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* primary/control channel center */
operator|*
name|frm
operator|++
operator|=
name|ieee80211_chan2ieee
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_bsschan
argument_list|)
expr_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_HTINFO_RIFSMODE_PROH
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40U
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_ABOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40D
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_BELOW
expr_stmt|;
else|else
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_2NDCHAN_NONE
expr_stmt|;
if|if
condition|(
name|IEEE80211_IS_CHAN_HT40
argument_list|(
name|ic
operator|->
name|ic_bsschan
argument_list|)
condition|)
name|frm
index|[
literal|0
index|]
operator||=
name|IEEE80211_HTINFO_TXWIDTH_2040
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
operator|(
name|ic
operator|->
name|ic_flags_ext
operator|&
name|IEEE80211_FEXT_PUREN
operator|)
condition|?
name|IEEE80211_HTINFO_OPMODE_PURE
else|:
name|IEEE80211_HTINFO_OPMODE_MIXED
expr_stmt|;
comment|/* XXX IEEE80211_HTINFO_NONHT_PRESENT */
name|frm
operator|+=
literal|5
expr_stmt|;
comment|/* basic MCS set */
name|ieee80211_set_basic_htrates
argument_list|(
name|frm
argument_list|,
operator|&
name|ni
operator|->
name|ni_htrates
argument_list|)
expr_stmt|;
name|frm
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
name|__offsetof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|,
name|hi_basicmcsset
argument_list|)
expr_stmt|;
return|return
name|frm
return|;
block|}
end_function

begin_comment
comment|/*  * Add 802.11n HT information information element.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htinfo
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_HTINFO
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
expr_stmt|;
return|return
name|ieee80211_add_htinfo_body
argument_list|(
name|frm
operator|+
literal|2
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add Broadcom OUI wrapped standard HTINFO ie; this is  * used for compatibility w/ pre-draft implementations.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_htinfo_vendor
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VENDOR
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
literal|4
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_htinfo
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
index|[
literal|2
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|3
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|4
index|]
operator|=
operator|(
name|BCM_OUI
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|frm
index|[
literal|5
index|]
operator|=
name|BCM_OUI_HTINFO
expr_stmt|;
return|return
name|ieee80211_add_htinfo_body
argument_list|(
name|frm
operator|+
literal|6
argument_list|,
name|ni
argument_list|)
return|;
block|}
end_function

end_unit

