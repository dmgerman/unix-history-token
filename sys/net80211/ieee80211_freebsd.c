begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2009 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11 support (FreeBSD-specific code)  */
end_comment

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/bpf.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_dl.h>
end_include

begin_include
include|#
directive|include
file|<net/if_clone.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net/route.h>
end_include

begin_include
include|#
directive|include
file|<net/vnet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_expr_stmt
name|SYSCTL_NODE
argument_list|(
name|_net
argument_list|,
name|OID_AUTO
argument_list|,
name|wlan
argument_list|,
name|CTLFLAG_RD
argument_list|,
literal|0
argument_list|,
literal|"IEEE 80211 parameters"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|ieee80211_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|SYSCTL_INT
argument_list|(
name|_net_wlan
argument_list|,
name|OID_AUTO
argument_list|,
name|debug
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|ieee80211_debug
argument_list|,
literal|0
argument_list|,
literal|"debugging printfs"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|MALLOC_DEFINE
argument_list|(
name|M_80211_COM
argument_list|,
literal|"80211com"
argument_list|,
literal|"802.11 com state"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Allocate/free com structure in conjunction with ifnet;  * these routines are registered with if_register_com_alloc  * below and are called automatically by the ifnet code  * when the ifnet of the parent device is created.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|wlan_alloc
parameter_list|(
name|u_char
name|type
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|ic
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211com
argument_list|)
argument_list|,
name|M_80211_COM
argument_list|,
name|M_WAITOK
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_ifp
operator|=
name|ifp
expr_stmt|;
return|return
operator|(
name|ic
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wlan_free
parameter_list|(
name|void
modifier|*
name|ic
parameter_list|,
name|u_char
name|type
parameter_list|)
block|{
name|free
argument_list|(
name|ic
argument_list|,
name|M_80211_COM
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|wlan_clone_create
parameter_list|(
name|struct
name|if_clone
modifier|*
name|ifc
parameter_list|,
name|int
name|unit
parameter_list|,
name|caddr_t
name|params
parameter_list|)
block|{
name|struct
name|ieee80211_clone_params
name|cp
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|copyin
argument_list|(
name|params
argument_list|,
operator|&
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|error
return|;
name|ifp
operator|=
name|ifunit
argument_list|(
name|cp
operator|.
name|icp_parent
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
return|return
name|ENXIO
return|;
comment|/* XXX move printfs to DIAGNOSTIC before release */
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_IEEE80211
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: reject, not an 802.11 device\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|ENXIO
return|;
block|}
if|if
condition|(
name|cp
operator|.
name|icp_opmode
operator|>=
name|IEEE80211_OPMODE_MAX
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: invalid opmode %d\n"
argument_list|,
name|__func__
argument_list|,
name|cp
operator|.
name|icp_opmode
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|ic
operator|=
name|ifp
operator|->
name|if_l2com
expr_stmt|;
if|if
condition|(
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|ieee80211_opcap
index|[
name|cp
operator|.
name|icp_opmode
index|]
operator|)
operator|==
literal|0
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s mode not supported\n"
argument_list|,
name|ieee80211_opmode_name
index|[
name|cp
operator|.
name|icp_opmode
index|]
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
if|if
condition|(
operator|(
name|cp
operator|.
name|icp_flags
operator|&
name|IEEE80211_CLONE_TDMA
operator|)
operator|&&
ifdef|#
directive|ifdef
name|IEEE80211_SUPPORT_TDMA
operator|(
name|ic
operator|->
name|ic_caps
operator|&
name|IEEE80211_C_TDMA
operator|)
operator|==
literal|0
else|#
directive|else
operator|(
literal|1
operator|)
endif|#
directive|endif
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"TDMA not supported\n"
argument_list|)
expr_stmt|;
return|return
name|EOPNOTSUPP
return|;
block|}
name|vap
operator|=
name|ic
operator|->
name|ic_vap_create
argument_list|(
name|ic
argument_list|,
name|ifc
operator|->
name|ifc_name
argument_list|,
name|unit
argument_list|,
name|cp
operator|.
name|icp_opmode
argument_list|,
name|cp
operator|.
name|icp_flags
argument_list|,
name|cp
operator|.
name|icp_bssid
argument_list|,
name|cp
operator|.
name|icp_flags
operator|&
name|IEEE80211_CLONE_MACADDR
condition|?
name|cp
operator|.
name|icp_macaddr
else|:
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vap
operator|==
name|NULL
condition|?
name|EIO
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wlan_clone_destroy
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
name|ic
operator|->
name|ic_vap_delete
argument_list|(
name|vap
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|IFC_SIMPLE_DECLARE
argument_list|(
name|wlan
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_vap_destroy
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|if_clone_destroyif
argument_list|(
operator|&
name|wlan_cloner
argument_list|,
name|vap
operator|->
name|iv_ifp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieee80211_sysctl_msecs_ticks
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|msecs
init|=
name|ticks_to_msecs
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|,
name|t
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|msecs
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|t
operator|=
name|msecs_to_ticks
argument_list|(
name|msecs
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
operator|(
name|t
operator|<
literal|1
operator|)
condition|?
literal|1
else|:
name|t
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee80211_sysctl_inact
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|int
name|inact
init|=
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|)
operator|*
name|IEEE80211_INACT_WAIT
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|inact
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
operator|*
operator|(
name|int
operator|*
operator|)
name|arg1
operator|=
name|inact
operator|/
name|IEEE80211_INACT_WAIT
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee80211_sysctl_parent
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|ic
operator|->
name|ic_ifp
operator|->
name|if_xname
decl_stmt|;
return|return
name|SYSCTL_OUT
argument_list|(
name|req
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ieee80211_sysctl_radar
parameter_list|(
name|SYSCTL_HANDLER_ARGS
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|arg1
decl_stmt|;
name|int
name|t
init|=
literal|0
decl_stmt|,
name|error
decl_stmt|;
name|error
operator|=
name|sysctl_handle_int
argument_list|(
name|oidp
argument_list|,
operator|&
name|t
argument_list|,
literal|0
argument_list|,
name|req
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|||
operator|!
name|req
operator|->
name|newptr
condition|)
return|return
name|error
return|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|ieee80211_dfs_notify_radar
argument_list|(
name|ic
argument_list|,
name|ic
operator|->
name|ic_curchan
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_sysctl_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_sysctl_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_sysctl_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|sysctl_ctx_list
modifier|*
name|ctx
decl_stmt|;
name|struct
name|sysctl_oid
modifier|*
name|oid
decl_stmt|;
name|char
name|num
index|[
literal|14
index|]
decl_stmt|;
comment|/* sufficient for 32 bits */
name|ctx
operator|=
operator|(
expr|struct
name|sysctl_ctx_list
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|sysctl_ctx_list
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|if_printf
argument_list|(
name|ifp
argument_list|,
literal|"%s: cannot allocate sysctl context!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return;
block|}
name|sysctl_ctx_init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|num
argument_list|,
sizeof|sizeof
argument_list|(
name|num
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|ifp
operator|->
name|if_dunit
argument_list|)
expr_stmt|;
name|oid
operator|=
name|SYSCTL_ADD_NODE
argument_list|(
name|ctx
argument_list|,
operator|&
name|SYSCTL_NODE_CHILDREN
argument_list|(
name|_net
argument_list|,
name|wlan
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
name|num
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"%parent"
argument_list|,
name|CTLFLAG_RD
argument_list|,
name|vap
operator|->
name|iv_ic
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_parent
argument_list|,
literal|"A"
argument_list|,
literal|"parent device"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"driver_caps"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_caps
argument_list|,
literal|0
argument_list|,
literal|"driver capabilities"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
name|vap
operator|->
name|iv_debug
operator|=
name|ieee80211_debug
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"debug"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_debug
argument_list|,
literal|0
argument_list|,
literal|"control debugging printfs"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"bmiss_max"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_bmiss_max
argument_list|,
literal|0
argument_list|,
literal|"consecutive beacon misses before scanning"
argument_list|)
expr_stmt|;
comment|/* XXX inherit from tunables */
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inact_run"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_inact_run
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_inact
argument_list|,
literal|"I"
argument_list|,
literal|"station inactivity timeout (sec)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inact_probe"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_inact_probe
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_inact
argument_list|,
literal|"I"
argument_list|,
literal|"station inactivity probe timeout (sec)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inact_auth"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_inact_auth
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_inact
argument_list|,
literal|"I"
argument_list|,
literal|"station authentication timeout (sec)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"inact_init"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_inact_init
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_inact
argument_list|,
literal|"I"
argument_list|,
literal|"station initial state timeout (sec)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_htcaps
operator|&
name|IEEE80211_HTC_HT
condition|)
block|{
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ampdu_mintraffic_bk"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_BK
index|]
argument_list|,
literal|0
argument_list|,
literal|"BK traffic tx aggr threshold (pps)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ampdu_mintraffic_be"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_BE
index|]
argument_list|,
literal|0
argument_list|,
literal|"BE traffic tx aggr threshold (pps)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ampdu_mintraffic_vo"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_VO
index|]
argument_list|,
literal|0
argument_list|,
literal|"VO traffic tx aggr threshold (pps)"
argument_list|)
expr_stmt|;
name|SYSCTL_ADD_INT
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"ampdu_mintraffic_vi"
argument_list|,
name|CTLFLAG_RW
argument_list|,
operator|&
name|vap
operator|->
name|iv_ampdu_mintraffic
index|[
name|WME_AC_VI
index|]
argument_list|,
literal|0
argument_list|,
literal|"VI traffic tx aggr threshold (pps)"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vap
operator|->
name|iv_caps
operator|&
name|IEEE80211_C_DFS
condition|)
block|{
name|SYSCTL_ADD_PROC
argument_list|(
name|ctx
argument_list|,
name|SYSCTL_CHILDREN
argument_list|(
name|oid
argument_list|)
argument_list|,
name|OID_AUTO
argument_list|,
literal|"radar"
argument_list|,
name|CTLTYPE_INT
operator||
name|CTLFLAG_RW
argument_list|,
name|vap
operator|->
name|iv_ic
argument_list|,
literal|0
argument_list|,
name|ieee80211_sysctl_radar
argument_list|,
literal|"I"
argument_list|,
literal|"simulate radar event"
argument_list|)
expr_stmt|;
block|}
name|vap
operator|->
name|iv_sysctl
operator|=
name|ctx
expr_stmt|;
name|vap
operator|->
name|iv_oid
operator|=
name|oid
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_sysctl_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
if|if
condition|(
name|vap
operator|->
name|iv_sysctl
operator|!=
name|NULL
condition|)
block|{
name|sysctl_ctx_free
argument_list|(
name|vap
operator|->
name|iv_sysctl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vap
operator|->
name|iv_sysctl
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_sysctl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|ieee80211_node_dectestref
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
comment|/* XXX need equivalent of atomic_dec_and_test */
name|atomic_subtract_int
argument_list|(
operator|&
name|ni
operator|->
name|ni_refcnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
name|atomic_cmpset_int
argument_list|(
operator|&
name|ni
operator|->
name|ni_refcnt
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_drain_ifq
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|IF_DEQUEUE
argument_list|(
name|ifq
argument_list|,
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
break|break;
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
name|KASSERT
argument_list|(
name|ni
operator|!=
name|NULL
argument_list|,
operator|(
literal|"frame w/o node"
operator|)
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
operator|=
name|NULL
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_flush_ifq
parameter_list|(
name|struct
name|ifqueue
modifier|*
name|ifq
parameter_list|,
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211_node
modifier|*
name|ni
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|,
modifier|*
modifier|*
name|mprev
decl_stmt|;
name|IF_LOCK
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|mprev
operator|=
operator|&
name|ifq
operator|->
name|ifq_head
expr_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
operator|*
name|mprev
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ni
operator|=
operator|(
expr|struct
name|ieee80211_node
operator|*
operator|)
name|m
operator|->
name|m_pkthdr
operator|.
name|rcvif
expr_stmt|;
if|if
condition|(
name|ni
operator|!=
name|NULL
operator|&&
name|ni
operator|->
name|ni_vap
operator|==
name|vap
condition|)
block|{
operator|*
name|mprev
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
comment|/* remove from list */
name|ifq
operator|->
name|ifq_len
operator|--
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ieee80211_free_node
argument_list|(
name|ni
argument_list|)
expr_stmt|;
comment|/* reclaim ref */
block|}
else|else
name|mprev
operator|=
operator|&
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
comment|/* recalculate tail ptr */
name|m
operator|=
name|ifq
operator|->
name|ifq_head
expr_stmt|;
for|for
control|(
init|;
name|m
operator|!=
name|NULL
operator|&&
name|m
operator|->
name|m_nextpkt
operator|!=
name|NULL
condition|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
control|)
empty_stmt|;
name|ifq
operator|->
name|ifq_tail
operator|=
name|m
expr_stmt|;
name|IF_UNLOCK
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * As above, for mbufs allocated with m_gethdr/MGETHDR  * or initialized by M_COPY_PKTHDR.  */
end_comment

begin_define
define|#
directive|define
name|MC_ALIGN
parameter_list|(
name|m
parameter_list|,
name|len
parameter_list|)
define|\
value|do {									\ 	(m)->m_data += (MCLBYTES - (len))&~ (sizeof(long) - 1);	\ } while (
comment|/* CONSTCOND */
value|0)
end_define

begin_comment
comment|/*  * Allocate and setup a management frame of the specified  * size.  We return the mbuf and a pointer to the start  * of the contiguous data area that's been reserved based  * on the packet length.  The data area is forced to 32-bit  * alignment and the buffer length to a multiple of 4 bytes.  * This is done mainly so beacon frames (that require this)  * can use this interface too.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_getmgtframe
parameter_list|(
name|uint8_t
modifier|*
modifier|*
name|frm
parameter_list|,
name|int
name|headroom
parameter_list|,
name|int
name|pktlen
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|u_int
name|len
decl_stmt|;
comment|/* 	 * NB: we know the mbuf routines will align the data area 	 *     so we don't need to do anything special. 	 */
name|len
operator|=
name|roundup2
argument_list|(
name|headroom
operator|+
name|pktlen
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|len
operator|<=
name|MCLBYTES
argument_list|,
operator|(
literal|"802.11 mgt frame too large: %u"
operator|,
name|len
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|MINCLSIZE
condition|)
block|{
name|m
operator|=
name|m_gethdr
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
comment|/* 		 * Align the data in case additional headers are added. 		 * This should only happen when a WEP header is added 		 * which only happens for shared key authentication mgt 		 * frames which all fit in MHLEN. 		 */
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|MH_ALIGN
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|m
operator|=
name|m_getcl
argument_list|(
name|M_NOWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|MC_ALIGN
argument_list|(
name|m
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
block|{
name|m
operator|->
name|m_data
operator|+=
name|headroom
expr_stmt|;
operator|*
name|frm
operator|=
name|m
operator|->
name|m_data
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/*  * Re-align the payload in the mbuf.  This is mainly used (right now)  * to handle IP header alignment requirements on certain architectures.  */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|ieee80211_realign
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|size_t
name|align
parameter_list|)
block|{
name|int
name|pktlen
decl_stmt|,
name|space
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|pktlen
operator|=
name|m
operator|->
name|m_pkthdr
operator|.
name|len
expr_stmt|;
name|space
operator|=
name|pktlen
operator|+
name|align
expr_stmt|;
if|if
condition|(
name|space
operator|<
name|MINCLSIZE
condition|)
name|n
operator|=
name|m_gethdr
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
else|else
block|{
name|n
operator|=
name|m_getjcl
argument_list|(
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|,
name|M_PKTHDR
argument_list|,
name|space
operator|<=
name|MCLBYTES
condition|?
name|MCLBYTES
else|:
if|#
directive|if
name|MJUMPAGESIZE
operator|!=
name|MCLBYTES
name|space
operator|<=
name|MJUMPAGESIZE
condition|?
name|MJUMPAGESIZE
else|:
endif|#
directive|endif
name|space
operator|<=
name|MJUM9BYTES
condition|?
name|MJUM9BYTES
else|:
name|MJUM16BYTES
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|__predict_true
argument_list|(
name|n
operator|!=
name|NULL
argument_list|)
condition|)
block|{
name|m_move_pkthdr
argument_list|(
name|n
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|ALIGN
argument_list|(
name|n
operator|->
name|m_data
operator|+
name|align
argument_list|)
operator|-
name|align
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
literal|0
argument_list|,
name|pktlen
argument_list|,
name|mtod
argument_list|(
name|n
argument_list|,
name|caddr_t
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
name|pktlen
expr_stmt|;
block|}
else|else
block|{
name|IEEE80211_DISCARD
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_ANY
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|"%s"
argument_list|,
literal|"no mbuf to realign"
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_badalign
operator|++
expr_stmt|;
block|}
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_function
name|int
name|ieee80211_add_callback
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|struct
name|ieee80211_cb
modifier|*
name|cb
decl_stmt|;
name|mtag
operator|=
name|m_tag_alloc
argument_list|(
name|MTAG_ABI_NET80211
argument_list|,
name|NET80211_TAG_CALLBACK
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_cb
argument_list|)
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|cb
operator|=
operator|(
expr|struct
name|ieee80211_cb
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
expr_stmt|;
name|cb
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|cb
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|m_tag_prepend
argument_list|(
name|m
argument_list|,
name|mtag
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_TXCB
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_process_callback
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|status
parameter_list|)
block|{
name|struct
name|m_tag
modifier|*
name|mtag
decl_stmt|;
name|mtag
operator|=
name|m_tag_locate
argument_list|(
name|m
argument_list|,
name|MTAG_ABI_NET80211
argument_list|,
name|NET80211_TAG_CALLBACK
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtag
operator|!=
name|NULL
condition|)
block|{
name|struct
name|ieee80211_cb
modifier|*
name|cb
init|=
operator|(
expr|struct
name|ieee80211_cb
operator|*
operator|)
operator|(
name|mtag
operator|+
literal|1
operator|)
decl_stmt|;
name|cb
operator|->
name|func
argument_list|(
name|ni
argument_list|,
name|cb
operator|->
name|arg
argument_list|,
name|status
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_include
include|#
directive|include
file|<sys/libkern.h>
end_include

begin_function
name|void
name|get_random_bytes
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|uint8_t
modifier|*
name|dp
init|=
name|p
decl_stmt|;
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|uint32_t
name|v
init|=
name|arc4random
argument_list|()
decl_stmt|;
name|size_t
name|nb
init|=
name|n
operator|>
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
else|:
name|n
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|v
argument_list|,
name|dp
argument_list|,
name|n
operator|>
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
else|:
name|n
argument_list|)
expr_stmt|;
name|dp
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|,
name|n
operator|-=
name|nb
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Helper function for events that pass just a single mac address.  */
end_comment

begin_function
specifier|static
name|void
name|notify_macaddr
parameter_list|(
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|op
parameter_list|,
specifier|const
name|uint8_t
name|mac
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|)
block|{
name|struct
name|ieee80211_join_event
name|iev
decl_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|iev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|iev
operator|.
name|iev_addr
argument_list|,
name|mac
argument_list|)
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|op
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_node_join
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|newassoc
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|CURVNET_SET_QUIET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%snode join"
argument_list|,
operator|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|)
condition|?
literal|"bss "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
condition|)
block|{
name|notify_macaddr
argument_list|(
name|ifp
argument_list|,
name|newassoc
condition|?
name|RTM_IEEE80211_ASSOC
else|:
name|RTM_IEEE80211_REASSOC
argument_list|,
name|ni
operator|->
name|ni_bssid
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_UP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|notify_macaddr
argument_list|(
name|ifp
argument_list|,
name|newassoc
condition|?
name|RTM_IEEE80211_JOIN
else|:
name|RTM_IEEE80211_REJOIN
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_node_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|CURVNET_SET_QUIET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%snode leave"
argument_list|,
operator|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
operator|)
condition|?
literal|"bss "
else|:
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|vap
operator|->
name|iv_bss
condition|)
block|{
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_DISASSOC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|if_link_state_change
argument_list|(
name|ifp
argument_list|,
name|LINK_STATE_DOWN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* fire off wireless event station leaving */
name|notify_macaddr
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_LEAVE
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_scan_done
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|IEEE80211_DPRINTF
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_SCAN
argument_list|,
literal|"%s\n"
argument_list|,
literal|"notify scan done"
argument_list|)
expr_stmt|;
comment|/* dispatch wireless event indicating scan completed */
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_SCAN
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_replay_failure
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|u_int64_t
name|rsc
parameter_list|,
name|int
name|tid
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
literal|"%s replay detected<rsc %ju, csc %ju, keyix %u rxkeyix %u>"
argument_list|,
name|k
operator|->
name|wk_cipher
operator|->
name|ic_name
argument_list|,
operator|(
name|intmax_t
operator|)
name|rsc
argument_list|,
operator|(
name|intmax_t
operator|)
name|k
operator|->
name|wk_keyrsc
index|[
name|tid
index|]
argument_list|,
name|k
operator|->
name|wk_keyix
argument_list|,
name|k
operator|->
name|wk_rxkeyix
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: for cipher test modules */
name|struct
name|ieee80211_replay_event
name|iev
decl_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|iev
operator|.
name|iev_dst
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|iev
operator|.
name|iev_src
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_cipher
operator|=
name|k
operator|->
name|wk_cipher
operator|->
name|ic_cipher
expr_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_rxkeyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|)
name|iev
operator|.
name|iev_keyix
operator|=
name|k
operator|->
name|wk_rxkeyix
expr_stmt|;
else|else
name|iev
operator|.
name|iev_keyix
operator|=
name|k
operator|->
name|wk_keyix
expr_stmt|;
name|iev
operator|.
name|iev_keyrsc
operator|=
name|k
operator|->
name|wk_keyrsc
index|[
name|tid
index|]
expr_stmt|;
name|iev
operator|.
name|iev_rsc
operator|=
name|rsc
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_REPLAY
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_notify_michael_failure
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
name|u_int
name|keyix
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|IEEE80211_NOTE_MAC
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
literal|"michael MIC verification failed<keyix %u>"
argument_list|,
name|keyix
argument_list|)
expr_stmt|;
name|vap
operator|->
name|iv_stats
operator|.
name|is_rx_tkipmic
operator|++
expr_stmt|;
if|if
condition|(
name|ifp
operator|!=
name|NULL
condition|)
block|{
comment|/* NB: for cipher test modules */
name|struct
name|ieee80211_michael_event
name|iev
decl_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|iev
operator|.
name|iev_dst
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|iev
operator|.
name|iev_src
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_cipher
operator|=
name|IEEE80211_CIPHER_TKIP
expr_stmt|;
name|iev
operator|.
name|iev_keyix
operator|=
name|keyix
expr_stmt|;
name|CURVNET_SET
argument_list|(
name|ifp
operator|->
name|if_vnet
argument_list|)
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_MICHAEL
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|CURVNET_RESTORE
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_notify_wds_discover
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|notify_macaddr
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_WDS
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_csa
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_csa_event
name|iev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|iev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_flags
operator|=
name|c
operator|->
name|ic_flags
expr_stmt|;
name|iev
operator|.
name|iev_freq
operator|=
name|c
operator|->
name|ic_freq
expr_stmt|;
name|iev
operator|.
name|iev_ieee
operator|=
name|c
operator|->
name|ic_ieee
expr_stmt|;
name|iev
operator|.
name|iev_mode
operator|=
name|mode
expr_stmt|;
name|iev
operator|.
name|iev_count
operator|=
name|count
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_CSA
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_radar
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_radar_event
name|iev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|iev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_flags
operator|=
name|c
operator|->
name|ic_flags
expr_stmt|;
name|iev
operator|.
name|iev_freq
operator|=
name|c
operator|->
name|ic_freq
expr_stmt|;
name|iev
operator|.
name|iev_ieee
operator|=
name|c
operator|->
name|ic_ieee
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_RADAR
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_cac
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
specifier|const
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|enum
name|ieee80211_notify_cac_event
name|type
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_cac_event
name|iev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|iev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_flags
operator|=
name|c
operator|->
name|ic_flags
expr_stmt|;
name|iev
operator|.
name|iev_freq
operator|=
name|c
operator|->
name|ic_freq
expr_stmt|;
name|iev
operator|.
name|iev_ieee
operator|=
name|c
operator|->
name|ic_ieee
expr_stmt|;
name|iev
operator|.
name|iev_type
operator|=
name|type
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_CAC
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_node_deauth
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"node deauth"
argument_list|)
expr_stmt|;
name|notify_macaddr
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_DEAUTH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_node_auth
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|IEEE80211_NOTE
argument_list|(
name|vap
argument_list|,
name|IEEE80211_MSG_NODE
argument_list|,
name|ni
argument_list|,
literal|"%s"
argument_list|,
literal|"node auth"
argument_list|)
expr_stmt|;
name|notify_macaddr
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_AUTH
argument_list|,
name|ni
operator|->
name|ni_macaddr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_country
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|,
specifier|const
name|uint8_t
name|bssid
index|[
name|IEEE80211_ADDR_LEN
index|]
parameter_list|,
specifier|const
name|uint8_t
name|cc
index|[
literal|2
index|]
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|vap
operator|->
name|iv_ifp
decl_stmt|;
name|struct
name|ieee80211_country_event
name|iev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|iev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_ADDR_COPY
argument_list|(
name|iev
operator|.
name|iev_addr
argument_list|,
name|bssid
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_cc
index|[
literal|0
index|]
operator|=
name|cc
index|[
literal|0
index|]
expr_stmt|;
name|iev
operator|.
name|iev_cc
index|[
literal|1
index|]
operator|=
name|cc
index|[
literal|1
index|]
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_COUNTRY
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_notify_radio
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|int
name|state
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
init|=
name|ic
operator|->
name|ic_ifp
decl_stmt|;
name|struct
name|ieee80211_radio_event
name|iev
decl_stmt|;
name|memset
argument_list|(
operator|&
name|iev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
name|iev
operator|.
name|iev_state
operator|=
name|state
expr_stmt|;
name|rt_ieee80211msg
argument_list|(
name|ifp
argument_list|,
name|RTM_IEEE80211_RADIO
argument_list|,
operator|&
name|iev
argument_list|,
sizeof|sizeof
argument_list|(
name|iev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_load_module
parameter_list|(
specifier|const
name|char
modifier|*
name|modname
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|notyet
operator|(
name|void
operator|)
name|kern_kldload
argument_list|(
name|curthread
argument_list|,
name|modname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"%s: load the %s module by hand for now.\n"
argument_list|,
name|__func__
argument_list|,
name|modname
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|wlan_bpfevent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|eventhandler_tag
name|wlan_ifllevent
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|bpf_track
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|,
name|int
name|dlt
parameter_list|,
name|int
name|attach
parameter_list|)
block|{
comment|/* NB: identify vap's by if_start */
if|if
condition|(
name|dlt
operator|==
name|DLT_IEEE802_11_RADIO
operator|&&
name|ifp
operator|->
name|if_start
operator|==
name|ieee80211_start
condition|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ifp
operator|->
name|if_softc
decl_stmt|;
comment|/* 		 * Track bpf radiotap listener state.  We mark the vap 		 * to indicate if any listener is present and the com 		 * to indicate if any listener exists on any associated 		 * vap.  This flag is used by drivers to prepare radiotap 		 * state only when needed. 		 */
if|if
condition|(
name|attach
condition|)
block|{
name|ieee80211_syncflag_ext
argument_list|(
name|vap
argument_list|,
name|IEEE80211_FEXT_BPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|atomic_add_int
argument_list|(
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_montaps
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|bpf_peers_present
argument_list|(
name|vap
operator|->
name|iv_rawbpf
argument_list|)
condition|)
block|{
name|ieee80211_syncflag_ext
argument_list|(
name|vap
argument_list|,
operator|-
name|IEEE80211_FEXT_BPF
argument_list|)
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_MONITOR
condition|)
name|atomic_subtract_int
argument_list|(
operator|&
name|vap
operator|->
name|iv_ic
operator|->
name|ic_montaps
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|wlan_iflladdr
parameter_list|(
name|void
modifier|*
name|arg
name|__unused
parameter_list|,
name|struct
name|ifnet
modifier|*
name|ifp
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ifp
operator|->
name|if_l2com
decl_stmt|;
name|struct
name|ieee80211vap
modifier|*
name|vap
decl_stmt|,
modifier|*
name|next
decl_stmt|;
if|if
condition|(
name|ifp
operator|->
name|if_type
operator|!=
name|IFT_IEEE80211
operator|||
name|ic
operator|==
name|NULL
condition|)
return|return;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|vap
argument_list|,
argument|&ic->ic_vaps
argument_list|,
argument|iv_next
argument_list|,
argument|next
argument_list|)
block|{
comment|/* 		 * If the MAC address has changed on the parent and it was 		 * copied to the vap on creation then re-sync. 		 */
if|if
condition|(
name|vap
operator|->
name|iv_ic
operator|==
name|ic
operator|&&
operator|(
name|vap
operator|->
name|iv_flags_ext
operator|&
name|IEEE80211_FEXT_UNIQMAC
operator|)
operator|==
literal|0
condition|)
block|{
name|IEEE80211_ADDR_COPY
argument_list|(
name|vap
operator|->
name|iv_myaddr
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|)
expr_stmt|;
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
name|if_setlladdr
argument_list|(
name|vap
operator|->
name|iv_ifp
argument_list|,
name|IF_LLADDR
argument_list|(
name|ifp
argument_list|)
argument_list|,
name|IEEE80211_ADDR_LEN
argument_list|)
expr_stmt|;
name|IEEE80211_LOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
block|}
name|IEEE80211_UNLOCK
argument_list|(
name|ic
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Module glue.  *  * NB: the module name is "wlan" for compatibility with NetBSD.  */
end_comment

begin_function
specifier|static
name|int
name|wlan_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
if|if
condition|(
name|bootverbose
condition|)
name|printf
argument_list|(
literal|"wlan:<802.11 Link Layer>\n"
argument_list|)
expr_stmt|;
name|wlan_bpfevent
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|bpf_track
argument_list|,
name|bpf_track
argument_list|,
literal|0
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlan_bpfevent
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|wlan_ifllevent
operator|=
name|EVENTHANDLER_REGISTER
argument_list|(
name|iflladdr_event
argument_list|,
name|wlan_iflladdr
argument_list|,
name|NULL
argument_list|,
name|EVENTHANDLER_PRI_ANY
argument_list|)
expr_stmt|;
if|if
condition|(
name|wlan_ifllevent
operator|==
name|NULL
condition|)
block|{
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|bpf_track
argument_list|,
name|wlan_bpfevent
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|if_clone_attach
argument_list|(
operator|&
name|wlan_cloner
argument_list|)
expr_stmt|;
name|if_register_com_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|,
name|wlan_alloc
argument_list|,
name|wlan_free
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
name|if_deregister_com_alloc
argument_list|(
name|IFT_IEEE80211
argument_list|)
expr_stmt|;
name|if_clone_detach
argument_list|(
operator|&
name|wlan_cloner
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|bpf_track
argument_list|,
name|wlan_bpfevent
argument_list|)
expr_stmt|;
name|EVENTHANDLER_DEREGISTER
argument_list|(
name|iflladdr_event
argument_list|,
name|wlan_ifllevent
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|wlan_mod
init|=
block|{
literal|"wlan"
block|,
name|wlan_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|wlan
argument_list|,
name|wlan_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wlan
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wlan
argument_list|,
name|ether
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

