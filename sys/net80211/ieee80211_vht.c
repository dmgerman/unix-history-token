begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Adrian Chadd<adrian@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11ac-2013 protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_action.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_vht.h>
end_include

begin_comment
comment|/* define here, used throughout file */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
end_define

begin_define
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|ADDWORD
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = ((v)>> 8)& 0xff;		\ 	frm[2] = ((v)>> 16)& 0xff;		\ 	frm[3] = ((v)>> 24)& 0xff;		\ 	frm += 4;				\ } while (0)
end_define

begin_comment
comment|/*  * XXX TODO: handle WLAN_ACTION_VHT_OPMODE_NOTIF  *  * Look at mac80211/vht.c:ieee80211_vht_handle_opmode() for further details.  */
end_comment

begin_function
specifier|static
name|void
name|ieee80211_vht_init
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_vht
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_vht_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_vht_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_vht_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_vht_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_CONF_VHT
argument_list|(
name|ic
argument_list|)
condition|)
return|return;
name|vap
operator|->
name|iv_vhtcaps
operator|=
name|ic
operator|->
name|ic_vhtcaps
expr_stmt|;
name|vap
operator|->
name|iv_vhtextcaps
operator|=
name|ic
operator|->
name|ic_vhtextcaps
expr_stmt|;
comment|/* XXX assume VHT80 support; should really check vhtcaps */
name|vap
operator|->
name|iv_flags_vht
operator|=
name|IEEE80211_FVHT_VHT
operator||
name|IEEE80211_FVHT_USEVHT40
operator||
name|IEEE80211_FVHT_USEVHT80
expr_stmt|;
comment|/* XXX TODO: enable VHT80+80, VHT160 capabilities */
name|memcpy
argument_list|(
operator|&
name|vap
operator|->
name|iv_vht_mcsinfo
argument_list|,
operator|&
name|ic
operator|->
name|ic_vht_mcsinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_mcs_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{ }
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void vht_announce(struct ieee80211com *ic, enum ieee80211_phymode mode) { }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vht_mcs_to_num
parameter_list|(
name|int
name|m
parameter_list|)
block|{
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|IEEE80211_VHT_MCS_SUPPORT_0_7
case|:
return|return
operator|(
literal|7
operator|)
return|;
case|case
name|IEEE80211_VHT_MCS_SUPPORT_0_8
case|:
return|return
operator|(
literal|8
operator|)
return|;
case|case
name|IEEE80211_VHT_MCS_SUPPORT_0_9
case|:
return|return
operator|(
literal|9
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_vht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tx
decl_stmt|,
name|rx
decl_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_CONF_VHT
argument_list|(
name|ic
argument_list|)
condition|)
return|return;
comment|/* Channel width */
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"[VHT] Channel Widths: 20MHz, 40MHz, 80MHz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_vhtcaps
operator|&
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_160_80PLUS80MHZ
condition|)
name|printf
argument_list|(
literal|" 80+80MHz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ic
operator|->
name|ic_vhtcaps
operator|&
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_160MHZ
condition|)
name|printf
argument_list|(
literal|" 160MHz"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Features */
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"[VHT] Features: %b\n"
argument_list|,
name|ic
operator|->
name|ic_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_BITS
argument_list|)
expr_stmt|;
comment|/* For now, just 5GHz VHT.  Worry about 2GHz VHT later */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/* Each stream is 2 bits */
name|tx
operator|=
operator|(
name|ic
operator|->
name|ic_vht_mcsinfo
operator|.
name|tx_mcs_map
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
name|rx
operator|=
operator|(
name|ic
operator|->
name|ic_vht_mcsinfo
operator|.
name|rx_mcs_map
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|tx
operator|==
literal|3
operator|&&
name|rx
operator|==
literal|3
condition|)
continue|continue;
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"[VHT] NSS %d: TX MCS 0..%d, RX MCS 0..%d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|vht_mcs_to_num
argument_list|(
name|tx
argument_list|)
argument_list|,
name|vht_mcs_to_num
argument_list|(
name|rx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_vht_node_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_VHT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_VHT
expr_stmt|;
name|ni
operator|->
name|ni_vhtcap
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ni
operator|->
name|ni_vht_mcsinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_mcs_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an 802.11ac VHT operation IE.  */
end_comment

begin_function
name|void
name|ieee80211_parse_vhtopmode
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
comment|/* vht operation */
name|ni
operator|->
name|ni_vht_chanwidth
operator|=
name|ie
index|[
literal|2
index|]
expr_stmt|;
name|ni
operator|->
name|ni_vht_chan1
operator|=
name|ie
index|[
literal|3
index|]
expr_stmt|;
name|ni
operator|->
name|ni_vht_chan2
operator|=
name|ie
index|[
literal|4
index|]
expr_stmt|;
name|ni
operator|->
name|ni_vht_basicmcs
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: chan1=%d, chan2=%d, chanwidth=%d, basicmcs=0x%04x\n", 	    __func__, 	    ni->ni_vht_chan1, 	    ni->ni_vht_chan2, 	    ni->ni_vht_chanwidth, 	    ni->ni_vht_basicmcs);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Parse an 802.11ac VHT capability IE.  */
end_comment

begin_function
name|void
name|ieee80211_parse_vhtcap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
comment|/* vht capability */
name|ni
operator|->
name|ni_vhtcap
operator|=
name|le32dec
argument_list|(
name|ie
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* suppmcs */
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|rx_mcs_map
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|6
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|rx_highest
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|8
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_mcs_map
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|10
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_highest
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieee80211_vht_updateparams
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtcap_ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtop_ie
parameter_list|)
block|{
comment|//printf("%s: called\n", __func__);
name|ieee80211_parse_vhtcap
argument_list|(
name|ni
argument_list|,
name|vhtcap_ie
argument_list|)
expr_stmt|;
name|ieee80211_parse_vhtopmode
argument_list|(
name|ni
argument_list|,
name|vhtop_ie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_setup_vht_rates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtcap_ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtop_ie
parameter_list|)
block|{
comment|//printf("%s: called\n", __func__);
comment|/* XXX TODO */
block|}
end_function

begin_function
name|void
name|ieee80211_vht_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_vht_node_join
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_node_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_vhtcap
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|uint32_t
name|cap
decl_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vhtcap
argument_list|)
argument_list|)
expr_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VHT_CAP
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vhtcap
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * For now, don't do any configuration. 	 * Just populate the node configuration. 	 * We can worry about making it configurable later. 	 */
name|cap
operator|=
name|ni
operator|->
name|ni_vhtcap
expr_stmt|;
comment|/* 	 * XXX TODO: any capability changes required by 	 * configuration. 	 */
comment|/* 32-bit VHT capability */
name|ADDWORD
argument_list|(
name|frm
argument_list|,
name|cap
argument_list|)
expr_stmt|;
comment|/* suppmcs */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|rx_mcs_map
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|rx_highest
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_mcs_map
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_highest
argument_list|)
expr_stmt|;
return|return
operator|(
name|frm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ieee80211_vht_get_chwidth_ie
parameter_list|(
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
comment|/* 	 * XXX TODO: look at the node configuration as 	 * well? 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT160
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_160MHZ
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT80_80
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_80P80MHZ
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT80
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_80MHZ
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT40
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_USE_HT
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT20
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_USE_HT
return|;
block|}
comment|/* We shouldn't get here */
name|printf
argument_list|(
literal|"%s: called on a non-VHT channel (freq=%d, flags=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|IEEE80211_VHT_CHANWIDTH_USE_HT
return|;
block|}
end_function

begin_comment
comment|/*  * Note: this just uses the current channel information;  * it doesn't use the node info after parsing.  *  * XXX TODO: need to make the basic MCS set configurable.  * XXX TODO: read 802.11-2013 to determine what to set  *           chwidth to when scanning.  I have a feeling  *           it isn't involved in scanning and we shouldn't  *           be sending it; and I don't yet know what to set  *           it to for IBSS or hostap where the peer may be  *           a completely different channel width to us.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_vhtinfo
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|memset
argument_list|(
name|frm
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vht_operation
argument_list|)
argument_list|)
expr_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VHT_OPMODE
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vht_operation
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
comment|/* 	 * XXX if it's a station, then see if we have a node 	 * channel or ANYC.  If it's ANYC then assume we're 	 * scanning, and announce our capabilities. 	 * 	 * This should set the "20/40/80/160MHz wide config"; 	 * the 80/80 or 160MHz wide config is done in VHTCAP. 	 * 	 * Other modes - just limit it to the channel. 	 */
comment|/* 8-bit chanwidth */
operator|*
name|frm
operator|++
operator|=
name|ieee80211_vht_get_chwidth_ie
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
comment|/* 8-bit freq1 */
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_vht_ch_freq1
expr_stmt|;
comment|/* 8-bit freq2 */
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_vht_ch_freq2
expr_stmt|;
comment|/* 16-bit basic MCS set - just MCS0..7 for NSS=1 for now */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0xfffc
argument_list|)
expr_stmt|;
return|return
operator|(
name|frm
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_update_cap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtcap_ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtop_ie
parameter_list|)
block|{
name|ieee80211_parse_vhtcap
argument_list|(
name|ni
argument_list|,
name|vhtcap_ie
argument_list|)
expr_stmt|;
name|ieee80211_parse_vhtopmode
argument_list|(
name|ni
argument_list|,
name|vhtop_ie
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|findvhtchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|vhtflags
parameter_list|)
block|{
return|return
operator|(
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_VHT
operator|)
operator||
name|vhtflags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle channel promotion to VHT, similar to ieee80211_ht_adjust_channel().  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_vht_adjust_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
comment|/* First case - handle channel demotion - if VHT isn't set */
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_VHT
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: demoting channel %d/0x%08x\n", __func__, 		    chan->ic_ieee, chan->ic_flags);
endif|#
directive|endif
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_VHT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|chan
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: .. to %d/0x%08x\n", __func__, 		    c->ic_ieee, c->ic_flags);
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
comment|/* 	 * We can upgrade to VHT - attempt to do so 	 * 	 * Note: we don't clear the HT flags, these are the hints 	 * for HT40U/HT40D when selecting VHT40 or larger channels. 	 */
comment|/* Start with VHT80 */
name|c
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT160
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT80P80
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT80_80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT80
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT40
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT40U
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT40
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT40D
argument_list|)
expr_stmt|;
comment|/* 	 * If we get here, VHT20 is always possible because we checked 	 * for IEEE80211_FVHT_VHT above. 	 */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: selected %d/0x%08x\n", __func__, c->ic_ieee, c->ic_flags);
endif|#
directive|endif
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

end_unit

