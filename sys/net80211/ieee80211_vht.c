begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2017 Adrian Chadd<adrian@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * IEEE 802.11ac-2013 protocol support.  */
end_comment

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_include
include|#
directive|include
file|"opt_wlan.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_action.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_input.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_vht.h>
end_include

begin_comment
comment|/* define here, used throughout file */
end_comment

begin_define
define|#
directive|define
name|MS
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)& _f)>> _f##_S)
end_define

begin_define
define|#
directive|define
name|SM
parameter_list|(
name|_v
parameter_list|,
name|_f
parameter_list|)
value|(((_v)<< _f##_S)& _f)
end_define

begin_define
define|#
directive|define
name|ADDSHORT
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = (v)>> 8;			\ 	frm += 2;				\ } while (0)
end_define

begin_define
define|#
directive|define
name|ADDWORD
parameter_list|(
name|frm
parameter_list|,
name|v
parameter_list|)
value|do {			\ 	frm[0] = (v)& 0xff;			\ 	frm[1] = ((v)>> 8)& 0xff;		\ 	frm[2] = ((v)>> 16)& 0xff;		\ 	frm[3] = ((v)>> 24)& 0xff;		\ 	frm += 4;				\ } while (0)
end_define

begin_comment
comment|/*  * Immediate TODO:  *  * + handle WLAN_ACTION_VHT_OPMODE_NOTIF and other VHT action frames  * + ensure vhtinfo/vhtcap parameters correctly use the negotiated  *   capabilities and ratesets  * + group ID management operation  */
end_comment

begin_comment
comment|/*  * XXX TODO: handle WLAN_ACTION_VHT_OPMODE_NOTIF  *  * Look at mac80211/vht.c:ieee80211_vht_handle_opmode() for further details.  */
end_comment

begin_function
specifier|static
name|int
name|vht_recv_action_placeholder
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|frm
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|efrm
parameter_list|)
block|{
name|ieee80211_note
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
literal|"%s: called; fc=0x%.2x/0x%.2x"
argument_list|,
name|__func__
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
argument_list|,
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vht_send_action_placeholder
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|action
parameter_list|,
name|void
modifier|*
name|arg0
parameter_list|)
block|{
name|ieee80211_note
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
literal|"%s: called; category=%d, action=%d"
argument_list|,
name|__func__
argument_list|,
name|category
argument_list|,
name|action
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ieee80211_vht_init
parameter_list|(
name|void
parameter_list|)
block|{
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_VHT
argument_list|,
name|WLAN_ACTION_VHT_COMPRESSED_BF
argument_list|,
name|vht_recv_action_placeholder
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_VHT
argument_list|,
name|WLAN_ACTION_VHT_GROUPID_MGMT
argument_list|,
name|vht_recv_action_placeholder
argument_list|)
expr_stmt|;
name|ieee80211_recv_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_VHT
argument_list|,
name|WLAN_ACTION_VHT_OPMODE_NOTIF
argument_list|,
name|vht_recv_action_placeholder
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_VHT
argument_list|,
name|WLAN_ACTION_VHT_COMPRESSED_BF
argument_list|,
name|vht_send_action_placeholder
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_VHT
argument_list|,
name|WLAN_ACTION_VHT_GROUPID_MGMT
argument_list|,
name|vht_send_action_placeholder
argument_list|)
expr_stmt|;
name|ieee80211_send_action_register
argument_list|(
name|IEEE80211_ACTION_CAT_VHT
argument_list|,
name|WLAN_ACTION_VHT_OPMODE_NOTIF
argument_list|,
name|vht_send_action_placeholder
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|SYSINIT
argument_list|(
name|wlan_vht
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|,
name|ieee80211_vht_init
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|void
name|ieee80211_vht_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_vht_detach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_vht_vattach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|vap
operator|->
name|iv_ic
decl_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_CONF_VHT
argument_list|(
name|ic
argument_list|)
condition|)
return|return;
name|vap
operator|->
name|iv_vhtcaps
operator|=
name|ic
operator|->
name|ic_vhtcaps
expr_stmt|;
name|vap
operator|->
name|iv_vhtextcaps
operator|=
name|ic
operator|->
name|ic_vhtextcaps
expr_stmt|;
comment|/* XXX assume VHT80 support; should really check vhtcaps */
name|vap
operator|->
name|iv_flags_vht
operator|=
name|IEEE80211_FVHT_VHT
operator||
name|IEEE80211_FVHT_USEVHT40
operator||
name|IEEE80211_FVHT_USEVHT80
expr_stmt|;
comment|/* XXX TODO: enable VHT80+80, VHT160 capabilities */
name|memcpy
argument_list|(
operator|&
name|vap
operator|->
name|iv_vht_mcsinfo
argument_list|,
operator|&
name|ic
operator|->
name|ic_vht_mcsinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_mcs_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_vdetach
parameter_list|(
name|struct
name|ieee80211vap
modifier|*
name|vap
parameter_list|)
block|{ }
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static void vht_announce(struct ieee80211com *ic, enum ieee80211_phymode mode) { }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|vht_mcs_to_num
parameter_list|(
name|int
name|m
parameter_list|)
block|{
switch|switch
condition|(
name|m
condition|)
block|{
case|case
name|IEEE80211_VHT_MCS_SUPPORT_0_7
case|:
return|return
operator|(
literal|7
operator|)
return|;
case|case
name|IEEE80211_VHT_MCS_SUPPORT_0_8
case|:
return|return
operator|(
literal|8
operator|)
return|;
case|case
name|IEEE80211_VHT_MCS_SUPPORT_0_9
case|:
return|return
operator|(
literal|9
operator|)
return|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_vht_announce
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tx
decl_stmt|,
name|rx
decl_stmt|;
if|if
condition|(
operator|!
name|IEEE80211_CONF_VHT
argument_list|(
name|ic
argument_list|)
condition|)
return|return;
comment|/* Channel width */
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"[VHT] Channel Widths: 20MHz, 40MHz, 80MHz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MS
argument_list|(
name|ic
operator|->
name|ic_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_MASK
argument_list|)
operator|==
literal|2
condition|)
name|printf
argument_list|(
literal|" 80+80MHz"
argument_list|)
expr_stmt|;
if|if
condition|(
name|MS
argument_list|(
name|ic
operator|->
name|ic_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_MASK
argument_list|)
operator|>=
literal|1
condition|)
name|printf
argument_list|(
literal|" 160MHz"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Features */
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"[VHT] Features: %b\n"
argument_list|,
name|ic
operator|->
name|ic_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_BITS
argument_list|)
expr_stmt|;
comment|/* For now, just 5GHz VHT.  Worry about 2GHz VHT later */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/* Each stream is 2 bits */
name|tx
operator|=
operator|(
name|ic
operator|->
name|ic_vht_mcsinfo
operator|.
name|tx_mcs_map
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
name|rx
operator|=
operator|(
name|ic
operator|->
name|ic_vht_mcsinfo
operator|.
name|rx_mcs_map
operator|>>
operator|(
literal|2
operator|*
name|i
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|tx
operator|==
literal|3
operator|&&
name|rx
operator|==
literal|3
condition|)
continue|continue;
name|ic_printf
argument_list|(
name|ic
argument_list|,
literal|"[VHT] NSS %d: TX MCS 0..%d, RX MCS 0..%d\n"
argument_list|,
name|i
operator|+
literal|1
argument_list|,
name|vht_mcs_to_num
argument_list|(
name|tx
argument_list|)
argument_list|,
name|vht_mcs_to_num
argument_list|(
name|rx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|ieee80211_vht_node_init
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator||=
name|IEEE80211_NODE_VHT
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_node_cleanup
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_flags
operator|&=
operator|~
name|IEEE80211_NODE_VHT
expr_stmt|;
name|ni
operator|->
name|ni_vhtcap
operator|=
literal|0
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ni
operator|->
name|ni_vht_mcsinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_vht_mcs_info
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Parse an 802.11ac VHT operation IE.  */
end_comment

begin_function
name|void
name|ieee80211_parse_vhtopmode
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
comment|/* vht operation */
name|ni
operator|->
name|ni_vht_chanwidth
operator|=
name|ie
index|[
literal|2
index|]
expr_stmt|;
name|ni
operator|->
name|ni_vht_chan1
operator|=
name|ie
index|[
literal|3
index|]
expr_stmt|;
name|ni
operator|->
name|ni_vht_chan2
operator|=
name|ie
index|[
literal|4
index|]
expr_stmt|;
name|ni
operator|->
name|ni_vht_basicmcs
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|5
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: chan1=%d, chan2=%d, chanwidth=%d, basicmcs=0x%04x\n", 	    __func__, 	    ni->ni_vht_chan1, 	    ni->ni_vht_chan2, 	    ni->ni_vht_chanwidth, 	    ni->ni_vht_basicmcs);
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Parse an 802.11ac VHT capability IE.  */
end_comment

begin_function
name|void
name|ieee80211_parse_vhtcap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|ie
parameter_list|)
block|{
comment|/* vht capability */
name|ni
operator|->
name|ni_vhtcap
operator|=
name|le32dec
argument_list|(
name|ie
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* suppmcs */
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|rx_mcs_map
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|6
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|rx_highest
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|8
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_mcs_map
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|10
argument_list|)
expr_stmt|;
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_highest
operator|=
name|le16dec
argument_list|(
name|ie
operator|+
literal|12
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|ieee80211_vht_updateparams
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtcap_ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtop_ie
parameter_list|)
block|{
comment|//printf("%s: called\n", __func__);
name|ieee80211_parse_vhtcap
argument_list|(
name|ni
argument_list|,
name|vhtcap_ie
argument_list|)
expr_stmt|;
name|ieee80211_parse_vhtopmode
argument_list|(
name|ni
argument_list|,
name|vhtop_ie
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_setup_vht_rates
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtcap_ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtop_ie
parameter_list|)
block|{
comment|//printf("%s: called\n", __func__);
comment|/* XXX TODO */
block|}
end_function

begin_function
name|void
name|ieee80211_vht_timeout
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|)
block|{ }
end_function

begin_function
name|void
name|ieee80211_vht_node_join
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_node_leave
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|IEEE80211_NOTE
argument_list|(
name|ni
operator|->
name|ni_vap
argument_list|,
name|IEEE80211_MSG_11N
argument_list|,
name|ni
argument_list|,
literal|"%s: called"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calculate the VHTCAP IE for a given node.  *  * This includes calculating the capability intersection based on the  * current operating mode and intersection of the TX/RX MCS maps.  *  * The standard only makes it clear about MCS rate negotiation  * and MCS basic rates (which must be a subset of the general  * negotiated rates).  It doesn't make it clear that the AP should  * figure out the minimum functional overlap with the STA and  * support that.  *  * Note: this is in host order, not in 802.11 endian order.  *  * TODO: ensure I re-read 9.7.11 Rate Selection for VHT STAs.  *  * TODO: investigate what we should negotiate for MU-MIMO beamforming  *       options.  *  * opmode is '1' for "vhtcap as if I'm a STA", 0 otherwise.  */
end_comment

begin_function
name|void
name|ieee80211_vht_get_vhtcap_ie
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_ie_vhtcap
modifier|*
name|vhtcap
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|struct
name|ieee80211vap
modifier|*
name|vap
init|=
name|ni
operator|->
name|ni_vap
decl_stmt|;
comment|//	struct ieee80211com *ic = vap->iv_ic;
name|uint32_t
name|val
decl_stmt|,
name|val1
decl_stmt|,
name|val2
decl_stmt|;
name|uint32_t
name|new_vhtcap
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vhtcap
operator|->
name|ie
operator|=
name|IEEE80211_ELEMID_VHT_CAP
expr_stmt|;
name|vhtcap
operator|->
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vhtcap
argument_list|)
operator|-
literal|2
expr_stmt|;
comment|/* 	 * Capabilities - it depends on whether we are a station 	 * or not. 	 */
name|new_vhtcap
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Station - use our desired configuration based on 	 * local config, local device bits and the already-learnt 	 * vhtcap/vhtinfo IE in the node. 	 */
comment|/* Limit MPDU size to the smaller of the two */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_MAX_MPDU_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_MAX_MPDU_MASK
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_MAX_MPDU_MASK
argument_list|)
expr_stmt|;
comment|/* Limit supp channel config */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_MASK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val2
operator|==
literal|2
operator|)
operator|&&
operator|(
operator|(
name|vap
operator|->
name|iv_flags_vht
operator|&
name|IEEE80211_FVHT_USEVHT80P80
operator|)
operator|==
literal|0
operator|)
condition|)
name|val2
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|val2
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|(
name|vap
operator|->
name|iv_flags_vht
operator|&
name|IEEE80211_FVHT_USEVHT160
operator|)
operator|==
literal|0
operator|)
condition|)
name|val2
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SUPP_CHAN_WIDTH_MASK
argument_list|)
expr_stmt|;
comment|/* RX LDPC */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_RXLDPC
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_RXLDPC
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_RXLDPC
argument_list|)
expr_stmt|;
comment|/* Short-GI 80 */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SHORT_GI_80
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_SHORT_GI_80
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SHORT_GI_80
argument_list|)
expr_stmt|;
comment|/* Short-GI 160 */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SHORT_GI_160
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_SHORT_GI_160
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SHORT_GI_160
argument_list|)
expr_stmt|;
comment|/* 	 * STBC is slightly more complicated. 	 * 	 * In non-STA mode, we just announce our capabilities and that 	 * is that. 	 * 	 * In STA mode, we should calculate our capabilities based on 	 * local capabilities /and/ what the remote says. So: 	 * 	 * + Only TX STBC if we support it and the remote supports RX STBC; 	 * + Only announce RX STBC if we support it and the remote supports 	 *   TX STBC; 	 * + RX STBC should be the minimum of local and remote RX STBC; 	 */
comment|/* TX STBC */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_TXSTBC
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
comment|/* STA mode - enable it only if node RXSTBC is non-zero */
name|val2
operator|=
operator|!
operator|!
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_RXSTBC_MASK
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
comment|/* XXX For now, use the 11n config flag */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_STBC_TX
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_TXSTBC
argument_list|)
expr_stmt|;
comment|/* RX STBC1..4 */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_RXSTBC_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
comment|/* STA mode - enable it only if node TXSTBC is non-zero */
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_TXSTBC
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
comment|/* XXX For now, use the 11n config flag */
if|if
condition|(
operator|(
name|vap
operator|->
name|iv_flags_ht
operator|&
name|IEEE80211_FHT_STBC_RX
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_RXSTBC_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * Finally - if RXSTBC is 0, then don't enable TXSTBC. 	 * Strictly speaking a device can TXSTBC and not RXSTBC, but 	 * it would be silly. 	 */
if|if
condition|(
name|val
operator|==
literal|0
condition|)
name|new_vhtcap
operator|&=
operator|~
name|IEEE80211_VHTCAP_TXSTBC
expr_stmt|;
comment|/* 	 * Some of these fields require other fields to exist. 	 * So before using it, the parent field needs to be checked 	 * otherwise the overridden value may be wrong. 	 * 	 * For example, if SU beamformee is set to 0, then BF STS 	 * needs to be 0. 	 */
comment|/* SU Beamformer capable */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMER_CAPABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMER_CAPABLE
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMER_CAPABLE
argument_list|)
expr_stmt|;
comment|/* SU Beamformee capable */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMEE_CAPABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMEE_CAPABLE
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMEE_CAPABLE
argument_list|)
expr_stmt|;
comment|/* Beamformee STS capability - only if SU beamformee capable */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_BEAMFORMEE_STS_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
block|{
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_BEAMFORMEE_STS_MASK
argument_list|)
expr_stmt|;
block|}
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_vhtcap
operator|&
name|IEEE80211_VHTCAP_SU_BEAMFORMEE_CAPABLE
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_BEAMFORMEE_STS_MASK
argument_list|)
expr_stmt|;
comment|/* Sounding dimensions - only if SU beamformer capable */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_SOUNDING_DIMENSIONS_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_SOUNDING_DIMENSIONS_MASK
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_vhtcap
operator|&
name|IEEE80211_VHTCAP_SU_BEAMFORMER_CAPABLE
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SOUNDING_DIMENSIONS_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * MU Beamformer capable - only if SU BFF capable, MU BFF capable 	 * and STA (not AP) 	 */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_MU_BEAMFORMER_CAPABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_MU_BEAMFORMER_CAPABLE
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_vhtcap
operator|&
name|IEEE80211_VHTCAP_SU_BEAMFORMER_CAPABLE
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
literal|1
condition|)
comment|/* Only enable for STA mode */
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMER_CAPABLE
argument_list|)
expr_stmt|;
comment|/* 	 * MU Beamformee capable - only if SU BFE capable, MU BFE capable 	 * and AP (not STA) 	 */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_MU_BEAMFORMEE_CAPABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_MU_BEAMFORMEE_CAPABLE
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_vhtcap
operator|&
name|IEEE80211_VHTCAP_SU_BEAMFORMEE_CAPABLE
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opmode
operator|!=
literal|0
condition|)
comment|/* Only enable for AP mode */
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_SU_BEAMFORMEE_CAPABLE
argument_list|)
expr_stmt|;
comment|/* VHT TXOP PS */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_VHT_TXOP_PS
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_VHT_TXOP_PS
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_VHT_TXOP_PS
argument_list|)
expr_stmt|;
comment|/* HTC_VHT */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_HTC_VHT
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_HTC_VHT
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_HTC_VHT
argument_list|)
expr_stmt|;
comment|/* A-MPDU length max */
comment|/* XXX TODO: we need a userland config knob for this */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_MAX_A_MPDU_LENGTH_EXPONENT_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * Link adaptation is only valid if HTC-VHT capable is 1. 	 * Otherwise, always set it to 0. 	 */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_VHT_LINK_ADAPTATION_VHT_MASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_VHT_LINK_ADAPTATION_VHT_MASK
argument_list|)
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new_vhtcap
operator|&
name|IEEE80211_VHTCAP_HTC_VHT
operator|)
operator|==
literal|0
condition|)
name|val
operator|=
literal|0
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_VHT_LINK_ADAPTATION_VHT_MASK
argument_list|)
expr_stmt|;
comment|/* 	 * The following two options are 0 if the pattern may change, 1 if it 	 * does not change.  So, downgrade to the higher value. 	 */
comment|/* RX antenna pattern */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_RX_ANTENNA_PATTERN
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_RX_ANTENNA_PATTERN
argument_list|)
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_RX_ANTENNA_PATTERN
argument_list|)
expr_stmt|;
comment|/* TX antenna pattern */
name|val2
operator|=
name|val1
operator|=
name|MS
argument_list|(
name|vap
operator|->
name|iv_vhtcaps
argument_list|,
name|IEEE80211_VHTCAP_TX_ANTENNA_PATTERN
argument_list|)
expr_stmt|;
if|if
condition|(
name|opmode
operator|==
literal|1
condition|)
name|val2
operator|=
name|MS
argument_list|(
name|ni
operator|->
name|ni_vhtcap
argument_list|,
name|IEEE80211_VHTCAP_TX_ANTENNA_PATTERN
argument_list|)
expr_stmt|;
name|val
operator|=
name|MAX
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
name|new_vhtcap
operator||=
name|SM
argument_list|(
name|val
argument_list|,
name|IEEE80211_VHTCAP_TX_ANTENNA_PATTERN
argument_list|)
expr_stmt|;
comment|/* 	 * MCS set - again, we announce what we want to use 	 * based on configuration, device capabilities and 	 * already-learnt vhtcap/vhtinfo IE information. 	 */
comment|/* MCS set - start with whatever the device supports */
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|rx_mcs_map
operator|=
name|vap
operator|->
name|iv_vht_mcsinfo
operator|.
name|rx_mcs_map
expr_stmt|;
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|rx_highest
operator|=
literal|0
expr_stmt|;
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|tx_mcs_map
operator|=
name|vap
operator|->
name|iv_vht_mcsinfo
operator|.
name|tx_mcs_map
expr_stmt|;
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|tx_highest
operator|=
literal|0
expr_stmt|;
name|vhtcap
operator|->
name|vht_cap_info
operator|=
name|new_vhtcap
expr_stmt|;
comment|/* 	 * Now, if we're a STA, mask off whatever the AP doesn't support. 	 * Ie, we continue to state we can receive whatever we can do, 	 * but we only announce that we will transmit rates that meet 	 * the AP requirement. 	 * 	 * Note: 0 - MCS0..7; 1 - MCS0..8; 2 - MCS0..9; 3 = not supported. 	 * We can't just use MIN() because '3' means "no", so special case it. 	 */
if|if
condition|(
name|opmode
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|val1
operator|=
operator|(
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|tx_mcs_map
operator|>>
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
name|val2
operator|=
operator|(
name|ni
operator|->
name|ni_vht_mcsinfo
operator|.
name|tx_mcs_map
operator|>>
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
operator|&
literal|0x3
expr_stmt|;
name|val
operator|=
name|MIN
argument_list|(
name|val1
argument_list|,
name|val2
argument_list|)
expr_stmt|;
if|if
condition|(
name|val1
operator|==
literal|3
operator|||
name|val2
operator|==
literal|3
condition|)
name|val
operator|=
literal|3
expr_stmt|;
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|tx_mcs_map
operator|&=
operator|~
operator|(
literal|0x3
operator|<<
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
name|vhtcap
operator|->
name|supp_mcs
operator|.
name|tx_mcs_map
operator||=
operator|(
name|val
operator|<<
operator|(
name|i
operator|*
literal|2
operator|)
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add a VHTCAP field.  *  * If in station mode, we announce what we would like our  * desired configuration to be.  *  * Else, we announce our capabilities based on our current  * configuration.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_vhtcap
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|struct
name|ieee80211_ie_vhtcap
name|vhtcap
decl_stmt|;
name|int
name|opmode
decl_stmt|;
name|opmode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|ni_vap
operator|->
name|iv_opmode
operator|==
name|IEEE80211_M_STA
condition|)
name|opmode
operator|=
literal|1
expr_stmt|;
name|ieee80211_vht_get_vhtcap_ie
argument_list|(
name|ni
argument_list|,
operator|&
name|vhtcap
argument_list|,
name|opmode
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|frm
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vhtcap
argument_list|)
argument_list|)
expr_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VHT_CAP
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vhtcap
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
comment|/* 32-bit VHT capability */
name|ADDWORD
argument_list|(
name|frm
argument_list|,
name|vhtcap
operator|.
name|vht_cap_info
argument_list|)
expr_stmt|;
comment|/* suppmcs */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|vhtcap
operator|.
name|supp_mcs
operator|.
name|rx_mcs_map
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|vhtcap
operator|.
name|supp_mcs
operator|.
name|rx_highest
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|vhtcap
operator|.
name|supp_mcs
operator|.
name|tx_mcs_map
argument_list|)
expr_stmt|;
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
name|vhtcap
operator|.
name|supp_mcs
operator|.
name|tx_highest
argument_list|)
expr_stmt|;
return|return
operator|(
name|frm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|ieee80211_vht_get_chwidth_ie
parameter_list|(
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|)
block|{
comment|/* 	 * XXX TODO: look at the node configuration as 	 * well? 	 */
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT160
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_160MHZ
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT80_80
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_80P80MHZ
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT80
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_80MHZ
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT40
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_USE_HT
return|;
block|}
if|if
condition|(
name|IEEE80211_IS_CHAN_VHT20
argument_list|(
name|c
argument_list|)
condition|)
block|{
return|return
name|IEEE80211_VHT_CHANWIDTH_USE_HT
return|;
block|}
comment|/* We shouldn't get here */
name|printf
argument_list|(
literal|"%s: called on a non-VHT channel (freq=%d, flags=0x%08x\n"
argument_list|,
name|__func__
argument_list|,
operator|(
name|int
operator|)
name|c
operator|->
name|ic_freq
argument_list|,
name|c
operator|->
name|ic_flags
argument_list|)
expr_stmt|;
return|return
name|IEEE80211_VHT_CHANWIDTH_USE_HT
return|;
block|}
end_function

begin_comment
comment|/*  * Note: this just uses the current channel information;  * it doesn't use the node info after parsing.  *  * XXX TODO: need to make the basic MCS set configurable.  * XXX TODO: read 802.11-2013 to determine what to set  *           chwidth to when scanning.  I have a feeling  *           it isn't involved in scanning and we shouldn't  *           be sending it; and I don't yet know what to set  *           it to for IBSS or hostap where the peer may be  *           a completely different channel width to us.  */
end_comment

begin_function
name|uint8_t
modifier|*
name|ieee80211_add_vhtinfo
parameter_list|(
name|uint8_t
modifier|*
name|frm
parameter_list|,
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|)
block|{
name|memset
argument_list|(
name|frm
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vht_operation
argument_list|)
argument_list|)
expr_stmt|;
name|frm
index|[
literal|0
index|]
operator|=
name|IEEE80211_ELEMID_VHT_OPMODE
expr_stmt|;
name|frm
index|[
literal|1
index|]
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ieee80211_ie_vht_operation
argument_list|)
operator|-
literal|2
expr_stmt|;
name|frm
operator|+=
literal|2
expr_stmt|;
comment|/* 8-bit chanwidth */
operator|*
name|frm
operator|++
operator|=
name|ieee80211_vht_get_chwidth_ie
argument_list|(
name|ni
operator|->
name|ni_chan
argument_list|)
expr_stmt|;
comment|/* 8-bit freq1 */
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_vht_ch_freq1
expr_stmt|;
comment|/* 8-bit freq2 */
operator|*
name|frm
operator|++
operator|=
name|ni
operator|->
name|ni_chan
operator|->
name|ic_vht_ch_freq2
expr_stmt|;
comment|/* 16-bit basic MCS set - just MCS0..7 for NSS=1 for now */
name|ADDSHORT
argument_list|(
name|frm
argument_list|,
literal|0xfffc
argument_list|)
expr_stmt|;
return|return
operator|(
name|frm
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ieee80211_vht_update_cap
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtcap_ie
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|vhtop_ie
parameter_list|)
block|{
name|ieee80211_parse_vhtcap
argument_list|(
name|ni
argument_list|,
name|vhtcap_ie
argument_list|)
expr_stmt|;
name|ieee80211_parse_vhtopmode
argument_list|(
name|ni
argument_list|,
name|vhtop_ie
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|struct
name|ieee80211_channel
modifier|*
name|findvhtchan
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|c
parameter_list|,
name|int
name|vhtflags
parameter_list|)
block|{
return|return
operator|(
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|c
operator|->
name|ic_freq
argument_list|,
operator|(
name|c
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_VHT
operator|)
operator||
name|vhtflags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle channel promotion to VHT, similar to ieee80211_ht_adjust_channel().  */
end_comment

begin_function
name|struct
name|ieee80211_channel
modifier|*
name|ieee80211_vht_adjust_channel
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_channel
modifier|*
name|chan
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|ieee80211_channel
modifier|*
name|c
decl_stmt|;
comment|/* First case - handle channel demotion - if VHT isn't set */
if|if
condition|(
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_VHT
operator|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
literal|0
block|printf("%s: demoting channel %d/0x%08x\n", __func__, 		    chan->ic_ieee, chan->ic_flags);
endif|#
directive|endif
name|c
operator|=
name|ieee80211_find_channel
argument_list|(
name|ic
argument_list|,
name|chan
operator|->
name|ic_freq
argument_list|,
name|chan
operator|->
name|ic_flags
operator|&
operator|~
name|IEEE80211_CHAN_VHT
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|chan
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: .. to %d/0x%08x\n", __func__, 		    c->ic_ieee, c->ic_flags);
endif|#
directive|endif
return|return
operator|(
name|c
operator|)
return|;
block|}
comment|/* 	 * We can upgrade to VHT - attempt to do so 	 * 	 * Note: we don't clear the HT flags, these are the hints 	 * for HT40U/HT40D when selecting VHT40 or larger channels. 	 */
comment|/* Start with VHT80 */
name|c
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT160
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT80P80
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT80_80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT80
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT80
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT40
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT40U
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|flags
operator|&
name|IEEE80211_FVHT_USEVHT40
operator|)
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT40D
argument_list|)
expr_stmt|;
comment|/* 	 * If we get here, VHT20 is always possible because we checked 	 * for IEEE80211_FVHT_VHT above. 	 */
if|if
condition|(
name|c
operator|==
name|NULL
condition|)
name|c
operator|=
name|findvhtchan
argument_list|(
name|ic
argument_list|,
name|chan
argument_list|,
name|IEEE80211_CHAN_VHT20
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|NULL
condition|)
name|chan
operator|=
name|c
expr_stmt|;
if|#
directive|if
literal|0
block|printf("%s: selected %d/0x%08x\n", __func__, c->ic_ieee, c->ic_flags);
endif|#
directive|endif
return|return
operator|(
name|chan
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the VHT operation IE for a given node.  *  * This includes calculating the suitable channel width/parameters  * and basic MCS set.  *  * TODO: ensure I read 9.7.11 Rate Selection for VHT STAs.  * TODO: ensure I read 10.39.7 - BSS Basic VHT-MCS and NSS set operation.  */
end_comment

begin_function
name|void
name|ieee80211_vht_get_vhtinfo_ie
parameter_list|(
name|struct
name|ieee80211_node
modifier|*
name|ni
parameter_list|,
name|struct
name|ieee80211_ie_vht_operation
modifier|*
name|vhtop
parameter_list|,
name|int
name|opmode
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%s: called; TODO!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

