begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002-2005 Sam Leffler, Errno Consulting  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * Alternatively, this software may be distributed under the terms of the  * GNU General Public License ("GPL") version 2 as published by the Free  * Software Foundation.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * IEEE 802.11i TKIP crypto support.  *  * Part of this module is derived from similar code in the Host  * AP driver. The code is used with the consent of the author and  * it's license is included below.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_media.h>
end_include

begin_include
include|#
directive|include
file|<net/ethernet.h>
end_include

begin_include
include|#
directive|include
file|<net80211/ieee80211_var.h>
end_include

begin_function_decl
specifier|static
name|void
modifier|*
name|tkip_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|tkip_detach
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_setkey
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_encap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int8_t
name|keyid
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_enmic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_decap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_demic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ieee80211_cipher
name|tkip
init|=
block|{
operator|.
name|ic_name
operator|=
literal|"TKIP"
block|,
operator|.
name|ic_cipher
operator|=
name|IEEE80211_CIPHER_TKIP
block|,
operator|.
name|ic_header
operator|=
name|IEEE80211_WEP_IVLEN
operator|+
name|IEEE80211_WEP_KIDLEN
operator|+
name|IEEE80211_WEP_EXTIVLEN
block|,
operator|.
name|ic_trailer
operator|=
name|IEEE80211_WEP_CRCLEN
block|,
operator|.
name|ic_miclen
operator|=
name|IEEE80211_WEP_MICLEN
block|,
operator|.
name|ic_attach
operator|=
name|tkip_attach
block|,
operator|.
name|ic_detach
operator|=
name|tkip_detach
block|,
operator|.
name|ic_setkey
operator|=
name|tkip_setkey
block|,
operator|.
name|ic_encap
operator|=
name|tkip_encap
block|,
operator|.
name|ic_decap
operator|=
name|tkip_decap
block|,
operator|.
name|ic_enmic
operator|=
name|tkip_enmic
block|,
operator|.
name|ic_demic
operator|=
name|tkip_demic
block|, }
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|uint8_t
name|u8
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint16_t
name|u16
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|__u32
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|uint32_t
name|u32
typedef|;
end_typedef

begin_define
define|#
directive|define
name|memmove
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|n
parameter_list|)
value|ovbcopy(src, dst, n)
end_define

begin_struct
struct|struct
name|tkip_ctx
block|{
name|struct
name|ieee80211com
modifier|*
name|tc_ic
decl_stmt|;
comment|/* for diagnostics */
name|u16
name|tx_ttak
index|[
literal|5
index|]
decl_stmt|;
name|int
name|tx_phase1_done
decl_stmt|;
name|u8
name|tx_rc4key
index|[
literal|16
index|]
decl_stmt|;
comment|/* XXX for test module; make locals? */
name|u16
name|rx_ttak
index|[
literal|5
index|]
decl_stmt|;
name|int
name|rx_phase1_done
decl_stmt|;
name|u8
name|rx_rc4key
index|[
literal|16
index|]
decl_stmt|;
comment|/* XXX for test module; make locals? */
name|uint64_t
name|rx_rsc
decl_stmt|;
comment|/* held until MIC verified */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|michael_mic
parameter_list|(
name|struct
name|tkip_ctx
modifier|*
parameter_list|,
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|off
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|u8
name|mic
index|[
name|IEEE80211_WEP_MICLEN
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_encrypt
parameter_list|(
name|struct
name|tkip_ctx
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
name|hdr_len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tkip_decrypt
parameter_list|(
name|struct
name|tkip_ctx
modifier|*
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|int
name|hdr_len
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* number of references from net80211 layer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nrefs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
modifier|*
name|tkip_attach
parameter_list|(
name|struct
name|ieee80211com
modifier|*
name|ic
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
decl_stmt|;
name|MALLOC
argument_list|(
name|ctx
argument_list|,
expr|struct
name|tkip_ctx
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tkip_ctx
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|==
name|NULL
condition|)
block|{
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_nomem
operator|++
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|ctx
operator|->
name|tc_ic
operator|=
name|ic
expr_stmt|;
name|nrefs
operator|++
expr_stmt|;
comment|/* NB: we assume caller locking */
return|return
name|ctx
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tkip_detach
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
name|FREE
argument_list|(
name|ctx
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|nrefs
operator|>
literal|0
argument_list|,
operator|(
literal|"imbalanced attach/detach"
operator|)
argument_list|)
expr_stmt|;
name|nrefs
operator|--
expr_stmt|;
comment|/* NB: we assume caller locking */
block|}
end_function

begin_function
specifier|static
name|int
name|tkip_setkey
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
if|if
condition|(
name|k
operator|->
name|wk_keylen
operator|!=
operator|(
literal|128
operator|/
name|NBBY
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|ctx
expr_stmt|;
comment|/* XXX */
name|IEEE80211_DPRINTF
argument_list|(
name|ctx
operator|->
name|tc_ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"%s: Invalid key length %u, expecting %u\n"
argument_list|,
name|__func__
argument_list|,
name|k
operator|->
name|wk_keylen
argument_list|,
literal|128
operator|/
name|NBBY
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|k
operator|->
name|wk_keytsc
operator|=
literal|1
expr_stmt|;
comment|/* TSC starts at 1 */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Add privacy headers and do any s/w encryption required.  */
end_comment

begin_function
specifier|static
name|int
name|tkip_encap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int8_t
name|keyid
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ctx
operator|->
name|tc_ic
decl_stmt|;
name|u_int8_t
modifier|*
name|ivp
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
comment|/* 	 * Handle TKIP counter measures requirement. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_COUNTERM
condition|)
block|{
ifdef|#
directive|ifdef
name|IEEE80211_DEBUG
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
endif|#
directive|endif
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] Discard frame due to countermeasures (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_tkipcm
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|hdrlen
operator|=
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Copy down 802.11 header and add the IV, KeyID, and ExtIV. 	 */
name|M_PREPEND
argument_list|(
name|m
argument_list|,
name|tkip
operator|.
name|ic_header
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|ivp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|u_int8_t
operator|*
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|ivp
argument_list|,
name|ivp
operator|+
name|tkip
operator|.
name|ic_header
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|ivp
operator|+=
name|hdrlen
expr_stmt|;
name|ivp
index|[
literal|0
index|]
operator|=
name|k
operator|->
name|wk_keytsc
operator|>>
literal|8
expr_stmt|;
comment|/* TSC1 */
name|ivp
index|[
literal|1
index|]
operator|=
operator|(
name|ivp
index|[
literal|0
index|]
operator||
literal|0x20
operator|)
operator|&
literal|0x7f
expr_stmt|;
comment|/* WEP seed */
name|ivp
index|[
literal|2
index|]
operator|=
name|k
operator|->
name|wk_keytsc
operator|>>
literal|0
expr_stmt|;
comment|/* TSC0 */
name|ivp
index|[
literal|3
index|]
operator|=
name|keyid
operator||
name|IEEE80211_WEP_EXTIV
expr_stmt|;
comment|/* KeyID | ExtID */
name|ivp
index|[
literal|4
index|]
operator|=
name|k
operator|->
name|wk_keytsc
operator|>>
literal|16
expr_stmt|;
comment|/* TSC2 */
name|ivp
index|[
literal|5
index|]
operator|=
name|k
operator|->
name|wk_keytsc
operator|>>
literal|24
expr_stmt|;
comment|/* TSC3 */
name|ivp
index|[
literal|6
index|]
operator|=
name|k
operator|->
name|wk_keytsc
operator|>>
literal|32
expr_stmt|;
comment|/* TSC4 */
name|ivp
index|[
literal|7
index|]
operator|=
name|k
operator|->
name|wk_keytsc
operator|>>
literal|40
expr_stmt|;
comment|/* TSC5 */
comment|/* 	 * Finally, do software encrypt if neeed. 	 */
if|if
condition|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
condition|)
block|{
if|if
condition|(
operator|!
name|tkip_encrypt
argument_list|(
name|ctx
argument_list|,
name|k
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* NB: tkip_encrypt handles wk_keytsc */
block|}
else|else
name|k
operator|->
name|wk_keytsc
operator|++
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Add MIC to the frame as needed.  */
end_comment

begin_function
specifier|static
name|int
name|tkip_enmic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
if|if
condition|(
name|force
operator|||
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
condition|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ctx
operator|->
name|tc_ic
decl_stmt|;
name|int
name|hdrlen
decl_stmt|;
name|uint8_t
name|mic
index|[
name|IEEE80211_WEP_MICLEN
index|]
decl_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_tkipenmic
operator|++
expr_stmt|;
name|hdrlen
operator|=
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
expr_stmt|;
name|michael_mic
argument_list|(
name|ctx
argument_list|,
name|k
operator|->
name|wk_txmic
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|hdrlen
argument_list|,
name|mic
argument_list|)
expr_stmt|;
return|return
name|m_append
argument_list|(
name|m
argument_list|,
name|tkip
operator|.
name|ic_miclen
argument_list|,
name|mic
argument_list|)
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|uint64_t
name|READ_6
parameter_list|(
name|uint8_t
name|b0
parameter_list|,
name|uint8_t
name|b1
parameter_list|,
name|uint8_t
name|b2
parameter_list|,
name|uint8_t
name|b3
parameter_list|,
name|uint8_t
name|b4
parameter_list|,
name|uint8_t
name|b5
parameter_list|)
block|{
name|uint32_t
name|iv32
init|=
operator|(
name|b0
operator|<<
literal|0
operator|)
operator||
operator|(
name|b1
operator|<<
literal|8
operator|)
operator||
operator|(
name|b2
operator|<<
literal|16
operator|)
operator||
operator|(
name|b3
operator|<<
literal|24
operator|)
decl_stmt|;
name|uint16_t
name|iv16
init|=
operator|(
name|b4
operator|<<
literal|0
operator|)
operator||
operator|(
name|b5
operator|<<
literal|8
operator|)
decl_stmt|;
return|return
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|iv16
operator|)
operator|<<
literal|32
operator|)
operator||
name|iv32
return|;
block|}
end_function

begin_comment
comment|/*  * Validate and strip privacy headers (and trailer) for a  * received frame.  If necessary, decrypt the frame using  * the specified key.  */
end_comment

begin_function
specifier|static
name|int
name|tkip_decap
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ctx
operator|->
name|tc_ic
decl_stmt|;
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint8_t
modifier|*
name|ivp
decl_stmt|;
comment|/* 	 * Header should have extended IV and sequence number; 	 * verify the former and validate the latter. 	 */
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
name|ivp
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|hdrlen
expr_stmt|;
if|if
condition|(
operator|(
name|ivp
index|[
name|IEEE80211_WEP_IVLEN
index|]
operator|&
name|IEEE80211_WEP_EXTIV
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No extended IV; discard frame. 		 */
name|IEEE80211_DPRINTF
argument_list|(
name|ctx
operator|->
name|tc_ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] missing ExtIV for TKIP cipher\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tc_ic
operator|->
name|ic_stats
operator|.
name|is_rx_tkipformat
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * Handle TKIP counter measures requirement. 	 */
if|if
condition|(
name|ic
operator|->
name|ic_flags
operator|&
name|IEEE80211_F_COUNTERM
condition|)
block|{
name|IEEE80211_DPRINTF
argument_list|(
name|ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] discard frame due to countermeasures (%s)\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_tkipcm
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ctx
operator|->
name|rx_rsc
operator|=
name|READ_6
argument_list|(
name|ivp
index|[
literal|2
index|]
argument_list|,
name|ivp
index|[
literal|0
index|]
argument_list|,
name|ivp
index|[
literal|4
index|]
argument_list|,
name|ivp
index|[
literal|5
index|]
argument_list|,
name|ivp
index|[
literal|6
index|]
argument_list|,
name|ivp
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|rx_rsc
operator|<=
name|k
operator|->
name|wk_keyrsc
condition|)
block|{
comment|/* 		 * Replay violation; notify upper layer. 		 */
name|ieee80211_notify_replay_failure
argument_list|(
name|ctx
operator|->
name|tc_ic
argument_list|,
name|wh
argument_list|,
name|k
argument_list|,
name|ctx
operator|->
name|rx_rsc
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tc_ic
operator|->
name|ic_stats
operator|.
name|is_rx_tkipreplay
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* 	 * NB: We can't update the rsc in the key until MIC is verified. 	 * 	 * We assume we are not preempted between doing the check above 	 * and updating wk_keyrsc when stripping the MIC in tkip_demic. 	 * Otherwise we might process another packet and discard it as 	 * a replay. 	 */
comment|/* 	 * Check if the device handled the decrypt in hardware. 	 * If so we just strip the header; otherwise we need to 	 * handle the decrypt in software. 	 */
if|if
condition|(
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWCRYPT
operator|)
operator|&&
operator|!
name|tkip_decrypt
argument_list|(
name|ctx
argument_list|,
name|k
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* 	 * Copy up 802.11 header and strip crypto bits. 	 */
name|memmove
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|tkip
operator|.
name|ic_header
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|void
operator|*
argument_list|)
argument_list|,
name|hdrlen
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
name|tkip
operator|.
name|ic_header
argument_list|)
expr_stmt|;
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|tkip
operator|.
name|ic_trailer
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Verify and strip MIC from the frame.  */
end_comment

begin_function
specifier|static
name|int
name|tkip_demic
parameter_list|(
name|struct
name|ieee80211_key
modifier|*
name|k
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|force
parameter_list|)
block|{
name|struct
name|tkip_ctx
modifier|*
name|ctx
init|=
name|k
operator|->
name|wk_private
decl_stmt|;
if|if
condition|(
name|force
operator|||
operator|(
name|k
operator|->
name|wk_flags
operator|&
name|IEEE80211_KEY_SWMIC
operator|)
condition|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
init|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
decl_stmt|;
name|struct
name|ieee80211com
modifier|*
name|ic
init|=
name|ctx
operator|->
name|tc_ic
decl_stmt|;
name|int
name|hdrlen
init|=
name|ieee80211_hdrspace
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|)
decl_stmt|;
name|u8
name|mic
index|[
name|IEEE80211_WEP_MICLEN
index|]
decl_stmt|;
name|u8
name|mic0
index|[
name|IEEE80211_WEP_MICLEN
index|]
decl_stmt|;
name|ic
operator|->
name|ic_stats
operator|.
name|is_crypto_tkipdemic
operator|++
expr_stmt|;
name|michael_mic
argument_list|(
name|ctx
argument_list|,
name|k
operator|->
name|wk_rxmic
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|+
name|tkip
operator|.
name|ic_miclen
operator|)
argument_list|,
name|mic
argument_list|)
expr_stmt|;
name|m_copydata
argument_list|(
name|m
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
name|tkip
operator|.
name|ic_miclen
argument_list|,
name|tkip
operator|.
name|ic_miclen
argument_list|,
name|mic0
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|mic
argument_list|,
name|mic0
argument_list|,
name|tkip
operator|.
name|ic_miclen
argument_list|)
condition|)
block|{
comment|/* NB: 802.11 layer handles statistic and debug msg */
name|ieee80211_notify_michael_failure
argument_list|(
name|ic
argument_list|,
name|wh
argument_list|,
name|k
operator|->
name|wk_rxkeyix
operator|!=
name|IEEE80211_KEYIX_NONE
condition|?
name|k
operator|->
name|wk_rxkeyix
else|:
name|k
operator|->
name|wk_keyix
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
comment|/* 	 * Strip MIC from the tail. 	 */
name|m_adj
argument_list|(
name|m
argument_list|,
operator|-
name|tkip
operator|.
name|ic_miclen
argument_list|)
expr_stmt|;
comment|/* 	 * Ok to update rsc now that MIC has been verified. 	 */
name|k
operator|->
name|wk_keyrsc
operator|=
name|ctx
operator|->
name|rx_rsc
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Host AP crypt: host-based TKIP encryption implementation for Host AP driver  *  * Copyright (c) 2003-2004, Jouni Malinen<jkmaline@cc.hut.fi>  *  * This program is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License version 2 as  * published by the Free Software Foundation. See README and COPYING for  * more details.  *  * Alternatively, this software may be distributed under the terms of BSD  * license.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|__u32
name|crc32_table
index|[
literal|256
index|]
init|=
block|{
literal|0x00000000L
block|,
literal|0x77073096L
block|,
literal|0xee0e612cL
block|,
literal|0x990951baL
block|,
literal|0x076dc419L
block|,
literal|0x706af48fL
block|,
literal|0xe963a535L
block|,
literal|0x9e6495a3L
block|,
literal|0x0edb8832L
block|,
literal|0x79dcb8a4L
block|,
literal|0xe0d5e91eL
block|,
literal|0x97d2d988L
block|,
literal|0x09b64c2bL
block|,
literal|0x7eb17cbdL
block|,
literal|0xe7b82d07L
block|,
literal|0x90bf1d91L
block|,
literal|0x1db71064L
block|,
literal|0x6ab020f2L
block|,
literal|0xf3b97148L
block|,
literal|0x84be41deL
block|,
literal|0x1adad47dL
block|,
literal|0x6ddde4ebL
block|,
literal|0xf4d4b551L
block|,
literal|0x83d385c7L
block|,
literal|0x136c9856L
block|,
literal|0x646ba8c0L
block|,
literal|0xfd62f97aL
block|,
literal|0x8a65c9ecL
block|,
literal|0x14015c4fL
block|,
literal|0x63066cd9L
block|,
literal|0xfa0f3d63L
block|,
literal|0x8d080df5L
block|,
literal|0x3b6e20c8L
block|,
literal|0x4c69105eL
block|,
literal|0xd56041e4L
block|,
literal|0xa2677172L
block|,
literal|0x3c03e4d1L
block|,
literal|0x4b04d447L
block|,
literal|0xd20d85fdL
block|,
literal|0xa50ab56bL
block|,
literal|0x35b5a8faL
block|,
literal|0x42b2986cL
block|,
literal|0xdbbbc9d6L
block|,
literal|0xacbcf940L
block|,
literal|0x32d86ce3L
block|,
literal|0x45df5c75L
block|,
literal|0xdcd60dcfL
block|,
literal|0xabd13d59L
block|,
literal|0x26d930acL
block|,
literal|0x51de003aL
block|,
literal|0xc8d75180L
block|,
literal|0xbfd06116L
block|,
literal|0x21b4f4b5L
block|,
literal|0x56b3c423L
block|,
literal|0xcfba9599L
block|,
literal|0xb8bda50fL
block|,
literal|0x2802b89eL
block|,
literal|0x5f058808L
block|,
literal|0xc60cd9b2L
block|,
literal|0xb10be924L
block|,
literal|0x2f6f7c87L
block|,
literal|0x58684c11L
block|,
literal|0xc1611dabL
block|,
literal|0xb6662d3dL
block|,
literal|0x76dc4190L
block|,
literal|0x01db7106L
block|,
literal|0x98d220bcL
block|,
literal|0xefd5102aL
block|,
literal|0x71b18589L
block|,
literal|0x06b6b51fL
block|,
literal|0x9fbfe4a5L
block|,
literal|0xe8b8d433L
block|,
literal|0x7807c9a2L
block|,
literal|0x0f00f934L
block|,
literal|0x9609a88eL
block|,
literal|0xe10e9818L
block|,
literal|0x7f6a0dbbL
block|,
literal|0x086d3d2dL
block|,
literal|0x91646c97L
block|,
literal|0xe6635c01L
block|,
literal|0x6b6b51f4L
block|,
literal|0x1c6c6162L
block|,
literal|0x856530d8L
block|,
literal|0xf262004eL
block|,
literal|0x6c0695edL
block|,
literal|0x1b01a57bL
block|,
literal|0x8208f4c1L
block|,
literal|0xf50fc457L
block|,
literal|0x65b0d9c6L
block|,
literal|0x12b7e950L
block|,
literal|0x8bbeb8eaL
block|,
literal|0xfcb9887cL
block|,
literal|0x62dd1ddfL
block|,
literal|0x15da2d49L
block|,
literal|0x8cd37cf3L
block|,
literal|0xfbd44c65L
block|,
literal|0x4db26158L
block|,
literal|0x3ab551ceL
block|,
literal|0xa3bc0074L
block|,
literal|0xd4bb30e2L
block|,
literal|0x4adfa541L
block|,
literal|0x3dd895d7L
block|,
literal|0xa4d1c46dL
block|,
literal|0xd3d6f4fbL
block|,
literal|0x4369e96aL
block|,
literal|0x346ed9fcL
block|,
literal|0xad678846L
block|,
literal|0xda60b8d0L
block|,
literal|0x44042d73L
block|,
literal|0x33031de5L
block|,
literal|0xaa0a4c5fL
block|,
literal|0xdd0d7cc9L
block|,
literal|0x5005713cL
block|,
literal|0x270241aaL
block|,
literal|0xbe0b1010L
block|,
literal|0xc90c2086L
block|,
literal|0x5768b525L
block|,
literal|0x206f85b3L
block|,
literal|0xb966d409L
block|,
literal|0xce61e49fL
block|,
literal|0x5edef90eL
block|,
literal|0x29d9c998L
block|,
literal|0xb0d09822L
block|,
literal|0xc7d7a8b4L
block|,
literal|0x59b33d17L
block|,
literal|0x2eb40d81L
block|,
literal|0xb7bd5c3bL
block|,
literal|0xc0ba6cadL
block|,
literal|0xedb88320L
block|,
literal|0x9abfb3b6L
block|,
literal|0x03b6e20cL
block|,
literal|0x74b1d29aL
block|,
literal|0xead54739L
block|,
literal|0x9dd277afL
block|,
literal|0x04db2615L
block|,
literal|0x73dc1683L
block|,
literal|0xe3630b12L
block|,
literal|0x94643b84L
block|,
literal|0x0d6d6a3eL
block|,
literal|0x7a6a5aa8L
block|,
literal|0xe40ecf0bL
block|,
literal|0x9309ff9dL
block|,
literal|0x0a00ae27L
block|,
literal|0x7d079eb1L
block|,
literal|0xf00f9344L
block|,
literal|0x8708a3d2L
block|,
literal|0x1e01f268L
block|,
literal|0x6906c2feL
block|,
literal|0xf762575dL
block|,
literal|0x806567cbL
block|,
literal|0x196c3671L
block|,
literal|0x6e6b06e7L
block|,
literal|0xfed41b76L
block|,
literal|0x89d32be0L
block|,
literal|0x10da7a5aL
block|,
literal|0x67dd4accL
block|,
literal|0xf9b9df6fL
block|,
literal|0x8ebeeff9L
block|,
literal|0x17b7be43L
block|,
literal|0x60b08ed5L
block|,
literal|0xd6d6a3e8L
block|,
literal|0xa1d1937eL
block|,
literal|0x38d8c2c4L
block|,
literal|0x4fdff252L
block|,
literal|0xd1bb67f1L
block|,
literal|0xa6bc5767L
block|,
literal|0x3fb506ddL
block|,
literal|0x48b2364bL
block|,
literal|0xd80d2bdaL
block|,
literal|0xaf0a1b4cL
block|,
literal|0x36034af6L
block|,
literal|0x41047a60L
block|,
literal|0xdf60efc3L
block|,
literal|0xa867df55L
block|,
literal|0x316e8eefL
block|,
literal|0x4669be79L
block|,
literal|0xcb61b38cL
block|,
literal|0xbc66831aL
block|,
literal|0x256fd2a0L
block|,
literal|0x5268e236L
block|,
literal|0xcc0c7795L
block|,
literal|0xbb0b4703L
block|,
literal|0x220216b9L
block|,
literal|0x5505262fL
block|,
literal|0xc5ba3bbeL
block|,
literal|0xb2bd0b28L
block|,
literal|0x2bb45a92L
block|,
literal|0x5cb36a04L
block|,
literal|0xc2d7ffa7L
block|,
literal|0xb5d0cf31L
block|,
literal|0x2cd99e8bL
block|,
literal|0x5bdeae1dL
block|,
literal|0x9b64c2b0L
block|,
literal|0xec63f226L
block|,
literal|0x756aa39cL
block|,
literal|0x026d930aL
block|,
literal|0x9c0906a9L
block|,
literal|0xeb0e363fL
block|,
literal|0x72076785L
block|,
literal|0x05005713L
block|,
literal|0x95bf4a82L
block|,
literal|0xe2b87a14L
block|,
literal|0x7bb12baeL
block|,
literal|0x0cb61b38L
block|,
literal|0x92d28e9bL
block|,
literal|0xe5d5be0dL
block|,
literal|0x7cdcefb7L
block|,
literal|0x0bdbdf21L
block|,
literal|0x86d3d2d4L
block|,
literal|0xf1d4e242L
block|,
literal|0x68ddb3f8L
block|,
literal|0x1fda836eL
block|,
literal|0x81be16cdL
block|,
literal|0xf6b9265bL
block|,
literal|0x6fb077e1L
block|,
literal|0x18b74777L
block|,
literal|0x88085ae6L
block|,
literal|0xff0f6a70L
block|,
literal|0x66063bcaL
block|,
literal|0x11010b5cL
block|,
literal|0x8f659effL
block|,
literal|0xf862ae69L
block|,
literal|0x616bffd3L
block|,
literal|0x166ccf45L
block|,
literal|0xa00ae278L
block|,
literal|0xd70dd2eeL
block|,
literal|0x4e048354L
block|,
literal|0x3903b3c2L
block|,
literal|0xa7672661L
block|,
literal|0xd06016f7L
block|,
literal|0x4969474dL
block|,
literal|0x3e6e77dbL
block|,
literal|0xaed16a4aL
block|,
literal|0xd9d65adcL
block|,
literal|0x40df0b66L
block|,
literal|0x37d83bf0L
block|,
literal|0xa9bcae53L
block|,
literal|0xdebb9ec5L
block|,
literal|0x47b2cf7fL
block|,
literal|0x30b5ffe9L
block|,
literal|0xbdbdf21cL
block|,
literal|0xcabac28aL
block|,
literal|0x53b39330L
block|,
literal|0x24b4a3a6L
block|,
literal|0xbad03605L
block|,
literal|0xcdd70693L
block|,
literal|0x54de5729L
block|,
literal|0x23d967bfL
block|,
literal|0xb3667a2eL
block|,
literal|0xc4614ab8L
block|,
literal|0x5d681b02L
block|,
literal|0x2a6f2b94L
block|,
literal|0xb40bbe37L
block|,
literal|0xc30c8ea1L
block|,
literal|0x5a05df1bL
block|,
literal|0x2d02ef8dL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|u16
name|RotR1
parameter_list|(
name|u16
name|val
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>>
literal|1
operator|)
operator||
operator|(
name|val
operator|<<
literal|15
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u8
name|Lo8
parameter_list|(
name|u16
name|val
parameter_list|)
block|{
return|return
name|val
operator|&
literal|0xff
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u8
name|Hi8
parameter_list|(
name|u16
name|val
parameter_list|)
block|{
return|return
name|val
operator|>>
literal|8
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u16
name|Lo16
parameter_list|(
name|u32
name|val
parameter_list|)
block|{
return|return
name|val
operator|&
literal|0xffff
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u16
name|Hi16
parameter_list|(
name|u32
name|val
parameter_list|)
block|{
return|return
name|val
operator|>>
literal|16
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u16
name|Mk16
parameter_list|(
name|u8
name|hi
parameter_list|,
name|u8
name|lo
parameter_list|)
block|{
return|return
name|lo
operator||
operator|(
operator|(
operator|(
name|u16
operator|)
name|hi
operator|)
operator|<<
literal|8
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u16
name|Mk16_le
parameter_list|(
specifier|const
name|u16
modifier|*
name|v
parameter_list|)
block|{
return|return
name|le16toh
argument_list|(
operator|*
name|v
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|u16
name|Sbox
index|[
literal|256
index|]
init|=
block|{
literal|0xC6A5
block|,
literal|0xF884
block|,
literal|0xEE99
block|,
literal|0xF68D
block|,
literal|0xFF0D
block|,
literal|0xD6BD
block|,
literal|0xDEB1
block|,
literal|0x9154
block|,
literal|0x6050
block|,
literal|0x0203
block|,
literal|0xCEA9
block|,
literal|0x567D
block|,
literal|0xE719
block|,
literal|0xB562
block|,
literal|0x4DE6
block|,
literal|0xEC9A
block|,
literal|0x8F45
block|,
literal|0x1F9D
block|,
literal|0x8940
block|,
literal|0xFA87
block|,
literal|0xEF15
block|,
literal|0xB2EB
block|,
literal|0x8EC9
block|,
literal|0xFB0B
block|,
literal|0x41EC
block|,
literal|0xB367
block|,
literal|0x5FFD
block|,
literal|0x45EA
block|,
literal|0x23BF
block|,
literal|0x53F7
block|,
literal|0xE496
block|,
literal|0x9B5B
block|,
literal|0x75C2
block|,
literal|0xE11C
block|,
literal|0x3DAE
block|,
literal|0x4C6A
block|,
literal|0x6C5A
block|,
literal|0x7E41
block|,
literal|0xF502
block|,
literal|0x834F
block|,
literal|0x685C
block|,
literal|0x51F4
block|,
literal|0xD134
block|,
literal|0xF908
block|,
literal|0xE293
block|,
literal|0xAB73
block|,
literal|0x6253
block|,
literal|0x2A3F
block|,
literal|0x080C
block|,
literal|0x9552
block|,
literal|0x4665
block|,
literal|0x9D5E
block|,
literal|0x3028
block|,
literal|0x37A1
block|,
literal|0x0A0F
block|,
literal|0x2FB5
block|,
literal|0x0E09
block|,
literal|0x2436
block|,
literal|0x1B9B
block|,
literal|0xDF3D
block|,
literal|0xCD26
block|,
literal|0x4E69
block|,
literal|0x7FCD
block|,
literal|0xEA9F
block|,
literal|0x121B
block|,
literal|0x1D9E
block|,
literal|0x5874
block|,
literal|0x342E
block|,
literal|0x362D
block|,
literal|0xDCB2
block|,
literal|0xB4EE
block|,
literal|0x5BFB
block|,
literal|0xA4F6
block|,
literal|0x764D
block|,
literal|0xB761
block|,
literal|0x7DCE
block|,
literal|0x527B
block|,
literal|0xDD3E
block|,
literal|0x5E71
block|,
literal|0x1397
block|,
literal|0xA6F5
block|,
literal|0xB968
block|,
literal|0x0000
block|,
literal|0xC12C
block|,
literal|0x4060
block|,
literal|0xE31F
block|,
literal|0x79C8
block|,
literal|0xB6ED
block|,
literal|0xD4BE
block|,
literal|0x8D46
block|,
literal|0x67D9
block|,
literal|0x724B
block|,
literal|0x94DE
block|,
literal|0x98D4
block|,
literal|0xB0E8
block|,
literal|0x854A
block|,
literal|0xBB6B
block|,
literal|0xC52A
block|,
literal|0x4FE5
block|,
literal|0xED16
block|,
literal|0x86C5
block|,
literal|0x9AD7
block|,
literal|0x6655
block|,
literal|0x1194
block|,
literal|0x8ACF
block|,
literal|0xE910
block|,
literal|0x0406
block|,
literal|0xFE81
block|,
literal|0xA0F0
block|,
literal|0x7844
block|,
literal|0x25BA
block|,
literal|0x4BE3
block|,
literal|0xA2F3
block|,
literal|0x5DFE
block|,
literal|0x80C0
block|,
literal|0x058A
block|,
literal|0x3FAD
block|,
literal|0x21BC
block|,
literal|0x7048
block|,
literal|0xF104
block|,
literal|0x63DF
block|,
literal|0x77C1
block|,
literal|0xAF75
block|,
literal|0x4263
block|,
literal|0x2030
block|,
literal|0xE51A
block|,
literal|0xFD0E
block|,
literal|0xBF6D
block|,
literal|0x814C
block|,
literal|0x1814
block|,
literal|0x2635
block|,
literal|0xC32F
block|,
literal|0xBEE1
block|,
literal|0x35A2
block|,
literal|0x88CC
block|,
literal|0x2E39
block|,
literal|0x9357
block|,
literal|0x55F2
block|,
literal|0xFC82
block|,
literal|0x7A47
block|,
literal|0xC8AC
block|,
literal|0xBAE7
block|,
literal|0x322B
block|,
literal|0xE695
block|,
literal|0xC0A0
block|,
literal|0x1998
block|,
literal|0x9ED1
block|,
literal|0xA37F
block|,
literal|0x4466
block|,
literal|0x547E
block|,
literal|0x3BAB
block|,
literal|0x0B83
block|,
literal|0x8CCA
block|,
literal|0xC729
block|,
literal|0x6BD3
block|,
literal|0x283C
block|,
literal|0xA779
block|,
literal|0xBCE2
block|,
literal|0x161D
block|,
literal|0xAD76
block|,
literal|0xDB3B
block|,
literal|0x6456
block|,
literal|0x744E
block|,
literal|0x141E
block|,
literal|0x92DB
block|,
literal|0x0C0A
block|,
literal|0x486C
block|,
literal|0xB8E4
block|,
literal|0x9F5D
block|,
literal|0xBD6E
block|,
literal|0x43EF
block|,
literal|0xC4A6
block|,
literal|0x39A8
block|,
literal|0x31A4
block|,
literal|0xD337
block|,
literal|0xF28B
block|,
literal|0xD532
block|,
literal|0x8B43
block|,
literal|0x6E59
block|,
literal|0xDAB7
block|,
literal|0x018C
block|,
literal|0xB164
block|,
literal|0x9CD2
block|,
literal|0x49E0
block|,
literal|0xD8B4
block|,
literal|0xACFA
block|,
literal|0xF307
block|,
literal|0xCF25
block|,
literal|0xCAAF
block|,
literal|0xF48E
block|,
literal|0x47E9
block|,
literal|0x1018
block|,
literal|0x6FD5
block|,
literal|0xF088
block|,
literal|0x4A6F
block|,
literal|0x5C72
block|,
literal|0x3824
block|,
literal|0x57F1
block|,
literal|0x73C7
block|,
literal|0x9751
block|,
literal|0xCB23
block|,
literal|0xA17C
block|,
literal|0xE89C
block|,
literal|0x3E21
block|,
literal|0x96DD
block|,
literal|0x61DC
block|,
literal|0x0D86
block|,
literal|0x0F85
block|,
literal|0xE090
block|,
literal|0x7C42
block|,
literal|0x71C4
block|,
literal|0xCCAA
block|,
literal|0x90D8
block|,
literal|0x0605
block|,
literal|0xF701
block|,
literal|0x1C12
block|,
literal|0xC2A3
block|,
literal|0x6A5F
block|,
literal|0xAEF9
block|,
literal|0x69D0
block|,
literal|0x1791
block|,
literal|0x9958
block|,
literal|0x3A27
block|,
literal|0x27B9
block|,
literal|0xD938
block|,
literal|0xEB13
block|,
literal|0x2BB3
block|,
literal|0x2233
block|,
literal|0xD2BB
block|,
literal|0xA970
block|,
literal|0x0789
block|,
literal|0x33A7
block|,
literal|0x2DB6
block|,
literal|0x3C22
block|,
literal|0x1592
block|,
literal|0xC920
block|,
literal|0x8749
block|,
literal|0xAAFF
block|,
literal|0x5078
block|,
literal|0xA57A
block|,
literal|0x038F
block|,
literal|0x59F8
block|,
literal|0x0980
block|,
literal|0x1A17
block|,
literal|0x65DA
block|,
literal|0xD731
block|,
literal|0x84C6
block|,
literal|0xD0B8
block|,
literal|0x82C3
block|,
literal|0x29B0
block|,
literal|0x5A77
block|,
literal|0x1E11
block|,
literal|0x7BCB
block|,
literal|0xA8FC
block|,
literal|0x6DD6
block|,
literal|0x2C3A
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|__inline
name|u16
name|_S_
parameter_list|(
name|u16
name|v
parameter_list|)
block|{
name|u16
name|t
init|=
name|Sbox
index|[
name|Hi8
argument_list|(
name|v
argument_list|)
index|]
decl_stmt|;
return|return
name|Sbox
index|[
name|Lo8
argument_list|(
name|v
argument_list|)
index|]
operator|^
operator|(
operator|(
name|t
operator|<<
literal|8
operator|)
operator||
operator|(
name|t
operator|>>
literal|8
operator|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|PHASE1_LOOP_COUNT
value|8
end_define

begin_function
specifier|static
name|void
name|tkip_mixing_phase1
parameter_list|(
name|u16
modifier|*
name|TTAK
parameter_list|,
specifier|const
name|u8
modifier|*
name|TK
parameter_list|,
specifier|const
name|u8
modifier|*
name|TA
parameter_list|,
name|u32
name|IV32
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* Initialize the 80-bit TTAK from TSC (IV32) and TA[0..5] */
name|TTAK
index|[
literal|0
index|]
operator|=
name|Lo16
argument_list|(
name|IV32
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|1
index|]
operator|=
name|Hi16
argument_list|(
name|IV32
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|2
index|]
operator|=
name|Mk16
argument_list|(
name|TA
index|[
literal|1
index|]
argument_list|,
name|TA
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|3
index|]
operator|=
name|Mk16
argument_list|(
name|TA
index|[
literal|3
index|]
argument_list|,
name|TA
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|4
index|]
operator|=
name|Mk16
argument_list|(
name|TA
index|[
literal|5
index|]
argument_list|,
name|TA
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|PHASE1_LOOP_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
literal|2
operator|*
operator|(
name|i
operator|&
literal|1
operator|)
expr_stmt|;
name|TTAK
index|[
literal|0
index|]
operator|+=
name|_S_
argument_list|(
name|TTAK
index|[
literal|4
index|]
operator|^
name|Mk16
argument_list|(
name|TK
index|[
literal|1
operator|+
name|j
index|]
argument_list|,
name|TK
index|[
literal|0
operator|+
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|1
index|]
operator|+=
name|_S_
argument_list|(
name|TTAK
index|[
literal|0
index|]
operator|^
name|Mk16
argument_list|(
name|TK
index|[
literal|5
operator|+
name|j
index|]
argument_list|,
name|TK
index|[
literal|4
operator|+
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|2
index|]
operator|+=
name|_S_
argument_list|(
name|TTAK
index|[
literal|1
index|]
operator|^
name|Mk16
argument_list|(
name|TK
index|[
literal|9
operator|+
name|j
index|]
argument_list|,
name|TK
index|[
literal|8
operator|+
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|3
index|]
operator|+=
name|_S_
argument_list|(
name|TTAK
index|[
literal|2
index|]
operator|^
name|Mk16
argument_list|(
name|TK
index|[
literal|13
operator|+
name|j
index|]
argument_list|,
name|TK
index|[
literal|12
operator|+
name|j
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|TTAK
index|[
literal|4
index|]
operator|+=
name|_S_
argument_list|(
name|TTAK
index|[
literal|3
index|]
operator|^
name|Mk16
argument_list|(
name|TK
index|[
literal|1
operator|+
name|j
index|]
argument_list|,
name|TK
index|[
literal|0
operator|+
name|j
index|]
argument_list|)
argument_list|)
operator|+
name|i
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|_BYTE_ORDER
end_ifndef

begin_error
error|#
directive|error
literal|"Don't know native byte order"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|tkip_mixing_phase2
parameter_list|(
name|u8
modifier|*
name|WEPSeed
parameter_list|,
specifier|const
name|u8
modifier|*
name|TK
parameter_list|,
specifier|const
name|u16
modifier|*
name|TTAK
parameter_list|,
name|u16
name|IV16
parameter_list|)
block|{
comment|/* Make temporary area overlap WEP seed so that the final copy can be 	 * avoided on little endian hosts. */
name|u16
modifier|*
name|PPK
init|=
operator|(
name|u16
operator|*
operator|)
operator|&
name|WEPSeed
index|[
literal|4
index|]
decl_stmt|;
comment|/* Step 1 - make copy of TTAK and bring in TSC */
name|PPK
index|[
literal|0
index|]
operator|=
name|TTAK
index|[
literal|0
index|]
expr_stmt|;
name|PPK
index|[
literal|1
index|]
operator|=
name|TTAK
index|[
literal|1
index|]
expr_stmt|;
name|PPK
index|[
literal|2
index|]
operator|=
name|TTAK
index|[
literal|2
index|]
expr_stmt|;
name|PPK
index|[
literal|3
index|]
operator|=
name|TTAK
index|[
literal|3
index|]
expr_stmt|;
name|PPK
index|[
literal|4
index|]
operator|=
name|TTAK
index|[
literal|4
index|]
expr_stmt|;
name|PPK
index|[
literal|5
index|]
operator|=
name|TTAK
index|[
literal|4
index|]
operator|+
name|IV16
expr_stmt|;
comment|/* Step 2 - 96-bit bijective mixing using S-box */
name|PPK
index|[
literal|0
index|]
operator|+=
name|_S_
argument_list|(
name|PPK
index|[
literal|5
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|1
index|]
operator|+=
name|_S_
argument_list|(
name|PPK
index|[
literal|0
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|2
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|2
index|]
operator|+=
name|_S_
argument_list|(
name|PPK
index|[
literal|1
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|4
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|3
index|]
operator|+=
name|_S_
argument_list|(
name|PPK
index|[
literal|2
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|6
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|4
index|]
operator|+=
name|_S_
argument_list|(
name|PPK
index|[
literal|3
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|8
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|5
index|]
operator|+=
name|_S_
argument_list|(
name|PPK
index|[
literal|4
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|10
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|0
index|]
operator|+=
name|RotR1
argument_list|(
name|PPK
index|[
literal|5
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|12
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|1
index|]
operator|+=
name|RotR1
argument_list|(
name|PPK
index|[
literal|0
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|14
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|2
index|]
operator|+=
name|RotR1
argument_list|(
name|PPK
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|3
index|]
operator|+=
name|RotR1
argument_list|(
name|PPK
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|4
index|]
operator|+=
name|RotR1
argument_list|(
name|PPK
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|PPK
index|[
literal|5
index|]
operator|+=
name|RotR1
argument_list|(
name|PPK
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
comment|/* Step 3 - bring in last of TK bits, assign 24-bit WEP IV value 	 * WEPSeed[0..2] is transmitted as WEP IV */
name|WEPSeed
index|[
literal|0
index|]
operator|=
name|Hi8
argument_list|(
name|IV16
argument_list|)
expr_stmt|;
name|WEPSeed
index|[
literal|1
index|]
operator|=
operator|(
name|Hi8
argument_list|(
name|IV16
argument_list|)
operator||
literal|0x20
operator|)
operator|&
literal|0x7F
expr_stmt|;
name|WEPSeed
index|[
literal|2
index|]
operator|=
name|Lo8
argument_list|(
name|IV16
argument_list|)
expr_stmt|;
name|WEPSeed
index|[
literal|3
index|]
operator|=
name|Lo8
argument_list|(
operator|(
name|PPK
index|[
literal|5
index|]
operator|^
name|Mk16_le
argument_list|(
operator|(
specifier|const
name|u16
operator|*
operator|)
operator|&
name|TK
index|[
literal|0
index|]
argument_list|)
operator|)
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|#
directive|if
name|_BYTE_ORDER
operator|==
name|_BIG_ENDIAN
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
name|PPK
index|[
name|i
index|]
operator|=
operator|(
name|PPK
index|[
name|i
index|]
operator|<<
literal|8
operator|)
operator||
operator|(
name|PPK
index|[
name|i
index|]
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|wep_encrypt
parameter_list|(
name|u8
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m0
parameter_list|,
name|u_int
name|off
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|uint8_t
name|icv
index|[
name|IEEE80211_WEP_CRCLEN
index|]
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|crc
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|u8
name|S
index|[
literal|256
index|]
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
define|#
directive|define
name|S_SWAP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { u8 t = S[a]; S[a] = S[b]; S[b] = t; } while(0)
comment|/* Setup RC4 state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|S
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|+
name|key
index|[
name|i
operator|&
literal|0x0f
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Compute CRC32 over unencrypted data and apply RC4 to data */
name|crc
operator|=
operator|~
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|m0
expr_stmt|;
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
operator|-
name|off
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|buflen
operator|>
name|data_len
condition|)
name|buflen
operator|=
name|data_len
expr_stmt|;
name|data_len
operator|-=
name|buflen
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|buflen
condition|;
name|k
operator|++
control|)
block|{
name|crc
operator|=
name|crc32_table
index|[
operator|(
name|crc
operator|^
operator|*
name|pos
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|++
operator|^=
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|data_len
operator|==
literal|0
argument_list|,
operator|(
literal|"out of buffers with data_len %zu\n"
operator|,
name|data_len
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
comment|/* Append little-endian CRC32 and encrypt it to produce ICV */
name|icv
index|[
literal|0
index|]
operator|=
name|crc
expr_stmt|;
name|icv
index|[
literal|1
index|]
operator|=
name|crc
operator|>>
literal|8
expr_stmt|;
name|icv
index|[
literal|2
index|]
operator|=
name|crc
operator|>>
literal|16
expr_stmt|;
name|icv
index|[
literal|3
index|]
operator|=
name|crc
operator|>>
literal|24
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|IEEE80211_WEP_CRCLEN
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|icv
index|[
name|k
index|]
operator|^=
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|wep_decrypt
parameter_list|(
name|u8
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|off
parameter_list|,
name|size_t
name|data_len
parameter_list|)
block|{
name|u32
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|crc
decl_stmt|;
name|u8
name|S
index|[
literal|256
index|]
decl_stmt|;
name|u8
modifier|*
name|pos
decl_stmt|,
name|icv
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
comment|/* Setup RC4 state */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|S
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
block|{
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|+
name|key
index|[
name|i
operator|&
literal|0x0f
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
comment|/* Apply RC4 to data and compute CRC32 over decrypted data */
name|crc
operator|=
operator|~
literal|0
expr_stmt|;
name|i
operator|=
name|j
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
operator|-
name|off
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|buflen
operator|>
name|data_len
condition|)
name|buflen
operator|=
name|data_len
expr_stmt|;
name|data_len
operator|-=
name|buflen
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|buflen
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
operator|*
name|pos
operator|^=
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
expr_stmt|;
name|crc
operator|=
name|crc32_table
index|[
operator|(
name|crc
operator|^
operator|*
name|pos
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|crc
operator|>>
literal|8
operator|)
expr_stmt|;
name|pos
operator|++
expr_stmt|;
block|}
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
name|data_len
operator|==
literal|0
argument_list|,
operator|(
literal|"out of buffers with data_len %zu\n"
operator|,
name|data_len
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|pos
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|buflen
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
name|crc
operator|=
operator|~
name|crc
expr_stmt|;
comment|/* Encrypt little-endian CRC32 and verify that it matches with the 	 * received ICV */
name|icv
index|[
literal|0
index|]
operator|=
name|crc
expr_stmt|;
name|icv
index|[
literal|1
index|]
operator|=
name|crc
operator|>>
literal|8
expr_stmt|;
name|icv
index|[
literal|2
index|]
operator|=
name|crc
operator|>>
literal|16
expr_stmt|;
name|icv
index|[
literal|3
index|]
operator|=
name|crc
operator|>>
literal|24
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
name|j
operator|=
operator|(
name|j
operator|+
name|S
index|[
name|i
index|]
operator|)
operator|&
literal|0xff
expr_stmt|;
name|S_SWAP
argument_list|(
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|icv
index|[
name|k
index|]
operator|^
name|S
index|[
operator|(
name|S
index|[
name|i
index|]
operator|+
name|S
index|[
name|j
index|]
operator|)
operator|&
literal|0xff
index|]
operator|)
operator|!=
operator|*
name|pos
operator|++
condition|)
block|{
comment|/* ICV mismatch - drop frame */
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u32
name|rotl
parameter_list|(
name|u32
name|val
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
return|return
operator|(
name|val
operator|<<
name|bits
operator|)
operator||
operator|(
name|val
operator|>>
operator|(
literal|32
operator|-
name|bits
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u32
name|rotr
parameter_list|(
name|u32
name|val
parameter_list|,
name|int
name|bits
parameter_list|)
block|{
return|return
operator|(
name|val
operator|>>
name|bits
operator|)
operator||
operator|(
name|val
operator|<<
operator|(
literal|32
operator|-
name|bits
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u32
name|xswap
parameter_list|(
name|u32
name|val
parameter_list|)
block|{
return|return
operator|(
operator|(
name|val
operator|&
literal|0x00ff00ff
operator|)
operator|<<
literal|8
operator|)
operator||
operator|(
operator|(
name|val
operator|&
literal|0xff00ff00
operator|)
operator|>>
literal|8
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|michael_block
parameter_list|(
name|l
parameter_list|,
name|r
parameter_list|)
define|\
value|do {				\ 	r ^= rotl(l, 17);	\ 	l += r;			\ 	r ^= xswap(l);		\ 	l += r;			\ 	r ^= rotl(l, 3);	\ 	l += r;			\ 	r ^= rotr(l, 2);	\ 	l += r;			\ } while (0)
end_define

begin_function
specifier|static
name|__inline
name|u32
name|get_le32_split
parameter_list|(
name|u8
name|b0
parameter_list|,
name|u8
name|b1
parameter_list|,
name|u8
name|b2
parameter_list|,
name|u8
name|b3
parameter_list|)
block|{
return|return
name|b0
operator||
operator|(
name|b1
operator|<<
literal|8
operator|)
operator||
operator|(
name|b2
operator|<<
literal|16
operator|)
operator||
operator|(
name|b3
operator|<<
literal|24
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u32
name|get_le32
parameter_list|(
specifier|const
name|u8
modifier|*
name|p
parameter_list|)
block|{
return|return
name|get_le32_split
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|p
index|[
literal|2
index|]
argument_list|,
name|p
index|[
literal|3
index|]
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|put_le32
parameter_list|(
name|u8
modifier|*
name|p
parameter_list|,
name|u32
name|v
parameter_list|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|v
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|v
operator|>>
literal|8
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
name|v
operator|>>
literal|16
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
name|v
operator|>>
literal|24
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Craft pseudo header used to calculate the MIC.  */
end_comment

begin_function
specifier|static
name|void
name|michael_mic_hdr
parameter_list|(
specifier|const
name|struct
name|ieee80211_frame
modifier|*
name|wh0
parameter_list|,
name|uint8_t
name|hdr
index|[
literal|16
index|]
parameter_list|)
block|{
specifier|const
name|struct
name|ieee80211_frame_addr4
modifier|*
name|wh
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_frame_addr4
operator|*
operator|)
name|wh0
decl_stmt|;
switch|switch
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|1
index|]
operator|&
name|IEEE80211_FC1_DIR_MASK
condition|)
block|{
case|case
name|IEEE80211_FC1_DIR_NODS
case|:
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
comment|/* DA */
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
operator|+
name|IEEE80211_ADDR_LEN
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_TODS
case|:
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
comment|/* DA */
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
operator|+
name|IEEE80211_ADDR_LEN
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_FROMDS
case|:
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
argument_list|,
name|wh
operator|->
name|i_addr1
argument_list|)
expr_stmt|;
comment|/* DA */
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
operator|+
name|IEEE80211_ADDR_LEN
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
break|break;
case|case
name|IEEE80211_FC1_DIR_DSTODS
case|:
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
argument_list|,
name|wh
operator|->
name|i_addr3
argument_list|)
expr_stmt|;
comment|/* DA */
name|IEEE80211_ADDR_COPY
argument_list|(
name|hdr
operator|+
name|IEEE80211_ADDR_LEN
argument_list|,
name|wh
operator|->
name|i_addr4
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wh
operator|->
name|i_fc
index|[
literal|0
index|]
operator|&
name|IEEE80211_FC0_SUBTYPE_QOS
condition|)
block|{
specifier|const
name|struct
name|ieee80211_qosframe
modifier|*
name|qwh
init|=
operator|(
specifier|const
expr|struct
name|ieee80211_qosframe
operator|*
operator|)
name|wh
decl_stmt|;
name|hdr
index|[
literal|12
index|]
operator|=
name|qwh
operator|->
name|i_qos
index|[
literal|0
index|]
operator|&
name|IEEE80211_QOS_TID
expr_stmt|;
block|}
else|else
name|hdr
index|[
literal|12
index|]
operator|=
literal|0
expr_stmt|;
name|hdr
index|[
literal|13
index|]
operator|=
name|hdr
index|[
literal|14
index|]
operator|=
name|hdr
index|[
literal|15
index|]
operator|=
literal|0
expr_stmt|;
comment|/* reserved */
block|}
end_function

begin_function
specifier|static
name|void
name|michael_mic
parameter_list|(
name|struct
name|tkip_ctx
modifier|*
name|ctx
parameter_list|,
specifier|const
name|u8
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|u_int
name|off
parameter_list|,
name|size_t
name|data_len
parameter_list|,
name|u8
name|mic
index|[
name|IEEE80211_WEP_MICLEN
index|]
parameter_list|)
block|{
name|uint8_t
name|hdr
index|[
literal|16
index|]
decl_stmt|;
name|u32
name|l
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|uint8_t
modifier|*
name|data
decl_stmt|;
name|u_int
name|space
decl_stmt|;
name|michael_mic_hdr
argument_list|(
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
argument_list|,
name|hdr
argument_list|)
expr_stmt|;
name|l
operator|=
name|get_le32
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|r
operator|=
name|get_le32
argument_list|(
name|key
operator|+
literal|4
argument_list|)
expr_stmt|;
comment|/* Michael MIC pseudo header: DA, SA, 3 x 0, Priority */
name|l
operator|^=
name|get_le32
argument_list|(
name|hdr
argument_list|)
expr_stmt|;
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|l
operator|^=
name|get_le32
argument_list|(
operator|&
name|hdr
index|[
literal|4
index|]
argument_list|)
expr_stmt|;
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|l
operator|^=
name|get_le32
argument_list|(
operator|&
name|hdr
index|[
literal|8
index|]
argument_list|)
expr_stmt|;
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|l
operator|^=
name|get_le32
argument_list|(
operator|&
name|hdr
index|[
literal|12
index|]
argument_list|)
expr_stmt|;
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* first buffer has special handling */
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
operator|+
name|off
expr_stmt|;
name|space
operator|=
name|m
operator|->
name|m_len
operator|-
name|off
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|space
operator|>
name|data_len
condition|)
name|space
operator|=
name|data_len
expr_stmt|;
comment|/* collect 32-bit blocks from current buffer */
while|while
condition|(
name|space
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
block|{
name|l
operator|^=
name|get_le32
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|data
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|,
name|space
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
name|data_len
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data_len
operator|<
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
break|break;
name|m
operator|=
name|m
operator|->
name|m_next
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
block|{
name|KASSERT
argument_list|(
literal|0
argument_list|,
operator|(
literal|"out of data, data_len %zu\n"
operator|,
name|data_len
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|space
operator|!=
literal|0
condition|)
block|{
specifier|const
name|uint8_t
modifier|*
name|data_next
decl_stmt|;
comment|/* 			 * Block straddles buffers, split references. 			 */
name|data_next
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|KASSERT
argument_list|(
name|m
operator|->
name|m_len
operator|>=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
name|space
argument_list|,
operator|(
literal|"not enough data in following buffer, "
literal|"m_len %u need %zu\n"
operator|,
name|m
operator|->
name|m_len
operator|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|-
name|space
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|space
condition|)
block|{
case|case
literal|1
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data_next
index|[
literal|0
index|]
argument_list|,
name|data_next
index|[
literal|1
index|]
argument_list|,
name|data_next
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|data
operator|=
name|data_next
operator|+
literal|3
expr_stmt|;
name|space
operator|=
name|m
operator|->
name|m_len
operator|-
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data_next
index|[
literal|0
index|]
argument_list|,
name|data_next
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|data
operator|=
name|data_next
operator|+
literal|2
expr_stmt|;
name|space
operator|=
name|m
operator|->
name|m_len
operator|-
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
name|data_next
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|data
operator|=
name|data_next
operator|+
literal|1
expr_stmt|;
name|space
operator|=
name|m
operator|->
name|m_len
operator|-
literal|1
expr_stmt|;
break|break;
block|}
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|data_len
operator|-=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Setup for next buffer. 			 */
name|data
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
specifier|const
name|uint8_t
operator|*
argument_list|)
expr_stmt|;
name|space
operator|=
name|m
operator|->
name|m_len
expr_stmt|;
block|}
block|}
comment|/* Last block and padding (0x5a, 4..7 x 0) */
switch|switch
condition|(
name|data_len
condition|)
block|{
case|case
literal|0
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
literal|0x5a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
literal|0x5a
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
literal|0x5a
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|l
operator|^=
name|get_le32_split
argument_list|(
name|data
index|[
literal|0
index|]
argument_list|,
name|data
index|[
literal|1
index|]
argument_list|,
name|data
index|[
literal|2
index|]
argument_list|,
literal|0x5a
argument_list|)
expr_stmt|;
break|break;
block|}
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* l ^= 0; */
name|michael_block
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|put_le32
argument_list|(
name|mic
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|put_le32
argument_list|(
name|mic
operator|+
literal|4
argument_list|,
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|tkip_encrypt
parameter_list|(
name|struct
name|tkip_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|uint8_t
name|icv
index|[
name|IEEE80211_WEP_CRCLEN
index|]
decl_stmt|;
name|ctx
operator|->
name|tc_ic
operator|->
name|ic_stats
operator|.
name|is_crypto_tkip
operator|++
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|tx_phase1_done
condition|)
block|{
name|tkip_mixing_phase1
argument_list|(
name|ctx
operator|->
name|tx_ttak
argument_list|,
name|key
operator|->
name|wk_key
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
call|(
name|u32
call|)
argument_list|(
name|key
operator|->
name|wk_keytsc
operator|>>
literal|16
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tx_phase1_done
operator|=
literal|1
expr_stmt|;
block|}
name|tkip_mixing_phase2
argument_list|(
name|ctx
operator|->
name|tx_rc4key
argument_list|,
name|key
operator|->
name|wk_key
argument_list|,
name|ctx
operator|->
name|tx_ttak
argument_list|,
operator|(
name|u16
operator|)
name|key
operator|->
name|wk_keytsc
argument_list|)
expr_stmt|;
name|wep_encrypt
argument_list|(
name|ctx
operator|->
name|tx_rc4key
argument_list|,
name|m
argument_list|,
name|hdrlen
operator|+
name|tkip
operator|.
name|ic_header
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|+
name|tkip
operator|.
name|ic_header
operator|)
argument_list|,
name|icv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|m_append
argument_list|(
name|m
argument_list|,
name|IEEE80211_WEP_CRCLEN
argument_list|,
name|icv
argument_list|)
expr_stmt|;
comment|/* XXX check return */
name|key
operator|->
name|wk_keytsc
operator|++
expr_stmt|;
if|if
condition|(
call|(
name|u16
call|)
argument_list|(
name|key
operator|->
name|wk_keytsc
argument_list|)
operator|==
literal|0
condition|)
name|ctx
operator|->
name|tx_phase1_done
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tkip_decrypt
parameter_list|(
name|struct
name|tkip_ctx
modifier|*
name|ctx
parameter_list|,
name|struct
name|ieee80211_key
modifier|*
name|key
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|int
name|hdrlen
parameter_list|)
block|{
name|struct
name|ieee80211_frame
modifier|*
name|wh
decl_stmt|;
name|u32
name|iv32
decl_stmt|;
name|u16
name|iv16
decl_stmt|;
name|ctx
operator|->
name|tc_ic
operator|->
name|ic_stats
operator|.
name|is_crypto_tkip
operator|++
expr_stmt|;
name|wh
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|ieee80211_frame
operator|*
argument_list|)
expr_stmt|;
comment|/* NB: tkip_decap already verified header and left seq in rx_rsc */
name|iv16
operator|=
operator|(
name|u16
operator|)
name|ctx
operator|->
name|rx_rsc
expr_stmt|;
name|iv32
operator|=
call|(
name|u32
call|)
argument_list|(
name|ctx
operator|->
name|rx_rsc
operator|>>
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|iv32
operator|!=
call|(
name|u32
call|)
argument_list|(
name|key
operator|->
name|wk_keyrsc
operator|>>
literal|16
argument_list|)
operator|||
operator|!
name|ctx
operator|->
name|rx_phase1_done
condition|)
block|{
name|tkip_mixing_phase1
argument_list|(
name|ctx
operator|->
name|rx_ttak
argument_list|,
name|key
operator|->
name|wk_key
argument_list|,
name|wh
operator|->
name|i_addr2
argument_list|,
name|iv32
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rx_phase1_done
operator|=
literal|1
expr_stmt|;
block|}
name|tkip_mixing_phase2
argument_list|(
name|ctx
operator|->
name|rx_rc4key
argument_list|,
name|key
operator|->
name|wk_key
argument_list|,
name|ctx
operator|->
name|rx_ttak
argument_list|,
name|iv16
argument_list|)
expr_stmt|;
comment|/* NB: m is unstripped; deduct headers + ICV to get payload */
if|if
condition|(
name|wep_decrypt
argument_list|(
name|ctx
operator|->
name|rx_rc4key
argument_list|,
name|m
argument_list|,
name|hdrlen
operator|+
name|tkip
operator|.
name|ic_header
argument_list|,
name|m
operator|->
name|m_pkthdr
operator|.
name|len
operator|-
operator|(
name|hdrlen
operator|+
name|tkip
operator|.
name|ic_header
operator|+
name|tkip
operator|.
name|ic_trailer
operator|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|iv32
operator|!=
call|(
name|u32
call|)
argument_list|(
name|key
operator|->
name|wk_keyrsc
operator|>>
literal|16
argument_list|)
condition|)
block|{
comment|/* Previously cached Phase1 result was already lost, so 			 * it needs to be recalculated for the next packet. */
name|ctx
operator|->
name|rx_phase1_done
operator|=
literal|0
expr_stmt|;
block|}
name|IEEE80211_DPRINTF
argument_list|(
name|ctx
operator|->
name|tc_ic
argument_list|,
name|IEEE80211_MSG_CRYPTO
argument_list|,
literal|"[%s] TKIP ICV mismatch on decrypt\n"
argument_list|,
name|ether_sprintf
argument_list|(
name|wh
operator|->
name|i_addr2
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|tc_ic
operator|->
name|ic_stats
operator|.
name|is_rx_tkipicv
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Module glue.  */
end_comment

begin_function
specifier|static
name|int
name|tkip_modevent
parameter_list|(
name|module_t
name|mod
parameter_list|,
name|int
name|type
parameter_list|,
name|void
modifier|*
name|unused
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MOD_LOAD
case|:
name|ieee80211_crypto_register
argument_list|(
operator|&
name|tkip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
name|MOD_UNLOAD
case|:
case|case
name|MOD_QUIESCE
case|:
if|if
condition|(
name|nrefs
condition|)
block|{
name|printf
argument_list|(
literal|"wlan_tkip: still in use (%u dynamic refs)\n"
argument_list|,
name|nrefs
argument_list|)
expr_stmt|;
return|return
name|EBUSY
return|;
block|}
if|if
condition|(
name|type
operator|==
name|MOD_UNLOAD
condition|)
name|ieee80211_crypto_unregister
argument_list|(
operator|&
name|tkip
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
name|EINVAL
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|moduledata_t
name|tkip_mod
init|=
block|{
literal|"wlan_tkip"
block|,
name|tkip_modevent
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|DECLARE_MODULE
argument_list|(
name|wlan_tkip
argument_list|,
name|tkip_mod
argument_list|,
name|SI_SUB_DRIVERS
argument_list|,
name|SI_ORDER_FIRST
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|wlan_tkip
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|wlan_tkip
argument_list|,
name|wlan
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

