begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: altq_rmclass.c,v 1.19 2005/04/13 03:44:25 suz Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1991-1997 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *      This product includes software developed by the Network Research  *      Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * LBL code modified by speer@eng.sun.com, May 1977.  * For questions and/or comments, please send mail to cbq@ee.lbl.gov  *  * @(#)rm_class.c  1.48     97/12/05 SMI  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_altq.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ || __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_CBQ
end_ifdef

begin_comment
comment|/* cbq is enabled by ALTQ_CBQ option in opt_altq.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_rmclass.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_rmclass_debug.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_red.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_rio.h>
end_include

begin_comment
comment|/*  * Local Macros  */
end_comment

begin_define
define|#
directive|define
name|reset_cutoff
parameter_list|(
name|ifd
parameter_list|)
value|{ ifd->cutoff_ = RM_MAXDEPTH; }
end_define

begin_comment
comment|/*  * Local routines.  */
end_comment

begin_function_decl
specifier|static
name|int
name|rmc_satisfied
parameter_list|(
name|struct
name|rm_class
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_wrr_set_weights
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_depth_compute
parameter_list|(
name|struct
name|rm_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_depth_recompute
parameter_list|(
name|rm_class_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mbuf_t
modifier|*
name|_rmc_wrr_dequeue_next
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mbuf_t
modifier|*
name|_rmc_prr_dequeue_next
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_rmc_addq
parameter_list|(
name|rm_class_t
modifier|*
parameter_list|,
name|mbuf_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_rmc_dropq
parameter_list|(
name|rm_class_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mbuf_t
modifier|*
name|_rmc_getq
parameter_list|(
name|rm_class_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mbuf_t
modifier|*
name|_rmc_pollq
parameter_list|(
name|rm_class_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rmc_under_limit
parameter_list|(
name|struct
name|rm_class
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_tl_satisfied
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_drop_action
parameter_list|(
name|struct
name|rm_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_restart
parameter_list|(
name|struct
name|rm_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rmc_root_overlimit
parameter_list|(
name|struct
name|rm_class
modifier|*
parameter_list|,
name|struct
name|rm_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|BORROW_OFFTIME
end_define

begin_comment
comment|/*  * BORROW_OFFTIME (experimental):  * borrow the offtime of the class borrowing from.  * the reason is that when its own offtime is set, the class is unable  * to borrow much, especially when cutoff is taking effect.  * but when the borrowed class is overloaded (advidle is close to minidle),  * use the borrowing class's offtime to avoid overload.  */
end_comment

begin_define
define|#
directive|define
name|ADJUST_CUTOFF
end_define

begin_comment
comment|/*  * ADJUST_CUTOFF (experimental):  * if no underlimit class is found due to cutoff, increase cutoff and  * retry the scheduling loop.  * also, don't invoke delay_actions while cutoff is taking effect,  * since a sleeping class won't have a chance to be scheduled in the  * next loop.  *  * now heuristics for setting the top-level variable (cutoff_) becomes:  *	1. if a packet arrives for a not-overlimit class, set cutoff  *	   to the depth of the class.  *	2. if cutoff is i, and a packet arrives for an overlimit class  *	   with an underlimit ancestor at a lower level than i (say j),  *	   then set cutoff to j.  *	3. at scheduling a packet, if there is no underlimit class  *	   due to the current cutoff level, increase cutoff by 1 and  *	   then try to schedule again.  */
end_comment

begin_comment
comment|/*  * rm_class_t *  * rmc_newclass(...) - Create a new resource management class at priority  * 'pri' on the interface given by 'ifd'.  *  * nsecPerByte  is the data rate of the interface in nanoseconds/byte.  *              E.g., 800 for a 10Mb/s ethernet.  If the class gets less  *              than 100% of the bandwidth, this number should be the  *              'effective' rate for the class.  Let f be the  *              bandwidth fraction allocated to this class, and let  *              nsPerByte be the data rate of the output link in  *              nanoseconds/byte.  Then nsecPerByte is set to  *              nsPerByte / f.  E.g., 1600 (= 800 / .5)  *              for a class that gets 50% of an ethernet's bandwidth.  *  * action       the routine to call when the class is over limit.  *  * maxq         max allowable queue size for class (in packets).  *  * parent       parent class pointer.  *  * borrow       class to borrow from (should be either 'parent' or null).  *  * maxidle      max value allowed for class 'idle' time estimate (this  *              parameter determines how large an initial burst of packets  *              can be before overlimit action is invoked.  *  * offtime      how long 'delay' action will delay when class goes over  *              limit (this parameter determines the steady-state burst  *              size when a class is running over its limit).  *  * Maxidle and offtime have to be computed from the following:  If the  * average packet size is s, the bandwidth fraction allocated to this  * class is f, we want to allow b packet bursts, and the gain of the  * averaging filter is g (= 1 - 2^(-RM_FILTER_GAIN)), then:  *  *   ptime = s * nsPerByte * (1 - f) / f  *   maxidle = ptime * (1 - g^b) / g^b  *   minidle = -ptime * (1 / (f - 1))  *   offtime = ptime * (1 + 1/(1 - g) * (1 - g^(b - 1)) / g^(b - 1)  *  * Operationally, it's convenient to specify maxidle& offtime in units  * independent of the link bandwidth so the maxidle& offtime passed to  * this routine are the above values multiplied by 8*f/(1000*nsPerByte).  * (The constant factor is a scale factor needed to make the parameters  * integers.  This scaling also means that the 'unscaled' values of  * maxidle*nsecPerByte/8 and offtime*nsecPerByte/8 will be in microseconds,  * not nanoseconds.)  Also note that the 'idle' filter computation keeps  * an estimate scaled upward by 2^RM_FILTER_GAIN so the passed value of  * maxidle also must be scaled upward by this value.  Thus, the passed  * values for maxidle and offtime can be computed as follows:  *  * maxidle = maxidle * 2^RM_FILTER_GAIN * 8 / (1000 * nsecPerByte)  * offtime = offtime * 8 / (1000 * nsecPerByte)  *  * When USE_HRTIME is employed, then maxidle and offtime become:  * 	maxidle = maxilde * (8.0 / nsecPerByte);  * 	offtime = offtime * (8.0 / nsecPerByte);  */
end_comment

begin_function
name|struct
name|rm_class
modifier|*
name|rmc_newclass
parameter_list|(
name|int
name|pri
parameter_list|,
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|u_int
name|nsecPerByte
parameter_list|,
name|void
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|(
name|rm_class_t
modifier|*
parameter_list|,
name|rm_class_t
modifier|*
parameter_list|)
parameter_list|,
name|int
name|maxq
parameter_list|,
name|struct
name|rm_class
modifier|*
name|parent
parameter_list|,
name|struct
name|rm_class
modifier|*
name|borrow
parameter_list|,
name|u_int
name|maxidle
parameter_list|,
name|int
name|minidle
parameter_list|,
name|u_int
name|offtime
parameter_list|,
name|int
name|pktsize
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|rm_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|rm_class
modifier|*
name|peer
decl_stmt|;
name|int
name|s
decl_stmt|;
if|if
condition|(
name|pri
operator|>=
name|RM_MAXPRIO
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifndef|#
directive|ifndef
name|ALTQ_RED
if|if
condition|(
name|flags
operator|&
name|RMCF_RED
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|printf
argument_list|(
literal|"rmc_newclass: RED not configured for CBQ!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ALTQ_RIO
if|if
condition|(
name|flags
operator|&
name|RMCF_RIO
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|printf
argument_list|(
literal|"rmc_newclass: RIO not configured for CBQ!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
name|cl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rm_class
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|CALLOUT_INIT
argument_list|(
operator|&
name|cl
operator|->
name|callout_
argument_list|)
expr_stmt|;
name|cl
operator|->
name|q_
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|class_queue_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|q_
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cl
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Class initialization. 	 */
name|cl
operator|->
name|children_
operator|=
name|NULL
expr_stmt|;
name|cl
operator|->
name|parent_
operator|=
name|parent
expr_stmt|;
name|cl
operator|->
name|borrow_
operator|=
name|borrow
expr_stmt|;
name|cl
operator|->
name|leaf_
operator|=
literal|1
expr_stmt|;
name|cl
operator|->
name|ifdat_
operator|=
name|ifd
expr_stmt|;
name|cl
operator|->
name|pri_
operator|=
name|pri
expr_stmt|;
name|cl
operator|->
name|allotment_
operator|=
name|RM_NS_PER_SEC
operator|/
name|nsecPerByte
expr_stmt|;
comment|/* Bytes per sec */
name|cl
operator|->
name|depth_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|qthresh_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|ns_per_byte_
operator|=
name|nsecPerByte
expr_stmt|;
name|qlimit
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|=
name|maxq
expr_stmt|;
name|qtype
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|=
name|Q_DROPHEAD
expr_stmt|;
name|qlen
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|flags_
operator|=
name|flags
expr_stmt|;
if|#
directive|if
literal|1
comment|/* minidle is also scaled in ALTQ */
name|cl
operator|->
name|minidle_
operator|=
operator|(
name|minidle
operator|*
operator|(
name|int
operator|)
name|nsecPerByte
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|minidle_
operator|>
literal|0
condition|)
name|cl
operator|->
name|minidle_
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|cl
operator|->
name|minidle_
operator|=
name|minidle
expr_stmt|;
endif|#
directive|endif
name|cl
operator|->
name|maxidle_
operator|=
operator|(
name|maxidle
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|maxidle_
operator|==
literal|0
condition|)
name|cl
operator|->
name|maxidle_
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|1
comment|/* offtime is also scaled in ALTQ */
name|cl
operator|->
name|avgidle_
operator|=
name|cl
operator|->
name|maxidle_
expr_stmt|;
name|cl
operator|->
name|offtime_
operator|=
operator|(
operator|(
name|offtime
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
operator|)
operator|>>
name|RM_FILTER_GAIN
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|offtime_
operator|==
literal|0
condition|)
name|cl
operator|->
name|offtime_
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|cl
operator|->
name|avgidle_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|offtime_
operator|=
operator|(
name|offtime
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
expr_stmt|;
endif|#
directive|endif
name|cl
operator|->
name|overlimit
operator|=
name|action
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|flags
operator|&
operator|(
name|RMCF_RED
operator||
name|RMCF_RIO
operator|)
condition|)
block|{
name|int
name|red_flags
decl_stmt|,
name|red_pkttime
decl_stmt|;
name|red_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RMCF_ECN
condition|)
name|red_flags
operator||=
name|REDF_ECN
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RMCF_FLOWVALVE
condition|)
name|red_flags
operator||=
name|REDF_FLOWVALVE
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|flags
operator|&
name|RMCF_CLEARDSCP
condition|)
name|red_flags
operator||=
name|RIOF_CLEARDSCP
expr_stmt|;
endif|#
directive|endif
name|red_pkttime
operator|=
name|nsecPerByte
operator|*
name|pktsize
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|RMCF_RED
condition|)
block|{
name|cl
operator|->
name|red_
operator|=
name|red_alloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|qlimit
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|*
literal|10
operator|/
literal|100
argument_list|,
name|qlimit
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|*
literal|30
operator|/
literal|100
argument_list|,
name|red_flags
argument_list|,
name|red_pkttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|red_
operator|!=
name|NULL
condition|)
name|qtype
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|=
name|Q_RED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ALTQ_RIO
else|else
block|{
name|cl
operator|->
name|red_
operator|=
operator|(
name|red_t
operator|*
operator|)
name|rio_alloc
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|red_flags
argument_list|,
name|red_pkttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|red_
operator|!=
name|NULL
condition|)
name|qtype
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|=
name|Q_RIO
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ALTQ_RED */
comment|/* 	 * put the class into the class tree 	 */
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|peer
operator|=
name|ifd
operator|->
name|active_
index|[
name|pri
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* find the last class at this pri */
name|cl
operator|->
name|peer_
operator|=
name|peer
expr_stmt|;
while|while
condition|(
name|peer
operator|->
name|peer_
operator|!=
name|ifd
operator|->
name|active_
index|[
name|pri
index|]
condition|)
name|peer
operator|=
name|peer
operator|->
name|peer_
expr_stmt|;
name|peer
operator|->
name|peer_
operator|=
name|cl
expr_stmt|;
block|}
else|else
block|{
name|ifd
operator|->
name|active_
index|[
name|pri
index|]
operator|=
name|cl
expr_stmt|;
name|cl
operator|->
name|peer_
operator|=
name|cl
expr_stmt|;
block|}
if|if
condition|(
name|cl
operator|->
name|parent_
condition|)
block|{
name|cl
operator|->
name|next_
operator|=
name|parent
operator|->
name|children_
expr_stmt|;
name|parent
operator|->
name|children_
operator|=
name|cl
expr_stmt|;
name|parent
operator|->
name|leaf_
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Compute the depth of this class and its ancestors in the class 	 * hierarchy. 	 */
name|rmc_depth_compute
argument_list|(
name|cl
argument_list|)
expr_stmt|;
comment|/* 	 * If CBQ's WRR is enabled, then initialize the class WRR state. 	 */
if|if
condition|(
name|ifd
operator|->
name|wrr_
condition|)
block|{
name|ifd
operator|->
name|num_
index|[
name|pri
index|]
operator|++
expr_stmt|;
name|ifd
operator|->
name|alloc_
index|[
name|pri
index|]
operator|+=
name|cl
operator|->
name|allotment_
expr_stmt|;
name|rmc_wrr_set_weights
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
name|IFQ_UNLOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cl
operator|)
return|;
block|}
end_function

begin_function
name|int
name|rmc_modclass
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|,
name|u_int
name|nsecPerByte
parameter_list|,
name|int
name|maxq
parameter_list|,
name|u_int
name|maxidle
parameter_list|,
name|int
name|minidle
parameter_list|,
name|u_int
name|offtime
parameter_list|,
name|int
name|pktsize
parameter_list|)
block|{
name|struct
name|rm_ifdat
modifier|*
name|ifd
decl_stmt|;
name|u_int
name|old_allotment
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ifd
operator|=
name|cl
operator|->
name|ifdat_
expr_stmt|;
name|old_allotment
operator|=
name|cl
operator|->
name|allotment_
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
name|cl
operator|->
name|allotment_
operator|=
name|RM_NS_PER_SEC
operator|/
name|nsecPerByte
expr_stmt|;
comment|/* Bytes per sec */
name|cl
operator|->
name|qthresh_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|ns_per_byte_
operator|=
name|nsecPerByte
expr_stmt|;
name|qlimit
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|=
name|maxq
expr_stmt|;
if|#
directive|if
literal|1
comment|/* minidle is also scaled in ALTQ */
name|cl
operator|->
name|minidle_
operator|=
operator|(
name|minidle
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|minidle_
operator|>
literal|0
condition|)
name|cl
operator|->
name|minidle_
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|cl
operator|->
name|minidle_
operator|=
name|minidle
expr_stmt|;
endif|#
directive|endif
name|cl
operator|->
name|maxidle_
operator|=
operator|(
name|maxidle
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|maxidle_
operator|==
literal|0
condition|)
name|cl
operator|->
name|maxidle_
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|1
comment|/* offtime is also scaled in ALTQ */
name|cl
operator|->
name|avgidle_
operator|=
name|cl
operator|->
name|maxidle_
expr_stmt|;
name|cl
operator|->
name|offtime_
operator|=
operator|(
operator|(
name|offtime
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
operator|)
operator|>>
name|RM_FILTER_GAIN
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|offtime_
operator|==
literal|0
condition|)
name|cl
operator|->
name|offtime_
operator|=
literal|1
expr_stmt|;
else|#
directive|else
name|cl
operator|->
name|avgidle_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|offtime_
operator|=
operator|(
name|offtime
operator|*
name|nsecPerByte
operator|)
operator|/
literal|8
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If CBQ's WRR is enabled, then initialize the class WRR state. 	 */
if|if
condition|(
name|ifd
operator|->
name|wrr_
condition|)
block|{
name|ifd
operator|->
name|alloc_
index|[
name|cl
operator|->
name|pri_
index|]
operator|+=
name|cl
operator|->
name|allotment_
operator|-
name|old_allotment
expr_stmt|;
name|rmc_wrr_set_weights
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
name|IFQ_UNLOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * static void  * rmc_wrr_set_weights(struct rm_ifdat *ifdat) - This function computes  *	the appropriate run robin weights for the CBQ weighted round robin  *	algorithm.  *  *	Returns: NONE  */
end_comment

begin_function
specifier|static
name|void
name|rmc_wrr_set_weights
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|rm_class
modifier|*
name|cl
decl_stmt|,
modifier|*
name|clh
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RM_MAXPRIO
condition|;
name|i
operator|++
control|)
block|{
comment|/* 		 * This is inverted from that of the simulator to 		 * maintain precision. 		 */
if|if
condition|(
name|ifd
operator|->
name|num_
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|ifd
operator|->
name|M_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
else|else
name|ifd
operator|->
name|M_
index|[
name|i
index|]
operator|=
name|ifd
operator|->
name|alloc_
index|[
name|i
index|]
operator|/
operator|(
name|ifd
operator|->
name|num_
index|[
name|i
index|]
operator|*
name|ifd
operator|->
name|maxpkt_
operator|)
expr_stmt|;
comment|/* 		 * Compute the weighted allotment for each class. 		 * This takes the expensive div instruction out 		 * of the main loop for the wrr scheduling path. 		 * These only get recomputed when a class comes or 		 * goes. 		 */
if|if
condition|(
name|ifd
operator|->
name|active_
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|clh
operator|=
name|cl
operator|=
name|ifd
operator|->
name|active_
index|[
name|i
index|]
expr_stmt|;
do|do
block|{
comment|/* safe-guard for slow link or alloc_ == 0 */
if|if
condition|(
name|ifd
operator|->
name|M_
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|cl
operator|->
name|w_allotment_
operator|=
literal|0
expr_stmt|;
else|else
name|cl
operator|->
name|w_allotment_
operator|=
name|cl
operator|->
name|allotment_
operator|/
name|ifd
operator|->
name|M_
index|[
name|i
index|]
expr_stmt|;
name|cl
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|cl
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|cl
operator|!=
name|clh
operator|)
condition|)
do|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|rmc_get_weight
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|int
name|pri
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pri
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|pri
operator|<
name|RM_MAXPRIO
operator|)
condition|)
return|return
operator|(
name|ifd
operator|->
name|M_
index|[
name|pri
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * static void  * rmc_depth_compute(struct rm_class *cl) - This function computes the  *	appropriate depth of class 'cl' and its ancestors.  *  *	Returns:	NONE  */
end_comment

begin_function
specifier|static
name|void
name|rmc_depth_compute
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|)
block|{
name|rm_class_t
modifier|*
name|t
init|=
name|cl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Recompute the depth for the branch of the tree. 	 */
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|t
operator|->
name|parent_
expr_stmt|;
if|if
condition|(
name|p
operator|&&
operator|(
name|t
operator|->
name|depth_
operator|>=
name|p
operator|->
name|depth_
operator|)
condition|)
block|{
name|p
operator|->
name|depth_
operator|=
name|t
operator|->
name|depth_
operator|+
literal|1
expr_stmt|;
name|t
operator|=
name|p
expr_stmt|;
block|}
else|else
name|t
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * static void  * rmc_depth_recompute(struct rm_class *cl) - This function re-computes  *	the depth of the tree after a class has been deleted.  *  *	Returns:	NONE  */
end_comment

begin_function
specifier|static
name|void
name|rmc_depth_recompute
parameter_list|(
name|rm_class_t
modifier|*
name|cl
parameter_list|)
block|{
if|#
directive|if
literal|1
comment|/* ALTQ */
name|rm_class_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|p
operator|=
name|cl
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|t
operator|=
name|p
operator|->
name|children_
operator|)
operator|==
name|NULL
condition|)
block|{
name|p
operator|->
name|depth_
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|cdepth
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|depth_
operator|>
name|cdepth
condition|)
name|cdepth
operator|=
name|t
operator|->
name|depth_
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next_
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|depth_
operator|==
name|cdepth
operator|+
literal|1
condition|)
comment|/* no change to this parent */
return|return;
name|p
operator|->
name|depth_
operator|=
name|cdepth
operator|+
literal|1
expr_stmt|;
block|}
name|p
operator|=
name|p
operator|->
name|parent_
expr_stmt|;
block|}
else|#
directive|else
name|rm_class_t
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|cl
operator|->
name|depth_
operator|>=
literal|1
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|children_
operator|==
name|NULL
condition|)
block|{
name|cl
operator|->
name|depth_
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|t
operator|=
name|cl
operator|->
name|children_
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|t
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|t
operator|->
name|children_
operator|!=
name|NULL
condition|)
name|rmc_depth_recompute
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next_
expr_stmt|;
block|}
block|}
else|else
name|rmc_depth_compute
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * void  * rmc_delete_class(struct rm_ifdat *ifdat, struct rm_class *cl) - This  *	function deletes a class from the link-sharing structure and frees  *	all resources associated with the class.  *  *	Returns: NONE  */
end_comment

begin_function
name|void
name|rmc_delete_class
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|rm_class
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|,
modifier|*
name|previous
decl_stmt|;
name|int
name|s
decl_stmt|;
name|ASSERT
argument_list|(
name|cl
operator|->
name|children_
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|sleeping_
condition|)
name|CALLOUT_STOP
argument_list|(
operator|&
name|cl
operator|->
name|callout_
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
comment|/* 	 * Free packets in the packet queue. 	 * XXX - this may not be a desired behavior.  Packets should be 	 *		re-queued. 	 */
name|rmc_dropall
argument_list|(
name|cl
argument_list|)
expr_stmt|;
comment|/* 	 * If the class has a parent, then remove the class from the 	 * class from the parent's children chain. 	 */
if|if
condition|(
name|cl
operator|->
name|parent_
operator|!=
name|NULL
condition|)
block|{
name|head
operator|=
name|cl
operator|->
name|parent_
operator|->
name|children_
expr_stmt|;
name|p
operator|=
name|previous
operator|=
name|head
expr_stmt|;
if|if
condition|(
name|head
operator|->
name|next_
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|head
operator|==
name|cl
argument_list|)
expr_stmt|;
name|cl
operator|->
name|parent_
operator|->
name|children_
operator|=
name|NULL
expr_stmt|;
name|cl
operator|->
name|parent_
operator|->
name|leaf_
operator|=
literal|1
expr_stmt|;
block|}
else|else
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|cl
condition|)
block|{
if|if
condition|(
name|cl
operator|==
name|head
condition|)
name|cl
operator|->
name|parent_
operator|->
name|children_
operator|=
name|cl
operator|->
name|next_
expr_stmt|;
else|else
name|previous
operator|->
name|next_
operator|=
name|cl
operator|->
name|next_
expr_stmt|;
name|cl
operator|->
name|next_
operator|=
name|NULL
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|previous
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|next_
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Delete class from class priority peer list. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|ifd
operator|->
name|active_
index|[
name|cl
operator|->
name|pri_
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If there is more than one member of this priority 		 * level, then look for class(cl) in the priority level. 		 */
if|if
condition|(
name|p
operator|!=
name|p
operator|->
name|peer_
condition|)
block|{
while|while
condition|(
name|p
operator|->
name|peer_
operator|!=
name|cl
condition|)
name|p
operator|=
name|p
operator|->
name|peer_
expr_stmt|;
name|p
operator|->
name|peer_
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
if|if
condition|(
name|ifd
operator|->
name|active_
index|[
name|cl
operator|->
name|pri_
index|]
operator|==
name|cl
condition|)
name|ifd
operator|->
name|active_
index|[
name|cl
operator|->
name|pri_
index|]
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|p
operator|==
name|cl
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|active_
index|[
name|cl
operator|->
name|pri_
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * Recompute the WRR weights. 	 */
if|if
condition|(
name|ifd
operator|->
name|wrr_
condition|)
block|{
name|ifd
operator|->
name|alloc_
index|[
name|cl
operator|->
name|pri_
index|]
operator|-=
name|cl
operator|->
name|allotment_
expr_stmt|;
name|ifd
operator|->
name|num_
index|[
name|cl
operator|->
name|pri_
index|]
operator|--
expr_stmt|;
name|rmc_wrr_set_weights
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Re-compute the depth of the tree. 	 */
if|#
directive|if
literal|1
comment|/* ALTQ */
name|rmc_depth_recompute
argument_list|(
name|cl
operator|->
name|parent_
argument_list|)
expr_stmt|;
else|#
directive|else
name|rmc_depth_recompute
argument_list|(
name|ifd
operator|->
name|root_
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|IFQ_UNLOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * Free the class structure. 	 */
if|if
condition|(
name|cl
operator|->
name|red_
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
name|rio_destroy
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|red_
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
name|red_destroy
argument_list|(
name|cl
operator|->
name|red_
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|free
argument_list|(
name|cl
operator|->
name|q_
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * void  * rmc_init(...) - Initialize the resource management data structures  *	associated with the output portion of interface 'ifp'.  'ifd' is  *	where the structures will be built (for backwards compatibility, the  *	structures aren't kept in the ifnet struct).  'nsecPerByte'  *	gives the link speed (inverse of bandwidth) in nanoseconds/byte.  *	'restart' is the driver-specific routine that the generic 'delay  *	until under limit' action will call to restart output.  `maxq'  *	is the queue size of the 'link'& 'default' classes.  'maxqueued'  *	is the maximum number of packets that the resource management  *	code will allow to be queued 'downstream' (this is typically 1).  *  *	Returns:	NONE  */
end_comment

begin_function
name|void
name|rmc_init
parameter_list|(
name|struct
name|ifaltq
modifier|*
name|ifq
parameter_list|,
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|u_int
name|nsecPerByte
parameter_list|,
name|void
function_decl|(
modifier|*
name|restart
function_decl|)
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|)
parameter_list|,
name|int
name|maxq
parameter_list|,
name|int
name|maxqueued
parameter_list|,
name|u_int
name|maxidle
parameter_list|,
name|int
name|minidle
parameter_list|,
name|u_int
name|offtime
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|mtu
decl_stmt|;
comment|/* 	 * Initialize the CBQ tracing/debug facility. 	 */
name|CBQTRACEINIT
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ifd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ifd
argument_list|)
argument_list|)
expr_stmt|;
name|mtu
operator|=
name|ifq
operator|->
name|altq_ifp
operator|->
name|if_mtu
expr_stmt|;
name|ifd
operator|->
name|ifq_
operator|=
name|ifq
expr_stmt|;
name|ifd
operator|->
name|restart
operator|=
name|restart
expr_stmt|;
name|ifd
operator|->
name|maxqueued_
operator|=
name|maxqueued
expr_stmt|;
name|ifd
operator|->
name|ns_per_byte_
operator|=
name|nsecPerByte
expr_stmt|;
name|ifd
operator|->
name|maxpkt_
operator|=
name|mtu
expr_stmt|;
name|ifd
operator|->
name|wrr_
operator|=
operator|(
name|flags
operator|&
name|RMCF_WRR
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|ifd
operator|->
name|efficient_
operator|=
operator|(
name|flags
operator|&
name|RMCF_EFFICIENT
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
if|#
directive|if
literal|1
name|ifd
operator|->
name|maxiftime_
operator|=
name|mtu
operator|*
name|nsecPerByte
operator|/
literal|1000
operator|*
literal|16
expr_stmt|;
if|if
condition|(
name|mtu
operator|*
name|nsecPerByte
operator|>
literal|10
operator|*
literal|1000000
condition|)
name|ifd
operator|->
name|maxiftime_
operator|/=
literal|4
expr_stmt|;
endif|#
directive|endif
name|reset_cutoff
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_init
argument_list|,
literal|'INIT'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the CBQ's WRR state. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RM_MAXPRIO
condition|;
name|i
operator|++
control|)
block|{
name|ifd
operator|->
name|alloc_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ifd
operator|->
name|M_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ifd
operator|->
name|num_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ifd
operator|->
name|na_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ifd
operator|->
name|active_
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Initialize current packet state. 	 */
name|ifd
operator|->
name|qi_
operator|=
literal|0
expr_stmt|;
name|ifd
operator|->
name|qo_
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RM_MAXQUEUED
condition|;
name|i
operator|++
control|)
block|{
name|ifd
operator|->
name|class_
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|ifd
operator|->
name|curlen_
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ifd
operator|->
name|borrowed_
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Create the root class of the link-sharing structure. 	 */
if|if
condition|(
operator|(
name|ifd
operator|->
name|root_
operator|=
name|rmc_newclass
argument_list|(
literal|0
argument_list|,
name|ifd
argument_list|,
name|nsecPerByte
argument_list|,
name|rmc_root_overlimit
argument_list|,
name|maxq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|maxidle
argument_list|,
name|minidle
argument_list|,
name|offtime
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"rmc_init: root class not allocated\n"
argument_list|)
expr_stmt|;
return|return ;
block|}
name|ifd
operator|->
name|root_
operator|->
name|depth_
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * void  * rmc_queue_packet(struct rm_class *cl, mbuf_t *m) - Add packet given by  *	mbuf 'm' to queue for resource class 'cl'.  This routine is called  *	by a driver's if_output routine.  This routine must be called with  *	output packet completion interrupts locked out (to avoid racing with  *	rmc_dequeue_next).  *  *	Returns:	0 on successful queueing  *			-1 when packet drop occurs  */
end_comment

begin_function
name|int
name|rmc_queue_packet
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|,
name|mbuf_t
modifier|*
name|m
parameter_list|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|rm_ifdat
modifier|*
name|ifd
init|=
name|cl
operator|->
name|ifdat_
decl_stmt|;
name|int
name|cpri
init|=
name|cl
operator|->
name|pri_
decl_stmt|;
name|int
name|is_empty
init|=
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
decl_stmt|;
name|RM_GETTIME
argument_list|(
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifd
operator|->
name|cutoff_
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|TV_LT
argument_list|(
operator|&
name|cl
operator|->
name|undertime_
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
name|ifd
operator|->
name|cutoff_
operator|>
name|cl
operator|->
name|depth_
condition|)
name|ifd
operator|->
name|cutoff_
operator|=
name|cl
operator|->
name|depth_
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_queue_packet
argument_list|,
literal|'ffoc'
argument_list|,
name|cl
operator|->
name|depth_
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|1
comment|/* ALTQ */
else|else
block|{
comment|/* 			 * the class is overlimit. if the class has 			 * underlimit ancestors, set cutoff to the lowest 			 * depth among them. 			 */
name|struct
name|rm_class
modifier|*
name|borrow
init|=
name|cl
operator|->
name|borrow_
decl_stmt|;
while|while
condition|(
name|borrow
operator|!=
name|NULL
operator|&&
name|borrow
operator|->
name|depth_
operator|<
name|ifd
operator|->
name|cutoff_
condition|)
block|{
if|if
condition|(
name|TV_LT
argument_list|(
operator|&
name|borrow
operator|->
name|undertime_
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|ifd
operator|->
name|cutoff_
operator|=
name|borrow
operator|->
name|depth_
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_queue_packet
argument_list|,
literal|'ffob'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
break|break;
block|}
name|borrow
operator|=
name|borrow
operator|->
name|borrow_
expr_stmt|;
block|}
block|}
else|#
directive|else
comment|/* !ALTQ */
elseif|else
if|if
condition|(
operator|(
name|ifd
operator|->
name|cutoff_
operator|>
literal|1
operator|)
operator|&&
name|cl
operator|->
name|borrow_
condition|)
block|{
if|if
condition|(
name|TV_LT
argument_list|(
operator|&
name|cl
operator|->
name|borrow_
operator|->
name|undertime_
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
name|ifd
operator|->
name|cutoff_
operator|=
name|cl
operator|->
name|borrow_
operator|->
name|depth_
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_queue_packet
argument_list|,
literal|'ffob'
argument_list|,
name|cl
operator|->
name|borrow_
operator|->
name|depth_
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* !ALTQ */
block|}
if|if
condition|(
name|_rmc_addq
argument_list|(
name|cl
argument_list|,
name|m
argument_list|)
operator|<
literal|0
condition|)
comment|/* failed */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|is_empty
condition|)
block|{
name|CBQTRACE
argument_list|(
name|rmc_queue_packet
argument_list|,
literal|'ytpe'
argument_list|,
name|cl
operator|->
name|stats_
operator|.
name|handle
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|na_
index|[
name|cpri
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|qlen
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|>
name|qlimit
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
block|{
comment|/* note: qlimit can be set to 0 or 1 */
name|rmc_drop_action
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * void  * rmc_tl_satisfied(struct rm_ifdat *ifd, struct timeval *now) - Check all  *	classes to see if there are satified.  */
end_comment

begin_function
specifier|static
name|void
name|rmc_tl_satisfied
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|rm_class_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|i
operator|=
name|RM_MAXPRIO
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
operator|(
name|bp
operator|=
name|ifd
operator|->
name|active_
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|bp
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|rmc_satisfied
argument_list|(
name|p
argument_list|,
name|now
argument_list|)
condition|)
block|{
name|ifd
operator|->
name|cutoff_
operator|=
name|p
operator|->
name|depth_
expr_stmt|;
return|return;
block|}
name|p
operator|=
name|p
operator|->
name|peer_
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|!=
name|bp
condition|)
do|;
block|}
block|}
name|reset_cutoff
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rmc_satisfied - Return 1 of the class is satisfied.  O, otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|rmc_satisfied
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
name|rm_class_t
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|TV_LT
argument_list|(
name|now
argument_list|,
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cl
operator|->
name|depth_
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|cl
operator|->
name|sleeping_
operator|&&
operator|(
name|qlen
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|>
name|cl
operator|->
name|qthresh_
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cl
operator|->
name|children_
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|cl
operator|->
name|children_
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|rmc_satisfied
argument_list|(
name|p
argument_list|,
name|now
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|p
operator|=
name|p
operator|->
name|next_
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 1 if class 'cl' is under limit or can borrow from a parent,  * 0 if overlimit.  As a side-effect, this routine will invoke the  * class overlimit action if the class if overlimit.  */
end_comment

begin_function
specifier|static
name|int
name|rmc_under_limit
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|,
name|struct
name|timeval
modifier|*
name|now
parameter_list|)
block|{
name|rm_class_t
modifier|*
name|p
init|=
name|cl
decl_stmt|;
name|rm_class_t
modifier|*
name|top
decl_stmt|;
name|struct
name|rm_ifdat
modifier|*
name|ifd
init|=
name|cl
operator|->
name|ifdat_
decl_stmt|;
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If cl is the root class, then always return that it is 	 * underlimit.  Otherwise, check to see if the class is underlimit. 	 */
if|if
condition|(
name|cl
operator|->
name|parent_
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|cl
operator|->
name|sleeping_
condition|)
block|{
if|if
condition|(
name|TV_LT
argument_list|(
name|now
argument_list|,
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|CALLOUT_STOP
argument_list|(
operator|&
name|cl
operator|->
name|callout_
argument_list|)
expr_stmt|;
name|cl
operator|->
name|sleeping_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|top
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|&&
name|TV_LT
argument_list|(
name|now
argument_list|,
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|cl
operator|=
name|cl
operator|->
name|borrow_
operator|)
operator|==
name|NULL
operator|)
operator|||
operator|(
name|cl
operator|->
name|depth_
operator|>
name|ifd
operator|->
name|cutoff_
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ADJUST_CUTOFF
if|if
condition|(
name|cl
operator|!=
name|NULL
condition|)
comment|/* cutoff is taking effect, just 				   return false without calling 				   the delay action. */
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BORROW_OFFTIME
comment|/* 			 * check if the class can borrow offtime too. 			 * borrow offtime from the top of the borrow 			 * chain if the top class is not overloaded. 			 */
if|if
condition|(
name|cl
operator|!=
name|NULL
condition|)
block|{
comment|/* cutoff is taking effect, use this class as top. */
name|top
operator|=
name|cl
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_under_limit
argument_list|,
literal|'ffou'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|top
operator|!=
name|NULL
operator|&&
name|top
operator|->
name|avgidle_
operator|==
name|top
operator|->
name|minidle_
condition|)
name|top
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|overtime_
operator|=
operator|*
name|now
expr_stmt|;
call|(
name|p
operator|->
name|overlimit
call|)
argument_list|(
name|p
argument_list|,
name|top
argument_list|)
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|overtime_
operator|=
operator|*
name|now
expr_stmt|;
call|(
name|p
operator|->
name|overlimit
call|)
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|top
operator|=
name|cl
expr_stmt|;
block|}
if|if
condition|(
name|cl
operator|!=
name|p
condition|)
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|cl
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * _rmc_wrr_dequeue_next() - This is scheduler for WRR as opposed to  *	Packet-by-packet round robin.  *  * The heart of the weighted round-robin scheduler, which decides which  * class next gets to send a packet.  Highest priority first, then  * weighted round-robin within priorites.  *  * Each able-to-send class gets to send until its byte allocation is  * exhausted.  Thus, the active pointer is only changed after a class has  * exhausted its allocation.  *  * If the scheduler finds no class that is underlimit or able to borrow,  * then the first class found that had a nonzero queue and is allowed to  * borrow gets to send.  */
end_comment

begin_function
specifier|static
name|mbuf_t
modifier|*
name|_rmc_wrr_dequeue_next
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|struct
name|rm_class
modifier|*
name|cl
init|=
name|NULL
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
name|u_int
name|deficit
decl_stmt|;
name|int
name|cpri
decl_stmt|;
name|mbuf_t
modifier|*
name|m
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|RM_GETTIME
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * if the driver polls the top of the queue and then removes 	 * the polled packet, we must return the same packet. 	 */
if|if
condition|(
name|op
operator|==
name|ALTDQ_REMOVE
operator|&&
name|ifd
operator|->
name|pollcache_
condition|)
block|{
name|cl
operator|=
name|ifd
operator|->
name|pollcache_
expr_stmt|;
name|cpri
operator|=
name|cl
operator|->
name|pri_
expr_stmt|;
if|if
condition|(
name|ifd
operator|->
name|efficient_
condition|)
block|{
comment|/* check if this class is overlimit */
if|if
condition|(
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|!=
literal|0
operator|&&
name|rmc_under_limit
argument_list|(
name|cl
argument_list|,
operator|&
name|now
argument_list|)
operator|==
literal|0
condition|)
name|first
operator|=
name|cl
expr_stmt|;
block|}
name|ifd
operator|->
name|pollcache_
operator|=
name|NULL
expr_stmt|;
goto|goto
name|_wrr_out
goto|;
block|}
else|else
block|{
comment|/* mode == ALTDQ_POLL || pollcache == NULL */
name|ifd
operator|->
name|pollcache_
operator|=
name|NULL
expr_stmt|;
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_CUTOFF
name|_again
label|:
endif|#
directive|endif
for|for
control|(
name|cpri
operator|=
name|RM_MAXPRIO
operator|-
literal|1
init|;
name|cpri
operator|>=
literal|0
condition|;
name|cpri
operator|--
control|)
block|{
if|if
condition|(
name|ifd
operator|->
name|na_
index|[
name|cpri
index|]
operator|==
literal|0
condition|)
continue|continue;
name|deficit
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Loop through twice for a priority level, if some class 		 * was unable to send a packet the first round because 		 * of the weighted round-robin mechanism. 		 * During the second loop at this level, deficit==2. 		 * (This second loop is not needed if for every class, 		 * "M[cl->pri_])" times "cl->allotment" is greater than 		 * the byte size for the largest packet in the class.) 		 */
name|_wrr_loop
label|:
name|cl
operator|=
name|ifd
operator|->
name|active_
index|[
name|cpri
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|deficit
operator|<
literal|2
operator|)
operator|&&
operator|(
name|cl
operator|->
name|bytes_alloc_
operator|<=
literal|0
operator|)
condition|)
name|cl
operator|->
name|bytes_alloc_
operator|+=
name|cl
operator|->
name|w_allotment_
expr_stmt|;
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|==
literal|0
operator|)
operator|||
name|rmc_under_limit
argument_list|(
name|cl
argument_list|,
operator|&
name|now
argument_list|)
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|bytes_alloc_
operator|>
literal|0
operator|||
name|deficit
operator|>
literal|1
condition|)
goto|goto
name|_wrr_out
goto|;
comment|/* underlimit but no alloc */
name|deficit
operator|=
literal|1
expr_stmt|;
if|#
directive|if
literal|1
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|first
operator|==
name|NULL
operator|&&
name|cl
operator|->
name|borrow_
operator|!=
name|NULL
condition|)
name|first
operator|=
name|cl
expr_stmt|;
comment|/* borrowing candidate */
block|}
name|cl
operator|->
name|bytes_alloc_
operator|=
literal|0
expr_stmt|;
name|cl
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
block|}
do|while
condition|(
name|cl
operator|!=
name|ifd
operator|->
name|active_
index|[
name|cpri
index|]
condition|)
do|;
if|if
condition|(
name|deficit
operator|==
literal|1
condition|)
block|{
comment|/* first loop found an underlimit class with deficit */
comment|/* Loop on same priority level, with new deficit.  */
name|deficit
operator|=
literal|2
expr_stmt|;
goto|goto
name|_wrr_loop
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|ADJUST_CUTOFF
comment|/* 	 * no underlimit class found.  if cutoff is taking effect, 	 * increase cutoff and try again. 	 */
if|if
condition|(
name|first
operator|!=
name|NULL
operator|&&
name|ifd
operator|->
name|cutoff_
operator|<
name|ifd
operator|->
name|root_
operator|->
name|depth_
condition|)
block|{
name|ifd
operator|->
name|cutoff_
operator|++
expr_stmt|;
name|CBQTRACE
argument_list|(
name|_rmc_wrr_dequeue_next
argument_list|,
literal|'ojda'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
goto|goto
name|_again
goto|;
block|}
endif|#
directive|endif
comment|/* ADJUST_CUTOFF */
comment|/* 	 * If LINK_EFFICIENCY is turned on, then the first overlimit 	 * class we encounter will send a packet if all the classes 	 * of the link-sharing structure are overlimit. 	 */
name|reset_cutoff
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|CBQTRACE
argument_list|(
name|_rmc_wrr_dequeue_next
argument_list|,
literal|'otsr'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifd
operator|->
name|efficient_
operator|||
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cl
operator|=
name|first
expr_stmt|;
name|cpri
operator|=
name|cl
operator|->
name|pri_
expr_stmt|;
if|#
directive|if
literal|0
comment|/* too time-consuming for nothing */
block|if (cl->sleeping_) 		CALLOUT_STOP(&cl->callout_); 	cl->sleeping_ = 0; 	cl->undertime_.tv_sec = 0;
endif|#
directive|endif
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|cl
operator|->
name|borrow_
expr_stmt|;
name|ifd
operator|->
name|cutoff_
operator|=
name|cl
operator|->
name|borrow_
operator|->
name|depth_
expr_stmt|;
comment|/* 	 * Deque the packet and do the book keeping... 	 */
name|_wrr_out
label|:
if|if
condition|(
name|op
operator|==
name|ALTDQ_REMOVE
condition|)
block|{
name|m
operator|=
name|_rmc_getq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"_rmc_wrr_dequeue_next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
name|ifd
operator|->
name|na_
index|[
name|cpri
index|]
operator|--
expr_stmt|;
comment|/* 		 * Update class statistics and link data. 		 */
if|if
condition|(
name|cl
operator|->
name|bytes_alloc_
operator|>
literal|0
condition|)
name|cl
operator|->
name|bytes_alloc_
operator|-=
name|m_pktlen
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cl
operator|->
name|bytes_alloc_
operator|<=
literal|0
operator|)
operator|||
name|first
operator|==
name|cl
condition|)
name|ifd
operator|->
name|active_
index|[
name|cl
operator|->
name|pri_
index|]
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
else|else
name|ifd
operator|->
name|active_
index|[
name|cl
operator|->
name|pri_
index|]
operator|=
name|cl
expr_stmt|;
name|ifd
operator|->
name|class_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|cl
expr_stmt|;
name|ifd
operator|->
name|curlen_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|m_pktlen
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|now_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|now
expr_stmt|;
name|ifd
operator|->
name|qi_
operator|=
operator|(
name|ifd
operator|->
name|qi_
operator|+
literal|1
operator|)
operator|%
name|ifd
operator|->
name|maxqueued_
expr_stmt|;
name|ifd
operator|->
name|queued_
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* mode == ALTDQ_PPOLL */
name|m
operator|=
name|_rmc_pollq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|pollcache_
operator|=
name|cl
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dequeue& return next packet from the highest priority class that  * has a packet to send& has enough allocation to send it.  This  * routine is called by a driver whenever it needs a new packet to  * output.  */
end_comment

begin_function
specifier|static
name|mbuf_t
modifier|*
name|_rmc_prr_dequeue_next
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m
decl_stmt|;
name|int
name|cpri
decl_stmt|;
name|struct
name|rm_class
modifier|*
name|cl
decl_stmt|,
modifier|*
name|first
init|=
name|NULL
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|RM_GETTIME
argument_list|(
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * if the driver polls the top of the queue and then removes 	 * the polled packet, we must return the same packet. 	 */
if|if
condition|(
name|op
operator|==
name|ALTDQ_REMOVE
operator|&&
name|ifd
operator|->
name|pollcache_
condition|)
block|{
name|cl
operator|=
name|ifd
operator|->
name|pollcache_
expr_stmt|;
name|cpri
operator|=
name|cl
operator|->
name|pri_
expr_stmt|;
name|ifd
operator|->
name|pollcache_
operator|=
name|NULL
expr_stmt|;
goto|goto
name|_prr_out
goto|;
block|}
else|else
block|{
comment|/* mode == ALTDQ_POLL || pollcache == NULL */
name|ifd
operator|->
name|pollcache_
operator|=
name|NULL
expr_stmt|;
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_CUTOFF
name|_again
label|:
endif|#
directive|endif
for|for
control|(
name|cpri
operator|=
name|RM_MAXPRIO
operator|-
literal|1
init|;
name|cpri
operator|>=
literal|0
condition|;
name|cpri
operator|--
control|)
block|{
if|if
condition|(
name|ifd
operator|->
name|na_
index|[
name|cpri
index|]
operator|==
literal|0
condition|)
continue|continue;
name|cl
operator|=
name|ifd
operator|->
name|active_
index|[
name|cpri
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|==
literal|0
operator|)
operator|||
name|rmc_under_limit
argument_list|(
name|cl
argument_list|,
operator|&
name|now
argument_list|)
condition|)
goto|goto
name|_prr_out
goto|;
if|if
condition|(
name|first
operator|==
name|NULL
operator|&&
name|cl
operator|->
name|borrow_
operator|!=
name|NULL
condition|)
name|first
operator|=
name|cl
expr_stmt|;
block|}
name|cl
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
block|}
do|while
condition|(
name|cl
operator|!=
name|ifd
operator|->
name|active_
index|[
name|cpri
index|]
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|ADJUST_CUTOFF
comment|/* 	 * no underlimit class found.  if cutoff is taking effect, increase 	 * cutoff and try again. 	 */
if|if
condition|(
name|first
operator|!=
name|NULL
operator|&&
name|ifd
operator|->
name|cutoff_
operator|<
name|ifd
operator|->
name|root_
operator|->
name|depth_
condition|)
block|{
name|ifd
operator|->
name|cutoff_
operator|++
expr_stmt|;
goto|goto
name|_again
goto|;
block|}
endif|#
directive|endif
comment|/* ADJUST_CUTOFF */
comment|/* 	 * If LINK_EFFICIENCY is turned on, then the first overlimit 	 * class we encounter will send a packet if all the classes 	 * of the link-sharing structure are overlimit. 	 */
name|reset_cutoff
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ifd
operator|->
name|efficient_
operator|||
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cl
operator|=
name|first
expr_stmt|;
name|cpri
operator|=
name|cl
operator|->
name|pri_
expr_stmt|;
if|#
directive|if
literal|0
comment|/* too time-consuming for nothing */
block|if (cl->sleeping_) 		CALLOUT_STOP(&cl->callout_); 	cl->sleeping_ = 0; 	cl->undertime_.tv_sec = 0;
endif|#
directive|endif
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|cl
operator|->
name|borrow_
expr_stmt|;
name|ifd
operator|->
name|cutoff_
operator|=
name|cl
operator|->
name|borrow_
operator|->
name|depth_
expr_stmt|;
comment|/* 	 * Deque the packet and do the book keeping... 	 */
name|_prr_out
label|:
if|if
condition|(
name|op
operator|==
name|ALTDQ_REMOVE
condition|)
block|{
name|m
operator|=
name|_rmc_getq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"_rmc_prr_dequeue_next"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
name|ifd
operator|->
name|na_
index|[
name|cpri
index|]
operator|--
expr_stmt|;
name|ifd
operator|->
name|active_
index|[
name|cpri
index|]
operator|=
name|cl
operator|->
name|peer_
expr_stmt|;
name|ifd
operator|->
name|class_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|cl
expr_stmt|;
name|ifd
operator|->
name|curlen_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|m_pktlen
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|now_
index|[
name|ifd
operator|->
name|qi_
index|]
operator|=
name|now
expr_stmt|;
name|ifd
operator|->
name|qi_
operator|=
operator|(
name|ifd
operator|->
name|qi_
operator|+
literal|1
operator|)
operator|%
name|ifd
operator|->
name|maxqueued_
expr_stmt|;
name|ifd
operator|->
name|queued_
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* mode == ALTDQ_POLL */
name|m
operator|=
name|_rmc_pollq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|pollcache_
operator|=
name|cl
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mbuf_t *  * rmc_dequeue_next(struct rm_ifdat *ifd, struct timeval *now) - this function  *	is invoked by the packet driver to get the next packet to be  *	dequeued and output on the link.  If WRR is enabled, then the  *	WRR dequeue next routine will determine the next packet to sent.  *	Otherwise, packet-by-packet round robin is invoked.  *  *	Returns:	NULL, if a packet is not available or if all  *			classes are overlimit.  *  *			Otherwise, Pointer to the next packet.  */
end_comment

begin_function
name|mbuf_t
modifier|*
name|rmc_dequeue_next
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|ifd
operator|->
name|queued_
operator|>=
name|ifd
operator|->
name|maxqueued_
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
elseif|else
if|if
condition|(
name|ifd
operator|->
name|wrr_
condition|)
return|return
operator|(
name|_rmc_wrr_dequeue_next
argument_list|(
name|ifd
argument_list|,
name|mode
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|_rmc_prr_dequeue_next
argument_list|(
name|ifd
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update the utilization estimate for the packet that just completed.  * The packet's class& the parent(s) of that class all get their  * estimators updated.  This routine is called by the driver's output-  * packet-completion interrupt service routine.  */
end_comment

begin_comment
comment|/*  * a macro to approximate "divide by 1000" that gives 0.000999,  * if a value has enough effective digits.  * (on pentium, mul takes 9 cycles but div takes 46!)  */
end_comment

begin_define
define|#
directive|define
name|NSEC_TO_USEC
parameter_list|(
name|t
parameter_list|)
value|(((t)>> 10) + ((t)>> 16) + ((t)>> 17))
end_define

begin_function
name|void
name|rmc_update_class_util
parameter_list|(
name|struct
name|rm_ifdat
modifier|*
name|ifd
parameter_list|)
block|{
name|int
name|idle
decl_stmt|,
name|avgidle
decl_stmt|,
name|pktlen
decl_stmt|;
name|int
name|pkt_time
decl_stmt|,
name|tidle
decl_stmt|;
name|rm_class_t
modifier|*
name|cl
decl_stmt|,
modifier|*
name|borrowed
decl_stmt|;
name|rm_class_t
modifier|*
name|borrows
decl_stmt|;
name|struct
name|timeval
modifier|*
name|nowp
decl_stmt|;
comment|/* 	 * Get the most recent completed class. 	 */
if|if
condition|(
operator|(
name|cl
operator|=
name|ifd
operator|->
name|class_
index|[
name|ifd
operator|->
name|qo_
index|]
operator|)
operator|==
name|NULL
condition|)
return|return;
name|pktlen
operator|=
name|ifd
operator|->
name|curlen_
index|[
name|ifd
operator|->
name|qo_
index|]
expr_stmt|;
name|borrowed
operator|=
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qo_
index|]
expr_stmt|;
name|borrows
operator|=
name|borrowed
expr_stmt|;
name|PKTCNTR_ADD
argument_list|(
operator|&
name|cl
operator|->
name|stats_
operator|.
name|xmit_cnt
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
comment|/* 	 * Run estimator on class and its ancestors. 	 */
comment|/* 	 * rm_update_class_util is designed to be called when the 	 * transfer is completed from a xmit complete interrupt, 	 * but most drivers don't implement an upcall for that. 	 * so, just use estimated completion time. 	 * as a result, ifd->qi_ and ifd->qo_ are always synced. 	 */
name|nowp
operator|=
operator|&
name|ifd
operator|->
name|now_
index|[
name|ifd
operator|->
name|qo_
index|]
expr_stmt|;
comment|/* get pkt_time (for link) in usec */
if|#
directive|if
literal|1
comment|/* use approximation */
name|pkt_time
operator|=
name|ifd
operator|->
name|curlen_
index|[
name|ifd
operator|->
name|qo_
index|]
operator|*
name|ifd
operator|->
name|ns_per_byte_
expr_stmt|;
name|pkt_time
operator|=
name|NSEC_TO_USEC
argument_list|(
name|pkt_time
argument_list|)
expr_stmt|;
else|#
directive|else
name|pkt_time
operator|=
name|ifd
operator|->
name|curlen_
index|[
name|ifd
operator|->
name|qo_
index|]
operator|*
name|ifd
operator|->
name|ns_per_byte_
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
literal|1
comment|/* ALTQ4PPP */
if|if
condition|(
name|TV_LT
argument_list|(
name|nowp
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
condition|)
block|{
name|int
name|iftime
decl_stmt|;
comment|/* 		 * make sure the estimated completion time does not go 		 * too far.  it can happen when the link layer supports 		 * data compression or the interface speed is set to 		 * a much lower value. 		 */
name|TV_DELTA
argument_list|(
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|,
name|nowp
argument_list|,
name|iftime
argument_list|)
expr_stmt|;
if|if
condition|(
name|iftime
operator|+
name|pkt_time
operator|<
name|ifd
operator|->
name|maxiftime_
condition|)
block|{
name|TV_ADD_DELTA
argument_list|(
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|,
name|pkt_time
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TV_ADD_DELTA
argument_list|(
name|nowp
argument_list|,
name|ifd
operator|->
name|maxiftime_
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|TV_ADD_DELTA
argument_list|(
name|nowp
argument_list|,
name|pkt_time
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|TV_LT
argument_list|(
name|nowp
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
condition|)
block|{
name|TV_ADD_DELTA
argument_list|(
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|,
name|pkt_time
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|TV_ADD_DELTA
argument_list|(
name|nowp
argument_list|,
name|pkt_time
argument_list|,
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
name|cl
operator|!=
name|NULL
condition|)
block|{
name|TV_DELTA
argument_list|(
operator|&
name|ifd
operator|->
name|ifnow_
argument_list|,
operator|&
name|cl
operator|->
name|last_
argument_list|,
name|idle
argument_list|)
expr_stmt|;
if|if
condition|(
name|idle
operator|>=
literal|2000000
condition|)
comment|/* 			 * this class is idle enough, reset avgidle. 			 * (TV_DELTA returns 2000000 us when delta is large.) 			 */
name|cl
operator|->
name|avgidle_
operator|=
name|cl
operator|->
name|maxidle_
expr_stmt|;
comment|/* get pkt_time (for class) in usec */
if|#
directive|if
literal|1
comment|/* use approximation */
name|pkt_time
operator|=
name|pktlen
operator|*
name|cl
operator|->
name|ns_per_byte_
expr_stmt|;
name|pkt_time
operator|=
name|NSEC_TO_USEC
argument_list|(
name|pkt_time
argument_list|)
expr_stmt|;
else|#
directive|else
name|pkt_time
operator|=
name|pktlen
operator|*
name|cl
operator|->
name|ns_per_byte_
operator|/
literal|1000
expr_stmt|;
endif|#
directive|endif
name|idle
operator|-=
name|pkt_time
expr_stmt|;
name|avgidle
operator|=
name|cl
operator|->
name|avgidle_
expr_stmt|;
name|avgidle
operator|+=
name|idle
operator|-
operator|(
name|avgidle
operator|>>
name|RM_FILTER_GAIN
operator|)
expr_stmt|;
name|cl
operator|->
name|avgidle_
operator|=
name|avgidle
expr_stmt|;
comment|/* Are we overlimit ? */
if|if
condition|(
name|avgidle
operator|<=
literal|0
condition|)
block|{
name|CBQTRACE
argument_list|(
name|rmc_update_class_util
argument_list|,
literal|'milo'
argument_list|,
name|cl
operator|->
name|stats_
operator|.
name|handle
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
comment|/* ALTQ */
comment|/* 			 * need some lower bound for avgidle, otherwise 			 * a borrowing class gets unbounded penalty. 			 */
if|if
condition|(
name|avgidle
operator|<
name|cl
operator|->
name|minidle_
condition|)
name|avgidle
operator|=
name|cl
operator|->
name|avgidle_
operator|=
name|cl
operator|->
name|minidle_
expr_stmt|;
endif|#
directive|endif
comment|/* set next idle to make avgidle 0 */
name|tidle
operator|=
name|pkt_time
operator|+
operator|(
operator|(
operator|(
literal|1
operator|-
name|RM_POWER
operator|)
operator|*
name|avgidle
operator|)
operator|>>
name|RM_FILTER_GAIN
operator|)
expr_stmt|;
name|TV_ADD_DELTA
argument_list|(
name|nowp
argument_list|,
name|tidle
argument_list|,
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
expr_stmt|;
operator|++
name|cl
operator|->
name|stats_
operator|.
name|over
expr_stmt|;
block|}
else|else
block|{
name|cl
operator|->
name|avgidle_
operator|=
operator|(
name|avgidle
operator|>
name|cl
operator|->
name|maxidle_
operator|)
condition|?
name|cl
operator|->
name|maxidle_
else|:
name|avgidle
expr_stmt|;
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|sleeping_
condition|)
block|{
name|CALLOUT_STOP
argument_list|(
operator|&
name|cl
operator|->
name|callout_
argument_list|)
expr_stmt|;
name|cl
operator|->
name|sleeping_
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|borrows
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|borrows
operator|!=
name|cl
condition|)
operator|++
name|cl
operator|->
name|stats_
operator|.
name|borrows
expr_stmt|;
else|else
name|borrows
operator|=
name|NULL
expr_stmt|;
block|}
name|cl
operator|->
name|last_
operator|=
name|ifd
operator|->
name|ifnow_
expr_stmt|;
name|cl
operator|->
name|last_pkttime_
operator|=
name|pkt_time
expr_stmt|;
if|#
directive|if
literal|1
if|if
condition|(
name|cl
operator|->
name|parent_
operator|==
name|NULL
condition|)
block|{
comment|/* take stats of root class */
name|PKTCNTR_ADD
argument_list|(
operator|&
name|cl
operator|->
name|stats_
operator|.
name|xmit_cnt
argument_list|,
name|pktlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|cl
operator|=
name|cl
operator|->
name|parent_
expr_stmt|;
block|}
comment|/* 	 * Check to see if cutoff needs to set to a new level. 	 */
name|cl
operator|=
name|ifd
operator|->
name|class_
index|[
name|ifd
operator|->
name|qo_
index|]
expr_stmt|;
if|if
condition|(
name|borrowed
operator|&&
operator|(
name|ifd
operator|->
name|cutoff_
operator|>=
name|borrowed
operator|->
name|depth_
operator|)
condition|)
block|{
if|#
directive|if
literal|1
comment|/* ALTQ */
if|if
condition|(
operator|(
name|qlen
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|<=
literal|0
operator|)
operator|||
name|TV_LT
argument_list|(
name|nowp
argument_list|,
operator|&
name|borrowed
operator|->
name|undertime_
argument_list|)
condition|)
block|{
name|rmc_tl_satisfied
argument_list|(
name|ifd
argument_list|,
name|nowp
argument_list|)
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_update_class_util
argument_list|,
literal|'broe'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifd
operator|->
name|cutoff_
operator|=
name|borrowed
operator|->
name|depth_
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_update_class_util
argument_list|,
literal|'ffob'
argument_list|,
name|borrowed
operator|->
name|depth_
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* !ALTQ */
if|if
condition|(
operator|(
name|qlen
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|<=
literal|1
operator|)
operator|||
name|TV_LT
argument_list|(
operator|&
name|now
argument_list|,
operator|&
name|borrowed
operator|->
name|undertime_
argument_list|)
condition|)
block|{
name|reset_cutoff
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|rmc_tl_satisfied
argument_list|(
name|ifd
argument_list|,
operator|&
name|now
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CBQTRACE
argument_list|(
name|rmc_update_class_util
argument_list|,
literal|'broe'
argument_list|,
name|ifd
operator|->
name|cutoff_
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ifd
operator|->
name|cutoff_
operator|=
name|borrowed
operator|->
name|depth_
expr_stmt|;
name|CBQTRACE
argument_list|(
name|rmc_update_class_util
argument_list|,
literal|'ffob'
argument_list|,
name|borrowed
operator|->
name|depth_
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !ALTQ */
block|}
comment|/* 	 * Release class slot 	 */
name|ifd
operator|->
name|borrowed_
index|[
name|ifd
operator|->
name|qo_
index|]
operator|=
name|NULL
expr_stmt|;
name|ifd
operator|->
name|class_
index|[
name|ifd
operator|->
name|qo_
index|]
operator|=
name|NULL
expr_stmt|;
name|ifd
operator|->
name|qo_
operator|=
operator|(
name|ifd
operator|->
name|qo_
operator|+
literal|1
operator|)
operator|%
name|ifd
operator|->
name|maxqueued_
expr_stmt|;
name|ifd
operator|->
name|queued_
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * void  * rmc_drop_action(struct rm_class *cl) - Generic (not protocol-specific)  *	over-limit action routines.  These get invoked by rmc_under_limit()  *	if a class with packets to send if over its bandwidth limit& can't  *	borrow from a parent class.  *  *	Returns: NONE  */
end_comment

begin_function
specifier|static
name|void
name|rmc_drop_action
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|rm_ifdat
modifier|*
name|ifd
init|=
name|cl
operator|->
name|ifdat_
decl_stmt|;
name|ASSERT
argument_list|(
name|qlen
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|>
literal|0
argument_list|)
expr_stmt|;
name|_rmc_dropq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
name|ifd
operator|->
name|na_
index|[
name|cl
operator|->
name|pri_
index|]
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rmc_dropall
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|rm_ifdat
modifier|*
name|ifd
init|=
name|cl
operator|->
name|ifdat_
decl_stmt|;
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
block|{
name|_flushq
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
expr_stmt|;
name|ifd
operator|->
name|na_
index|[
name|cl
operator|->
name|pri_
index|]
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|300000
operator|)
end_if

begin_comment
comment|/* hzto() is removed from FreeBSD-3.0 */
end_comment

begin_function_decl
specifier|static
name|int
name|hzto
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|hzto
parameter_list|(
name|tv
parameter_list|)
name|struct
name|timeval
modifier|*
name|tv
decl_stmt|;
block|{
name|struct
name|timeval
name|t2
decl_stmt|;
name|getmicrotime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
name|t2
operator|.
name|tv_sec
operator|=
name|tv
operator|->
name|tv_sec
operator|-
name|t2
operator|.
name|tv_sec
expr_stmt|;
name|t2
operator|.
name|tv_usec
operator|=
name|tv
operator|->
name|tv_usec
operator|-
name|t2
operator|.
name|tv_usec
expr_stmt|;
return|return
operator|(
name|tvtohz
argument_list|(
operator|&
name|t2
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD_version> 300000 */
end_comment

begin_comment
comment|/*  * void  * rmc_delay_action(struct rm_class *cl) - This function is the generic CBQ  *	delay action routine.  It is invoked via rmc_under_limit when the  *	packet is discoverd to be overlimit.  *  *	If the delay action is result of borrow class being overlimit, then  *	delay for the offtime of the borrowing class that is overlimit.  *  *	Returns: NONE  */
end_comment

begin_function
name|void
name|rmc_delay_action
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|,
name|struct
name|rm_class
modifier|*
name|borrow
parameter_list|)
block|{
name|int
name|delay
decl_stmt|,
name|t
decl_stmt|,
name|extradelay
decl_stmt|;
name|cl
operator|->
name|stats_
operator|.
name|overactions
operator|++
expr_stmt|;
name|TV_DELTA
argument_list|(
operator|&
name|cl
operator|->
name|undertime_
argument_list|,
operator|&
name|cl
operator|->
name|overtime_
argument_list|,
name|delay
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BORROW_OFFTIME
name|delay
operator|+=
name|cl
operator|->
name|offtime_
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cl
operator|->
name|sleeping_
condition|)
block|{
name|CBQTRACE
argument_list|(
name|rmc_delay_action
argument_list|,
literal|'yled'
argument_list|,
name|cl
operator|->
name|stats_
operator|.
name|handle
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BORROW_OFFTIME
if|if
condition|(
name|borrow
operator|!=
name|NULL
condition|)
name|extradelay
operator|=
name|borrow
operator|->
name|offtime_
expr_stmt|;
else|else
endif|#
directive|endif
name|extradelay
operator|=
name|cl
operator|->
name|offtime_
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ
comment|/* 		 * XXX recalculate suspend time: 		 * current undertime is (tidle + pkt_time) calculated 		 * from the last transmission. 		 *	tidle: time required to bring avgidle back to 0 		 *	pkt_time: target waiting time for this class 		 * we need to replace pkt_time by offtime 		 */
name|extradelay
operator|-=
name|cl
operator|->
name|last_pkttime_
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|extradelay
operator|>
literal|0
condition|)
block|{
name|TV_ADD_DELTA
argument_list|(
operator|&
name|cl
operator|->
name|undertime_
argument_list|,
name|extradelay
argument_list|,
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
expr_stmt|;
name|delay
operator|+=
name|extradelay
expr_stmt|;
block|}
name|cl
operator|->
name|sleeping_
operator|=
literal|1
expr_stmt|;
name|cl
operator|->
name|stats_
operator|.
name|delays
operator|++
expr_stmt|;
comment|/* 		 * Since packets are phased randomly with respect to the 		 * clock, 1 tick (the next clock tick) can be an arbitrarily 		 * short time so we have to wait for at least two ticks. 		 * NOTE:  If there's no other traffic, we need the timer as 		 * a 'backstop' to restart this class. 		 */
if|if
condition|(
name|delay
operator|>
name|tick
operator|*
literal|2
condition|)
block|{
ifdef|#
directive|ifdef
name|__FreeBSD__
comment|/* FreeBSD rounds up the tick */
name|t
operator|=
name|hzto
argument_list|(
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* other BSDs round down the tick */
name|t
operator|=
name|hzto
argument_list|(
operator|&
name|cl
operator|->
name|undertime_
argument_list|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|t
operator|=
literal|2
expr_stmt|;
name|CALLOUT_RESET
argument_list|(
operator|&
name|cl
operator|->
name|callout_
argument_list|,
name|t
argument_list|,
operator|(
name|timeout_t
operator|*
operator|)
name|rmc_restart
argument_list|,
operator|(
name|caddr_t
operator|)
name|cl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * void  * rmc_restart() - is just a helper routine for rmc_delay_action -- it is  *	called by the system timer code& is responsible checking if the  *	class is still sleeping (it might have been restarted as a side  *	effect of the queue scan on a packet arrival) and, if so, restarting  *	output for the class.  Inspecting the class state& restarting output  *	require locking the class structure.  In general the driver is  *	responsible for locking but this is the only routine that is not  *	called directly or indirectly from the interface driver so it has  *	know about system locking conventions.  Under bsd, locking is done  *	by raising IPL to splimp so that's what's implemented here.  On a  *	different system this would probably need to be changed.  *  *	Returns:	NONE  */
end_comment

begin_function
specifier|static
name|void
name|rmc_restart
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|rm_ifdat
modifier|*
name|ifd
init|=
name|cl
operator|->
name|ifdat_
decl_stmt|;
name|int
name|s
decl_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|sleeping_
condition|)
block|{
name|cl
operator|->
name|sleeping_
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|undertime_
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ifd
operator|->
name|queued_
operator|<
name|ifd
operator|->
name|maxqueued_
operator|&&
name|ifd
operator|->
name|restart
operator|!=
name|NULL
condition|)
block|{
name|CBQTRACE
argument_list|(
name|rmc_restart
argument_list|,
literal|'trts'
argument_list|,
name|cl
operator|->
name|stats_
operator|.
name|handle
argument_list|)
expr_stmt|;
call|(
name|ifd
operator|->
name|restart
call|)
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
block|}
block|}
name|IFQ_UNLOCK
argument_list|(
name|ifd
operator|->
name|ifq_
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * void  * rmc_root_overlimit(struct rm_class *cl) - This the generic overlimit  *	handling routine for the root class of the link sharing structure.  *  *	Returns: NONE  */
end_comment

begin_function
specifier|static
name|void
name|rmc_root_overlimit
parameter_list|(
name|struct
name|rm_class
modifier|*
name|cl
parameter_list|,
name|struct
name|rm_class
modifier|*
name|borrow
parameter_list|)
block|{
name|panic
argument_list|(
literal|"rmc_root_overlimit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Packet Queue handling routines.  Eventually, this is to localize the  *	effects on the code whether queues are red queues or droptail  *	queues.  */
end_comment

begin_function
specifier|static
name|int
name|_rmc_addq
parameter_list|(
name|rm_class_t
modifier|*
name|cl
parameter_list|,
name|mbuf_t
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
return|return
name|rio_addq
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|red_
argument_list|,
name|cl
operator|->
name|q_
argument_list|,
name|m
argument_list|,
name|cl
operator|->
name|pktattr_
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
return|return
name|red_addq
argument_list|(
name|cl
operator|->
name|red_
argument_list|,
name|cl
operator|->
name|q_
argument_list|,
name|m
argument_list|,
name|cl
operator|->
name|pktattr_
argument_list|)
return|;
endif|#
directive|endif
comment|/* ALTQ_RED */
if|if
condition|(
name|cl
operator|->
name|flags_
operator|&
name|RMCF_CLEARDSCP
condition|)
name|write_dsfield
argument_list|(
name|m
argument_list|,
name|cl
operator|->
name|pktattr_
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_addq
argument_list|(
name|cl
operator|->
name|q_
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* note: _rmc_dropq is not called for red */
end_comment

begin_function
specifier|static
name|void
name|_rmc_dropq
parameter_list|(
name|rm_class_t
modifier|*
name|cl
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|_getq
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|mbuf_t
modifier|*
name|_rmc_getq
parameter_list|(
name|rm_class_t
modifier|*
name|cl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
return|return
name|rio_getq
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|red_
argument_list|,
name|cl
operator|->
name|q_
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
condition|)
return|return
name|red_getq
argument_list|(
name|cl
operator|->
name|red_
argument_list|,
name|cl
operator|->
name|q_
argument_list|)
return|;
endif|#
directive|endif
return|return
name|_getq
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|mbuf_t
modifier|*
name|_rmc_pollq
parameter_list|(
name|rm_class_t
modifier|*
name|cl
parameter_list|)
block|{
return|return
name|qhead
argument_list|(
name|cl
operator|->
name|q_
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CBQ_TRACE
end_ifdef

begin_decl_stmt
name|struct
name|cbqtrace
name|cbqtrace_buffer
index|[
name|NCBQTRACE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|cbqtrace
modifier|*
name|cbqtrace_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cbqtrace_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * DDB hook to trace cbq events:  *  the last 1024 events are held in a circular buffer.  *  use "call cbqtrace_dump(N)" to display 20 events from Nth event.  */
end_comment

begin_function_decl
name|void
name|cbqtrace_dump
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|rmc_funcname
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
name|rmc_funcs
block|{
name|void
modifier|*
name|func
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
name|rmc_funcs
index|[]
init|=
block|{
name|rmc_init
block|,
literal|"rmc_init"
block|,
name|rmc_queue_packet
block|,
literal|"rmc_queue_packet"
block|,
name|rmc_under_limit
block|,
literal|"rmc_under_limit"
block|,
name|rmc_update_class_util
block|,
literal|"rmc_update_class_util"
block|,
name|rmc_delay_action
block|,
literal|"rmc_delay_action"
block|,
name|rmc_restart
block|,
literal|"rmc_restart"
block|,
name|_rmc_wrr_dequeue_next
block|,
literal|"_rmc_wrr_dequeue_next"
block|,
name|NULL
block|,
name|NULL
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|rmc_funcname
parameter_list|(
name|void
modifier|*
name|func
parameter_list|)
block|{
name|struct
name|rmc_funcs
modifier|*
name|fp
decl_stmt|;
for|for
control|(
name|fp
operator|=
name|rmc_funcs
init|;
name|fp
operator|->
name|func
operator|!=
name|NULL
condition|;
name|fp
operator|++
control|)
if|if
condition|(
name|fp
operator|->
name|func
operator|==
name|func
condition|)
return|return
operator|(
name|fp
operator|->
name|name
operator|)
return|;
return|return
operator|(
literal|"unknown"
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cbqtrace_dump
parameter_list|(
name|int
name|counter
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|counter
operator|=
name|counter
operator|%
name|NCBQTRACE
expr_stmt|;
name|p
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|cbqtrace_buffer
index|[
name|counter
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"[0x%x] "
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|rmc_funcname
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|p
operator|++
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|++
expr_stmt|;
name|printf
argument_list|(
literal|"%c%c%c%c: "
argument_list|,
name|cp
index|[
literal|0
index|]
argument_list|,
name|cp
index|[
literal|1
index|]
argument_list|,
name|cp
index|[
literal|2
index|]
argument_list|,
name|cp
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d\n"
argument_list|,
operator|*
name|p
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>=
operator|(
name|int
operator|*
operator|)
operator|&
name|cbqtrace_buffer
index|[
name|NCBQTRACE
index|]
condition|)
name|p
operator|=
operator|(
name|int
operator|*
operator|)
name|cbqtrace_buffer
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CBQ_TRACE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_CBQ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ALTQ_CBQ
argument_list|)
operator|||
name|defined
argument_list|(
name|ALTQ_RED
argument_list|)
operator|||
name|defined
argument_list|(
name|ALTQ_RIO
argument_list|)
operator|||
name|defined
argument_list|(
name|ALTQ_HFSC
argument_list|)
operator|||
name|defined
argument_list|(
name|ALTQ_PRIQ
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|ALTQ_DEBUG
argument_list|)
end_if

begin_function
name|void
name|_addq
parameter_list|(
name|class_queue_t
modifier|*
name|q
parameter_list|,
name|mbuf_t
modifier|*
name|m
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
operator|(
name|m0
operator|=
name|qtail
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m
operator|->
name|m_nextpkt
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
else|else
name|m0
operator|=
name|m
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|m
expr_stmt|;
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|m
expr_stmt|;
name|qlen
argument_list|(
name|q
argument_list|)
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|mbuf_t
modifier|*
name|_getq
parameter_list|(
name|class_queue_t
modifier|*
name|q
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|qtail
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|m0
operator|=
name|m
operator|->
name|m_nextpkt
operator|)
operator|!=
name|m
condition|)
name|m
operator|->
name|m_nextpkt
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
else|else
block|{
name|ASSERT
argument_list|(
name|qlen
argument_list|(
name|q
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
name|qlen
argument_list|(
name|q
argument_list|)
operator|--
expr_stmt|;
name|m0
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* drop a packet at the tail of the queue */
end_comment

begin_function
name|mbuf_t
modifier|*
name|_getq_tail
parameter_list|(
name|class_queue_t
modifier|*
name|q
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m
decl_stmt|,
modifier|*
name|m0
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|m0
operator|=
name|qtail
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
do|do
block|{
name|prev
operator|=
name|m0
expr_stmt|;
name|m0
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
block|}
do|while
condition|(
name|m0
operator|!=
name|m
condition|)
do|;
name|prev
operator|->
name|m_nextpkt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|m
condition|)
block|{
name|ASSERT
argument_list|(
name|qlen
argument_list|(
name|q
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|prev
expr_stmt|;
name|qlen
argument_list|(
name|q
argument_list|)
operator|--
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/* randomly select a packet in the queue */
end_comment

begin_function
name|mbuf_t
modifier|*
name|_getq_random
parameter_list|(
name|class_queue_t
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|qtail
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|m
operator|->
name|m_nextpkt
operator|==
name|m
condition|)
block|{
name|ASSERT
argument_list|(
name|qlen
argument_list|(
name|q
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|struct
name|mbuf
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|n
operator|=
name|arc4random
argument_list|()
operator|%
name|qlen
argument_list|(
name|q
argument_list|)
operator|+
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|prev
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
block|}
name|prev
operator|->
name|m_nextpkt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|qtail
argument_list|(
name|q
argument_list|)
condition|)
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|prev
expr_stmt|;
block|}
name|qlen
argument_list|(
name|q
argument_list|)
operator|--
expr_stmt|;
name|m
operator|->
name|m_nextpkt
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_removeq
parameter_list|(
name|class_queue_t
modifier|*
name|q
parameter_list|,
name|mbuf_t
modifier|*
name|m
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m0
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|m0
operator|=
name|qtail
argument_list|(
name|q
argument_list|)
expr_stmt|;
do|do
block|{
name|prev
operator|=
name|m0
expr_stmt|;
name|m0
operator|=
name|m0
operator|->
name|m_nextpkt
expr_stmt|;
block|}
do|while
condition|(
name|m0
operator|!=
name|m
condition|)
do|;
name|prev
operator|->
name|m_nextpkt
operator|=
name|m
operator|->
name|m_nextpkt
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|m
condition|)
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|qtail
argument_list|(
name|q
argument_list|)
operator|==
name|m
condition|)
name|qtail
argument_list|(
name|q
argument_list|)
operator|=
name|prev
expr_stmt|;
name|qlen
argument_list|(
name|q
argument_list|)
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_flushq
parameter_list|(
name|class_queue_t
modifier|*
name|q
parameter_list|)
block|{
name|mbuf_t
modifier|*
name|m
decl_stmt|;
while|while
condition|(
operator|(
name|m
operator|=
name|_getq
argument_list|(
name|q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|qlen
argument_list|(
name|q
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !__GNUC__ || ALTQ_DEBUG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_CBQ || ALTQ_RED || ALTQ_RIO || ALTQ_HFSC || ALTQ_PRIQ */
end_comment

end_unit

