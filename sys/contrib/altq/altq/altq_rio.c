begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: altq_rio.c,v 1.17 2003/07/10 12:07:49 kjc Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1998-2003  *	Sony Computer Science Laboratories Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1990-1994 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_altq.h"
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD__
operator|!=
literal|2
operator|)
end_if

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ || __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_RIO
end_ifdef

begin_comment
comment|/* rio is enabled by ALTQ_RIO option in opt_altq.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_cdnr.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_red.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_rio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq_conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * RIO: RED with IN/OUT bit  *   described in  *	"Explicit Allocation of Best Effort Packet Delivery Service"  *	David D. Clark and Wenjia Fang, MIT Lab for Computer Science  *	http://diffserv.lcs.mit.edu/Papers/exp-alloc-ddc-wf.{ps,pdf}  *  * this implementation is extended to support more than 2 drop precedence  * values as described in RFC2597 (Assured Forwarding PHB Group).  *  */
end_comment

begin_comment
comment|/*  * AF DS (differentiated service) codepoints.  * (classes can be mapped to CBQ or H-FSC classes.)  *  *      0   1   2   3   4   5   6   7  *    +---+---+---+---+---+---+---+---+  *    |   CLASS   |DropPre| 0 |  CU   |  *    +---+---+---+---+---+---+---+---+  *  *    class 1: 001  *    class 2: 010  *    class 3: 011  *    class 4: 100  *  *    low drop prec:    01  *    medium drop prec: 10  *    high drop prec:   01  */
end_comment

begin_comment
comment|/* normal red parameters */
end_comment

begin_define
define|#
directive|define
name|W_WEIGHT
value|512
end_define

begin_comment
comment|/* inverse of weight of EWMA (511/512) */
end_comment

begin_comment
comment|/* q_weight = 0.00195 */
end_comment

begin_comment
comment|/* red parameters for a slow link */
end_comment

begin_define
define|#
directive|define
name|W_WEIGHT_1
value|128
end_define

begin_comment
comment|/* inverse of weight of EWMA (127/128) */
end_comment

begin_comment
comment|/* q_weight = 0.0078125 */
end_comment

begin_comment
comment|/* red parameters for a very slow link (e.g., dialup) */
end_comment

begin_define
define|#
directive|define
name|W_WEIGHT_2
value|64
end_define

begin_comment
comment|/* inverse of weight of EWMA (63/64) */
end_comment

begin_comment
comment|/* q_weight = 0.015625 */
end_comment

begin_comment
comment|/* fixed-point uses 12-bit decimal places */
end_comment

begin_define
define|#
directive|define
name|FP_SHIFT
value|12
end_define

begin_comment
comment|/* fixed-point shift */
end_comment

begin_comment
comment|/* red parameters for drop probability */
end_comment

begin_define
define|#
directive|define
name|INV_P_MAX
value|10
end_define

begin_comment
comment|/* inverse of max drop probability */
end_comment

begin_define
define|#
directive|define
name|TH_MIN
value|5
end_define

begin_comment
comment|/* min threshold */
end_comment

begin_define
define|#
directive|define
name|TH_MAX
value|15
end_define

begin_comment
comment|/* max threshold */
end_comment

begin_define
define|#
directive|define
name|RIO_LIMIT
value|60
end_define

begin_comment
comment|/* default max queue lenght */
end_comment

begin_define
define|#
directive|define
name|RIO_STATS
end_define

begin_comment
comment|/* collect statistics */
end_comment

begin_define
define|#
directive|define
name|TV_DELTA
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|delta
parameter_list|)
value|{					\ 	register int	xxs;					\ 								\ 	delta = (a)->tv_usec - (b)->tv_usec; 			\ 	if ((xxs = (a)->tv_sec - (b)->tv_sec) != 0) { 		\ 		if (xxs< 0) { 					\ 			delta = 60000000;			\ 		} else if (xxs> 4)  {				\ 			if (xxs> 60)				\ 				delta = 60000000;		\ 			else					\ 				delta += xxs * 1000000;		\ 		} else while (xxs> 0) {			\ 			delta += 1000000;			\ 			xxs--;					\ 		}						\ 	}							\ }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_comment
comment|/* rio_list keeps all rio_queue_t's allocated. */
end_comment

begin_decl_stmt
specifier|static
name|rio_queue_t
modifier|*
name|rio_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* default rio parameter values */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|redparams
name|default_rio_params
index|[
name|RIO_NDROPPREC
index|]
init|=
block|{
comment|/* th_min,		 th_max,     inv_pmax */
block|{
name|TH_MAX
operator|*
literal|2
operator|+
name|TH_MIN
block|,
name|TH_MAX
operator|*
literal|3
block|,
name|INV_P_MAX
block|}
block|,
comment|/* low drop precedence */
block|{
name|TH_MAX
operator|+
name|TH_MIN
block|,
name|TH_MAX
operator|*
literal|2
block|,
name|INV_P_MAX
block|}
block|,
comment|/* medium drop precedence */
block|{
name|TH_MIN
block|,
name|TH_MAX
block|,
name|INV_P_MAX
block|}
comment|/* high drop precedence */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal function prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|dscp2index
parameter_list|(
name|u_int8_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_function_decl
specifier|static
name|int
name|rio_enqueue
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|rio_dequeue
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rio_request
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rio_detach
parameter_list|(
name|rio_queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * rio device interface  */
end_comment

begin_expr_stmt
name|altqdev_decl
argument_list|(
name|rio
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_function
name|rio_t
modifier|*
name|rio_alloc
parameter_list|(
name|int
name|weight
parameter_list|,
name|struct
name|redparams
modifier|*
name|params
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|pkttime
parameter_list|)
block|{
name|rio_t
modifier|*
name|rp
decl_stmt|;
name|int
name|w
decl_stmt|,
name|i
decl_stmt|;
name|int
name|npkts_per_sec
decl_stmt|;
name|MALLOC
argument_list|(
name|rp
argument_list|,
name|rio_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|rio_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|rio_t
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rio_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|pkttime
operator|==
literal|0
condition|)
comment|/* default packet time: 1000 bytes / 10Mbps * 8 * 1000000 */
name|rp
operator|->
name|rio_pkttime
operator|=
literal|800
expr_stmt|;
else|else
name|rp
operator|->
name|rio_pkttime
operator|=
name|pkttime
expr_stmt|;
if|if
condition|(
name|weight
operator|!=
literal|0
condition|)
name|rp
operator|->
name|rio_weight
operator|=
name|weight
expr_stmt|;
else|else
block|{
comment|/* use default */
name|rp
operator|->
name|rio_weight
operator|=
name|W_WEIGHT
expr_stmt|;
comment|/* when the link is very slow, adjust red parameters */
name|npkts_per_sec
operator|=
literal|1000000
operator|/
name|rp
operator|->
name|rio_pkttime
expr_stmt|;
if|if
condition|(
name|npkts_per_sec
operator|<
literal|50
condition|)
block|{
comment|/* up to about 400Kbps */
name|rp
operator|->
name|rio_weight
operator|=
name|W_WEIGHT_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|npkts_per_sec
operator|<
literal|300
condition|)
block|{
comment|/* up to about 2.4Mbps */
name|rp
operator|->
name|rio_weight
operator|=
name|W_WEIGHT_1
expr_stmt|;
block|}
block|}
comment|/* calculate wshift.  weight must be power of 2 */
name|w
operator|=
name|rp
operator|->
name|rio_weight
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|w
operator|>
literal|1
condition|;
name|i
operator|++
control|)
name|w
operator|=
name|w
operator|>>
literal|1
expr_stmt|;
name|rp
operator|->
name|rio_wshift
operator|=
name|i
expr_stmt|;
name|w
operator|=
literal|1
operator|<<
name|rp
operator|->
name|rio_wshift
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|rp
operator|->
name|rio_weight
condition|)
block|{
name|printf
argument_list|(
literal|"invalid weight value %d for red! use %d\n"
argument_list|,
name|rp
operator|->
name|rio_weight
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|rp
operator|->
name|rio_weight
operator|=
name|w
expr_stmt|;
block|}
comment|/* allocate weight table */
name|rp
operator|->
name|rio_wtab
operator|=
name|wtab_alloc
argument_list|(
name|rp
operator|->
name|rio_weight
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|dropprec_state
modifier|*
name|prec
init|=
operator|&
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
decl_stmt|;
name|prec
operator|->
name|avg
operator|=
literal|0
expr_stmt|;
name|prec
operator|->
name|idle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
operator|||
name|params
index|[
name|i
index|]
operator|.
name|inv_pmax
operator|==
literal|0
condition|)
name|prec
operator|->
name|inv_pmax
operator|=
name|default_rio_params
index|[
name|i
index|]
operator|.
name|inv_pmax
expr_stmt|;
else|else
name|prec
operator|->
name|inv_pmax
operator|=
name|params
index|[
name|i
index|]
operator|.
name|inv_pmax
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
operator|||
name|params
index|[
name|i
index|]
operator|.
name|th_min
operator|==
literal|0
condition|)
name|prec
operator|->
name|th_min
operator|=
name|default_rio_params
index|[
name|i
index|]
operator|.
name|th_min
expr_stmt|;
else|else
name|prec
operator|->
name|th_min
operator|=
name|params
index|[
name|i
index|]
operator|.
name|th_min
expr_stmt|;
if|if
condition|(
name|params
operator|==
name|NULL
operator|||
name|params
index|[
name|i
index|]
operator|.
name|th_max
operator|==
literal|0
condition|)
name|prec
operator|->
name|th_max
operator|=
name|default_rio_params
index|[
name|i
index|]
operator|.
name|th_max
expr_stmt|;
else|else
name|prec
operator|->
name|th_max
operator|=
name|params
index|[
name|i
index|]
operator|.
name|th_max
expr_stmt|;
comment|/* 		 * th_min_s and th_max_s are scaled versions of th_min 		 * and th_max to be compared with avg. 		 */
name|prec
operator|->
name|th_min_s
operator|=
name|prec
operator|->
name|th_min
operator|<<
operator|(
name|rp
operator|->
name|rio_wshift
operator|+
name|FP_SHIFT
operator|)
expr_stmt|;
name|prec
operator|->
name|th_max_s
operator|=
name|prec
operator|->
name|th_max
operator|<<
operator|(
name|rp
operator|->
name|rio_wshift
operator|+
name|FP_SHIFT
operator|)
expr_stmt|;
comment|/* 		 * precompute probability denominator 		 *  probd = (2 * (TH_MAX-TH_MIN) / pmax) in fixed-point 		 */
name|prec
operator|->
name|probd
operator|=
operator|(
literal|2
operator|*
operator|(
name|prec
operator|->
name|th_max
operator|-
name|prec
operator|->
name|th_min
operator|)
operator|*
name|prec
operator|->
name|inv_pmax
operator|)
operator|<<
name|FP_SHIFT
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|prec
operator|->
name|last
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|rio_destroy
parameter_list|(
name|rio_t
modifier|*
name|rp
parameter_list|)
block|{
name|wtab_destroy
argument_list|(
name|rp
operator|->
name|rio_wtab
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rio_getstats
parameter_list|(
name|rio_t
modifier|*
name|rp
parameter_list|,
name|struct
name|redstats
modifier|*
name|sp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
block|{
name|bcopy
argument_list|(
operator|&
name|rp
operator|->
name|q_stats
index|[
name|i
index|]
argument_list|,
name|sp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|redstats
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|->
name|q_avg
operator|=
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|avg
operator|>>
name|rp
operator|->
name|rio_wshift
expr_stmt|;
name|sp
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|(
name|RIO_NDROPPREC
operator|==
literal|3
operator|)
end_if

begin_comment
comment|/*  * internally, a drop precedence value is converted to an index  * starting from 0.  */
end_comment

begin_function
specifier|static
name|int
name|dscp2index
parameter_list|(
name|u_int8_t
name|dscp
parameter_list|)
block|{
name|int
name|dpindex
init|=
name|dscp
operator|&
name|AF_DROPPRECMASK
decl_stmt|;
if|if
condition|(
name|dpindex
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
name|dpindex
operator|>>
literal|3
operator|)
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/*  * kludge: when a packet is dequeued, we need to know its drop precedence  * in order to keep the queue length of each drop precedence.  * use m_pkthdr.rcvif to pass this info.  */
end_comment

begin_define
define|#
directive|define
name|RIOM_SET_PRECINDEX
parameter_list|(
name|m
parameter_list|,
name|idx
parameter_list|)
define|\
value|do { (m)->m_pkthdr.rcvif = (struct ifnet *)((long)(idx)); } while (0)
end_define

begin_define
define|#
directive|define
name|RIOM_GET_PRECINDEX
parameter_list|(
name|m
parameter_list|)
define|\
value|({ long idx; idx = (long)((m)->m_pkthdr.rcvif); \ 	(m)->m_pkthdr.rcvif = NULL; idx; })
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|rio_addq
parameter_list|(
name|rio_t
modifier|*
name|rp
parameter_list|,
name|class_queue_t
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
name|pktattr
parameter_list|)
block|{
name|int
name|avg
decl_stmt|,
name|droptype
decl_stmt|;
name|u_int8_t
name|dsfield
decl_stmt|,
name|odsfield
decl_stmt|;
name|int
name|dpindex
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|dropprec_state
modifier|*
name|prec
decl_stmt|;
name|dsfield
operator|=
name|odsfield
operator|=
name|read_dsfield
argument_list|(
name|m
argument_list|,
name|pktattr
argument_list|)
expr_stmt|;
name|dpindex
operator|=
name|dscp2index
argument_list|(
name|dsfield
argument_list|)
expr_stmt|;
comment|/* 	 * update avg of the precedence states whose drop precedence 	 * is larger than or equal to the drop precedence of the packet 	 */
name|now
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dpindex
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
block|{
name|prec
operator|=
operator|&
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
expr_stmt|;
name|avg
operator|=
name|prec
operator|->
name|avg
expr_stmt|;
if|if
condition|(
name|prec
operator|->
name|idle
condition|)
block|{
name|prec
operator|->
name|idle
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|==
literal|0
condition|)
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|prec
operator|->
name|last
operator|.
name|tv_sec
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|60
condition|)
name|avg
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|t
operator|=
name|t
operator|*
literal|1000000
operator|+
operator|(
name|now
operator|.
name|tv_usec
operator|-
name|prec
operator|->
name|last
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|n
operator|=
name|t
operator|/
name|rp
operator|->
name|rio_pkttime
expr_stmt|;
comment|/* calculate (avg = (1 - Wq)^n * avg) */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|avg
operator|=
operator|(
name|avg
operator|>>
name|FP_SHIFT
operator|)
operator|*
name|pow_w
argument_list|(
name|rp
operator|->
name|rio_wtab
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* run estimator. (avg is scaled by WEIGHT in fixed-point) */
name|avg
operator|+=
operator|(
name|prec
operator|->
name|qlen
operator|<<
name|FP_SHIFT
operator|)
operator|-
operator|(
name|avg
operator|>>
name|rp
operator|->
name|rio_wshift
operator|)
expr_stmt|;
name|prec
operator|->
name|avg
operator|=
name|avg
expr_stmt|;
comment|/* save the new value */
comment|/* 		 * count keeps a tally of arriving traffic that has not 		 * been dropped. 		 */
name|prec
operator|->
name|count
operator|++
expr_stmt|;
block|}
name|prec
operator|=
operator|&
name|rp
operator|->
name|rio_precstate
index|[
name|dpindex
index|]
expr_stmt|;
name|avg
operator|=
name|prec
operator|->
name|avg
expr_stmt|;
comment|/* see if we drop early */
name|droptype
operator|=
name|DTYPE_NODROP
expr_stmt|;
if|if
condition|(
name|avg
operator|>=
name|prec
operator|->
name|th_min_s
operator|&&
name|prec
operator|->
name|qlen
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|avg
operator|>=
name|prec
operator|->
name|th_max_s
condition|)
block|{
comment|/* avg>= th_max: forced drop */
name|droptype
operator|=
name|DTYPE_FORCED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|prec
operator|->
name|old
operator|==
literal|0
condition|)
block|{
comment|/* first exceeds th_min */
name|prec
operator|->
name|count
operator|=
literal|1
expr_stmt|;
name|prec
operator|->
name|old
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drop_early
argument_list|(
operator|(
name|avg
operator|-
name|prec
operator|->
name|th_min_s
operator|)
operator|>>
name|rp
operator|->
name|rio_wshift
argument_list|,
name|prec
operator|->
name|probd
argument_list|,
name|prec
operator|->
name|count
argument_list|)
condition|)
block|{
comment|/* unforced drop by red */
name|droptype
operator|=
name|DTYPE_EARLY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* avg< th_min */
name|prec
operator|->
name|old
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * if the queue length hits the hard limit, it's a forced drop. 	 */
if|if
condition|(
name|droptype
operator|==
name|DTYPE_NODROP
operator|&&
name|qlen
argument_list|(
name|q
argument_list|)
operator|>=
name|qlimit
argument_list|(
name|q
argument_list|)
condition|)
name|droptype
operator|=
name|DTYPE_FORCED
expr_stmt|;
if|if
condition|(
name|droptype
operator|!=
name|DTYPE_NODROP
condition|)
block|{
comment|/* always drop incoming packet (as opposed to randomdrop) */
for|for
control|(
name|i
operator|=
name|dpindex
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RIO_STATS
if|if
condition|(
name|droptype
operator|==
name|DTYPE_EARLY
condition|)
name|rp
operator|->
name|q_stats
index|[
name|dpindex
index|]
operator|.
name|drop_unforced
operator|++
expr_stmt|;
else|else
name|rp
operator|->
name|q_stats
index|[
name|dpindex
index|]
operator|.
name|drop_forced
operator|++
expr_stmt|;
name|PKTCNTR_ADD
argument_list|(
operator|&
name|rp
operator|->
name|q_stats
index|[
name|dpindex
index|]
operator|.
name|drop_cnt
argument_list|,
name|m_pktlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
name|dpindex
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|qlen
operator|++
expr_stmt|;
comment|/* save drop precedence index in mbuf hdr */
name|RIOM_SET_PRECINDEX
argument_list|(
name|m
argument_list|,
name|dpindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|rio_flags
operator|&
name|RIOF_CLEARDSCP
condition|)
name|dsfield
operator|&=
operator|~
name|DSCP_MASK
expr_stmt|;
if|if
condition|(
name|dsfield
operator|!=
name|odsfield
condition|)
name|write_dsfield
argument_list|(
name|m
argument_list|,
name|pktattr
argument_list|,
name|dsfield
argument_list|)
expr_stmt|;
name|_addq
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|RIO_STATS
name|PKTCNTR_ADD
argument_list|(
operator|&
name|rp
operator|->
name|q_stats
index|[
name|dpindex
index|]
operator|.
name|xmit_cnt
argument_list|,
name|m_pktlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|rio_getq
parameter_list|(
name|rio_t
modifier|*
name|rp
parameter_list|,
name|class_queue_t
modifier|*
name|q
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|dpindex
decl_stmt|,
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|_getq
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dpindex
operator|=
name|RIOM_GET_PRECINDEX
argument_list|(
name|m
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|dpindex
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|--
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|qlen
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|idle
operator|==
literal|0
condition|)
block|{
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|idle
operator|=
literal|1
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|last
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_function
name|int
name|rioopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
comment|/* everything will be done when the queueing scheme is attached. */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rioclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|rio_queue_t
modifier|*
name|rqp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|rqp
operator|=
name|rio_list
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* destroy all */
name|err
operator|=
name|rio_detach
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|rioioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|rio_queue_t
modifier|*
name|rqp
decl_stmt|;
name|struct
name|rio_interface
modifier|*
name|ifacep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* check super-user privilege */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RIO_GETSTATS
case|:
break|break;
default|default:
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|400000
operator|)
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RIO_ENABLE
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|rio_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|rio_ifname
argument_list|,
name|ALTQT_RIO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|altq_enable
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIO_DISABLE
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|rio_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|rio_ifname
argument_list|,
name|ALTQT_RIO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|altq_disable
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIO_IF_ATTACH
case|:
name|ifp
operator|=
name|ifunit
argument_list|(
operator|(
operator|(
expr|struct
name|rio_interface
operator|*
operator|)
name|addr
operator|)
operator|->
name|rio_ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* allocate and initialize rio_queue_t */
name|MALLOC
argument_list|(
name|rqp
argument_list|,
name|rio_queue_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|rio_queue_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|rqp
argument_list|,
sizeof|sizeof
argument_list|(
name|rio_queue_t
argument_list|)
argument_list|)
expr_stmt|;
name|MALLOC
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|class_queue_t
operator|*
argument_list|,
sizeof|sizeof
argument_list|(
name|class_queue_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|rq_q
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
sizeof|sizeof
argument_list|(
name|class_queue_t
argument_list|)
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq_rio
operator|=
name|rio_alloc
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|rq_rio
operator|==
name|NULL
condition|)
block|{
name|FREE
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|rqp
operator|->
name|rq_ifq
operator|=
operator|&
name|ifp
operator|->
name|if_snd
expr_stmt|;
name|qtail
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|qlen
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
literal|0
expr_stmt|;
name|qlimit
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|RIO_LIMIT
expr_stmt|;
name|qtype
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|Q_RIO
expr_stmt|;
comment|/* 		 * set RIO to this ifnet structure. 		 */
name|error
operator|=
name|altq_attach
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|,
name|ALTQT_RIO
argument_list|,
name|rqp
argument_list|,
name|rio_enqueue
argument_list|,
name|rio_dequeue
argument_list|,
name|rio_request
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|rio_destroy
argument_list|(
name|rqp
operator|->
name|rq_rio
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* add this state to the rio list */
name|rqp
operator|->
name|rq_next
operator|=
name|rio_list
expr_stmt|;
name|rio_list
operator|=
name|rqp
expr_stmt|;
break|break;
case|case
name|RIO_IF_DETACH
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|rio_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|rio_ifname
argument_list|,
name|ALTQT_RIO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|rio_detach
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RIO_GETSTATS
case|:
do|do
block|{
name|struct
name|rio_stats
modifier|*
name|q_stats
decl_stmt|;
name|rio_t
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|q_stats
operator|=
operator|(
expr|struct
name|rio_stats
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|q_stats
operator|->
name|iface
operator|.
name|rio_ifname
argument_list|,
name|ALTQT_RIO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|rp
operator|=
name|rqp
operator|->
name|rq_rio
expr_stmt|;
name|q_stats
operator|->
name|q_limit
operator|=
name|qlimit
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
name|q_stats
operator|->
name|weight
operator|=
name|rp
operator|->
name|rio_weight
expr_stmt|;
name|q_stats
operator|->
name|flags
operator|=
name|rp
operator|->
name|rio_flags
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
block|{
name|q_stats
operator|->
name|q_len
index|[
name|i
index|]
operator|=
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|qlen
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|rp
operator|->
name|q_stats
index|[
name|i
index|]
argument_list|,
operator|&
name|q_stats
operator|->
name|q_stats
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|redstats
argument_list|)
argument_list|)
expr_stmt|;
name|q_stats
operator|->
name|q_stats
index|[
name|i
index|]
operator|.
name|q_avg
operator|=
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|avg
operator|>>
name|rp
operator|->
name|rio_wshift
expr_stmt|;
name|q_stats
operator|->
name|q_params
index|[
name|i
index|]
operator|.
name|inv_pmax
operator|=
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|inv_pmax
expr_stmt|;
name|q_stats
operator|->
name|q_params
index|[
name|i
index|]
operator|.
name|th_min
operator|=
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|th_min
expr_stmt|;
name|q_stats
operator|->
name|q_params
index|[
name|i
index|]
operator|.
name|th_max
operator|=
name|rp
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|th_max
expr_stmt|;
block|}
block|}
do|while
condition|(
comment|/*CONSTCOND*/
literal|0
condition|)
do|;
break|break;
case|case
name|RIO_CONFIG
case|:
do|do
block|{
name|struct
name|rio_conf
modifier|*
name|fc
decl_stmt|;
name|rio_t
modifier|*
name|new
decl_stmt|;
name|int
name|s
decl_stmt|,
name|limit
decl_stmt|,
name|i
decl_stmt|;
name|fc
operator|=
operator|(
expr|struct
name|rio_conf
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|fc
operator|->
name|iface
operator|.
name|rio_ifname
argument_list|,
name|ALTQT_RIO
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|rio_alloc
argument_list|(
name|fc
operator|->
name|rio_weight
argument_list|,
operator|&
name|fc
operator|->
name|q_params
index|[
literal|0
index|]
argument_list|,
name|fc
operator|->
name|rio_flags
argument_list|,
name|fc
operator|->
name|rio_pkttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|_flushq
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
name|limit
operator|=
name|fc
operator|->
name|rio_limit
expr_stmt|;
if|if
condition|(
name|limit
operator|<
name|fc
operator|->
name|q_params
index|[
name|RIO_NDROPPREC
operator|-
literal|1
index|]
operator|.
name|th_max
condition|)
name|limit
operator|=
name|fc
operator|->
name|q_params
index|[
name|RIO_NDROPPREC
operator|-
literal|1
index|]
operator|.
name|th_max
expr_stmt|;
name|qlimit
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|limit
expr_stmt|;
name|rio_destroy
argument_list|(
name|rqp
operator|->
name|rq_rio
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq_rio
operator|=
name|new
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* write back new values */
name|fc
operator|->
name|rio_limit
operator|=
name|limit
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
block|{
name|fc
operator|->
name|q_params
index|[
name|i
index|]
operator|.
name|inv_pmax
operator|=
name|rqp
operator|->
name|rq_rio
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|inv_pmax
expr_stmt|;
name|fc
operator|->
name|q_params
index|[
name|i
index|]
operator|.
name|th_min
operator|=
name|rqp
operator|->
name|rq_rio
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|th_min
expr_stmt|;
name|fc
operator|->
name|q_params
index|[
name|i
index|]
operator|.
name|th_max
operator|=
name|rqp
operator|->
name|rq_rio
operator|->
name|rio_precstate
index|[
name|i
index|]
operator|.
name|th_max
expr_stmt|;
block|}
block|}
do|while
condition|(
comment|/*CONSTCOND*/
literal|0
condition|)
do|;
break|break;
case|case
name|RIO_SETDEFAULTS
case|:
do|do
block|{
name|struct
name|redparams
modifier|*
name|rp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|redparams
operator|*
operator|)
name|addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RIO_NDROPPREC
condition|;
name|i
operator|++
control|)
name|default_rio_params
index|[
name|i
index|]
operator|=
name|rp
index|[
name|i
index|]
expr_stmt|;
block|}
do|while
condition|(
comment|/*CONSTCOND*/
literal|0
condition|)
do|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rio_detach
parameter_list|(
name|rqp
parameter_list|)
name|rio_queue_t
modifier|*
name|rqp
decl_stmt|;
block|{
name|rio_queue_t
modifier|*
name|tmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
condition|)
name|altq_disable
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|altq_detach
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rio_list
operator|==
name|rqp
condition|)
name|rio_list
operator|=
name|rqp
operator|->
name|rq_next
expr_stmt|;
else|else
block|{
for|for
control|(
name|tmp
operator|=
name|rio_list
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|rq_next
control|)
if|if
condition|(
name|tmp
operator|->
name|rq_next
operator|==
name|rqp
condition|)
block|{
name|tmp
operator|->
name|rq_next
operator|=
name|rqp
operator|->
name|rq_next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"rio_detach: no state found in rio_list!\n"
argument_list|)
expr_stmt|;
block|}
name|rio_destroy
argument_list|(
name|rqp
operator|->
name|rq_rio
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|FREE
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rio support routines  */
end_comment

begin_function
specifier|static
name|int
name|rio_request
parameter_list|(
name|ifq
parameter_list|,
name|req
parameter_list|,
name|arg
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|int
name|req
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|rio_queue_t
modifier|*
name|rqp
init|=
operator|(
name|rio_queue_t
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|ALTRQ_PURGE
case|:
name|_flushq
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|ifq
argument_list|)
condition|)
name|ifq
operator|->
name|ifq_len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * enqueue routine:  *  *	returns: 0 when successfully queued.  *		 ENOBUFS when drop occurs.  */
end_comment

begin_function
specifier|static
name|int
name|rio_enqueue
parameter_list|(
name|ifq
parameter_list|,
name|m
parameter_list|,
name|pktattr
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|altq_pktattr
modifier|*
name|pktattr
decl_stmt|;
block|{
name|rio_queue_t
modifier|*
name|rqp
init|=
operator|(
name|rio_queue_t
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rio_addq
argument_list|(
name|rqp
operator|->
name|rq_rio
argument_list|,
name|rqp
operator|->
name|rq_q
argument_list|,
name|m
argument_list|,
name|pktattr
argument_list|)
operator|==
literal|0
condition|)
name|ifq
operator|->
name|ifq_len
operator|++
expr_stmt|;
else|else
name|error
operator|=
name|ENOBUFS
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * dequeue routine:  *	must be called in splimp.  *  *	returns: mbuf dequeued.  *		 NULL when no packet is available in the queue.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|rio_dequeue
parameter_list|(
name|ifq
parameter_list|,
name|op
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|int
name|op
decl_stmt|;
block|{
name|rio_queue_t
modifier|*
name|rqp
init|=
operator|(
name|rio_queue_t
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|op
operator|==
name|ALTDQ_POLL
condition|)
return|return
name|qhead
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
return|;
name|m
operator|=
name|rio_getq
argument_list|(
name|rqp
operator|->
name|rq_rio
argument_list|,
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|ifq
operator|->
name|ifq_len
operator|--
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KLD_MODULE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|altqsw
name|rio_sw
init|=
block|{
literal|"rio"
block|,
name|rioopen
block|,
name|rioclose
block|,
name|rioioctl
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ALTQ_MODULE
argument_list|(
name|altq_rio
argument_list|,
name|ALTQT_RIO
argument_list|,
operator|&
name|rio_sw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|altq_rio
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|altq_rio
argument_list|,
name|altq_red
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KLD_MODULE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_RIO */
end_comment

end_unit

