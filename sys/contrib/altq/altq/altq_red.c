begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: altq_red.c,v 1.18 2003/09/05 22:40:36 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1997-2003  *	Sony Computer Science Laboratories Inc.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY SONY CSL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL SONY CSL OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1990-1994 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the Computer Systems  *	Engineering Group at Lawrence Berkeley Laboratory.  * 4. Neither the name of the University nor of the Laboratory may be used  *    to endorse or promote products derived from this software without  *    specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_altq.h"
end_include

begin_if
if|#
directive|if
operator|(
name|__FreeBSD__
operator|!=
literal|2
operator|)
end_if

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ || __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_RED
end_ifdef

begin_comment
comment|/* red is enabled by ALTQ_RED option in opt_altq.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
end_ifdef

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in_systm.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<net/pfvar.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_red.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq_conf.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq_flowvalve.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ALTQ/RED (Random Early Detection) implementation using 32-bit  * fixed-point calculation.  *  * written by kjc using the ns code as a reference.  * you can learn more about red and ns from Sally's home page at  * http://www-nrg.ee.lbl.gov/floyd/  *  * most of the red parameter values are fixed in this implementation  * to prevent fixed-point overflow/underflow.  * if you change the parameters, watch out for overflow/underflow!  *  * the parameters used are recommended values by Sally.  * the corresponding ns config looks:  *	q_weight=0.00195  *	minthresh=5 maxthresh=15 queue-size=60  *	linterm=30  *	dropmech=drop-tail  *	bytes=false (can't be handled by 32-bit fixed-point)  *	doubleq=false dqthresh=false  *	wait=true  */
end_comment

begin_comment
comment|/*  * alternative red parameters for a slow link.  *  * assume the queue length becomes from zero to L and keeps L, it takes  * N packets for q_avg to reach 63% of L.  * when q_weight is 0.002, N is about 500 packets.  * for a slow link like dial-up, 500 packets takes more than 1 minute!  * when q_weight is 0.008, N is about 127 packets.  * when q_weight is 0.016, N is about 63 packets.  * bursts of 50 packets are allowed for 0.002, bursts of 25 packets  * are allowed for 0.016.  * see Sally's paper for more details.  */
end_comment

begin_comment
comment|/* normal red parameters */
end_comment

begin_define
define|#
directive|define
name|W_WEIGHT
value|512
end_define

begin_comment
comment|/* inverse of weight of EWMA (511/512) */
end_comment

begin_comment
comment|/* q_weight = 0.00195 */
end_comment

begin_comment
comment|/* red parameters for a slow link */
end_comment

begin_define
define|#
directive|define
name|W_WEIGHT_1
value|128
end_define

begin_comment
comment|/* inverse of weight of EWMA (127/128) */
end_comment

begin_comment
comment|/* q_weight = 0.0078125 */
end_comment

begin_comment
comment|/* red parameters for a very slow link (e.g., dialup) */
end_comment

begin_define
define|#
directive|define
name|W_WEIGHT_2
value|64
end_define

begin_comment
comment|/* inverse of weight of EWMA (63/64) */
end_comment

begin_comment
comment|/* q_weight = 0.015625 */
end_comment

begin_comment
comment|/* fixed-point uses 12-bit decimal places */
end_comment

begin_define
define|#
directive|define
name|FP_SHIFT
value|12
end_define

begin_comment
comment|/* fixed-point shift */
end_comment

begin_comment
comment|/* red parameters for drop probability */
end_comment

begin_define
define|#
directive|define
name|INV_P_MAX
value|10
end_define

begin_comment
comment|/* inverse of max drop probability */
end_comment

begin_define
define|#
directive|define
name|TH_MIN
value|5
end_define

begin_comment
comment|/* min threshold */
end_comment

begin_define
define|#
directive|define
name|TH_MAX
value|15
end_define

begin_comment
comment|/* max threshold */
end_comment

begin_define
define|#
directive|define
name|RED_LIMIT
value|60
end_define

begin_comment
comment|/* default max queue lenght */
end_comment

begin_define
define|#
directive|define
name|RED_STATS
end_define

begin_comment
comment|/* collect statistics */
end_comment

begin_comment
comment|/*  * our default policy for forced-drop is drop-tail.  * (in altq-1.1.2 or earlier, the default was random-drop.  * but it makes more sense to punish the cause of the surge.)  * to switch to the random-drop policy, define "RED_RANDOM_DROP".  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
end_ifdef

begin_comment
comment|/*  * flow-valve is an extention to protect red from unresponsive flows  * and to promote end-to-end congestion control.  * flow-valve observes the average drop rates of the flows that have  * experienced packet drops in the recent past.  * when the average drop rate exceeds the threshold, the flow is  * blocked by the flow-valve.  the trapped flow should back off  * exponentially to escape from the flow-valve.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|RED_RANDOM_DROP
end_ifdef

begin_error
error|#
directive|error
literal|"random-drop can't be used with flow-valve!"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_FLOWVALVE */
end_comment

begin_comment
comment|/* red_list keeps all red_queue_t's allocated. */
end_comment

begin_decl_stmt
specifier|static
name|red_queue_t
modifier|*
name|red_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_comment
comment|/* default red parameter values */
end_comment

begin_decl_stmt
specifier|static
name|int
name|default_th_min
init|=
name|TH_MIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_th_max
init|=
name|TH_MAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_inv_pmax
init|=
name|INV_P_MAX
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_comment
comment|/* internal function prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|red_enqueue
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|red_dequeue
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|red_request
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|red_purgeq
parameter_list|(
name|red_queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|red_detach
parameter_list|(
name|red_queue_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
end_ifdef

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|fve
operator|*
name|flowlist_lookup
argument_list|(
expr|struct
name|flowvalve
operator|*
argument_list|,
expr|struct
name|altq_pktattr
operator|*
argument_list|,
expr|struct
name|timeval
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|fve
operator|*
name|flowlist_reclaim
argument_list|(
expr|struct
name|flowvalve
operator|*
argument_list|,
expr|struct
name|altq_pktattr
operator|*
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|void
name|flowlist_move_to_head
parameter_list|(
name|struct
name|flowvalve
modifier|*
parameter_list|,
name|struct
name|fve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|int
name|fv_p2f
parameter_list|(
name|struct
name|flowvalve
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX: make the compiler happy (fv_alloc unused) */
end_comment

begin_endif
unit|static struct flowvalve *fv_alloc(struct red *);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|fv_destroy
parameter_list|(
name|struct
name|flowvalve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fv_checkflow
parameter_list|(
name|struct
name|flowvalve
modifier|*
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
parameter_list|,
name|struct
name|fve
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fv_dropbyred
parameter_list|(
name|struct
name|flowvalve
modifier|*
name|fv
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
parameter_list|,
name|struct
name|fve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_comment
comment|/*  * red support routines  */
end_comment

begin_function
name|red_t
modifier|*
name|red_alloc
parameter_list|(
name|int
name|weight
parameter_list|,
name|int
name|inv_pmax
parameter_list|,
name|int
name|th_min
parameter_list|,
name|int
name|th_max
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|pkttime
parameter_list|)
block|{
name|red_t
modifier|*
name|rp
decl_stmt|;
name|int
name|w
decl_stmt|,
name|i
decl_stmt|;
name|int
name|npkts_per_sec
decl_stmt|;
name|rp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|red_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|rp
argument_list|,
sizeof|sizeof
argument_list|(
name|red_t
argument_list|)
argument_list|)
expr_stmt|;
name|rp
operator|->
name|red_avg
operator|=
literal|0
expr_stmt|;
name|rp
operator|->
name|red_idle
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|weight
operator|==
literal|0
condition|)
name|rp
operator|->
name|red_weight
operator|=
name|W_WEIGHT
expr_stmt|;
else|else
name|rp
operator|->
name|red_weight
operator|=
name|weight
expr_stmt|;
if|if
condition|(
name|inv_pmax
operator|==
literal|0
condition|)
name|rp
operator|->
name|red_inv_pmax
operator|=
name|default_inv_pmax
expr_stmt|;
else|else
name|rp
operator|->
name|red_inv_pmax
operator|=
name|inv_pmax
expr_stmt|;
if|if
condition|(
name|th_min
operator|==
literal|0
condition|)
name|rp
operator|->
name|red_thmin
operator|=
name|default_th_min
expr_stmt|;
else|else
name|rp
operator|->
name|red_thmin
operator|=
name|th_min
expr_stmt|;
if|if
condition|(
name|th_max
operator|==
literal|0
condition|)
name|rp
operator|->
name|red_thmax
operator|=
name|default_th_max
expr_stmt|;
else|else
name|rp
operator|->
name|red_thmax
operator|=
name|th_max
expr_stmt|;
name|rp
operator|->
name|red_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|pkttime
operator|==
literal|0
condition|)
comment|/* default packet time: 1000 bytes / 10Mbps * 8 * 1000000 */
name|rp
operator|->
name|red_pkttime
operator|=
literal|800
expr_stmt|;
else|else
name|rp
operator|->
name|red_pkttime
operator|=
name|pkttime
expr_stmt|;
if|if
condition|(
name|weight
operator|==
literal|0
condition|)
block|{
comment|/* when the link is very slow, adjust red parameters */
name|npkts_per_sec
operator|=
literal|1000000
operator|/
name|rp
operator|->
name|red_pkttime
expr_stmt|;
if|if
condition|(
name|npkts_per_sec
operator|<
literal|50
condition|)
block|{
comment|/* up to about 400Kbps */
name|rp
operator|->
name|red_weight
operator|=
name|W_WEIGHT_2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|npkts_per_sec
operator|<
literal|300
condition|)
block|{
comment|/* up to about 2.4Mbps */
name|rp
operator|->
name|red_weight
operator|=
name|W_WEIGHT_1
expr_stmt|;
block|}
block|}
comment|/* calculate wshift.  weight must be power of 2 */
name|w
operator|=
name|rp
operator|->
name|red_weight
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|w
operator|>
literal|1
condition|;
name|i
operator|++
control|)
name|w
operator|=
name|w
operator|>>
literal|1
expr_stmt|;
name|rp
operator|->
name|red_wshift
operator|=
name|i
expr_stmt|;
name|w
operator|=
literal|1
operator|<<
name|rp
operator|->
name|red_wshift
expr_stmt|;
if|if
condition|(
name|w
operator|!=
name|rp
operator|->
name|red_weight
condition|)
block|{
name|printf
argument_list|(
literal|"invalid weight value %d for red! use %d\n"
argument_list|,
name|rp
operator|->
name|red_weight
argument_list|,
name|w
argument_list|)
expr_stmt|;
name|rp
operator|->
name|red_weight
operator|=
name|w
expr_stmt|;
block|}
comment|/* 	 * thmin_s and thmax_s are scaled versions of th_min and th_max 	 * to be compared with avg. 	 */
name|rp
operator|->
name|red_thmin_s
operator|=
name|rp
operator|->
name|red_thmin
operator|<<
operator|(
name|rp
operator|->
name|red_wshift
operator|+
name|FP_SHIFT
operator|)
expr_stmt|;
name|rp
operator|->
name|red_thmax_s
operator|=
name|rp
operator|->
name|red_thmax
operator|<<
operator|(
name|rp
operator|->
name|red_wshift
operator|+
name|FP_SHIFT
operator|)
expr_stmt|;
comment|/* 	 * precompute probability denominator 	 *  probd = (2 * (TH_MAX-TH_MIN) / pmax) in fixed-point 	 */
name|rp
operator|->
name|red_probd
operator|=
operator|(
literal|2
operator|*
operator|(
name|rp
operator|->
name|red_thmax
operator|-
name|rp
operator|->
name|red_thmin
operator|)
operator|*
name|rp
operator|->
name|red_inv_pmax
operator|)
operator|<<
name|FP_SHIFT
expr_stmt|;
comment|/* allocate weight table */
name|rp
operator|->
name|red_wtab
operator|=
name|wtab_alloc
argument_list|(
name|rp
operator|->
name|red_weight
argument_list|)
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|rp
operator|->
name|red_last
argument_list|)
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|red_destroy
parameter_list|(
name|red_t
modifier|*
name|rp
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
if|if
condition|(
name|rp
operator|->
name|red_flowvalve
operator|!=
name|NULL
condition|)
name|fv_destroy
argument_list|(
name|rp
operator|->
name|red_flowvalve
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ALTQ3_COMPAT */
name|wtab_destroy
argument_list|(
name|rp
operator|->
name|red_wtab
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|red_getstats
parameter_list|(
name|red_t
modifier|*
name|rp
parameter_list|,
name|struct
name|redstats
modifier|*
name|sp
parameter_list|)
block|{
name|sp
operator|->
name|q_avg
operator|=
name|rp
operator|->
name|red_avg
operator|>>
name|rp
operator|->
name|red_wshift
expr_stmt|;
name|sp
operator|->
name|xmit_cnt
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|xmit_cnt
expr_stmt|;
name|sp
operator|->
name|drop_cnt
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|drop_cnt
expr_stmt|;
name|sp
operator|->
name|drop_forced
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|drop_forced
expr_stmt|;
name|sp
operator|->
name|drop_unforced
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|drop_unforced
expr_stmt|;
name|sp
operator|->
name|marked_packets
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|marked_packets
expr_stmt|;
block|}
end_function

begin_function
name|int
name|red_addq
parameter_list|(
name|red_t
modifier|*
name|rp
parameter_list|,
name|class_queue_t
modifier|*
name|q
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
name|pktattr
parameter_list|)
block|{
name|int
name|avg
decl_stmt|,
name|droptype
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
name|struct
name|fve
modifier|*
name|fve
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|rp
operator|->
name|red_flowvalve
operator|!=
name|NULL
operator|&&
name|rp
operator|->
name|red_flowvalve
operator|->
name|fv_flows
operator|>
literal|0
condition|)
if|if
condition|(
name|fv_checkflow
argument_list|(
name|rp
operator|->
name|red_flowvalve
argument_list|,
name|pktattr
argument_list|,
operator|&
name|fve
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* ALTQ3_COMPAT */
name|avg
operator|=
name|rp
operator|->
name|red_avg
expr_stmt|;
comment|/* 	 * if we were idle, we pretend that n packets arrived during 	 * the idle period. 	 */
if|if
condition|(
name|rp
operator|->
name|red_idle
condition|)
block|{
name|struct
name|timeval
name|now
decl_stmt|;
name|int
name|t
decl_stmt|;
name|rp
operator|->
name|red_idle
operator|=
literal|0
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|now
operator|.
name|tv_sec
operator|-
name|rp
operator|->
name|red_last
operator|.
name|tv_sec
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|60
condition|)
block|{
comment|/* 			 * being idle for more than 1 minute, set avg to zero. 			 * this prevents t from overflow. 			 */
name|avg
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|t
operator|*
literal|1000000
operator|+
operator|(
name|now
operator|.
name|tv_usec
operator|-
name|rp
operator|->
name|red_last
operator|.
name|tv_usec
operator|)
expr_stmt|;
name|n
operator|=
name|t
operator|/
name|rp
operator|->
name|red_pkttime
operator|-
literal|1
expr_stmt|;
comment|/* the following line does (avg = (1 - Wq)^n * avg) */
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|avg
operator|=
operator|(
name|avg
operator|>>
name|FP_SHIFT
operator|)
operator|*
name|pow_w
argument_list|(
name|rp
operator|->
name|red_wtab
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* run estimator. (note: avg is scaled by WEIGHT in fixed-point) */
name|avg
operator|+=
operator|(
name|qlen
argument_list|(
name|q
argument_list|)
operator|<<
name|FP_SHIFT
operator|)
operator|-
operator|(
name|avg
operator|>>
name|rp
operator|->
name|red_wshift
operator|)
expr_stmt|;
name|rp
operator|->
name|red_avg
operator|=
name|avg
expr_stmt|;
comment|/* save the new value */
comment|/* 	 * red_count keeps a tally of arriving traffic that has not 	 * been dropped. 	 */
name|rp
operator|->
name|red_count
operator|++
expr_stmt|;
comment|/* see if we drop early */
name|droptype
operator|=
name|DTYPE_NODROP
expr_stmt|;
if|if
condition|(
name|avg
operator|>=
name|rp
operator|->
name|red_thmin_s
operator|&&
name|qlen
argument_list|(
name|q
argument_list|)
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|avg
operator|>=
name|rp
operator|->
name|red_thmax_s
condition|)
block|{
comment|/* avg>= th_max: forced drop */
name|droptype
operator|=
name|DTYPE_FORCED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rp
operator|->
name|red_old
operator|==
literal|0
condition|)
block|{
comment|/* first exceeds th_min */
name|rp
operator|->
name|red_count
operator|=
literal|1
expr_stmt|;
name|rp
operator|->
name|red_old
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|drop_early
argument_list|(
operator|(
name|avg
operator|-
name|rp
operator|->
name|red_thmin_s
operator|)
operator|>>
name|rp
operator|->
name|red_wshift
argument_list|,
name|rp
operator|->
name|red_probd
argument_list|,
name|rp
operator|->
name|red_count
argument_list|)
condition|)
block|{
comment|/* mark or drop by red */
if|if
condition|(
operator|(
name|rp
operator|->
name|red_flags
operator|&
name|REDF_ECN
operator|)
operator|&&
name|mark_ecn
argument_list|(
name|m
argument_list|,
name|pktattr
argument_list|,
name|rp
operator|->
name|red_flags
argument_list|)
condition|)
block|{
comment|/* successfully marked.  do not drop. */
name|rp
operator|->
name|red_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|RED_STATS
name|rp
operator|->
name|red_stats
operator|.
name|marked_packets
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* unforced drop by red */
name|droptype
operator|=
name|DTYPE_EARLY
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* avg< th_min */
name|rp
operator|->
name|red_old
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * if the queue length hits the hard limit, it's a forced drop. 	 */
if|if
condition|(
name|droptype
operator|==
name|DTYPE_NODROP
operator|&&
name|qlen
argument_list|(
name|q
argument_list|)
operator|>=
name|qlimit
argument_list|(
name|q
argument_list|)
condition|)
name|droptype
operator|=
name|DTYPE_FORCED
expr_stmt|;
ifdef|#
directive|ifdef
name|RED_RANDOM_DROP
comment|/* if successful or forced drop, enqueue this packet. */
if|if
condition|(
name|droptype
operator|!=
name|DTYPE_EARLY
condition|)
name|_addq
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* if successful, enqueue this packet. */
if|if
condition|(
name|droptype
operator|==
name|DTYPE_NODROP
condition|)
name|_addq
argument_list|(
name|q
argument_list|,
name|m
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|droptype
operator|!=
name|DTYPE_NODROP
condition|)
block|{
if|if
condition|(
name|droptype
operator|==
name|DTYPE_EARLY
condition|)
block|{
comment|/* drop the incoming packet */
ifdef|#
directive|ifdef
name|RED_STATS
name|rp
operator|->
name|red_stats
operator|.
name|drop_unforced
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* forced drop, select a victim packet in the queue. */
ifdef|#
directive|ifdef
name|RED_RANDOM_DROP
name|m
operator|=
name|_getq_random
argument_list|(
name|q
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RED_STATS
name|rp
operator|->
name|red_stats
operator|.
name|drop_forced
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|RED_STATS
name|PKTCNTR_ADD
argument_list|(
operator|&
name|rp
operator|->
name|red_stats
operator|.
name|drop_cnt
argument_list|,
name|m_pktlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|rp
operator|->
name|red_count
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
if|if
condition|(
name|rp
operator|->
name|red_flowvalve
operator|!=
name|NULL
condition|)
name|fv_dropbyred
argument_list|(
name|rp
operator|->
name|red_flowvalve
argument_list|,
name|pktattr
argument_list|,
name|fve
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* ALTQ3_COMPAT */
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* successfully queued */
ifdef|#
directive|ifdef
name|RED_STATS
name|PKTCNTR_ADD
argument_list|(
operator|&
name|rp
operator|->
name|red_stats
operator|.
name|xmit_cnt
argument_list|,
name|m_pktlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * early-drop probability is calculated as follows:  *   prob = p_max * (avg - th_min) / (th_max - th_min)  *   prob_a = prob / (2 - count*prob)  *	    = (avg-th_min) / (2*(th_max-th_min)*inv_p_max - count*(avg-th_min))  * here prob_a increases as successive undrop count increases.  * (prob_a starts from prob/2, becomes prob when (count == (1 / prob)),  * becomes 1 when (count>= (2 / prob))).  */
end_comment

begin_function
name|int
name|drop_early
parameter_list|(
name|int
name|fp_len
parameter_list|,
name|int
name|fp_probd
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|int
name|d
decl_stmt|;
comment|/* denominator of drop-probability */
name|d
operator|=
name|fp_probd
operator|-
name|count
operator|*
name|fp_len
expr_stmt|;
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
comment|/* count exceeds the hard limit: drop or mark */
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * now the range of d is [1..600] in fixed-point. (when 	 * th_max-th_min=10 and p_max=1/30) 	 * drop probability = (avg - TH_MIN) / d 	 */
if|if
condition|(
operator|(
name|arc4random
argument_list|()
operator|%
name|d
operator|)
operator|<
name|fp_len
condition|)
block|{
comment|/* drop or mark */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* no drop/mark */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * try to mark CE bit to the packet.  *    returns 1 if successfully marked, 0 otherwise.  */
end_comment

begin_function
name|int
name|mark_ecn
parameter_list|(
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
name|pktattr
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|struct
name|pf_mtag
modifier|*
name|at
decl_stmt|;
name|void
modifier|*
name|hdr
decl_stmt|;
name|int
name|af
decl_stmt|;
name|at
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|at
operator|!=
name|NULL
condition|)
block|{
name|af
operator|=
name|at
operator|->
name|af
expr_stmt|;
name|hdr
operator|=
name|at
operator|->
name|hdr
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
block|}
elseif|else
if|if
condition|(
name|pktattr
operator|!=
name|NULL
condition|)
block|{
name|af
operator|=
name|pktattr
operator|->
name|pattr_af
expr_stmt|;
name|hdr
operator|=
name|pktattr
operator|->
name|pattr_hdr
expr_stmt|;
endif|#
directive|endif
comment|/* ALTQ3_COMPAT */
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|af
operator|!=
name|AF_INET
operator|&&
name|af
operator|!=
name|AF_INET6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* verify that pattr_hdr is within the mbuf data */
for|for
control|(
name|m0
operator|=
name|m
init|;
name|m0
operator|!=
name|NULL
condition|;
name|m0
operator|=
name|m0
operator|->
name|m_next
control|)
if|if
condition|(
operator|(
operator|(
name|caddr_t
operator|)
name|hdr
operator|>=
name|m0
operator|->
name|m_data
operator|)
operator|&&
operator|(
operator|(
name|caddr_t
operator|)
name|hdr
operator|<
name|m0
operator|->
name|m_data
operator|+
name|m0
operator|->
name|m_len
operator|)
condition|)
break|break;
if|if
condition|(
name|m0
operator|==
name|NULL
condition|)
block|{
comment|/* ick, tag info is stale */
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|flags
operator|&
name|REDF_ECN4
condition|)
block|{
name|struct
name|ip
modifier|*
name|ip
init|=
name|hdr
decl_stmt|;
name|u_int8_t
name|otos
decl_stmt|;
name|int
name|sum
decl_stmt|;
if|if
condition|(
name|ip
operator|->
name|ip_v
operator|!=
literal|4
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* version mismatch! */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_ECN_MASK
operator|)
operator|==
name|IPTOS_ECN_NOTECT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not-ECT */
if|if
condition|(
operator|(
name|ip
operator|->
name|ip_tos
operator|&
name|IPTOS_ECN_MASK
operator|)
operator|==
name|IPTOS_ECN_CE
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* already marked */
comment|/* 			 * ecn-capable but not marked, 			 * mark CE and update checksum 			 */
name|otos
operator|=
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|ip
operator|->
name|ip_tos
operator||=
name|IPTOS_ECN_CE
expr_stmt|;
comment|/* 			 * update checksum (from RFC1624) 			 *	   HC' = ~(~HC + ~m + m') 			 */
name|sum
operator|=
operator|~
name|ntohs
argument_list|(
name|ip
operator|->
name|ip_sum
argument_list|)
operator|&
literal|0xffff
expr_stmt|;
name|sum
operator|+=
operator|(
operator|~
name|otos
operator|&
literal|0xffff
operator|)
operator|+
name|ip
operator|->
name|ip_tos
expr_stmt|;
name|sum
operator|=
operator|(
name|sum
operator|>>
literal|16
operator|)
operator|+
operator|(
name|sum
operator|&
literal|0xffff
operator|)
expr_stmt|;
name|sum
operator|+=
operator|(
name|sum
operator|>>
literal|16
operator|)
expr_stmt|;
comment|/* add carry */
name|ip
operator|->
name|ip_sum
operator|=
name|htons
argument_list|(
operator|~
name|sum
operator|&
literal|0xffff
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|flags
operator|&
name|REDF_ECN6
condition|)
block|{
name|struct
name|ip6_hdr
modifier|*
name|ip6
init|=
name|hdr
decl_stmt|;
name|u_int32_t
name|flowlabel
decl_stmt|;
name|flowlabel
operator|=
name|ntohl
argument_list|(
name|ip6
operator|->
name|ip6_flow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flowlabel
operator|>>
literal|28
operator|)
operator|!=
literal|6
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* version mismatch! */
if|if
condition|(
operator|(
name|flowlabel
operator|&
operator|(
name|IPTOS_ECN_MASK
operator|<<
literal|20
operator|)
operator|)
operator|==
operator|(
name|IPTOS_ECN_NOTECT
operator|<<
literal|20
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* not-ECT */
if|if
condition|(
operator|(
name|flowlabel
operator|&
operator|(
name|IPTOS_ECN_MASK
operator|<<
literal|20
operator|)
operator|)
operator|==
operator|(
name|IPTOS_ECN_CE
operator|<<
literal|20
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* already marked */
comment|/* 			 * ecn-capable but not marked,  mark CE 			 */
name|flowlabel
operator||=
operator|(
name|IPTOS_ECN_CE
operator|<<
literal|20
operator|)
expr_stmt|;
name|ip6
operator|->
name|ip6_flow
operator|=
name|htonl
argument_list|(
name|flowlabel
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
block|}
comment|/* not marked */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|mbuf
modifier|*
name|red_getq
parameter_list|(
name|rp
parameter_list|,
name|q
parameter_list|)
name|red_t
modifier|*
name|rp
decl_stmt|;
name|class_queue_t
modifier|*
name|q
decl_stmt|;
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|=
name|_getq
argument_list|(
name|q
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rp
operator|->
name|red_idle
operator|==
literal|0
condition|)
block|{
name|rp
operator|->
name|red_idle
operator|=
literal|1
expr_stmt|;
name|microtime
argument_list|(
operator|&
name|rp
operator|->
name|red_last
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
name|rp
operator|->
name|red_idle
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * helper routine to calibrate avg during idle.  * pow_w(wtab, n) returns (1 - Wq)^n in fixed-point  * here Wq = 1/weight and the code assumes Wq is close to zero.  *  * w_tab[n] holds ((1 - Wq)^(2^n)) in fixed-point.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|wtab
modifier|*
name|wtab_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to wtab list */
end_comment

begin_function
name|struct
name|wtab
modifier|*
name|wtab_alloc
parameter_list|(
name|int
name|weight
parameter_list|)
block|{
name|struct
name|wtab
modifier|*
name|w
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|w
operator|=
name|wtab_list
init|;
name|w
operator|!=
name|NULL
condition|;
name|w
operator|=
name|w
operator|->
name|w_next
control|)
if|if
condition|(
name|w
operator|->
name|w_weight
operator|==
name|weight
condition|)
block|{
name|w
operator|->
name|w_refcount
operator|++
expr_stmt|;
return|return
operator|(
name|w
operator|)
return|;
block|}
name|w
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|wtab
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"wtab_alloc: malloc failed!"
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|w
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|wtab
argument_list|)
argument_list|)
expr_stmt|;
name|w
operator|->
name|w_weight
operator|=
name|weight
expr_stmt|;
name|w
operator|->
name|w_refcount
operator|=
literal|1
expr_stmt|;
name|w
operator|->
name|w_next
operator|=
name|wtab_list
expr_stmt|;
name|wtab_list
operator|=
name|w
expr_stmt|;
comment|/* initialize the weight table */
name|w
operator|->
name|w_tab
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|weight
operator|-
literal|1
operator|)
operator|<<
name|FP_SHIFT
operator|)
operator|/
name|weight
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
name|w
operator|->
name|w_tab
index|[
name|i
index|]
operator|=
operator|(
name|w
operator|->
name|w_tab
index|[
name|i
operator|-
literal|1
index|]
operator|*
name|w
operator|->
name|w_tab
index|[
name|i
operator|-
literal|1
index|]
operator|)
operator|>>
name|FP_SHIFT
expr_stmt|;
if|if
condition|(
name|w
operator|->
name|w_tab
index|[
name|i
index|]
operator|==
literal|0
operator|&&
name|w
operator|->
name|w_param_max
operator|==
literal|0
condition|)
name|w
operator|->
name|w_param_max
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
return|return
operator|(
name|w
operator|)
return|;
block|}
end_function

begin_function
name|int
name|wtab_destroy
parameter_list|(
name|struct
name|wtab
modifier|*
name|w
parameter_list|)
block|{
name|struct
name|wtab
modifier|*
name|prev
decl_stmt|;
if|if
condition|(
operator|--
name|w
operator|->
name|w_refcount
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|wtab_list
operator|==
name|w
condition|)
name|wtab_list
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
else|else
for|for
control|(
name|prev
operator|=
name|wtab_list
init|;
name|prev
operator|->
name|w_next
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|prev
operator|->
name|w_next
control|)
if|if
condition|(
name|prev
operator|->
name|w_next
operator|==
name|w
condition|)
block|{
name|prev
operator|->
name|w_next
operator|=
name|w
operator|->
name|w_next
expr_stmt|;
break|break;
block|}
name|free
argument_list|(
name|w
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int32_t
name|pow_w
parameter_list|(
name|struct
name|wtab
modifier|*
name|w
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|;
name|int32_t
name|val
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|w
operator|->
name|w_param_max
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|val
operator|=
literal|1
operator|<<
name|FP_SHIFT
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return
operator|(
name|val
operator|)
return|;
name|bit
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
name|n
operator|&
name|bit
condition|)
block|{
name|val
operator|=
operator|(
name|val
operator|*
name|w
operator|->
name|w_tab
index|[
name|i
index|]
operator|)
operator|>>
name|FP_SHIFT
expr_stmt|;
name|n
operator|&=
operator|~
name|bit
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|bit
operator|<<=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_comment
comment|/*  * red device interface  */
end_comment

begin_expr_stmt
name|altqdev_decl
argument_list|(
name|red
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|redopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
comment|/* everything will be done when the queueing scheme is attached. */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|redclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|red_queue_t
modifier|*
name|rqp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|rqp
operator|=
name|red_list
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* destroy all */
name|err
operator|=
name|red_detach
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|redioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|red_queue_t
modifier|*
name|rqp
decl_stmt|;
name|struct
name|red_interface
modifier|*
name|ifacep
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* check super-user privilege */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RED_GETSTATS
case|:
break|break;
default|default:
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|700000
operator|)
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|p
argument_list|,
name|PRIV_ALTQ_MANAGE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
empty|#elsif (__FreeBSD_version> 400000)
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|RED_ENABLE
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|red_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|red_ifname
argument_list|,
name|ALTQT_RED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|altq_enable
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
expr_stmt|;
break|break;
case|case
name|RED_DISABLE
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|red_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|red_ifname
argument_list|,
name|ALTQT_RED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|altq_disable
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
expr_stmt|;
break|break;
case|case
name|RED_IF_ATTACH
case|:
name|ifp
operator|=
name|ifunit
argument_list|(
operator|(
operator|(
expr|struct
name|red_interface
operator|*
operator|)
name|addr
operator|)
operator|->
name|red_ifname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENXIO
expr_stmt|;
break|break;
block|}
comment|/* allocate and initialize red_queue_t */
name|rqp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|red_queue_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|rqp
argument_list|,
sizeof|sizeof
argument_list|(
name|red_queue_t
argument_list|)
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq_q
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|class_queue_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|rq_q
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|bzero
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
sizeof|sizeof
argument_list|(
name|class_queue_t
argument_list|)
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq_red
operator|=
name|red_alloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rqp
operator|->
name|rq_red
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|rqp
operator|->
name|rq_ifq
operator|=
operator|&
name|ifp
operator|->
name|if_snd
expr_stmt|;
name|qtail
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|qlen
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
literal|0
expr_stmt|;
name|qlimit
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|RED_LIMIT
expr_stmt|;
name|qtype
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|Q_RED
expr_stmt|;
comment|/* 		 * set RED to this ifnet structure. 		 */
name|error
operator|=
name|altq_attach
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|,
name|ALTQT_RED
argument_list|,
name|rqp
argument_list|,
name|red_enqueue
argument_list|,
name|red_dequeue
argument_list|,
name|red_request
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|red_destroy
argument_list|(
name|rqp
operator|->
name|rq_red
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* add this state to the red list */
name|rqp
operator|->
name|rq_next
operator|=
name|red_list
expr_stmt|;
name|red_list
operator|=
name|rqp
expr_stmt|;
break|break;
case|case
name|RED_IF_DETACH
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|red_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|red_ifname
argument_list|,
name|ALTQT_RED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|red_detach
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
break|break;
case|case
name|RED_GETSTATS
case|:
do|do
block|{
name|struct
name|red_stats
modifier|*
name|q_stats
decl_stmt|;
name|red_t
modifier|*
name|rp
decl_stmt|;
name|q_stats
operator|=
operator|(
expr|struct
name|red_stats
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|q_stats
operator|->
name|iface
operator|.
name|red_ifname
argument_list|,
name|ALTQT_RED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|q_stats
operator|->
name|q_len
operator|=
name|qlen
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
name|q_stats
operator|->
name|q_limit
operator|=
name|qlimit
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
name|rp
operator|=
name|rqp
operator|->
name|rq_red
expr_stmt|;
name|q_stats
operator|->
name|q_avg
operator|=
name|rp
operator|->
name|red_avg
operator|>>
name|rp
operator|->
name|red_wshift
expr_stmt|;
name|q_stats
operator|->
name|xmit_cnt
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|xmit_cnt
expr_stmt|;
name|q_stats
operator|->
name|drop_cnt
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|drop_cnt
expr_stmt|;
name|q_stats
operator|->
name|drop_forced
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|drop_forced
expr_stmt|;
name|q_stats
operator|->
name|drop_unforced
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|drop_unforced
expr_stmt|;
name|q_stats
operator|->
name|marked_packets
operator|=
name|rp
operator|->
name|red_stats
operator|.
name|marked_packets
expr_stmt|;
name|q_stats
operator|->
name|weight
operator|=
name|rp
operator|->
name|red_weight
expr_stmt|;
name|q_stats
operator|->
name|inv_pmax
operator|=
name|rp
operator|->
name|red_inv_pmax
expr_stmt|;
name|q_stats
operator|->
name|th_min
operator|=
name|rp
operator|->
name|red_thmin
expr_stmt|;
name|q_stats
operator|->
name|th_max
operator|=
name|rp
operator|->
name|red_thmax
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
if|if
condition|(
name|rp
operator|->
name|red_flowvalve
operator|!=
name|NULL
condition|)
block|{
name|struct
name|flowvalve
modifier|*
name|fv
init|=
name|rp
operator|->
name|red_flowvalve
decl_stmt|;
name|q_stats
operator|->
name|fv_flows
operator|=
name|fv
operator|->
name|fv_flows
expr_stmt|;
name|q_stats
operator|->
name|fv_pass
operator|=
name|fv
operator|->
name|fv_stats
operator|.
name|pass
expr_stmt|;
name|q_stats
operator|->
name|fv_predrop
operator|=
name|fv
operator|->
name|fv_stats
operator|.
name|predrop
expr_stmt|;
name|q_stats
operator|->
name|fv_alloc
operator|=
name|fv
operator|->
name|fv_stats
operator|.
name|alloc
expr_stmt|;
name|q_stats
operator|->
name|fv_escape
operator|=
name|fv
operator|->
name|fv_stats
operator|.
name|escape
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* ALTQ_FLOWVALVE */
name|q_stats
operator|->
name|fv_flows
operator|=
literal|0
expr_stmt|;
name|q_stats
operator|->
name|fv_pass
operator|=
literal|0
expr_stmt|;
name|q_stats
operator|->
name|fv_predrop
operator|=
literal|0
expr_stmt|;
name|q_stats
operator|->
name|fv_alloc
operator|=
literal|0
expr_stmt|;
name|q_stats
operator|->
name|fv_escape
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
block|}
endif|#
directive|endif
comment|/* ALTQ_FLOWVALVE */
block|}
do|while
condition|(
comment|/*CONSTCOND*/
literal|0
condition|)
do|;
break|break;
case|case
name|RED_CONFIG
case|:
do|do
block|{
name|struct
name|red_conf
modifier|*
name|fc
decl_stmt|;
name|red_t
modifier|*
name|new
decl_stmt|;
name|int
name|s
decl_stmt|,
name|limit
decl_stmt|;
name|fc
operator|=
operator|(
expr|struct
name|red_conf
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|rqp
operator|=
name|altq_lookup
argument_list|(
name|fc
operator|->
name|iface
operator|.
name|red_ifname
argument_list|,
name|ALTQT_RED
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
name|new
operator|=
name|red_alloc
argument_list|(
name|fc
operator|->
name|red_weight
argument_list|,
name|fc
operator|->
name|red_inv_pmax
argument_list|,
name|fc
operator|->
name|red_thmin
argument_list|,
name|fc
operator|->
name|red_thmax
argument_list|,
name|fc
operator|->
name|red_flags
argument_list|,
name|fc
operator|->
name|red_pkttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|red_purgeq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
name|limit
operator|=
name|fc
operator|->
name|red_limit
expr_stmt|;
if|if
condition|(
name|limit
operator|<
name|fc
operator|->
name|red_thmax
condition|)
name|limit
operator|=
name|fc
operator|->
name|red_thmax
expr_stmt|;
name|qlimit
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
operator|=
name|limit
expr_stmt|;
name|fc
operator|->
name|red_limit
operator|=
name|limit
expr_stmt|;
comment|/* write back the new value */
name|red_destroy
argument_list|(
name|rqp
operator|->
name|rq_red
argument_list|)
expr_stmt|;
name|rqp
operator|->
name|rq_red
operator|=
name|new
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* write back new values */
name|fc
operator|->
name|red_limit
operator|=
name|limit
expr_stmt|;
name|fc
operator|->
name|red_inv_pmax
operator|=
name|rqp
operator|->
name|rq_red
operator|->
name|red_inv_pmax
expr_stmt|;
name|fc
operator|->
name|red_thmin
operator|=
name|rqp
operator|->
name|rq_red
operator|->
name|red_thmin
expr_stmt|;
name|fc
operator|->
name|red_thmax
operator|=
name|rqp
operator|->
name|rq_red
operator|->
name|red_thmax
expr_stmt|;
block|}
do|while
condition|(
comment|/*CONSTCOND*/
literal|0
condition|)
do|;
break|break;
case|case
name|RED_SETDEFAULTS
case|:
do|do
block|{
name|struct
name|redparams
modifier|*
name|rp
decl_stmt|;
name|rp
operator|=
operator|(
expr|struct
name|redparams
operator|*
operator|)
name|addr
expr_stmt|;
name|default_th_min
operator|=
name|rp
operator|->
name|th_min
expr_stmt|;
name|default_th_max
operator|=
name|rp
operator|->
name|th_max
expr_stmt|;
name|default_inv_pmax
operator|=
name|rp
operator|->
name|inv_pmax
expr_stmt|;
block|}
do|while
condition|(
comment|/*CONSTCOND*/
literal|0
condition|)
do|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|red_detach
parameter_list|(
name|rqp
parameter_list|)
name|red_queue_t
modifier|*
name|rqp
decl_stmt|;
block|{
name|red_queue_t
modifier|*
name|tmp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
condition|)
name|altq_disable
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|altq_detach
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|red_list
operator|==
name|rqp
condition|)
name|red_list
operator|=
name|rqp
operator|->
name|rq_next
expr_stmt|;
else|else
block|{
for|for
control|(
name|tmp
operator|=
name|red_list
init|;
name|tmp
operator|!=
name|NULL
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|rq_next
control|)
if|if
condition|(
name|tmp
operator|->
name|rq_next
operator|==
name|rqp
condition|)
block|{
name|tmp
operator|->
name|rq_next
operator|=
name|rqp
operator|->
name|rq_next
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"red_detach: no state found in red_list!\n"
argument_list|)
expr_stmt|;
block|}
name|red_destroy
argument_list|(
name|rqp
operator|->
name|rq_red
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|rqp
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * enqueue routine:  *  *	returns: 0 when successfully queued.  *		 ENOBUFS when drop occurs.  */
end_comment

begin_function
specifier|static
name|int
name|red_enqueue
parameter_list|(
name|ifq
parameter_list|,
name|m
parameter_list|,
name|pktattr
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|altq_pktattr
modifier|*
name|pktattr
decl_stmt|;
block|{
name|red_queue_t
modifier|*
name|rqp
init|=
operator|(
name|red_queue_t
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|IFQ_LOCK_ASSERT
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|red_addq
argument_list|(
name|rqp
operator|->
name|rq_red
argument_list|,
name|rqp
operator|->
name|rq_q
argument_list|,
name|m
argument_list|,
name|pktattr
argument_list|)
operator|<
literal|0
condition|)
return|return
name|ENOBUFS
return|;
name|ifq
operator|->
name|ifq_len
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * dequeue routine:  *	must be called in splimp.  *  *	returns: mbuf dequeued.  *		 NULL when no packet is available in the queue.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|red_dequeue
parameter_list|(
name|ifq
parameter_list|,
name|op
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|int
name|op
decl_stmt|;
block|{
name|red_queue_t
modifier|*
name|rqp
init|=
operator|(
name|red_queue_t
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|IFQ_LOCK_ASSERT
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|ALTDQ_POLL
condition|)
return|return
name|qhead
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
return|;
comment|/* op == ALTDQ_REMOVE */
name|m
operator|=
name|red_getq
argument_list|(
name|rqp
operator|->
name|rq_red
argument_list|,
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|NULL
condition|)
name|ifq
operator|->
name|ifq_len
operator|--
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|red_request
parameter_list|(
name|ifq
parameter_list|,
name|req
parameter_list|,
name|arg
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|int
name|req
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
block|{
name|red_queue_t
modifier|*
name|rqp
init|=
operator|(
name|red_queue_t
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|IFQ_LOCK_ASSERT
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|ALTRQ_PURGE
case|:
name|red_purgeq
argument_list|(
name|rqp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|red_purgeq
parameter_list|(
name|rqp
parameter_list|)
name|red_queue_t
modifier|*
name|rqp
decl_stmt|;
block|{
name|_flushq
argument_list|(
name|rqp
operator|->
name|rq_q
argument_list|)
expr_stmt|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|rqp
operator|->
name|rq_ifq
argument_list|)
condition|)
name|rqp
operator|->
name|rq_ifq
operator|->
name|ifq_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_FLOWVALVE
end_ifdef

begin_define
define|#
directive|define
name|FV_PSHIFT
value|7
end_define

begin_comment
comment|/* weight of average drop rate -- 1/128 */
end_comment

begin_define
define|#
directive|define
name|FV_PSCALE
parameter_list|(
name|x
parameter_list|)
value|((x)<< FV_PSHIFT)
end_define

begin_define
define|#
directive|define
name|FV_PUNSCALE
parameter_list|(
name|x
parameter_list|)
value|((x)>> FV_PSHIFT)
end_define

begin_define
define|#
directive|define
name|FV_FSHIFT
value|5
end_define

begin_comment
comment|/* weight of average fraction -- 1/32 */
end_comment

begin_define
define|#
directive|define
name|FV_FSCALE
parameter_list|(
name|x
parameter_list|)
value|((x)<< FV_FSHIFT)
end_define

begin_define
define|#
directive|define
name|FV_FUNSCALE
parameter_list|(
name|x
parameter_list|)
value|((x)>> FV_FSHIFT)
end_define

begin_define
define|#
directive|define
name|FV_TIMER
value|(3 * hz)
end_define

begin_comment
comment|/* timer value for garbage collector */
end_comment

begin_define
define|#
directive|define
name|FV_FLOWLISTSIZE
value|64
end_define

begin_comment
comment|/* how many flows in flowlist */
end_comment

begin_define
define|#
directive|define
name|FV_N
value|10
end_define

begin_comment
comment|/* update fve_f every FV_N packets */
end_comment

begin_define
define|#
directive|define
name|FV_BACKOFFTHRESH
value|1
end_define

begin_comment
comment|/* backoff threshold interval in second */
end_comment

begin_define
define|#
directive|define
name|FV_TTHRESH
value|3
end_define

begin_comment
comment|/* time threshold to delete fve */
end_comment

begin_define
define|#
directive|define
name|FV_ALPHA
value|5
end_define

begin_comment
comment|/* extra packet count */
end_comment

begin_define
define|#
directive|define
name|FV_STATS
end_define

begin_if
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|300000
operator|)
end_if

begin_define
define|#
directive|define
name|FV_TIMESTAMP
parameter_list|(
name|tp
parameter_list|)
value|getmicrotime(tp)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FV_TIMESTAMP
parameter_list|(
name|tp
parameter_list|)
value|{ (*(tp)) = time; }
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Brtt table: 127 entry table to convert drop rate (p) to  * the corresponding bandwidth fraction (f)  * the following equation is implemented to use scaled values,  * fve_p and fve_f, in the fixed point format.  *  *   Brtt(p) = 1 /(sqrt(4*p/3) + min(1,3*sqrt(p*6/8)) * p * (1+32 * p*p))  *   f = Brtt(p) / (max_th + alpha)  */
end_comment

begin_define
define|#
directive|define
name|BRTT_SIZE
value|128
end_define

begin_define
define|#
directive|define
name|BRTT_SHIFT
value|12
end_define

begin_define
define|#
directive|define
name|BRTT_MASK
value|0x0007f000
end_define

begin_define
define|#
directive|define
name|BRTT_PMAX
value|(1<< (FV_PSHIFT + FP_SHIFT))
end_define

begin_decl_stmt
specifier|const
name|int
name|brtt_tab
index|[
name|BRTT_SIZE
index|]
init|=
block|{
literal|0
block|,
literal|1262010
block|,
literal|877019
block|,
literal|703694
block|,
literal|598706
block|,
literal|525854
block|,
literal|471107
block|,
literal|427728
block|,
literal|392026
block|,
literal|361788
block|,
literal|335598
block|,
literal|312506
block|,
literal|291850
block|,
literal|273158
block|,
literal|256081
block|,
literal|240361
block|,
literal|225800
block|,
literal|212247
block|,
literal|199585
block|,
literal|187788
block|,
literal|178388
block|,
literal|169544
block|,
literal|161207
block|,
literal|153333
block|,
literal|145888
block|,
literal|138841
block|,
literal|132165
block|,
literal|125836
block|,
literal|119834
block|,
literal|114141
block|,
literal|108739
block|,
literal|103612
block|,
literal|98747
block|,
literal|94129
block|,
literal|89746
block|,
literal|85585
block|,
literal|81637
block|,
literal|77889
block|,
literal|74333
block|,
literal|70957
block|,
literal|67752
block|,
literal|64711
block|,
literal|61824
block|,
literal|59084
block|,
literal|56482
block|,
literal|54013
block|,
literal|51667
block|,
literal|49440
block|,
literal|47325
block|,
literal|45315
block|,
literal|43406
block|,
literal|41591
block|,
literal|39866
block|,
literal|38227
block|,
literal|36667
block|,
literal|35184
block|,
literal|33773
block|,
literal|32430
block|,
literal|31151
block|,
literal|29933
block|,
literal|28774
block|,
literal|27668
block|,
literal|26615
block|,
literal|25611
block|,
literal|24653
block|,
literal|23740
block|,
literal|22868
block|,
literal|22035
block|,
literal|21240
block|,
literal|20481
block|,
literal|19755
block|,
literal|19062
block|,
literal|18399
block|,
literal|17764
block|,
literal|17157
block|,
literal|16576
block|,
literal|16020
block|,
literal|15487
block|,
literal|14976
block|,
literal|14487
block|,
literal|14017
block|,
literal|13567
block|,
literal|13136
block|,
literal|12721
block|,
literal|12323
block|,
literal|11941
block|,
literal|11574
block|,
literal|11222
block|,
literal|10883
block|,
literal|10557
block|,
literal|10243
block|,
literal|9942
block|,
literal|9652
block|,
literal|9372
block|,
literal|9103
block|,
literal|8844
block|,
literal|8594
block|,
literal|8354
block|,
literal|8122
block|,
literal|7898
block|,
literal|7682
block|,
literal|7474
block|,
literal|7273
block|,
literal|7079
block|,
literal|6892
block|,
literal|6711
block|,
literal|6536
block|,
literal|6367
block|,
literal|6204
block|,
literal|6046
block|,
literal|5893
block|,
literal|5746
block|,
literal|5603
block|,
literal|5464
block|,
literal|5330
block|,
literal|5201
block|,
literal|5075
block|,
literal|4954
block|,
literal|4836
block|,
literal|4722
block|,
literal|4611
block|,
literal|4504
block|,
literal|4400
block|,
literal|4299
block|,
literal|4201
block|,
literal|4106
block|,
literal|4014
block|,
literal|3924
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|fve
operator|*
name|flowlist_lookup
argument_list|(
argument|fv
argument_list|,
argument|pktattr
argument_list|,
argument|now
argument_list|)
expr|struct
name|flowvalve
operator|*
name|fv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|altq_pktattr
modifier|*
name|pktattr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|now
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|fve
modifier|*
name|fve
decl_stmt|;
name|int
name|flows
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
name|struct
name|timeval
name|tthresh
decl_stmt|;
if|if
condition|(
name|pktattr
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|tthresh
operator|.
name|tv_sec
operator|=
name|now
operator|->
name|tv_sec
operator|-
name|FV_TTHRESH
expr_stmt|;
name|flows
operator|=
literal|0
expr_stmt|;
comment|/* 	 * search the flow list 	 */
switch|switch
condition|(
name|pktattr
operator|->
name|pattr_af
condition|)
block|{
case|case
name|AF_INET
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|pktattr
operator|->
name|pattr_hdr
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|fve
argument_list|,
argument|&fv->fv_flowlist
argument_list|,
argument|fve_lru
argument_list|)
block|{
if|if
condition|(
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|<
name|tthresh
operator|.
name|tv_sec
condition|)
block|{
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fve
operator|->
name|fve_flow
operator|.
name|flow_af
operator|==
name|AF_INET
operator|&&
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip
operator|.
name|ip_src
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_src
operator|.
name|s_addr
operator|&&
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip
operator|.
name|ip_dst
operator|.
name|s_addr
operator|==
name|ip
operator|->
name|ip_dst
operator|.
name|s_addr
condition|)
return|return
operator|(
name|fve
operator|)
return|;
name|flows
operator|++
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|pktattr
operator|->
name|pattr_hdr
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|fve
argument_list|,
argument|&fv->fv_flowlist
argument_list|,
argument|fve_lru
argument_list|)
block|{
if|if
condition|(
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|<
name|tthresh
operator|.
name|tv_sec
condition|)
block|{
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fve
operator|->
name|fve_flow
operator|.
name|flow_af
operator|==
name|AF_INET6
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip6
operator|.
name|ip6_src
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_src
argument_list|)
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip6
operator|.
name|ip6_dst
argument_list|,
operator|&
name|ip6
operator|->
name|ip6_dst
argument_list|)
condition|)
return|return
operator|(
name|fve
operator|)
return|;
name|flows
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* INET6 */
default|default:
comment|/* unknown protocol.  no drop. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fv
operator|->
name|fv_flows
operator|=
name|flows
expr_stmt|;
comment|/* save the number of active fve's */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|fve
operator|*
name|flowlist_reclaim
argument_list|(
argument|fv
argument_list|,
argument|pktattr
argument_list|)
expr|struct
name|flowvalve
operator|*
name|fv
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|altq_pktattr
modifier|*
name|pktattr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|fve
modifier|*
name|fve
decl_stmt|;
name|struct
name|ip
modifier|*
name|ip
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|ip6_hdr
modifier|*
name|ip6
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * get an entry from the tail of the LRU list. 	 */
name|fve
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|fv
operator|->
name|fv_flowlist
argument_list|,
name|fv_flowhead
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pktattr
operator|->
name|pattr_af
condition|)
block|{
case|case
name|AF_INET
case|:
name|ip
operator|=
operator|(
expr|struct
name|ip
operator|*
operator|)
name|pktattr
operator|->
name|pattr_hdr
expr_stmt|;
name|fve
operator|->
name|fve_flow
operator|.
name|flow_af
operator|=
name|AF_INET
expr_stmt|;
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip
operator|.
name|ip_src
operator|=
name|ip
operator|->
name|ip_src
expr_stmt|;
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip
operator|.
name|ip_dst
operator|=
name|ip
operator|->
name|ip_dst
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|ip6
operator|=
operator|(
expr|struct
name|ip6_hdr
operator|*
operator|)
name|pktattr
operator|->
name|pattr_hdr
expr_stmt|;
name|fve
operator|->
name|fve_flow
operator|.
name|flow_af
operator|=
name|AF_INET6
expr_stmt|;
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip6
operator|.
name|ip6_src
operator|=
name|ip6
operator|->
name|ip6_src
expr_stmt|;
name|fve
operator|->
name|fve_flow
operator|.
name|flow_ip6
operator|.
name|ip6_dst
operator|=
name|ip6
operator|->
name|ip6_dst
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|fve
operator|->
name|fve_state
operator|=
name|Green
expr_stmt|;
name|fve
operator|->
name|fve_p
operator|=
literal|0.0
expr_stmt|;
name|fve
operator|->
name|fve_f
operator|=
literal|0.0
expr_stmt|;
name|fve
operator|->
name|fve_ifseq
operator|=
name|fv
operator|->
name|fv_ifseq
operator|-
literal|1
expr_stmt|;
name|fve
operator|->
name|fve_count
operator|=
literal|0
expr_stmt|;
name|fv
operator|->
name|fv_flows
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|FV_STATS
name|fv
operator|->
name|fv_stats
operator|.
name|alloc
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|fve
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|__inline
name|void
name|flowlist_move_to_head
parameter_list|(
name|fv
parameter_list|,
name|fve
parameter_list|)
name|struct
name|flowvalve
modifier|*
name|fv
decl_stmt|;
name|struct
name|fve
modifier|*
name|fve
decl_stmt|;
block|{
if|if
condition|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|fv
operator|->
name|fv_flowlist
argument_list|)
operator|!=
name|fve
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|fv
operator|->
name|fv_flowlist
argument_list|,
name|fve
argument_list|,
name|fve_lru
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|fv
operator|->
name|fv_flowlist
argument_list|,
name|fve
argument_list|,
name|fve_lru
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX: make the compiler happy (fv_alloc unused) */
end_comment

begin_comment
comment|/*  * allocate flowvalve structure  */
end_comment

begin_comment
unit|static struct flowvalve * fv_alloc(rp) 	struct red *rp; { 	struct flowvalve *fv; 	struct fve *fve; 	int i, num;  	num = FV_FLOWLISTSIZE; 	fv = malloc(sizeof(struct flowvalve), 	       M_DEVBUF, M_WAITOK); 	if (fv == NULL) 		return (NULL); 	bzero(fv, sizeof(struct flowvalve));  	fv->fv_fves = malloc(sizeof(struct fve) * num, 	       M_DEVBUF, M_WAITOK); 	if (fv->fv_fves == NULL) { 		free(fv, M_DEVBUF); 		return (NULL); 	} 	bzero(fv->fv_fves, sizeof(struct fve) * num);  	fv->fv_flows = 0; 	TAILQ_INIT(&fv->fv_flowlist); 	for (i = 0; i< num; i++) { 		fve =&fv->fv_fves[i]; 		fve->fve_lastdrop.tv_sec = 0; 		TAILQ_INSERT_TAIL(&fv->fv_flowlist, fve, fve_lru); 	}
comment|/* initialize drop rate threshold in scaled fixed-point */
end_comment

begin_comment
unit|fv->fv_pthresh = (FV_PSCALE(1)<< FP_SHIFT) / rp->red_inv_pmax;
comment|/* initialize drop rate to fraction table */
end_comment

begin_comment
unit|fv->fv_p2ftab = malloc(sizeof(int) * BRTT_SIZE, 	       M_DEVBUF, M_WAITOK); 	if (fv->fv_p2ftab == NULL) { 		free(fv->fv_fves, M_DEVBUF); 		free(fv, M_DEVBUF); 		return (NULL); 	}
comment|/* 	 * create the p2f table. 	 * (shift is used to keep the precision) 	 */
end_comment

begin_endif
unit|for (i = 1; i< BRTT_SIZE; i++) { 		int f;  		f = brtt_tab[i]<< 8; 		fv->fv_p2ftab[i] = (f / (rp->red_thmax + FV_ALPHA))>> 8; 	}  	return (fv); }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|fv_destroy
parameter_list|(
name|fv
parameter_list|)
name|struct
name|flowvalve
modifier|*
name|fv
decl_stmt|;
block|{
name|free
argument_list|(
name|fv
operator|->
name|fv_p2ftab
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fv
operator|->
name|fv_fves
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fv
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|fv_p2f
parameter_list|(
name|fv
parameter_list|,
name|p
parameter_list|)
name|struct
name|flowvalve
modifier|*
name|fv
decl_stmt|;
name|int
name|p
decl_stmt|;
block|{
name|int
name|val
decl_stmt|,
name|f
decl_stmt|;
if|if
condition|(
name|p
operator|>=
name|BRTT_PMAX
condition|)
name|f
operator|=
name|fv
operator|->
name|fv_p2ftab
index|[
name|BRTT_SIZE
operator|-
literal|1
index|]
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|=
operator|(
name|p
operator|&
name|BRTT_MASK
operator|)
operator|)
condition|)
name|f
operator|=
name|fv
operator|->
name|fv_p2ftab
index|[
operator|(
name|val
operator|>>
name|BRTT_SHIFT
operator|)
index|]
expr_stmt|;
else|else
name|f
operator|=
name|fv
operator|->
name|fv_p2ftab
index|[
literal|1
index|]
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * check if an arriving packet should be pre-dropped.  * called from red_addq() when a packet arrives.  * returns 1 when the packet should be pre-dropped.  * should be called in splimp.  */
end_comment

begin_function
specifier|static
name|int
name|fv_checkflow
parameter_list|(
name|fv
parameter_list|,
name|pktattr
parameter_list|,
name|fcache
parameter_list|)
name|struct
name|flowvalve
modifier|*
name|fv
decl_stmt|;
name|struct
name|altq_pktattr
modifier|*
name|pktattr
decl_stmt|;
name|struct
name|fve
modifier|*
modifier|*
name|fcache
decl_stmt|;
block|{
name|struct
name|fve
modifier|*
name|fve
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
name|fv
operator|->
name|fv_ifseq
operator|++
expr_stmt|;
name|FV_TIMESTAMP
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fve
operator|=
name|flowlist_lookup
argument_list|(
name|fv
argument_list|,
name|pktattr
argument_list|,
operator|&
name|now
argument_list|)
operator|)
operator|==
name|NULL
condition|)
comment|/* no matching entry in the flowlist */
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|fcache
operator|=
name|fve
expr_stmt|;
comment|/* update fraction f for every FV_N packets */
if|if
condition|(
operator|++
name|fve
operator|->
name|fve_count
operator|==
name|FV_N
condition|)
block|{
comment|/* 		 * f = Wf * N / (fv_ifseq - fve_ifseq) + (1 - Wf) * f 		 */
name|fve
operator|->
name|fve_f
operator|=
operator|(
name|FV_N
operator|<<
name|FP_SHIFT
operator|)
operator|/
operator|(
name|fv
operator|->
name|fv_ifseq
operator|-
name|fve
operator|->
name|fve_ifseq
operator|)
operator|+
name|fve
operator|->
name|fve_f
operator|-
name|FV_FUNSCALE
argument_list|(
name|fve
operator|->
name|fve_f
argument_list|)
expr_stmt|;
name|fve
operator|->
name|fve_ifseq
operator|=
name|fv
operator|->
name|fv_ifseq
expr_stmt|;
name|fve
operator|->
name|fve_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * overpumping test 	 */
if|if
condition|(
name|fve
operator|->
name|fve_state
operator|==
name|Green
operator|&&
name|fve
operator|->
name|fve_p
operator|>
name|fv
operator|->
name|fv_pthresh
condition|)
block|{
name|int
name|fthresh
decl_stmt|;
comment|/* calculate a threshold */
name|fthresh
operator|=
name|fv_p2f
argument_list|(
name|fv
argument_list|,
name|fve
operator|->
name|fve_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|fve
operator|->
name|fve_f
operator|>
name|fthresh
condition|)
name|fve
operator|->
name|fve_state
operator|=
name|Red
expr_stmt|;
block|}
if|if
condition|(
name|fve
operator|->
name|fve_state
operator|==
name|Red
condition|)
block|{
comment|/* 		 * backoff test 		 */
if|if
condition|(
name|now
operator|.
name|tv_sec
operator|-
name|fve
operator|->
name|fve_lastdrop
operator|.
name|tv_sec
operator|>
name|FV_BACKOFFTHRESH
condition|)
block|{
comment|/* no drop for at least FV_BACKOFFTHRESH sec */
name|fve
operator|->
name|fve_p
operator|=
literal|0
expr_stmt|;
name|fve
operator|->
name|fve_state
operator|=
name|Green
expr_stmt|;
ifdef|#
directive|ifdef
name|FV_STATS
name|fv
operator|->
name|fv_stats
operator|.
name|escape
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* block this flow */
name|flowlist_move_to_head
argument_list|(
name|fv
argument_list|,
name|fve
argument_list|)
expr_stmt|;
name|fve
operator|->
name|fve_lastdrop
operator|=
name|now
expr_stmt|;
ifdef|#
directive|ifdef
name|FV_STATS
name|fv
operator|->
name|fv_stats
operator|.
name|predrop
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * p = (1 - Wp) * p 	 */
name|fve
operator|->
name|fve_p
operator|-=
name|FV_PUNSCALE
argument_list|(
name|fve
operator|->
name|fve_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|fve
operator|->
name|fve_p
operator|<
literal|0
condition|)
name|fve
operator|->
name|fve_p
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|FV_STATS
name|fv
operator|->
name|fv_stats
operator|.
name|pass
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * called from red_addq when a packet is dropped by red.  * should be called in splimp.  */
end_comment

begin_function
specifier|static
name|void
name|fv_dropbyred
parameter_list|(
name|fv
parameter_list|,
name|pktattr
parameter_list|,
name|fcache
parameter_list|)
name|struct
name|flowvalve
modifier|*
name|fv
decl_stmt|;
name|struct
name|altq_pktattr
modifier|*
name|pktattr
decl_stmt|;
name|struct
name|fve
modifier|*
name|fcache
decl_stmt|;
block|{
name|struct
name|fve
modifier|*
name|fve
decl_stmt|;
name|struct
name|timeval
name|now
decl_stmt|;
if|if
condition|(
name|pktattr
operator|==
name|NULL
condition|)
return|return;
name|FV_TIMESTAMP
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcache
operator|!=
name|NULL
condition|)
comment|/* the fve of this packet is already cached */
name|fve
operator|=
name|fcache
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|fve
operator|=
name|flowlist_lookup
argument_list|(
name|fv
argument_list|,
name|pktattr
argument_list|,
operator|&
name|now
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fve
operator|=
name|flowlist_reclaim
argument_list|(
name|fv
argument_list|,
name|pktattr
argument_list|)
expr_stmt|;
name|flowlist_move_to_head
argument_list|(
name|fv
argument_list|,
name|fve
argument_list|)
expr_stmt|;
comment|/* 	 * update p:  the following line cancels the update 	 *	      in fv_checkflow() and calculate 	 *	p = Wp + (1 - Wp) * p 	 */
name|fve
operator|->
name|fve_p
operator|=
operator|(
literal|1
operator|<<
name|FP_SHIFT
operator|)
operator|+
name|fve
operator|->
name|fve_p
expr_stmt|;
name|fve
operator|->
name|fve_lastdrop
operator|=
name|now
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_FLOWVALVE */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|KLD_MODULE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|altqsw
name|red_sw
init|=
block|{
literal|"red"
block|,
name|redopen
block|,
name|redclose
block|,
name|redioctl
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ALTQ_MODULE
argument_list|(
name|altq_red
argument_list|,
name|ALTQT_RED
argument_list|,
operator|&
name|red_sw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_VERSION
argument_list|(
name|altq_red
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KLD_MODULE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_RED */
end_comment

end_unit

