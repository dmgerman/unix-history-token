begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$KAME: altq_hfsc.c,v 1.24 2003/12/05 05:40:46 kjc Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1997-1999 Carnegie Mellon University. All Rights Reserved.  *  * Permission to use, copy, modify, and distribute this software and  * its documentation is hereby granted (including for commercial or  * for-profit use), provided that both the copyright notice and this  * permission notice appear in all copies of the software, derivative  * works, or modified versions, and any portions thereof.  *  * THIS SOFTWARE IS EXPERIMENTAL AND IS KNOWN TO HAVE BUGS, SOME OF  * WHICH MAY HAVE SERIOUS CONSEQUENCES.  CARNEGIE MELLON PROVIDES THIS  * SOFTWARE IN ITS ``AS IS'' CONDITION, AND ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL CARNEGIE MELLON UNIVERSITY BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT  * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH  * DAMAGE.  *  * Carnegie Mellon encourages (but does not require) users of this  * software to return any improvements or extensions that they make,  * and to grant Carnegie Mellon the rights to redistribute these  * changes without encumbrance.  */
end_comment

begin_comment
comment|/*  * H-FSC is described in Proceedings of SIGCOMM'97,  * "A Hierarchical Fair Service Curve Algorithm for Link-Sharing,  * Real-Time and Priority Service"  * by Ion Stoica, Hui Zhang, and T. S. Eugene Ng.  *  * Oleg Cherevko<olwi@aq.ml.com.ua> added the upperlimit for link-sharing.  * when a class has an upperlimit, the fit-time is computed from the  * upperlimit service curve.  the link-sharing scheduler does not schedule  * a class whose fit-time exceeds the current time.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_include
include|#
directive|include
file|"opt_altq.h"
end_include

begin_include
include|#
directive|include
file|"opt_inet.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_include
include|#
directive|include
file|"opt_inet6.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ || __NetBSD__ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ_HFSC
end_ifdef

begin_comment
comment|/* hfsc is enabled by ALTQ_HFSC option in opt_altq.h */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/malloc.h>
end_include

begin_include
include|#
directive|include
file|<sys/mbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_if
if|#
directive|if
literal|1
end_if

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_include
include|#
directive|include
file|<sys/sockio.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/kernel.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/pf.h>
end_include

begin_include
include|#
directive|include
file|<net/pf_altq.h>
end_include

begin_include
include|#
directive|include
file|<net/pf_mtag.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq.h>
end_include

begin_include
include|#
directive|include
file|<altq/altq_hfsc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_include
include|#
directive|include
file|<altq/altq_conf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * function prototypes  */
end_comment

begin_function_decl
specifier|static
name|int
name|hfsc_clear_interface
parameter_list|(
name|struct
name|hfsc_if
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsc_request
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hfsc_purge
parameter_list|(
name|struct
name|hfsc_if
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hfsc_class
modifier|*
name|hfsc_class_create
parameter_list|(
name|struct
name|hfsc_if
modifier|*
parameter_list|,
name|struct
name|service_curve
modifier|*
parameter_list|,
name|struct
name|service_curve
modifier|*
parameter_list|,
name|struct
name|service_curve
modifier|*
parameter_list|,
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsc_class_destroy
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hfsc_class
modifier|*
name|hfsc_nextclass
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsc_enqueue
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|hfsc_dequeue
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsc_addq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|struct
name|mbuf
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|hfsc_getq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|mbuf
modifier|*
name|hfsc_pollq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hfsc_purgeq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_cfmin
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_active
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_passive
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_ed
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_ed
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_d
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_vf
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_vf
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ellist_insert
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ellist_remove
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ellist_update
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|hfsc_class
modifier|*
name|hfsc_get_mindl
parameter_list|(
name|struct
name|hfsc_if
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|actlist_insert
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|actlist_remove
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|actlist_update
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hfsc_class
modifier|*
name|actlist_firstfit
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int64_t
name|seg_x2y
parameter_list|(
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int64_t
name|seg_y2x
parameter_list|(
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int64_t
name|m2sm
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int64_t
name|m2ism
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int64_t
name|d2dx
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|sm2m
parameter_list|(
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|dx2d
parameter_list|(
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|sc2isc
parameter_list|(
name|struct
name|service_curve
modifier|*
parameter_list|,
name|struct
name|internal_sc
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtsc_init
parameter_list|(
name|struct
name|runtime_sc
modifier|*
parameter_list|,
name|struct
name|internal_sc
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|rtsc_y2x
parameter_list|(
name|struct
name|runtime_sc
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|rtsc_x2y
parameter_list|(
name|struct
name|runtime_sc
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|rtsc_min
parameter_list|(
name|struct
name|runtime_sc
modifier|*
parameter_list|,
name|struct
name|internal_sc
modifier|*
parameter_list|,
name|u_int64_t
parameter_list|,
name|u_int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_class_stats
parameter_list|(
name|struct
name|hfsc_classstats
modifier|*
parameter_list|,
name|struct
name|hfsc_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hfsc_class
modifier|*
name|clh_to_clp
parameter_list|(
name|struct
name|hfsc_if
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_function_decl
specifier|static
name|struct
name|hfsc_if
modifier|*
name|hfsc_attach
parameter_list|(
name|struct
name|ifaltq
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsc_detach
parameter_list|(
name|struct
name|hfsc_if
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsc_class_modify
parameter_list|(
name|struct
name|hfsc_class
modifier|*
parameter_list|,
name|struct
name|service_curve
modifier|*
parameter_list|,
name|struct
name|service_curve
modifier|*
parameter_list|,
name|struct
name|service_curve
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_if_attach
parameter_list|(
name|struct
name|hfsc_attach
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_if_detach
parameter_list|(
name|struct
name|hfsc_interface
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_add_class
parameter_list|(
name|struct
name|hfsc_add_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_delete_class
parameter_list|(
name|struct
name|hfsc_delete_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_modify_class
parameter_list|(
name|struct
name|hfsc_modify_class
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_add_filter
parameter_list|(
name|struct
name|hfsc_add_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_delete_filter
parameter_list|(
name|struct
name|hfsc_delete_filter
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|hfsccmd_class_stats
parameter_list|(
name|struct
name|hfsc_class_stats
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|altqdev_decl
argument_list|(
name|hfsc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_comment
comment|/*  * macros  */
end_comment

begin_define
define|#
directive|define
name|is_a_parent_class
parameter_list|(
name|cl
parameter_list|)
value|((cl)->cl_children != NULL)
end_define

begin_define
define|#
directive|define
name|HT_INFINITY
value|0xffffffffffffffffLL
end_define

begin_comment
comment|/* infinite time value */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_comment
comment|/* hif_list keeps all hfsc_if's allocated. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|hfsc_if
modifier|*
name|hif_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_function
name|int
name|hfsc_pfattach
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|a
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|a
operator|->
name|altq_disc
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|altq_attach
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ALTQT_HFSC
argument_list|,
name|a
operator|->
name|altq_disc
argument_list|,
name|hfsc_enqueue
argument_list|,
name|hfsc_dequeue
argument_list|,
name|hfsc_request
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfsc_add_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|a
operator|->
name|ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|!
name|ALTQ_IS_READY
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|)
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
name|hif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hfsc_if
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|hif
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|)
expr_stmt|;
name|hif
operator|->
name|hif_ifq
operator|=
operator|&
name|ifp
operator|->
name|if_snd
expr_stmt|;
comment|/* keep the state in pf_altq */
name|a
operator|->
name|altq_disc
operator|=
name|hif
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfsc_remove_altq
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|a
operator|->
name|altq_disc
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|a
operator|->
name|altq_disc
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|hfsc_clear_interface
argument_list|(
name|hif
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hfsc_class_destroy
argument_list|(
name|hif
operator|->
name|hif_rootclass
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfsc_add_queue
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|hfsc_opts
modifier|*
name|opts
decl_stmt|;
name|struct
name|service_curve
name|rtsc
decl_stmt|,
name|lssc
decl_stmt|,
name|ulsc
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|a
operator|->
name|altq_disc
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|opts
operator|=
operator|&
name|a
operator|->
name|pq_u
operator|.
name|hfsc_opts
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|parent_qid
operator|==
name|HFSC_NULLCLASS_HANDLE
operator|&&
name|hif
operator|->
name|hif_rootclass
operator|==
name|NULL
condition|)
name|parent
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parent
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|a
operator|->
name|parent_qid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|a
operator|->
name|qid
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|a
operator|->
name|qid
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|rtsc
operator|.
name|m1
operator|=
name|opts
operator|->
name|rtsc_m1
expr_stmt|;
name|rtsc
operator|.
name|d
operator|=
name|opts
operator|->
name|rtsc_d
expr_stmt|;
name|rtsc
operator|.
name|m2
operator|=
name|opts
operator|->
name|rtsc_m2
expr_stmt|;
name|lssc
operator|.
name|m1
operator|=
name|opts
operator|->
name|lssc_m1
expr_stmt|;
name|lssc
operator|.
name|d
operator|=
name|opts
operator|->
name|lssc_d
expr_stmt|;
name|lssc
operator|.
name|m2
operator|=
name|opts
operator|->
name|lssc_m2
expr_stmt|;
name|ulsc
operator|.
name|m1
operator|=
name|opts
operator|->
name|ulsc_m1
expr_stmt|;
name|ulsc
operator|.
name|d
operator|=
name|opts
operator|->
name|ulsc_d
expr_stmt|;
name|ulsc
operator|.
name|m2
operator|=
name|opts
operator|->
name|ulsc_m2
expr_stmt|;
name|cl
operator|=
name|hfsc_class_create
argument_list|(
name|hif
argument_list|,
operator|&
name|rtsc
argument_list|,
operator|&
name|lssc
argument_list|,
operator|&
name|ulsc
argument_list|,
name|parent
argument_list|,
name|a
operator|->
name|qlimit
argument_list|,
name|opts
operator|->
name|flags
argument_list|,
name|a
operator|->
name|qid
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfsc_remove_queue
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|a
operator|->
name|altq_disc
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|cl
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|a
operator|->
name|qid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|hfsc_class_destroy
argument_list|(
name|cl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|hfsc_getqstats
parameter_list|(
name|struct
name|pf_altq
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|ubuf
parameter_list|,
name|int
modifier|*
name|nbytes
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|hfsc_classstats
name|stats
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|a
operator|->
name|ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
operator|(
name|cl
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|a
operator|->
name|qid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|*
name|nbytes
operator|<
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|get_class_stats
argument_list|(
operator|&
name|stats
argument_list|,
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stats
argument_list|,
name|ubuf
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * bring the interface back to the initial state by discarding  * all the filters and classes except the root class.  */
end_comment

begin_function
specifier|static
name|int
name|hfsc_clear_interface
parameter_list|(
name|struct
name|hfsc_if
modifier|*
name|hif
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
comment|/* free the filters for this interface */
name|acc_discard_filters
argument_list|(
operator|&
name|hif
operator|->
name|hif_classifier
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* clear out the classes */
while|while
condition|(
name|hif
operator|->
name|hif_rootclass
operator|!=
name|NULL
operator|&&
operator|(
name|cl
operator|=
name|hif
operator|->
name|hif_rootclass
operator|->
name|cl_children
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * remove the first leaf class found in the hierarchy 		 * then start over 		 */
for|for
control|(
init|;
name|cl
operator|!=
name|NULL
condition|;
name|cl
operator|=
name|hfsc_nextclass
argument_list|(
name|cl
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|is_a_parent_class
argument_list|(
name|cl
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|hfsc_class_destroy
argument_list|(
name|cl
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsc_request
parameter_list|(
name|struct
name|ifaltq
modifier|*
name|ifq
parameter_list|,
name|int
name|req
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
init|=
operator|(
expr|struct
name|hfsc_if
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|IFQ_LOCK_ASSERT
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|req
condition|)
block|{
case|case
name|ALTRQ_PURGE
case|:
name|hfsc_purge
argument_list|(
name|hif
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* discard all the queued packets on the interface */
end_comment

begin_function
specifier|static
name|void
name|hfsc_purge
parameter_list|(
name|struct
name|hfsc_if
modifier|*
name|hif
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
for|for
control|(
name|cl
operator|=
name|hif
operator|->
name|hif_rootclass
init|;
name|cl
operator|!=
name|NULL
condition|;
name|cl
operator|=
name|hfsc_nextclass
argument_list|(
name|cl
argument_list|)
control|)
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|hfsc_purgeq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
condition|)
name|hif
operator|->
name|hif_ifq
operator|->
name|ifq_len
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|hfsc_class
modifier|*
name|hfsc_class_create
parameter_list|(
name|struct
name|hfsc_if
modifier|*
name|hif
parameter_list|,
name|struct
name|service_curve
modifier|*
name|rsc
parameter_list|,
name|struct
name|service_curve
modifier|*
name|fsc
parameter_list|,
name|struct
name|service_curve
modifier|*
name|usc
parameter_list|,
name|struct
name|hfsc_class
modifier|*
name|parent
parameter_list|,
name|int
name|qlimit
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|qid
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|hif
operator|->
name|hif_classes
operator|>=
name|HFSC_MAX_CLASSES
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifndef|#
directive|ifndef
name|ALTQ_RED
if|if
condition|(
name|flags
operator|&
name|HFCF_RED
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|printf
argument_list|(
literal|"hfsc_class_create: RED not configured for HFSC!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
endif|#
directive|endif
name|cl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hfsc_class
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|cl
operator|->
name|cl_q
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|class_queue_t
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
operator||
name|M_ZERO
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_q
operator|==
name|NULL
condition|)
goto|goto
name|err_ret
goto|;
name|TAILQ_INIT
argument_list|(
operator|&
name|cl
operator|->
name|cl_actc
argument_list|)
expr_stmt|;
if|if
condition|(
name|qlimit
operator|==
literal|0
condition|)
name|qlimit
operator|=
literal|50
expr_stmt|;
comment|/* use default */
name|qlimit
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|=
name|qlimit
expr_stmt|;
name|qtype
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|=
name|Q_DROPTAIL
expr_stmt|;
name|qlen
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|cl_flags
operator|=
name|flags
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|flags
operator|&
operator|(
name|HFCF_RED
operator||
name|HFCF_RIO
operator|)
condition|)
block|{
name|int
name|red_flags
decl_stmt|,
name|red_pkttime
decl_stmt|;
name|u_int
name|m2
decl_stmt|;
name|m2
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rsc
operator|!=
name|NULL
operator|&&
name|rsc
operator|->
name|m2
operator|>
name|m2
condition|)
name|m2
operator|=
name|rsc
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|fsc
operator|!=
name|NULL
operator|&&
name|fsc
operator|->
name|m2
operator|>
name|m2
condition|)
name|m2
operator|=
name|fsc
operator|->
name|m2
expr_stmt|;
if|if
condition|(
name|usc
operator|!=
name|NULL
operator|&&
name|usc
operator|->
name|m2
operator|>
name|m2
condition|)
name|m2
operator|=
name|usc
operator|->
name|m2
expr_stmt|;
name|red_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HFCF_ECN
condition|)
name|red_flags
operator||=
name|REDF_ECN
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|flags
operator|&
name|HFCF_CLEARDSCP
condition|)
name|red_flags
operator||=
name|RIOF_CLEARDSCP
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|m2
operator|<
literal|8
condition|)
name|red_pkttime
operator|=
literal|1000
operator|*
literal|1000
operator|*
literal|1000
expr_stmt|;
comment|/* 1 sec */
else|else
name|red_pkttime
operator|=
operator|(
name|int64_t
operator|)
name|hif
operator|->
name|hif_ifq
operator|->
name|altq_ifp
operator|->
name|if_mtu
operator|*
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|/
operator|(
name|m2
operator|/
literal|8
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|HFCF_RED
condition|)
block|{
name|cl
operator|->
name|cl_red
operator|=
name|red_alloc
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|qlimit
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|*
literal|10
operator|/
literal|100
argument_list|,
name|qlimit
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|*
literal|30
operator|/
literal|100
argument_list|,
name|red_flags
argument_list|,
name|red_pkttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_red
operator|!=
name|NULL
condition|)
name|qtype
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|=
name|Q_RED
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ALTQ_RIO
else|else
block|{
name|cl
operator|->
name|cl_red
operator|=
operator|(
name|red_t
operator|*
operator|)
name|rio_alloc
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|,
name|red_flags
argument_list|,
name|red_pkttime
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_red
operator|!=
name|NULL
condition|)
name|qtype
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|=
name|Q_RIO
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* ALTQ_RED */
if|if
condition|(
name|rsc
operator|!=
name|NULL
operator|&&
operator|(
name|rsc
operator|->
name|m1
operator|!=
literal|0
operator|||
name|rsc
operator|->
name|m2
operator|!=
literal|0
operator|)
condition|)
block|{
name|cl
operator|->
name|cl_rsc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internal_sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|==
name|NULL
condition|)
goto|goto
name|err_ret
goto|;
name|sc2isc
argument_list|(
name|rsc
argument_list|,
name|cl
operator|->
name|cl_rsc
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_deadline
argument_list|,
name|cl
operator|->
name|cl_rsc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_eligible
argument_list|,
name|cl
operator|->
name|cl_rsc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fsc
operator|!=
name|NULL
operator|&&
operator|(
name|fsc
operator|->
name|m1
operator|!=
literal|0
operator|||
name|fsc
operator|->
name|m2
operator|!=
literal|0
operator|)
condition|)
block|{
name|cl
operator|->
name|cl_fsc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internal_sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|==
name|NULL
condition|)
goto|goto
name|err_ret
goto|;
name|sc2isc
argument_list|(
name|fsc
argument_list|,
name|cl
operator|->
name|cl_fsc
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_virtual
argument_list|,
name|cl
operator|->
name|cl_fsc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usc
operator|!=
name|NULL
operator|&&
operator|(
name|usc
operator|->
name|m1
operator|!=
literal|0
operator|||
name|usc
operator|->
name|m2
operator|!=
literal|0
operator|)
condition|)
block|{
name|cl
operator|->
name|cl_usc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internal_sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|==
name|NULL
condition|)
goto|goto
name|err_ret
goto|;
name|sc2isc
argument_list|(
name|usc
argument_list|,
name|cl
operator|->
name|cl_usc
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_ulimit
argument_list|,
name|cl
operator|->
name|cl_usc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|cl
operator|->
name|cl_id
operator|=
name|hif
operator|->
name|hif_classid
operator|++
expr_stmt|;
name|cl
operator|->
name|cl_handle
operator|=
name|qid
expr_stmt|;
name|cl
operator|->
name|cl_hif
operator|=
name|hif
expr_stmt|;
name|cl
operator|->
name|cl_parent
operator|=
name|parent
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
name|hif
operator|->
name|hif_classes
operator|++
expr_stmt|;
comment|/* 	 * find a free slot in the class table.  if the slot matching 	 * the lower bits of qid is free, use this slot.  otherwise, 	 * use the first free slot. 	 */
name|i
operator|=
name|qid
operator|%
name|HFSC_MAX_CLASSES
expr_stmt|;
if|if
condition|(
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|==
name|NULL
condition|)
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|=
name|cl
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HFSC_MAX_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|=
name|cl
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|HFSC_MAX_CLASSES
condition|)
block|{
name|IFQ_UNLOCK
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|err_ret
goto|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|HFCF_DEFAULTCLASS
condition|)
name|hif
operator|->
name|hif_defaultclass
operator|=
name|cl
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
comment|/* this is root class */
name|hif
operator|->
name|hif_rootclass
operator|=
name|cl
expr_stmt|;
block|}
else|else
block|{
comment|/* add this class to the children list of the parent */
if|if
condition|(
operator|(
name|p
operator|=
name|parent
operator|->
name|cl_children
operator|)
operator|==
name|NULL
condition|)
name|parent
operator|->
name|cl_children
operator|=
name|cl
expr_stmt|;
else|else
block|{
while|while
condition|(
name|p
operator|->
name|cl_siblings
operator|!=
name|NULL
condition|)
name|p
operator|=
name|p
operator|->
name|cl_siblings
expr_stmt|;
name|p
operator|->
name|cl_siblings
operator|=
name|cl
expr_stmt|;
block|}
block|}
name|IFQ_UNLOCK
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|cl
operator|)
return|;
name|err_ret
label|:
if|if
condition|(
name|cl
operator|->
name|cl_red
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|rio_destroy
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|cl_red
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|red_destroy
argument_list|(
name|cl
operator|->
name|cl_red
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_fsc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_rsc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_usc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_q
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsc_class_destroy
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|is_a_parent_class
argument_list|(
name|cl
argument_list|)
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
comment|/* delete filters referencing to this class */
name|acc_discard_filters
argument_list|(
operator|&
name|cl
operator|->
name|cl_hif
operator|->
name|hif_classifier
argument_list|,
name|cl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ALTQ3_COMPAT */
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|hfsc_purgeq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_parent
operator|==
name|NULL
condition|)
block|{
comment|/* this is root class */
block|}
else|else
block|{
name|struct
name|hfsc_class
modifier|*
name|p
init|=
name|cl
operator|->
name|cl_parent
operator|->
name|cl_children
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|cl
condition|)
name|cl
operator|->
name|cl_parent
operator|->
name|cl_children
operator|=
name|cl
operator|->
name|cl_siblings
expr_stmt|;
else|else
do|do
block|{
if|if
condition|(
name|p
operator|->
name|cl_siblings
operator|==
name|cl
condition|)
block|{
name|p
operator|->
name|cl_siblings
operator|=
name|cl
operator|->
name|cl_siblings
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|cl_siblings
operator|)
operator|!=
name|NULL
condition|)
do|;
name|ASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HFSC_MAX_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|==
name|cl
condition|)
block|{
name|cl
operator|->
name|cl_hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|cl
operator|->
name|cl_hif
operator|->
name|hif_classes
operator|--
expr_stmt|;
name|IFQ_UNLOCK
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_red
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|rio_destroy
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|cl_red
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|red_destroy
argument_list|(
name|cl
operator|->
name|cl_red
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|IFQ_LOCK
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|cl
operator|->
name|cl_hif
operator|->
name|hif_rootclass
condition|)
name|cl
operator|->
name|cl_hif
operator|->
name|hif_rootclass
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|cl
operator|->
name|cl_hif
operator|->
name|hif_defaultclass
condition|)
name|cl
operator|->
name|cl_hif
operator|->
name|hif_defaultclass
operator|=
name|NULL
expr_stmt|;
name|IFQ_UNLOCK
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_usc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_fsc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|cl
operator|->
name|cl_rsc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hfsc_nextclass returns the next class in the tree.  *   usage:  *	for (cl = hif->hif_rootclass; cl != NULL; cl = hfsc_nextclass(cl))  *		do_something;  */
end_comment

begin_function
specifier|static
name|struct
name|hfsc_class
modifier|*
name|hfsc_nextclass
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_children
operator|!=
name|NULL
condition|)
name|cl
operator|=
name|cl
operator|->
name|cl_children
expr_stmt|;
elseif|else
if|if
condition|(
name|cl
operator|->
name|cl_siblings
operator|!=
name|NULL
condition|)
name|cl
operator|=
name|cl
operator|->
name|cl_siblings
expr_stmt|;
else|else
block|{
while|while
condition|(
operator|(
name|cl
operator|=
name|cl
operator|->
name|cl_parent
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|cl
operator|->
name|cl_siblings
condition|)
block|{
name|cl
operator|=
name|cl
operator|->
name|cl_siblings
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|cl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hfsc_enqueue is an enqueue function to be registered to  * (*altq_enqueue) in struct ifaltq.  */
end_comment

begin_function
specifier|static
name|int
name|hfsc_enqueue
parameter_list|(
name|struct
name|ifaltq
modifier|*
name|ifq
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|,
name|struct
name|altq_pktattr
modifier|*
name|pktattr
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
init|=
operator|(
expr|struct
name|hfsc_if
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|pf_mtag
modifier|*
name|t
decl_stmt|;
name|int
name|len
decl_stmt|;
name|IFQ_LOCK_ASSERT
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
comment|/* grab class set by classifier */
if|if
condition|(
operator|(
name|m
operator|->
name|m_flags
operator|&
name|M_PKTHDR
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* should not happen */
name|printf
argument_list|(
literal|"altq: packet for %s does not have pkthdr\n"
argument_list|,
name|ifq
operator|->
name|altq_ifp
operator|->
name|if_xname
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|cl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|t
operator|=
name|pf_find_mtag
argument_list|(
name|m
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|cl
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|t
operator|->
name|qid
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
elseif|else
if|if
condition|(
operator|(
name|ifq
operator|->
name|altq_flags
operator|&
name|ALTQF_CLASSIFY
operator|)
operator|&&
name|pktattr
operator|!=
name|NULL
condition|)
name|cl
operator|=
name|pktattr
operator|->
name|pattr_class
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cl
operator|==
name|NULL
operator|||
name|is_a_parent_class
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|cl
operator|=
name|hif
operator|->
name|hif_defaultclass
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
if|if
condition|(
name|pktattr
operator|!=
name|NULL
condition|)
name|cl
operator|->
name|cl_pktattr
operator|=
name|pktattr
expr_stmt|;
comment|/* save proto hdr used by ECN */
else|else
endif|#
directive|endif
name|cl
operator|->
name|cl_pktattr
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
name|m_pktlen
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|hfsc_addq
argument_list|(
name|cl
argument_list|,
name|m
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* drop occurred.  mbuf was freed in hfsc_addq. */
name|PKTCNTR_ADD
argument_list|(
operator|&
name|cl
operator|->
name|cl_stats
operator|.
name|drop_cnt
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOBUFS
operator|)
return|;
block|}
name|IFQ_INC_LEN
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_hif
operator|->
name|hif_packets
operator|++
expr_stmt|;
comment|/* successfully queued. */
if|if
condition|(
name|qlen
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|==
literal|1
condition|)
name|set_active
argument_list|(
name|cl
argument_list|,
name|m_pktlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * hfsc_dequeue is a dequeue function to be registered to  * (*altq_dequeue) in struct ifaltq.  *  * note: ALTDQ_POLL returns the next packet without removing the packet  *	from the queue.  ALTDQ_REMOVE is a normal dequeue operation.  *	ALTDQ_REMOVE must return the same packet if called immediately  *	after ALTDQ_POLL.  */
end_comment

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|hfsc_dequeue
parameter_list|(
name|struct
name|ifaltq
modifier|*
name|ifq
parameter_list|,
name|int
name|op
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
init|=
operator|(
expr|struct
name|hfsc_if
operator|*
operator|)
name|ifq
operator|->
name|altq_disc
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|len
decl_stmt|,
name|next_len
decl_stmt|;
name|int
name|realtime
init|=
literal|0
decl_stmt|;
name|u_int64_t
name|cur_time
decl_stmt|;
name|IFQ_LOCK_ASSERT
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|hif
operator|->
name|hif_packets
operator|==
literal|0
condition|)
comment|/* no packet in the tree */
return|return
operator|(
name|NULL
operator|)
return|;
name|cur_time
operator|=
name|read_machclk
argument_list|()
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|ALTDQ_REMOVE
operator|&&
name|hif
operator|->
name|hif_pollcache
operator|!=
name|NULL
condition|)
block|{
name|cl
operator|=
name|hif
operator|->
name|hif_pollcache
expr_stmt|;
name|hif
operator|->
name|hif_pollcache
operator|=
name|NULL
expr_stmt|;
comment|/* check if the class was scheduled by real-time criteria */
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
name|realtime
operator|=
operator|(
name|cl
operator|->
name|cl_e
operator|<=
name|cur_time
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * if there are eligible classes, use real-time criteria. 		 * find the class with the minimum deadline among 		 * the eligible classes. 		 */
if|if
condition|(
operator|(
name|cl
operator|=
name|hfsc_get_mindl
argument_list|(
name|hif
argument_list|,
name|cur_time
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|realtime
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|int
name|fits
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* 			 * use link-sharing criteria 			 * get the class with the minimum vt in the hierarchy 			 */
name|cl
operator|=
name|hif
operator|->
name|hif_rootclass
expr_stmt|;
while|while
condition|(
name|is_a_parent_class
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|cl
operator|=
name|actlist_firstfit
argument_list|(
name|cl
argument_list|,
name|cur_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
if|if
condition|(
name|fits
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"%d fit but none found\n"
argument_list|,
name|fits
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 				 * update parent's cl_cvtmin. 				 * don't update if the new vt is smaller. 				 */
if|if
condition|(
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
operator|<
name|cl
operator|->
name|cl_vt
condition|)
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
operator|=
name|cl
operator|->
name|cl_vt
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|fits
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
if|if
condition|(
name|op
operator|==
name|ALTDQ_POLL
condition|)
block|{
name|hif
operator|->
name|hif_pollcache
operator|=
name|cl
expr_stmt|;
name|m
operator|=
name|hfsc_pollq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
block|}
name|m
operator|=
name|hfsc_getq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"hfsc_dequeue:"
argument_list|)
expr_stmt|;
name|len
operator|=
name|m_pktlen
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_hif
operator|->
name|hif_packets
operator|--
expr_stmt|;
name|IFQ_DEC_LEN
argument_list|(
name|ifq
argument_list|)
expr_stmt|;
name|PKTCNTR_ADD
argument_list|(
operator|&
name|cl
operator|->
name|cl_stats
operator|.
name|xmit_cnt
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|update_vf
argument_list|(
name|cl
argument_list|,
name|len
argument_list|,
name|cur_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|realtime
condition|)
name|cl
operator|->
name|cl_cumul
operator|+=
name|len
expr_stmt|;
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
block|{
comment|/* update ed */
name|next_len
operator|=
name|m_pktlen
argument_list|(
name|qhead
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|realtime
condition|)
name|update_ed
argument_list|(
name|cl
argument_list|,
name|next_len
argument_list|)
expr_stmt|;
else|else
name|update_d
argument_list|(
name|cl
argument_list|,
name|next_len
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* the class becomes passive */
name|set_passive
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsc_addq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|struct
name|mbuf
modifier|*
name|m
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
return|return
name|rio_addq
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|cl_red
argument_list|,
name|cl
operator|->
name|cl_q
argument_list|,
name|m
argument_list|,
name|cl
operator|->
name|cl_pktattr
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
return|return
name|red_addq
argument_list|(
name|cl
operator|->
name|cl_red
argument_list|,
name|cl
operator|->
name|cl_q
argument_list|,
name|m
argument_list|,
name|cl
operator|->
name|cl_pktattr
argument_list|)
return|;
endif|#
directive|endif
if|if
condition|(
name|qlen
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|>=
name|qlimit
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cl
operator|->
name|cl_flags
operator|&
name|HFCF_CLEARDSCP
condition|)
name|write_dsfield
argument_list|(
name|m
argument_list|,
name|cl
operator|->
name|cl_pktattr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|_addq
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|,
name|m
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|hfsc_getq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
return|return
name|rio_getq
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|cl_red
argument_list|,
name|cl
operator|->
name|cl_q
argument_list|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
return|return
name|red_getq
argument_list|(
name|cl
operator|->
name|cl_red
argument_list|,
name|cl
operator|->
name|cl_q
argument_list|)
return|;
endif|#
directive|endif
return|return
name|_getq
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|mbuf
modifier|*
name|hfsc_pollq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
return|return
name|qhead
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hfsc_purgeq
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
if|if
condition|(
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
return|return;
while|while
condition|(
operator|(
name|m
operator|=
name|_getq
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|PKTCNTR_ADD
argument_list|(
operator|&
name|cl
operator|->
name|cl_stats
operator|.
name|drop_cnt
argument_list|,
name|m_pktlen
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_hif
operator|->
name|hif_packets
operator|--
expr_stmt|;
name|IFQ_DEC_LEN
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|qlen
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|update_vf
argument_list|(
name|cl
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* remove cl from the actlist */
name|set_passive
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_active
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
name|init_ed
argument_list|(
name|cl
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|!=
name|NULL
condition|)
name|init_vf
argument_list|(
name|cl
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_stats
operator|.
name|period
operator|++
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_passive
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
name|ellist_remove
argument_list|(
name|cl
argument_list|)
expr_stmt|;
comment|/* 	 * actlist is now handled in update_vf() so that update_vf(cl, 0, 0) 	 * needs to be called explicitly to remove a class from actlist 	 */
block|}
end_function

begin_function
specifier|static
name|void
name|init_ed
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|int
name|next_len
parameter_list|)
block|{
name|u_int64_t
name|cur_time
decl_stmt|;
name|cur_time
operator|=
name|read_machclk
argument_list|()
expr_stmt|;
comment|/* update the deadline curve */
name|rtsc_min
argument_list|(
operator|&
name|cl
operator|->
name|cl_deadline
argument_list|,
name|cl
operator|->
name|cl_rsc
argument_list|,
name|cur_time
argument_list|,
name|cl
operator|->
name|cl_cumul
argument_list|)
expr_stmt|;
comment|/* 	 * update the eligible curve. 	 * for concave, it is equal to the deadline curve. 	 * for convex, it is a linear curve with slope m2. 	 */
name|cl
operator|->
name|cl_eligible
operator|=
name|cl
operator|->
name|cl_deadline
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|->
name|sm1
operator|<=
name|cl
operator|->
name|cl_rsc
operator|->
name|sm2
condition|)
block|{
name|cl
operator|->
name|cl_eligible
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|cl_eligible
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute e and d */
name|cl
operator|->
name|cl_e
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_eligible
argument_list|,
name|cl
operator|->
name|cl_cumul
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_d
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_deadline
argument_list|,
name|cl
operator|->
name|cl_cumul
operator|+
name|next_len
argument_list|)
expr_stmt|;
name|ellist_insert
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_ed
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|int
name|next_len
parameter_list|)
block|{
name|cl
operator|->
name|cl_e
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_eligible
argument_list|,
name|cl
operator|->
name|cl_cumul
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_d
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_deadline
argument_list|,
name|cl
operator|->
name|cl_cumul
operator|+
name|next_len
argument_list|)
expr_stmt|;
name|ellist_update
argument_list|(
name|cl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|update_d
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|int
name|next_len
parameter_list|)
block|{
name|cl
operator|->
name|cl_d
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_deadline
argument_list|,
name|cl
operator|->
name|cl_cumul
operator|+
name|next_len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_vf
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|max_cl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|u_int64_t
name|vt
decl_stmt|,
name|f
decl_stmt|,
name|cur_time
decl_stmt|;
name|int
name|go_active
decl_stmt|;
name|cur_time
operator|=
literal|0
expr_stmt|;
name|go_active
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
name|cl
operator|->
name|cl_parent
operator|!=
name|NULL
condition|;
name|cl
operator|=
name|cl
operator|->
name|cl_parent
control|)
block|{
if|if
condition|(
name|go_active
operator|&&
name|cl
operator|->
name|cl_nactive
operator|++
operator|==
literal|0
condition|)
name|go_active
operator|=
literal|1
expr_stmt|;
else|else
name|go_active
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go_active
condition|)
block|{
name|max_cl
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|acthead
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_cl
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * set vt to the average of the min and max 				 * classes.  if the parent's period didn't 				 * change, don't decrease vt of the class. 				 */
name|vt
operator|=
name|max_cl
operator|->
name|cl_vt
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
operator|!=
literal|0
condition|)
name|vt
operator|=
operator|(
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
operator|+
name|vt
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_parent
operator|->
name|cl_vtperiod
operator|!=
name|cl
operator|->
name|cl_parentperiod
operator|||
name|vt
operator|>
name|cl
operator|->
name|cl_vt
condition|)
name|cl
operator|->
name|cl_vt
operator|=
name|vt
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * first child for a new parent backlog period. 				 * add parent's cvtmax to vtoff of children 				 * to make a new vt (vtoff + vt) larger than 				 * the vt in the last period for all children. 				 */
name|vt
operator|=
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmax
expr_stmt|;
for|for
control|(
name|p
operator|=
name|cl
operator|->
name|cl_parent
operator|->
name|cl_children
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|cl_siblings
control|)
name|p
operator|->
name|cl_vtoff
operator|+=
name|vt
expr_stmt|;
name|cl
operator|->
name|cl_vt
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmax
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
operator|=
literal|0
expr_stmt|;
block|}
name|cl
operator|->
name|cl_initvt
operator|=
name|cl
operator|->
name|cl_vt
expr_stmt|;
comment|/* update the virtual curve */
name|vt
operator|=
name|cl
operator|->
name|cl_vt
operator|+
name|cl
operator|->
name|cl_vtoff
expr_stmt|;
name|rtsc_min
argument_list|(
operator|&
name|cl
operator|->
name|cl_virtual
argument_list|,
name|cl
operator|->
name|cl_fsc
argument_list|,
name|vt
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_virtual
operator|.
name|x
operator|==
name|vt
condition|)
block|{
name|cl
operator|->
name|cl_virtual
operator|.
name|x
operator|-=
name|cl
operator|->
name|cl_vtoff
expr_stmt|;
name|cl
operator|->
name|cl_vtoff
operator|=
literal|0
expr_stmt|;
block|}
name|cl
operator|->
name|cl_vtadj
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|cl_vtperiod
operator|++
expr_stmt|;
comment|/* increment vt period */
name|cl
operator|->
name|cl_parentperiod
operator|=
name|cl
operator|->
name|cl_parent
operator|->
name|cl_vtperiod
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_parent
operator|->
name|cl_nactive
operator|==
literal|0
condition|)
name|cl
operator|->
name|cl_parentperiod
operator|++
expr_stmt|;
name|cl
operator|->
name|cl_f
operator|=
literal|0
expr_stmt|;
name|actlist_insert
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|!=
name|NULL
condition|)
block|{
comment|/* class has upper limit curve */
if|if
condition|(
name|cur_time
operator|==
literal|0
condition|)
name|cur_time
operator|=
name|read_machclk
argument_list|()
expr_stmt|;
comment|/* update the ulimit curve */
name|rtsc_min
argument_list|(
operator|&
name|cl
operator|->
name|cl_ulimit
argument_list|,
name|cl
operator|->
name|cl_usc
argument_list|,
name|cur_time
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
expr_stmt|;
comment|/* compute myf */
name|cl
operator|->
name|cl_myf
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_ulimit
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_myfadj
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cl
operator|->
name|cl_myf
operator|>
name|cl
operator|->
name|cl_cfmin
condition|)
name|f
operator|=
name|cl
operator|->
name|cl_myf
expr_stmt|;
else|else
name|f
operator|=
name|cl
operator|->
name|cl_cfmin
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|cl
operator|->
name|cl_f
condition|)
block|{
name|cl
operator|->
name|cl_f
operator|=
name|f
expr_stmt|;
name|update_cfmin
argument_list|(
name|cl
operator|->
name|cl_parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_vf
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|int
name|len
parameter_list|,
name|u_int64_t
name|cur_time
parameter_list|)
block|{
name|u_int64_t
name|f
decl_stmt|,
name|myf_bound
decl_stmt|,
name|delta
decl_stmt|;
name|int
name|go_passive
decl_stmt|;
name|go_passive
operator|=
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|cl
operator|->
name|cl_parent
operator|!=
name|NULL
condition|;
name|cl
operator|=
name|cl
operator|->
name|cl_parent
control|)
block|{
name|cl
operator|->
name|cl_total
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|==
name|NULL
operator|||
name|cl
operator|->
name|cl_nactive
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|go_passive
operator|&&
operator|--
name|cl
operator|->
name|cl_nactive
operator|==
literal|0
condition|)
name|go_passive
operator|=
literal|1
expr_stmt|;
else|else
name|go_passive
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|go_passive
condition|)
block|{
comment|/* no more active child, going passive */
comment|/* update cvtmax of the parent class */
if|if
condition|(
name|cl
operator|->
name|cl_vt
operator|>
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmax
condition|)
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmax
operator|=
name|cl
operator|->
name|cl_vt
expr_stmt|;
comment|/* remove this class from the vt list */
name|actlist_remove
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|update_cfmin
argument_list|(
name|cl
operator|->
name|cl_parent
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * update vt and f 		 */
name|cl
operator|->
name|cl_vt
operator|=
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_virtual
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
operator|-
name|cl
operator|->
name|cl_vtoff
operator|+
name|cl
operator|->
name|cl_vtadj
expr_stmt|;
comment|/* 		 * if vt of the class is smaller than cvtmin, 		 * the class was skipped in the past due to non-fit. 		 * if so, we need to adjust vtadj. 		 */
if|if
condition|(
name|cl
operator|->
name|cl_vt
operator|<
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
condition|)
block|{
name|cl
operator|->
name|cl_vtadj
operator|+=
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
operator|-
name|cl
operator|->
name|cl_vt
expr_stmt|;
name|cl
operator|->
name|cl_vt
operator|=
name|cl
operator|->
name|cl_parent
operator|->
name|cl_cvtmin
expr_stmt|;
block|}
comment|/* update the vt list */
name|actlist_update
argument_list|(
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|!=
name|NULL
condition|)
block|{
name|cl
operator|->
name|cl_myf
operator|=
name|cl
operator|->
name|cl_myfadj
operator|+
name|rtsc_y2x
argument_list|(
operator|&
name|cl
operator|->
name|cl_ulimit
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
expr_stmt|;
comment|/* 			 * if myf lags behind by more than one clock tick 			 * from the current time, adjust myfadj to prevent 			 * a rate-limited class from going greedy. 			 * in a steady state under rate-limiting, myf 			 * fluctuates within one clock tick. 			 */
name|myf_bound
operator|=
name|cur_time
operator|-
name|machclk_per_tick
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_myf
operator|<
name|myf_bound
condition|)
block|{
name|delta
operator|=
name|cur_time
operator|-
name|cl
operator|->
name|cl_myf
expr_stmt|;
name|cl
operator|->
name|cl_myfadj
operator|+=
name|delta
expr_stmt|;
name|cl
operator|->
name|cl_myf
operator|+=
name|delta
expr_stmt|;
block|}
block|}
comment|/* cl_f is max(cl_myf, cl_cfmin) */
if|if
condition|(
name|cl
operator|->
name|cl_myf
operator|>
name|cl
operator|->
name|cl_cfmin
condition|)
name|f
operator|=
name|cl
operator|->
name|cl_myf
expr_stmt|;
else|else
name|f
operator|=
name|cl
operator|->
name|cl_cfmin
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|cl
operator|->
name|cl_f
condition|)
block|{
name|cl
operator|->
name|cl_f
operator|=
name|f
expr_stmt|;
name|update_cfmin
argument_list|(
name|cl
operator|->
name|cl_parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|update_cfmin
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|;
name|u_int64_t
name|cfmin
decl_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|cl
operator|->
name|cl_actc
argument_list|)
condition|)
block|{
name|cl
operator|->
name|cl_cfmin
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|cfmin
operator|=
name|HT_INFINITY
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&cl->cl_actc
argument_list|,
argument|cl_actlist
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|cl_f
operator|==
literal|0
condition|)
block|{
name|cl
operator|->
name|cl_cfmin
operator|=
literal|0
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|cl_f
operator|<
name|cfmin
condition|)
name|cfmin
operator|=
name|p
operator|->
name|cl_f
expr_stmt|;
block|}
name|cl
operator|->
name|cl_cfmin
operator|=
name|cfmin
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TAILQ based ellist and actlist implementation  * (ion wanted to make a calendar queue based implementation)  */
end_comment

begin_comment
comment|/*  * eligible list holds backlogged classes being sorted by their eligible times.  * there is one eligible list per interface.  */
end_comment

begin_function
specifier|static
name|void
name|ellist_insert
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
init|=
name|cl
operator|->
name|cl_hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|;
comment|/* check the last entry first */
if|if
condition|(
operator|(
name|p
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|elighead
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|cl_e
operator|<=
name|cl
operator|->
name|cl_e
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&hif->hif_eligible
argument_list|,
argument|cl_ellist
argument_list|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_e
operator|<
name|p
operator|->
name|cl_e
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should not reach here */
block|}
end_function

begin_function
specifier|static
name|void
name|ellist_remove
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
init|=
name|cl
operator|->
name|cl_hif
decl_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ellist_update
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
init|=
name|cl
operator|->
name|cl_hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|,
modifier|*
name|last
decl_stmt|;
comment|/* 	 * the eligible time of a class increases monotonically. 	 * if the next entry has a larger eligible time, nothing to do. 	 */
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|cl
operator|->
name|cl_e
operator|<=
name|p
operator|->
name|cl_e
condition|)
return|return;
comment|/* check the last entry */
name|last
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|elighead
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|cl_e
operator|<=
name|cl
operator|->
name|cl_e
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * the new position must be between the next entry 	 * and the last entry 	 */
while|while
condition|(
operator|(
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|cl_ellist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_e
operator|<
name|p
operator|->
name|cl_e
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|hif
operator|->
name|hif_eligible
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|cl
argument_list|,
name|cl_ellist
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should not reach here */
block|}
end_function

begin_comment
comment|/* find the class with the minimum deadline among the eligible classes */
end_comment

begin_function
name|struct
name|hfsc_class
modifier|*
name|hfsc_get_mindl
parameter_list|(
name|struct
name|hfsc_if
modifier|*
name|hif
parameter_list|,
name|u_int64_t
name|cur_time
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|,
modifier|*
name|cl
init|=
name|NULL
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&hif->hif_eligible
argument_list|,
argument|cl_ellist
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|cl_e
operator|>
name|cur_time
condition|)
break|break;
if|if
condition|(
name|cl
operator|==
name|NULL
operator|||
name|p
operator|->
name|cl_d
operator|<
name|cl
operator|->
name|cl_d
condition|)
name|cl
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
name|cl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * active children list holds backlogged child classes being sorted  * by their virtual time.  * each intermediate class has one active children list.  */
end_comment

begin_function
specifier|static
name|void
name|actlist_insert
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|;
comment|/* check the last entry first */
if|if
condition|(
operator|(
name|p
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|acthead
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|cl_vt
operator|<=
name|cl
operator|->
name|cl_vt
condition|)
block|{
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
return|return;
block|}
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&cl->cl_parent->cl_actc
argument_list|,
argument|cl_actlist
argument_list|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_vt
operator|<
name|p
operator|->
name|cl_vt
condition|)
block|{
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should not reach here */
block|}
end_function

begin_function
specifier|static
name|void
name|actlist_remove
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|actlist_update
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|,
modifier|*
name|last
decl_stmt|;
comment|/* 	 * the virtual time of a class increases monotonically during its 	 * backlogged period. 	 * if the next entry has a larger virtual time, nothing to do. 	 */
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|cl
operator|->
name|cl_vt
operator|<
name|p
operator|->
name|cl_vt
condition|)
return|return;
comment|/* check the last entry */
name|last
operator|=
name|TAILQ_LAST
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|acthead
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|last
operator|->
name|cl_vt
operator|<=
name|cl
operator|->
name|cl_vt
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * the new position must be between the next entry 	 * and the last entry 	 */
while|while
condition|(
operator|(
name|p
operator|=
name|TAILQ_NEXT
argument_list|(
name|p
argument_list|,
name|cl_actlist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_vt
operator|<
name|p
operator|->
name|cl_vt
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|cl
operator|->
name|cl_parent
operator|->
name|cl_actc
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_BEFORE
argument_list|(
name|p
argument_list|,
name|cl
argument_list|,
name|cl_actlist
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* should not reach here */
block|}
end_function

begin_function
specifier|static
name|struct
name|hfsc_class
modifier|*
name|actlist_firstfit
parameter_list|(
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|,
name|u_int64_t
name|cur_time
parameter_list|)
block|{
name|struct
name|hfsc_class
modifier|*
name|p
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|p
argument_list|,
argument|&cl->cl_actc
argument_list|,
argument|cl_actlist
argument_list|)
block|{
if|if
condition|(
name|p
operator|->
name|cl_f
operator|<=
name|cur_time
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * service curve support functions  *  *  external service curve parameters  *	m: bits/sec  *	d: msec  *  internal service curve parameters  *	sm: (bytes/tsc_interval)<< SM_SHIFT  *	ism: (tsc_count/byte)<< ISM_SHIFT  *	dx: tsc_count  *  * SM_SHIFT and ISM_SHIFT are scaled in order to keep effective digits.  * we should be able to handle 100K-1Gbps linkspeed with 200Hz-1GHz CPU  * speed.  SM_SHIFT and ISM_SHIFT are selected to have at least 3 effective  * digits in decimal using the following table.  *  *  bits/sec    100Kbps     1Mbps     10Mbps     100Mbps    1Gbps  *  ----------+-------------------------------------------------------  *  bytes/nsec  12.5e-6    125e-6     1250e-6    12500e-6   125000e-6  *  sm(500MHz)  25.0e-6    250e-6     2500e-6    25000e-6   250000e-6  *  sm(200MHz)  62.5e-6    625e-6     6250e-6    62500e-6   625000e-6  *  *  nsec/byte   80000      8000       800        80         8  *  ism(500MHz) 40000      4000       400        40         4  *  ism(200MHz) 16000      1600       160        16         1.6  */
end_comment

begin_define
define|#
directive|define
name|SM_SHIFT
value|24
end_define

begin_define
define|#
directive|define
name|ISM_SHIFT
value|10
end_define

begin_define
define|#
directive|define
name|SM_MASK
value|((1LL<< SM_SHIFT) - 1)
end_define

begin_define
define|#
directive|define
name|ISM_MASK
value|((1LL<< ISM_SHIFT) - 1)
end_define

begin_function
specifier|static
name|__inline
name|u_int64_t
name|seg_x2y
parameter_list|(
name|u_int64_t
name|x
parameter_list|,
name|u_int64_t
name|sm
parameter_list|)
block|{
name|u_int64_t
name|y
decl_stmt|;
comment|/* 	 * compute 	 *	y = x * sm>> SM_SHIFT 	 * but divide it for the upper and lower bits to avoid overflow 	 */
name|y
operator|=
operator|(
name|x
operator|>>
name|SM_SHIFT
operator|)
operator|*
name|sm
operator|+
operator|(
operator|(
operator|(
name|x
operator|&
name|SM_MASK
operator|)
operator|*
name|sm
operator|)
operator|>>
name|SM_SHIFT
operator|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int64_t
name|seg_y2x
parameter_list|(
name|u_int64_t
name|y
parameter_list|,
name|u_int64_t
name|ism
parameter_list|)
block|{
name|u_int64_t
name|x
decl_stmt|;
if|if
condition|(
name|y
operator|==
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|ism
operator|==
name|HT_INFINITY
condition|)
name|x
operator|=
name|HT_INFINITY
expr_stmt|;
else|else
block|{
name|x
operator|=
operator|(
name|y
operator|>>
name|ISM_SHIFT
operator|)
operator|*
name|ism
operator|+
operator|(
operator|(
operator|(
name|y
operator|&
name|ISM_MASK
operator|)
operator|*
name|ism
operator|)
operator|>>
name|ISM_SHIFT
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int64_t
name|m2sm
parameter_list|(
name|u_int
name|m
parameter_list|)
block|{
name|u_int64_t
name|sm
decl_stmt|;
name|sm
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|m
operator|<<
name|SM_SHIFT
operator|)
operator|/
literal|8
operator|/
name|machclk_freq
expr_stmt|;
return|return
operator|(
name|sm
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int64_t
name|m2ism
parameter_list|(
name|u_int
name|m
parameter_list|)
block|{
name|u_int64_t
name|ism
decl_stmt|;
if|if
condition|(
name|m
operator|==
literal|0
condition|)
name|ism
operator|=
name|HT_INFINITY
expr_stmt|;
else|else
name|ism
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|machclk_freq
operator|<<
name|ISM_SHIFT
operator|)
operator|*
literal|8
operator|/
name|m
expr_stmt|;
return|return
operator|(
name|ism
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|u_int64_t
name|d2dx
parameter_list|(
name|u_int
name|d
parameter_list|)
block|{
name|u_int64_t
name|dx
decl_stmt|;
name|dx
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|d
operator|*
name|machclk_freq
operator|)
operator|/
literal|1000
expr_stmt|;
return|return
operator|(
name|dx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|sm2m
parameter_list|(
name|u_int64_t
name|sm
parameter_list|)
block|{
name|u_int64_t
name|m
decl_stmt|;
name|m
operator|=
operator|(
name|sm
operator|*
literal|8
operator|*
name|machclk_freq
operator|)
operator|>>
name|SM_SHIFT
expr_stmt|;
return|return
operator|(
operator|(
name|u_int
operator|)
name|m
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|dx2d
parameter_list|(
name|u_int64_t
name|dx
parameter_list|)
block|{
name|u_int64_t
name|d
decl_stmt|;
name|d
operator|=
name|dx
operator|*
literal|1000
operator|/
name|machclk_freq
expr_stmt|;
return|return
operator|(
operator|(
name|u_int
operator|)
name|d
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sc2isc
parameter_list|(
name|struct
name|service_curve
modifier|*
name|sc
parameter_list|,
name|struct
name|internal_sc
modifier|*
name|isc
parameter_list|)
block|{
name|isc
operator|->
name|sm1
operator|=
name|m2sm
argument_list|(
name|sc
operator|->
name|m1
argument_list|)
expr_stmt|;
name|isc
operator|->
name|ism1
operator|=
name|m2ism
argument_list|(
name|sc
operator|->
name|m1
argument_list|)
expr_stmt|;
name|isc
operator|->
name|dx
operator|=
name|d2dx
argument_list|(
name|sc
operator|->
name|d
argument_list|)
expr_stmt|;
name|isc
operator|->
name|dy
operator|=
name|seg_x2y
argument_list|(
name|isc
operator|->
name|dx
argument_list|,
name|isc
operator|->
name|sm1
argument_list|)
expr_stmt|;
name|isc
operator|->
name|sm2
operator|=
name|m2sm
argument_list|(
name|sc
operator|->
name|m2
argument_list|)
expr_stmt|;
name|isc
operator|->
name|ism2
operator|=
name|m2ism
argument_list|(
name|sc
operator|->
name|m2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialize the runtime service curve with the given internal  * service curve starting at (x, y).  */
end_comment

begin_function
specifier|static
name|void
name|rtsc_init
parameter_list|(
name|struct
name|runtime_sc
modifier|*
name|rtsc
parameter_list|,
name|struct
name|internal_sc
modifier|*
name|isc
parameter_list|,
name|u_int64_t
name|x
parameter_list|,
name|u_int64_t
name|y
parameter_list|)
block|{
name|rtsc
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|rtsc
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|rtsc
operator|->
name|sm1
operator|=
name|isc
operator|->
name|sm1
expr_stmt|;
name|rtsc
operator|->
name|ism1
operator|=
name|isc
operator|->
name|ism1
expr_stmt|;
name|rtsc
operator|->
name|dx
operator|=
name|isc
operator|->
name|dx
expr_stmt|;
name|rtsc
operator|->
name|dy
operator|=
name|isc
operator|->
name|dy
expr_stmt|;
name|rtsc
operator|->
name|sm2
operator|=
name|isc
operator|->
name|sm2
expr_stmt|;
name|rtsc
operator|->
name|ism2
operator|=
name|isc
operator|->
name|ism2
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * calculate the y-projection of the runtime service curve by the  * given x-projection value  */
end_comment

begin_function
specifier|static
name|u_int64_t
name|rtsc_y2x
parameter_list|(
name|struct
name|runtime_sc
modifier|*
name|rtsc
parameter_list|,
name|u_int64_t
name|y
parameter_list|)
block|{
name|u_int64_t
name|x
decl_stmt|;
if|if
condition|(
name|y
operator|<
name|rtsc
operator|->
name|y
condition|)
name|x
operator|=
name|rtsc
operator|->
name|x
expr_stmt|;
elseif|else
if|if
condition|(
name|y
operator|<=
name|rtsc
operator|->
name|y
operator|+
name|rtsc
operator|->
name|dy
condition|)
block|{
comment|/* x belongs to the 1st segment */
if|if
condition|(
name|rtsc
operator|->
name|dy
operator|==
literal|0
condition|)
name|x
operator|=
name|rtsc
operator|->
name|x
operator|+
name|rtsc
operator|->
name|dx
expr_stmt|;
else|else
name|x
operator|=
name|rtsc
operator|->
name|x
operator|+
name|seg_y2x
argument_list|(
name|y
operator|-
name|rtsc
operator|->
name|y
argument_list|,
name|rtsc
operator|->
name|ism1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* x belongs to the 2nd segment */
name|x
operator|=
name|rtsc
operator|->
name|x
operator|+
name|rtsc
operator|->
name|dx
operator|+
name|seg_y2x
argument_list|(
name|y
operator|-
name|rtsc
operator|->
name|y
operator|-
name|rtsc
operator|->
name|dy
argument_list|,
name|rtsc
operator|->
name|ism2
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|rtsc_x2y
parameter_list|(
name|struct
name|runtime_sc
modifier|*
name|rtsc
parameter_list|,
name|u_int64_t
name|x
parameter_list|)
block|{
name|u_int64_t
name|y
decl_stmt|;
if|if
condition|(
name|x
operator|<=
name|rtsc
operator|->
name|x
condition|)
name|y
operator|=
name|rtsc
operator|->
name|y
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|<=
name|rtsc
operator|->
name|x
operator|+
name|rtsc
operator|->
name|dx
condition|)
comment|/* y belongs to the 1st segment */
name|y
operator|=
name|rtsc
operator|->
name|y
operator|+
name|seg_x2y
argument_list|(
name|x
operator|-
name|rtsc
operator|->
name|x
argument_list|,
name|rtsc
operator|->
name|sm1
argument_list|)
expr_stmt|;
else|else
comment|/* y belongs to the 2nd segment */
name|y
operator|=
name|rtsc
operator|->
name|y
operator|+
name|rtsc
operator|->
name|dy
operator|+
name|seg_x2y
argument_list|(
name|x
operator|-
name|rtsc
operator|->
name|x
operator|-
name|rtsc
operator|->
name|dx
argument_list|,
name|rtsc
operator|->
name|sm2
argument_list|)
expr_stmt|;
return|return
operator|(
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * update the runtime service curve by taking the minimum of the current  * runtime service curve and the service curve starting at (x, y).  */
end_comment

begin_function
specifier|static
name|void
name|rtsc_min
parameter_list|(
name|struct
name|runtime_sc
modifier|*
name|rtsc
parameter_list|,
name|struct
name|internal_sc
modifier|*
name|isc
parameter_list|,
name|u_int64_t
name|x
parameter_list|,
name|u_int64_t
name|y
parameter_list|)
block|{
name|u_int64_t
name|y1
decl_stmt|,
name|y2
decl_stmt|,
name|dx
decl_stmt|,
name|dy
decl_stmt|;
if|if
condition|(
name|isc
operator|->
name|sm1
operator|<=
name|isc
operator|->
name|sm2
condition|)
block|{
comment|/* service curve is convex */
name|y1
operator|=
name|rtsc_x2y
argument_list|(
name|rtsc
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y1
operator|<
name|y
condition|)
comment|/* the current rtsc is smaller */
return|return;
name|rtsc
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|rtsc
operator|->
name|y
operator|=
name|y
expr_stmt|;
return|return;
block|}
comment|/* 	 * service curve is concave 	 * compute the two y values of the current rtsc 	 *	y1: at x 	 *	y2: at (x + dx) 	 */
name|y1
operator|=
name|rtsc_x2y
argument_list|(
name|rtsc
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y1
operator|<=
name|y
condition|)
block|{
comment|/* rtsc is below isc, no change to rtsc */
return|return;
block|}
name|y2
operator|=
name|rtsc_x2y
argument_list|(
name|rtsc
argument_list|,
name|x
operator|+
name|isc
operator|->
name|dx
argument_list|)
expr_stmt|;
if|if
condition|(
name|y2
operator|>=
name|y
operator|+
name|isc
operator|->
name|dy
condition|)
block|{
comment|/* rtsc is above isc, replace rtsc by isc */
name|rtsc
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|rtsc
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|rtsc
operator|->
name|dx
operator|=
name|isc
operator|->
name|dx
expr_stmt|;
name|rtsc
operator|->
name|dy
operator|=
name|isc
operator|->
name|dy
expr_stmt|;
return|return;
block|}
comment|/* 	 * the two curves intersect 	 * compute the offsets (dx, dy) using the reverse 	 * function of seg_x2y() 	 *	seg_x2y(dx, sm1) == seg_x2y(dx, sm2) + (y1 - y) 	 */
name|dx
operator|=
operator|(
operator|(
name|y1
operator|-
name|y
operator|)
operator|<<
name|SM_SHIFT
operator|)
operator|/
operator|(
name|isc
operator|->
name|sm1
operator|-
name|isc
operator|->
name|sm2
operator|)
expr_stmt|;
comment|/* 	 * check if (x, y1) belongs to the 1st segment of rtsc. 	 * if so, add the offset. 	 */
if|if
condition|(
name|rtsc
operator|->
name|x
operator|+
name|rtsc
operator|->
name|dx
operator|>
name|x
condition|)
name|dx
operator|+=
name|rtsc
operator|->
name|x
operator|+
name|rtsc
operator|->
name|dx
operator|-
name|x
expr_stmt|;
name|dy
operator|=
name|seg_x2y
argument_list|(
name|dx
argument_list|,
name|isc
operator|->
name|sm1
argument_list|)
expr_stmt|;
name|rtsc
operator|->
name|x
operator|=
name|x
expr_stmt|;
name|rtsc
operator|->
name|y
operator|=
name|y
expr_stmt|;
name|rtsc
operator|->
name|dx
operator|=
name|dx
expr_stmt|;
name|rtsc
operator|->
name|dy
operator|=
name|dy
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|get_class_stats
parameter_list|(
name|struct
name|hfsc_classstats
modifier|*
name|sp
parameter_list|,
name|struct
name|hfsc_class
modifier|*
name|cl
parameter_list|)
block|{
name|sp
operator|->
name|class_id
operator|=
name|cl
operator|->
name|cl_id
expr_stmt|;
name|sp
operator|->
name|class_handle
operator|=
name|cl
operator|->
name|cl_handle
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|rsc
operator|.
name|m1
operator|=
name|sm2m
argument_list|(
name|cl
operator|->
name|cl_rsc
operator|->
name|sm1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rsc
operator|.
name|d
operator|=
name|dx2d
argument_list|(
name|cl
operator|->
name|cl_rsc
operator|->
name|dx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|rsc
operator|.
name|m2
operator|=
name|sm2m
argument_list|(
name|cl
operator|->
name|cl_rsc
operator|->
name|sm2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|rsc
operator|.
name|m1
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rsc
operator|.
name|d
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|rsc
operator|.
name|m2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|fsc
operator|.
name|m1
operator|=
name|sm2m
argument_list|(
name|cl
operator|->
name|cl_fsc
operator|->
name|sm1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fsc
operator|.
name|d
operator|=
name|dx2d
argument_list|(
name|cl
operator|->
name|cl_fsc
operator|->
name|dx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fsc
operator|.
name|m2
operator|=
name|sm2m
argument_list|(
name|cl
operator|->
name|cl_fsc
operator|->
name|sm2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|fsc
operator|.
name|m1
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|fsc
operator|.
name|d
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|fsc
operator|.
name|m2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|->
name|usc
operator|.
name|m1
operator|=
name|sm2m
argument_list|(
name|cl
operator|->
name|cl_usc
operator|->
name|sm1
argument_list|)
expr_stmt|;
name|sp
operator|->
name|usc
operator|.
name|d
operator|=
name|dx2d
argument_list|(
name|cl
operator|->
name|cl_usc
operator|->
name|dx
argument_list|)
expr_stmt|;
name|sp
operator|->
name|usc
operator|.
name|m2
operator|=
name|sm2m
argument_list|(
name|cl
operator|->
name|cl_usc
operator|->
name|sm2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sp
operator|->
name|usc
operator|.
name|m1
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|usc
operator|.
name|d
operator|=
literal|0
expr_stmt|;
name|sp
operator|->
name|usc
operator|.
name|m2
operator|=
literal|0
expr_stmt|;
block|}
name|sp
operator|->
name|total
operator|=
name|cl
operator|->
name|cl_total
expr_stmt|;
name|sp
operator|->
name|cumul
operator|=
name|cl
operator|->
name|cl_cumul
expr_stmt|;
name|sp
operator|->
name|d
operator|=
name|cl
operator|->
name|cl_d
expr_stmt|;
name|sp
operator|->
name|e
operator|=
name|cl
operator|->
name|cl_e
expr_stmt|;
name|sp
operator|->
name|vt
operator|=
name|cl
operator|->
name|cl_vt
expr_stmt|;
name|sp
operator|->
name|f
operator|=
name|cl
operator|->
name|cl_f
expr_stmt|;
name|sp
operator|->
name|initvt
operator|=
name|cl
operator|->
name|cl_initvt
expr_stmt|;
name|sp
operator|->
name|vtperiod
operator|=
name|cl
operator|->
name|cl_vtperiod
expr_stmt|;
name|sp
operator|->
name|parentperiod
operator|=
name|cl
operator|->
name|cl_parentperiod
expr_stmt|;
name|sp
operator|->
name|nactive
operator|=
name|cl
operator|->
name|cl_nactive
expr_stmt|;
name|sp
operator|->
name|vtoff
operator|=
name|cl
operator|->
name|cl_vtoff
expr_stmt|;
name|sp
operator|->
name|cvtmax
operator|=
name|cl
operator|->
name|cl_cvtmax
expr_stmt|;
name|sp
operator|->
name|myf
operator|=
name|cl
operator|->
name|cl_myf
expr_stmt|;
name|sp
operator|->
name|cfmin
operator|=
name|cl
operator|->
name|cl_cfmin
expr_stmt|;
name|sp
operator|->
name|cvtmin
operator|=
name|cl
operator|->
name|cl_cvtmin
expr_stmt|;
name|sp
operator|->
name|myfadj
operator|=
name|cl
operator|->
name|cl_myfadj
expr_stmt|;
name|sp
operator|->
name|vtadj
operator|=
name|cl
operator|->
name|cl_vtadj
expr_stmt|;
name|sp
operator|->
name|cur_time
operator|=
name|read_machclk
argument_list|()
expr_stmt|;
name|sp
operator|->
name|machclk_freq
operator|=
name|machclk_freq
expr_stmt|;
name|sp
operator|->
name|qlength
operator|=
name|qlen
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
expr_stmt|;
name|sp
operator|->
name|qlimit
operator|=
name|qlimit
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
expr_stmt|;
name|sp
operator|->
name|xmit_cnt
operator|=
name|cl
operator|->
name|cl_stats
operator|.
name|xmit_cnt
expr_stmt|;
name|sp
operator|->
name|drop_cnt
operator|=
name|cl
operator|->
name|cl_stats
operator|.
name|drop_cnt
expr_stmt|;
name|sp
operator|->
name|period
operator|=
name|cl
operator|->
name|cl_stats
operator|.
name|period
expr_stmt|;
name|sp
operator|->
name|qtype
operator|=
name|qtype
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALTQ_RED
if|if
condition|(
name|q_is_red
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|red_getstats
argument_list|(
name|cl
operator|->
name|cl_red
argument_list|,
operator|&
name|sp
operator|->
name|red
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ALTQ_RIO
if|if
condition|(
name|q_is_rio
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|rio_getstats
argument_list|(
operator|(
name|rio_t
operator|*
operator|)
name|cl
operator|->
name|cl_red
argument_list|,
operator|&
name|sp
operator|->
name|red
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* convert a class handle to the corresponding class pointer */
end_comment

begin_function
specifier|static
name|struct
name|hfsc_class
modifier|*
name|clh_to_clp
parameter_list|(
name|struct
name|hfsc_if
modifier|*
name|hif
parameter_list|,
name|u_int32_t
name|chandle
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
name|chandle
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * first, try optimistically the slot matching the lower bits of 	 * the handle.  if it fails, do the linear table search. 	 */
name|i
operator|=
name|chandle
operator|%
name|HFSC_MAX_CLASSES
expr_stmt|;
if|if
condition|(
operator|(
name|cl
operator|=
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|cl
operator|->
name|cl_handle
operator|==
name|chandle
condition|)
return|return
operator|(
name|cl
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HFSC_MAX_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|cl
operator|=
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|)
operator|!=
name|NULL
operator|&&
name|cl
operator|->
name|cl_handle
operator|==
name|chandle
condition|)
return|return
operator|(
name|cl
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ALTQ3_COMPAT
end_ifdef

begin_function
specifier|static
name|struct
name|hfsc_if
modifier|*
name|hfsc_attach
parameter_list|(
name|ifq
parameter_list|,
name|bandwidth
parameter_list|)
name|struct
name|ifaltq
modifier|*
name|ifq
decl_stmt|;
name|u_int
name|bandwidth
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|hif
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hfsc_if
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|hif
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bzero
argument_list|(
name|hif
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|hfsc_if
argument_list|)
argument_list|)
expr_stmt|;
name|hif
operator|->
name|hif_eligible
operator|=
name|ellist_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|hif
operator|->
name|hif_eligible
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|hif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hif
operator|->
name|hif_ifq
operator|=
name|ifq
expr_stmt|;
comment|/* add this state to the hfsc list */
name|hif
operator|->
name|hif_next
operator|=
name|hif_list
expr_stmt|;
name|hif_list
operator|=
name|hif
expr_stmt|;
return|return
operator|(
name|hif
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsc_detach
parameter_list|(
name|hif
parameter_list|)
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|hfsc_clear_interface
argument_list|(
name|hif
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|hfsc_class_destroy
argument_list|(
name|hif
operator|->
name|hif_rootclass
argument_list|)
expr_stmt|;
comment|/* remove this interface from the hif list */
if|if
condition|(
name|hif_list
operator|==
name|hif
condition|)
name|hif_list
operator|=
name|hif
operator|->
name|hif_next
expr_stmt|;
else|else
block|{
name|struct
name|hfsc_if
modifier|*
name|h
decl_stmt|;
for|for
control|(
name|h
operator|=
name|hif_list
init|;
name|h
operator|!=
name|NULL
condition|;
name|h
operator|=
name|h
operator|->
name|hif_next
control|)
if|if
condition|(
name|h
operator|->
name|hif_next
operator|==
name|hif
condition|)
block|{
name|h
operator|->
name|hif_next
operator|=
name|hif
operator|->
name|hif_next
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|h
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|ellist_destroy
argument_list|(
name|hif
operator|->
name|hif_eligible
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hif
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsc_class_modify
parameter_list|(
name|cl
parameter_list|,
name|rsc
parameter_list|,
name|fsc
parameter_list|,
name|usc
parameter_list|)
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|service_curve
modifier|*
name|rsc
decl_stmt|,
decl|*
name|fsc
decl_stmt|,
modifier|*
name|usc
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|internal_sc
modifier|*
name|rsc_tmp
decl_stmt|,
modifier|*
name|fsc_tmp
decl_stmt|,
modifier|*
name|usc_tmp
decl_stmt|;
name|u_int64_t
name|cur_time
decl_stmt|;
name|int
name|s
decl_stmt|;
name|rsc_tmp
operator|=
name|fsc_tmp
operator|=
name|usc_tmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|rsc
operator|!=
name|NULL
operator|&&
operator|(
name|rsc
operator|->
name|m1
operator|!=
literal|0
operator|||
name|rsc
operator|->
name|m2
operator|!=
literal|0
operator|)
operator|&&
name|cl
operator|->
name|cl_rsc
operator|==
name|NULL
condition|)
block|{
name|rsc_tmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internal_sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsc_tmp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
if|if
condition|(
name|fsc
operator|!=
name|NULL
operator|&&
operator|(
name|fsc
operator|->
name|m1
operator|!=
literal|0
operator|||
name|fsc
operator|->
name|m2
operator|!=
literal|0
operator|)
operator|&&
name|cl
operator|->
name|cl_fsc
operator|==
name|NULL
condition|)
block|{
name|fsc_tmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internal_sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|fsc_tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rsc_tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
if|if
condition|(
name|usc
operator|!=
name|NULL
operator|&&
operator|(
name|usc
operator|->
name|m1
operator|!=
literal|0
operator|||
name|usc
operator|->
name|m2
operator|!=
literal|0
operator|)
operator|&&
name|cl
operator|->
name|cl_usc
operator|==
name|NULL
condition|)
block|{
name|usc_tmp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|internal_sc
argument_list|)
argument_list|,
name|M_DEVBUF
argument_list|,
name|M_WAITOK
argument_list|)
expr_stmt|;
if|if
condition|(
name|usc_tmp
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|rsc_tmp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fsc_tmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
block|}
name|cur_time
operator|=
name|read_machclk
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|__NetBSD__
name|s
operator|=
name|splnet
argument_list|()
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|splimp
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|IFQ_LOCK
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|rsc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rsc
operator|->
name|m1
operator|==
literal|0
operator|&&
name|rsc
operator|->
name|m2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|hfsc_purgeq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
operator|->
name|cl_rsc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_rsc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|==
name|NULL
condition|)
name|cl
operator|->
name|cl_rsc
operator|=
name|rsc_tmp
expr_stmt|;
name|sc2isc
argument_list|(
name|rsc
argument_list|,
name|cl
operator|->
name|cl_rsc
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_deadline
argument_list|,
name|cl
operator|->
name|cl_rsc
argument_list|,
name|cur_time
argument_list|,
name|cl
operator|->
name|cl_cumul
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_eligible
operator|=
name|cl
operator|->
name|cl_deadline
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|->
name|sm1
operator|<=
name|cl
operator|->
name|cl_rsc
operator|->
name|sm2
condition|)
block|{
name|cl
operator|->
name|cl_eligible
operator|.
name|dx
operator|=
literal|0
expr_stmt|;
name|cl
operator|->
name|cl_eligible
operator|.
name|dy
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fsc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fsc
operator|->
name|m1
operator|==
literal|0
operator|&&
name|fsc
operator|->
name|m2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
name|hfsc_purgeq
argument_list|(
name|cl
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cl
operator|->
name|cl_fsc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_fsc
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|==
name|NULL
condition|)
name|cl
operator|->
name|cl_fsc
operator|=
name|fsc_tmp
expr_stmt|;
name|sc2isc
argument_list|(
name|fsc
argument_list|,
name|cl
operator|->
name|cl_fsc
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_virtual
argument_list|,
name|cl
operator|->
name|cl_fsc
argument_list|,
name|cl
operator|->
name|cl_vt
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|usc
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|usc
operator|->
name|m1
operator|==
literal|0
operator|&&
name|usc
operator|->
name|m2
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cl
operator|->
name|cl_usc
argument_list|,
name|M_DEVBUF
argument_list|)
expr_stmt|;
name|cl
operator|->
name|cl_usc
operator|=
name|NULL
expr_stmt|;
name|cl
operator|->
name|cl_myf
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|cl
operator|->
name|cl_usc
operator|==
name|NULL
condition|)
name|cl
operator|->
name|cl_usc
operator|=
name|usc_tmp
expr_stmt|;
name|sc2isc
argument_list|(
name|usc
argument_list|,
name|cl
operator|->
name|cl_usc
argument_list|)
expr_stmt|;
name|rtsc_init
argument_list|(
operator|&
name|cl
operator|->
name|cl_ulimit
argument_list|,
name|cl
operator|->
name|cl_usc
argument_list|,
name|cur_time
argument_list|,
name|cl
operator|->
name|cl_total
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|qempty
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
condition|)
block|{
if|if
condition|(
name|cl
operator|->
name|cl_rsc
operator|!=
name|NULL
condition|)
name|update_ed
argument_list|(
name|cl
argument_list|,
name|m_pktlen
argument_list|(
name|qhead
argument_list|(
name|cl
operator|->
name|cl_q
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_fsc
operator|!=
name|NULL
condition|)
name|update_vf
argument_list|(
name|cl
argument_list|,
literal|0
argument_list|,
name|cur_time
argument_list|)
expr_stmt|;
comment|/* is this enough? */
block|}
name|IFQ_UNLOCK
argument_list|(
name|cl
operator|->
name|cl_hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * hfsc device interface  */
end_comment

begin_function
name|int
name|hfscopen
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
if|if
condition|(
name|machclk_freq
operator|==
literal|0
condition|)
name|init_machclk
argument_list|()
expr_stmt|;
if|if
condition|(
name|machclk_freq
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"hfsc: no cpu clock available!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENXIO
operator|)
return|;
block|}
comment|/* everything will be done when the queueing scheme is attached. */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|hfscclose
parameter_list|(
name|dev
parameter_list|,
name|flag
parameter_list|,
name|fmt
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|int
name|flag
decl_stmt|,
name|fmt
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|int
name|err
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|hif
operator|=
name|hif_list
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* destroy all */
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
condition|)
name|altq_disable
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
name|err
operator|=
name|altq_detach
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|hfsc_detach
argument_list|(
name|hif
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
operator|&&
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
name|int
name|hfscioctl
parameter_list|(
name|dev
parameter_list|,
name|cmd
parameter_list|,
name|addr
parameter_list|,
name|flag
parameter_list|,
name|p
parameter_list|)
name|dev_t
name|dev
decl_stmt|;
name|ioctlcmd_t
name|cmd
decl_stmt|;
name|caddr_t
name|addr
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|500000
operator|)
name|struct
name|thread
modifier|*
name|p
decl_stmt|;
else|#
directive|else
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
endif|#
directive|endif
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_interface
modifier|*
name|ifacep
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* check super-user privilege */
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HFSC_GETSTATS
case|:
break|break;
default|default:
if|#
directive|if
operator|(
name|__FreeBSD_version
operator|>
literal|700000
operator|)
if|if
condition|(
operator|(
name|error
operator|=
name|priv_check
argument_list|(
name|p
argument_list|,
name|PRIV_ALTQ_MANAGE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
empty|#elsif (__FreeBSD_version> 400000)
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
else|#
directive|else
if|if
condition|(
operator|(
name|error
operator|=
name|suser
argument_list|(
name|p
operator|->
name|p_ucred
argument_list|,
operator|&
name|p
operator|->
name|p_acflag
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
endif|#
directive|endif
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HFSC_IF_ATTACH
case|:
name|error
operator|=
name|hfsccmd_if_attach
argument_list|(
operator|(
expr|struct
name|hfsc_attach
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_IF_DETACH
case|:
name|error
operator|=
name|hfsccmd_if_detach
argument_list|(
operator|(
expr|struct
name|hfsc_interface
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_ENABLE
case|:
case|case
name|HFSC_DISABLE
case|:
case|case
name|HFSC_CLEAR_HIERARCHY
case|:
name|ifacep
operator|=
operator|(
expr|struct
name|hfsc_interface
operator|*
operator|)
name|addr
expr_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ifacep
operator|->
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|EBADF
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|HFSC_ENABLE
case|:
if|if
condition|(
name|hif
operator|->
name|hif_defaultclass
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|printf
argument_list|(
literal|"hfsc: no default class\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|altq_enable
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_DISABLE
case|:
name|error
operator|=
name|altq_disable
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_CLEAR_HIERARCHY
case|:
name|hfsc_clear_interface
argument_list|(
name|hif
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|HFSC_ADD_CLASS
case|:
name|error
operator|=
name|hfsccmd_add_class
argument_list|(
operator|(
expr|struct
name|hfsc_add_class
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_DEL_CLASS
case|:
name|error
operator|=
name|hfsccmd_delete_class
argument_list|(
operator|(
expr|struct
name|hfsc_delete_class
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_MOD_CLASS
case|:
name|error
operator|=
name|hfsccmd_modify_class
argument_list|(
operator|(
expr|struct
name|hfsc_modify_class
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_ADD_FILTER
case|:
name|error
operator|=
name|hfsccmd_add_filter
argument_list|(
operator|(
expr|struct
name|hfsc_add_filter
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_DEL_FILTER
case|:
name|error
operator|=
name|hfsccmd_delete_filter
argument_list|(
operator|(
expr|struct
name|hfsc_delete_filter
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|HFSC_GETSTATS
case|:
name|error
operator|=
name|hfsccmd_class_stats
argument_list|(
operator|(
expr|struct
name|hfsc_class_stats
operator|*
operator|)
name|addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
return|return
name|error
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_if_attach
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_attach
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|ifunit
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
if|if
condition|(
operator|(
name|hif
operator|=
name|hfsc_attach
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ap
operator|->
name|bandwidth
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* 	 * set HFSC to this ifnet structure. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|altq_attach
argument_list|(
operator|&
name|ifp
operator|->
name|if_snd
argument_list|,
name|ALTQT_HFSC
argument_list|,
name|hif
argument_list|,
name|hfsc_enqueue
argument_list|,
name|hfsc_dequeue
argument_list|,
name|hfsc_request
argument_list|,
operator|&
name|hif
operator|->
name|hif_classifier
argument_list|,
name|acc_classify
argument_list|)
operator|)
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|hfsc_detach
argument_list|(
name|hif
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_if_detach
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_interface
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|ALTQ_IS_ENABLED
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
condition|)
name|altq_disable
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|altq_detach
argument_list|(
name|hif
operator|->
name|hif_ifq
argument_list|)
operator|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
name|hfsc_detach
argument_list|(
name|hif
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_add_class
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_add_class
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|parent_handle
operator|==
name|HFSC_NULLCLASS_HANDLE
operator|&&
name|hif
operator|->
name|hif_rootclass
operator|==
name|NULL
condition|)
name|parent
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|parent
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|ap
operator|->
name|parent_handle
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* assign a class handle (use a free slot number for now) */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|HFSC_MAX_CLASSES
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hif
operator|->
name|hif_class_tbl
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|HFSC_MAX_CLASSES
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
if|if
condition|(
operator|(
name|cl
operator|=
name|hfsc_class_create
argument_list|(
name|hif
argument_list|,
operator|&
name|ap
operator|->
name|service_curve
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|parent
argument_list|,
name|ap
operator|->
name|qlimit
argument_list|,
name|ap
operator|->
name|flags
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
comment|/* return a class handle to the user */
name|ap
operator|->
name|class_handle
operator|=
name|i
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_delete_class
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_delete_class
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
operator|(
name|cl
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|ap
operator|->
name|class_handle
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
name|hfsc_class_destroy
argument_list|(
name|cl
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_modify_class
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_modify_class
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|service_curve
modifier|*
name|rsc
init|=
name|NULL
decl_stmt|;
name|struct
name|service_curve
modifier|*
name|fsc
init|=
name|NULL
decl_stmt|;
name|struct
name|service_curve
modifier|*
name|usc
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
operator|(
name|cl
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|ap
operator|->
name|class_handle
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|ap
operator|->
name|sctype
operator|&
name|HFSC_REALTIMESC
condition|)
name|rsc
operator|=
operator|&
name|ap
operator|->
name|service_curve
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|sctype
operator|&
name|HFSC_LINKSHARINGSC
condition|)
name|fsc
operator|=
operator|&
name|ap
operator|->
name|service_curve
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|sctype
operator|&
name|HFSC_UPPERLIMITSC
condition|)
name|usc
operator|=
operator|&
name|ap
operator|->
name|service_curve
expr_stmt|;
return|return
name|hfsc_class_modify
argument_list|(
name|cl
argument_list|,
name|rsc
argument_list|,
name|fsc
argument_list|,
name|usc
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_add_filter
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_add_filter
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
if|if
condition|(
operator|(
name|cl
operator|=
name|clh_to_clp
argument_list|(
name|hif
argument_list|,
name|ap
operator|->
name|class_handle
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|is_a_parent_class
argument_list|(
name|cl
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|ALTQ_DEBUG
name|printf
argument_list|(
literal|"hfsccmd_add_filter: not a leaf class!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
return|return
name|acc_add_filter
argument_list|(
operator|&
name|hif
operator|->
name|hif_classifier
argument_list|,
operator|&
name|ap
operator|->
name|filter
argument_list|,
name|cl
argument_list|,
operator|&
name|ap
operator|->
name|filter_handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_delete_filter
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_delete_filter
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
return|return
name|acc_delete_filter
argument_list|(
operator|&
name|hif
operator|->
name|hif_classifier
argument_list|,
name|ap
operator|->
name|filter_handle
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hfsccmd_class_stats
parameter_list|(
name|ap
parameter_list|)
name|struct
name|hfsc_class_stats
modifier|*
name|ap
decl_stmt|;
block|{
name|struct
name|hfsc_if
modifier|*
name|hif
decl_stmt|;
name|struct
name|hfsc_class
modifier|*
name|cl
decl_stmt|;
name|struct
name|hfsc_classstats
name|stats
decl_stmt|,
modifier|*
name|usp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|nclasses
decl_stmt|,
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|hif
operator|=
name|altq_lookup
argument_list|(
name|ap
operator|->
name|iface
operator|.
name|hfsc_ifname
argument_list|,
name|ALTQT_HFSC
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBADF
operator|)
return|;
name|ap
operator|->
name|cur_time
operator|=
name|read_machclk
argument_list|()
expr_stmt|;
name|ap
operator|->
name|machclk_freq
operator|=
name|machclk_freq
expr_stmt|;
name|ap
operator|->
name|hif_classes
operator|=
name|hif
operator|->
name|hif_classes
expr_stmt|;
name|ap
operator|->
name|hif_packets
operator|=
name|hif
operator|->
name|hif_packets
expr_stmt|;
comment|/* skip the first N classes in the tree */
name|nclasses
operator|=
name|ap
operator|->
name|nskip
expr_stmt|;
for|for
control|(
name|cl
operator|=
name|hif
operator|->
name|hif_rootclass
operator|,
name|n
operator|=
literal|0
init|;
name|cl
operator|!=
name|NULL
operator|&&
name|n
operator|<
name|nclasses
condition|;
name|cl
operator|=
name|hfsc_nextclass
argument_list|(
name|cl
argument_list|)
operator|,
name|n
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|n
operator|!=
name|nclasses
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* then, read the next N classes in the tree */
name|nclasses
operator|=
name|ap
operator|->
name|nclasses
expr_stmt|;
name|usp
operator|=
name|ap
operator|->
name|stats
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|cl
operator|!=
name|NULL
operator|&&
name|n
operator|<
name|nclasses
condition|;
name|cl
operator|=
name|hfsc_nextclass
argument_list|(
name|cl
argument_list|)
operator|,
name|n
operator|++
control|)
block|{
name|get_class_stats
argument_list|(
operator|&
name|stats
argument_list|,
name|cl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|copyout
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|stats
argument_list|,
operator|(
name|caddr_t
operator|)
name|usp
operator|++
argument_list|,
sizeof|sizeof
argument_list|(
name|stats
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ap
operator|->
name|nclasses
operator|=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|KLD_MODULE
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|altqsw
name|hfsc_sw
init|=
block|{
literal|"hfsc"
block|,
name|hfscopen
block|,
name|hfscclose
block|,
name|hfscioctl
block|}
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ALTQ_MODULE
argument_list|(
name|altq_hfsc
argument_list|,
name|ALTQT_HFSC
argument_list|,
operator|&
name|hfsc_sw
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|altq_hfsc
argument_list|,
name|altq_red
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MODULE_DEPEND
argument_list|(
name|altq_hfsc
argument_list|,
name|altq_rio
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* KLD_MODULE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ3_COMPAT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ALTQ_HFSC */
end_comment

end_unit

