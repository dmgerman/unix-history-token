begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-dfa-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon dfa.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_DFA_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_DFA_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_BIST0
value|CVMX_DFA_BIST0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_BIST0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_BIST0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370007F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_BIST0
value|(CVMX_ADD_IO_SEG(0x00011800370007F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_BIST1
value|CVMX_DFA_BIST1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_BIST1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_BIST1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370007F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_BIST1
value|(CVMX_ADD_IO_SEG(0x00011800370007F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_BST0
value|CVMX_DFA_BST0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_BST0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_BST0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800300007F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_BST0
value|(CVMX_ADD_IO_SEG(0x00011800300007F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_BST1
value|CVMX_DFA_BST1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_BST1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_BST1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800300007F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_BST1
value|(CVMX_ADD_IO_SEG(0x00011800300007F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_CFG
value|CVMX_DFA_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_CFG
value|(CVMX_ADD_IO_SEG(0x0001180030000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_CONFIG
value|CVMX_DFA_CONFIG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_CONFIG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_CONFIG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_CONFIG
value|(CVMX_ADD_IO_SEG(0x0001180037000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_CONTROL
value|CVMX_DFA_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_CONTROL
value|(CVMX_ADD_IO_SEG(0x0001180037000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DBELL
value|CVMX_DFA_DBELL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DBELL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DBELL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001370000000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DBELL
value|(CVMX_ADD_IO_SEG(0x0001370000000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_ADDR
value|CVMX_DFA_DDR2_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000210ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_ADDR
value|(CVMX_ADD_IO_SEG(0x0001180030000210ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_BUS
value|CVMX_DFA_DDR2_BUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_BUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_BUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_BUS
value|(CVMX_ADD_IO_SEG(0x0001180030000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_CFG
value|CVMX_DFA_DDR2_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000208ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_CFG
value|(CVMX_ADD_IO_SEG(0x0001180030000208ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_COMP
value|CVMX_DFA_DDR2_COMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_COMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_COMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_COMP
value|(CVMX_ADD_IO_SEG(0x0001180030000090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_EMRS
value|CVMX_DFA_DDR2_EMRS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_EMRS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_EMRS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000268ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_EMRS
value|(CVMX_ADD_IO_SEG(0x0001180030000268ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_FCNT
value|CVMX_DFA_DDR2_FCNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_FCNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_FCNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000078ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_FCNT
value|(CVMX_ADD_IO_SEG(0x0001180030000078ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_MRS
value|CVMX_DFA_DDR2_MRS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_MRS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_MRS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000260ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_MRS
value|(CVMX_ADD_IO_SEG(0x0001180030000260ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_OPT
value|CVMX_DFA_DDR2_OPT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_OPT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_OPT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000070ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_OPT
value|(CVMX_ADD_IO_SEG(0x0001180030000070ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_PLL
value|CVMX_DFA_DDR2_PLL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_PLL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_PLL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_PLL
value|(CVMX_ADD_IO_SEG(0x0001180030000088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_TMG
value|CVMX_DFA_DDR2_TMG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DDR2_TMG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DDR2_TMG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000218ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DDR2_TMG
value|(CVMX_ADD_IO_SEG(0x0001180030000218ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG0
value|CVMX_DFA_DEBUG0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DEBUG0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DEBUG0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG0
value|(CVMX_ADD_IO_SEG(0x0001180037000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG1
value|CVMX_DFA_DEBUG1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DEBUG1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DEBUG1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000048ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG1
value|(CVMX_ADD_IO_SEG(0x0001180037000048ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG2
value|CVMX_DFA_DEBUG2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DEBUG2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DEBUG2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000050ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG2
value|(CVMX_ADD_IO_SEG(0x0001180037000050ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG3
value|CVMX_DFA_DEBUG3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DEBUG3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DEBUG3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DEBUG3
value|(CVMX_ADD_IO_SEG(0x0001180037000058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DIFCTL
value|CVMX_DFA_DIFCTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DIFCTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DIFCTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001370600000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DIFCTL
value|(CVMX_ADD_IO_SEG(0x0001370600000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DIFRDPTR
value|CVMX_DFA_DIFRDPTR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DIFRDPTR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DIFRDPTR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001370200000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DIFRDPTR
value|(CVMX_ADD_IO_SEG(0x0001370200000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_DTCFADR
value|CVMX_DFA_DTCFADR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_DTCFADR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_DTCFADR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_DTCFADR
value|(CVMX_ADD_IO_SEG(0x0001180037000060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_ECLKCFG
value|CVMX_DFA_ECLKCFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_ECLKCFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_ECLKCFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000200ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_ECLKCFG
value|(CVMX_ADD_IO_SEG(0x0001180030000200ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_ERR
value|CVMX_DFA_ERR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_ERR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_ERR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_ERR
value|(CVMX_ADD_IO_SEG(0x0001180030000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_ERROR
value|CVMX_DFA_ERROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_ERROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_ERROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_ERROR
value|(CVMX_ADD_IO_SEG(0x0001180037000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_INTMSK
value|CVMX_DFA_INTMSK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_INTMSK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_INTMSK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_INTMSK
value|(CVMX_ADD_IO_SEG(0x0001180037000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMCFG0
value|CVMX_DFA_MEMCFG0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMCFG0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMCFG0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMCFG0
value|(CVMX_ADD_IO_SEG(0x0001180030000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMCFG1
value|CVMX_DFA_MEMCFG1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMCFG1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMCFG1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMCFG1
value|(CVMX_ADD_IO_SEG(0x0001180030000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMCFG2
value|CVMX_DFA_MEMCFG2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMCFG2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMCFG2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMCFG2
value|(CVMX_ADD_IO_SEG(0x0001180030000060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMFADR
value|CVMX_DFA_MEMFADR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMFADR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMFADR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMFADR
value|(CVMX_ADD_IO_SEG(0x0001180030000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMFCR
value|CVMX_DFA_MEMFCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMFCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMFCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMFCR
value|(CVMX_ADD_IO_SEG(0x0001180030000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMHIDAT
value|CVMX_DFA_MEMHIDAT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMHIDAT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMHIDAT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001370700000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMHIDAT
value|(CVMX_ADD_IO_SEG(0x0001370700000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_MEMRLD
value|CVMX_DFA_MEMRLD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_MEMRLD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_MEMRLD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_MEMRLD
value|(CVMX_ADD_IO_SEG(0x0001180030000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_NCBCTL
value|CVMX_DFA_NCBCTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_NCBCTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_NCBCTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_NCBCTL
value|(CVMX_ADD_IO_SEG(0x0001180030000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC0_CNT
value|CVMX_DFA_PFC0_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC0_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC0_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC0_CNT
value|(CVMX_ADD_IO_SEG(0x0001180037000090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC0_CTL
value|CVMX_DFA_PFC0_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC0_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC0_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC0_CTL
value|(CVMX_ADD_IO_SEG(0x0001180037000088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC1_CNT
value|CVMX_DFA_PFC1_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC1_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC1_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370000A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC1_CNT
value|(CVMX_ADD_IO_SEG(0x00011800370000A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC1_CTL
value|CVMX_DFA_PFC1_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC1_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC1_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000098ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC1_CTL
value|(CVMX_ADD_IO_SEG(0x0001180037000098ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC2_CNT
value|CVMX_DFA_PFC2_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC2_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC2_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370000B0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC2_CNT
value|(CVMX_ADD_IO_SEG(0x00011800370000B0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC2_CTL
value|CVMX_DFA_PFC2_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC2_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC2_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370000A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC2_CTL
value|(CVMX_ADD_IO_SEG(0x00011800370000A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC3_CNT
value|CVMX_DFA_PFC3_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC3_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC3_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370000C0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC3_CNT
value|(CVMX_ADD_IO_SEG(0x00011800370000C0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC3_CTL
value|CVMX_DFA_PFC3_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC3_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC3_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800370000B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC3_CTL
value|(CVMX_ADD_IO_SEG(0x00011800370000B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_PFC_GCTL
value|CVMX_DFA_PFC_GCTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_PFC_GCTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_PFC_GCTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180037000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_PFC_GCTL
value|(CVMX_ADD_IO_SEG(0x0001180037000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_RODT_COMP_CTL
value|CVMX_DFA_RODT_COMP_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_RODT_COMP_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_RODT_COMP_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000068ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_RODT_COMP_CTL
value|(CVMX_ADD_IO_SEG(0x0001180030000068ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG0
value|CVMX_DFA_SBD_DBG0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_SBD_DBG0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_SBD_DBG0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG0
value|(CVMX_ADD_IO_SEG(0x0001180030000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG1
value|CVMX_DFA_SBD_DBG1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_SBD_DBG1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_SBD_DBG1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000048ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG1
value|(CVMX_ADD_IO_SEG(0x0001180030000048ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG2
value|CVMX_DFA_SBD_DBG2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_SBD_DBG2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_SBD_DBG2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000050ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG2
value|(CVMX_ADD_IO_SEG(0x0001180030000050ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG3
value|CVMX_DFA_SBD_DBG3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_DFA_SBD_DBG3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_DFA_SBD_DBG3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180030000058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_DFA_SBD_DBG3
value|(CVMX_ADD_IO_SEG(0x0001180030000058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_dfa_bist0  *  * DFA_BIST0 = DFA Bist Status (per-DTC)  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_bist0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_bist0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for GFB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx2
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX2 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stx1
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX1 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX0 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtx2
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX2 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dtx1
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX1 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX0 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for RWB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdb
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for PDB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|pdb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtx1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtx2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_bist0_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX0 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX0 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RWB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pdb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for PDB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|pdb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_dfa_bist0_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|mwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MWB RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_25_27
range|:
literal|3
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFB RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RWB[3:0] RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pdb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for PDB RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|pdb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_23
range|:
literal|6
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_27
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dfa_bist0_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_bist0_cn63xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_dfa_bist0_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|mrp
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for MRP RAM(s) (per-DLC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for GFB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx2
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX2 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stx1
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX1 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for STX0 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtx2
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX2 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dtx1
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX1 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for DTX0 RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for RWB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdb
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for PDB RAM(s) (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|pdb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtx1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtx2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stx2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|gfb
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_dfa_bist0_cn68xx
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_bist0
name|cvmx_dfa_bist0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_bist1  *  * DFA_BIST1 = DFA Bist Status (Globals)  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_bist1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_bist1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|dlc1ram
range|:
literal|1
decl_stmt|;
comment|/**< DLC1 Bist Results                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dlc0ram
range|:
literal|1
decl_stmt|;
comment|/**< DLC0 Bist Results                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dc2ram3
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#2 Bist Results for RAM3 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dc2ram2
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#2 Bist Results for RAM2 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dc2ram1
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#2 Bist Results for RAM1 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dc1ram3
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#1 Bist Results for RAM3 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dc1ram2
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#1 Bist Results for RAM2 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dc1ram1
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#1 Bist Results for RAM1 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram3
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#0 Bist Results for RAM3 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram2
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#0 Bist Results for RAM2 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram1
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#0 Bist Results for RAM1 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gutv
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GUTV RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gutp
range|:
literal|3
decl_stmt|;
comment|/**< Bist Results for GUTP RAMs (per-cluster)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ncd
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for NCD RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gif
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GIF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gib
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GIB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gib
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gutp
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gutv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc1ram1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc1ram2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc1ram3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc2ram1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc2ram2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc2ram3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlc0ram
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlc1ram
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_bist1_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|dlc0ram
range|:
literal|1
decl_stmt|;
comment|/**< DLC0 Bist Results                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_13_18
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ram3
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#0 Bist Results for RAM3 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram2
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#0 Bist Results for RAM2 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram1
range|:
literal|1
decl_stmt|;
comment|/**< Cluster#0 Bist Results for RAM1 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gutv
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GUTV RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|gutp
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GUTP RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ncd
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for NCD RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gif
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GIF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gib
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GIB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gib
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gutp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|gutv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_18
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dlc0ram
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_dfa_bist1_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|ram3
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RAM3 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram2
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RAM2 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ram1
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RAM1 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gutv
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GUTV RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|gutp
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for NCD RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ncd
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for NCD RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gif
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GIF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gib
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GIB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gib
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gif
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gutp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|gutv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ram3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dfa_bist1_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_bist1_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_bist1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_bist1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_bist1
name|cvmx_dfa_bist1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_bst0  *  * DFA_BST0 = DFA Bist Status  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_bst0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_bst0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|16
decl_stmt|;
comment|/**< Bist Results for RDF[3:0] RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|pdf
range|:
literal|16
decl_stmt|;
comment|/**< Bist Results for PDF[3:0] RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|pdf
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_bst0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_bst0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_bst0_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_dfa_bst0_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for RDF[3:0] RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|pdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for PDF[3:0] RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|pdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|rdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_dfa_bst0_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_bst0
name|cvmx_dfa_bst0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_bst1  *  * DFA_BST1 = DFA Bist Status  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_bst1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_bst1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ifu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for IFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|drf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|crf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p0_bwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for P0_BWB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p1_bwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for P1_BWB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p0_brf
range|:
literal|8
decl_stmt|;
comment|/**< Bist Results for P0_BRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p1_brf
range|:
literal|8
decl_stmt|;
comment|/**< Bist Results for P1_BRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|p1_brf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_brf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_bwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_bwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_bst1_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ifu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for IFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|drf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|crf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_0_17
range|:
literal|18
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_17
range|:
literal|18
decl_stmt|;
name|uint64_t
name|crf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_dfa_bst1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_bst1_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_dfa_bst1_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRQ RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ifu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for IFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for GFU RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for CRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p0_bwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for P0_BWB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p1_bwb
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for P1_BWB RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p0_brf
range|:
literal|8
decl_stmt|;
comment|/**< Bist Results for P0_BRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|p1_brf
range|:
literal|8
decl_stmt|;
comment|/**< Bist Results for P1_BRF RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|p1_brf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_brf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_bwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_bwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gfu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_dfa_bst1_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_bst1
name|cvmx_dfa_bst1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_cfg  *  * Specify the RSL base addresses for the block  *  *                  DFA_CFG = DFA Configuration  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|nrpl_ena
range|:
literal|1
decl_stmt|;
comment|/**< When set, allows the per-node replication feature to be                                                          enabled.                                                          In 36-bit mode: The IWORD0[31:30]=SNREPL field AND                                                          bits [21:20] of the Next Node ptr are used in generating                                                          the next node address (see OCTEON HRM - DFA Chapter for                                                          psuedo-code of DTE next node address generation).                                                          NOTE: When NRPL_ENA=1 and IWORD0[TY]=1(36b mode),                                                          (regardless of IWORD0[NRPLEN]), the Resultant Word1+                                                          [[47:44],[23:20]] = Next Node's [27:20] bits. This allows                                                          SW to use the RESERVED bits of the final node for SW                                                          caching. Also, if required, SW will use [22:21]=Node                                                          Replication to re-start the same graph walk(if graph                                                          walk prematurely terminated (ie: DATA_GONE).                                                          In 18-bit mode: The IWORD0[31:30]=SNREPL field AND                                                          bit [16:14] of the Next Node ptr are used in generating                                                          the next node address (see OCTEON HRM - DFA Chapter for                                                          psuedo-code of DTE next node address generation).                                                          If (IWORD0[NREPLEN]=1 and DFA_CFG[NRPL_ENA]=1) [                                                             If next node ptr[16] is set [                                                               next node ptr[15:14] indicates the next node repl                                                               next node ptr[13:0]  indicates the position of the                                                                  node relative to the first normal node (i.e.                                                                  IWORD3[Msize] must be added to get the final node)                                                             ]                                                             else If next node ptr[16] is not set [                                                               next node ptr[15:0] indicates the next node id                                                               next node repl = 0                                                             ]                                                          ]                                                          NOTE: For 18b node replication, MAX node space=64KB(2^16)                                                          is used in detecting terminal node space(see HRM for full                                                          description).                                                          NOTE: The DFA graphs MUST BE built/written to DFA LLM memory                                                          aware of the "per-node" replication. */
name|uint64_t
name|nxor_ena
range|:
literal|1
decl_stmt|;
comment|/**< When set, allows the DTE Instruction IWORD0[NXOREN]                                                          to be used to enable/disable the per-node address 'scramble'                                                          of the LLM address to lessen the effects of bank conflicts.                                                          If IWORD0[NXOREN] is also set, then:                                                          In 36-bit mode: The node_Id[7:0] 8-bit value is XORed                                                          against the LLM address addr[9:2].                                                          In 18-bit mode: The node_id[6:0] 7-bit value is XORed                                                          against the LLM address addr[8:2]. (note: we don't address                                                          scramble outside the mode's node space).                                                          NOTE: The DFA graphs MUST BE built/written to DFA LLM memory                                                          aware of the "per-node" address scramble.                                                          NOTE: The address 'scramble' ocurs for BOTH DFA LLM graph                                                          read/write operations. */
name|uint64_t
name|gxor_ena
range|:
literal|1
decl_stmt|;
comment|/**< When set, the DTE Instruction IWORD0[GXOR]                                                          field is used to 'scramble' the LLM address                                                          to lessen the effects of bank conflicts.                                                          In 36-bit mode: The GXOR[7:0] 8-bit value is XORed                                                          against the LLM address addr[9:2].                                                          In 18-bit mode: GXOR[6:0] 7-bit value is XORed against                                                          the LLM address addr[8:2]. (note: we don't address                                                          scramble outside the mode's node space)                                                          NOTE: The DFA graphs MUST BE built/written to DFA LLM memory                                                          aware of the "per-graph" address scramble.                                                          NOTE: The address 'scramble' ocurs for BOTH DFA LLM graph                                                          read/write operations. */
name|uint64_t
name|sarb
range|:
literal|1
decl_stmt|;
comment|/**< DFA Source Arbiter Mode                                                          Selects the arbitration mode used to select DFA                                                          requests issued from either CP2 or the DTE (NCB-CSR                                                          or DFA HW engine).                                                             - 0: Fixed Priority [Highest=CP2, Lowest=DTE]                                                             - 1: Round-Robin                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|sarb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gxor_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nxor_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nrpl_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_cfg_s
name|cn38xx
decl_stmt|;
struct|struct
name|cvmx_dfa_cfg_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|sarb
range|:
literal|1
decl_stmt|;
comment|/**< DFA Source Arbiter Mode                                                          Selects the arbitration mode used to select DFA                                                          requests issued from either CP2 or the DTE (NCB-CSR                                                          or DFA HW engine).                                                             - 0: Fixed Priority [Highest=CP2, Lowest=DTE]                                                             - 1: Round-Robin                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|sarb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_dfa_cfg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_cfg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_cfg
name|cvmx_dfa_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_config  *  * Specify the RSL base addresses for the block  *  *                  DFA_CONFIG = DFA Configuration Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_config
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_config_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|dlcclear_bist
range|:
literal|1
decl_stmt|;
comment|/**< When DLCSTART_BIST is written 0->1, if DLCCLEAR_BIST=1, all                                                          previous DLC BiST state is cleared.                                                          NOTES:                                                          1) DLCCLEAR_BIST must be written to 1 before DLCSTART_BIST                                                          is written to 1 udsing a separate CSR write.                                                          2) DLCCLEAR_BIST must not be changed after writing DLCSTART_BIST                                                          0->1 until the BIST operation completes. */
name|uint64_t
name|dlcstart_bist
range|:
literal|1
decl_stmt|;
comment|/**< When software writes DLCSTART_BIST=0->1, a BiST is executed                                                          for the DLC sub-block RAMs which contains DCLK domain                                                          asynchronous RAMs.                                                          NOTES:                                                          1) This bit should only be written after DCLK has been enabled                                                          by software and is stable.                                                          (see LMC initialization routine for details on how to enable                                                          the DDR3 memory (DCLK) - which requires LMC PLL init, clock                                                          divider and proper DLL initialization sequence). */
name|uint64_t
name|repl_ena
range|:
literal|1
decl_stmt|;
comment|/**< Replication Mode Enable                                                          *** o63-P2 NEW ***                                                          When set, enables replication mode performance enhancement                                                          feature. This enables the DFA to communicate address                                                          replication information during memory references to the                                                          memory controller.                                                          For o63-P2: This is used by the memory controller                                                          to support graph data in multiple banks (or bank sets), so that                                                          the least full bank can be selected to minimize the effects of                                                          DDR3 bank conflicts (ie: tRC=row cycle time).                                                          For o68: This is used by the memory controller to support graph                                                          data in multiple ports (or port sets), so that the least full                                                          port can be selected to minimize latency effects.                                                          SWNOTE: Using this mode requires the DFA SW compiler and DFA                                                          driver to be aware of the address replication changes.                                                          This involves changes to the MLOAD/GWALK DFA instruction format                                                          (see: IWORD2.SREPL), as well as changes to node arc and metadata                                                          definitions which now support an additional REPL field.                                                          When clear, replication mode is disabled, and DFA will interpret                                                          DFA instructions and node-arc formats which DO NOT have                                                          address replication information. */
name|uint64_t
name|clmskcrip
range|:
literal|4
decl_stmt|;
comment|/**< Cluster Cripple Mask                                                          A one in each bit of the mask represents which DTE cluster to                                                          cripple.                                                          NOTE: o63 has only a single Cluster (therefore CLMSKCRIP[0]                                                          is the only bit used.                                                          o2 has 4 clusters, where all CLMSKCRIP mask bits are used.                                                          SWNOTE: The MIO_FUS___DFA_CLMASK_CRIPPLE[3:0] fuse bits will                                                          be forced into this register at reset. Any fuse bits that                                                          contain '1' will be disallowed during a write and will always                                                          be read as '1'. */
name|uint64_t
name|cldtecrip
range|:
literal|3
decl_stmt|;
comment|/**< Encoding which represents \#of DTEs to cripple for each                                                          cluster. Typically DTE_CLCRIP=0 which enables all DTEs                                                          within each cluster. However, when the DFA performance                                                          counters are used, SW may want to limit the \#of DTEs                                                          per cluster available, as there are only 4 parallel                                                          performance counters.                                                             DTE_CLCRIP | \#DTEs crippled(per cluster)                                                          ------------+-----------------------------                                                                 0    |  0      DTE[15:0]:ON                                                                 1    |  1/2    DTE[15:8]:OFF  /DTE[7:0]:ON                                                                 2    |  1/4    DTE[15:12]:OFF /DTE[11:0]:ON                                                                 3    |  3/4    DTE[15:4]:OFF  /DTE[3:0]:ON                                                                 4    |  1/8    DTE[15:14]:OFF /DTE[13:0]:ON                                                                 5    |  5/8    DTE[15:6]:OFF  /DTE[5:0]:ON                                                                 6    |  3/8    DTE[15:10]:OFF /DTE[9:0]:ON                                                                 7    |  7/8    DTE[15:2]:OFF  /DTE[1:0]:ON                                                          NOTE: Higher numbered DTEs are crippled first. For instance,                                                          on o63 (with 16 DTEs/cluster), if DTE_CLCRIP=1(1/2), then                                                          DTE#s [15:8] within the cluster are crippled and only                                                          DTE#s [7:0] are available.                                                          IMPNOTE: The encodings are done in such a way as to later                                                          be used with fuses (for future o2 revisions which will disable                                                          some \#of DTEs). Blowing a fuse has the effect that there will                                                          always be fewer DTEs available. [ie: we never want a customer                                                          to blow additional fuses to get more DTEs].                                                          SWNOTE: The MIO_FUS___DFA_NUMDTE_CRIPPLE[2:0] fuse bits will                                                          be forced into this register at reset. Any fuse bits that                                                          contain '1' will be disallowed during a write and will always                                                          be read as '1'. */
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
comment|/**< DFA Clock Disable Source                                                          When SET, the DFA clocks for DTE(thread engine)                                                          operation are disabled (to conserve overall chip clocking                                                          power when the DFA function is not used).                                                          NOTE: When SET, SW MUST NEVER issue NCB-Direct CSR                                                          operations to the DFA (will result in NCB Bus Timeout                                                          errors).                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          SWNOTE: The MIO_FUS___DFA_DTE_DISABLE fuse bit will                                                          be forced into this register at reset. If the fuse bit                                                          contains '1', writes to DTECLKDIS are disallowed and                                                          will always be read as '1'. */
else|#
directive|else
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cldtecrip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clmskcrip
range|:
literal|4
decl_stmt|;
name|uint64_t
name|repl_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlcstart_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlcclear_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_config_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_dfa_config_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|repl_ena
range|:
literal|1
decl_stmt|;
comment|/**< Replication Mode Enable                                                          *** o63-P2 NEW ***                                                          When set, enables replication mode performance enhancement                                                          feature. This enables the DFA to communicate address                                                          replication information during memory references to the DFM                                                          (memory controller). This in turn is used by the DFM to support                                                          graph data in multiple banks (or bank sets), so that the least                                                          full bank can be selected to minimize the effects of DDR3 bank                                                          conflicts (ie: tRC=row cycle time).                                                          SWNOTE: Using this mode requires the DFA SW compiler and DFA                                                          driver to be aware of the o63-P2 address replication changes.                                                          This involves changes to the MLOAD/GWALK DFA instruction format                                                          (see: IWORD2.SREPL), as well as changes to node arc and metadata                                                          definitions which now support an additional REPL field.                                                          When clear, replication mode is disabled, and DFA will interpret                                                          o63-P1 DFA instructions and node-arc formats which DO NOT have                                                          address replication information. */
name|uint64_t
name|clmskcrip
range|:
literal|4
decl_stmt|;
comment|/**< Cluster Cripple Mask                                                          A one in each bit of the mask represents which DTE cluster to                                                          cripple.                                                          NOTE: o63 has only a single Cluster (therefore CLMSKCRIP[0]                                                          is the only bit used.                                                          o2 has 4 clusters, where all CLMSKCRIP mask bits are used.                                                          SWNOTE: The MIO_FUS___DFA_CLMASK_CRIPPLE[3:0] fuse bits will                                                          be forced into this register at reset. Any fuse bits that                                                          contain '1' will be disallowed during a write and will always                                                          be read as '1'. */
name|uint64_t
name|cldtecrip
range|:
literal|3
decl_stmt|;
comment|/**< Encoding which represents \#of DTEs to cripple for each                                                          cluster. Typically DTE_CLCRIP=0 which enables all DTEs                                                          within each cluster. However, when the DFA performance                                                          counters are used, SW may want to limit the \#of DTEs                                                          per cluster available, as there are only 4 parallel                                                          performance counters.                                                             DTE_CLCRIP | \#DTEs crippled(per cluster)                                                          ------------+-----------------------------                                                                 0    |  0      DTE[15:0]:ON                                                                 1    |  1/2    DTE[15:8]:OFF  /DTE[7:0]:ON                                                                 2    |  1/4    DTE[15:12]:OFF /DTE[11:0]:ON                                                                 3    |  3/4    DTE[15:4]:OFF  /DTE[3:0]:ON                                                                 4    |  1/8    DTE[15:14]:OFF /DTE[13:0]:ON                                                                 5    |  5/8    DTE[15:6]:OFF  /DTE[5:0]:ON                                                                 6    |  3/8    DTE[15:10]:OFF /DTE[9:0]:ON                                                                 7    |  7/8    DTE[15:2]:OFF  /DTE[1:0]:ON                                                          NOTE: Higher numbered DTEs are crippled first. For instance,                                                          on o63 (with 16 DTEs/cluster), if DTE_CLCRIP=1(1/2), then                                                          DTE#s [15:8] within the cluster are crippled and only                                                          DTE#s [7:0] are available.                                                          IMPNOTE: The encodings are done in such a way as to later                                                          be used with fuses (for future o2 revisions which will disable                                                          some \#of DTEs). Blowing a fuse has the effect that there will                                                          always be fewer DTEs available. [ie: we never want a customer                                                          to blow additional fuses to get more DTEs].                                                          SWNOTE: The MIO_FUS___DFA_NUMDTE_CRIPPLE[2:0] fuse bits will                                                          be forced into this register at reset. Any fuse bits that                                                          contain '1' will be disallowed during a write and will always                                                          be read as '1'. */
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
comment|/**< DFA Clock Disable Source                                                          When SET, the DFA clocks for DTE(thread engine)                                                          operation are disabled (to conserve overall chip clocking                                                          power when the DFA function is not used).                                                          NOTE: When SET, SW MUST NEVER issue NCB-Direct CSR                                                          operations to the DFA (will result in NCB Bus Timeout                                                          errors).                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          SWNOTE: The MIO_FUS___DFA_DTE_DISABLE fuse bit will                                                          be forced into this register at reset. If the fuse bit                                                          contains '1', writes to DTECLKDIS are disallowed and                                                          will always be read as '1'. */
else|#
directive|else
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cldtecrip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clmskcrip
range|:
literal|4
decl_stmt|;
name|uint64_t
name|repl_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_dfa_config_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|clmskcrip
range|:
literal|4
decl_stmt|;
comment|/**< Cluster Cripple Mask                                                          A one in each bit of the mask represents which DTE cluster to                                                          cripple.                                                          NOTE: o63 has only a single Cluster (therefore CLMSKCRIP[0]                                                          is the only bit used.                                                          o2 has 4 clusters, where all CLMSKCRIP mask bits are used.                                                          SWNOTE: The MIO_FUS___DFA_CLMASK_CRIPPLE[3:0] fuse bits will                                                          be forced into this register at reset. Any fuse bits that                                                          contain '1' will be disallowed during a write and will always                                                          be read as '1'. */
name|uint64_t
name|cldtecrip
range|:
literal|3
decl_stmt|;
comment|/**< Encoding which represents \#of DTEs to cripple for each                                                          cluster. Typically DTE_CLCRIP=0 which enables all DTEs                                                          within each cluster. However, when the DFA performance                                                          counters are used, SW may want to limit the \#of DTEs                                                          per cluster available, as there are only 4 parallel                                                          performance counters.                                                             DTE_CLCRIP | \#DTEs crippled(per cluster)                                                          ------------+-----------------------------                                                                 0    |  0      DTE[15:0]:ON                                                                 1    |  1/2    DTE[15:8]:OFF  /DTE[7:0]:ON                                                                 2    |  1/4    DTE[15:12]:OFF /DTE[11:0]:ON                                                                 3    |  3/4    DTE[15:4]:OFF  /DTE[3:0]:ON                                                                 4    |  1/8    DTE[15:14]:OFF /DTE[13:0]:ON                                                                 5    |  5/8    DTE[15:6]:OFF  /DTE[5:0]:ON                                                                 6    |  3/8    DTE[15:10]:OFF /DTE[9:0]:ON                                                                 7    |  7/8    DTE[15:2]:OFF  /DTE[1:0]:ON                                                          NOTE: Higher numbered DTEs are crippled first. For instance,                                                          on o63 (with 16 DTEs/cluster), if DTE_CLCRIP=1(1/2), then                                                          DTE#s [15:8] within the cluster are crippled and only                                                          DTE#s [7:0] are available.                                                          IMPNOTE: The encodings are done in such a way as to later                                                          be used with fuses (for future o2 revisions which will disable                                                          some \#of DTEs). Blowing a fuse has the effect that there will                                                          always be fewer DTEs available. [ie: we never want a customer                                                          to blow additional fuses to get more DTEs].                                                          SWNOTE: The MIO_FUS___DFA_NUMDTE_CRIPPLE[2:0] fuse bits will                                                          be forced into this register at reset. Any fuse bits that                                                          contain '1' will be disallowed during a write and will always                                                          be read as '1'. */
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
comment|/**< DFA Clock Disable Source                                                          When SET, the DFA clocks for DTE(thread engine)                                                          operation are disabled (to conserve overall chip clocking                                                          power when the DFA function is not used).                                                          NOTE: When SET, SW MUST NEVER issue NCB-Direct CSR                                                          operations to the DFA (will result in NCB Bus Timeout                                                          errors).                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          SWNOTE: The MIO_FUS___DFA_DTE_DISABLE fuse bit will                                                          be forced into this register at reset. If the fuse bit                                                          contains '1', writes to DTECLKDIS are disallowed and                                                          will always be read as '1'. */
else|#
directive|else
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cldtecrip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clmskcrip
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_dfa_config_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_config_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_config_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_config
name|cvmx_dfa_config_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_control  *  * DFA_CONTROL = DFA Control Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|6
decl_stmt|;
comment|/**< SBD Debug Entry#                                                          *FOR INTERNAL USE ONLY*                                                          DFA Scoreboard debug control                                                          Selects which one of 48 DFA Scoreboard entries is                                                          latched into the DFA_SBD_DBG[0-3] registers. */
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
comment|/**< DFA Scoreboard LOCK Strobe                                                          *FOR INTERNAL USE ONLY*                                                          DFA Scoreboard debug control                                                          When written with a '1', the DFA Scoreboard Debug                                                          registers (DFA_SBD_DBG[0-3]) are all locked down.                                                          This allows SW to lock down the contents of the entire                                                          SBD for a single instant in time. All subsequent reads                                                          of the DFA scoreboard registers will return the data                                                          from that instant in time. */
name|uint64_t
name|reserved_3_4
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRP Arbiter Mode                                                          (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRQ Arbiter Mode                                                          (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-Inbound Arbiter                                                          (0=FP [LP=NRQ,HP=NRP], 1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_4
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_control_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|4
decl_stmt|;
comment|/**< SBD Debug Entry#                                                          *FOR INTERNAL USE ONLY*                                                          DFA Scoreboard debug control                                                          Selects which one of 16 DFA Scoreboard entries is                                                          latched into the DFA_SBD_DBG[0-3] registers. */
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
comment|/**< DFA Scoreboard LOCK Strobe                                                          *FOR INTERNAL USE ONLY*                                                          DFA Scoreboard debug control                                                          When written with a '1', the DFA Scoreboard Debug                                                          registers (DFA_SBD_DBG[0-3]) are all locked down.                                                          This allows SW to lock down the contents of the entire                                                          SBD for a single instant in time. All subsequent reads                                                          of the DFA scoreboard registers will return the data                                                          from that instant in time. */
name|uint64_t
name|reserved_3_4
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRP Arbiter Mode                                                          (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRQ Arbiter Mode                                                          (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-Inbound Arbiter                                                          (0=FP [LP=NRQ,HP=NRP], 1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_4
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_dfa_control_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_control_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_control_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_control_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_control_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_control
name|cvmx_dfa_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_dbell  *  * DFA_DBELL = DFA Doorbell Register  *  * Description:  *  NOTE: To write to the DFA_DBELL register, a device would issue an IOBST directed at the DFA with addr[34:33]=2'b00.  *        To read the DFA_DBELL register, a device would issue an IOBLD64 directed at the DFA with addr[34:33]=2'b00.  *  *  NOTE: If DFA_CONFIG[DTECLKDIS]=1 (DFA-DTE clocks disabled), reads/writes to the DFA_DBELL register do not take effect.  *  NOTE: If FUSE[TBD]="DFA DTE disable" is blown, reads/writes to the DFA_DBELL register do not take effect.  */
end_comment

begin_union
union|union
name|cvmx_dfa_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|dbell
range|:
literal|20
decl_stmt|;
comment|/**< Represents the cumulative total of pending                                                          DFA instructions which SW has previously written                                                          into the DFA Instruction FIFO (DIF) in main memory.                                                          Each DFA instruction contains a fixed size 32B                                                          instruction word which is executed by the DFA HW.                                                          The DBL register can hold up to 1M-1 (2^20-1)                                                          pending DFA instruction requests.                                                          During a read (by SW), the 'most recent' contents                                                          of the DFA_DBELL register are returned at the time                                                          the NCB-INB bus is driven.                                                          NOTE: Since DFA HW updates this register, its                                                          contents are unpredictable in SW. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_dbell_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_dbell_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_dbell
name|cvmx_dfa_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_addr  *  * DFA_DDR2_ADDR = DFA DDR2  fclk-domain Memory Address Config Register  *  *  * Description: The following registers are used to compose the DFA's DDR2 address into ROW/COL/BNK  *              etc.  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
comment|/**< If there is a need to insert a register chip on the                                                          system (the equivalent of a registered DIMM) to                                                          provide better setup for the command and control bits                                                          turn this mode on.                                                              RDIMM_ENA                                                                 0           Registered Mode OFF                                                                 1           Registered Mode ON */
name|uint64_t
name|num_rnks
range|:
literal|2
decl_stmt|;
comment|/**< NUM_RNKS is programmed based on how many ranks there                                                          are in the system. This needs to be programmed correctly                                                          regardless of whether we are in RNK_LO mode or not.                                                             NUM_RNKS     \# of Ranks                                                               0              1                                                               1              2                                                               2              4                                                               3              RESERVED */
name|uint64_t
name|rnk_lo
range|:
literal|1
decl_stmt|;
comment|/**< When this mode is turned on, consecutive addresses                                                          outside the bank boundary                                                          are programmed to go to different ranks in order to                                                          minimize bank conflicts. It is useful in 4-bank DDR2                                                          parts based memory to extend out the \#physical banks                                                          available and minimize bank conflicts.                                                          On 8 bank ddr2 parts, this mode is not very useful                                                          because this mode does come with                                                          a penalty which is that every successive reads that                                                          cross rank boundary will need a 1 cycle bubble                                                          inserted to prevent bus turnaround conflicts.                                                             RNK_LO                                                              0      - OFF                                                              1      - ON */
name|uint64_t
name|num_colrows
range|:
literal|3
decl_stmt|;
comment|/**< NUM_COLROWS    is used to set the MSB of the ROW_ADDR                                                          and the LSB of RANK address when not in RNK_LO mode.                                                          Calculate the sum of \#COL and \#ROW and program the                                                          controller appropriately                                                             RANK_LSB        \#COLs + \#ROWs                                                             ------------------------------                                                              - 000:                   22                                                              - 001:                   23                                                              - 010:                   24                                                              - 011:                   25                                                             - 100-111:             RESERVED */
name|uint64_t
name|num_cols
range|:
literal|2
decl_stmt|;
comment|/**< The Long word address that the controller receives                                                          needs to be converted to Row, Col, Rank and Bank                                                          addresses depending on the memory part's micro arch.                                                          NUM_COL tells the controller how many colum bits                                                          there are and the controller uses this info to map                                                          the LSB of the row address                                                              - 00: num_cols = 9                                                              - 01: num_cols = 10                                                              - 10: num_cols = 11                                                              - 11: RESERVED */
else|#
directive|else
name|uint64_t
name|num_cols
range|:
literal|2
decl_stmt|;
name|uint64_t
name|num_colrows
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rnk_lo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|num_rnks
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rdimm_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_addr_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_addr
name|cvmx_dfa_ddr2_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_bus  *  * DFA_DDR2_BUS = DFA DDR Bus Activity Counter  *  *  * Description: This counter counts \# cycles that the memory bus is doing a read/write/command  *              Useful to benchmark the bus utilization as a ratio of  *              \#Cycles of Data Transfer/\#Cycles since init or  *              \#Cycles of Data Transfer/\#Cycles that memory controller is active  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_bus
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_bus_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|bus_cnt
range|:
literal|47
decl_stmt|;
comment|/**< Counter counts the \# cycles of Data transfer */
else|#
directive|else
name|uint64_t
name|bus_cnt
range|:
literal|47
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_bus_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_bus
name|cvmx_dfa_ddr2_bus_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_cfg  *  * DFA_DDR2_CFG = DFA DDR2 fclk-domain Memory Configuration \#0 Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_41_63
range|:
literal|23
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< Establishes tRFC(from DDR2 data sheets) in \# of                                                          4 fclk intervals.                                                          General Equation:                                                          TRFC(csr) = ROUNDUP[tRFC(data-sheet-ns)/(4 * fclk(ns))]                                                          Example:                                                             tRFC(data-sheet-ns) = 127.5ns                                                             Operational Frequency: 533MHz DDR rate                                                                 [fclk=266MHz(3.75ns)]                                                          Then:                                                             TRFC(csr) = ROUNDUP[127.5ns/(4 * 3.75ns)]                                                                       = 9 */
name|uint64_t
name|mrs_pgm
range|:
literal|1
decl_stmt|;
comment|/**< When clear, the HW initialization sequence fixes                                                          some of the *MRS register bit definitions.                                                             EMRS:                                                               A[14:13] = 0 RESERVED                                                               A[12] = 0    Output Buffers Enabled (FIXED)                                                               A[11] = 0    RDQS Disabled (FIXED)                                                               A[10] = 0    DQSn Enabled (FIXED)                                                               A[9:7] = 0   OCD Not supported (FIXED)                                                               A[6] = 0     RTT Disabled (FIXED)                                                               A[5:3]=DFA_DDR2_TMG[ADDLAT] (if DFA_DDR2_TMG[POCAS]=1)                                                                             Additive LATENCY (Programmable)                                                               A[2]=0       RTT Disabled (FIXED)                                                               A[1]=DFA_DDR2_TMG[DIC] (Programmable)                                                               A[0] = 0     DLL Enabled (FIXED)                                                             MRS:                                                               A[14:13] = 0 RESERVED                                                               A[12] = 0    Fast Active Power Down Mode (FIXED)                                                               A[11:9] = DFA_DDR2_TMG[TWR](Programmable)                                                               A[8] = 1     DLL Reset (FIXED)                                                               A[7] = 0     Test Mode (FIXED)                                                               A[6:4]=DFA_DDR2_TMG[CASLAT] CAS LATENCY (Programmable)                                                               A[3] = 0     Burst Type(must be 0:Sequential) (FIXED)                                                               A[2:0] = 2   Burst Length=4 (must be 0:Sequential) (FIXED)                                                          When set, the HW initialization sequence sources                                                          the DFA_DDR2_MRS, DFA_DDR2_EMRS registers which are                                                          driven onto the DFA_A[] pins. (this allows the MRS/EMRS                                                          fields to be completely programmable - however care                                                          must be taken by software).                                                          This mode is useful for customers who wish to:                                                             1) override the FIXED definitions(above), or                                                             2) Use a "clamshell mode" of operation where the                                                                address bits(per rank) are swizzled on the                                                                board to reduce stub lengths for optimal                                                                frequency operation.                                                          Use this in combination with DFA_DDR2_CFG[RNK_MSK]                                                          to specify the INIT sequence for each of the 4                                                          supported ranks. */
name|uint64_t
name|fpip
range|:
literal|3
decl_stmt|;
comment|/**< Early Fill Programmable Pipe [\#fclks]                                                          This field dictates the \#fclks prior to the arrival                                                          of fill data(in fclk domain), to start the 'early' fill                                                          command pipe (in the eclk domain) so as to minimize the                                                          overall fill latency.                                                          The programmable early fill command signal is synchronized                                                          into the eclk domain, where it is used to pull data out of                                                          asynchronous RAM as fast as possible.                                                          NOTE: A value of FPIP=0 is the 'safest' setting and will                                                          result in the early fill command pipe starting in the                                                          same cycle as the fill data.                                                          General Equation: (for FPIP)                                                              FPIP<= MIN[6, (ROUND_DOWN[6/EF_RATIO] + 1)]                                                          where:                                                            EF_RATIO = ECLK/FCLK Ratio [eclk(MHz)/fclk(MHz)]                                                          Example: FCLK=200MHz/ECLK=600MHz                                                             FPIP = MIN[6, (ROUND_DOWN[6/(600/200))] + 1)]                                                             FPIP<= 3 */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ref_int
range|:
literal|13
decl_stmt|;
comment|/**< Refresh Interval (represented in \#of fclk                                                          increments).                                                          Each refresh interval will generate a single                                                          auto-refresh command sequence which implicitly targets                                                          all banks within the device:                                                          Example: For fclk=200MHz(5ns)/400MHz(DDR):                                                            trefint(ns) = [tREFI(max)=3.9us = 3900ns [datasheet]                                                            REF_INT = ROUND_DOWN[(trefint/fclk)]                                                                    = ROUND_DOWN[(3900ns/5ns)]                                                                    = 780 fclks (0x30c)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< Board Skew (represented in \#fclks)                                                          Represents additional board skew of DQ/DQS.                                                              - 00: board-skew = 0 fclk                                                              - 01: board-skew = 1 fclk                                                              - 10: board-skew = 2 fclk                                                              - 11: board-skew = 3 fclk                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|rnk_msk
range|:
literal|4
decl_stmt|;
comment|/**< Controls the CS_N[3:0] during a) a HW Initialization                                                          sequence (triggered by DFA_DDR2_CFG[INIT]) or                                                          b) during a normal refresh sequence. If                                                          the RNK_MSK[x]=1, the corresponding CS_N[x] is driven.                                                          NOTE: This is required for DRAM used in a                                                          clamshell configuration, since the address lines                                                          carry Mode Register write data that is unique                                                          per rank(or clam). In a clamshell configuration,                                                          the N3K DFA_A[x] pin may be tied into Clam#0's A[x]                                                          and also into Clam#1's 'mirrored' address bit A[y]                                                          (eg: Clam0 sees A[5] and Clam1 sees A[15]).                                                          To support clamshell designs, SW must initiate                                                          separate HW init sequences each unique rank address                                                          mapping. Before each HW init sequence is triggered,                                                          SW must preload the DFA_DDR2_MRS/EMRS registers with                                                          the data that will be driven onto the A[14:0] wires                                                          during the EMRS/MRS mode register write(s).                                                          NOTE: After the final HW initialization sequence has                                                          been triggered, SW must wait 64K eclks before writing                                                          the RNK_MSK[3:0] field = 3'b1111 (so that CS_N[3:0]                                                          is driven during refresh sequences in normal operation.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|silo_qc
range|:
literal|1
decl_stmt|;
comment|/**< Enables Quarter Cycle move of the Rd sampling window */
name|uint64_t
name|silo_hc
range|:
literal|1
decl_stmt|;
comment|/**< A combination of SILO_HC, SILO_QC and TSKW                                                          specifies the positioning of the sampling strobe                                                          when receiving read data back from DDR2. This is                                                          done to offset any board trace induced delay on                                                          the DQ and DQS which inherently makes these                                                          asynchronous with respect to the internal clk of                                                          controller. TSKW moves this sampling window by                                                          integer cycles. SILO_QC and HC move this quarter                                                          and half a cycle respectively. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< Silo Latency (\#fclks): On reads, determines how many                                                          additional fclks to wait (on top of CASLAT+1) before                                                          pulling data out of the padring silos used for time                                                          domain boundary crossing.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
comment|/**< Tristate Enable (back porch) (\#fclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable back porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|fprch
range|:
literal|1
decl_stmt|;
comment|/**< Tristate Enable (front porch) (\#fclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable front porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|init
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for the LLM Memory Port is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Enable memory port                                                                a) PRTENA=1                                                            2) Wait 200us (to ensure a stable clock                                                               to the DDR2) - as per DDR2 spec.                                                            3) Write a '1' to the INIT which                                                               will initiate a hardware initialization                                                               sequence.                                                          NOTE: After writing a '1', SW must wait 64K eclk                                                          cycles to ensure the HW init sequence has completed                                                          before writing to ANY of the DFA_DDR2* registers.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|prtena
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA Memory                                                          When enabled, this bit lets N3K be the default                                                          driver for DFA-LLM memory port. */
else|#
directive|else
name|uint64_t
name|prtena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|silo_hc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|silo_qc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnk_msk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ref_int
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|fpip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mrs_pgm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_41_63
range|:
literal|23
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_cfg_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_cfg
name|cvmx_dfa_ddr2_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_comp  *  * DFA_DDR2_COMP = DFA DDR2 I/O PVT Compensation Configuration  *  *  * Description: The following are registers to program the DDR2 PLL and DLL  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_comp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_comp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dfa__pctl
range|:
literal|4
decl_stmt|;
comment|/**< DFA DDR pctl from compensation circuit                                                          Internal DBG only */
name|uint64_t
name|dfa__nctl
range|:
literal|4
decl_stmt|;
comment|/**< DFA DDR nctl from compensation circuit                                                          Internal DBG only */
name|uint64_t
name|reserved_9_55
range|:
literal|47
decl_stmt|;
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|comp_bypass
range|:
literal|1
decl_stmt|;
comment|/**< Compensation Bypass */
else|#
directive|else
name|uint64_t
name|comp_bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl_csr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_9_55
range|:
literal|47
decl_stmt|;
name|uint64_t
name|dfa__nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dfa__pctl
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_comp_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_comp
name|cvmx_dfa_ddr2_comp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_emrs  *  * DFA_DDR2_EMRS = DDR2 EMRS Register(s) EMRS1[14:0], EMRS1_OCD[14:0]  * Description: This register contains the data driven onto the Address[14:0] lines during  DDR INIT  * To support Clamshelling (where N3K DFA_A[] pins are not 1:1 mapped to each clam(or rank), a HW init  * sequence is allowed on a "per-rank" basis. Care must be taken in the values programmed into these  * registers during the HW initialization sequence (see N3K specific restrictions in notes below).  * DFA_DDR2_CFG[MRS_PGM] must be 1 to support this feature.  *  * Notes:  * For DDR-II please consult your device's data sheet for further details:  *  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_emrs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_emrs_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|emrs1_ocd
range|:
literal|15
decl_stmt|;
comment|/**< Memory Address[14:0] during "EMRS1 (OCD Calibration)"                                                          step \#12a "EMRS OCD Default Command" A[9:7]=111                                                          of DDR2 HW initialization sequence.                                                          (See JEDEC DDR2 specification (JESD79-2):                                                          Power Up and initialization sequence).                                                             A[14:13] = 0, RESERVED                                                             A[12] = 0, Output Buffers Enabled                                                             A[11] = 0, RDQS Disabled (we do not support RDQS)                                                             A[10] = 0, DQSn Enabled                                                             A[9:7] = 7, OCD Calibration Mode Default                                                             A[6] = 0, ODT Disabled                                                             A[5:3]=DFA_DDR2_TMG[ADDLAT]  Additive LATENCY (Default 0)                                                             A[2]=0    Termination Res RTT (ODT off Default)                                                             [A6,A2] = 0 -> ODT Disabled                                                                       1 -> 75 ohm; 2 -> 150 ohm; 3 - Reserved                                                             A[1]=0  Normal Output Driver Imp mode                                                                     (1 - weak ie., 60% of normal drive strength)                                                             A[0] = 0 DLL Enabled */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|emrs1
range|:
literal|15
decl_stmt|;
comment|/**< Memory Address[14:0] during:                                                            a) Step \#7 "EMRS1 to enable DLL (A[0]=0)"                                                            b) Step \#12b "EMRS OCD Calibration Mode Exit"                                                          steps of DDR2 HW initialization sequence.                                                          (See JEDEC DDR2 specification (JESD79-2): Power Up and                                                          initialization sequence).                                                            A[14:13] = 0, RESERVED                                                            A[12] = 0, Output Buffers Enabled                                                            A[11] = 0, RDQS Disabled (we do not support RDQS)                                                            A[10] = 0, DQSn Enabled                                                            A[9:7] = 0, OCD Calibration Mode exit/maintain                                                            A[6] = 0, ODT Disabled                                                            A[5:3]=DFA_DDR2_TMG[ADDLAT]  Additive LATENCY (Default 0)                                                            A[2]=0    Termination Res RTT (ODT off Default)                                                            [A6,A2] = 0 -> ODT Disabled                                                                      1 -> 75 ohm; 2 -> 150 ohm; 3 - Reserved                                                            A[1]=0  Normal Output Driver Imp mode                                                                    (1 - weak ie., 60% of normal drive strength)                                                            A[0] = 0 DLL Enabled */
else|#
directive|else
name|uint64_t
name|emrs1
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|emrs1_ocd
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_emrs_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_emrs
name|cvmx_dfa_ddr2_emrs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_fcnt  *  * DFA_DDR2_FCNT = DFA FCLK Counter  *  *  * Description: This FCLK cycle counter gets going after memory has been initialized  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_fcnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_fcnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|fcyc_cnt
range|:
literal|47
decl_stmt|;
comment|/**< Counter counts FCLK cycles or \# cycles that the memory                                                          controller has requests queued up depending on FCNT_MODE                                                          If FCNT_MODE = 0, this counter counts the \# FCLK cycles                                                          If FCNT_MODE = 1, this counter counts the \# cycles the                                                          controller is active with memory requests. */
else|#
directive|else
name|uint64_t
name|fcyc_cnt
range|:
literal|47
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_fcnt_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_fcnt
name|cvmx_dfa_ddr2_fcnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_mrs  *  * DFA_DDR2_MRS = DDR2 MRS Register(s) MRS_DLL[14:0], MRS[14:0]  * Description: This register contains the data driven onto the Address[14:0] lines during DDR INIT  * To support Clamshelling (where N3K DFA_A[] pins are not 1:1 mapped to each clam(or rank), a HW init  * sequence is allowed on a "per-rank" basis. Care must be taken in the values programmed into these  * registers during the HW initialization sequence (see N3K specific restrictions in notes below).  * DFA_DDR2_CFG[MRS_PGM] must be 1 to support this feature.  *  * Notes:  * For DDR-II please consult your device's data sheet for further details:  *  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_mrs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_mrs_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|mrs
range|:
literal|15
decl_stmt|;
comment|/**< Memory Address[14:0] during "MRS without resetting                                                          DLL A[8]=0" step of HW initialization sequence.                                                          (See JEDEC DDR2 specification (JESD79-2): Power Up                                                          and initialization sequence - Step \#11).                                                            A[14:13] = 0, RESERVED                                                            A[12] = 0, Fast Active Power Down Mode                                                            A[11:9] = DFA_DDR2_TMG[TWR]                                                            A[8] = 0, for DLL Reset                                                            A[7] =0  Test Mode (must be 0 for normal operation)                                                            A[6:4]=DFA_DDR2_TMG[CASLAT] CAS LATENCY (default 4)                                                            A[3]=0    Burst Type(must be 0:Sequential)                                                            A[2:0]=2  Burst Length=4(default) */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrs_dll
range|:
literal|15
decl_stmt|;
comment|/**< Memory Address[14:0] during "MRS for DLL_RESET A[8]=1"                                                          step of HW initialization sequence.                                                          (See JEDEC DDR2 specification (JESD79-2): Power Up                                                          and initialization sequence - Step \#8).                                                            A[14:13] = 0, RESERVED                                                            A[12] = 0, Fast Active Power Down Mode                                                            A[11:9] = DFA_DDR2_TMG[TWR]                                                            A[8] = 1, for DLL Reset                                                            A[7] = 0  Test Mode (must be 0 for normal operation)                                                            A[6:4]=DFA_DDR2_TMG[CASLAT]    CAS LATENCY (default 4)                                                            A[3] = 0    Burst Type(must be 0:Sequential)                                                            A[2:0] = 2  Burst Length=4(default) */
else|#
directive|else
name|uint64_t
name|mrs_dll
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrs
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_mrs_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_mrs
name|cvmx_dfa_ddr2_mrs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_opt  *  * DFA_DDR2_OPT = DFA DDR2 Optimization Registers  *  *  * Description: The following are registers to tweak certain parameters to boost performance  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_opt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_opt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|max_read_batch
range|:
literal|5
decl_stmt|;
comment|/**< Maximum number of consecutive read to service before                                                          allowing write to interrupt. */
name|uint64_t
name|max_write_batch
range|:
literal|5
decl_stmt|;
comment|/**< Maximum number of consecutive writes to service before                                                          allowing reads to interrupt. */
else|#
directive|else
name|uint64_t
name|max_write_batch
range|:
literal|5
decl_stmt|;
name|uint64_t
name|max_read_batch
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_opt_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_opt
name|cvmx_dfa_ddr2_opt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_pll  *  * DFA_DDR2_PLL = DFA DDR2 PLL and DLL Configuration  *  *  * Description: The following are registers to program the DDR2 PLL and DLL  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_pll
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_pll_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pll_setting
range|:
literal|17
decl_stmt|;
comment|/**< Internal Debug Use Only */
name|uint64_t
name|reserved_32_46
range|:
literal|15
decl_stmt|;
name|uint64_t
name|setting90
range|:
literal|5
decl_stmt|;
comment|/**< Contains the setting of DDR DLL; Internal DBG only */
name|uint64_t
name|reserved_21_26
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dll_setting
range|:
literal|5
decl_stmt|;
comment|/**< Contains the open loop setting value for the DDR90 delay                                                          line. */
name|uint64_t
name|dll_byp
range|:
literal|1
decl_stmt|;
comment|/**< DLL Bypass. When set, the DDR90 DLL is bypassed and                                                          the DLL behaves in Open Loop giving a fixed delay                                                          set by DLL_SETTING */
name|uint64_t
name|qdll_ena
range|:
literal|1
decl_stmt|;
comment|/**< DDR Quad DLL Enable: A 0->1 transition on this bit after                                                          erst deassertion will reset the DDR 90 DLL. Allow                                                          200 micro seconds for Lock before DDR Init. */
name|uint64_t
name|bw_ctl
range|:
literal|4
decl_stmt|;
comment|/**< Internal Use Only - for Debug */
name|uint64_t
name|bw_upd
range|:
literal|1
decl_stmt|;
comment|/**< Internal Use Only - for Debug */
name|uint64_t
name|pll_div2
range|:
literal|1
decl_stmt|;
comment|/**< PLL Output is further divided by 2. Useful for slow                                                          fclk frequencies where the PLL may be out of range. */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_ratio
range|:
literal|5
decl_stmt|;
comment|/**< Bits<6:2> sets the clk multiplication ratio                                                          If the fclk frequency desired is less than 260MHz                                                          (lower end saturation point of the pll), write 2x                                                          the ratio desired in this register and set PLL_DIV2 */
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
comment|/**< PLL Bypass. Uses the ref_clk without multiplication. */
name|uint64_t
name|pll_init
range|:
literal|1
decl_stmt|;
comment|/**< Need a 0 to 1 pulse on this CSR to get the DFA                                                          Clk Generator Started. Write this register before                                                          starting anything. Allow 200 uS for PLL Lock before                                                          doing anything. */
else|#
directive|else
name|uint64_t
name|pll_init
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_ratio
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pll_div2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bw_upd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bw_ctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qdll_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dll_setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_26
range|:
literal|6
decl_stmt|;
name|uint64_t
name|setting90
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_32_46
range|:
literal|15
decl_stmt|;
name|uint64_t
name|pll_setting
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_pll_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_pll
name|cvmx_dfa_ddr2_pll_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ddr2_tmg  *  * DFA_DDR2_TMG = DFA DDR2 Memory Timing Config Register  *  *  * Description: The following are registers to program the DDR2 memory timing parameters.  */
end_comment

begin_union
union|union
name|cvmx_dfa_ddr2_tmg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ddr2_tmg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|fcnt_mode
range|:
literal|1
decl_stmt|;
comment|/**< If FCNT_MODE = 0, this counter counts the \# FCLK cycles                                                          If FCNT_MODE = 1, this counter counts the \# cycles the                                                          controller is active with memory requests. */
name|uint64_t
name|cnt_clr
range|:
literal|1
decl_stmt|;
comment|/**< Clears the FCLK Cyc& Bus Util counter */
name|uint64_t
name|cavmipo
range|:
literal|1
decl_stmt|;
comment|/**< RESERVED */
name|uint64_t
name|ctr_rst
range|:
literal|1
decl_stmt|;
comment|/**< Reset oneshot pulse for refresh counter& Perf counters                                                          SW should first write this field to a one to clear& then write to a zero for normal operation */
name|uint64_t
name|odt_rtt
range|:
literal|2
decl_stmt|;
comment|/**< DDR2 Termination Resistor Setting                                                          These two bits are loaded into the RTT                                                          portion of the EMRS register bits A6& A2. If DDR2's                                                          termination (for the memory's DQ/DQS/DM pads) is not                                                          desired, set it to 00. If it is, chose between                                                          01 for 75 ohm and 10 for 150 ohm termination.                                                               00 = ODT Disabled                                                               01 = 75 ohm Termination                                                               10 = 150 ohm Termination                                                               11 = 50 ohm Termination */
name|uint64_t
name|dqsn_ena
range|:
literal|1
decl_stmt|;
comment|/**< For DDR-II Mode, DIC[1] is used to load into EMRS                                                          bit 10 - DQSN Enable/Disable field. By default, we                                                          program the DDR's to drive the DQSN also. Set it to                                                          1 if DQSN should be Hi-Z.                                                               0 - DQSN Enable                                                               1 - DQSN Disable */
name|uint64_t
name|dic
range|:
literal|1
decl_stmt|;
comment|/**< Drive Strength Control:                                                          For DDR-I/II Mode, DIC[0] is                                                          loaded into the Extended Mode Register (EMRS) A1 bit                                                          during initialization. (see DDR-I data sheet EMRS                                                          description)                                                               0 = Normal                                                               1 = Reduced */
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
comment|/**< A 1 on this register will force the controller to                                                          slot a bubble between every reads */
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
comment|/**< tFAW - Cycles = RNDUP[tFAW(ns)/tcyc(ns)] - 1                                                          Four Access Window time. Relevant only in                                                          8-bank parts.                                                               TFAW = 5'b0 for DDR2-4bank                                                               TFAW = RNDUP[tFAW(ns)/tcyc(ns)] - 1 in DDR2-8bank */
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
comment|/**< tWTR Cycles = RNDUP[tWTR(ns)/tcyc(ns)]                                                          Last Wr Data to Rd Command time.                                                          (Represented in fclk cycles)                                                          TYP=15ns                                                               - 0000: RESERVED                                                               - 0001: 1                                                               - ...                                                               - 0111: 7                                                               - 1000-1111: RESERVED */
name|uint64_t
name|twr
range|:
literal|3
decl_stmt|;
comment|/**< DDR Write Recovery time (tWR). Last Wr Brst to Prech                                                          This is not a direct encoding of the value. Its                                                          programmed as below per DDR2 spec. The decimal number                                                          on the right is RNDUP(tWR(ns) / clkFreq)                                                          TYP=15ns                                                               - 000: RESERVED                                                               - 001: 2                                                               - 010: 3                                                               - 011: 4                                                               - 100: 5                                                               - 101: 6                                                               - 110-111: RESERVED */
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
comment|/**< tRP Cycles = RNDUP[tRP(ns)/tcyc(ns)]                                                          (Represented in fclk cycles)                                                          TYP=15ns                                                               - 0000: RESERVED                                                               - 0001: 1                                                               - ...                                                               - 0111: 7                                                               - 1000-1111: RESERVED                                                          When using parts with 8 banks (DFA_CFG->MAX_BNK                                                          is 1), load tRP cycles + 1 into this register. */
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
comment|/**< tRAS Cycles = RNDUP[tRAS(ns)/tcyc(ns)]                                                          (Represented in fclk cycles)                                                          TYP=45ns                                                               - 00000-0001: RESERVED                                                               - 00010: 2                                                               - ...                                                               - 10100: 20                                                               - 10101-11111: RESERVED */
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
comment|/**< tRRD cycles: ACT-ACT timing parameter for different                                                          banks. (Represented in fclk cycles)                                                          For DDR2, TYP=7.5ns                                                              - 000: RESERVED                                                              - 001: 1 tCYC                                                              - 010: 2 tCYC                                                              - 011: 3 tCYC                                                              - 100: 4 tCYC                                                              - 101: 5 tCYC                                                              - 110-111: RESERVED */
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
comment|/**< tRCD Cycles = RNDUP[tRCD(ns)/tcyc(ns)]                                                          (Represented in fclk cycles)                                                          TYP=15ns                                                               - 0000: RESERVED                                                               - 0001: 2 (2 is the smallest value allowed)                                                               - 0002: 2                                                               - ...                                                               - 0111: 7                                                               - 1110-1111: RESERVED */
name|uint64_t
name|addlat
range|:
literal|3
decl_stmt|;
comment|/**< When in Posted CAS mode ADDLAT needs to be programmed                                                          to tRCD-1                                                                ADDLAT         \#additional latency cycles                                                                 000              0                                                                 001              1 (tRCD = 2 fclk's)                                                                 010              2 (tRCD = 3 fclk's)                                                                 011              3 (tRCD = 4 fclk's)                                                                 100              4 (tRCD = 5 fclk's)                                                                 101              5 (tRCD = 6 fclk's)                                                                 110              6 (tRCD = 7 fclk's)                                                                 111              7 (tRCD = 8 fclk's) */
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
comment|/**< Posted CAS mode. When 1, we use DDR2's Posted CAS                                                          feature. When using this mode, ADDLAT needs to be                                                          programmed as well */
name|uint64_t
name|caslat
range|:
literal|3
decl_stmt|;
comment|/**< CAS Latency in \# fclk Cycles                                                          CASLAT           \#  CAS latency cycles                                                           000 - 010           RESERVED                                                           011                    3                                                           100                    4                                                           101                    5                                                           110                    6                                                           111                    7 */
name|uint64_t
name|tmrd
range|:
literal|2
decl_stmt|;
comment|/**< tMRD Cycles                                                          (Represented in fclk tCYC)                                                          For DDR2, its TYP 2*tCYC)                                                              - 000: RESERVED                                                              - 001: 1                                                              - 010: 2                                                              - 011: 3 */
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
comment|/**< When 2T mode is turned on, command signals are                                                          setup a cycle ahead of when the CS is enabled                                                          and kept for a total of 2 cycles. This mode is                                                          enabled in higher speeds when there is difficulty                                                          meeting setup. Performance could                                                          be negatively affected in 2T mode */
else|#
directive|else
name|uint64_t
name|ddr2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tmrd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|caslat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pocas
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addlat
range|:
literal|3
decl_stmt|;
name|uint64_t
name|trcd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trrd
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tras
range|:
literal|5
decl_stmt|;
name|uint64_t
name|trp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|twtr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tfaw
range|:
literal|5
decl_stmt|;
name|uint64_t
name|r2r_slot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dic
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dqsn_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|odt_rtt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ctr_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cavmipo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcnt_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_ddr2_tmg_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ddr2_tmg
name|cvmx_dfa_ddr2_tmg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_debug0  *  * DFA_DEBUG0 = DFA Scoreboard Debug \#0 Register  * *FOR INTERNAL USE ONLY*  * Description: When the DFA_CONTROL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_CONTROL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_debug0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_debug0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd0
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#0 Data                                                          (DFA Scoreboard Debug)                                                             [63:38]   (26) rptr[28:3]: Result Base Pointer (QW-aligned)                                                             [37:22]   (16) Cumulative Result Write Counter (for HDR write)                                                             [21]       (1) Waiting for GRdRsp EOT                                                             [20]       (1) Waiting for GRdReq Issue (to NRQ)                                                             [19]       (1) GLPTR/GLCNT Valid                                                             [18]       (1) Completion Mark Detected                                                             [17:15]    (3) Completion Code [0=PDGONE/1=PERR/2=RFULL/3=TERM]                                                             [14]       (1) Completion Detected                                                             [13]       (1) Waiting for HDR RWrCmtRsp                                                             [12]       (1) Waiting for LAST RESULT RWrCmtRsp                                                             [11]       (1) Waiting for HDR RWrReq                                                             [10]        (1) Waiting for RWrReq                                                             [9]        (1) Waiting for WQWrReq issue                                                             [8]        (1) Waiting for PRdRsp EOT                                                             [7]        (1) Waiting for PRdReq Issue (to NRQ)                                                             [6]        (1) Packet Data Valid                                                             [5]        (1) WQVLD                                                             [4]        (1) WQ Done Point (either WQWrReq issued (for WQPTR<>0) OR HDR RWrCmtRsp)                                                             [3]        (1) Resultant write STF/P Mode                                                             [2]        (1) Packet Data LDT mode                                                             [1]        (1) Gather Mode                                                             [0]        (1) Valid */
else|#
directive|else
name|uint64_t
name|sbd0
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_debug0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_debug0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_debug0
name|cvmx_dfa_debug0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_debug1  *  * DFA_DEBUG1 = DFA Scoreboard Debug \#1 Register  * *FOR INTERNAL USE ONLY*  * Description: When the DFA_CONTROL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_CONTROL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_debug1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_debug1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd1
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#1 Data                                                          DFA Scoreboard Debug Data                                                             [63:56]   (8) UNUSED                                                             [55:16]  (40) Packet Data Pointer                                                             [15:0]   (16) Packet Data Counter */
else|#
directive|else
name|uint64_t
name|sbd1
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_debug1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_debug1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_debug1
name|cvmx_dfa_debug1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_debug2  *  * DFA_DEBUG2 = DFA Scoreboard Debug \#2 Register  *  * Description: When the DFA_CONTROL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_CONTROL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_debug2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_debug2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd2
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#2 Data                                                          [63:45] (19) UNUSED                                                          [44:42]  (3) Instruction Type                                                          [41:5]  (37) rwptr[39:3]: Result Write Pointer                                                          [4:0]    (5) prwcnt[4:0]: Pending Result Write Counter */
else|#
directive|else
name|uint64_t
name|sbd2
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_debug2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_debug2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug2_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_debug2
name|cvmx_dfa_debug2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_debug3  *  * DFA_DEBUG3 = DFA Scoreboard Debug \#3 Register  *  * Description: When the DFA_CONTROL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_CONTROL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_debug3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_debug3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd3
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#3 Data                                                          [63:52] (11) rptr[39:29]: Result Base Pointer (QW-aligned)                                                          [52:16] (37) glptr[39:3]: Gather List Pointer                                                          [15:0]  (16) glcnt Gather List Counter */
else|#
directive|else
name|uint64_t
name|sbd3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_debug3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_debug3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_debug3_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_debug3
name|cvmx_dfa_debug3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_difctl  *  * DFA_DIFCTL = DFA Instruction FIFO (DIF) Control Register  *  * Description:  *  NOTE: To write to the DFA_DIFCTL register, a device would issue an IOBST directed at the DFA with addr[34:32]=3'b110.  *        To read the DFA_DIFCTL register, a device would issue an IOBLD64 directed at the DFA with addr[34:32]=3'b110.  *  *  NOTE: This register is intended to ONLY be written once (at power-up). Any future writes could  *  cause the DFA and FPA HW to become unpredictable.  *  *  NOTE: If DFA_CONFIG[DTECLKDIS]=1 (DFA-DTE clocks disabled), reads/writes to the DFA_DIFCTL register do not take effect.  *  NOTE: If FUSE[TBD]="DFA DTE disable" is blown, reads/writes to the DFA_DIFCTL register do not take effect.  */
end_comment

begin_union
union|union
name|cvmx_dfa_difctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_difctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|msegbase
range|:
literal|6
decl_stmt|;
comment|/**< Memory Segmentation Base Address                                                          For debug purposes, backdoor accesses to the DFA                                                          memory are supported via NCB-Direct CSR accesses to                                                          the DFA Memory REGION(if addr[34:32]=5. However due                                                          to the existing NCB address decoding scheme, the                                                          address only offers a 4GB extent into the DFA memory                                                          REGION. Therefore, the MSEGBASE CSR field provides                                                          the additional upper memory address bits to allow access                                                          to the full extent of memory (128GB MAX).                                                          For DFA Memory REGION read NCB-Direct CSR accesses, the                                                          38bit L2/DRAM memory byte address is generated as follows:                                                            memaddr[37:0] = [DFA_DIFCTL[MSEGBASE],ncb_addr[31:3],3'b0]                                                          NOTE: See the upper 6bits of the memory address are sourced                                                          from DFA_DIFCTL[MSEGBASE] CSR field. The lower 4GB address                                                          offset is directly referenced using the NCB address bits during                                                          the reference itself.                                                          NOTE: The DFA_DIFCTL[MSEGBASE] is shared amongst all references.                                                          As such, if multiple PPs are accessing different segments in memory,                                                          their must be a SW mutual exclusive lock during each DFA Memory                                                          REGION access to avoid collisions between PPs using the same MSEGBASE                                                          CSR field.                                                          NOTE: See also DFA_ERROR[DFANXM] programmable interrupt which is                                                          flagged if SW tries to access non-existent memory space (address hole                                                          or upper unused region of 38bit address space). */
name|uint64_t
name|dwbcnt
range|:
literal|8
decl_stmt|;
comment|/**< Represents the \# of cache lines in the instruction                                                          buffer that may be dirty and should not be                                                          written-back to memory when the instruction                                                          chunk is returned to the Free Page list.                                                          NOTE: Typically SW will want to mark all DFA                                                          Instruction memory returned to the Free Page list                                                          as DWB (Don't WriteBack), therefore SW should                                                          seed this register as:                                                            DFA_DIFCTL[DWBCNT] = (DFA_DIFCTL[SIZE] + 4)/4 */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Represents the 3bit buffer pool-id  used by DFA HW                                                          when the DFA instruction chunk is recycled back                                                          to the Free Page List maintained by the FPA HW                                                          (once the DFA instruction has been issued). */
name|uint64_t
name|size
range|:
literal|9
decl_stmt|;
comment|/**< Represents the \# of 32B instructions contained                                                          within each DFA instruction chunk. At Power-on,                                                          SW will seed the SIZE register with a fixed                                                          chunk-size. (Must be at least 3)                                                          DFA HW uses this field to determine the size                                                          of each DFA instruction chunk, in order to:                                                             a) determine when to read the next DFA                                                                instruction chunk pointer which is                                                                written by SW at the end of the current                                                                DFA instruction chunk (see DFA description                                                                of next chunk buffer Ptr for format).                                                             b) determine when a DFA instruction chunk                                                                can be returned to the Free Page List                                                                maintained by the FPA HW. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|9
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwbcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|msegbase
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_difctl_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|dwbcnt
range|:
literal|8
decl_stmt|;
comment|/**< Represents the \# of cache lines in the instruction                                                          buffer that may be dirty and should not be                                                          written-back to memory when the instruction                                                          chunk is returned to the Free Page list.                                                          NOTE: Typically SW will want to mark all DFA                                                          Instruction memory returned to the Free Page list                                                          as DWB (Don't WriteBack), therefore SW should                                                          seed this register as:                                                            DFA_DIFCTL[DWBCNT] = (DFA_DIFCTL[SIZE] + 4)/4 */
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
comment|/**< Represents the 3bit buffer pool-id  used by DFA HW                                                          when the DFA instruction chunk is recycled back                                                          to the Free Page List maintained by the FPA HW                                                          (once the DFA instruction has been issued). */
name|uint64_t
name|size
range|:
literal|9
decl_stmt|;
comment|/**< Represents the \# of 32B instructions contained                                                          within each DFA instruction chunk. At Power-on,                                                          SW will seed the SIZE register with a fixed                                                          chunk-size. (Must be at least 3)                                                          DFA HW uses this field to determine the size                                                          of each DFA instruction chunk, in order to:                                                             a) determine when to read the next DFA                                                                instruction chunk pointer which is                                                                written by SW at the end of the current                                                                DFA instruction chunk (see DFA description                                                                of next chunk buffer Ptr for format).                                                             b) determine when a DFA instruction chunk                                                                can be returned to the Free Page List                                                                maintained by the FPA HW. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|9
decl_stmt|;
name|uint64_t
name|pool
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dwbcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_cn31xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_difctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_difctl
name|cvmx_dfa_difctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_difrdptr  *  * DFA_DIFRDPTR = DFA Instruction FIFO (DIF) RDPTR Register  *  * Description:  *  NOTE: To write to the DFA_DIFRDPTR register, a device would issue an IOBST directed at the DFA with addr[34:33]=2'b01.  *        To read the DFA_DIFRDPTR register, a device would issue an IOBLD64 directed at the DFA with addr[34:33]=2'b01.  *  *  NOTE: If DFA_CONFIG[DTECLKDIS]=1 (DFA-DTE clocks disabled), reads/writes to the DFA_DIFRDPTR register do not take effect.  *  NOTE: If FUSE[TBD]="DFA DTE disable" is blown, reads/writes to the DFA_DIFRDPTR register do not take effect.  */
end_comment

begin_union
union|union
name|cvmx_dfa_difrdptr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_difrdptr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|rdptr
range|:
literal|35
decl_stmt|;
comment|/**< Represents the 32B-aligned address of the current                                                          instruction in the DFA Instruction FIFO in main                                                          memory. The RDPTR must be seeded by software at                                                          boot time, and is then maintained thereafter                                                          by DFA HW.                                                          During the seed write (by SW), RDPTR[6:5]=0,                                                          since DFA instruction chunks must be 128B aligned.                                                          During a read (by SW), the 'most recent' contents                                                          of the RDPTR register are returned at the time                                                          the NCB-INB bus is driven.                                                          NOTE: Since DFA HW updates this register, its                                                          contents are unpredictable in SW (unless                                                          its guaranteed that no new DoorBell register                                                          writes have occurred and the DoorBell register is                                                          read as zero). */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rdptr
range|:
literal|35
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_difrdptr_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|rdptr
range|:
literal|31
decl_stmt|;
comment|/**< Represents the 32B-aligned address of the current                                                          instruction in the DFA Instruction FIFO in main                                                          memory. The RDPTR must be seeded by software at                                                          boot time, and is then maintained thereafter                                                          by DFA HW.                                                          During the seed write (by SW), RDPTR[6:5]=0,                                                          since DFA instruction chunks must be 128B aligned.                                                          During a read (by SW), the 'most recent' contents                                                          of the RDPTR register are returned at the time                                                          the NCB-INB bus is driven.                                                          NOTE: Since DFA HW updates this register, its                                                          contents are unpredictable in SW (unless                                                          its guaranteed that no new DoorBell register                                                          writes have occurred and the DoorBell register is                                                          read as zero). */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rdptr
range|:
literal|31
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_dfa_difrdptr_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_cn31xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_cn31xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_cn31xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_difrdptr_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_difrdptr
name|cvmx_dfa_difrdptr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_dtcfadr  *  * DFA_DTCFADR = DFA DTC Failing Address Register  *  * Description: DFA Node Cache Failing Address/Control Error Capture information  * This register contains useful information to help in isolating a Node Cache RAM failure.  * NOTE: The first detected PERR failure is captured in DFA_DTCFADR (locked down), until the  * corresponding PERR Interrupt is cleared by writing one (W1C). (see: DFA_ERR[DC0PERR[2:0]]).  * NOTE: In the rare event that multiple parity errors are detected in the same cycle from multiple  * clusters, the FADR register will be locked down for the least signicant cluster \# (0->3).  */
end_comment

begin_union
union|union
name|cvmx_dfa_dtcfadr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_dtcfadr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|ram3fadr
range|:
literal|12
decl_stmt|;
comment|/**< DFA RAM3 Failing Address                                                          If DFA_ERR[DC0PERR<2>]=1, this field indicates the                                                          failing RAM3 Address. The failing address is locked                                                          down until the DC0PERR<2> W1C occurs.                                                          NOTE: If multiple DC0PERR<0>=1 errors are detected,                                                          then the lsb cluster error information is captured. */
name|uint64_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ram2fadr
range|:
literal|9
decl_stmt|;
comment|/**< DFA RAM2 Failing Address                                                          If DFA_ERR[DC0PERR<1>]=1, this field indicates the                                                          failing RAM2 Address. The failing address is locked                                                          down until the DC0PERR<1> W1C occurs.                                                          NOTE: If multiple DC0PERR<0>=1 errors are detected,                                                          then the lsb cluster error information is captured. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ram1fadr
range|:
literal|14
decl_stmt|;
comment|/**< DFA RAM1 Failing Address                                                          If DFA_ERR[DC0PERR<0>]=1, this field indicates the                                                          failing RAM1 Address. The failing address is locked                                                          down until the DC0PERR<0> W1C occurs.                                                          NOTE: If multiple DC0PERR<0>=1 errors are detected,                                                          then the lsb cluster error information is captured. */
else|#
directive|else
name|uint64_t
name|ram1fadr
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ram2fadr
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ram3fadr
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_dtcfadr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_dtcfadr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_dtcfadr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_dtcfadr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_dtcfadr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_dtcfadr_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_dtcfadr
name|cvmx_dfa_dtcfadr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_eclkcfg  *  * Specify the RSL base addresses for the block  *  *                  DFA_ECLKCFG = DFA eclk-domain Configuration Registers  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_eclkcfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_eclkcfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|3
decl_stmt|;
comment|/**< SBD Debug Entry#                                                          For internal use only. (DFA Scoreboard debug)                                                          Selects which one of 8 DFA Scoreboard entries is                                                          latched into the DFA_SBD_DBG[0-3] registers. */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
comment|/**< DFA Scoreboard LOCK Strobe                                                          For internal use only. (DFA Scoreboard debug)                                                          When written with a '1', the DFA Scoreboard Debug                                                          registers (DFA_SBD_DBG[0-3]) are all locked down.                                                          This allows SW to lock down the contents of the entire                                                          SBD for a single instant in time. All subsequent reads                                                          of the DFA scoreboard registers will return the data                                                          from that instant in time. */
name|uint64_t
name|dcmode
range|:
literal|1
decl_stmt|;
comment|/**< DRF-CRQ/DTE Arbiter Mode                                                          DTE-DRF Arbiter (0=FP [LP=CRQ/HP=DTE],1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|dtmode
range|:
literal|1
decl_stmt|;
comment|/**< DRF-DTE Arbiter Mode                                                          DTE-DRF Arbiter (0=FP [LP=DTE[15],...,HP=DTE[0]],1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRP Arbiter Mode                                                          (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRQ Arbiter Mode                                                          (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-Inbound Arbiter                                                          (0=FP [LP=NRQ,HP=NRP], 1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|sarb
range|:
literal|1
decl_stmt|;
comment|/**< DFA Source Arbiter Mode                                                          Selects the arbitration mode used to select DFA requests                                                          issued from either CP2 or the DTE (NCB-CSR or DFA HW engine).                                                           - 0: Fixed Priority [Highest=CP2, Lowest=DTE]                                                           - 1: Round-Robin                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
comment|/**< DFA DTE Clock Disable                                                          When SET, the DFA clocks for DTE(thread engine)                                                          operation are disabled.                                                          NOTE: When SET, SW MUST NEVER issue ANY operations to                                                          the DFA via the NCB Bus. All DFA Operations must be                                                          issued solely through the CP2 interface. */
name|uint64_t
name|maxbnk
range|:
literal|1
decl_stmt|;
comment|/**< Maximum Banks per-device (used by the address mapper                                                          when extracting address bits for the memory bank#.                                                                  - 0: 4 banks/device                                                                  - 1: 8 banks/device */
name|uint64_t
name|dfa_frstn
range|:
literal|1
decl_stmt|;
comment|/**< Hold this 0 until the DFA DDR PLL and DLL lock                                                          and then write a 1. A 1 on this register deasserts                                                          the internal frst_n. Refer to DFA_DDR2_PLL registers for more                                                          startup information.                                                          Startup sequence if DFA interface needs to be ON:                                                           After valid power up,                                                           Write DFA_DDR2_PLL-> PLL_RATIO& PLL_DIV2& PLL_BYPASS                                                           to the appropriate values                                                           Wait a few cycles                                                           Write a 1 DFA_DDR2_PLL -> PLL_INIT                                                           Wait 100 microseconds                                                           Write a 1 to DFA_DDR2_PLL -> QDLL_ENA                                                           Wait 10 microseconds                                                           Write a 1 to this register DFA_FRSTN to pull DFA out of                                                           reset                                                           Now the DFA block is ready to be initialized (follow the                                                           DDR init sequence). */
else|#
directive|else
name|uint64_t
name|dfa_frstn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxbnk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|sarb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_eclkcfg_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_eclkcfg
name|cvmx_dfa_eclkcfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_err  *  * DFA_ERR = DFA ERROR Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_err
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_err_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow Interrupt Enable bit.                                                          When set, doorbell overflow conditions are reported. */
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow detected - Status bit                                                          When set, the 20b accumulated doorbell register                                                          had overflowed (SW wrote too many doorbell requests).                                                          If the DBLINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          NOTE: Detection of a Doorbell Register overflow                                                          is a catastrophic error which may leave the DFA                                                          HW in an unrecoverable state. */
name|uint64_t
name|cp2pina
range|:
literal|1
decl_stmt|;
comment|/**< CP2 LW Mode Parity Error Interrupt Enable bit.                                                          When set, all PP-generated LW Mode read                                                          transactions which encounter a parity error (across                                                          the 36b of data) are reported. */
name|uint64_t
name|cp2perr
range|:
literal|1
decl_stmt|;
comment|/**< PP-CP2 Parity Error Detected - Status bit                                                          When set, a parity error had been detected for a                                                          PP-generated LW Mode read transaction.                                                          If the CP2PINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          See also: DFA_MEMFADR CSR which contains more data                                                          about the memory address/control to help isolate                                                          the failure. */
name|uint64_t
name|cp2parena
range|:
literal|1
decl_stmt|;
comment|/**< CP2 LW Mode Parity Error Enable                                                          When set, all PP-generated LW Mode read                                                          transactions which encounter a parity error (across                                                          the 36b of data) are reported.                                                          NOTE: This signal must only be written to a different                                                          value when there are no PP-CP2 transactions                                                          (preferrably during power-on software initialization). */
name|uint64_t
name|dtepina
range|:
literal|1
decl_stmt|;
comment|/**< DTE Parity Error Interrupt Enable bit                                                          (for 18b SIMPLE mode ONLY).                                                          When set, all DTE-generated 18b SIMPLE Mode read                                                          transactions which encounter a parity error (across                                                          the 17b of data) are reported. */
name|uint64_t
name|dteperr
range|:
literal|1
decl_stmt|;
comment|/**< DTE Parity Error Detected (for 18b SIMPLE mode ONLY)                                                          When set, all DTE-generated 18b SIMPLE Mode read                                                          transactions which encounter a parity error (across                                                          the 17b of data) are reported. */
name|uint64_t
name|dteparena
range|:
literal|1
decl_stmt|;
comment|/**< DTE Parity Error Enable (for 18b SIMPLE mode ONLY)                                                          When set, all DTE-generated 18b SIMPLE Mode read                                                          transactions which encounter a parity error (across                                                          the 17b of data) are reported.                                                          NOTE: This signal must only be written to a different                                                          value when there are no DFA thread engines active                                                          (preferrably during power-on). */
name|uint64_t
name|dtesyn
range|:
literal|7
decl_stmt|;
comment|/**< DTE 29b ECC Failing 6bit Syndrome                                                          When DTESBE or DTEDBE are set, this field contains                                                          the failing 7b ECC syndrome. */
name|uint64_t
name|dtedbina
range|:
literal|1
decl_stmt|;
comment|/**< DTE 29b Double Bit Error Interrupt Enable bit                                                          When set, an interrupt is posted for any DTE-generated                                                          36b SIMPLE Mode read which encounters a double bit                                                          error. */
name|uint64_t
name|dtesbina
range|:
literal|1
decl_stmt|;
comment|/**< DTE 29b Single Bit Error Interrupt Enable bit                                                          When set, an interrupt is posted for any DTE-generated                                                          36b SIMPLE Mode read which encounters a single bit                                                          error (which is also corrected). */
name|uint64_t
name|dtedbe
range|:
literal|1
decl_stmt|;
comment|/**< DTE 29b Double Bit Error Detected - Status bit                                                          When set, a double bit error had been detected                                                          for a DTE-generated 36b SIMPLE Mode read transaction.                                                          The DTESYN contains the failing syndrome.                                                          If the DTEDBINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          See also: DFA_MEMFADR CSR which contains more data                                                          about the memory address/control to help isolate                                                          the failure.                                                          NOTE: DTE-generated 18b SIMPLE Mode Read transactions                                                          do not participate in ECC check/correct). */
name|uint64_t
name|dtesbe
range|:
literal|1
decl_stmt|;
comment|/**< DTE 29b Single Bit Error Corrected - Status bit                                                          When set, a single bit error had been detected and                                                          corrected for a DTE-generated 36b SIMPLE Mode read                                                          transaction.                                                          If the DTEDBE=0, then the DTESYN contains the                                                          failing syndrome (used during correction).                                                          NOTE: DTE-generated 18b SIMPLE Mode Read                                                          transactions do not participate in ECC check/correct).                                                          If the DTESBINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          See also: DFA_MEMFADR CSR which contains more data                                                          about the memory address/control to help isolate                                                          the failure. */
name|uint64_t
name|dteeccena
range|:
literal|1
decl_stmt|;
comment|/**< DTE 29b ECC Enable (for 36b SIMPLE mode ONLY)                                                          When set, 29b ECC is enabled on all DTE-generated                                                          36b SIMPLE Mode read transactions.                                                          NOTE: This signal must only be written to a different                                                          value when there are no DFA thread engines active                                                          (preferrably during power-on software initialization). */
name|uint64_t
name|cp2syn
range|:
literal|8
decl_stmt|;
comment|/**< PP-CP2 QW ECC Failing 8bit Syndrome                                                          When CP2SBE or CP2DBE are set, this field contains                                                          the failing ECC 8b syndrome.                                                          Refer to CP2ECCENA. */
name|uint64_t
name|cp2dbina
range|:
literal|1
decl_stmt|;
comment|/**< PP-CP2 Double Bit Error Interrupt Enable bit                                                          When set, an interrupt is posted for any PP-generated                                                          QW Mode read which encounters a double bit error.                                                          Refer to CP2DBE. */
name|uint64_t
name|cp2sbina
range|:
literal|1
decl_stmt|;
comment|/**< PP-CP2 Single Bit Error Interrupt Enable bit                                                          When set, an interrupt is posted for any PP-generated                                                          QW Mode read which encounters a single bit error                                                          (which is also corrected).                                                          Refer to CP2SBE. */
name|uint64_t
name|cp2dbe
range|:
literal|1
decl_stmt|;
comment|/**< PP-CP2 Double Bit Error Detected - Status bit                                                          When set, a double bit error had been detected                                                          for a PP-generated QW Mode read transaction.                                                          The CP2SYN contains the failing syndrome.                                                           NOTE: PP-generated LW Mode Read transactions                                                          do not participate in ECC check/correct).                                                          Refer to CP2ECCENA.                                                          If the CP2DBINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          See also: DFA_MEMFADR CSR which contains more data                                                          about the memory address/control to help isolate                                                          the failure. */
name|uint64_t
name|cp2sbe
range|:
literal|1
decl_stmt|;
comment|/**< PP-CP2 Single Bit Error Corrected - Status bit                                                          When set, a single bit error had been detected and                                                          corrected for a PP-generated QW Mode read                                                          transaction.                                                          If the CP2DBE=0, then the CP2SYN contains the                                                          failing syndrome (used during correction).                                                          Refer to CP2ECCENA.                                                          If the CP2SBINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          See also: DFA_MEMFADR CSR which contains more data                                                          about the memory address/control to help isolate                                                          the failure.                                                          NOTE: PP-generated LW Mode Read transactions                                                          do not participate in ECC check/correct). */
name|uint64_t
name|cp2eccena
range|:
literal|1
decl_stmt|;
comment|/**< PP-CP2 QW ECC Enable (for QW Mode transactions)                                                          When set, 8bit QW ECC is enabled on all PP-generated                                                          QW Mode read transactions, CP2SBE and                                                          CP2DBE may be set, and CP2SYN may be filled.                                                          NOTE: This signal must only be written to a different                                                          value when there are no PP-CP2 transactions                                                          (preferrably during power-on software initialization).                                                          NOTE: QW refers to a 64-bit LLM Load/Store (intiated                                                          by a processor core). LW refers to a 36-bit load/store. */
else|#
directive|else
name|uint64_t
name|cp2eccena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2dbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2sbina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2dbina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2syn
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dteeccena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtesbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtedbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtesbina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtedbina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtesyn
range|:
literal|7
decl_stmt|;
name|uint64_t
name|dteparena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dteperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtepina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2parena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cp2pina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_err_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_err_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_err_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_err_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_err_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_err
name|cvmx_dfa_err_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_error  *  * DFA_ERROR = DFA ERROR Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_error
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_error_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|replerr
range|:
literal|1
decl_stmt|;
comment|/**< DFA Illegal Replication Factor Error                                                          For o68: DFA only supports 1x, 2x, and 4x port replication.                                                          Legal configurations for memory are to support 2 port or                                                          4 port configurations.                                                          The REPLERR interrupt will be set in the following illegal                                                          configuration cases:                                                              1) An 8x replication factor is detected for any memory reference.                                                              2) A 4x replication factor is detected for any memory reference                                                                 when only 2 memory ports are enabled.                                                          NOTE: If REPLERR is set during a DFA Graph Walk operation,                                                          then the walk will prematurely terminate with RWORD0[REA]=ERR.                                                          If REPLERR is set during a NCB-Direct CSR read access to DFA                                                          Memory REGION, then the CSR read response data is UNPREDICTABLE. */
name|uint64_t
name|dfanxm
range|:
literal|1
decl_stmt|;
comment|/**< DFA Non-existent Memory Access                                                          For o68: DTEs (and backdoor CSR DFA Memory REGION reads)                                                          have access to the following 38bit L2/DRAM address space                                                          which maps to a 37bit physical DDR3 SDRAM address space.                                                          see:                                                          DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF                                                                  maps to lower 256MB of physical DDR3 SDRAM                                                          DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF                                                                  maps to upper 127.75GB of DDR3 SDRAM                                                                     L2/DRAM address space                     Physical DDR3 SDRAM Address space                                                                       (38bit address)                           (37bit address)                                                                        +-----------+ 0x0020.0FFF.FFFF                                                                        ===   DR1   ===                          +-----------+ 0x001F.FFFF.FFFF                                                           (128GB-256MB)|           |                                                                        |           |                     =>    |           |  (128GB-256MB)                                                                        +-----------+ 0x0000.1FFF.FFFF          |   DR1                                                                256MB   |   HOLE    |   (DO NOT USE)                                                                        +-----------+ 0x0000.0FFF.FFFF          +-----------+ 0x0000.0FFF.FFFF                                                                256MB   |    DR0    |                           |   DR0     |   (256MB)                                                                        +-----------+ 0x0000.0000.0000          +-----------+ 0x0000.0000.0000                                                          In the event the DFA generates a reference to the L2/DRAM                                                          address hole (0x0000.0FFF.FFFF - 0x0000.1FFF.FFFF) or to                                                          an address above 0x0020.0FFF.FFFF, the DFANXM programmable                                                          interrupt bit will be set.                                                          SWNOTE: Both the 1) SW DFA Graph compiler and the 2) SW NCB-Direct CSR                                                          accesses to DFA Memory REGION MUST avoid making references                                                          to these non-existent memory regions.                                                          NOTE: If DFANXM is set during a DFA Graph Walk operation,                                                          then the walk will prematurely terminate with RWORD0[REA]=ERR.                                                          If DFANXM is set during a NCB-Direct CSR read access to DFA                                                          Memory REGION, then the CSR read response data is forced to                                                          128'hBADE_FEED_DEAD_BEEF_FACE_CAFE_BEAD_C0DE. (NOTE: the QW                                                          being accessed, either the upper or lower QW will be returned). */
name|uint64_t
name|cndrd
range|:
literal|1
decl_stmt|;
comment|/**< If Any of the cluster's detected a Parity error on RAM1                                                          this additional bit further specifies that the                                                          RAM1 parity error was detected during a CND-RD                                                          (Cache Node Metadata Read).                                                           For CNDRD Parity Error, the previous CNA arc fetch                                                          information is written to RWORD1+ as follows:                                                             RWORD1+[NTYPE]=MNODE                                                             RWORD1+[NDNID]=cna.ndnid                                                             RWORD1+[NHMSK]=cna.hmsk                                                             RWORD1+[NNPTR]=cna.nnptr[13:0]                                                          NOTE: This bit is set if ANY node cluster's RAM1 accesses                                                          detect a CNDRD error. */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlc1_ovferr
range|:
literal|1
decl_stmt|;
comment|/**< DLC1 Fifo Overflow Error Detected                                                          This condition should NEVER architecturally occur, and                                                          is here in case HW credit/debit scheme is not working. */
name|uint64_t
name|dlc0_ovferr
range|:
literal|1
decl_stmt|;
comment|/**< DLC0 Fifo Overflow Error Detected                                                          This condition should NEVER architecturally occur, and                                                          is here in case HW credit/debit scheme is not working. */
name|uint64_t
name|reserved_10_12
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dc2perr
range|:
literal|3
decl_stmt|;
comment|/**< Cluster#2 RAM[3:1] Parity Error Detected                                                          See also DFA_DTCFADR register which contains the                                                          failing addresses for the internal node cache RAMs. */
name|uint64_t
name|dc1perr
range|:
literal|3
decl_stmt|;
comment|/**< Cluster#1 RAM[3:1] Parity Error Detected                                                          See also DFA_DTCFADR register which contains the                                                          failing addresses for the internal node cache RAMs. */
name|uint64_t
name|dc0perr
range|:
literal|3
decl_stmt|;
comment|/**< Cluster#0 RAM[3:1] Parity Error Detected                                                          See also DFA_DTCFADR register which contains the                                                          failing addresses for the internal node cache RAMs. */
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow detected - Status bit                                                          When set, the 20b accumulated doorbell register                                                          had overflowed (SW wrote too many doorbell requests).                                                          If the DBLINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          NOTE: Detection of a Doorbell Register overflow                                                          is a catastrophic error which may leave the DFA                                                          HW in an unrecoverable state. */
else|#
directive|else
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc0perr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dc1perr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dc2perr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_10_12
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dlc0_ovferr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlc1_ovferr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cndrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfanxm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|replerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_error_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|replerr
range|:
literal|1
decl_stmt|;
comment|/**< DFA Illegal Replication Factor Error                                                          For o68: DFA only supports 1x, 2x, and 4x port replication.                                                          Legal configurations for memory are to support 2 port or                                                          4 port configurations.                                                          The REPLERR interrupt will be set in the following illegal                                                          configuration cases:                                                              1) An 8x replication factor is detected for any memory reference.                                                              2) A 4x replication factor is detected for any memory reference                                                                 when only 2 memory ports are enabled.                                                          NOTE: If REPLERR is set during a DFA Graph Walk operation,                                                          then the walk will prematurely terminate with RWORD0[REA]=ERR.                                                          If REPLERR is set during a NCB-Direct CSR read access to DFA                                                          Memory REGION, then the CSR read response data is UNPREDICTABLE. */
name|uint64_t
name|dfanxm
range|:
literal|1
decl_stmt|;
comment|/**< DFA Non-existent Memory Access                                                          For o68/o61: DTEs (and backdoor CSR DFA Memory REGION reads)                                                          have access to the following 38bit L2/DRAM address space                                                          which maps to a 37bit physical DDR3 SDRAM address space.                                                          see:                                                          DR0: 0x0 0000 0000 0000 to 0x0 0000 0FFF FFFF                                                                  maps to lower 256MB of physical DDR3 SDRAM                                                          DR1: 0x0 0000 2000 0000 to 0x0 0020 0FFF FFFF                                                                  maps to upper 127.75GB of DDR3 SDRAM                                                                     L2/DRAM address space                     Physical DDR3 SDRAM Address space                                                                       (38bit address)                           (37bit address)                                                                        +-----------+ 0x0020.0FFF.FFFF                                                                        |                                                                       ===   DR1   ===                          +-----------+ 0x001F.FFFF.FFFF                                                           (128GB-256MB)|           |                           |                                                                        |           |                     =>    |           |  (128GB-256MB)                                                                        +-----------+ 0x0000.1FFF.FFFF          |   DR1                                                                256MB   |   HOLE    |   (DO NOT USE)            |                                                                        +-----------+ 0x0000.0FFF.FFFF          +-----------+ 0x0000.0FFF.FFFF                                                                256MB   |    DR0    |                           |   DR0     |   (256MB)                                                                        +-----------+ 0x0000.0000.0000          +-----------+ 0x0000.0000.0000                                                          In the event the DFA generates a reference to the L2/DRAM                                                          address hole (0x0000.0FFF.FFFF - 0x0000.1FFF.FFFF) or to                                                          an address above 0x0020.0FFF.FFFF, the DFANXM programmable                                                          interrupt bit will be set.                                                          SWNOTE: Both the 1) SW DFA Graph compiler and the 2) SW NCB-Direct CSR                                                          accesses to DFA Memory REGION MUST avoid making references                                                          to these non-existent memory regions.                                                          NOTE: If DFANXM is set during a DFA Graph Walk operation,                                                          then the walk will prematurely terminate with RWORD0[REA]=ERR.                                                          If DFANXM is set during a NCB-Direct CSR read access to DFA                                                          Memory REGION, then the CSR read response data is forced to                                                          128'hBADE_FEED_DEAD_BEEF_FACE_CAFE_BEAD_C0DE. (NOTE: the QW                                                          being accessed, either the upper or lower QW will be returned). */
name|uint64_t
name|cndrd
range|:
literal|1
decl_stmt|;
comment|/**< If any of the cluster's detected a Parity error on RAM1                                                          this additional bit further specifies that the                                                          RAM1 parity error was detected during a CND-RD                                                          (Cache Node Metadata Read).                                                           For CNDRD Parity Error, the previous CNA arc fetch                                                          information is written to RWORD1+ as follows:                                                             RWORD1+[NTYPE]=MNODE                                                             RWORD1+[NDNID]=cna.ndnid                                                             RWORD1+[NHMSK]=cna.hmsk                                                             RWORD1+[NNPTR]=cna.nnptr[13:0]                                                          NOTE: This bit is set if ANY node cluster's RAM1 accesses                                                          detect a CNDRD error. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dlc0_ovferr
range|:
literal|1
decl_stmt|;
comment|/**< DLC0 Fifo Overflow Error Detected                                                          This condition should NEVER architecturally occur, and                                                          is here in case HW credit/debit scheme is not working. */
name|uint64_t
name|reserved_4_12
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dc0perr
range|:
literal|3
decl_stmt|;
comment|/**< Cluster#0 RAM[3:1] Parity Error Detected                                                          See also DFA_DTCFADR register which contains the                                                          failing addresses for the internal node cache RAMs. */
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow detected - Status bit                                                          When set, the 20b accumulated doorbell register                                                          had overflowed (SW wrote too many doorbell requests).                                                          If the DBLINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          NOTE: Detection of a Doorbell Register overflow                                                          is a catastrophic error which may leave the DFA                                                          HW in an unrecoverable state. */
else|#
directive|else
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc0perr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_4_12
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dlc0_ovferr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cndrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfanxm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|replerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_dfa_error_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|cndrd
range|:
literal|1
decl_stmt|;
comment|/**< If DC0PERR[0]=1 indicating a RAM1 Parity error,                                                          this additional bit further specifies that the                                                          RAM1 parity error was detected during a CND-RD                                                          (Cache Node Metadata Read).                                                           For CNDRD Parity Error, the previous CNA arc fetch                                                          information is written to RWORD1+ as follows:                                                             RWORD1+[NTYPE]=MNODE                                                             RWORD1+[NDNID]=cna.ndnid                                                             RWORD1+[NHMSK]=cna.hmsk                                                             RWORD1+[NNPTR]=cna.nnptr[13:0] */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|dc0perr
range|:
literal|3
decl_stmt|;
comment|/**< RAM[3:1] Parity Error Detected from Node Cluster \#0                                                          See also DFA_DTCFADR register which contains the                                                          failing addresses for the internal node cache RAMs. */
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow detected - Status bit                                                          When set, the 20b accumulated doorbell register                                                          had overflowed (SW wrote too many doorbell requests).                                                          If the DBLINA had previously been enabled(set),                                                          an interrupt will be posted. Software can clear                                                          the interrupt by writing a 1 to this register bit.                                                          NOTE: Detection of a Doorbell Register overflow                                                          is a catastrophic error which may leave the DFA                                                          HW in an unrecoverable state. */
else|#
directive|else
name|uint64_t
name|dblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc0perr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|cndrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dfa_error_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_error_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_error_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_error_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_error
name|cvmx_dfa_error_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_intmsk  *  * DFA_INTMSK = DFA ERROR Interrupt Mask Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_intmsk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_intmsk_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|replerrena
range|:
literal|1
decl_stmt|;
comment|/**< DFA Illegal Replication Factor Interrupt Enable */
name|uint64_t
name|dfanxmena
range|:
literal|1
decl_stmt|;
comment|/**< DFA Non-existent Memory Access Interrupt Enable */
name|uint64_t
name|reserved_15_16
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dlc1_ovfena
range|:
literal|1
decl_stmt|;
comment|/**< DLC1 Fifo Overflow Error Interrupt Enable */
name|uint64_t
name|dlc0_ovfena
range|:
literal|1
decl_stmt|;
comment|/**< DLC0 Fifo Overflow Error Interrupt Enable */
name|uint64_t
name|reserved_10_12
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dc2pena
range|:
literal|3
decl_stmt|;
comment|/**< RAM[3:1] Parity Error Enabled Node Cluster \#2 */
name|uint64_t
name|dc1pena
range|:
literal|3
decl_stmt|;
comment|/**< RAM[3:1] Parity Error Enabled Node Cluster \#1 */
name|uint64_t
name|dc0pena
range|:
literal|3
decl_stmt|;
comment|/**< RAM[3:1] Parity Error Enabled Node Cluster \#0 */
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow Interrupt Enable bit.                                                          When set, doorbell overflow conditions are reported. */
else|#
directive|else
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc0pena
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dc1pena
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dc2pena
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_10_12
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dlc0_ovfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlc1_ovfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_16
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dfanxmena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|replerrena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_intmsk_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|replerrena
range|:
literal|1
decl_stmt|;
comment|/**< DFA Illegal Replication Factor Interrupt Enable */
name|uint64_t
name|dfanxmena
range|:
literal|1
decl_stmt|;
comment|/**< DFA Non-existent Memory Access Interrupt Enable */
name|uint64_t
name|reserved_14_16
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dlc0_ovfena
range|:
literal|1
decl_stmt|;
comment|/**< DLC0 Fifo Overflow Error Interrupt Enable */
name|uint64_t
name|reserved_4_12
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dc0pena
range|:
literal|3
decl_stmt|;
comment|/**< RAM[3:1] Parity Error Enabled Node Cluster \#0 */
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow Interrupt Enable bit.                                                          When set, doorbell overflow conditions are reported. */
else|#
directive|else
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc0pena
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_4_12
range|:
literal|9
decl_stmt|;
name|uint64_t
name|dlc0_ovfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_16
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dfanxmena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|replerrena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_dfa_intmsk_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|dc0pena
range|:
literal|3
decl_stmt|;
comment|/**< RAM[3:1] Parity Error Enabled Node Cluster \#0 */
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
comment|/**< Doorbell Overflow Interrupt Enable bit.                                                          When set, doorbell overflow conditions are reported. */
else|#
directive|else
name|uint64_t
name|dblina
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dc0pena
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_dfa_intmsk_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_intmsk_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_intmsk_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_intmsk_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_intmsk
name|cvmx_dfa_intmsk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memcfg0  *  * DFA_MEMCFG0 = DFA Memory Configuration  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_memcfg0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memcfg0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rldqck90_rst
range|:
literal|1
decl_stmt|;
comment|/**< RLDCK90 and RLDQK90 DLL SW Reset                                                          When written with a '1' the RLDCK90 and RLDQK90 DLL are                                                          in soft-reset. */
name|uint64_t
name|rldck_rst
range|:
literal|1
decl_stmt|;
comment|/**< RLDCK Zero Delay DLL(Clock Generator) SW Reset                                                          When written with a '1' the RLDCK zero delay DLL is in                                                          soft-reset. */
name|uint64_t
name|clkdiv
range|:
literal|2
decl_stmt|;
comment|/**< RLDCLK Divisor Select                                                            - 0: RLDx_CK_H/L = Core Clock /2                                                            - 1: RESERVED (must not be used)                                                            - 2: RLDx_CK_H/L = Core Clock /3                                                            - 3: RLDx_CK_H/L = Core Clock /4                                                          The DFA LLM interface(s) are tied to the core clock                                                          frequency through this programmable clock divisor.                                                          Examples:                                                             Core Clock(MHz) | DFA-LLM Clock(MHz) | CLKDIV                                                            -----------------+--------------------+--------                                                                  800        |    400/(800-DDR)   |  /2                                                                 1000        |    333/(666-DDR)   |  /3                                                                  800        |    200/(400-DDR)   |  /4                                                          NOTE: This value MUST BE programmed BEFORE doing a                                                          Hardware init sequence (see: DFA_MEMCFG0[INIT_Px] bits). */
name|uint64_t
name|lpp_ena
range|:
literal|1
decl_stmt|;
comment|/**< PP Linear Port Addressing Mode Enable                                                          When enabled, PP-core LLM accesses to the lower-512MB                                                          LLM address space are sent to the single DFA port                                                          which is enabled. NOTE: If LPP_ENA=1, only                                                          one DFA RLDRAM port may be enabled for RLDRAM accesses                                                          (ie: ENA_P0 and ENA_P1 CAN NEVER BOTH be set).                                                          PP-core LLM accesses to the upper-512MB LLM address                                                          space are sent to the other 'disabled' DFA port.                                                          SW RESTRICTION: If LPP_ENA=1, then only one DFA port                                                          may be enabled for RLDRAM accesses (ie: ENA_P0 and                                                          ENA_P1 CAN NEVER BOTH be set).                                                          NOTE: This bit is used to allow PP-Core LLM accesses to a                                                          disabled port, such that each port can be sequentially                                                          addressed (ie: disable LW address interleaving).                                                          Enabling this bit allows BOTH PORTs to be active and                                                          sequentially addressable. The single port that is                                                          enabled(ENA_Px) will respond to the low-512MB LLM address                                                          space, and the other 'disabled' port will respond to the                                                          high-512MB LLM address space.                                                          Example usage:                                                             - DFA RLD0 pins used for TCAM-FPGA(CP2 accesses)                                                             - DFA RLD1 pins used for RLDRAM (DTE/CP2 accesses).                                                          USAGE NOTE:                                                          If LPP_ENA=1 and SW DOES NOT initialize the disabled port                                                          (ie: INIT_Px=0->1), then refreshes and the HW init                                                          sequence WILL NOT occur for the disabled port.                                                          If LPP_ENA=1 and SW does initialize the disabled port                                                          (INIT_Px=0->1 with ENA_Px=0), then refreshes and                                                          the HW init sequence WILL occur to the disabled port. */
name|uint64_t
name|bunk_init
range|:
literal|2
decl_stmt|;
comment|/**< Controls the CS_N[1:0] during a) a HW Initialization                                                          sequence (triggered by DFA_MEMCFG0[INIT_Px]) or                                                          b) during a normal refresh sequence. If                                                          the BNK_INIT[x]=1, the corresponding CS_N[x] is driven.                                                          NOTE: This is required for DRAM used in a                                                          clamshell configuration, since the address lines                                                          carry Mode Register write data that is unique                                                          per bunk(or clam). In a clamshell configuration,                                                          The N3K A[x] pin may be tied into Clam#0's A[x]                                                          and also into Clam#1's 'mirrored' address bit A[y]                                                          (eg: Clam0 sees A[5] and Clam1 sees A[15]).                                                          To support clamshell designs, SW must initiate                                                          two separate HW init sequences for the two bunks                                                          (or clams) . Before each HW init sequence is triggered,                                                          SW must preload the DFA_MEMRLD[22:0] with the data                                                          that will be driven onto the A[22:0] wires during                                                          an MRS mode register write.                                                          NOTE: After the final HW initialization sequence has                                                          been triggered, SW must wait 64K eclks before writing                                                          the BUNK_INIT[1:0] field = 3'b11 (so that CS_N[1:0] is                                                          driven during refresh sequences in normal operation.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|init_p0
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for Memory Port \#0 is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Set up the DFA_MEMCFG0[CLKDIV] ratio for intended                                                               RLDRAM operation.                                                                 [legal values 0: DIV2 2: DIV3 3: DIV4]                                                            2) Write a '1' into BOTH the DFA_MEM_CFG0[RLDCK_RST]                                                               and DFA_MEM_CFG0[RLDQCK90_RST] field at                                                               the SAME TIME. This step puts all three DLLs in                                                               SW reset (RLDCK, RLDCK90, RLDQK90 DLLs).                                                            3) Write a '0' into the DFA_MEM_CFG0[RLDCK_RST] field.                                                               This step takes the RLDCK DLL out of soft-reset so                                                               that the DLL can generate the RLDx_CK_H/L clock pins.                                                            4) Wait 1ms (for RLDCK DLL to achieve lock)                                                            5) Write a '0' into DFA_MEM_CFG0[RLDQCK90_RST] field.                                                               This step takes the RLDCK90 DLL AND RLDQK90 DLL out                                                               of soft-reset.                                                            6) Wait 1ms (for RLDCK90/RLDQK90 DLLs to achieve lock)                                                            7) Enable memory port(s):  ENA_P0=1/ENA_P1=1                                                            8) Wait 100us (to ensure a stable clock                                                               to the RLDRAMs) - as per RLDRAM spec.                                                            - - - - - Hardware Initialization Sequence - - - - -                                                            9) Setup the DFA_MEMCFG0[BUNK_INIT] for the bunk(s)                                                               intended to be initialized.                                                           10) Write a '1' to the corresponding INIT_Px which                                                               will initiate a hardware initialization                                                               sequence to that'specific' port.                                                           11) Wait (DFA_MEMCFG0[CLKDIV] * 32K) eclk cycles.                                                               [to ensure the HW init sequence has completed                                                               before writing to ANY of the DFA_MEM* registers]                                                            - - - - - Hardware Initialization Sequence - - - - -                                                           12) Write the DFA_MEMCFG0[BUNK_INIT]=3 to enable                                                               refreshes to BOTH bunks.                                                          NOTE: In some cases (where the address wires are routed                                                          differently between the front and back 'bunks'),                                                          SW will need to use DFA_MEMCFG0[BUNK_INIT] bits to                                                          control the Hardware initialization sequence for a                                                          'specific bunk'. In these cases, SW would setup the                                                          BUNK_INIT and repeat Steps \#9-11 for each bunk/port.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: DFA Memory Port#0 corresponds to the Octeon                                                          RLD0_* pins. */
name|uint64_t
name|init_p1
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for Memory Port \#1 is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Set up the DFA_MEMCFG0[CLKDIV] ratio for intended                                                               RLDRAM operation.                                                                 [legal values 0: DIV2 2: DIV3 3: DIV4]                                                            2) Write a '1' into BOTH the DFA_MEM_CFG0[RLDCK_RST]                                                               and DFA_MEM_CFG0[RLDQCK90_RST] field at                                                               the SAME TIME. This step puts all three DLLs in                                                               SW reset (RLDCK, RLDCK90, RLDQK90 DLLs).                                                            3) Write a '0' into the DFA_MEM_CFG0[RLDCK_RST] field.                                                               This step takes the RLDCK DLL out of soft-reset so                                                               that the DLL can generate the RLDx_CK_H/L clock pins.                                                            4) Wait 1ms (for RLDCK DLL to achieve lock)                                                            5) Write a '0' into DFA_MEM_CFG0[RLDQCK90_RST] field.                                                               This step takes the RLDCK90 DLL AND RLDQK90 DLL out                                                               of soft-reset.                                                            6) Wait 1ms (for RLDCK90/RLDQK90 DLLs to achieve lock)                                                            7) Enable memory port(s) ENA_P0=1/ENA_P1=1                                                            8) Wait 100us (to ensure a stable clock                                                               to the RLDRAMs) - as per RLDRAM spec.                                                            - - - - - Hardware Initialization Sequence - - - - -                                                            9) Setup the DFA_MEMCFG0[BUNK_INIT] for the bunk(s)                                                               intended to be initialized.                                                           10) Write a '1' to the corresponding INIT_Px which                                                               will initiate a hardware initialization                                                               sequence to that'specific' port.                                                           11) Wait (DFA_MEMCFG0[CLKDIV] * 32K) eclk cycles.                                                               [to ensure the HW init sequence has completed                                                               before writing to ANY of the DFA_MEM* registers]                                                            - - - - - Hardware Initialization Sequence - - - - -                                                           12) Write the DFA_MEMCFG0[BUNK_INIT]=3 to enable                                                               refreshes to BOTH bunks.                                                          NOTE: In some cases (where the address wires are routed                                                          differently between the front and back 'bunks'),                                                          SW will need to use DFA_MEMCFG0[BUNK_INIT] bits to                                                          control the Hardware initialization sequence for a                                                          'specific bunk'. In these cases, SW would setup the                                                          BUNK_INIT and repeat Steps \#9-11 for each bunk/port.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: DFA Memory Port#1 corresponds to the Octeon                                                          RLD1_* pins. */
name|uint64_t
name|r2r_pbunk
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, an additional command bubble is inserted                                                          if back to back reads are issued to different physical                                                          bunks. This is to avoid DQ data bus collisions when                                                          references cross between physical bunks.                                                          [NOTE: the physical bunk address boundary is determined                                                          by the PBUNK bit].                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|pbunk
range|:
literal|3
decl_stmt|;
comment|/**< Physical Bunk address bit pointer.                                                          Specifies which address bit within the Longword                                                          Memory address MA[23:0] is used to determine the                                                          chip selects.                                                          [RLD_CS0_N corresponds to physical bunk \#0, and                                                          RLD_CS1_N corresponds to physical bunk \#1].                                                            - 000: CS0_N = MA[19]/CS1_N = !MA[19]                                                            - 001: CS0_N = MA[20]/CS1_N = !MA[20]                                                            - 010: CS0_N = MA[21]/CS1_N = !MA[21]                                                            - 011: CS0_N = MA[22]/CS1_N = !MA[22]                                                            - 100: CS0_N = MA[23]/CS1_N = !MA[23]                                                            - 101-111: CS0_N = 0 /CS1_N = 1                                                          Example(s):                                                          To build out a 128MB DFA memory, 4x 32Mx9                                                          parts could be used to fill out TWO physical                                                          bunks (clamshell configuration). Each (of the                                                          two) physical bunks contains 2x 32Mx9 = 16Mx36.                                                          Each RLDRAM device also contains 8 internal banks,                                                          therefore the memory Address is 16M/8banks = 2M                                                          addresses/bunk (2^21). In this case, MA[21] would                                                          select the physical bunk.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          be used to determine the Chip Select(s). */
name|uint64_t
name|blen
range|:
literal|1
decl_stmt|;
comment|/**< Device Burst Length  (0=2-burst/1=4-burst)                                                          NOTE: RLDRAM-II MUST USE BLEN=0(2-burst) */
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
comment|/**< Tristate Enable (back porch) (\#dclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable back porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|fprch
range|:
literal|2
decl_stmt|;
comment|/**< Tristate Enable (front porch) (\#dclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable front porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|wr_dly
range|:
literal|4
decl_stmt|;
comment|/**< Write->Read CMD Delay (\#mclks):                                                          Determines \#mclk cycles to insert when controller                                                          switches from write to read. This allows programmer                                                          to control the data bus contention.                                                          For RLDRAM-II(BL2): (TBL=1)                                                          WR_DLY = ROUND_UP[((TWL+TBL)*2 - TSKW + FPRCH) / 2] - TRL + 1                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For aggressive(performance optimal) designs,                                                          the WR_DLY 'may' be tuned down(-1) if bus fight                                                          on W->R transitions is not pronounced. */
name|uint64_t
name|rw_dly
range|:
literal|4
decl_stmt|;
comment|/**< Read->Write CMD Delay (\#mclks):                                                          Determines \#mclk cycles to insert when controller                                                          switches from read to write. This allows programmer                                                          to control the data bus contention.                                                          For RLDRAM-II(BL2): (TBL=1)                                                          RW_DLY = ROUND_UP[((TRL+TBL)*2 + TSKW + BPRCH+2)/2] - TWL + 1                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For aggressive(performance optimal) designs,                                                          the RW_DLY 'may' be tuned down(-1) if bus fight                                                          on R->W transitions is not pronounced. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< Silo Latency (\#dclks): On reads, determines how many                                                          additional dclks to wait (on top of tRL+1) before                                                          pulling data out of the padring silos used for time                                                          domain boundary crossing.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|mtype
range|:
literal|1
decl_stmt|;
comment|/**< FCRAM-II Memory Type                                                          *** CN58XX UNSUPPORTED *** */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_p0
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA RLDRAM Port#0                                                          When enabled, this bit lets N3K be the default                                                          driver for memory port \#0.                                                          NOTE: a customer is at                                                          liberty to enable either Port#0 or Port#1 or both.                                                          NOTE: Once a port has been disabled, it MUST NEVER                                                          be re-enabled. [the only way to enable a port is                                                          through a chip reset].                                                          NOTE: DFA Memory Port#0 corresponds to the Octeon                                                          RLD0_* pins. */
name|uint64_t
name|ena_p1
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA RLDRAM Port#1                                                          When enabled, this bit lets N3K be the default                                                          driver for memory port \#1.                                                          NOTE: a customer is at                                                          liberty to enable either Port#0 or Port#1 or both.                                                          NOTE: Once a port has been disabled, it MUST NEVER                                                          be re-enabled. [the only way to enable a port is                                                          through a chip reset].                                                          NOTE: DFA Memory Port#1 corresponds to the Octeon                                                          RLD1_* pins. */
else|#
directive|else
name|uint64_t
name|ena_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mtype
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rw_dly
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wr_dly
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|blen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbunk
range|:
literal|3
decl_stmt|;
name|uint64_t
name|r2r_pbunk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bunk_init
range|:
literal|2
decl_stmt|;
name|uint64_t
name|lpp_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clkdiv
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rldck_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rldqck90_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_memcfg0_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|lpp_ena
range|:
literal|1
decl_stmt|;
comment|/**< PP Linear Port Addressing Mode Enable                                                          When enabled, PP-core LLM accesses to the lower-512MB                                                          LLM address space are sent to the single DFA port                                                          which is enabled. NOTE: If LPP_ENA=1, only                                                          one DFA RLDRAM port may be enabled for RLDRAM accesses                                                          (ie: ENA_P0 and ENA_P1 CAN NEVER BOTH be set).                                                          PP-core LLM accesses to the upper-512MB LLM address                                                          space are sent to the other 'disabled' DFA port.                                                          SW RESTRICTION: If LPP_ENA=1, then only one DFA port                                                          may be enabled for RLDRAM accesses (ie: ENA_P0 and                                                          ENA_P1 CAN NEVER BOTH be set).                                                          NOTE: This bit is used to allow PP-Core LLM accesses to a                                                          disabled port, such that each port can be sequentially                                                          addressed (ie: disable LW address interleaving).                                                          Enabling this bit allows BOTH PORTs to be active and                                                          sequentially addressable. The single port that is                                                          enabled(ENA_Px) will respond to the low-512MB LLM address                                                          space, and the other 'disabled' port will respond to the                                                          high-512MB LLM address space.                                                          Example usage:                                                             - DFA RLD0 pins used for TCAM-FPGA(CP2 accesses)                                                             - DFA RLD1 pins used for RLDRAM (DTE/CP2 accesses).                                                          USAGE NOTE:                                                          If LPP_ENA=1 and SW DOES NOT initialize the disabled port                                                          (ie: INIT_Px=0->1), then refreshes and the HW init                                                          sequence WILL NOT occur for the disabled port.                                                          If LPP_ENA=1 and SW does initialize the disabled port                                                          (INIT_Px=0->1 with ENA_Px=0), then refreshes and                                                          the HW init sequence WILL occur to the disabled port. */
name|uint64_t
name|bunk_init
range|:
literal|2
decl_stmt|;
comment|/**< Controls the CS_N[1:0] during a) a HW Initialization                                                          sequence (triggered by DFA_MEMCFG0[INIT_Px]) or                                                          b) during a normal refresh sequence. If                                                          the BNK_INIT[x]=1, the corresponding CS_N[x] is driven.                                                          NOTE: This is required for DRAM used in a                                                          clamshell configuration, since the address lines                                                          carry Mode Register write data that is unique                                                          per bunk(or clam). In a clamshell configuration,                                                          The N3K A[x] pin may be tied into Clam#0's A[x]                                                          and also into Clam#1's 'mirrored' address bit A[y]                                                          (eg: Clam0 sees A[5] and Clam1 sees A[15]).                                                          To support clamshell designs, SW must initiate                                                          two separate HW init sequences for the two bunks                                                          (or clams) . Before each HW init sequence is triggered,                                                          SW must preload the DFA_MEMRLD[22:0] with the data                                                          that will be driven onto the A[22:0] wires during                                                          an MRS mode register write.                                                          NOTE: After the final HW initialization sequence has                                                          been triggered, SW must wait 64K eclks before writing                                                          the BUNK_INIT[1:0] field = 3'b11 (so that CS_N[1:0] is                                                          driven during refresh sequences in normal operation.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For MTYPE=1(FCRAM) Mode, each bunk MUST BE                                                          initialized independently. In other words, a HW init                                                          must be done for Bunk#0, and then another HW init                                                          must be done for Bunk#1 at power-on. */
name|uint64_t
name|init_p0
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for Memory Port \#0 is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Enable memory port(s):                                                                a) ENA_P1=1 (single port in pass 1) OR                                                                b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)                                                            2) Wait 100us (to ensure a stable clock                                                               to the RLDRAMs) - as per RLDRAM spec.                                                            3) Write a '1' to the corresponding INIT_Px which                                                               will initiate a hardware initialization                                                               sequence.                                                          NOTE: After writing a '1', SW must wait 64K eclk                                                          cycles to ensure the HW init sequence has completed                                                          before writing to ANY of the DFA_MEM* registers.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: DFA Memory Port#0 corresponds to the Octeon                                                          RLD0_* pins. */
name|uint64_t
name|init_p1
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for Memory Port \#1 is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Enable memory port(s):                                                                a) ENA_P1=1 (single port in pass 1) OR                                                                b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)                                                            2) Wait 100us (to ensure a stable clock                                                               to the RLDRAMs) - as per RLDRAM spec.                                                            3) Write a '1' to the corresponding INIT_Px which                                                               will initiate a hardware initialization                                                               sequence.                                                          NOTE: After writing a '1', SW must wait 64K eclk                                                          cycles to ensure the HW init sequence has completed                                                          before writing to ANY of the DFA_MEM* registers.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: DFA Memory Port#1 corresponds to the Octeon                                                          RLD1_* pins. */
name|uint64_t
name|r2r_pbunk
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, an additional command bubble is inserted                                                          if back to back reads are issued to different physical                                                          bunks. This is to avoid DQ data bus collisions when                                                          references cross between physical bunks.                                                          [NOTE: the physical bunk address boundary is determined                                                          by the PBUNK bit].                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          When MTYPE=1(FCRAM)/BLEN=0(2-burst), R2R_PBUNK SHOULD BE                                                          ZERO(for optimal performance). However, if electrically,                                                          DQ-sharing becomes a power/heat issue, then R2R_PBUNK                                                          should be set (but at a cost to performance (1/2 BW). */
name|uint64_t
name|pbunk
range|:
literal|3
decl_stmt|;
comment|/**< Physical Bunk address bit pointer.                                                          Specifies which address bit within the Longword                                                          Memory address MA[23:0] is used to determine the                                                          chip selects.                                                          [RLD_CS0_N corresponds to physical bunk \#0, and                                                          RLD_CS1_N corresponds to physical bunk \#1].                                                            - 000: CS0_N = MA[19]/CS1_N = !MA[19]                                                            - 001: CS0_N = MA[20]/CS1_N = !MA[20]                                                            - 010: CS0_N = MA[21]/CS1_N = !MA[21]                                                            - 011: CS0_N = MA[22]/CS1_N = !MA[22]                                                            - 100: CS0_N = MA[23]/CS1_N = !MA[23]                                                            - 101-111: CS0_N = 0 /CS1_N = 1                                                          Example(s):                                                          To build out a 128MB DFA memory, 4x 32Mx9                                                          parts could be used to fill out TWO physical                                                          bunks (clamshell configuration). Each (of the                                                          two) physical bunks contains 2x 32Mx9 = 16Mx36.                                                          Each RLDRAM device also contains 8 internal banks,                                                          therefore the memory Address is 16M/8banks = 2M                                                          addresses/bunk (2^21). In this case, MA[21] would                                                          select the physical bunk.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          be used to determine the Chip Select(s).                                                          NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), a                                                          "Redundant Bunk" scheme is employed to provide the                                                          highest overall performance (1 Req/ MCLK cycle).                                                          In this mode, it's imperative that SW set the PBUNK                                                          field +1 'above' the highest address bit. (such that                                                          the PBUNK extracted from the address will always be                                                          zero). In this mode, the CS_N[1:0] pins are driven                                                          to each redundant bunk based on a TDM scheme:                                                          [MCLK-EVEN=Bunk#0/MCLK-ODD=Bunk#1]. */
name|uint64_t
name|blen
range|:
literal|1
decl_stmt|;
comment|/**< Device Burst Length  (0=2-burst/1=4-burst)                                                          When BLEN=0(BL2), all QW reads/writes from CP2 are                                                          decomposed into 2 separate BL2(LW) requests to the                                                          Low-Latency memory.                                                          When BLEN=1(BL4), a LW request (from CP2 or NCB) is                                                          treated as 1 BL4(QW) request to the low latency memory.                                                          NOTE: QW refers to a 64-bit LLM Load/Store (intiated                                                          by a processor core). LW refers to a 36-bit load/store.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization before the DFA LLM                                                          (low latency memory) is used.                                                          NOTE: MTYPE=0(RLDRAM-II) MUST USE BLEN=0(2-burst)                                                          NOTE: MTYPE=1(FCRAM)/BLEN=0(BL2) requires a                                                          multi-bunk(clam) board design.                                                          NOTE: If MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=1(BL4),                                                          SW SHOULD use CP2 QW read/write requests (for                                                          optimal low-latency bus performance).                                                          [LW length read/write requests(in BL4 mode) use 50%                                                          of the available bus bandwidth]                                                          NOTE: MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=0(BL2) can only                                                          be used with FCRAM-II devices which support BL2 mode                                                          (see: Toshiba FCRAM-II, where DQ tristate after 2 data                                                          transfers).                                                          NOTE: MTYPE=1(FCRAM)/FCRAM2P=1(II+) does not support LW                                                          write requests (FCRAM-II+ device specification has removed                                                          the variable write mask function from the devices).                                                          As such, if this mode is used, SW must be careful to                                                          issue only PP-CP2 QW write requests. */
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
comment|/**< Tristate Enable (back porch) (\#dclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable back porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|fprch
range|:
literal|2
decl_stmt|;
comment|/**< Tristate Enable (front porch) (\#dclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable front porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|wr_dly
range|:
literal|4
decl_stmt|;
comment|/**< Write->Read CMD Delay (\#mclks):                                                          Determines \#mclk cycles to insert when controller                                                          switches from write to read. This allows programmer                                                          to control the data bus contention.                                                          For RLDRAM-II(BL2): (TBL=1)                                                          For FCRAM-II (BL4): (TBL=2)                                                          For FCRAM-II (BL2 grepl=1x ONLY): (TBL=1)                                                          For FCRAM-II (BL2 grepl>=2x): (TBL=3)                                                             NOTE: When MTYTPE=1(FCRAM-II) BLEN=0(BL2 Mode),                                                             grepl>=2x, writes require redundant bunk writes                                                             which require an additional 2 cycles before slotting                                                             the next read.                                                          WR_DLY = ROUND_UP[((TWL+TBL)*2 - TSKW + FPRCH) / 2] - TRL + 1                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For aggressive(performance optimal) designs,                                                          the WR_DLY 'may' be tuned down(-1) if bus fight                                                          on W->R transitions is not pronounced. */
name|uint64_t
name|rw_dly
range|:
literal|4
decl_stmt|;
comment|/**< Read->Write CMD Delay (\#mclks):                                                          Determines \#mclk cycles to insert when controller                                                          switches from read to write. This allows programmer                                                          to control the data bus contention.                                                          For RLDRAM-II/FCRAM-II (BL2): (TBL=1)                                                          For FCRAM-II (BL4): (TBL=2)                                                          RW_DLY = ROUND_UP[((TRL+TBL)*2 + TSKW + BPRCH+2)/2] - TWL + 1                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For aggressive(performance optimal) designs,                                                          the RW_DLY 'may' be tuned down(-1) if bus fight                                                          on R->W transitions is not pronounced. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< Silo Latency (\#dclks): On reads, determines how many                                                          additional dclks to wait (on top of tRL+1) before                                                          pulling data out of the padring silos used for time                                                          domain boundary crossing.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|mtype
range|:
literal|1
decl_stmt|;
comment|/**< Memory Type (0=RLDRAM-II/1=Network DRAM-II/FCRAM)                                                          NOTE: N3K-P1 only supports RLDRAM-II                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), only the                                                          "unidirectional DS/QS" mode is supported. (see FCRAM                                                          data sheet EMRS[A6:A5]=SS(Strobe Select) register                                                          definition. [in FCRAM 2-burst mode, we use FCRAM                                                          in a clamshell configuration such that clam0 is                                                          addressed independently of clam1, and DQ is shared                                                          for optimal performance. As such it's imperative that                                                          the QS are conditionally received (and are NOT                                                          free-running), as the N3K receive data capture silos                                                          OR the clam0/1 QS strobes.                                                          NOTE: If this bit is SET, the ASX0/1                                                          ASX_RLD_FCRAM_MODE[MODE] bit(s) should also be SET                                                          in order for the RLD0/1-PHY(s) to support FCRAM devices. */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_p0
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA RLDRAM Port#0                                                          When enabled, this bit lets N3K be the default                                                          driver for memory port \#0.                                                          NOTE: For N3K-P1, to enable Port#0(2nd port),                                                          Port#1 MUST ALSO be enabled.                                                          NOTE: For N3K-P2, single port mode, a customer is at                                                          liberty to enable either Port#0 or Port#1.                                                          NOTE: Once a port has been disabled, it MUST NEVER                                                          be re-enabled. [the only way to enable a port is                                                          through a chip reset].                                                          NOTE: DFA Memory Port#0 corresponds to the Octeon                                                          RLD0_* pins. */
name|uint64_t
name|ena_p1
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA RLDRAM Port#1                                                          When enabled, this bit lets N3K be the default                                                          driver for memory port \#1.                                                          NOTE: For N3K-P1, If the customer wishes to use a                                                          single port, s/he must enable Port#1 (and not Port#0).                                                          NOTE: For N3K-P2, single port mode, a customer is at                                                          liberty to enable either Port#0 or Port#1.                                                          NOTE: Once a port has been disabled, it MUST NEVER                                                          be re-enabled. [the only way to enable a port is                                                          through a chip reset].                                                          NOTE: DFA Memory Port#1 corresponds to the Octeon                                                          RLD1_* pins. */
else|#
directive|else
name|uint64_t
name|ena_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mtype
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rw_dly
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wr_dly
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|blen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbunk
range|:
literal|3
decl_stmt|;
name|uint64_t
name|r2r_pbunk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bunk_init
range|:
literal|2
decl_stmt|;
name|uint64_t
name|lpp_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_dfa_memcfg0_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|bunk_init
range|:
literal|2
decl_stmt|;
comment|/**< Controls the CS_N[1:0] during a) a HW Initialization                                                          sequence (triggered by DFA_MEMCFG0[INIT_Px]) or                                                          b) during a normal refresh sequence. If                                                          the BNK_INIT[x]=1, the corresponding CS_N[x] is driven.                                                          NOTE: This is required for DRAM used in a                                                          clamshell configuration, since the address lines                                                          carry Mode Register write data that is unique                                                          per bunk(or clam). In a clamshell configuration,                                                          The N3K A[x] pin may be tied into Clam#0's A[x]                                                          and also into Clam#1's 'mirrored' address bit A[y]                                                          (eg: Clam0 sees A[5] and Clam1 sees A[15]).                                                          To support clamshell designs, SW must initiate                                                          two separate HW init sequences for the two bunks                                                          (or clams) . Before each HW init sequence is triggered,                                                          SW must preload the DFA_MEMRLD[22:0] with the data                                                          that will be driven onto the A[22:0] wires during                                                          an MRS mode register write.                                                          NOTE: After the final HW initialization sequence has                                                          been triggered, SW must wait 64K eclks before writing                                                          the BUNK_INIT[1:0] field = 3'b11 (so that CS_N[1:0] is                                                          driven during refresh sequences in normal operation.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For MTYPE=1(FCRAM) Mode, each bunk MUST BE                                                          initialized independently. In other words, a HW init                                                          must be done for Bunk#0, and then another HW init                                                          must be done for Bunk#1 at power-on. */
name|uint64_t
name|init_p0
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for Memory Port \#0 is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Enable memory port(s):                                                                a) ENA_P1=1 (single port in pass 1) OR                                                                b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)                                                            2) Wait 100us (to ensure a stable clock                                                               to the RLDRAMs) - as per RLDRAM spec.                                                            3) Write a '1' to the corresponding INIT_Px which                                                               will initiate a hardware initialization                                                               sequence.                                                          NOTE: After writing a '1', SW must wait 64K eclk                                                          cycles to ensure the HW init sequence has completed                                                          before writing to ANY of the DFA_MEM* registers.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: DFA Memory Port#0 corresponds to the Octeon                                                          RLD0_* pins. */
name|uint64_t
name|init_p1
range|:
literal|1
decl_stmt|;
comment|/**< When a '1' is written (and the previous value was '0'),                                                          the HW init sequence(s) for Memory Port \#1 is                                                          initiated.                                                          NOTE: To initialize memory, SW must:                                                            1) Enable memory port(s):                                                                a) ENA_P1=1 (single port in pass 1) OR                                                                b) ENA_P0=1/ENA_P1=1 (dual ports or single when not pass 1)                                                            2) Wait 100us (to ensure a stable clock                                                               to the RLDRAMs) - as per RLDRAM spec.                                                            3) Write a '1' to the corresponding INIT_Px which                                                               will initiate a hardware initialization                                                               sequence.                                                          NOTE: After writing a '1', SW must wait 64K eclk                                                          cycles to ensure the HW init sequence has completed                                                          before writing to ANY of the DFA_MEM* registers.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: DFA Memory Port#1 corresponds to the Octeon                                                          RLD1_* pins. */
name|uint64_t
name|r2r_pbunk
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, an additional command bubble is inserted                                                          if back to back reads are issued to different physical                                                          bunks. This is to avoid DQ data bus collisions when                                                          references cross between physical bunks.                                                          [NOTE: the physical bunk address boundary is determined                                                          by the PBUNK bit].                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          When MTYPE=1(FCRAM)/BLEN=0(2-burst), R2R_PBUNK SHOULD BE                                                          ZERO(for optimal performance). However, if electrically,                                                          DQ-sharing becomes a power/heat issue, then R2R_PBUNK                                                          should be set (but at a cost to performance (1/2 BW). */
name|uint64_t
name|pbunk
range|:
literal|3
decl_stmt|;
comment|/**< Physical Bunk address bit pointer.                                                          Specifies which address bit within the Longword                                                          Memory address MA[23:0] is used to determine the                                                          chip selects.                                                          [RLD_CS0_N corresponds to physical bunk \#0, and                                                          RLD_CS1_N corresponds to physical bunk \#1].                                                            - 000: CS0_N = MA[19]/CS1_N = !MA[19]                                                            - 001: CS0_N = MA[20]/CS1_N = !MA[20]                                                            - 010: CS0_N = MA[21]/CS1_N = !MA[21]                                                            - 011: CS0_N = MA[22]/CS1_N = !MA[22]                                                            - 100: CS0_N = MA[23]/CS1_N = !MA[23]                                                            - 101-111: CS0_N = 0 /CS1_N = 1                                                          Example(s):                                                          To build out a 128MB DFA memory, 4x 32Mx9                                                          parts could be used to fill out TWO physical                                                          bunks (clamshell configuration). Each (of the                                                          two) physical bunks contains 2x 32Mx9 = 16Mx36.                                                          Each RLDRAM device also contains 8 internal banks,                                                          therefore the memory Address is 16M/8banks = 2M                                                          addresses/bunk (2^21). In this case, MA[21] would                                                          select the physical bunk.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          be used to determine the Chip Select(s).                                                          NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), a                                                          "Redundant Bunk" scheme is employed to provide the                                                          highest overall performance (1 Req/ MCLK cycle).                                                          In this mode, it's imperative that SW set the PBUNK                                                          field +1 'above' the highest address bit. (such that                                                          the PBUNK extracted from the address will always be                                                          zero). In this mode, the CS_N[1:0] pins are driven                                                          to each redundant bunk based on a TDM scheme:                                                          [MCLK-EVEN=Bunk#0/MCLK-ODD=Bunk#1]. */
name|uint64_t
name|blen
range|:
literal|1
decl_stmt|;
comment|/**< Device Burst Length  (0=2-burst/1=4-burst)                                                          When BLEN=0(BL2), all QW reads/writes from CP2 are                                                          decomposed into 2 separate BL2(LW) requests to the                                                          Low-Latency memory.                                                          When BLEN=1(BL4), a LW request (from CP2 or NCB) is                                                          treated as 1 BL4(QW) request to the low latency memory.                                                          NOTE: QW refers to a 64-bit LLM Load/Store (intiated                                                          by a processor core). LW refers to a 36-bit load/store.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization before the DFA LLM                                                          (low latency memory) is used.                                                          NOTE: MTYPE=0(RLDRAM-II) MUST USE BLEN=0(2-burst)                                                          NOTE: MTYPE=1(FCRAM)/BLEN=0(BL2) requires a                                                          multi-bunk(clam) board design.                                                          NOTE: If MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=1(BL4),                                                          SW SHOULD use CP2 QW read/write requests (for                                                          optimal low-latency bus performance).                                                          [LW length read/write requests(in BL4 mode) use 50%                                                          of the available bus bandwidth]                                                          NOTE: MTYPE=1(FCRAM)/FCRAM2P=0(II)/BLEN=0(BL2) can only                                                          be used with FCRAM-II devices which support BL2 mode                                                          (see: Toshiba FCRAM-II, where DQ tristate after 2 data                                                          transfers).                                                          NOTE: MTYPE=1(FCRAM)/FCRAM2P=1(II+) does not support LW                                                          write requests (FCRAM-II+ device specification has removed                                                          the variable write mask function from the devices).                                                          As such, if this mode is used, SW must be careful to                                                          issue only PP-CP2 QW write requests. */
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
comment|/**< Tristate Enable (back porch) (\#dclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable back porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|fprch
range|:
literal|2
decl_stmt|;
comment|/**< Tristate Enable (front porch) (\#dclks)                                                          On reads, allows user to control the shape of the                                                          tristate disable front porch for the DQ data bus.                                                          This parameter is also very dependent on the                                                          RW_DLY and WR_DLY parameters and care must be                                                          taken when programming these parameters to avoid                                                          data bus contention. Valid range [0..2]                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|wr_dly
range|:
literal|4
decl_stmt|;
comment|/**< Write->Read CMD Delay (\#mclks):                                                          Determines \#mclk cycles to insert when controller                                                          switches from write to read. This allows programmer                                                          to control the data bus contention.                                                          For RLDRAM-II(BL2): (TBL=1)                                                          For FCRAM-II (BL4): (TBL=2)                                                          For FCRAM-II (BL2 grepl=1x ONLY): (TBL=1)                                                          For FCRAM-II (BL2 grepl>=2x): (TBL=3)                                                             NOTE: When MTYTPE=1(FCRAM-II) BLEN=0(BL2 Mode),                                                             grepl>=2x, writes require redundant bunk writes                                                             which require an additional 2 cycles before slotting                                                             the next read.                                                          WR_DLY = ROUND_UP[((TWL+TBL)*2 - TSKW + FPRCH) / 2] - TRL + 1                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For aggressive(performance optimal) designs,                                                          the WR_DLY 'may' be tuned down(-1) if bus fight                                                          on W->R transitions is not pronounced. */
name|uint64_t
name|rw_dly
range|:
literal|4
decl_stmt|;
comment|/**< Read->Write CMD Delay (\#mclks):                                                          Determines \#mclk cycles to insert when controller                                                          switches from read to write. This allows programmer                                                          to control the data bus contention.                                                          For RLDRAM-II/FCRAM-II (BL2): (TBL=1)                                                          For FCRAM-II (BL4): (TBL=2)                                                          RW_DLY = ROUND_UP[((TRL+TBL)*2 + TSKW + BPRCH+2)/2] - TWL + 1                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: For aggressive(performance optimal) designs,                                                          the RW_DLY 'may' be tuned down(-1) if bus fight                                                          on R->W transitions is not pronounced. */
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
comment|/**< Silo Latency (\#dclks): On reads, determines how many                                                          additional dclks to wait (on top of tRL+1) before                                                          pulling data out of the padring silos used for time                                                          domain boundary crossing.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|mtype
range|:
literal|1
decl_stmt|;
comment|/**< Memory Type (0=RLDRAM-II/1=Network DRAM-II/FCRAM)                                                          NOTE: N3K-P1 only supports RLDRAM-II                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: When MTYPE=1(FCRAM)/BLEN=0(2-burst), only the                                                          "unidirectional DS/QS" mode is supported. (see FCRAM                                                          data sheet EMRS[A6:A5]=SS(Strobe Select) register                                                          definition. [in FCRAM 2-burst mode, we use FCRAM                                                          in a clamshell configuration such that clam0 is                                                          addressed independently of clam1, and DQ is shared                                                          for optimal performance. As such it's imperative that                                                          the QS are conditionally received (and are NOT                                                          free-running), as the N3K receive data capture silos                                                          OR the clam0/1 QS strobes.                                                          NOTE: If this bit is SET, the ASX0/1                                                          ASX_RLD_FCRAM_MODE[MODE] bit(s) should also be SET                                                          in order for the RLD0/1-PHY(s) to support FCRAM devices. */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_p0
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA RLDRAM Port#0                                                          When enabled, this bit lets N3K be the default                                                          driver for memory port \#0.                                                          NOTE: For N3K-P1, to enable Port#0(2nd port),                                                          Port#1 MUST ALSO be enabled.                                                          NOTE: For N3K-P2, single port mode, a customer is at                                                          liberty to enable either Port#0 or Port#1.                                                          NOTE: Once a port has been disabled, it MUST NEVER                                                          be re-enabled. [the only way to enable a port is                                                          through a chip reset].                                                          NOTE: DFA Memory Port#0 corresponds to the Octeon                                                          RLD0_* pins. */
name|uint64_t
name|ena_p1
range|:
literal|1
decl_stmt|;
comment|/**< Enable DFA RLDRAM Port#1                                                          When enabled, this bit lets N3K be the default                                                          driver for memory port \#1.                                                          NOTE: For N3K-P1, If the customer wishes to use a                                                          single port, s/he must enable Port#1 (and not Port#0).                                                          NOTE: For N3K-P2, single port mode, a customer is at                                                          liberty to enable either Port#0 or Port#1.                                                          NOTE: Once a port has been disabled, it MUST NEVER                                                          be re-enabled. [the only way to enable a port is                                                          through a chip reset].                                                          NOTE: DFA Memory Port#1 corresponds to the Octeon                                                          RLD1_* pins. */
else|#
directive|else
name|uint64_t
name|ena_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ena_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mtype
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sil_lat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rw_dly
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wr_dly
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bprch
range|:
literal|2
decl_stmt|;
name|uint64_t
name|blen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbunk
range|:
literal|3
decl_stmt|;
name|uint64_t
name|r2r_pbunk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|init_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bunk_init
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_dfa_memcfg0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memcfg0
name|cvmx_dfa_memcfg0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memcfg1  *  * DFA_MEMCFG1 = RLDRAM Memory Timing Configuration  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_memcfg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memcfg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|ref_intlo
range|:
literal|9
decl_stmt|;
comment|/**< Burst Refresh Interval[8:0] (\#dclks)                                                          For finer refresh interval granularity control.                                                          This field provides an additional level of granularity                                                          for the refresh interval. It specifies the additional                                                          \#dclks [0...511] to be added to the REF_INT[3:0] field.                                                          For RLDRAM-II: For dclk(400MHz=2.5ns):                                                          Example: 64K AREF cycles required within tREF=32ms                                                              trefint = tREF(ms)/(64K cycles/8banks)                                                                          = 32ms/8K = 3.9us = 3900ns                                                              REF_INT[3:0] = ROUND_DOWN[(trefint/dclk)/512]                                                                           = ROUND_DOWN[(3900/2.5)/512]                                                                           = 3                                                              REF_INTLO[8:0] = MOD[(trefint/dclk)/512]                                                                             = MOD[(3900/2.5)/512]                                                                             = 24                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|aref_ena
range|:
literal|1
decl_stmt|;
comment|/**< Auto Refresh Cycle Enable                                                          INTERNAL USE ONLY:                                                          NOTE: This mode bit is ONLY intended to be used by                                                          low-level power-on initialization routines in the                                                          event that the hardware initialization routine                                                          does not work. It allows SW to create AREF                                                          commands on the RLDRAM bus directly.                                                          When this bit is set, ALL RLDRAM writes (issued by                                                          a PP through the NCB or CP2) are converted to AREF                                                          commands on the RLDRAM bus. The write-address is                                                          presented on the A[20:0]/BA[2:0] pins (for which                                                          the RLDRAM only interprets BA[2:0]).                                                          When this bit is set, only writes are allowed                                                          and MUST use grepl=0 (1x).                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: MRS_ENA and AREF_ENA are mutually exclusive                                                          (SW can set one or the other, but never both!)                                                          NOTE: AREF commands generated using this method target                                                          the 'addressed' bunk. */
name|uint64_t
name|mrs_ena
range|:
literal|1
decl_stmt|;
comment|/**< Mode Register Set Cycle Enable                                                          INTERNAL USE ONLY:                                                          NOTE: This mode bit is ONLY intended to be used by                                                          low-level power-on initialization routines in the                                                          event that the hardware initialization routine                                                          does not work. It allows SW to create MRS                                                          commands on the RLDRAM bus directly.                                                          When this bit is set, ALL RLDRAM writes (issued by                                                          a PP through the NCB or CP2) are converted to MRS                                                          commands on the RLDRAM bus. The write-address is                                                          presented on the A[20:0]/BA[2:0] pins (for which                                                          the RLDRAM only interprets A[17:0]).                                                          When this bit is set, only writes are allowed                                                          and MUST use grepl=0 (1x).                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization.                                                          NOTE: MRS_ENA and AREF_ENA are mutually exclusive                                                          (SW can set one or the other, but never both!)                                                          NOTE: MRS commands generated using this method target                                                          the 'addressed' bunk. */
name|uint64_t
name|tmrsc
range|:
literal|3
decl_stmt|;
comment|/**< Mode Register Set Cycle Time (represented in \#mclks)                                                               - 000-001: RESERVED                                                               - 010: tMRSC = 2 mclks                                                               - 011: tMRSC = 3 mclks                                                               - ...                                                               - 111: tMRSC = 7 mclks                                                          NOTE: The device tMRSC parameter is a function of CL                                                          (which during HW initialization is not known. Its                                                          recommended to load tMRSC(MAX) value to avoid timing                                                          violations.                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|trc
range|:
literal|4
decl_stmt|;
comment|/**< Row Cycle Time (represented in \#mclks)                                                          see also: DFA_MEMRLD[RLCFG] field which must                                                          correspond with tRL/tWL parameter(s).                                                               - 0000-0010: RESERVED                                                               - 0011: tRC = 3 mclks                                                               - 0100: tRC = 4 mclks                                                               - 0101: tRC = 5 mclks                                                               - 0110: tRC = 6 mclks                                                               - 0111: tRC = 7 mclks                                                               - 1000: tRC = 8 mclks                                                               - 1001: tRC = 9 mclks                                                               - 1010-1111: RESERVED                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|twl
range|:
literal|4
decl_stmt|;
comment|/**< Write Latency (represented in \#mclks)                                                          see also: DFA_MEMRLD[RLCFG] field which must                                                          correspond with tRL/tWL parameter(s).                                                               - 0000-0001: RESERVED                                                               - 0010: Write Latency (WL=2.0 mclk)                                                               - 0011: Write Latency (WL=3.0 mclks)                                                               - 0100: Write Latency (WL=4.0 mclks)                                                               - 0101: Write Latency (WL=5.0 mclks)                                                               - 0110: Write Latency (WL=6.0 mclks)                                                               - 0111: Write Latency (WL=7.0 mclks)                                                               - 1000: Write Latency (WL=8.0 mclks)                                                               - 1001: Write Latency (WL=9.0 mclks)                                                               - 1010: Write Latency (WL=10.0 mclks)                                                               - 1011-1111: RESERVED                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|trl
range|:
literal|4
decl_stmt|;
comment|/**< Read Latency (represented in \#mclks)                                                          see also: DFA_MEMRLD[RLCFG] field which must                                                          correspond with tRL/tWL parameter(s).                                                               - 0000-0010: RESERVED                                                               - 0011: Read Latency = 3 mclks                                                               - 0100: Read Latency = 4 mclks                                                               - 0101: Read Latency = 5 mclks                                                               - 0110: Read Latency = 6 mclks                                                               - 0111: Read Latency = 7 mclks                                                               - 1000: Read Latency = 8 mclks                                                               - 1001: Read Latency = 9 mclks                                                               - 1010: Read Latency = 10 mclks                                                               - 1011-1111: RESERVED                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
comment|/**< Board Skew (represented in \#dclks)                                                          Represents additional board skew of DQ/DQS.                                                              - 00: board-skew = 0 dclk                                                              - 01: board-skew = 1 dclk                                                              - 10: board-skew = 2 dclk                                                              - 11: board-skew = 3 dclk                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|ref_int
range|:
literal|4
decl_stmt|;
comment|/**< Refresh Interval (represented in \#of 512 dclk                                                          increments).                                                               - 0000: RESERVED                                                               - 0001: 1 * 512  = 512 dclks                                                               - ...                                                               - 1111: 15 * 512 = 7680 dclks                                                          NOTE: For finer level of granularity, refer to                                                          REF_INTLO[8:0] field.                                                          For RLDRAM-II, each refresh interval will                                                          generate a burst of 8 AREF commands, one to each of                                                          8 explicit banks (referenced using the RLD_BA[2:0]                                                          pins.                                                          Example: For mclk=200MHz/dclk(400MHz=2.5ns):                                                            64K AREF cycles required within tREF=32ms                                                              trefint = tREF(ms)/(64K cycles/8banks)                                                                      = 32ms/8K = 3.9us = 3900ns                                                              REF_INT = ROUND_DOWN[(trefint/dclk)/512]                                                                      = ROUND_DOWN[(3900/2.5)/512]                                                                      = 3                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|ref_int
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tskw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|trl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|twl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|trc
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tmrsc
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mrs_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|aref_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ref_intlo
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_memcfg1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memcfg1
name|cvmx_dfa_memcfg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memcfg2  *  * DFA_MEMCFG2 = DFA Memory Config Register \#2  * *** NOTE: Pass2 Addition  *  * Description: Additional Memory Configuration CSRs to support FCRAM-II/II+ and Network DRAM-II  */
end_comment

begin_union
union|union
name|cvmx_dfa_memcfg2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memcfg2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
comment|/**< DFA DTE Clock Disable                                                          When SET, the DFA clocks for DTE(thread engine)                                                          operation are disabled.                                                          NOTE: When SET, SW MUST NEVER issue ANY operations to                                                          the DFA via the NCB Bus. All DFA Operations must be                                                          issued solely through the CP2 interface.                                                           NOTE: When DTECLKDIS=1, if CP2 Errors are encountered                                                          (ie: CP2SBE, CP2DBE, CP2PERR), the DFA_MEMFADR CSR                                                          does not reflect the failing address/ctl information. */
name|uint64_t
name|silrst
range|:
literal|1
decl_stmt|;
comment|/**< LLM-PHY Silo Reset                                                          When a '1' is written (when the previous                                                          value was a '0') causes the the LLM-PHY Silo read/write                                                          pointers to be reset.                                                          NOTE: SW MUST WAIT 400 dclks after the LAST HW Init                                                          sequence was launched (ie: INIT_START 0->1 CSR write),                                                          before the SILRST can be triggered (0->1). */
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
comment|/**< FCRAM-II Refresh Interval                                                          *** CN58XX UNSUPPORTED *** */
name|uint64_t
name|refshort
range|:
literal|1
decl_stmt|;
comment|/**< FCRAM Short Refresh Mode                                                          *** CN58XX UNSUPPORTED *** */
name|uint64_t
name|ua_start
range|:
literal|2
decl_stmt|;
comment|/**< FCRAM-II Upper Addres Start                                                          *** CN58XX UNSUPPORTED *** */
name|uint64_t
name|maxbnk
range|:
literal|1
decl_stmt|;
comment|/**< Maximum Banks per-device (used by the address mapper                                                          when extracting address bits for the memory bank#.                                                            - 0: 4 banks/device                                                            - 1: 8 banks/device */
name|uint64_t
name|fcram2p
range|:
literal|1
decl_stmt|;
comment|/**< FCRAM-II+ Mode Enable                                                          *** CN58XX UNSUPPORTED *** */
else|#
directive|else
name|uint64_t
name|fcram2p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxbnk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ua_start
range|:
literal|2
decl_stmt|;
name|uint64_t
name|refshort
range|:
literal|1
decl_stmt|;
name|uint64_t
name|trfc
range|:
literal|5
decl_stmt|;
name|uint64_t
name|silrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dteclkdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_memcfg2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_memcfg2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memcfg2
name|cvmx_dfa_memcfg2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memfadr  *  * DFA_MEMFADR = RLDRAM Failing Address/Control Register  *  * Description: DFA Memory Failing Address/Control Error Capture information  * This register contains useful information to help in isolating an RLDRAM memory failure.  * NOTE: The first detected SEC/DED/PERR failure is captured in DFA_MEMFADR, however, a DED or PERR (which is  * more severe) will always overwrite a SEC error. The user can 'infer' the source of the interrupt  * via the FSRC field.  * NOTE: If DFA_MEMCFG2[DTECLKDIS]=1, the contents of this register are UNDEFINED.  */
end_comment

begin_union
union|union
name|cvmx_dfa_memfadr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memfadr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|maddr
range|:
literal|24
decl_stmt|;
comment|/**< Memory Address */
else|#
directive|else
name|uint64_t
name|maddr
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_memfadr_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|fdst
range|:
literal|9
decl_stmt|;
comment|/**< Fill-Destination                                                             FSRC[1:0]    | FDST[8:0]                                                             -------------+-------------------------------------                                                              0(NCB-DTE)  | [fillstart,2'b0,WIDX(1),DMODE(1),DTE(4)]                                                              1(NCB-CSR)  | [ncbSRC[8:0]]                                                              3(CP2-PP)   | [2'b0,SIZE(1),INDEX(1),PP(4),FID(1)]                                                            where:                                                                DTE: DFA Thread Engine ID#                                                                PP: Packet Processor ID#                                                                FID: Fill-ID# (unique per PP)                                                                WIDX:  16b SIMPLE Mode (index)                                                                DMODE: (0=16b SIMPLE/1=32b SIMPLE)                                                                SIZE: (0=LW Mode access/1=QW Mode Access)                                                                INDEX: (0=Low LW/1=High LW)                                                          NOTE: QW refers to a 56/64-bit LLM Load/Store (intiated                                                          by a processor core). LW refers to a 32-bit load/store. */
name|uint64_t
name|fsrc
range|:
literal|2
decl_stmt|;
comment|/**< Fill-Source (0=NCB-DTE/1=NCB-CSR/2=RESERVED/3=PP-CP2) */
name|uint64_t
name|pnum
range|:
literal|1
decl_stmt|;
comment|/**< Memory Port                                                          NOTE: For O2P, this bit will always return zero. */
name|uint64_t
name|bnum
range|:
literal|3
decl_stmt|;
comment|/**< Memory Bank                                                          When DFA_DDR2_ADDR[RNK_LO]=1, BNUM[2]=RANK[0].                                                          (RANK[1] can be inferred from MADDR[24:0]) */
name|uint64_t
name|maddr
range|:
literal|25
decl_stmt|;
comment|/**< Memory Address */
else|#
directive|else
name|uint64_t
name|maddr
range|:
literal|25
decl_stmt|;
name|uint64_t
name|bnum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pnum
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsrc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fdst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_dfa_memfadr_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
name|uint64_t
name|fdst
range|:
literal|9
decl_stmt|;
comment|/**< Fill-Destination                                                             FSRC[1:0]    | FDST[8:0]                                                             -------------+-------------------------------------                                                              0(NCB-DTE)  | [fillstart,2'b0,WIDX(1),DMODE(1),DTE(4)]                                                              1(NCB-CSR)  | [ncbSRC[8:0]]                                                              3(CP2-PP)   | [2'b0,SIZE(1),INDEX(1),PP(4),FID(1)]                                                            where:                                                                DTE: DFA Thread Engine ID#                                                                PP: Packet Processor ID#                                                                FID: Fill-ID# (unique per PP)                                                                WIDX:  18b SIMPLE Mode (index)                                                                DMODE: (0=18b SIMPLE/1=36b SIMPLE)                                                                SIZE: (0=LW Mode access/1=QW Mode Access)                                                                INDEX: (0=Low LW/1=High LW)                                                          NOTE: QW refers to a 64-bit LLM Load/Store (intiated                                                          by a processor core). LW refers to a 36-bit load/store. */
name|uint64_t
name|fsrc
range|:
literal|2
decl_stmt|;
comment|/**< Fill-Source (0=NCB-DTE/1=NCB-CSR/2=RESERVED/3=PP-CP2) */
name|uint64_t
name|pnum
range|:
literal|1
decl_stmt|;
comment|/**< Memory Port                                                          NOTE: the port id's are reversed                                                             PNUM==0 => port#1                                                             PNUM==1 => port#0 */
name|uint64_t
name|bnum
range|:
literal|3
decl_stmt|;
comment|/**< Memory Bank */
name|uint64_t
name|maddr
range|:
literal|24
decl_stmt|;
comment|/**< Memory Address */
else|#
directive|else
name|uint64_t
name|maddr
range|:
literal|24
decl_stmt|;
name|uint64_t
name|bnum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pnum
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsrc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fdst
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_39_63
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_dfa_memfadr_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_memfadr_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_memfadr_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memfadr
name|cvmx_dfa_memfadr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memfcr  *  * DFA_MEMFCR = FCRAM MRS Register(s) EMRS2[14:0], EMRS1[14:0], MRS[14:0]  * *** CN58XX UNSUPPORTED ***  *  * Notes:  * For FCRAM-II please consult your device's data sheet for further details:  * MRS Definition:  *    A[13:8]=0   RESERVED  *    A[7]=0      TEST MODE     (N3K requires test mode 0:"disabled")  *    A[6:4]      CAS LATENCY   (fully programmable - SW must ensure that the value programmed  *                               into DFA_MEM_CFG0[TRL] corresponds with this value).  *    A[3]=0      BURST TYPE    (N3K requires 0:"Sequential" Burst Type)  *    A[2:0]      BURST LENGTH  Burst Length [1:BL2/2:BL4] (N3K only supports BL=2,4)  *  *                                  In BL2 mode(for highest performance), only 1/2 the phsyical  *                                  memory is unique (ie: each bunk stores the same information).  *                                  In BL4 mode(highest capacity), all of the physical memory  *                                  is unique (ie: each bunk is uniquely addressable).  * EMRS Definition:  *    A[13:12]    REFRESH MODE  (N3K Supports only 0:"Conventional" and 1:"Short" auto-refresh modes)  *  *                              (SW must ensure that the value programmed into DFA_MEMCFG2[REFSHORT]  *                              is also reflected in the Refresh Mode encoding).  *    A[11:7]=0   RESERVED  *    A[6:5]=2    STROBE SELECT (N3K supports only 2:"Unidirectional DS/QS" mode - the read capture  *                              silos rely on a conditional QS strobe)  *    A[4:3]      DIC(QS)       QS Drive Strength: fully programmable (consult your FCRAM-II data sheet)  *                                [0: Normal Output Drive/1: Strong Output Drive/2: Weak output Drive]  *    A[2:1]      DIC(DQ)       DQ Drive Strength: fully programmable (consult your FCRAM-II data sheet)  *                                [0: Normal Output Drive/1: Strong Output Drive/2: Weak output Drive]  *    A[0]        DLL           DLL Enable: Programmable [0:DLL Enable/1: DLL Disable]  *  * EMRS2 Definition: (for FCRAM-II+)  *    A[13:11]=0                RESERVED  *    A[10:8]     ODTDS         On Die Termination (DS+/-)  *                                 [0: ODT Disable /1: 15ohm termination /(2-7): RESERVED]  *    A[7:6]=0    MBW           Multi-Bank Write: (N3K requires use of 0:"single bank" mode only)  *    A[5:3]      ODTin         On Die Termination (input pin)  *                                 [0: ODT Disable /1: 15ohm termination /(2-7): RESERVED]  *    A[2:0]      ODTDQ         On Die Termination (DQ)  *                                 [0: ODT Disable /1: 15ohm termination /(2-7): RESERVED]  */
end_comment

begin_union
union|union
name|cvmx_dfa_memfcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memfcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|emrs2
range|:
literal|15
decl_stmt|;
comment|/**< Memory Address[14:0] during EMRS2(for FCRAM-II+)                                                          *** CN58XX UNSUPPORTED *** */
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|emrs
range|:
literal|15
decl_stmt|;
comment|/**< Memory Address[14:0] during EMRS                                                          *** CN58XX UNSUPPORTED ***                                                            A[0]=1: DLL Enabled) */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrs
range|:
literal|15
decl_stmt|;
comment|/**< FCRAM Memory Address[14:0] during MRS                                                          *** CN58XX UNSUPPORTED ***                                                            A[6:4]=4  CAS LATENCY=4(default)                                                            A[3]=0    Burst Type(must be 0:Sequential)                                                            A[2:0]=2  Burst Length=4(default) */
else|#
directive|else
name|uint64_t
name|mrs
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|emrs
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|emrs2
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_memfcr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_memfcr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_memfcr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_memfcr_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memfcr
name|cvmx_dfa_memfcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memhidat  *  * DFA_MEMHIDAT = DFA NCB-Direct CSR access to DFM Memory Space (High QW)  *  * Description:  * DFA supports NCB-Direct CSR acccesses to DFM Memory space for debug purposes. Unfortunately, NCB-Direct accesses  * are limited to QW-size(64bits), whereas the minimum access granularity for DFM Memory space is OW(128bits). To  * support writes to DFM Memory space, the Hi-QW of data is sourced from the DFA_MEMHIDAT register. Recall, the  * OW(128b) in DDR3 memory space is fixed format:  *     OWDATA[127:118]: OWECC[9:0] 10bits of in-band OWECC SEC/DED codeword  *                      This can be precomputed/written by SW OR  *                      if DFM_FNTCTL[ECC_WENA]=1, DFM hardware will auto-compute the 10b OWECC and place in the  *                      OWDATA[127:118] before being written to memory.  *     OWDATA[117:0]:   Memory Data (contains fixed MNODE/MONODE arc formats for use by DTEs(thread engines).  *                      Or, a user may choose to treat DFM Memory Space as 'scratch pad' in which case the  *                      OWDATA[117:0] may contain user-specified information accessible via NCB-Direct CSR mode  *                      accesses to DFA Memory Space.  *  NOTE: To write to the DFA_MEMHIDAT register, a device would issue an IOBST directed at the DFA with addr[34:32]=3'b111.  *        To read the DFA_MEMHIDAT register, a device would issue an IOBLD64 directed at the DFA with addr[34:32]=3'b111.  *  *  NOTE: If DFA_CONFIG[DTECLKDIS]=1 (DFA-DTE clocks disabled), reads/writes to the DFA_MEMHIDAT register do not take effect.  *  NOTE: If FUSE[TBD]="DFA DTE disable" is blown, reads/writes to the DFA_MEMHIDAT register do not take effect.  *  * NOTE: PLEASE REMOVE DEFINITION FROM o68 HRM  */
end_comment

begin_union
union|union
name|cvmx_dfa_memhidat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memhidat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|hidat
range|:
literal|64
decl_stmt|;
comment|/**< DFA Hi-QW of Write data during NCB-Direct DFM DDR3                                                          Memory accesses.                                                          All DFM DDR3 memory accesses are OW(128b) references,                                                          and since NCB-Direct Mode writes only support QW(64b),                                                          the Hi QW of data must be sourced from a CSR register.                                                          NOTE: This single register is 'shared' for ALL DFM                                                          DDR3 Memory writes.                                                          For o68: This register is UNUSED. Treat as spare bits.                                                          NOTE: PLEASE REMOVE DEFINITION FROM o68 HRM */
else|#
directive|else
name|uint64_t
name|hidat
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_memhidat_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_memhidat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_memhidat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_memhidat_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_memhidat_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_memhidat_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memhidat
name|cvmx_dfa_memhidat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_memrld  *  * DFA_MEMRLD = DFA RLDRAM MRS Register Values  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_memrld
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_memrld_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|mrsdat
range|:
literal|23
decl_stmt|;
comment|/**< This field represents the data driven onto the                                                          A[22:0] address lines during MRS(Mode Register Set)                                                          commands (during a HW init sequence). This field                                                          corresponds with the Mode Register Bit Map from                                                          your RLDRAM-II device specific data sheet.                                                             A[17:10]: RESERVED                                                             A[9]:     ODT (on die termination)                                                             A[8]:     Impedance Matching                                                             A[7]:     DLL Reset                                                             A[6]:     UNUSED                                                             A[5]:     Address Mux  (for N3K: MUST BE ZERO)                                                             A[4:3]:   Burst Length (for N3K: MUST BE ZERO)                                                             A[2:0]:   Configuration (see data sheet for                                                                       specific RLDRAM-II device).                                                                - 000-001: CFG=1 [tRC=4/tRL=4/tWL=5]                                                                - 010:     CFG=2 [tRC=6/tRL=6/tWL=7]                                                                - 011:     CFG=3 [tRC=8/tRL=8/tWL=9]                                                                - 100-111: RESERVED                                                           NOTE: For additional density, the RLDRAM-II parts                                                           can be 'clamshelled' (ie: two devices mounted on                                                           different sides of the PCB board), since the BGA                                                           pinout supports 'mirroring'.                                                           To support a clamshell design, SW must preload                                                           the MRSDAT[22:0] with the proper A[22:0] pin mapping                                                           which is dependent on the 'selected' bunk/clam                                                           (see also: DFA_MEMCFG0[BUNK_INIT] field).                                                           NOTE: Care MUST BE TAKEN NOT to write to this register                                                           within 64K eclk cycles of a HW INIT (see: INIT_P0/INIT_P1).                                                           NOTE: This should only be written to a different value                                                           during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|mrsdat
range|:
literal|23
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_memrld_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_memrld_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_memrld_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_memrld_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_memrld
name|cvmx_dfa_memrld_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_ncbctl  *  * DFA_NCBCTL = DFA NCB CTL Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_ncbctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_ncbctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|5
decl_stmt|;
comment|/**< SBD Debug Entry#                                                          For internal use only. (DFA Scoreboard debug)                                                          Selects which one of 32 DFA Scoreboard entries is                                                          latched into the DFA_SBD_DBG[0-3] registers. */
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
comment|/**< DFA Scoreboard LOCK Strobe                                                          For internal use only. (DFA Scoreboard debug)                                                          When written with a '1', the DFA Scoreboard Debug                                                          registers (DFA_SBD_DBG[0-3]) are all locked down.                                                          This allows SW to lock down the contents of the entire                                                          SBD for a single instant in time. All subsequent reads                                                          of the DFA scoreboard registers will return the data                                                          from that instant in time. */
name|uint64_t
name|dcmode
range|:
literal|1
decl_stmt|;
comment|/**< DRF-CRQ/DTE Arbiter Mode                                                          DTE-DRF Arbiter (0=FP [LP=CRQ/HP=DTE],1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|dtmode
range|:
literal|1
decl_stmt|;
comment|/**< DRF-DTE Arbiter Mode                                                          DTE-DRF Arbiter (0=FP [LP=DTE[15],...,HP=DTE[0]],1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRP Arbiter Mode                                                          (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRQ Arbiter Mode                                                          (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-Inbound Arbiter                                                          (0=FP [LP=NRQ,HP=NRP], 1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_dfa_ncbctl_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|4
decl_stmt|;
comment|/**< SBD Debug Entry#                                                          For internal use only. (DFA Scoreboard debug)                                                          Selects which one of 16 DFA Scoreboard entries is                                                          latched into the DFA_SBD_DBG[0-3] registers. */
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
comment|/**< DFA Scoreboard LOCK Strobe                                                          For internal use only. (DFA Scoreboard debug)                                                          When written with a '1', the DFA Scoreboard Debug                                                          registers (DFA_SBD_DBG[0-3]) are all locked down.                                                          This allows SW to lock down the contents of the entire                                                          SBD for a single instant in time. All subsequent reads                                                          of the DFA scoreboard registers will return the data                                                          from that instant in time. */
name|uint64_t
name|dcmode
range|:
literal|1
decl_stmt|;
comment|/**< DRF-CRQ/DTE Arbiter Mode                                                          DTE-DRF Arbiter (0=FP [LP=CRQ/HP=DTE],1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|dtmode
range|:
literal|1
decl_stmt|;
comment|/**< DRF-DTE Arbiter Mode                                                          DTE-DRF Arbiter (0=FP [LP=DTE[15],...,HP=DTE[0]],1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRP Arbiter Mode                                                          (0=Fixed Priority [LP=WQF,DFF,HP=RGF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-NRQ Arbiter Mode                                                          (0=Fixed Priority [LP=IRF,RWF,PRF,HP=GRF]/1=RR                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
comment|/**< NCB-Inbound Arbiter                                                          (0=FP [LP=NRQ,HP=NRP], 1=RR)                                                          NOTE: This should only be written to a different value                                                          during power-on SW initialization. */
else|#
directive|else
name|uint64_t
name|imode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdlck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbdnum
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_dfa_ncbctl_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_ncbctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_ncbctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_ncbctl
name|cvmx_dfa_ncbctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc0_cnt  *  * DFA_PFC0_CNT = DFA Performance Counter \#0  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc0_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc0_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pfcnt0
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter \#0                                                          When DFA_PFC_GCTL[CNT0ENA]=1, the event selected                                                          by DFA_PFC0_CTL[EVSEL] is counted.                                                          See also DFA_PFC_GCTL[CNT0WCLR] and DFA_PFC_GCTL                                                          [CNT0RCLR] for special clear count cases available                                                          for SW data collection. */
else|#
directive|else
name|uint64_t
name|pfcnt0
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc0_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_cnt_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc0_cnt
name|cvmx_dfa_pfc0_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc0_ctl  *  * DFA_PFC0_CTL = DFA Performance Counter#0 Control  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc0_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc0_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter#0 Event Selector                                                          // Events [0-31] are based on PMODE(0:per cluster-DTE 1:per graph)                                                           - 0:  \#Total Cycles                                                           - 1:  \#LDNODE visits                                                           - 2:  \#SDNODE visits                                                           - 3:  \#DNODE visits (LD/SD)                                                           - 4:  \#LCNODE visits                                                           - 5:  \#SCNODE visits                                                           - 6:  \#CNODE visits (LC/SC)                                                           - 7:  \#LMNODE visits                                                           - 8:  \#SMNODE visits                                                           - 9:  \#MNODE visits (LM/SM)                                                            - 10: \#MONODE visits                                                            - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX                                                            - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)                                                            - 13: \#MEMORY visits (MNODE+MONODE)                                                            - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)                                                            - 15: \#MPHIDX detected (occur for ->LMNODE transitions)                                                            - 16: \#RESCANs detected (occur when HASH collision is detected)                                                            - 17: \#GWALK iterations STALLED - Packet data/Result Buffer                                                            - 18: \#GWALK iterations NON-STALLED                                                            - 19: \#CLOAD iterations                                                            - 20: \#MLOAD iterations                                                                [NOTE: If PMODE=1(per-graph) the MLOAD IWORD0.VGID will be used to discern graph#].                                                            - 21: \#RWORD1+ writes                                                            - 22: \#cycles Cluster is busy                                                            - 23: \#GWALK Instructions                                                            - 24: \#CLOAD Instructions                                                            - 25: \#MLOAD Instructions                                                                [NOTE: If PMODE=1(per-graph) the MLOAD IWORD0.VGID will be used to discern graph#].                                                            - 26: \#GFREE Instructions                                                            - 27-30: RESERVED                                                            - 31: \# Node Transitions detected (see DFA_PFC_GCTL[SNODE,ENODE,EDNODE] registers                                                          //=============================================================                                                          // Events [32-63] are used ONLY FOR PMODE=0(per-cluster DTE mode):                                                            - 32: \#cycles a specific cluster-DTE remains active(valid state)                                                            - 33: \#cycles a specific cluster-DTE waits for Memory Response Data                                                            - 34: \#cycles a specific cluster-DTE waits in resource stall state                                                                   (waiting for packet data or result buffer space)                                                            - 35: \#cycles a specific cluster-DTE waits in resource pending state                                                            - 36-63: RESERVED                                                          //============================================================= */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
comment|/**< Performance Counter#0 Cluster DTE Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster's DTE# for all events                                                          associated with Performance Counter#0. */
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
comment|/**< Performance Counter#0 Cluster Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster# for all events                                                          associated with Performance Counter#0. */
else|#
directive|else
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc0_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc0_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc0_ctl
name|cvmx_dfa_pfc0_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc1_cnt  *  * DFA_PFC1_CNT = DFA Performance Counter \#1  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc1_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc1_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pfcnt1
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter \#1                                                          When DFA_PFC_GCTL[CNT1ENA]=1, the event selected                                                          by DFA_PFC1_CTL[EVSEL] is counted.                                                          See also DFA_PFC_GCTL[CNT1WCLR] and DFA_PFC_GCTL                                                          [CNT1RCLR] for special clear count cases available                                                          for SW data collection. */
else|#
directive|else
name|uint64_t
name|pfcnt1
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc1_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_cnt_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc1_cnt
name|cvmx_dfa_pfc1_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc1_ctl  *  * DFA_PFC1_CTL = DFA Performance Counter#1 Control  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc1_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc1_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter#1 Event Selector                                                          - 0:  \#Cycles                                                          - 1:  \#LDNODE visits                                                          - 2:  \#SDNODE visits                                                          - 3:  \#DNODE visits (LD/SD)                                                          - 4:  \#LCNODE visits                                                          - 5:  \#SCNODE visits                                                          - 6:  \#CNODE visits (LC/SC)                                                          - 7:  \#LMNODE visits                                                          - 8:  \#SMNODE visits                                                          - 9:  \#MNODE visits (LM/SM)                                                           - 10: \#MONODE visits                                                           - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX                                                           - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)                                                           - 13: \#MEMORY visits (MNODE+MONODE)                                                           - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)                                                           - 15: \#MPHIDX detected (occur for ->LMNODE transitions)                                                           - 16: \#RESCANs detected (occur when HASH collision is detected)                                                           - 17: \#GWALK STALLs detected - Packet data/Result Buffer                                                           - 18: \#GWALK DTE cycles (all DTE-GNT[3a])                                                           - 19: \#CLOAD DTE cycles                                                           - 20: \#MLOAD DTE cycles                                                           - 21: \#cycles waiting for Memory Response Data                                                           - 22: \#cycles waiting in resource stall state (waiting for packet data or result buffer space)                                                           - 23: \#cycles waiting in resource pending state                                                           - 24: \#RWORD1+ writes                                                           - 25: \#DTE-VLD cycles                                                           - 26: \#DTE Transitions detected (see DFA_PFC_GCTL[SNODE,ENODE] registers                                                           - 27: \#GWALK Instructions                                                           - 28: \#CLOAD Instructions                                                           - 29: \#MLOAD Instructions                                                           - 30: \#GFREE Instructions (== \#GFREE DTE cycles)                                                           - 31: RESERVED                                                           - 32: \#DTE-Busy cycles (ALL DTE-GNT strobes) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
comment|/**< Performance Counter#1 Cluster DTE Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster's DTE# for all events                                                          associated with Performance Counter#1. */
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
comment|/**< Performance Counter#1 Cluster Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster# for all events                                                          associated with Performance Counter#1. */
else|#
directive|else
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc1_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc1_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc1_ctl
name|cvmx_dfa_pfc1_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc2_cnt  *  * DFA_PFC2_CNT = DFA Performance Counter \#2  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc2_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc2_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pfcnt2
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter \#2                                                          When DFA_PFC_GCTL[CNT2ENA]=1, the event selected                                                          by DFA_PFC2_CTL[EVSEL] is counted.                                                          See also DFA_PFC_GCTL[CNT2WCLR] and DFA_PFC_GCTL                                                          [CNT2RCLR] for special clear count cases available                                                          for SW data collection. */
else|#
directive|else
name|uint64_t
name|pfcnt2
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc2_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_cnt_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc2_cnt
name|cvmx_dfa_pfc2_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc2_ctl  *  * DFA_PFC2_CTL = DFA Performance Counter#2 Control  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc2_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc2_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter#2 Event Selector                                                          - 0:  \#Cycles                                                          - 1:  \#LDNODE visits                                                          - 2:  \#SDNODE visits                                                          - 3:  \#DNODE visits (LD/SD)                                                          - 4:  \#LCNODE visits                                                          - 5:  \#SCNODE visits                                                          - 6:  \#CNODE visits (LC/SC)                                                          - 7:  \#LMNODE visits                                                          - 8:  \#SMNODE visits                                                          - 9:  \#MNODE visits (LM/SM)                                                           - 10: \#MONODE visits                                                           - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX                                                           - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)                                                           - 13: \#MEMORY visits (MNODE+MONODE)                                                           - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)                                                           - 15: \#MPHIDX detected (occur for ->LMNODE transitions)                                                           - 16: \#RESCANs detected (occur when HASH collision is detected)                                                           - 17: \#GWALK STALLs detected - Packet data/Result Buffer                                                           - 18: \#GWALK DTE cycles (all DTE-GNT[3a])                                                           - 19: \#CLOAD DTE cycles                                                           - 20: \#MLOAD DTE cycles                                                           - 21: \#cycles waiting for Memory Response Data                                                           - 22: \#cycles waiting in resource stall state (waiting for packet data or result buffer space)                                                           - 23: \#cycles waiting in resource pending state                                                           - 24: \#RWORD1+ writes                                                           - 25: \#DTE-VLD cycles                                                           - 26: \#DTE Transitions detected (see DFA_PFC_GCTL[SNODE,ENODE] registers                                                           - 27: \#GWALK Instructions                                                           - 28: \#CLOAD Instructions                                                           - 29: \#MLOAD Instructions                                                           - 30: \#GFREE Instructions (== \#GFREE DTE cycles)                                                           - 31: RESERVED                                                           - 32: \#DTE-Busy cycles (ALL DTE-GNT strobes) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
comment|/**< Performance Counter#2 Cluster DTE Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster's DTE# for all events                                                          associated with Performance Counter#2. */
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
comment|/**< Performance Counter#2 Cluster Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster# for all events                                                          associated with Performance Counter#2. */
else|#
directive|else
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc2_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc2_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc2_ctl
name|cvmx_dfa_pfc2_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc3_cnt  *  * DFA_PFC3_CNT = DFA Performance Counter \#3  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc3_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc3_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pfcnt3
range|:
literal|64
decl_stmt|;
comment|/**< Performance Counter \#3                                                          When DFA_PFC_GCTL[CNT3ENA]=1, the event selected                                                          by DFA_PFC3_CTL[EVSEL] is counted.                                                          See also DFA_PFC_GCTL[CNT3WCLR] and DFA_PFC_GCTL                                                          [CNT3RCLR] for special clear count cases available                                                          for SW data collection. */
else|#
directive|else
name|uint64_t
name|pfcnt3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc3_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_cnt_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc3_cnt
name|cvmx_dfa_pfc3_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc3_ctl  *  * DFA_PFC3_CTL = DFA Performance Counter#3 Control  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc3_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc3_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter#3 Event Selector                                                          - 0:  \#Cycles                                                          - 1:  \#LDNODE visits                                                          - 2:  \#SDNODE visits                                                          - 3:  \#DNODE visits (LD/SD)                                                          - 4:  \#LCNODE visits                                                          - 5:  \#SCNODE visits                                                          - 6:  \#CNODE visits (LC/SC)                                                          - 7:  \#LMNODE visits                                                          - 8:  \#SMNODE visits                                                          - 9:  \#MNODE visits (LM/SM)                                                           - 10: \#MONODE visits                                                           - 11: \#CACHE visits (DNODE,CNODE) exc: CNDRD,MPHIDX                                                           - 12: \#CACHE visits (DNODE,CNODE)+(CNDRD,MPHIDX)                                                           - 13: \#MEMORY visits (MNODE+MONODE)                                                           - 14: \#CNDRDs detected (occur for SCNODE->*MNODE transitions)                                                           - 15: \#MPHIDX detected (occur for ->LMNODE transitions)                                                           - 16: \#RESCANs detected (occur when HASH collision is detected)                                                           - 17: \#GWALK STALLs detected - Packet data/Result Buffer                                                           - 18: \#GWALK DTE cycles (all DTE-GNT[3a])                                                           - 19: \#CLOAD DTE cycles                                                           - 20: \#MLOAD DTE cycles                                                           - 21: \#cycles waiting for Memory Response Data                                                           - 22: \#cycles waiting in resource stall state (waiting for packet data or result buffer space)                                                           - 23: \#cycles waiting in resource pending state                                                           - 24: \#RWORD1+ writes                                                           - 25: \#DTE-VLD cycles                                                           - 26: \#DTE Transitions detected (see DFA_PFC_GCTL[SNODE,ENODE] registers                                                           - 27: \#GWALK Instructions                                                           - 28: \#CLOAD Instructions                                                           - 29: \#MLOAD Instructions                                                           - 30: \#GFREE Instructions (== \#GFREE DTE cycles)                                                           - 31: RESERVED                                                           - 32: \#DTE-Busy cycles (ALL DTE-GNT strobes) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
comment|/**< Performance Counter#3 Cluster DTE Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster's DTE# for all events                                                          associated with Performance Counter#3. */
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
comment|/**< Performance Counter#3 Cluster Selector                                                          When DFA_PFC_GCTL[PMODE]=0 (per-cluster DTE), this field                                                          is used to select/monitor the cluster# for all events                                                          associated with Performance Counter#3. */
else|#
directive|else
name|uint64_t
name|clnum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cldte
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|evsel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc3_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc3_ctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc3_ctl
name|cvmx_dfa_pfc3_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_pfc_gctl  *  * DFA_PFC_GCTL = DFA Performance Counter Global Control  * *FOR INTERNAL USE ONLY*  * Description:  */
end_comment

begin_union
union|union
name|cvmx_dfa_pfc_gctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_pfc_gctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|vgid
range|:
literal|8
decl_stmt|;
comment|/**< Virtual Graph Id#                                                          When PMODE=1(per-graph selector), this field is used                                                          to select/monitor only those events which are                                                          associated with this selected VGID(virtual graph ID).                                                          This field is used globally across all four performance                                                          counters.                                                          IMPNOTE: I implemented a global VGID across all 4 performance                                                          counters to save wires/area. */
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
comment|/**< Select Mode                                                          - 0: Events are selected on a per-cluster DTE# (CLNUM/CLDTE)                                                           DFA_PFCx_CTL[CLNUM,CLDTE] specifies the cluster-DTE for                                                           each 1(of 4) performance counters.                                                          - 1: Events are selected on a per-graph basis (VGID=virtual Graph ID).                                                           NOTE: Only EVSEL=[0...31] can be used in conjunction with PMODE=1.                                                           DFA_PFC_GCTL[VGID] specifies the Virtual graph ID used across                                                           all four performance counters. */
name|uint64_t
name|ednode
range|:
literal|2
decl_stmt|;
comment|/**< Ending DNODE Selector                                                          When ENODE=0/1(*DNODE), this field is used to further                                                          specify the Ending DNODE transition sub-type:                                                            - 0: ALL DNODE sub-types                                                            - 1: ->D2e (explicit DNODE transition node-arc alone transitions to DNODE)                                                            - 2: ->D2i (implicit DNODE transition:arc-present triggers transition)                                                            - 3: ->D1r (rescan DNODE transition) */
name|uint64_t
name|enode
range|:
literal|3
decl_stmt|;
comment|/**< Ending Node Selector                                                          When DFA_PFCx_CTL[EVSEL]=Node Transition(31), the ENODE                                                          field is used to select Ending Node, and the SNODE                                                          field is used to select the Starting Node.                                                           - 0: LDNODE                                                           - 1: SDNODE                                                           - 2: LCNODE                                                           - 3: SCNODE                                                           - 4: LMNODE                                                           - 5: SMNODE                                                           - 6: MONODE                                                           - 7: RESERVED */
name|uint64_t
name|snode
range|:
literal|3
decl_stmt|;
comment|/**< Starting Node Selector                                                          When DFA_PFCx_CTL[EVSEL]=Node Transition(31), the SNODE                                                          field is used to select Starting Node, and the ENODE                                                          field is used to select the Ending Node.                                                           - 0: LDNODE                                                           - 1: SDNODE                                                           - 2: LCNODE                                                           - 3: SCNODE                                                           - 4: LMNODE                                                           - 5: SMNODE                                                           - 6: MONODE                                                           - 7: RESERVED */
name|uint64_t
name|cnt3rclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#3 Read Clear                                                          If this bit is set, CSR reads to the DFA_PFC3_CNT                                                          will clear the count value. This allows SW to maintain                                                          'cumulative' counters to avoid HW wraparound. */
name|uint64_t
name|cnt2rclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#2 Read Clear                                                          If this bit is set, CSR reads to the DFA_PFC2_CNT                                                          will clear the count value. This allows SW to maintain                                                          'cumulative' counters to avoid HW wraparound. */
name|uint64_t
name|cnt1rclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#1 Read Clear                                                          If this bit is set, CSR reads to the DFA_PFC1_CNT                                                          will clear the count value. This allows SW to maintain                                                          'cumulative' counters to avoid HW wraparound. */
name|uint64_t
name|cnt0rclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#0 Read Clear                                                          If this bit is set, CSR reads to the DFA_PFC0_CNT                                                          will clear the count value. This allows SW to maintain                                                          'cumulative' counters to avoid HW wraparound. */
name|uint64_t
name|cnt3wclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#3 Write Clear                                                          If this bit is set, CSR writes to the DFA_PFC3_CNT                                                          will clear the count value.                                                          If this bit is clear, CSR writes to the DFA_PFC3_CNT                                                          will continue the count from the written value. */
name|uint64_t
name|cnt2wclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#2 Write Clear                                                          If this bit is set, CSR writes to the DFA_PFC2_CNT                                                          will clear the count value.                                                          If this bit is clear, CSR writes to the DFA_PFC2_CNT                                                          will continue the count from the written value. */
name|uint64_t
name|cnt1wclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#1 Write Clear                                                          If this bit is set, CSR writes to the DFA_PFC1_CNT                                                          will clear the count value.                                                          If this bit is clear, CSR writes to the DFA_PFC1_CNT                                                          will continue the count from the written value. */
name|uint64_t
name|cnt0wclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter \#0 Write Clear                                                          If this bit is set, CSR writes to the DFA_PFC0_CNT                                                          will clear the count value.                                                          If this bit is clear, CSR writes to the DFA_PFC0_CNT                                                          will continue the count from the written value. */
name|uint64_t
name|cnt3ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 3 Enable                                                          When this bit is set, the performance counter \#3                                                          is enabled. */
name|uint64_t
name|cnt2ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 2 Enable                                                          When this bit is set, the performance counter \#2                                                          is enabled. */
name|uint64_t
name|cnt1ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 1 Enable                                                          When this bit is set, the performance counter \#1                                                          is enabled. */
name|uint64_t
name|cnt0ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 0 Enable                                                          When this bit is set, the performance counter \#0                                                          is enabled. */
else|#
directive|else
name|uint64_t
name|cnt0ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt1ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt2ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt3ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt0wclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt1wclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt2wclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt3wclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt0rclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt1rclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt2rclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt3rclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|snode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|enode
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ednode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vgid
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_pfc_gctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc_gctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc_gctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_dfa_pfc_gctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc_gctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_dfa_pfc_gctl_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_pfc_gctl
name|cvmx_dfa_pfc_gctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_rodt_comp_ctl  *  * DFA_RODT_COMP_CTL = DFA RLD Compensation control (For read "on die termination")  *  */
end_comment

begin_union
union|union
name|cvmx_dfa_rodt_comp_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_rodt_comp_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Read On Die Termination Enable                                                          (0=disable, 1=enable) */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< Compensation control bits */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< Compensation control bits */
else|#
directive|else
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_rodt_comp_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_rodt_comp_ctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_rodt_comp_ctl
name|cvmx_dfa_rodt_comp_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_sbd_dbg0  *  * DFA_SBD_DBG0 = DFA Scoreboard Debug \#0 Register  *  * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_sbd_dbg0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_sbd_dbg0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd0
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#0 Data                                                          For internal use only! (DFA Scoreboard Debug)                                                          [63:40] rptr[26:3]: Result Base Pointer                                                          [39:24] rwcnt[15:0] Cumulative Result Write Counter                                                          [23]    lastgrdrsp: Last Gather-Rd Response                                                          [22]    wtgrdrsp: Waiting Gather-Rd Response                                                          [21]    wtgrdreq: Waiting for Gather-Rd Issue                                                          [20]    glvld: GLPTR/GLCNT Valid                                                          [19]    cmpmark: Completion Marked Node Detected                                                          [18:17] cmpcode[1:0]: Completion Code                                                                        [0=PDGONE/1=PERR/2=RFULL/3=TERM]                                                          [16]    cmpdet: Completion Detected                                                          [15]    wthdrwrcmtrsp: Waiting for HDR RWrCmtRsp                                                          [14]    wtlastwrcmtrsp: Waiting for LAST RESULT                                                                        RWrCmtRsp                                                          [13]    hdrwrreq: Waiting for HDR RWrReq                                                          [12]    wtrwrreq: Waiting for RWrReq                                                          [11]    wtwqwrreq: Waiting for WQWrReq issue                                                          [10]    lastprdrspeot: Last Packet-Rd Response                                                          [9]     lastprdrsp: Last Packet-Rd Response                                                          [8]     wtprdrsp:  Waiting for PRdRsp EOT                                                          [7]     wtprdreq: Waiting for PRdReq Issue                                                          [6]     lastpdvld: PDPTR/PDLEN Valid                                                          [5]     pdvld: Packet Data Valid                                                          [4]     wqvld: WQVLD                                                          [3]     wqdone: WorkQueue Done condition                                                                        a) WQWrReq issued(for WQPTR<>0) OR                                                                        b) HDR RWrCmtRsp completed)                                                          [2]     rwstf: Resultant write STF/P Mode                                                          [1]     pdldt: Packet-Data LDT mode                                                          [0]     gmode: Gather-Mode */
else|#
directive|else
name|uint64_t
name|sbd0
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_sbd_dbg0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_sbd_dbg0
name|cvmx_dfa_sbd_dbg0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_sbd_dbg1  *  * DFA_SBD_DBG1 = DFA Scoreboard Debug \#1 Register  *  * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_sbd_dbg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_sbd_dbg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd1
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#1 Data                                                          For internal use only! (DFA Scoreboard Debug)                                                          [63:61] wqptr[35:33]: Work Queue Pointer                                                          [60:52] rptr[35:27]: Result Base Pointer                                                          [51:16] pdptr[35:0]: Packet Data Pointer                                                          [15:0]  pdcnt[15:0]: Packet Data Counter */
else|#
directive|else
name|uint64_t
name|sbd1
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_sbd_dbg1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_sbd_dbg1
name|cvmx_dfa_sbd_dbg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_sbd_dbg2  *  * DFA_SBD_DBG2 = DFA Scoreboard Debug \#2 Register  *  * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_sbd_dbg2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_sbd_dbg2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd2
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#2 Data                                                          [63:49] wqptr[17:3]: Work Queue Pointer                                                          [48:16] rwptr[35:3]: Result Write Pointer                                                          [15:0]  prwcnt[15:0]: Pending Result Write Counter */
else|#
directive|else
name|uint64_t
name|sbd2
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_sbd_dbg2_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_sbd_dbg2
name|cvmx_dfa_sbd_dbg2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_dfa_sbd_dbg3  *  * DFA_SBD_DBG3 = DFA Scoreboard Debug \#3 Register  *  * Description: When the DFA_NCBCTL[SBDLCK] bit is written '1', the contents of this register are locked down.  * Otherwise, the contents of this register are the 'active' contents of the DFA Scoreboard at the time of the  * CSR read.  * VERIFICATION NOTE: Read data is unsafe. X's(undefined data) can propagate (in the behavioral model)  * on the reads unless the DTE Engine specified by DFA_NCBCTL[SBDNUM] has previously been assigned an  * instruction.  */
end_comment

begin_union
union|union
name|cvmx_dfa_sbd_dbg3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_dfa_sbd_dbg3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|sbd3
range|:
literal|64
decl_stmt|;
comment|/**< DFA ScoreBoard \#3 Data                                                          [63:49] wqptr[32:18]: Work Queue Pointer                                                          [48:16] glptr[35:3]: Gather List Pointer                                                          [15:0]  glcnt[15:0]: Gather List Counter */
else|#
directive|else
name|uint64_t
name|sbd3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_dfa_sbd_dbg3_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg3_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg3_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_dfa_sbd_dbg3_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_dfa_sbd_dbg3
name|cvmx_dfa_sbd_dbg3_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

