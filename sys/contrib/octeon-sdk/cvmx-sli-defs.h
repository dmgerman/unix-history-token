begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-sli-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon sli.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SLI_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SLI_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_BIST_STATUS
value|CVMX_SLI_BIST_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_BIST_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_BIST_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000580ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_BIST_STATUS
value|(0x0000000000000580ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_CTL_PORTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_CTL_PORTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000050ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_CTL_PORTX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000050ull + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_CTL_STATUS
value|CVMX_SLI_CTL_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_CTL_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_CTL_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000570ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_CTL_STATUS
value|(0x0000000000000570ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_DATA_OUT_CNT
value|CVMX_SLI_DATA_OUT_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_DATA_OUT_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_DATA_OUT_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000005F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_DATA_OUT_CNT
value|(0x00000000000005F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_DBG_DATA
value|CVMX_SLI_DBG_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_DBG_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_DBG_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000310ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_DBG_DATA
value|(0x0000000000000310ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_DBG_SELECT
value|CVMX_SLI_DBG_SELECT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_DBG_SELECT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_DBG_SELECT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000300ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_DBG_SELECT
value|(0x0000000000000300ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_DMAX_CNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_DMAX_CNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_DMAX_CNT
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000400ull + ((offset)& 1) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_DMAX_INT_LEVEL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_DMAX_INT_LEVEL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000003E0ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_DMAX_INT_LEVEL
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000003E0ull + ((offset)& 1) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_DMAX_TIM
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_DMAX_TIM(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000420ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_DMAX_TIM
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000420ull + ((offset)& 1) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_INT_ENB_CIU
value|CVMX_SLI_INT_ENB_CIU_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_INT_ENB_CIU_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_INT_ENB_CIU not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CD0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_INT_ENB_CIU
value|(0x0000000000003CD0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_INT_ENB_PORTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_INT_ENB_PORTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000340ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_INT_ENB_PORTX
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000340ull + ((offset)& 1) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_INT_SUM
value|CVMX_SLI_INT_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_INT_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_INT_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000330ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_INT_SUM
value|(0x0000000000000330ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA0
value|CVMX_SLI_LAST_WIN_RDATA0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_LAST_WIN_RDATA0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_LAST_WIN_RDATA0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000600ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA0
value|(0x0000000000000600ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA1
value|CVMX_SLI_LAST_WIN_RDATA1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_LAST_WIN_RDATA1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_LAST_WIN_RDATA1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000610ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA1
value|(0x0000000000000610ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA2
value|CVMX_SLI_LAST_WIN_RDATA2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_LAST_WIN_RDATA2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_LAST_WIN_RDATA2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000006C0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA2
value|(0x00000000000006C0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA3
value|CVMX_SLI_LAST_WIN_RDATA3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_LAST_WIN_RDATA3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_LAST_WIN_RDATA3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000006D0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_LAST_WIN_RDATA3
value|(0x00000000000006D0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MAC_CREDIT_CNT
value|CVMX_SLI_MAC_CREDIT_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MAC_CREDIT_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MAC_CREDIT_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D70ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MAC_CREDIT_CNT
value|(0x0000000000003D70ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MAC_CREDIT_CNT2
value|CVMX_SLI_MAC_CREDIT_CNT2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MAC_CREDIT_CNT2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MAC_CREDIT_CNT2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003E10ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MAC_CREDIT_CNT2
value|(0x0000000000003E10ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MAC_NUMBER
value|CVMX_SLI_MAC_NUMBER_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MAC_NUMBER_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MAC_NUMBER not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003E00ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MAC_NUMBER
value|(0x0000000000003E00ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MEM_ACCESS_CTL
value|CVMX_SLI_MEM_ACCESS_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MEM_ACCESS_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MEM_ACCESS_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000002F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MEM_ACCESS_CTL
value|(0x00000000000002F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MEM_ACCESS_SUBIDX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|12
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|27
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MEM_ACCESS_SUBIDX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000000E0ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
operator|-
literal|16
operator|*
literal|12
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MEM_ACCESS_SUBIDX
parameter_list|(
name|offset
parameter_list|)
value|(0x00000000000000E0ull + ((offset)& 31) * 16 - 16*12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB0
value|CVMX_SLI_MSI_ENB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_ENB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_ENB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C50ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB0
value|(0x0000000000003C50ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB1
value|CVMX_SLI_MSI_ENB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_ENB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_ENB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C60ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB1
value|(0x0000000000003C60ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB2
value|CVMX_SLI_MSI_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C70ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB2
value|(0x0000000000003C70ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB3
value|CVMX_SLI_MSI_ENB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_ENB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_ENB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C80ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_ENB3
value|(0x0000000000003C80ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV0
value|CVMX_SLI_MSI_RCV0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_RCV0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_RCV0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C10ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV0
value|(0x0000000000003C10ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV1
value|CVMX_SLI_MSI_RCV1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_RCV1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_RCV1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C20ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV1
value|(0x0000000000003C20ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV2
value|CVMX_SLI_MSI_RCV2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_RCV2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_RCV2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C30ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV2
value|(0x0000000000003C30ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV3
value|CVMX_SLI_MSI_RCV3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_RCV3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_RCV3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C40ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RCV3
value|(0x0000000000003C40ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RD_MAP
value|CVMX_SLI_MSI_RD_MAP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_RD_MAP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_RD_MAP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CA0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_RD_MAP
value|(0x0000000000003CA0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB0
value|CVMX_SLI_MSI_W1C_ENB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1C_ENB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1C_ENB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CF0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB0
value|(0x0000000000003CF0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB1
value|CVMX_SLI_MSI_W1C_ENB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1C_ENB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1C_ENB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D00ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB1
value|(0x0000000000003D00ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB2
value|CVMX_SLI_MSI_W1C_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1C_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1C_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D10ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB2
value|(0x0000000000003D10ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB3
value|CVMX_SLI_MSI_W1C_ENB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1C_ENB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1C_ENB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D20ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1C_ENB3
value|(0x0000000000003D20ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB0
value|CVMX_SLI_MSI_W1S_ENB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1S_ENB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1S_ENB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D30ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB0
value|(0x0000000000003D30ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB1
value|CVMX_SLI_MSI_W1S_ENB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1S_ENB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1S_ENB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D40ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB1
value|(0x0000000000003D40ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB2
value|CVMX_SLI_MSI_W1S_ENB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1S_ENB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1S_ENB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D50ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB2
value|(0x0000000000003D50ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB3
value|CVMX_SLI_MSI_W1S_ENB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_W1S_ENB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_W1S_ENB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D60ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_W1S_ENB3
value|(0x0000000000003D60ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_WR_MAP
value|CVMX_SLI_MSI_WR_MAP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_MSI_WR_MAP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_MSI_WR_MAP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003C90ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_MSI_WR_MAP
value|(0x0000000000003C90ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV
value|CVMX_SLI_PCIE_MSI_RCV_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PCIE_MSI_RCV_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PCIE_MSI_RCV not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003CB0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV
value|(0x0000000000003CB0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV_B1
value|CVMX_SLI_PCIE_MSI_RCV_B1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PCIE_MSI_RCV_B1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PCIE_MSI_RCV_B1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000650ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV_B1
value|(0x0000000000000650ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV_B2
value|CVMX_SLI_PCIE_MSI_RCV_B2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PCIE_MSI_RCV_B2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PCIE_MSI_RCV_B2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000660ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV_B2
value|(0x0000000000000660ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV_B3
value|CVMX_SLI_PCIE_MSI_RCV_B3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PCIE_MSI_RCV_B3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PCIE_MSI_RCV_B3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000670ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PCIE_MSI_RCV_B3
value|(0x0000000000000670ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_CNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_CNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_CNTS
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002400ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_INSTR_BADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_INSTR_BADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_INSTR_BADDR
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_INSTR_BAOFF_DBELL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_INSTR_BAOFF_DBELL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002C00ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_INSTR_BAOFF_DBELL
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002C00ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_INSTR_FIFO_RSIZE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_INSTR_FIFO_RSIZE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003000ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_INSTR_FIFO_RSIZE
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003000ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_INSTR_HEADER
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_INSTR_HEADER(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_INSTR_HEADER
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003400ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_IN_BP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_IN_BP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_IN_BP
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_OUT_SIZE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_OUT_SIZE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000C00ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_OUT_SIZE
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000C00ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_SLIST_BADDR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_SLIST_BADDR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001400ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_SLIST_BADDR
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000001400ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_SLIST_BAOFF_DBELL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_SLIST_BAOFF_DBELL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_SLIST_BAOFF_DBELL
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000001800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKTX_SLIST_FIFO_RSIZE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKTX_SLIST_FIFO_RSIZE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001C00ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKTX_SLIST_FIFO_RSIZE
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000001C00ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_CNT_INT
value|CVMX_SLI_PKT_CNT_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_CNT_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_CNT_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001130ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_CNT_INT
value|(0x0000000000001130ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_CNT_INT_ENB
value|CVMX_SLI_PKT_CNT_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_CNT_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_CNT_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001150ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_CNT_INT_ENB
value|(0x0000000000001150ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_CTL
value|CVMX_SLI_PKT_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001220ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_CTL
value|(0x0000000000001220ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DATA_OUT_ES
value|CVMX_SLI_PKT_DATA_OUT_ES_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_DATA_OUT_ES_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_DATA_OUT_ES not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DATA_OUT_ES
value|(0x00000000000010B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DATA_OUT_NS
value|CVMX_SLI_PKT_DATA_OUT_NS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_DATA_OUT_NS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_DATA_OUT_NS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DATA_OUT_NS
value|(0x00000000000010A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DATA_OUT_ROR
value|CVMX_SLI_PKT_DATA_OUT_ROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_DATA_OUT_ROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_DATA_OUT_ROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001090ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DATA_OUT_ROR
value|(0x0000000000001090ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DPADDR
value|CVMX_SLI_PKT_DPADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_DPADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_DPADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001080ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_DPADDR
value|(0x0000000000001080ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INPUT_CONTROL
value|CVMX_SLI_PKT_INPUT_CONTROL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_INPUT_CONTROL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_INPUT_CONTROL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001170ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INPUT_CONTROL
value|(0x0000000000001170ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INSTR_ENB
value|CVMX_SLI_PKT_INSTR_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_INSTR_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_INSTR_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INSTR_ENB
value|(0x0000000000001000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INSTR_RD_SIZE
value|CVMX_SLI_PKT_INSTR_RD_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_INSTR_RD_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_INSTR_RD_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000011A0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INSTR_RD_SIZE
value|(0x00000000000011A0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INSTR_SIZE
value|CVMX_SLI_PKT_INSTR_SIZE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_INSTR_SIZE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_INSTR_SIZE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INSTR_SIZE
value|(0x0000000000001020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INT_LEVELS
value|CVMX_SLI_PKT_INT_LEVELS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_INT_LEVELS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_INT_LEVELS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001120ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_INT_LEVELS
value|(0x0000000000001120ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_BP
value|CVMX_SLI_PKT_IN_BP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_IN_BP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_IN_BP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001210ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_BP
value|(0x0000000000001210ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_IN_DONEX_CNTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_IN_DONEX_CNTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000002000ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_DONEX_CNTS
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000002000ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_INSTR_COUNTS
value|CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_IN_INSTR_COUNTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_IN_INSTR_COUNTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001200ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_INSTR_COUNTS
value|(0x0000000000001200ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_PCIE_PORT
value|CVMX_SLI_PKT_IN_PCIE_PORT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_IN_PCIE_PORT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_IN_PCIE_PORT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000011B0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IN_PCIE_PORT
value|(0x00000000000011B0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IPTR
value|CVMX_SLI_PKT_IPTR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_IPTR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_IPTR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001070ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_IPTR
value|(0x0000000000001070ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUTPUT_WMARK
value|CVMX_SLI_PKT_OUTPUT_WMARK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_OUTPUT_WMARK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_OUTPUT_WMARK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001180ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUTPUT_WMARK
value|(0x0000000000001180ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUT_BMODE
value|CVMX_SLI_PKT_OUT_BMODE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_OUT_BMODE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_OUT_BMODE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010D0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUT_BMODE
value|(0x00000000000010D0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUT_BP_EN
value|CVMX_SLI_PKT_OUT_BP_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_OUT_BP_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_OUT_BP_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001240ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUT_BP_EN
value|(0x0000000000001240ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUT_ENB
value|CVMX_SLI_PKT_OUT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_OUT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_OUT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_OUT_ENB
value|(0x0000000000001010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_PCIE_PORT
value|CVMX_SLI_PKT_PCIE_PORT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_PCIE_PORT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_PCIE_PORT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000010E0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_PCIE_PORT
value|(0x00000000000010E0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_PORT_IN_RST
value|CVMX_SLI_PKT_PORT_IN_RST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_PORT_IN_RST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_PORT_IN_RST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000011F0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_PORT_IN_RST
value|(0x00000000000011F0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_SLIST_ES
value|CVMX_SLI_PKT_SLIST_ES_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_SLIST_ES_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_SLIST_ES not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001050ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_SLIST_ES
value|(0x0000000000001050ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_SLIST_NS
value|CVMX_SLI_PKT_SLIST_NS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_SLIST_NS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_SLIST_NS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001040ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_SLIST_NS
value|(0x0000000000001040ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_SLIST_ROR
value|CVMX_SLI_PKT_SLIST_ROR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_SLIST_ROR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_SLIST_ROR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001030ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_SLIST_ROR
value|(0x0000000000001030ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_TIME_INT
value|CVMX_SLI_PKT_TIME_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_TIME_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_TIME_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001140ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_TIME_INT
value|(0x0000000000001140ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_TIME_INT_ENB
value|CVMX_SLI_PKT_TIME_INT_ENB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PKT_TIME_INT_ENB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PKT_TIME_INT_ENB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001160ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PKT_TIME_INT_ENB
value|(0x0000000000001160ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_PORTX_PKIND
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_PORTX_PKIND(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000800ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_PORTX_PKIND
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000000800ull + ((offset)& 31) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_S2M_PORTX_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_S2M_PORTX_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000003D80ull
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_S2M_PORTX_CTL
parameter_list|(
name|offset
parameter_list|)
value|(0x0000000000003D80ull + ((offset)& 3) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_SCRATCH_1
value|CVMX_SLI_SCRATCH_1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_SCRATCH_1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_SCRATCH_1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000003C0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_SCRATCH_1
value|(0x00000000000003C0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_SCRATCH_2
value|CVMX_SLI_SCRATCH_2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_SCRATCH_2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_SCRATCH_2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000003D0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_SCRATCH_2
value|(0x00000000000003D0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_STATE1
value|CVMX_SLI_STATE1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_STATE1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_STATE1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000620ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_STATE1
value|(0x0000000000000620ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_STATE2
value|CVMX_SLI_STATE2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_STATE2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_STATE2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000630ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_STATE2
value|(0x0000000000000630ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_STATE3
value|CVMX_SLI_STATE3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_STATE3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_STATE3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000640ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_STATE3
value|(0x0000000000000640ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_TX_PIPE
value|CVMX_SLI_TX_PIPE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_TX_PIPE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_TX_PIPE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000001230ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_TX_PIPE
value|(0x0000000000001230ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_WINDOW_CTL
value|CVMX_SLI_WINDOW_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_WINDOW_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_WINDOW_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x00000000000002E0ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_WINDOW_CTL
value|(0x00000000000002E0ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_RD_ADDR
value|CVMX_SLI_WIN_RD_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_WIN_RD_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_WIN_RD_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000010ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_RD_ADDR
value|(0x0000000000000010ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_RD_DATA
value|CVMX_SLI_WIN_RD_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_WIN_RD_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_WIN_RD_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000040ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_RD_DATA
value|(0x0000000000000040ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_WR_ADDR
value|CVMX_SLI_WIN_WR_ADDR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_WIN_WR_ADDR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_WIN_WR_ADDR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_WR_ADDR
value|(0x0000000000000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_WR_DATA
value|CVMX_SLI_WIN_WR_DATA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_WIN_WR_DATA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_WIN_WR_DATA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000020ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_WR_DATA
value|(0x0000000000000020ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_WR_MASK
value|CVMX_SLI_WIN_WR_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SLI_WIN_WR_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SLI_WIN_WR_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
literal|0x0000000000000030ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SLI_WIN_WR_MASK
value|(0x0000000000000030ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_sli_bist_status  *  * SLI_BIST_STATUS = SLI's BIST Status Register  *  * Results from BIST runs of SLI's memories.  */
end_comment

begin_union
union|union
name|cvmx_sli_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_bist_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ncb_req
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Request FIFO */
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Cmd */
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Data */
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dsi1_1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI1 Memory 1 */
name|uint64_t
name|dsi1_0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI1 Memory 0 */
name|uint64_t
name|dsi0_1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI0 Memory 1 */
name|uint64_t
name|dsi0_0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI0 Memory 0 */
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi0_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi1_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncb_req
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_bist_status_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|reserved_27_28
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dsi1_1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI1 Memory 1 */
name|uint64_t
name|dsi1_0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI1 Memory 0 */
name|uint64_t
name|dsi0_1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI0 Memory 1 */
name|uint64_t
name|dsi0_0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI0 Memory 0 */
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi0_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi1_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_28
range|:
literal|2
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_sli_bist_status_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Cmd */
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port0 Data */
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Cmd */
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for N2P Port1 Data */
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 0 */
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for CPL Port 1 */
name|uint64_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C0 */
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 C1 */
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 N */
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P0 */
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port0 P1 */
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C0 */
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 C1 */
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 N */
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P0 */
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for P2N Port1 P1 */
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dsi1_1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI1 Memory 1 */
name|uint64_t
name|dsi1_0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI1 Memory 0 */
name|uint64_t
name|dsi0_1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI0 Memory 1 */
name|uint64_t
name|dsi0_0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for DSI0 Memory 0 */
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for MSI Memory Map */
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for NCB Outbound Commands */
else|#
directive|else
name|uint64_t
name|ncb_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|msi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi0_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi1_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsi1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_8
range|:
literal|3
decl_stmt|;
name|uint64_t
name|p2n1_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n1_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2n0_c0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_24
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cpl_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p1_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_o
range|:
literal|1
decl_stmt|;
name|uint64_t
name|n2p0_c
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sli_bist_status_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_bist_status_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_bist_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_bist_status_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_bist_status_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_bist_status
name|cvmx_sli_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_ctl_port#  *  * SLI_CTL_PORTX = SLI's Control Port X  *  * Contains control for access for Port0  */
end_comment

begin_union
union|union
name|cvmx_sli_ctl_portx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_ctl_portx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|intd
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intd wire asserted. Before mapping. */
name|uint64_t
name|intc
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intc wire asserted. Before mapping. */
name|uint64_t
name|intb
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Intb wire asserted. Before mapping. */
name|uint64_t
name|inta
range|:
literal|1
decl_stmt|;
comment|/**< When '0' Inta wire asserted. Before mapping. */
name|uint64_t
name|dis_port
range|:
literal|1
decl_stmt|;
comment|/**< When set the output to the MAC is disabled. This                                                          occurs when the MAC reset line transitions from                                                          de-asserted to asserted. Writing a '1' to this                                                          location will clear this condition when the MAC is                                                          no longer in reset and the output to the MAC is at                                                          the begining of a transfer. */
name|uint64_t
name|waitl_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the SLI to wait for a commit                                                          from the L2C before sending additional completions                                                          to the L2C from a MAC.                                                          Set this for more conservative behavior. Clear                                                          this for more aggressive, higher-performance                                                          behavior */
name|uint64_t
name|intd_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTD to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|intc_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTC to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|intb_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTB to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|inta_map
range|:
literal|2
decl_stmt|;
comment|/**< Maps INTA to INTA(00), INTB(01), INTC(10) or                                                          INTD (11). */
name|uint64_t
name|ctlp_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed ordering enable for Completion TLPS. */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_ro
range|:
literal|1
decl_stmt|;
comment|/**< Relaxed ordering enable for Posted TLPS. */
name|uint64_t
name|reserved_1_4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' casues the SLI to wait for a commit                                                          from the L2C before sending additional stores to                                                          the L2C from a MAC.                                                          The SLI will request a commit on the last store                                                          if more than one STORE operation is required on                                                          the NCB.                                                          Most applications will not notice a difference, so                                                          should not set this bit. Setting the bit is more                                                          conservative on ordering, lower performance */
else|#
directive|else
name|uint64_t
name|wait_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptlp_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctlp_ro
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inta_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intb_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intc_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|intd_map
range|:
literal|2
decl_stmt|;
name|uint64_t
name|waitl_com
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dis_port
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inta
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|intd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_ctl_portx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_ctl_portx
name|cvmx_sli_ctl_portx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_ctl_status  *  * SLI_CTL_STATUS = SLI Control Status Register  *  * Contains control and status for SLI. Writes to this register are not ordered with writes/reads to the MAC Memory space.  * To ensure that a write has completed the user must read the register before making an access(i.e. MAC memory space)  * that requires the value of this register to be updated.  */
end_comment

begin_union
union|union
name|cvmx_sli_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_ctl_status_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|p1_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags available for MAC Port1.                                                          In RC mode 1 tag is needed for each outbound TLP                                                          that requires a CPL TLP. In Endpoint mode the                                                          number of tags required for a TLP request is                                                          1 per 64-bytes of CPL data + 1.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags available for outbound TLPs to the                                                          MACS. One tag is needed for each outbound TLP that                                                          requires a CPL TLP.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The chip revision. */
else|#
directive|else
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p1_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_ctl_status_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
comment|/**< Number of tags available for outbound TLPs to the                                                          MACS. One tag is needed for each outbound TLP that                                                          requires a CPL TLP.                                                          This field should only be written as part of                                                          reset sequence, before issuing any reads, CFGs, or                                                          IO transactions from the core(s). */
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
comment|/**< The chip revision. */
else|#
directive|else
name|uint64_t
name|chip_rev
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ntags
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_sli_ctl_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_status_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_ctl_status_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_status_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_ctl_status_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_ctl_status_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_ctl_status
name|cvmx_sli_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_data_out_cnt  *  * SLI_DATA_OUT_CNT = SLI DATA OUT COUNT  *  * The EXEC data out fifo-count and the data unload counter.  */
end_comment

begin_union
union|union
name|cvmx_sli_data_out_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_data_out_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|p1_ucnt
range|:
literal|16
decl_stmt|;
comment|/**< SLI Order-FIFO1 Fifo Unload Count. This counter is                                                          incremented by '1' every time a word is removed                                                          from the Data Out FIFO, whose count is shown in                                                          P1_FCNT. */
name|uint64_t
name|p1_fcnt
range|:
literal|6
decl_stmt|;
comment|/**< SLI Order-FIFO1 Data Out Fifo Count. Number of                                                          address data words to be sent out the Order-FIFO                                                          presently buffered in the FIFO. */
name|uint64_t
name|p0_ucnt
range|:
literal|16
decl_stmt|;
comment|/**< SLI Order-FIFO0 Fifo Unload Count. This counter is                                                          incremented by '1' every time a word is removed                                                          from the Data Out FIFO, whose count is shown in                                                          P0_FCNT. */
name|uint64_t
name|p0_fcnt
range|:
literal|6
decl_stmt|;
comment|/**< SLI Order-FIFO0 Data Out Fifo Count. Number of                                                          address data words to be sent out the Order-FIFO                                                          presently buffered in the FIFO. */
else|#
directive|else
name|uint64_t
name|p0_fcnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p0_ucnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p1_fcnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|p1_ucnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_data_out_cnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_data_out_cnt
name|cvmx_sli_data_out_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_dbg_data  *  * SLI_DBG_DATA = SLI Debug Data Register  *  * Value returned on the debug-data lines from the RSLs  */
end_comment

begin_union
union|union
name|cvmx_sli_dbg_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_dbg_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
comment|/**< Allows changes in the external pins to set the                                                          debug select value. */
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
comment|/**< Value on the debug data lines. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|17
decl_stmt|;
name|uint64_t
name|dsel_ext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_dbg_data_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_data_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_data_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dbg_data_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_data_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_data_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dbg_data_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_dbg_data
name|cvmx_sli_dbg_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_dbg_select  *  * SLI_DBG_SELECT = Debug Select Register  *  * Contains the debug select value last written to the RSLs.  */
end_comment

begin_union
union|union
name|cvmx_sli_dbg_select
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_dbg_select_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|adbg_sel
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the SLI_DBG_DATA[DATA] will only be                                                          loaded when SLI_DBG_DATA[DATA] bit [16] is a '1'.                                                          When the debug data comes from an Async-RSL bit                                                          16 is used to tell that the data present is valid. */
name|uint64_t
name|dbg_sel
range|:
literal|32
decl_stmt|;
comment|/**< When this register is written the RML will write                                                          all "F"s to the previous RTL to disable it from                                                          sending Debug-Data. The RML will then send a write                                                          to the new RSL with the supplied Debug-Select                                                          value. Because it takes time for the new Debug                                                          Select value to take effect and the requested                                                          Debug-Data to return, time is needed to the new                                                          Debug-Data to arrive.  The inititator of the Debug                                                          Select should issue a read to a CSR before reading                                                          the Debug Data (this read could also be to the                                                          SLI_DBG_DATA but the returned value for the first                                                          read will return NS data. */
else|#
directive|else
name|uint64_t
name|dbg_sel
range|:
literal|32
decl_stmt|;
name|uint64_t
name|adbg_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_dbg_select_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_select_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_select_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dbg_select_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_select_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_dbg_select_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dbg_select_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_dbg_select
name|cvmx_sli_dbg_select_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_dma#_cnt  *  * SLI_DMAx_CNT = SLI DMA Count  *  * The DMA Count value.  */
end_comment

begin_union
union|union
name|cvmx_sli_dmax_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_dmax_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< The DMA counter.                                                          Writing this field will cause the written value                                                          to be subtracted from DMA. HW will optionally                                                          increment this field after it completes an                                                          OUTBOUND or EXTERNAL-ONLY DMA instruction. These                                                          increments may cause interrupts. Refer to                                                          SLI_DMAx_INT_LEVEL and SLI_INT_SUM[DCNT,DTIME]. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dmax_cnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_dmax_cnt
name|cvmx_sli_dmax_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_dma#_int_level  *  * SLI_DMAx_INT_LEVEL = SLI DMAx Interrupt Level  *  * Thresholds for DMA count and timer interrupts.  */
end_comment

begin_union
union|union
name|cvmx_sli_dmax_int_level
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_dmax_int_level_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
comment|/**< Whenever the SLI_DMAx_TIM[TIM] timer exceeds                                                          this value, SLI_INT_SUM[DTIME<x>] is set.                                                          The SLI_DMAx_TIM[TIM] timer increments every SLI                                                          clock whenever SLI_DMAx_CNT[CNT]!=0, and is                                                          cleared when SLI_INT_SUM[DTIME<x>] is written with                                                          one. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Whenever SLI_DMAx_CNT[CNT] exceeds this value,                                                          SLI_INT_SUM[DCNT<x>] is set. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dmax_int_level_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_dmax_int_level
name|cvmx_sli_dmax_int_level_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_dma#_tim  *  * SLI_DMAx_TIM = SLI DMA Timer  *  * The DMA Timer value.  */
end_comment

begin_union
union|union
name|cvmx_sli_dmax_tim
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_dmax_tim_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tim
range|:
literal|32
decl_stmt|;
comment|/**< The DMA timer value.                                                          The timer will increment when SLI_DMAx_CNT[CNT]!=0                                                          and will clear when SLI_DMAx_CNT[CNT]==0 */
else|#
directive|else
name|uint64_t
name|tim
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_dmax_tim_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_dmax_tim
name|cvmx_sli_dmax_tim_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_int_enb_ciu  *  * SLI_INT_ENB_CIU = SLI's Interrupt Enable CIU Register  *  * Used to enable the various interrupting conditions of SLI  */
end_comment

begin_union
union|union
name|cvmx_sli_int_enb_ciu
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_int_enb_ciu_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 3. */
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 2. */
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Input Count exceeded WMARK. */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_int_enb_ciu_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 3. */
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 2. */
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Input Count exceeded WMARK. */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_sli_int_enb_ciu_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Input Count exceeded WMARK. */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sli_int_enb_ciu_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_int_enb_ciu_cn61xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_sli_int_enb_ciu_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|reserved_51_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt on the RSL.                                                          THIS SHOULD NEVER BE SET */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt on the RSL. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt on the RSL. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_51_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_sli_int_enb_ciu_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_int_enb_ciu_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_int_enb_ciu
name|cvmx_sli_int_enb_ciu_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_int_enb_port#  *  * SLI_INT_ENB_PORTX = SLI's Interrupt Enable Register per mac port  *  * Used to allow the generation of interrupts (MSI/INTA) to the PORT X  *  * Notes:  * This CSR is not used when the corresponding MAC is sRIO.  *  */
end_comment

begin_union
union|union
name|cvmx_sli_int_enb_portx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_int_enb_portx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
comment|/**< Out of range PIPE value. */
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 3. */
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 2. */
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Input Count exceeded WMARK. */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[19] to generate an                                                          interrupt to the PCIE-Port1 for MSI/inta.                                                          The valuse of this bit has NO effect on PCIE Port0.                                                          SLI_INT_ENB_PORT0[MAC1_INT] sould NEVER be set. */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[18] to generate an                                                          interrupt to the PCIE-Port0 for MSI/inta.                                                          The valus of this bit has NO effect on PCIE Port1.                                                          SLI_INT_ENB_PORT1[MAC0_INT] sould NEVER be set. */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT0[MIO_INT1] should NEVER be set. */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT1[MIO_INT0] should NEVER be set. */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_int_enb_portx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 3. */
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 2. */
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Input Count exceeded WMARK. */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[19] to generate an                                                          interrupt to the PCIE-Port1 for MSI/inta.                                                          The valuse of this bit has NO effect on PCIE Port0.                                                          SLI_INT_ENB_PORT0[MAC1_INT] sould NEVER be set. */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[18] to generate an                                                          interrupt to the PCIE-Port0 for MSI/inta.                                                          The valus of this bit has NO effect on PCIE Port1.                                                          SLI_INT_ENB_PORT1[MAC0_INT] sould NEVER be set. */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT0[MIO_INT1] should NEVER be set. */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT1[MIO_INT0] should NEVER be set. */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_sli_int_enb_portx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Input Count exceeded WMARK. */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[19] to generate an                                                          interrupt to the PCIE-Port1 for MSI/inta.                                                          The valuse of this bit has NO effect on PCIE Port0.                                                          SLI_INT_ENB_PORT0[MAC1_INT] sould NEVER be set. */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[18] to generate an                                                          interrupt to the PCIE-Port0 for MSI/inta.                                                          The valus of this bit has NO effect on PCIE Port1.                                                          SLI_INT_ENB_PORT1[MAC0_INT] sould NEVER be set. */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT0[MIO_INT1] should NEVER be set. */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT1[MIO_INT0] should NEVER be set. */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sli_int_enb_portx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_int_enb_portx_cn61xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_sli_int_enb_portx_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
comment|/**< Out of range PIPE value. */
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Illegal packet csr address. */
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 1. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< Error Response received on SLI port 0. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet instruction fetch. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet scatter pointer fetch. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during packet data fetch. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< Read Error during gather list fetch. */
name|uint64_t
name|reserved_51_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Packet Out Interrupt, Error From PKO. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell Count Overflow. */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell Count Overflow. */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< DMA Timer Interrupts */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DMA Count Interrupts */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[19] to generate an                                                          interrupt to the PCIE-Port1 for MSI/inta.                                                          The valuse of this bit has NO effect on PCIE Port0.                                                          SLI_INT_ENB_PORT0[MAC1_INT] sould NEVER be set. */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[18] to generate an                                                          interrupt to the PCIE-Port0 for MSI/inta.                                                          The valus of this bit has NO effect on PCIE Port1.                                                          SLI_INT_ENB_PORT1[MAC0_INT] sould NEVER be set. */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[17] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT0[MIO_INT1] should NEVER be set. */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[16] to generate an                                                          interrupt to the PCIE core for MSI/inta.                                                          SLI_INT_ENB_PORT1[MIO_INT0] should NEVER be set. */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[15] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[14] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[13] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[12] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[11] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[10] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[9] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[8] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[5] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[4] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[3] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[2] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< Enables SLI_INT_SUM[0] to generate an                                                          interrupt to the PCIE core for MSI/inta. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_51_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_sli_int_enb_portx_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_int_enb_portx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_int_enb_portx
name|cvmx_sli_int_enb_portx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_int_sum  *  * SLI_INT_SUM = SLI Interrupt Summary Register  *  * Set when an interrupt condition occurs, write '1' to clear.  */
end_comment

begin_union
union|union
name|cvmx_sli_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_int_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when a PIPE value outside range is received. */
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Set when a BAR0 address R/W falls into theaddress                                                          range of the Packet-CSR, but for an unused                                                          address. */
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 1                                                          this bit is set. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 0                                                          this bit is set. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet instruction                                                          this bit is set. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet scatter                                                          pointer pair this bit is set. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet data read                                                          this bit is set. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet gather list                                                          read this bit is set. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet input count has exceeded the WMARK.                                                          See SLI_PKT_IN_BP */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when PKO sends packet data with the error bit                                                          set. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PSLDBOF] */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PIDBOF] */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< Whenever SLI_DMAx_CNT[CNT] is not 0, the                                                          SLI_DMAx_TIM[TIM] timer increments every SLI                                                          clock.                                                          DTIME[x] is set whenever SLI_DMAx_TIM[TIM]>                                                          SLI_DMAx_INT_LEVEL[TIME].                                                          DTIME[x] is normally cleared by clearing                                                          SLI_DMAx_CNT[CNT] (which also clears                                                          SLI_DMAx_TIM[TIM]). */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DCNT[x] is set whenever SLI_DMAx_CNT[CNT]>                                                          SLI_DMAx_INT_LEVEL[CNT].                                                          DCNT[x] is normally cleared by decreasing                                                          SLI_DMAx_CNT[CNT]. */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts. */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC1.                                                          See PEM1_INT_SUM (enabled by PEM1_INT_ENB_INT) */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC0.                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB_INT) */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 1.                                                          See CIU_INT33_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT33_EN0, CIU_INT33_EN1) */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 0.                                                          See CIU_INT32_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT32_EN0, CIU_INT32_EN1) */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Packet Timer has an interrupt. Which rings can                                                          be found in SLI_PKT_TIME_INT. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Packet Counter has an interrupt. Which rings can                                                          be found in SLI_PKT_CNT_INT. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< A read or write transfer did not complete                                                          within 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_int_sum_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Set when a BAR0 address R/W falls into theaddress                                                          range of the Packet-CSR, but for an unused                                                          address. */
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 1                                                          this bit is set. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 0                                                          this bit is set. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet instruction                                                          this bit is set. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet scatter                                                          pointer pair this bit is set. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet data read                                                          this bit is set. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet gather list                                                          read this bit is set. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet input count has exceeded the WMARK.                                                          See SLI_PKT_IN_BP */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when PKO sends packet data with the error bit                                                          set. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PSLDBOF] */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PIDBOF] */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< Whenever SLI_DMAx_CNT[CNT] is not 0, the                                                          SLI_DMAx_TIM[TIM] timer increments every SLI                                                          clock.                                                          DTIME[x] is set whenever SLI_DMAx_TIM[TIM]>                                                          SLI_DMAx_INT_LEVEL[TIME].                                                          DTIME[x] is normally cleared by clearing                                                          SLI_DMAx_CNT[CNT] (which also clears                                                          SLI_DMAx_TIM[TIM]). */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DCNT[x] is set whenever SLI_DMAx_CNT[CNT]>                                                          SLI_DMAx_INT_LEVEL[CNT].                                                          DCNT[x] is normally cleared by decreasing                                                          SLI_DMAx_CNT[CNT]. */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts. */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Reserved. */
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC1.                                                          See PEM1_INT_SUM (enabled by PEM1_INT_ENB_INT) */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC0.                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB_INT) */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 1.                                                          See CIU_INT33_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT33_EN0, CIU_INT33_EN1) */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 0.                                                          See CIU_INT32_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT32_EN0, CIU_INT32_EN1) */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Packet Timer has an interrupt. Which rings can                                                          be found in SLI_PKT_TIME_INT. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Packet Counter has an interrupt. Which rings can                                                          be found in SLI_PKT_CNT_INT. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< A read or write transfer did not complete                                                          within 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m2_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m3_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt2_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt3_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_sli_int_sum_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Set when a BAR0 address R/W falls into theaddress                                                          range of the Packet-CSR, but for an unused                                                          address. */
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 1                                                          this bit is set. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 0                                                          this bit is set. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet instruction                                                          this bit is set. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet scatter                                                          pointer pair this bit is set. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet data read                                                          this bit is set. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet gather list                                                          read this bit is set. */
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
comment|/**< Packet input count has exceeded the WMARK.                                                          See SLI_PKT_IN_BP */
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when PKO sends packet data with the error bit                                                          set. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PSLDBOF] */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PIDBOF] */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< Whenever SLI_DMAx_CNT[CNT] is not 0, the                                                          SLI_DMAx_TIM[TIM] timer increments every SLI                                                          clock.                                                          DTIME[x] is set whenever SLI_DMAx_TIM[TIM]>                                                          SLI_DMAx_INT_LEVEL[TIME].                                                          DTIME[x] is normally cleared by clearing                                                          SLI_DMAx_CNT[CNT] (which also clears                                                          SLI_DMAx_TIM[TIM]). */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DCNT[x] is set whenever SLI_DMAx_CNT[CNT]>                                                          SLI_DMAx_INT_LEVEL[CNT].                                                          DCNT[x] is normally cleared by decreasing                                                          SLI_DMAx_CNT[CNT]. */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts. */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC1.                                                          See PEM1_INT_SUM (enabled by PEM1_INT_ENB_INT) */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC0.                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB_INT) */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 1.                                                          See CIU_INT33_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT33_EN0, CIU_INT33_EN1) */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 0.                                                          See CIU_INT32_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT32_EN0, CIU_INT32_EN1) */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Packet Timer has an interrupt. Which rings can                                                          be found in SLI_PKT_TIME_INT. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Packet Counter has an interrupt. Which rings can                                                          be found in SLI_PKT_CNT_INT. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< A read or write transfer did not complete                                                          within 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_61_63
range|:
literal|3
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sli_int_sum_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_int_sum_cn61xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_sli_int_sum_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when a PIPE value outside range is received. */
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
comment|/**< Set when a BAR0 address R/W falls into theaddress                                                          range of the Packet-CSR, but for an unused                                                          address. */
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 1                                                          this bit is set. */
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
comment|/**< When an error response received on SLI port 0                                                          this bit is set. */
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet instruction                                                          this bit is set. */
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet scatter                                                          pointer pair this bit is set. */
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet data read                                                          this bit is set. */
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
comment|/**< When a read error occurs on a packet gather list                                                          read this bit is set. */
name|uint64_t
name|reserved_51_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
comment|/**< Set when PKO sends packet data with the error bit                                                          set. */
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Scatterlist Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PSLDBOF] */
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
comment|/**< Packet Instruction Doorbell count overflowed. Which                                                          doorbell can be found in DPI_PINT_INFO[PIDBOF] */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
comment|/**< Whenever SLI_DMAx_CNT[CNT] is not 0, the                                                          SLI_DMAx_TIM[TIM] timer increments every SLI                                                          clock.                                                          DTIME[x] is set whenever SLI_DMAx_TIM[TIM]>                                                          SLI_DMAx_INT_LEVEL[TIME].                                                          DTIME[x] is normally cleared by clearing                                                          SLI_DMAx_CNT[CNT] (which also clears                                                          SLI_DMAx_TIM[TIM]). */
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
comment|/**< DCNT[x] is set whenever SLI_DMAx_CNT[CNT]>                                                          SLI_DMAx_INT_LEVEL[CNT].                                                          DCNT[x] is normally cleared by decreasing                                                          SLI_DMAx_CNT[CNT]. */
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
comment|/**< DMA set Forced Interrupts. */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC1.                                                          See PEM1_INT_SUM (enabled by PEM1_INT_ENB_INT) */
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MAC0.                                                          See PEM0_INT_SUM (enabled by PEM0_INT_ENB_INT) */
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 1.                                                          See CIU_INT33_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT33_EN0, CIU_INT33_EN1) */
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
comment|/**< Interrupt from MIO for PORT 0.                                                          See CIU_INT32_SUM0, CIU_INT_SUM1                                                          (enabled by CIU_INT32_EN0, CIU_INT32_EN1) */
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 1. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 1.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported N-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Window Register                                                          from MAC 0. This occurs when the window registers                                                          are disabeld and a window register access occurs. */
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
comment|/**< Received Unsupported P-TLP for Bar0 from MAC 0.                                                          This occurs when the BAR 0 address space is                                                          disabeled. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Packet Timer has an interrupt. Which rings can                                                          be found in SLI_PKT_TIME_INT. */
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
comment|/**< Packet Counter has an interrupt. Which rings can                                                          be found in SLI_PKT_CNT_INT. */
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
comment|/**< A requested IOBDMA is to large. */
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
comment|/**< BAR0 R/W to a NCB device did not receive                                                          read-data/commit in 0xffff core clocks. */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
comment|/**< A read or write transfer did not complete                                                          within 0xffff core clocks. */
else|#
directive|else
name|uint64_t
name|rml_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar0_to
range|:
literal|1
decl_stmt|;
name|uint64_t
name|iob2big
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcnt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|m0_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m0_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_up_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_b0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|m1_un_wi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mio_int1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mac1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|dmafi
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dcnt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dtime
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pidbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|psldbof
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pout_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_51_51
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pgl_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pdi_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pop_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pins_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt0_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sprt1_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_59
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ill_pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pipe_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_sli_int_sum_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_int_sum_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_int_sum
name|cvmx_sli_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_last_win_rdata0  *  * SLI_LAST_WIN_RDATA0 = SLI Last Window Read Data  *  * The data from the last initiated window read by MAC 0.  */
end_comment

begin_union
union|union
name|cvmx_sli_last_win_rdata0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_last_win_rdata0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Last window read data. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_last_win_rdata0
name|cvmx_sli_last_win_rdata0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_last_win_rdata1  *  * SLI_LAST_WIN_RDATA1 = SLI Last Window Read Data  *  * The data from the last initiated window read by MAC 1.  */
end_comment

begin_union
union|union
name|cvmx_sli_last_win_rdata1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_last_win_rdata1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Last window read data. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_last_win_rdata1
name|cvmx_sli_last_win_rdata1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_last_win_rdata2  *  * SLI_LAST_WIN_RDATA2 = SLI Last Window Read Data  *  * The data from the last initiated window read by MAC 2.  */
end_comment

begin_union
union|union
name|cvmx_sli_last_win_rdata2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_last_win_rdata2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Last window read data. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_last_win_rdata2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_last_win_rdata2
name|cvmx_sli_last_win_rdata2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_last_win_rdata3  *  * SLI_LAST_WIN_RDATA3 = SLI Last Window Read Data  *  * The data from the last initiated window read by MAC 3.  */
end_comment

begin_union
union|union
name|cvmx_sli_last_win_rdata3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_last_win_rdata3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Last window read data. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_last_win_rdata3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_last_win_rdata3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_last_win_rdata3
name|cvmx_sli_last_win_rdata3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_mac_credit_cnt  *  * SLI_MAC_CREDIT_CNT = SLI MAC Credit Count  *  * Contains the number of credits for the MAC port FIFOs used by the SLI. This value needs to be set BEFORE S2M traffic  * flow starts. A write to this register will cause the credit counts in the SLI for the MAC ports to be reset to the value  * in this register.  */
end_comment

begin_union
union|union
name|cvmx_sli_mac_credit_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_mac_credit_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|p1_c_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P1_CCNT. */
name|uint64_t
name|p1_n_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P1_NCNT. */
name|uint64_t
name|p1_p_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P1_PCNT. */
name|uint64_t
name|p0_c_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P0_CCNT. */
name|uint64_t
name|p0_n_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P0_NCNT. */
name|uint64_t
name|p0_p_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P0_PCNT. */
name|uint64_t
name|p1_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p1_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p1_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p0_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p0_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p0_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
else|#
directive|else
name|uint64_t
name|p0_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_p_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_n_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p0_c_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_p_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_n_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p1_c_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_mac_credit_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_credit_cnt_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_sli_mac_credit_cnt_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|p1_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p1_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p1_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port1 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p0_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p0_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p0_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port0 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
else|#
directive|else
name|uint64_t
name|p0_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p0_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p1_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_sli_mac_credit_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_credit_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_credit_cnt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_mac_credit_cnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_mac_credit_cnt
name|cvmx_sli_mac_credit_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_mac_credit_cnt2  *  * SLI_MAC_CREDIT_CNT2 = SLI MAC Credit Count2  *  * Contains the number of credits for the MAC port FIFOs (for MACs 2 and 3) used by the SLI. This value needs to be set BEFORE S2M traffic  * flow starts. A write to this register will cause the credit counts in the SLI for the MAC ports to be reset to the value  * in this register.  */
end_comment

begin_union
union|union
name|cvmx_sli_mac_credit_cnt2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_mac_credit_cnt2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|p3_c_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P3_CCNT. */
name|uint64_t
name|p3_n_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P3_NCNT. */
name|uint64_t
name|p3_p_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P3_PCNT. */
name|uint64_t
name|p2_c_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P2_CCNT. */
name|uint64_t
name|p2_n_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P2_NCNT. */
name|uint64_t
name|p2_p_d
range|:
literal|1
decl_stmt|;
comment|/**< When set does not allow writing of P2_PCNT. */
name|uint64_t
name|p3_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port3 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p3_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port3 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p3_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port3 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p2_ccnt
range|:
literal|8
decl_stmt|;
comment|/**< Port2 C-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
name|uint64_t
name|p2_ncnt
range|:
literal|8
decl_stmt|;
comment|/**< Port2 N-TLP FIFO Credits.                                                          Legal values are 0x5 to 0x10. */
name|uint64_t
name|p2_pcnt
range|:
literal|8
decl_stmt|;
comment|/**< Port2 P-TLP FIFO Credits.                                                          Legal values are 0x25 to 0x80. */
else|#
directive|else
name|uint64_t
name|p2_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p2_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p2_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p3_pcnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p3_ncnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p3_ccnt
range|:
literal|8
decl_stmt|;
name|uint64_t
name|p2_p_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_n_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p2_c_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_p_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_n_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p3_c_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_mac_credit_cnt2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_credit_cnt2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_credit_cnt2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_mac_credit_cnt2
name|cvmx_sli_mac_credit_cnt2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_mac_number  *  * 0x13DA0 - 0x13DF0 reserved for ports 2 - 7  *  *                  SLI_MAC_NUMBER = SLI MAC Number  *  * When read from a MAC port it returns the MAC's port number.  */
end_comment

begin_union
union|union
name|cvmx_sli_mac_number
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_mac_number_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|a_mode
range|:
literal|1
decl_stmt|;
comment|/**< SLI in Authenticate Mode. */
name|uint64_t
name|num
range|:
literal|8
decl_stmt|;
comment|/**< The mac number. */
else|#
directive|else
name|uint64_t
name|num
range|:
literal|8
decl_stmt|;
name|uint64_t
name|a_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_mac_number_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_sli_mac_number_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|num
range|:
literal|8
decl_stmt|;
comment|/**< The mac number. */
else|#
directive|else
name|uint64_t
name|num
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sli_mac_number_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_number_cn63xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_mac_number_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_mac_number_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_mac_number
name|cvmx_sli_mac_number_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_mem_access_ctl  *  * SLI_MEM_ACCESS_CTL = SLI's Memory Access Control  *  * Contains control for access to the MAC address space.  */
end_comment

begin_union
union|union
name|cvmx_sli_mem_access_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_mem_access_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|4
decl_stmt|;
comment|/**< The maximum number of words to merge into a single                                                          write operation from the PPs to the MAC. Legal                                                          values are 1 to 16, where a '0' is treated as 16. */
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
comment|/**< When the SLI starts a PP to MAC write it waits                                                          no longer than the value of TIMER in eclks to                                                          merge additional writes from the PPs into 1                                                          large write. The values for this field is 1 to                                                          1024 where a value of '0' is treated as 1024. */
else|#
directive|else
name|uint64_t
name|timer
range|:
literal|10
decl_stmt|;
name|uint64_t
name|max_word
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_mem_access_ctl
name|cvmx_sli_mem_access_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_mem_access_subid#  *  * // *  * // * 8070 - 80C0 saved for ports 2 through 7  * // *  * // *  * // * 0x80d0 free  * // *  *  *                   SLI_MEM_ACCESS_SUBIDX = SLI Memory Access SubidX Register  *  *  Contains address index and control bits for access to memory from Core PPs.  */
end_comment

begin_union
union|union
name|cvmx_sli_mem_access_subidx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_mem_access_subidx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
comment|/**< Causes all byte reads to be zero length reads.                                                          Returns to the EXEC a zero for all read data.                                                          This must be zero for sRIO ports. */
name|uint64_t
name|port
range|:
literal|3
decl_stmt|;
comment|/**< Physical MAC Port that reads/writes to                                                          this subid are sent to. Must be<= 1, as there are                                                          only two ports present. */
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
comment|/**< When set, no merging is allowed in this window. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for reads to this subid.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for writes to this subid.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space writes. */
name|uint64_t
name|wtype
range|:
literal|2
decl_stmt|;
comment|/**< ADDRTYPE<1:0> for writes to this subid                                                          For PCIe:                                                          - ADDRTYPE<0> is the relaxed-order attribute                                                          - ADDRTYPE<1> is the no-snoop attribute                                                          For sRIO:                                                          - ADDRTYPE<1:0> help select an SRIO*_S2M_TYPE*                                                            entry */
name|uint64_t
name|rtype
range|:
literal|2
decl_stmt|;
comment|/**< ADDRTYPE<1:0> for reads to this subid                                                          For PCIe:                                                          - ADDRTYPE<0> is the relaxed-order attribute                                                          - ADDRTYPE<1> is the no-snoop attribute                                                          For sRIO:                                                          - ADDRTYPE<1:0> help select an SRIO*_S2M_TYPE*                                                            entry */
name|uint64_t
name|reserved_0_29
range|:
literal|30
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_29
range|:
literal|30
decl_stmt|;
name|uint64_t
name|rtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|port
range|:
literal|3
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_mem_access_subidx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
comment|/**< Causes all byte reads to be zero length reads.                                                          Returns to the EXEC a zero for all read data.                                                          This must be zero for sRIO ports. */
name|uint64_t
name|port
range|:
literal|3
decl_stmt|;
comment|/**< Physical MAC Port that reads/writes to                                                          this subid are sent to. Must be<= 1, as there are                                                          only two ports present. */
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
comment|/**< When set, no merging is allowed in this window. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for reads to this subid.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for writes to this subid.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space writes. */
name|uint64_t
name|wtype
range|:
literal|2
decl_stmt|;
comment|/**< ADDRTYPE<1:0> for writes to this subid                                                          For PCIe:                                                          - ADDRTYPE<0> is the relaxed-order attribute                                                          - ADDRTYPE<1> is the no-snoop attribute                                                          For sRIO:                                                          - ADDRTYPE<1:0> help select an SRIO*_S2M_TYPE*                                                            entry */
name|uint64_t
name|rtype
range|:
literal|2
decl_stmt|;
comment|/**< ADDRTYPE<1:0> for reads to this subid                                                          For PCIe:                                                          - ADDRTYPE<0> is the relaxed-order attribute                                                          - ADDRTYPE<1> is the no-snoop attribute                                                          For sRIO:                                                          - ADDRTYPE<1:0> help select an SRIO*_S2M_TYPE*                                                            entry */
name|uint64_t
name|ba
range|:
literal|30
decl_stmt|;
comment|/**< Address Bits<63:34> for reads/writes that use                                                          this subid. */
else|#
directive|else
name|uint64_t
name|ba
range|:
literal|30
decl_stmt|;
name|uint64_t
name|rtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|port
range|:
literal|3
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_sli_mem_access_subidx_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_subidx_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_subidx_cn61xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_sli_mem_access_subidx_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
comment|/**< Causes all byte reads to be zero length reads.                                                          Returns to the EXEC a zero for all read data.                                                          This must be zero for sRIO ports. */
name|uint64_t
name|port
range|:
literal|3
decl_stmt|;
comment|/**< Physical MAC Port that reads/writes to                                                          this subid are sent to. Must be<= 1, as there are                                                          only two ports present. */
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
comment|/**< When set, no merging is allowed in this window. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for reads to this subid.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for writes to this subid.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space writes. */
name|uint64_t
name|wtype
range|:
literal|2
decl_stmt|;
comment|/**< ADDRTYPE<1:0> for writes to this subid                                                          For PCIe:                                                          - ADDRTYPE<0> is the relaxed-order attribute                                                          - ADDRTYPE<1> is the no-snoop attribute */
name|uint64_t
name|rtype
range|:
literal|2
decl_stmt|;
comment|/**< ADDRTYPE<1:0> for reads to this subid                                                          For PCIe:                                                          - ADDRTYPE<0> is the relaxed-order attribute                                                          - ADDRTYPE<1> is the no-snoop attribute */
name|uint64_t
name|ba
range|:
literal|28
decl_stmt|;
comment|/**< Address Bits<63:36> for reads/writes that use                                                          this subid. */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ba
range|:
literal|28
decl_stmt|;
name|uint64_t
name|rtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wtype
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nmerge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|port
range|:
literal|3
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_sli_mem_access_subidx_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_mem_access_subidx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_mem_access_subidx
name|cvmx_sli_mem_access_subidx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_enb0  *  * SLI_MSI_ENB0 = SLI MSI Enable0  *  * Used to enable the interrupt generation for the bits in the SLI_MSI_RCV0.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_enb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_enb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of SLI_MSI_RCV0. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_enb0
name|cvmx_sli_msi_enb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_enb1  *  * SLI_MSI_ENB1 = SLI MSI Enable1  *  * Used to enable the interrupt generation for the bits in the SLI_MSI_RCV1.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_enb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_enb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of SLI_MSI_RCV1. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_enb1
name|cvmx_sli_msi_enb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_enb2  *  * SLI_MSI_ENB2 = SLI MSI Enable2  *  * Used to enable the interrupt generation for the bits in the SLI_MSI_RCV2.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of SLI_MSI_RCV2. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_enb2
name|cvmx_sli_msi_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_enb3  *  * SLI_MSI_ENB3 = SLI MSI Enable3  *  * Used to enable the interrupt generation for the bits in the SLI_MSI_RCV3.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_enb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_enb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
comment|/**< Enables bit [63:0] of SLI_MSI_RCV3. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_enb3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_enb3
name|cvmx_sli_msi_enb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_rcv0  *  * SLI_MSI_RCV0 = SLI MSI Receive0  *  * Contains bits [63:0] of the 256 bits of MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_rcv0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_rcv0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 63-0 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_rcv0
name|cvmx_sli_msi_rcv0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_rcv1  *  * SLI_MSI_RCV1 = SLI MSI Receive1  *  * Contains bits [127:64] of the 256 bits of MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_rcv1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_rcv1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 127-64 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_rcv1
name|cvmx_sli_msi_rcv1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_rcv2  *  * SLI_MSI_RCV2 = SLI MSI Receive2  *  * Contains bits [191:128] of the 256 bits of MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_rcv2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_rcv2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 191-128 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_rcv2
name|cvmx_sli_msi_rcv2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_rcv3  *  * SLI_MSI_RCV3 = SLI MSI Receive3  *  * Contains bits [255:192] of the 256 bits of MSI interrupts.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_rcv3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_rcv3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
comment|/**< Bits 255-192 of the 256 bits of MSI interrupt. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rcv3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_rcv3
name|cvmx_sli_msi_rcv3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_rd_map  *  * SLI_MSI_RD_MAP = SLI MSI Read MAP  *  * Used to read the mapping function of the SLI_PCIE_MSI_RCV to SLI_MSI_RCV registers.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_rd_map
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_rd_map_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|rd_int
range|:
literal|8
decl_stmt|;
comment|/**< The value of the map at the location PREVIOUSLY                                                          written to the MSI_INT field of this register. */
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
comment|/**< Selects the value that would be received when the                                                          SLI_PCIE_MSI_RCV register is written. */
else|#
directive|else
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rd_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_rd_map_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_rd_map
name|cvmx_sli_msi_rd_map_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1c_enb0  *  * SLI_MSI_W1C_ENB0 = SLI MSI Write 1 To Clear Enable0  *  * Used to clear bits in SLI_MSI_ENB0.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1c_enb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1c_enb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in SLI_MSI_ENB0.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1c_enb0
name|cvmx_sli_msi_w1c_enb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1c_enb1  *  * SLI_MSI_W1C_ENB1 = SLI MSI Write 1 To Clear Enable1  *  * Used to clear bits in SLI_MSI_ENB1.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1c_enb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1c_enb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in SLI_MSI_ENB1.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1c_enb1
name|cvmx_sli_msi_w1c_enb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1c_enb2  *  * SLI_MSI_W1C_ENB2 = SLI MSI Write 1 To Clear Enable2  *  * Used to clear bits in SLI_MSI_ENB2.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1c_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1c_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in SLI_MSI_ENB2.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1c_enb2
name|cvmx_sli_msi_w1c_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1c_enb3  *  * SLI_MSI_W1C_ENB3 = SLI MSI Write 1 To Clear Enable3  *  * Used to clear bits in SLI_MSI_ENB3.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1c_enb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1c_enb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will clear the                                                          cooresponding bit in SLI_MSI_ENB3.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1c_enb3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1c_enb3
name|cvmx_sli_msi_w1c_enb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1s_enb0  *  * SLI_MSI_W1S_ENB0 = SLI MSI Write 1 To Set Enable0  *  * Used to set bits in SLI_MSI_ENB0.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1s_enb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1s_enb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in SLI_MSI_ENB0.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1s_enb0
name|cvmx_sli_msi_w1s_enb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1s_enb1  *  * SLI_MSI_W1S_ENB0 = SLI MSI Write 1 To Set Enable1  *  * Used to set bits in SLI_MSI_ENB1.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1s_enb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1s_enb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in SLI_MSI_ENB1.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1s_enb1
name|cvmx_sli_msi_w1s_enb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1s_enb2  *  * SLI_MSI_W1S_ENB2 = SLI MSI Write 1 To Set Enable2  *  * Used to set bits in SLI_MSI_ENB2.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1s_enb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1s_enb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in SLI_MSI_ENB2.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1s_enb2
name|cvmx_sli_msi_w1s_enb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_w1s_enb3  *  * SLI_MSI_W1S_ENB3 = SLI MSI Write 1 To Set Enable3  *  * Used to set bits in SLI_MSI_ENB3.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_w1s_enb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_w1s_enb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
comment|/**< A write of '1' to a vector will set the                                                          cooresponding bit in SLI_MSI_ENB3.                                                          A read to this address will return 0. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_w1s_enb3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_w1s_enb3
name|cvmx_sli_msi_w1s_enb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_msi_wr_map  *  * SLI_MSI_WR_MAP = SLI MSI Write MAP  *  * Used to write the mapping function of the SLI_PCIE_MSI_RCV to SLI_MSI_RCV registers.  */
end_comment

begin_union
union|union
name|cvmx_sli_msi_wr_map
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_msi_wr_map_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|ciu_int
range|:
literal|8
decl_stmt|;
comment|/**< Selects which bit in the SLI_MSI_RCV# (0-255)                                                          will be set when the value specified in the                                                          MSI_INT of this register is recevied during a                                                          write to the SLI_PCIE_MSI_RCV register. */
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
comment|/**< Selects the value that would be received when the                                                          SLI_PCIE_MSI_RCV register is written. */
else|#
directive|else
name|uint64_t
name|msi_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ciu_int
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_msi_wr_map_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_msi_wr_map
name|cvmx_sli_msi_wr_map_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pcie_msi_rcv  *  * SLI_PCIE_MSI_RCV = SLI MAC MSI Receive  *  * Register where MSI writes are directed from the MAC.  */
end_comment

begin_union
union|union
name|cvmx_sli_pcie_msi_rcv
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pcie_msi_rcv_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the SLI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the SLI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pcie_msi_rcv
name|cvmx_sli_pcie_msi_rcv_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pcie_msi_rcv_b1  *  * SLI_PCIE_MSI_RCV_B1 = SLI MAC MSI Receive Byte 1  *  * Register where MSI writes are directed from the MAC.  *  * Notes:  * This CSR can be used by PCIe and sRIO MACs.  *  */
end_comment

begin_union
union|union
name|cvmx_sli_pcie_msi_rcv_b1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the SLI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the SLI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pcie_msi_rcv_b1
name|cvmx_sli_pcie_msi_rcv_b1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pcie_msi_rcv_b2  *  * SLI_PCIE_MSI_RCV_B2 = SLI MAC MSI Receive Byte 2  *  * Register where MSI writes are directed from the MAC.  *  * Notes:  * This CSR can be used by PCIe and sRIO MACs.  *  */
end_comment

begin_union
union|union
name|cvmx_sli_pcie_msi_rcv_b2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the SLI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the SLI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pcie_msi_rcv_b2
name|cvmx_sli_pcie_msi_rcv_b2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pcie_msi_rcv_b3  *  * SLI_PCIE_MSI_RCV_B3 = SLI MAC MSI Receive Byte 3  *  * Register where MSI writes are directed from the MAC.  *  * Notes:  * This CSR can be used by PCIe and sRIO MACs.  *  */
end_comment

begin_union
union|union
name|cvmx_sli_pcie_msi_rcv_b3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
comment|/**< A write to this register will result in a bit in                                                          one of the SLI_MSI_RCV# registers being set.                                                          Which bit is set is dependent on the previously                                                          written using the SLI_MSI_WR_MAP register or if                                                          not previously written the reset value of the MAP. */
name|uint64_t
name|reserved_0_23
range|:
literal|24
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_23
range|:
literal|24
decl_stmt|;
name|uint64_t
name|intr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pcie_msi_rcv_b3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pcie_msi_rcv_b3
name|cvmx_sli_pcie_msi_rcv_b3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_cnts  *  * SLI_PKT[0..31]_CNTS = SLI Packet ring# Counts  *  * The counters for output rings.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|22
decl_stmt|;
comment|/**< Timer incremented every 1024 core clocks                                                          when SLI_PKTS#_CNTS[CNT] is non zero. Field                                                          cleared when SLI_PKTS#_CNTS[CNT] goes to 0.                                                          Field is also cleared when SLI_PKT_TIME_INT is                                                          cleared.                                                          The first increment of this count can occur                                                          between 0 to 1023 core clocks. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< ring counter. This field is incremented as                                                          packets are sent out and decremented in response to                                                          writes to this field.                                                          When SLI_PKT_OUT_BMODE is '0' a value of 1 is                                                          added to the register for each packet, when '1'                                                          and the info-pointer is NOT used the length of the                                                          packet plus 8 is added, when '1' and info-pointer                                                          mode IS used the packet length is added to this                                                          field. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_cnts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_cnts
name|cvmx_sli_pktx_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_in_bp  *  * SLI_PKT[0..31]_IN_BP = SLI Packet ring# Input Backpressure  *  * The counters and thresholds for input packets to apply backpressure to processing of the packets.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_in_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_in_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
comment|/**< When CNT is greater than this threshold no more                                                          packets will be processed for this ring.                                                          When writing this field of the SLI_PKT#_IN_BP                                                          register, use a 4-byte write so as to not write                                                          any other field of this register. */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< ring counter. This field is incremented by one                                                          whenever OCTEON receives, buffers, and creates a                                                          work queue entry for a packet that arrives by the                                                          cooresponding input ring. A write to this field                                                          will be subtracted from the field value.                                                          When writing this field of the SLI_PKT#_IN_BP                                                          register, use a 4-byte write so as to not write                                                          any other field of this register. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_in_bp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_in_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_in_bp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_in_bp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_in_bp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_in_bp
name|cvmx_sli_pktx_in_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_instr_baddr  *  * SLI_PKT[0..31]_INSTR_BADDR = SLI Packet ring# Instruction Base Address  *  * Start of Instruction for input packets.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_instr_baddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_instr_baddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|addr
range|:
literal|61
decl_stmt|;
comment|/**< Base address for Instructions. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baddr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_instr_baddr
name|cvmx_sli_pktx_instr_baddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_instr_baoff_dbell  *  * SLI_PKT[0..31]_INSTR_BAOFF_DBELL = SLI Packet ring# Instruction Base Address Offset and Doorbell  *  * The doorbell and base address offset for next read.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_instr_baoff_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
comment|/**< The offset from the SLI_PKT[0..31]_INSTR_BADDR                                                          where the next instruction will be read. */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Instruction doorbell count. Writes to this field                                                          will increment the value here. Reads will return                                                          present value. A write of 0xffffffff will set the                                                          DBELL and AOFF fields to '0'. */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_baoff_dbell_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_instr_baoff_dbell
name|cvmx_sli_pktx_instr_baoff_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_instr_fifo_rsize  *  * SLI_PKT[0..31]_INSTR_FIFO_RSIZE = SLI Packet ring# Instruction FIFO and Ring Size.  *  * Fifo field and ring size for Instructions.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_instr_fifo_rsize
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|max
range|:
literal|9
decl_stmt|;
comment|/**< Max Fifo Size. */
name|uint64_t
name|rrp
range|:
literal|9
decl_stmt|;
comment|/**< Fifo read pointer. */
name|uint64_t
name|wrp
range|:
literal|9
decl_stmt|;
comment|/**< Fifo write pointer. */
name|uint64_t
name|fcnt
range|:
literal|5
decl_stmt|;
comment|/**< Fifo count. */
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
comment|/**< Instruction ring size. */
else|#
directive|else
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|wrp
range|:
literal|9
decl_stmt|;
name|uint64_t
name|rrp
range|:
literal|9
decl_stmt|;
name|uint64_t
name|max
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_fifo_rsize_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_instr_fifo_rsize
name|cvmx_sli_pktx_instr_fifo_rsize_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_instr_header  *  * SLI_PKT[0..31]_INSTR_HEADER = SLI Packet ring# Instruction Header.  *  * VAlues used to build input packet header.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_instr_header
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_instr_header_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode.                                                          Allows DPI to generate PKT_INST_HDR[PM,SL]                                                          differently per DPI instruction.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|reserved_38_42
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Becomes PKT_INST_HDR[PM]                                                          when DPI_INST_HDR[R]==1 and PBP==0 */
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Becomes PKT_INST_HDR[SL]                                                          when DPI_INST_HDR[R]==1 and PBP==0 */
name|uint64_t
name|rngrpext
range|:
literal|2
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[GRPEXT]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rnqos
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NQOS]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rngrp
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NGRP]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rntt
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTT]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rntag
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTAG]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' DPI always prepends a PKT_INST_HDR                                                          as part of the packet data sent to PIP/IPD,                                                          regardless of DPI_INST_HDR[R]. (DPI also always                                                          prepends a PKT_INST_HDR when DPI_INST_HDR[R]=1.)                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Becomes PKT_INST_HDR[PM]                                                          when DPI_INST_HDR[R]==0 and USE_IHDR==1 and PBP==0 */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Becomes PKT_INST_HDR[SL]                                                          when DPI_INST_HDR[R]==0 and USE_IHDR==1 and PBP==0 */
name|uint64_t
name|ngrpext
range|:
literal|2
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[GRPEXT]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NQOS]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NGRP]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTT]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTAG]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
else|#
directive|else
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ngrpext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rntag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rntt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rngrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnqos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rngrpext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_42
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_sli_pktx_instr_header_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
comment|/**< Enable Packet-by-packet mode.                                                          Allows DPI to generate PKT_INST_HDR[PM,SL]                                                          differently per DPI instruction.                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|reserved_38_42
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Becomes PKT_INST_HDR[PM]                                                          when DPI_INST_HDR[R]==1 and PBP==0 */
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Becomes PKT_INST_HDR[SL]                                                          when DPI_INST_HDR[R]==1 and PBP==0 */
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rnqos
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NQOS]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rngrp
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NGRP]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rntt
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTT]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|rntag
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTAG]                                                          when DPI_INST_HDR[R]==1 */
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' DPI always prepends a PKT_INST_HDR                                                          as part of the packet data sent to PIP/IPD,                                                          regardless of DPI_INST_HDR[R]. (DPI also always                                                          prepends a PKT_INST_HDR when DPI_INST_HDR[R]=1.)                                                          USE_IHDR must be set whenever PBP is set. */
name|uint64_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode. Becomes PKT_INST_HDR[PM]                                                          when DPI_INST_HDR[R]==0 and USE_IHDR==1 and PBP==0 */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
comment|/**< Skip Length. Becomes PKT_INST_HDR[SL]                                                          when DPI_INST_HDR[R]==0 and USE_IHDR==1 and PBP==0 */
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NQOS]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NGRP]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTT]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
comment|/**< Becomes PKT_INST_HDR[NTAG]                                                          when DPI_INST_HDR[R]==0 (and USE_IHDR==1) */
else|#
directive|else
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|skp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|par_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_16_20
range|:
literal|5
decl_stmt|;
name|uint64_t
name|use_ihdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rntag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rntt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rngrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnqos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_26_27
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rskp_len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_35_35
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rparmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_38_42
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pbp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_sli_pktx_instr_header_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_header_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_header_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_header_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_header_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_instr_header_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_instr_header
name|cvmx_sli_pktx_instr_header_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_out_size  *  * SLI_PKT[0..31]_OUT_SIZE = SLI Packet Out Size  *  * Contains the BSIZE and ISIZE for output packet ports.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_out_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_out_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|7
decl_stmt|;
comment|/**< INFO BYTES size (bytes) for ring X. Legal sizes                                                          are 0 to 120. Not used in buffer-pointer-only mode. */
name|uint64_t
name|bsize
range|:
literal|16
decl_stmt|;
comment|/**< BUFFER SIZE (bytes) for ring X. */
else|#
directive|else
name|uint64_t
name|bsize
range|:
literal|16
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_out_size_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_out_size
name|cvmx_sli_pktx_out_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_slist_baddr  *  * SLI_PKT[0..31]_SLIST_BADDR = SLI Packet ring# Scatter List Base Address  *  * Start of Scatter List for output packet pointers - MUST be 16 byte alligned  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_slist_baddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_slist_baddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|addr
range|:
literal|60
decl_stmt|;
comment|/**< Base address for scatter list pointers. */
name|uint64_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baddr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_slist_baddr
name|cvmx_sli_pktx_slist_baddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_slist_baoff_dbell  *  * SLI_PKT[0..31]_SLIST_BAOFF_DBELL = SLI Packet ring# Scatter List Base Address Offset and Doorbell  *  * The doorbell and base address offset for next read.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_slist_baoff_dbell
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
comment|/**< The offset from the SLI_PKT[0..31]_SLIST_BADDR                                                          where the next SList pointer will be read.                                                          A write of 0xFFFFFFFF to the DBELL field will                                                          clear DBELL and AOFF */
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
comment|/**< Scatter list doorbell count. Writes to this field                                                          will increment the value here. Reads will return                                                          present value. The value of this field is                                                          decremented as read operations are ISSUED for                                                          scatter pointers.                                                          A write of 0xFFFFFFFF will clear DBELL and AOFF */
else|#
directive|else
name|uint64_t
name|dbell
range|:
literal|32
decl_stmt|;
name|uint64_t
name|aoff
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_baoff_dbell_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_slist_baoff_dbell
name|cvmx_sli_pktx_slist_baoff_dbell_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt#_slist_fifo_rsize  *  * SLI_PKT[0..31]_SLIST_FIFO_RSIZE = SLI Packet ring# Scatter List FIFO and Ring Size.  *  * The number of scatter pointer pairs in the scatter list.  */
end_comment

begin_union
union|union
name|cvmx_sli_pktx_slist_fifo_rsize
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
comment|/**< The number of scatter pointer pairs contained in                                                          the scatter list ring. */
else|#
directive|else
name|uint64_t
name|rsize
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pktx_slist_fifo_rsize_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pktx_slist_fifo_rsize
name|cvmx_sli_pktx_slist_fifo_rsize_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_cnt_int  *  * SLI_PKT_CNT_INT = SLI Packet Counter Interrupt  *  * The packets rings that are interrupting because of Packet Counters.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_cnt_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_cnt_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Output ring packet counter interrupt bits                                                          SLI sets PORT<i> whenever                                                          SLI_PKTi_CNTS[CNT]> SLI_PKT_INT_LEVELS[CNT].                                                          SLI_PKT_CNT_INT_ENB[PORT<i>] is the corresponding                                                          enable. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_cnt_int
name|cvmx_sli_pkt_cnt_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_cnt_int_enb  *  * SLI_PKT_CNT_INT_ENB = SLI Packet Counter Interrupt Enable  *  * Enable for the packets rings that are interrupting because of Packet Counters.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_cnt_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_cnt_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Output ring packet counter interrupt enables                                                          When both PORT<i> and corresponding                                                          SLI_PKT_CNT_INT[PORT<i>] are set, for any i,                                                          then SLI_INT_SUM[PCNT] is set, which can cause                                                          an interrupt. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_cnt_int_enb_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_cnt_int_enb
name|cvmx_sli_pkt_cnt_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_ctl  *  * SLI_PKT_CTL = SLI Packet Control  *  * Control for packets.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
comment|/**< When '0' forces "relative Q position" received                                                          from PKO to be zero, and replicates the back-                                                          pressure indication for the first ring attached                                                          to a PKO port across all the rings attached to a                                                          PKO port. When '1' backpressure is on a per                                                          port/ring. */
name|uint64_t
name|pkt_bp
range|:
literal|4
decl_stmt|;
comment|/**< When set '1' enable the port level backpressure for                                                          PKO ports associated with the bit. */
else|#
directive|else
name|uint64_t
name|pkt_bp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_ctl
name|cvmx_sli_pkt_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_data_out_es  *  * SLI_PKT_DATA_OUT_ES = SLI's Packet Data Out Endian Swap  *  * The Endian Swap for writing Data Out.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_data_out_es
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_data_out_es_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
comment|/**< ES<1:0> or MACADD<63:62> for buffer/info writes.                                                          ES<2i+1:2i> becomes either ES<1:0> or                                                          MACADD<63:62> for writes to buffer/info pair                                                          MAC memory space addresses fetched from packet                                                          output ring i. ES<1:0> if SLI_PKT_DPADDR[DPTR<i>]=1                                                          , else MACADD<63:62>.                                                          In the latter case, ES<1:0> comes from DPTR<63:62>.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space writes. */
else|#
directive|else
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_es_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_data_out_es
name|cvmx_sli_pkt_data_out_es_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_data_out_ns  *  * SLI_PKT_DATA_OUT_NS = SLI's Packet Data Out No Snoop  *  * The NS field for the TLP when writing packet data.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_data_out_ns
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_data_out_ns_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
comment|/**< ADDRTYPE<1> or MACADD<61> for buffer/info writes.                                                          NSR<i> becomes either ADDRTYPE<1> or MACADD<61>                                                          for writes to buffer/info pair MAC memory space                                                          addresses fetched from packet output ring i.                                                          ADDRTYPE<1> if SLI_PKT_DPADDR[DPTR<i>]=1, else                                                          MACADD<61>.                                                          In the latter case,ADDRTYPE<1> comes from DPTR<61>.                                                          ADDRTYPE<1> is the no-snoop attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
else|#
directive|else
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ns_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_data_out_ns
name|cvmx_sli_pkt_data_out_ns_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_data_out_ror  *  * SLI_PKT_DATA_OUT_ROR = SLI's Packet Data Out Relaxed Ordering  *  * The ROR field for the TLP when writing Packet Data.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_data_out_ror
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_data_out_ror_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
comment|/**< ADDRTYPE<0> or MACADD<60> for buffer/info writes.                                                          ROR<i> becomes either ADDRTYPE<0> or MACADD<60>                                                          for writes to buffer/info pair MAC memory space                                                          addresses fetched from packet output ring i.                                                          ADDRTYPE<0> if SLI_PKT_DPADDR[DPTR<i>]=1, else                                                          MACADD<60>.                                                          In the latter case,ADDRTYPE<0> comes from DPTR<60>.                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_data_out_ror_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_data_out_ror
name|cvmx_sli_pkt_data_out_ror_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_dpaddr  *  * SLI_PKT_DPADDR = SLI's Packet Data Pointer Addr  *  * Used to detemine address and attributes for packet data writes.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_dpaddr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_dpaddr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dptr
range|:
literal|32
decl_stmt|;
comment|/**< Determines whether buffer/info pointers are                                                          DPTR format 0 or DPTR format 1.                                                          When DPTR<i>=1, the buffer/info pointers fetched                                                          from packet output ring i are DPTR format 0.                                                          When DPTR<i>=0, the buffer/info pointers fetched                                                          from packet output ring i are DPTR format 1.                                                          (Replace SLI_PKT_INPUT_CONTROL[D_ESR,D_NSR,D_ROR]                                                          in the HRM descriptions of DPTR format 0/1 with                                                          SLI_PKT_DATA_OUT_ES[ES<2i+1:2i>],                                                          SLI_PKT_DATA_OUT_NS[NSR<i>], and                                                          SLI_PKT_DATA_OUT_ROR[ROR<i>], respectively,                                                          though.) */
else|#
directive|else
name|uint64_t
name|dptr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_dpaddr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_dpaddr
name|cvmx_sli_pkt_dpaddr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_in_bp  *  * SLI_PKT_IN_BP = SLI Packet Input Backpressure  *  * Which input rings have backpressure applied.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_in_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_in_bp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|32
decl_stmt|;
comment|/**< A packet input  ring that has its count greater                                                          than its WMARK will have backpressure applied.                                                          Each of the 32 bits coorespond to an input ring.                                                          When '1' that ring has backpressure applied an                                                          will fetch no more instructions, but will process                                                          any previously fetched instructions. */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_in_bp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_bp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_bp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_bp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_in_bp
name|cvmx_sli_pkt_in_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_in_done#_cnts  *  * SLI_PKT_IN_DONE[0..31]_CNTS = SLI Instruction Done ring# Counts  *  * Counters for instructions completed on Input rings.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_in_donex_cnts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_in_donex_cnts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< This field is incrmented by '1' when an instruction                                                          is completed. This field is incremented as the                                                          last of the data is read from the MAC. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_donex_cnts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_in_donex_cnts
name|cvmx_sli_pkt_in_donex_cnts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_in_instr_counts  *  * SLI_PKT_IN_INSTR_COUNTS = SLI Packet Input Instrutction Counts  *  * Keeps track of the number of instructions read into the FIFO and Packets sent to IPD.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_in_instr_counts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_in_instr_counts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wr_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Shows the number of packets sent to the IPD. */
name|uint64_t
name|rd_cnt
range|:
literal|32
decl_stmt|;
comment|/**< Shows the value of instructions that have had reads                                                          issued for them.                                                          to the Packet-ring is in reset. */
else|#
directive|else
name|uint64_t
name|rd_cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wr_cnt
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_instr_counts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_in_instr_counts
name|cvmx_sli_pkt_in_instr_counts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_in_pcie_port  *  * SLI_PKT_IN_PCIE_PORT = SLI's Packet In To MAC Port Assignment  *  * Assigns Packet Input rings to MAC ports.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_in_pcie_port
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_in_pcie_port_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
comment|/**< The MAC port that the Packet ring number is                                                          assigned. Two bits are used per ring (i.e. ring 0                                                          [1:0], ring 1 [3:2], ....). A value of '0 means                                                          that the Packetring is assign to MAC Port 0, a '1'                                                          MAC Port 1, a '2' MAC Port 2, and a '3' MAC Port 3. */
else|#
directive|else
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_in_pcie_port_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_in_pcie_port
name|cvmx_sli_pkt_in_pcie_port_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_input_control  *  * SLI_PKT_INPUT_CONTROL = SLI's Packet Input Control  *  * Control for reads for gather list and instructions.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_input_control
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_input_control_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|prd_erst
range|:
literal|1
decl_stmt|;
comment|/**< PRD Error Reset */
name|uint64_t
name|prd_rds
range|:
literal|7
decl_stmt|;
comment|/**< PRD Reads Out */
name|uint64_t
name|gii_erst
range|:
literal|1
decl_stmt|;
comment|/**< GII Error Reset */
name|uint64_t
name|gii_rds
range|:
literal|7
decl_stmt|;
comment|/**< GII Reads Out */
name|uint64_t
name|reserved_41_47
range|:
literal|7
decl_stmt|;
name|uint64_t
name|prc_idle
range|:
literal|1
decl_stmt|;
comment|/**< PRC In IDLE */
name|uint64_t
name|reserved_24_39
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pin_rst
range|:
literal|1
decl_stmt|;
comment|/**< Packet In Reset. When a gather-list read receives                                                          an error this bit (along with SLI_INT_SUM[PGL_ERR])                                                          is set. When receiveing a PGL_ERR interrupt the SW                                                          should:                                                          1. Wait 2ms to allow any outstanding reads to return                                                             or be timed out.                                                          2. Write a '0' to this bit.                                                          3. Startup the packet input again (all previous                                                             CSR setting of the packet-input will be lost). */
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the input packet selection will be                                                          made with a Round Robin arbitration. When '0'                                                          the input packet ring is fixed in priority,                                                          where the lower ring number has higher priority. */
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
comment|/**< PBP_DHI replaces address bits that are used                                                          for parse mode and skip-length when                                                          SLI_PKTi_INSTR_HEADER[PBP]=1.                                                          PBP_DHI becomes either MACADD<63:55> or MACADD<59:51>                                                          for the instruction DPTR reads in this case.                                                          The instruction DPTR reads are called                                                          "First Direct" or "First Indirect" in the HRM.                                                          When PBP=1, if "First Direct" and USE_CSR=0, PBP_DHI                                                          becomes MACADD<59:51>, else MACADD<63:55>. */
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<1> or MACADD<61> for packet input data                                                          reads.                                                          D_NSR becomes either ADDRTYPE<1> or MACADD<61>                                                          for MAC memory space reads of packet input data                                                          fetched for any packet input ring.                                                          ADDRTYPE<1> if USE_CSR=1, else MACADD<61>.                                                          In the latter case, ADDRTYPE<1> comes from DPTR<61>.                                                          ADDRTYPE<1> is the no-snoop attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> or MACADD<63:62> for packet input data                                                          reads.                                                          D_ESR becomes either ES<1:0> or MACADD<63:62>                                                          for MAC memory space reads of packet input data                                                          fetched for any packet input ring.                                                          ES<1:0> if USE_CSR=1, else MACADD<63:62>.                                                          In the latter case, ES<1:0> comes from DPTR<63:62>.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<0> or MACADD<60> for packet input data                                                          reads.                                                          D_ROR becomes either ADDRTYPE<0> or MACADD<60>                                                          for MAC memory space reads of packet input data                                                          fetched for any packet input ring.                                                          ADDRTYPE<0> if USE_CSR=1, else MACADD<60>.                                                          In the latter case, ADDRTYPE<0> comes from DPTR<60>.                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the csr value will be used for                                                          ROR, ESR, and NSR. When clear '0' the value in                                                          DPTR will be used. In turn the bits not used for                                                          ROR, ESR, and NSR, will be used for bits [63:60]                                                          of the address used to fetch packet data. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<1> for packet input instruction reads and                                                          gather list (i.e. DPI component) reads from MAC                                                          memory space.                                                          ADDRTYPE<1> is the no-snoop attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for packet input instruction reads and                                                          gather list (i.e. DPI component) reads from MAC                                                          memory space.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<0> for packet input instruction reads and                                                          gather list (i.e. DPI component) reads from MAC                                                          memory space.                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pin_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_39
range|:
literal|16
decl_stmt|;
name|uint64_t
name|prc_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_41_47
range|:
literal|7
decl_stmt|;
name|uint64_t
name|gii_rds
range|:
literal|7
decl_stmt|;
name|uint64_t
name|gii_erst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prd_rds
range|:
literal|7
decl_stmt|;
name|uint64_t
name|prd_erst
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_input_control_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_input_control_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the input packet selection will be                                                          made with a Round Robin arbitration. When '0'                                                          the input packet ring is fixed in priority,                                                          where the lower ring number has higher priority. */
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
comment|/**< PBP_DHI replaces address bits that are used                                                          for parse mode and skip-length when                                                          SLI_PKTi_INSTR_HEADER[PBP]=1.                                                          PBP_DHI becomes either MACADD<63:55> or MACADD<59:51>                                                          for the instruction DPTR reads in this case.                                                          The instruction DPTR reads are called                                                          "First Direct" or "First Indirect" in the HRM.                                                          When PBP=1, if "First Direct" and USE_CSR=0, PBP_DHI                                                          becomes MACADD<59:51>, else MACADD<63:55>. */
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<1> or MACADD<61> for packet input data                                                          reads.                                                          D_NSR becomes either ADDRTYPE<1> or MACADD<61>                                                          for MAC memory space reads of packet input data                                                          fetched for any packet input ring.                                                          ADDRTYPE<1> if USE_CSR=1, else MACADD<61>.                                                          In the latter case, ADDRTYPE<1> comes from DPTR<61>.                                                          ADDRTYPE<1> is the no-snoop attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> or MACADD<63:62> for packet input data                                                          reads.                                                          D_ESR becomes either ES<1:0> or MACADD<63:62>                                                          for MAC memory space reads of packet input data                                                          fetched for any packet input ring.                                                          ES<1:0> if USE_CSR=1, else MACADD<63:62>.                                                          In the latter case, ES<1:0> comes from DPTR<63:62>.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<0> or MACADD<60> for packet input data                                                          reads.                                                          D_ROR becomes either ADDRTYPE<0> or MACADD<60>                                                          for MAC memory space reads of packet input data                                                          fetched for any packet input ring.                                                          ADDRTYPE<0> if USE_CSR=1, else MACADD<60>.                                                          In the latter case, ADDRTYPE<0> comes from DPTR<60>.                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the csr value will be used for                                                          ROR, ESR, and NSR. When clear '0' the value in                                                          DPTR will be used. In turn the bits not used for                                                          ROR, ESR, and NSR, will be used for bits [63:60]                                                          of the address used to fetch packet data. */
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<1> for packet input instruction reads and                                                          gather list (i.e. DPI component) reads from MAC                                                          memory space.                                                          ADDRTYPE<1> is the no-snoop attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
comment|/**< ES<1:0> for packet input instruction reads and                                                          gather list (i.e. DPI component) reads from MAC                                                          memory space.                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
comment|/**< ADDRTYPE<0> for packet input instruction reads and                                                          gather list (i.e. DPI component) reads from MAC                                                          memory space.                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use_csr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_ror
range|:
literal|1
decl_stmt|;
name|uint64_t
name|d_esr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|d_nsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pbp_dhi
range|:
literal|13
decl_stmt|;
name|uint64_t
name|pkt_rr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_sli_pkt_input_control_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_input_control_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_input_control_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_input_control_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_input_control_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_input_control
name|cvmx_sli_pkt_input_control_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_instr_enb  *  * SLI_PKT_INSTR_ENB = SLI's Packet Instruction Enable  *  * Enables the instruction fetch for a Packet-ring.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_instr_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_instr_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
comment|/**< When ENB<i>=1, instruction input ring i is enabled. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_enb_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_instr_enb
name|cvmx_sli_pkt_instr_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_instr_rd_size  *  * SLI_PKT_INSTR_RD_SIZE = SLI Instruction Read Size  *  * The number of instruction allowed to be read at one time.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_instr_rd_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_instr_rd_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rdsize
range|:
literal|64
decl_stmt|;
comment|/**< Number of instructions to be read in one MAC read                                                          request for the 4 ports - 8 rings. Every two bits                                                          (i.e. 1:0, 3:2, 5:4..) are assign to the port/ring                                                          combinations.                                                          - 15:0  PKIPort0,Ring 7..0  31:16 PKIPort1,Ring 7..0                                                          - 47:32 PKIPort2,Ring 7..0  63:48 PKIPort3,Ring 7..0                                                          Two bit value are:                                                          0 - 1 Instruction                                                          1 - 2 Instructions                                                          2 - 3 Instructions                                                          3 - 4 Instructions */
else|#
directive|else
name|uint64_t
name|rdsize
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_rd_size_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_instr_rd_size
name|cvmx_sli_pkt_instr_rd_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_instr_size  *  * SLI_PKT_INSTR_SIZE = SLI's Packet Instruction Size  *  * Determines if instructions are 64 or 32 byte in size for a Packet-ring.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_instr_size
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_instr_size_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|is_64b
range|:
literal|32
decl_stmt|;
comment|/**< When IS_64B<i>=1, instruction input ring i uses 64B                                                          instructions, else 32B instructions. */
else|#
directive|else
name|uint64_t
name|is_64b
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_instr_size_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_instr_size
name|cvmx_sli_pkt_instr_size_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_int_levels  *  * 0x90F0 reserved SLI_PKT_PCIE_PORT2  *  *  *                  SLI_PKT_INT_LEVELS = SLI's Packet Interrupt Levels  *  * Output packet interrupt levels.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_int_levels
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_int_levels_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|time
range|:
literal|22
decl_stmt|;
comment|/**< Output ring counter time interrupt threshold                                                          SLI sets SLI_PKT_TIME_INT[PORT<i>] whenever                                                          SLI_PKTi_CNTS[TIMER]> TIME */
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Output ring counter interrupt threshold                                                          SLI sets SLI_PKT_CNT_INT[PORT<i>] whenever                                                          SLI_PKTi_CNTS[CNT]> CNT */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|22
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_int_levels_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_int_levels
name|cvmx_sli_pkt_int_levels_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_iptr  *  * SLI_PKT_IPTR = SLI's Packet Info Poitner  *  * Controls using the Info-Pointer to store length and data.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_iptr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_iptr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iptr
range|:
literal|32
decl_stmt|;
comment|/**< When IPTR<i>=1, packet output ring i is in info-                                                          pointer mode, else buffer-pointer-only mode. */
else|#
directive|else
name|uint64_t
name|iptr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_iptr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_iptr
name|cvmx_sli_pkt_iptr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_out_bmode  *  * SLI_PKT_OUT_BMODE = SLI's Packet Out Byte Mode  *  * Control the updating of the SLI_PKT#_CNT register.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_out_bmode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_out_bmode_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bmode
range|:
literal|32
decl_stmt|;
comment|/**< Determines whether SLI_PKTi_CNTS[CNT] is a byte or                                                          packet counter.                                                          When BMODE<i>=1, SLI_PKTi_CNTS[CNT] is a byte                                                          counter, else SLI_PKTi_CNTS[CNT] is a packet                                                          counter. */
else|#
directive|else
name|uint64_t
name|bmode
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bmode_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_out_bmode
name|cvmx_sli_pkt_out_bmode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_out_bp_en  *  * SLI_PKT_OUT_BP_EN = SLI Packet Output Backpressure Enable  *  * Enables sending backpressure to the PKO.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_out_bp_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_out_bp_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bp_en
range|:
literal|32
decl_stmt|;
comment|/**< When set '1' enable the ring level backpressure                                                          to be sent to PKO. Backpressure is sent to the                                                          PKO on the PIPE number associated with the ring.                                                          (See SLI_TX_PIPE for ring to pipe associations). */
else|#
directive|else
name|uint64_t
name|bp_en
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_out_bp_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_bp_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_out_bp_en
name|cvmx_sli_pkt_out_bp_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_out_enb  *  * SLI_PKT_OUT_ENB = SLI's Packet Output Enable  *  * Enables the output packet engines.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_out_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_out_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
comment|/**< When ENB<i>=1, packet output ring i is enabled.                                                          If an error occurs on reading pointers for an                                                          output ring, the ring will be disabled by clearing                                                          the bit associated with the ring to '0'. */
else|#
directive|else
name|uint64_t
name|enb
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_out_enb_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_out_enb
name|cvmx_sli_pkt_out_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_output_wmark  *  * SLI_PKT_OUTPUT_WMARK = SLI's Packet Output Water Mark  *  * Value that when the SLI_PKT#_SLIST_BAOFF_DBELL[DBELL] value is less then that backpressure for the rings will be applied.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_output_wmark
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_output_wmark_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
comment|/**< Value when DBELL count drops below backpressure                                                          for the ring will be applied to the PKO. */
else|#
directive|else
name|uint64_t
name|wmark
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_output_wmark_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_output_wmark
name|cvmx_sli_pkt_output_wmark_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_pcie_port  *  * SLI_PKT_PCIE_PORT = SLI's Packet To MAC Port Assignment  *  * Assigns Packet Ports to MAC ports.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_pcie_port
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_pcie_port_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
comment|/**< The physical MAC  port that the output ring uses.                                                          Two bits are used per ring (i.e. ring 0 [1:0],                                                          ring 1 [3:2], ....). A value of '0 means                                                          that the Packetring is assign to MAC Port 0, a '1'                                                          MAC Port 1, '2' and '3' are reserved. */
else|#
directive|else
name|uint64_t
name|pp
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_pcie_port_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_pcie_port
name|cvmx_sli_pkt_pcie_port_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_port_in_rst  *  * 91c0 reserved  * 91d0 reserved  * 91e0 reserved  *  *  *                   SLI_PKT_PORT_IN_RST = SLI Packet Port In Reset  *  *  Vector bits related to ring-port for ones that are reset.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_port_in_rst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_port_in_rst_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|in_rst
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the inbound Packet-ring is in reset. */
name|uint64_t
name|out_rst
range|:
literal|32
decl_stmt|;
comment|/**< When asserted '1' the vector bit cooresponding                                                          to the outbound Packet-ring is in reset. */
else|#
directive|else
name|uint64_t
name|out_rst
range|:
literal|32
decl_stmt|;
name|uint64_t
name|in_rst
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_port_in_rst_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_port_in_rst
name|cvmx_sli_pkt_port_in_rst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_slist_es  *  * SLI_PKT_SLIST_ES = SLI's Packet Scatter List Endian Swap  *  * The Endian Swap for Scatter List Read.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_slist_es
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_slist_es_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
comment|/**< ES<1:0> for the packet output ring reads that                                                          fetch buffer/info pointer pairs.                                                          ES<2i+1:2i> becomes ES<1:0> in DPI/SLI reads that                                                          fetch buffer/info pairs from packet output ring i                                                          (from address SLI_PKTi_SLIST_BADDR+ in MAC memory                                                          space.)                                                          ES<1:0> is the endian-swap attribute for these MAC                                                          memory space reads. */
else|#
directive|else
name|uint64_t
name|es
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_es_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_slist_es
name|cvmx_sli_pkt_slist_es_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_slist_ns  *  * SLI_PKT_SLIST_NS = SLI's Packet Scatter List No Snoop  *  * The NS field for the TLP when fetching Scatter List.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_slist_ns
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_slist_ns_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
comment|/**< ADDRTYPE<1> for the packet output ring reads that                                                          fetch buffer/info pointer pairs.                                                          NSR<i> becomes ADDRTYPE<1> in DPI/SLI reads that                                                          fetch buffer/info pairs from packet output ring i                                                          (from address SLI_PKTi_SLIST_BADDR+ in MAC memory                                                          space.)                                                          ADDRTYPE<1> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
else|#
directive|else
name|uint64_t
name|nsr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ns_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_slist_ns
name|cvmx_sli_pkt_slist_ns_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_slist_ror  *  * SLI_PKT_SLIST_ROR = SLI's Packet Scatter List Relaxed Ordering  *  * The ROR field for the TLP when fetching Scatter List.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_slist_ror
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_slist_ror_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
comment|/**< ADDRTYPE<0> for the packet output ring reads that                                                          fetch buffer/info pointer pairs.                                                          ROR<i> becomes ADDRTYPE<0> in DPI/SLI reads that                                                          fetch buffer/info pairs from packet output ring i                                                          (from address SLI_PKTi_SLIST_BADDR+ in MAC memory                                                          space.)                                                          ADDRTYPE<0> is the relaxed-order attribute for PCIe                                                          , helps select an SRIO*_S2M_TYPE* entry with sRIO. */
else|#
directive|else
name|uint64_t
name|ror
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_slist_ror_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_slist_ror
name|cvmx_sli_pkt_slist_ror_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_time_int  *  * SLI_PKT_TIME_INT = SLI Packet Timer Interrupt  *  * The packets rings that are interrupting because of Packet Timers.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_time_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_time_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Output ring packet timer interrupt bits                                                          SLI sets PORT<i> whenever                                                          SLI_PKTi_CNTS[TIMER]> SLI_PKT_INT_LEVELS[TIME].                                                          SLI_PKT_TIME_INT_ENB[PORT<i>] is the corresponding                                                          enable. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_time_int
name|cvmx_sli_pkt_time_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_pkt_time_int_enb  *  * SLI_PKT_TIME_INT_ENB = SLI Packet Timer Interrupt Enable  *  * The packets rings that are interrupting because of Packet Timers.  */
end_comment

begin_union
union|union
name|cvmx_sli_pkt_time_int_enb
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_pkt_time_int_enb_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
comment|/**< Output ring packet timer interrupt enables                                                          When both PORT<i> and corresponding                                                          SLI_PKT_TIME_INT[PORT<i>] are set, for any i,                                                          then SLI_INT_SUM[PTIME] is set, which can cause                                                          an interrupt. */
else|#
directive|else
name|uint64_t
name|port
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_pkt_time_int_enb_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_pkt_time_int_enb
name|cvmx_sli_pkt_time_int_enb_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_port#_pkind  *  * SLI_PORT[0..31]_PKIND = SLI Port Pkind  *  * The SLI/DPI supports 32 input rings for fetching input packets. This register maps the input-rings (0-31) to a PKIND.  */
end_comment

begin_union
union|union
name|cvmx_sli_portx_pkind
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_portx_pkind_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|rpk_enb
range|:
literal|1
decl_stmt|;
comment|/**< Alternate PKT_INST_HDR PKind Enable for this ring.                                                          When RPK_ENB==1 and DPI prepends                                                          a PKT_INST_HDR to a packet, the pkind for the                                                          packet is PKINDR (rather than PKIND), and any                                                          special PIP/IPD processing of the DPI packet is                                                          disabled (see PIP_PRT_CFG*[INST_HDR,HIGIG_EN]).                                                          (DPI prepends a PKT_INST_HDR when either                                                          DPI_INST_HDR[R]==1 for the packet or                                                          SLI_PKT*_INSTR_HEADER[USE_IHDR]==1 for the ring.)                                                          When RPK_ENB==0, PKIND is the pkind for all                                                          packets through the input ring, and                                                          PIP/IPD will process a DPI packet that has a                                                          PKT_INST_HDR specially. */
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkindr
range|:
literal|6
decl_stmt|;
comment|/**< Port Kind For this Ring used with packets                                                          that include a DPI-prepended PKT_INST_HDR                                                          when RPK_ENB is set. */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpkind
range|:
literal|6
decl_stmt|;
comment|/**< Back-pressure pkind for this Ring. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkind
range|:
literal|6
decl_stmt|;
comment|/**< Port Kind For this Ring. */
else|#
directive|else
name|uint64_t
name|pkind
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpkind
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkindr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_22_23
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rpk_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_portx_pkind_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_sli_portx_pkind_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|bpkind
range|:
literal|6
decl_stmt|;
comment|/**< Back-pressure pkind for this Ring. */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pkind
range|:
literal|6
decl_stmt|;
comment|/**< Port Kind For this Ring. */
else|#
directive|else
name|uint64_t
name|pkind
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpkind
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_portx_pkind
name|cvmx_sli_portx_pkind_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_s2m_port#_ctl  *  * SLI_S2M_PORTX_CTL = SLI's S2M Port 0 Control  *  * Contains control for access from SLI to a MAC port.  * Writes to this register are not ordered with writes/reads to the MAC Memory space.  * To ensure that a write has completed the user must read the register before  * making an access(i.e. MAC memory space) that requires the value of this register to be updated.  */
end_comment

begin_union
union|union
name|cvmx_sli_s2m_portx_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_s2m_portx_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|wind_d
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access to the Window                                                          Registers from the MAC-Port.                                                          When Authenticate-Mode is set the reset value of                                                          this field is "1" else "0'. */
name|uint64_t
name|bar0_d
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' disables access from MAC to                                                          BAR-0 address offsets: Less Than 0x330,                                                          0x3CD0, and greater than 0x3D70 excluding                                                          0x3e00.                                                          When Authenticate-Mode is set the reset value of                                                          this field is "1" else "0'. */
name|uint64_t
name|mrrs
range|:
literal|3
decl_stmt|;
comment|/**< Max Read Request Size                                                                  0 = 128B                                                                  1 = 256B                                                                  2 = 512B                                                                  3 = 1024B                                                                  4 = 2048B                                                                  5-7 = Reserved                                                          This field should not exceed the desired                                                                max read request size. This field is used to                                                                determine if an IOBDMA is too large.                                                          For a PCIe MAC, this field should not exceed                                                                PCIE*_CFG030[MRRS].                                                          For a sRIO MAC, this field should indicate a size                                                                of 256B or smaller. */
else|#
directive|else
name|uint64_t
name|mrrs
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bar0_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wind_d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_s2m_portx_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_s2m_portx_ctl
name|cvmx_sli_s2m_portx_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_scratch_1  *  * SLI_SCRATCH_1 = SLI's Scratch 1  *  * A general purpose 64 bit register for SW use.  */
end_comment

begin_union
union|union
name|cvmx_sli_scratch_1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_scratch_1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< The value in this register is totaly SW dependent. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_scratch_1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_scratch_1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_scratch_1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_scratch_1
name|cvmx_sli_scratch_1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_scratch_2  *  * SLI_SCRATCH_2 = SLI's Scratch 2  *  * A general purpose 64 bit register for SW use.  */
end_comment

begin_union
union|union
name|cvmx_sli_scratch_2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_scratch_2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< The value in this register is totaly SW dependent. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_scratch_2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_scratch_2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_scratch_2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_scratch_2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_scratch_2
name|cvmx_sli_scratch_2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_state1  *  * SLI_STATE1 = SLI State 1  *  * State machines in SLI. For debug.  */
end_comment

begin_union
union|union
name|cvmx_sli_state1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_state1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|cpl1
range|:
literal|12
decl_stmt|;
comment|/**< CPL1 State */
name|uint64_t
name|cpl0
range|:
literal|12
decl_stmt|;
comment|/**< CPL0 State */
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
comment|/**< ARB State */
name|uint64_t
name|csr
range|:
literal|39
decl_stmt|;
comment|/**< CSR State */
else|#
directive|else
name|uint64_t
name|csr
range|:
literal|39
decl_stmt|;
name|uint64_t
name|arb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cpl0
range|:
literal|12
decl_stmt|;
name|uint64_t
name|cpl1
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_state1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_state1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_state1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_state1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_state1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_state1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_state1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_state1
name|cvmx_sli_state1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_state2  *  * SLI_STATE2 = SLI State 2  *  * State machines in SLI. For debug.  */
end_comment

begin_union
union|union
name|cvmx_sli_state2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_state2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nnp1
range|:
literal|8
decl_stmt|;
comment|/**< NNP1 State */
name|uint64_t
name|reserved_47_47
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rac
range|:
literal|1
decl_stmt|;
comment|/**< RAC State */
name|uint64_t
name|csm1
range|:
literal|15
decl_stmt|;
comment|/**< CSM1 State */
name|uint64_t
name|csm0
range|:
literal|15
decl_stmt|;
comment|/**< CSM0 State */
name|uint64_t
name|nnp0
range|:
literal|8
decl_stmt|;
comment|/**< NNP0 State */
name|uint64_t
name|nnd
range|:
literal|8
decl_stmt|;
comment|/**< NND State */
else|#
directive|else
name|uint64_t
name|nnd
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nnp0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|csm0
range|:
literal|15
decl_stmt|;
name|uint64_t
name|csm1
range|:
literal|15
decl_stmt|;
name|uint64_t
name|rac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_47
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nnp1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_state2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_state2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_state2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_state2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_state2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_state2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_state2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_state2
name|cvmx_sli_state2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_state3  *  * SLI_STATE3 = SLI State 3  *  * State machines in SLI. For debug.  */
end_comment

begin_union
union|union
name|cvmx_sli_state3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_state3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|psm1
range|:
literal|15
decl_stmt|;
comment|/**< PSM1 State */
name|uint64_t
name|psm0
range|:
literal|15
decl_stmt|;
comment|/**< PSM0 State */
name|uint64_t
name|nsm1
range|:
literal|13
decl_stmt|;
comment|/**< NSM1 State */
name|uint64_t
name|nsm0
range|:
literal|13
decl_stmt|;
comment|/**< NSM0 State */
else|#
directive|else
name|uint64_t
name|nsm0
range|:
literal|13
decl_stmt|;
name|uint64_t
name|nsm1
range|:
literal|13
decl_stmt|;
name|uint64_t
name|psm0
range|:
literal|15
decl_stmt|;
name|uint64_t
name|psm1
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_state3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_state3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_state3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_state3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_state3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_state3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_state3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_state3
name|cvmx_sli_state3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_tx_pipe  *  * SLI_TX_PIPE = SLI Packet TX Pipe  *  * Contains the starting pipe number and number of pipes used by the SLI packet Output.  * If a packet is recevied from PKO with an out of range PIPE number, the following occurs:  * - SLI_INT_SUM[PIPE_ERR] is set.  * - the out of range pipe value is used for returning credits to the PKO.  * - the PCIe packet engine will treat the PIPE value to be equal to [BASE].  */
end_comment

begin_union
union|union
name|cvmx_sli_tx_pipe
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_tx_pipe_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|nump
range|:
literal|8
decl_stmt|;
comment|/**< Number of pipes the the SLI/DPI supports.                                                          When this value is 4 or less there is a performance                                                          advantage for output packets.                                                          The SLI/DPI can support up to 32 pipes assigned to                                                          packet-rings 0 - 31. */
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|base
range|:
literal|7
decl_stmt|;
comment|/**< When NUMP is non-zero, indicates the base pipe                                                          number the SLI/DPI will accept.                                                          The SLI/DPI will accept pko packets from pipes in                                                          the range of:                                                            BASE .. (BASE+(NUMP-1))                                                          BASE and NUMP must be constrained such that                                                            1) BASE+(NUMP-1)< 127                                                            2) Each used PKO pipe must map to exactly                                                               one ring. Where BASE == ring 0, BASE+1 == to                                                               ring 1, etc                                                            3) The pipe ranges must be consistent with                                                               the PKO configuration. */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|nump
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_tx_pipe_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_tx_pipe_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_tx_pipe
name|cvmx_sli_tx_pipe_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_win_rd_addr  *  * SLI_WIN_RD_ADDR = SLI Window Read Address Register  *  * The address to be read when the SLI_WIN_RD_DATA register is read.  * This register should NOT be used to read SLI_* registers.  */
end_comment

begin_union
union|union
name|cvmx_sli_win_rd_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_win_rd_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
name|uint64_t
name|ld_cmd
range|:
literal|2
decl_stmt|;
comment|/**< The load command sent wit hthe read.                                                          0x3 == Load 8-bytes, 0x2 == Load 4-bytes,                                                          0x1 == Load 2-bytes, 0x0 == Load 1-bytes, */
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but will not be used                                                          in address generation. */
name|uint64_t
name|rd_addr
range|:
literal|48
decl_stmt|;
comment|/**< The address to be read from.                                                          [47:40] = NCB_ID                                                          [39:0]  = Address                                                          When [47:43] == SLI& [42:40] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:24] == RSL_ID                                                               [23:0]  == RSL Register Offset */
else|#
directive|else
name|uint64_t
name|rd_addr
range|:
literal|48
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ld_cmd
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_51_63
range|:
literal|13
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_addr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_win_rd_addr
name|cvmx_sli_win_rd_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_win_rd_data  *  * SLI_WIN_RD_DATA = SLI Window Read Data Register  *  * Reading this register causes a window read operation to take place. Address read is that contained in the SLI_WIN_RD_ADDR  * register.  */
end_comment

begin_union
union|union
name|cvmx_sli_win_rd_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_win_rd_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|rd_data
range|:
literal|64
decl_stmt|;
comment|/**< The read data. */
else|#
directive|else
name|uint64_t
name|rd_data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_rd_data_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_win_rd_data
name|cvmx_sli_win_rd_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_win_wr_addr  *  * Add Lock Register (Set on Read, Clear on write), SW uses to control access to BAR0 space.  *  * Total Address is 16Kb; 0x0000 - 0x3fff, 0x000 - 0x7fe(Reg, every other 8B)  *  * General  5kb; 0x0000 - 0x13ff, 0x000 - 0x27e(Reg-General)  * PktMem  10Kb; 0x1400 - 0x3bff, 0x280 - 0x77e(Reg-General-Packet)  * Rsvd     1Kb; 0x3c00 - 0x3fff, 0x780 - 0x7fe(Reg-NCB Only Mode)  *  *                  SLI_WIN_WR_ADDR = SLI Window Write Address Register  *  * Contains the address to be writen to when a write operation is started by writing the  * SLI_WIN_WR_DATA register (see below).  *  * This register should NOT be used to write SLI_* registers.  */
end_comment

begin_union
union|union
name|cvmx_sli_win_wr_addr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_win_wr_addr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
comment|/**< A 1 or 0 can be written here but this will always                                                          read as '0'. */
name|uint64_t
name|wr_addr
range|:
literal|45
decl_stmt|;
comment|/**< The address that will be written to when the                                                          SLI_WIN_WR_DATA register is written.                                                          [47:40] = NCB_ID                                                          [39:3]  = Address                                                          When [47:43] == SLI& [42:40] == 0 bits [39:0] are:                                                               [39:32] == x, Not Used                                                               [31:24] == RSL_ID                                                               [23:3]  == RSL Register Offset */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wr_addr
range|:
literal|45
decl_stmt|;
name|uint64_t
name|iobit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_addr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_win_wr_addr
name|cvmx_sli_win_wr_addr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_win_wr_data  *  * SLI_WIN_WR_DATA = SLI Window Write Data Register  *  * Contains the data to write to the address located in the SLI_WIN_WR_ADDR Register.  * Writing the least-significant-byte of this register will cause a write operation to take place.  */
end_comment

begin_union
union|union
name|cvmx_sli_win_wr_data
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_win_wr_data_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wr_data
range|:
literal|64
decl_stmt|;
comment|/**< The data to be written. Whenever the LSB of this                                                          register is written, the Window Write will take                                                          place. */
else|#
directive|else
name|uint64_t
name|wr_data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_data_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_win_wr_data
name|cvmx_sli_win_wr_data_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_win_wr_mask  *  * SLI_WIN_WR_MASK = SLI Window Write Mask Register  *  * Contains the mask for the data in the SLI_WIN_WR_DATA Register.  */
end_comment

begin_union
union|union
name|cvmx_sli_win_wr_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_win_wr_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|wr_mask
range|:
literal|8
decl_stmt|;
comment|/**< The data to be written. When a bit is '1'                                                          the corresponding byte will be written. The values                                                          of this field must be contiguos and for 1, 2, 4, or                                                          8 byte operations and aligned to operation size.                                                          A Value of 0 will produce unpredictable results */
else|#
directive|else
name|uint64_t
name|wr_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_win_wr_mask_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_win_wr_mask
name|cvmx_sli_win_wr_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_sli_window_ctl  *  * // *  * // * 81e0 - 82d0 Reserved for future subids  * // *  *  *                   SLI_WINDOW_CTL = SLI's Window Control  *  *  Access to register space on the NCB (caused by Window Reads/Writes) will wait for a period of time specified  *  by this register before timeing out. Because a Window Access can access the RML, which has a fixed timeout of 0xFFFF  *  core clocks, the value of this register should be set to a minimum of 0x200000 to ensure that a timeout to an RML register  *  occurs on the RML 0xFFFF timer before the timeout for a BAR0 access from the MAC.  */
end_comment

begin_union
union|union
name|cvmx_sli_window_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_sli_window_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
comment|/**< Time to wait in core clocks for a                                                          BAR0 access to completeon the NCB                                                          before timing out. A value of 0 will cause no                                                          timeouts. A minimum value of 0x200000 should be                                                          used when this register is not set to 0x0. */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_sli_window_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_sli_window_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_sli_window_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_sli_window_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_sli_window_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_sli_window_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_sli_window_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_sli_window_ctl
name|cvmx_sli_window_ctl_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

