begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pip-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pip.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PIP_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PIP_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PIP_BCK_PRS
value|CVMX_PIP_BCK_PRS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_BCK_PRS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_BCK_PRS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_BCK_PRS
value|(CVMX_ADD_IO_SEG(0x00011800A0000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PIP_BIST_STATUS
value|(CVMX_ADD_IO_SEG(0x00011800A0000000ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PIP_CLKEN
value|CVMX_PIP_CLKEN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_CLKEN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_CLKEN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_CLKEN
value|(CVMX_ADD_IO_SEG(0x00011800A0000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_CRC_CTLX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_CRC_CTLX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_CRC_CTLX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000040ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_CRC_IVX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_CRC_IVX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_CRC_IVX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000050ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_DEC_IPSECX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_DEC_IPSECX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_DEC_IPSECX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000080ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PIP_DSA_SRC_GRP
value|CVMX_PIP_DSA_SRC_GRP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_DSA_SRC_GRP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_DSA_SRC_GRP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000190ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_DSA_SRC_GRP
value|(CVMX_ADD_IO_SEG(0x00011800A0000190ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PIP_DSA_VID_GRP
value|CVMX_PIP_DSA_VID_GRP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_DSA_VID_GRP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_DSA_VID_GRP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000198ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_DSA_VID_GRP
value|(CVMX_ADD_IO_SEG(0x00011800A0000198ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_FRM_LEN_CHKX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_FRM_LEN_CHKX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000180ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_FRM_LEN_CHKX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000180ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PIP_GBL_CFG
value|(CVMX_ADD_IO_SEG(0x00011800A0000028ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PIP_GBL_CTL
value|(CVMX_ADD_IO_SEG(0x00011800A0000020ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_PIP_HG_PRI_QOS
value|CVMX_PIP_HG_PRI_QOS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_HG_PRI_QOS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_HG_PRI_QOS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A00001A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_HG_PRI_QOS
value|(CVMX_ADD_IO_SEG(0x00011800A00001A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PIP_INT_EN
value|(CVMX_ADD_IO_SEG(0x00011800A0000010ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PIP_INT_REG
value|(CVMX_ADD_IO_SEG(0x00011800A0000008ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PIP_IP_OFFSET
value|(CVMX_ADD_IO_SEG(0x00011800A0000060ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_PRT_CFGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_PRT_CFGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000200ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_PRT_CFGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000200ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_PRT_TAGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_PRT_TAGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000400ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_PRT_TAGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000400ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_QOS_DIFFX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_QOS_DIFFX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000600ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_QOS_DIFFX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000600ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_QOS_VLANX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_QOS_VLANX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A00000C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_QOS_VLANX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A00000C0ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_QOS_WATCHX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_QOS_WATCHX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000100ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_QOS_WATCHX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000100ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PIP_RAW_WORD
value|(CVMX_ADD_IO_SEG(0x00011800A00000B0ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PIP_SFT_RST
value|(CVMX_ADD_IO_SEG(0x00011800A0000030ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT0_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT0_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000800ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT0_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000800ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT1_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT1_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000808ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT1_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000808ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT2_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT2_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000810ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT2_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000810ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT3_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT3_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000818ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT3_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000818ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT4_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT4_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000820ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT4_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000820ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT5_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT5_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000828ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT5_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000828ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT6_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT6_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000830ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT6_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000830ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT7_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT7_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000838ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT7_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000838ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT8_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT8_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000840ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT8_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000840ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT9_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT9_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0000848ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT9_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0000848ull) + ((offset)& 63) * 80)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PIP_STAT_CTL
value|(CVMX_ADD_IO_SEG(0x00011800A0000018ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT_INB_ERRSX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT_INB_ERRSX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0001A10ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT_INB_ERRSX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0001A10ull) + ((offset)& 63) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT_INB_OCTSX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT_INB_OCTSX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0001A08ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT_INB_OCTSX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0001A08ull) + ((offset)& 63) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_STAT_INB_PKTSX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|33
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|19
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|32
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|35
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|36
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|39
operator|)
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_STAT_INB_PKTSX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0001A00ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|32
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_STAT_INB_PKTSX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0001A00ull) + ((offset)& 63) * 32)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_TAG_INCX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|63
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_TAG_INCX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0001800ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_TAG_INCX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0001800ull) + ((offset)& 63) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_PIP_TAG_MASK
value|(CVMX_ADD_IO_SEG(0x00011800A0000070ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PIP_TAG_SECRET
value|(CVMX_ADD_IO_SEG(0x00011800A0000068ull))
end_define

begin_define
define|#
directive|define
name|CVMX_PIP_TODO_ENTRY
value|(CVMX_ADD_IO_SEG(0x00011800A0000078ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT0_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT0_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT0_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002000ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT1_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT1_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT1_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002008ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT2_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT2_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT2_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002010ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT3_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT3_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT3_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002018ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT4_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT4_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT4_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002020ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT5_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT5_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT5_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002028ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT6_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT6_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT6_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002030ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT7_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT7_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT7_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002038ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT8_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT8_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT8_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002040ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PIP_XSTAT9_PRTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|>=
literal|40
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|43
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PIP_XSTAT9_PRTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800A0002048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|63
operator|)
operator|*
literal|80
operator|-
literal|80
operator|*
literal|40
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PIP_XSTAT9_PRTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800A0002048ull) + ((offset)& 63) * 80 - 80*40)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pip_bck_prs  *  * PIP_BCK_PRS = PIP's Back Pressure Register  *  * When to assert backpressure based on the todo list filling up  */
end_comment

begin_union
union|union
name|cvmx_pip_bck_prs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_bck_prs_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP is currently asserting backpressure to IOB                                                          Backpressure from PIP will assert when the                                                          entries to the todo list exceed HIWATER.                                                          Backpressure will be held until the todo entries                                                          is less than or equal to LOWATER. */
name|uint64_t
name|reserved_13_62
range|:
literal|50
decl_stmt|;
name|uint64_t
name|hiwater
range|:
literal|5
decl_stmt|;
comment|/**< Water mark in the todo list to assert backpressure                                                          Legal values are 1-26.  A 0 value will deadlock                                                          the machine.  A value> 26, will trash memory */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lowater
range|:
literal|5
decl_stmt|;
comment|/**< Water mark in the todo list to release backpressure                                                          The LOWATER value should be< HIWATER. */
else|#
directive|else
name|uint64_t
name|lowater
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|hiwater
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_62
range|:
literal|50
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_bck_prs_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_bck_prs
name|cvmx_pip_bck_prs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_bist_status  *  * PIP_BIST_STATUS = PIP's BIST Results  *  */
end_comment

begin_union
union|union
name|cvmx_pip_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_bist_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|bist
range|:
literal|18
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          BIST. */
else|#
directive|else
name|uint64_t
name|bist
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_bist_status_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pip_bist_status_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|bist
range|:
literal|17
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          BIST. */
else|#
directive|else
name|uint64_t
name|bist
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pip_bist_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_bist_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_bist_status
name|cvmx_pip_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_clken  */
end_comment

begin_union
union|union
name|cvmx_pip_clken
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_clken_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|clken
range|:
literal|1
decl_stmt|;
comment|/**< Controls the conditional clocking within PIP                                                          0=Allow HW to control the clocks                                                          1=Force the clocks to be always on */
else|#
directive|else
name|uint64_t
name|clken
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_clken_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_clken_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_clken
name|cvmx_pip_clken_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_crc_ctl#  *  * PIP_CRC_CTL = PIP CRC Control Register  *  * Controls datapath reflection when calculating CRC  */
end_comment

begin_union
union|union
name|cvmx_pip_crc_ctlx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_crc_ctlx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|invres
range|:
literal|1
decl_stmt|;
comment|/**< Invert the result */
name|uint64_t
name|reflect
range|:
literal|1
decl_stmt|;
comment|/**< Reflect the bits in each byte.                                                           Byte order does not change.                                                          - 0: CRC is calculated MSB to LSB                                                          - 1: CRC is calculated LSB to MSB */
else|#
directive|else
name|uint64_t
name|reflect
range|:
literal|1
decl_stmt|;
name|uint64_t
name|invres
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_crc_ctlx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_crc_ctlx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_crc_ctlx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_crc_ctlx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_crc_ctlx
name|cvmx_pip_crc_ctlx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_crc_iv#  *  * PIP_CRC_IV = PIP CRC IV Register  *  * Determines the IV used by the CRC algorithm  *  * Notes:  * * PIP_CRC_IV  * PIP_CRC_IV controls the initial state of the CRC algorithm.  Octane can  * support a wide range of CRC algorithms and as such, the IV must be  * carefully constructed to meet the specific algorithm.  The code below  * determines the value to program into Octane based on the algorthim's IV  * and width.  In the case of Octane, the width should always be 32.  *  * PIP_CRC_IV0 sets the IV for ports 0-15 while PIP_CRC_IV1 sets the IV for  * ports 16-31.  *  *  unsigned octane_crc_iv(unsigned algorithm_iv, unsigned poly, unsigned w)  *  [  *    int i;  *    int doit;  *    unsigned int current_val = algorithm_iv;  *  *    for(i = 0; i< w; i++) [  *      doit = current_val& 0x1;  *  *      if(doit) current_val ^= poly;  *      assert(!(current_val& 0x1));  *  *      current_val = (current_val>> 1) | (doit<< (w-1));  *    ]  *  *    return current_val;  *  ]  */
end_comment

begin_union
union|union
name|cvmx_pip_crc_ivx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_crc_ivx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|iv
range|:
literal|32
decl_stmt|;
comment|/**< IV used by the CRC algorithm.  Default is FCS32. */
else|#
directive|else
name|uint64_t
name|iv
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_crc_ivx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_crc_ivx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_crc_ivx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_crc_ivx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_crc_ivx
name|cvmx_pip_crc_ivx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_dec_ipsec#  *  * PIP_DEC_IPSEC = UDP or TCP ports to watch for DEC IPSEC  *  * PIP sets the dec_ipsec based on TCP or UDP destination port.  */
end_comment

begin_union
union|union
name|cvmx_pip_dec_ipsecx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_dec_ipsecx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|tcp
range|:
literal|1
decl_stmt|;
comment|/**< This DPRT should be used for TCP packets */
name|uint64_t
name|udp
range|:
literal|1
decl_stmt|;
comment|/**< This DPRT should be used for UDP packets */
name|uint64_t
name|dprt
range|:
literal|16
decl_stmt|;
comment|/**< UDP or TCP destination port to match on */
else|#
directive|else
name|uint64_t
name|dprt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|udp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tcp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_dec_ipsecx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_dec_ipsecx
name|cvmx_pip_dec_ipsecx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_dsa_src_grp  */
end_comment

begin_union
union|union
name|cvmx_pip_dsa_src_grp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_dsa_src_grp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|map15
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map14
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map13
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map12
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map11
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map10
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map9
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map8
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map7
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map6
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map5
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map4
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map3
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map2
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map1
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map0
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA source id to compute GRP */
else|#
directive|else
name|uint64_t
name|map0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map9
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map10
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map12
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map13
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map14
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map15
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_dsa_src_grp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_dsa_src_grp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_dsa_src_grp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_dsa_src_grp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_dsa_src_grp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_dsa_src_grp
name|cvmx_pip_dsa_src_grp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_dsa_vid_grp  */
end_comment

begin_union
union|union
name|cvmx_pip_dsa_vid_grp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_dsa_vid_grp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|map15
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map14
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map13
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map12
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map11
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map10
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map9
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map8
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map7
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map6
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map5
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map4
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map3
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map2
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map1
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm */
name|uint64_t
name|map0
range|:
literal|4
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA source id to compute GRP */
else|#
directive|else
name|uint64_t
name|map0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map3
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map4
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map9
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map10
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map11
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map12
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map13
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map14
range|:
literal|4
decl_stmt|;
name|uint64_t
name|map15
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_dsa_vid_grp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_dsa_vid_grp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_dsa_vid_grp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_dsa_vid_grp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_dsa_vid_grp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_dsa_vid_grp
name|cvmx_pip_dsa_vid_grp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_frm_len_chk#  *  * Notes:  * PIP_FRM_LEN_CHK0 is used for packets on packet interface0, PCI, PCI RAW, and PKO loopback ports.  * PIP_FRM_LEN_CHK1 is unused.  */
end_comment

begin_union
union|union
name|cvmx_pip_frm_len_chkx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_frm_len_chkx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|maxlen
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for Max-sized frame check                                                          PIP_PRT_CFGn[MAXERR_EN] enables the check for                                                          port n.                                                          If enabled, failing packets set the MAXERR                                                          interrupt and work-queue entry WORD2[opcode] is                                                          set to OVER_FCS (0x3, if packet has bad FCS) or                                                          OVER_ERR (0x4, if packet has good FCS).                                                          The effective MAXLEN used by HW is                                                          PIP_PRT_CFG[DSA_EN] == 0,                                                           PIP_FRM_LEN_CHK[MAXLEN] + 4*VV + 4*VS                                                          PIP_PRT_CFG[DSA_EN] == 1,                                                           PIP_FRM_LEN_CHK[MAXLEN] + PIP_PRT_CFG[SKIP]+4*VS                                                          If PTP_MODE, the 8B timestamp is prepended to the                                                           packet.  MAXLEN should be increased by 8 to                                                           compensate for the additional timestamp field. */
name|uint64_t
name|minlen
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for Min-sized frame check                                                          PIP_PRT_CFGn[MINERR_EN] enables the check for                                                          port n.                                                          If enabled, failing packets set the MINERR                                                          interrupt and work-queue entry WORD2[opcode] is                                                          set to UNDER_FCS (0x6, if packet has bad FCS) or                                                          UNDER_ERR (0x8, if packet has good FCS).                                                          If PTP_MODE, the 8B timestamp is prepended to the                                                           packet.  MINLEN should be increased by 8 to                                                           compensate for the additional timestamp field. */
else|#
directive|else
name|uint64_t
name|minlen
range|:
literal|16
decl_stmt|;
name|uint64_t
name|maxlen
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_frm_len_chkx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_frm_len_chkx
name|cvmx_pip_frm_len_chkx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_gbl_cfg  *  * PIP_GBL_CFG = PIP's Global Config Register  *  * Global config information that applies to all ports.  *  * Notes:  * * IP6_UDP  * IPv4 allows optional UDP checksum by sending the all 0's patterns.  IPv6  * outlaws this and the spec says to always check UDP checksum.  This mode  * bit allows the user to treat IPv6 as IPv4, meaning that the all 0's  * pattern will cause a UDP checksum pass.  */
end_comment

begin_union
union|union
name|cvmx_pip_gbl_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_gbl_cfg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|tag_syn
range|:
literal|1
decl_stmt|;
comment|/**< Do not include src_crc for TCP/SYN&!ACK packets                                                          0 = include src_crc                                                          1 = tag hash is dst_crc for TCP/SYN&!ACK packets */
name|uint64_t
name|ip6_udp
range|:
literal|1
decl_stmt|;
comment|/**< IPv6/UDP checksum is not optional                                                          0 = Allow optional checksum code                                                          1 = Do not allow optional checksum code */
name|uint64_t
name|max_l2
range|:
literal|1
decl_stmt|;
comment|/**< Config bit to choose the largest L2 frame size                                                          Chooses the value of the L2 Type/Length field                                                          to classify the frame as length.                                                          0 = 1500 / 0x5dc                                                          1 = 1535 / 0x5ff */
name|uint64_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint64_t
name|raw_shf
range|:
literal|3
decl_stmt|;
comment|/**< RAW Packet shift amount                                                          Number of bytes to pad a RAW packet. */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|nip_shf
range|:
literal|3
decl_stmt|;
comment|/**< Non-IP shift amount                                                          Number of bytes to pad a packet that has been                                                          classified as not IP. */
else|#
directive|else
name|uint64_t
name|nip_shf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|raw_shf
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_15
range|:
literal|5
decl_stmt|;
name|uint64_t
name|max_l2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_udp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_syn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_cfg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_gbl_cfg
name|cvmx_pip_gbl_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_gbl_ctl  *  * PIP_GBL_CTL = PIP's Global Control Register  *  * Global control information.  These are the global checker enables for  * IPv4/IPv6 and TCP/UDP parsing.  The enables effect all ports.  *  * Notes:  * The following text describes the conditions in which each checker will  * assert and flag an exception.  By disabling the checker, the exception will  * not be flagged and the packet will be parsed as best it can.  Note, by  * disabling conditions, packets can be parsed incorrectly (.i.e. IP_MAL and  * L4_MAL could cause bits to be seen in the wrong place.  IP_CHK and L4_CHK  * means that the packet was corrupted).  *  * * IP_CHK  *   Indicates that an IPv4 packet contained an IPv4 header checksum  *   violations.  Only applies to packets classified as IPv4.  *  * * IP_MAL  *   Indicates that the packet was malformed.  Malformed packets are defined as  *   packets that are not long enough to cover the IP header or not long enough  *   to cover the length in the IP header.  *  * * IP_HOP  *   Indicates that the IPv4 TTL field or IPv6 HOP field is zero.  *  * * IP4_OPTS  *   Indicates the presence of IPv4 options.  It is set when the length != 5.  *   This only applies to packets classified as IPv4.  *  * * IP6_EEXT  *   Indicate the presence of IPv6 early extension headers.  These bits only  *   apply to packets classified as IPv6.  Bit 0 will flag early extensions  *   when next_header is any one of the following...  *  *         - hop-by-hop (0)  *         - destination (60)  *         - routing (43)  *  *   Bit 1 will flag early extentions when next_header is NOT any of the  *   following...  *  *         - TCP (6)  *         - UDP (17)  *         - fragmentation (44)  *         - ICMP (58)  *         - IPSEC ESP (50)  *         - IPSEC AH (51)  *         - IPCOMP  *  * * L4_MAL  *   Indicates that a TCP or UDP packet is not long enough to cover the TCP or  *   UDP header.  *  * * L4_PRT  *   Indicates that a TCP or UDP packet has an illegal port number - either the  *   source or destination port is zero.  *  * * L4_CHK  *   Indicates that a packet classified as either TCP or UDP contains an L4  *   checksum failure  *  * * L4_LEN  *   Indicates that the TCP or UDP length does not match the the IP length.  *  * * TCP_FLAG  *   Indicates any of the following conditions...  *  *         [URG, ACK, PSH, RST, SYN, FIN] : tcp_flag  *         6'b000001: (FIN only)  *         6'b000000: (0)  *         6'bxxx1x1: (RST+FIN+*)  *         6'b1xxx1x: (URG+SYN+*)  *         6'bxxx11x: (RST+SYN+*)  *         6'bxxxx11: (SYN+FIN+*)  */
end_comment

begin_union
union|union
name|cvmx_pip_gbl_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_gbl_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|ihmsk_dis
range|:
literal|1
decl_stmt|;
comment|/**< Instruction Header Mask Disable                                                          0=Allow NTAG,NTT,NGRP,NQOS bits in the                                                            instruction header to control which fields from                                                            the instruction header are used for WQE WORD2.                                                          1=Ignore the NTAG,NTT,NGRP,NQOS bits in the                                                            instruction header and act as if these fields                                                            were zero.  Thus always use the TAG,TT,GRP,QOS                                                            (depending on the instruction header length)                                                            from the instruction header for the WQE WORD2. */
name|uint64_t
name|dsa_grp_tvid
range|:
literal|1
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA source id to compute GRP */
name|uint64_t
name|dsa_grp_scmd
range|:
literal|1
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA source id to compute GRP when the                                                          DSA tag command to TO_CPU */
name|uint64_t
name|dsa_grp_sid
range|:
literal|1
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA VLAN id to compute GRP */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PCIe ring information in WQE */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the PKT_INST_HDR[RS] bit when set                                                          Does not apply to PCI ports (32-35)                                                          When using 2-byte instruction header words,                                                          either PIP_PRT_CFG[DYN_RS] or IGNRS should be set */
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
comment|/**< Which DSA/VLAN CFI/ID to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
comment|/**< Which DSA/VLAN priority to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable L2 malformed packet check */
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP flags checks */
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP length check */
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP checksum check */
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP illegal port check */
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP malformed packet check */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
comment|/**< Enable IPv6 early extension headers */
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 options check */
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
comment|/**< Enable TTL (IPv4) / hop (IPv6) check */
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable malformed check */
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 header checksum check */
else|#
directive|else
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dsa_grp_sid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsa_grp_scmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsa_grp_tvid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ihmsk_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_gbl_ctl_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the PKT_INST_HDR[RS] bit when set                                                          Only applies to the packet interface prts (0-31)                                                          When using 2-byte instruction header words,                                                          either PIP_PRT_CFG[DYN_RS] or IGNRS should be set */
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
comment|/**< Which VLAN CFI and ID to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
comment|/**< Which VLAN priority to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable L2 malformed packet check */
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP flags checks */
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP length check */
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP checksum check */
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP illegal port check */
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP malformed packet check */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
comment|/**< Enable IPv6 early extension headers */
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 options check */
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
comment|/**< Enable TTL (IPv4) / hop (IPv6) check */
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable malformed check */
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 header checksum check */
else|#
directive|else
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_gbl_ctl_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_cn30xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_pip_gbl_ctl_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|dsa_grp_tvid
range|:
literal|1
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA source id to compute GRP */
name|uint64_t
name|dsa_grp_scmd
range|:
literal|1
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA source id to compute GRP when the                                                          DSA tag command to TO_CPU */
name|uint64_t
name|dsa_grp_sid
range|:
literal|1
decl_stmt|;
comment|/**< DSA Group Algorithm                                                          Use the DSA VLAN id to compute GRP */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PCIe ring information in WQE */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the PKT_INST_HDR[RS] bit when set                                                          Does not apply to PCI ports (32-35)                                                          When using 2-byte instruction header words,                                                          either PIP_PRT_CFG[DYN_RS] or IGNRS should be set */
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
comment|/**< Which DSA/VLAN CFI/ID to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
comment|/**< Which DSA/VLAN priority to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable L2 malformed packet check */
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP flags checks */
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP length check */
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP checksum check */
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP illegal port check */
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP malformed packet check */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
comment|/**< Enable IPv6 early extension headers */
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 options check */
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
comment|/**< Enable TTL (IPv4) / hop (IPv6) check */
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable malformed check */
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 header checksum check */
else|#
directive|else
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dsa_grp_sid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsa_grp_scmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsa_grp_tvid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pip_gbl_ctl_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_cn52xx
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_pip_gbl_ctl_cn56xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PCIe ring information in WQE */
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the PKT_INST_HDR[RS] bit when set                                                          Does not apply to PCI ports (32-35)                                                          When using 2-byte instruction header words,                                                          either PIP_PRT_CFG[DYN_RS] or IGNRS should be set */
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
comment|/**< Which VLAN CFI and ID to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
comment|/**< Which VLAN priority to use when VLAN Stacking                                                          0=use the 1st (network order) VLAN                                                          1=use the 2nd (network order) VLAN */
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable L2 malformed packet check */
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP flags checks */
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP length check */
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP checksum check */
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP illegal port check */
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable TCP/UDP malformed packet check */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
comment|/**< Enable IPv6 early extension headers */
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 options check */
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
comment|/**< Enable TTL (IPv4) / hop (IPv6) check */
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
comment|/**< Enable malformed check */
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
comment|/**< Enable IPv4 header checksum check */
else|#
directive|else
name|uint64_t
name|ip_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip_hop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_opts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_eext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l4_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_prt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l4_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tcp_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2_mal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_qos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vs_wqe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ignrs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_19
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ring_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
name|struct
name|cvmx_pip_gbl_ctl_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_gbl_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_gbl_ctl
name|cvmx_pip_gbl_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_hg_pri_qos  *  * Notes:  * This register controls accesses to the HG_QOS_TABLE.  To write an entry of  * the table, write PIP_HG_PRI_QOS with PRI=table address, QOS=priority level,  * UP_QOS=1.  To read an entry of the table, write PIP_HG_PRI_QOS with  * PRI=table address, QOS=dont_carepriority level, UP_QOS=0 and then read  * PIP_HG_PRI_QOS.  The table data will be in PIP_HG_PRI_QOS[QOS].  */
end_comment

begin_union
union|union
name|cvmx_pip_hg_pri_qos
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_hg_pri_qos_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|up_qos
range|:
literal|1
decl_stmt|;
comment|/**< When written to '1', updates the entry in the                                                          HG_QOS_TABLE as specified by PRI to a value of                                                          QOS as follows                                                          HG_QOS_TABLE[PRI] = QOS */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< QOS Map level to priority */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pri
range|:
literal|6
decl_stmt|;
comment|/**< The priority level from HiGig header                                                          HiGig/HiGig+ PRI = [1'b0, CNG[1:0], COS[2:0]]                                                          HiGig2       PRI = [DP[1:0], TC[3:0]] */
else|#
directive|else
name|uint64_t
name|pri
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|up_qos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_hg_pri_qos_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_hg_pri_qos_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_hg_pri_qos_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_hg_pri_qos_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_hg_pri_qos_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_hg_pri_qos
name|cvmx_pip_hg_pri_qos_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_int_en  *  * PIP_INT_EN = PIP's Interrupt Enable Register  *  * Determines if hardward should raise an interrupt to software  * when an exception event occurs.  */
end_comment

begin_union
union|union
name|cvmx_pip_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_int_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length<=4B when CRC                                                          stripping in IPD is enable */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow (see PIP_BCK_PRS[HIWATER]) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_int_en_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow                                                          (not used in O2P) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure                                                          (not used in O2P) */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC                                                          (not used in O2P) */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_int_en_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_int_en_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_int_en_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pip_int_en_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pip_int_en_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length<=4B when CRC                                                          stripping in IPD is enable */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pip_int_en_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_int_en_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_pip_int_en_cn56xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow (see PIP_BCK_PRS[HIWATER]) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC                                                          (Disabled in 56xx) */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
struct|struct
name|cvmx_pip_int_en_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length<=4B when CRC                                                          stripping in IPD is enable */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow (see PIP_BCK_PRS[HIWATER]) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_pip_int_en_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_int_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_int_en
name|cvmx_pip_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_int_reg  *  * PIP_INT_REG = PIP's Interrupt Register  *  * Any exception event that occurs is captured in the PIP_INT_REG.  * PIP_INT_REG will set the exception bit regardless of the value  * of PIP_INT_EN.  PIP_INT_EN only controls if an interrupt is  * raised to software.  *  * Notes:  * * TODOOVR  *   The PIP Todo list stores packets that have been received and require work  *   queue entry generation.  PIP will normally assert backpressure when the  *   list fills up such that any error is normally is result of a programming  *   the PIP_BCK_PRS[HIWATER] incorrectly.  PIP itself can handle 29M  *   packets/sec X500MHz or 15Gbs X 64B packets.  *  * * SKPRUNT  *   If a packet size is less then the amount programmed in the per port  *   skippers, then there will be nothing to parse and the entire packet will  *   basically be skipped over.  This is probably not what the user desired, so  *   there is an indication to software.  *  * * BADTAG  *   A tag is considered bad when it is resued by a new packet before it was  *   released by PIP.  PIP considers a tag released by one of two methods.  *   . QOS dropped so that it is released over the pip__ipd_release bus.  *   . WorkQ entry is validated by the pip__ipd_done signal  *  * * PRTNXA  *   If PIP receives a packet that is not in the valid port range, the port  *   processed will be mapped into the valid port space (the mapping is  *   currently unpredictable) and the PRTNXA bit will be set.  PRTNXA will be  *   set for packets received under the following conditions:  *  *   * packet ports (ports 0-31)  *     - GMX_INF_MODE[TYPE]==0 (SGMII), received port is 4-15 or 20-31  *     - GMX_INF_MODE[TYPE]==1 (XAUI),  received port is 1-15 or 17-31  *   * upper ports (pci and loopback ports 32-63)  *     - received port is 40-47 or 52-63  *  * * BCKPRS  *   PIP can assert backpressure to the receive logic when the todo list  *   exceeds a high-water mark (see PIP_BCK_PRS for more details).  When this  *   occurs, PIP can raise an interrupt to software.  *  * * CRCERR  *   Octane can compute CRC in two places.  Each RGMII port will compute its  *   own CRC, but PIP can provide an additional check or check loopback or  *   PCI ports. If PIP computes a bad CRC, then PIP will raise an interrupt.  *  * * PKTDRP  *   PIP can drop packets based on QOS results received from IPD.  If the QOS  *   algorithm decides to drop a packet, PIP will assert an interrupt.  */
end_comment

begin_union
union|union
name|cvmx_pip_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_int_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length<=4B when CRC                                                          stripping in IPD is enable */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow (see PIP_BCK_PRS[HIWATER]) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper                                                          This interrupt can occur with received PARTIAL                                                          packets that are truncated to SKIP bytes or                                                          smaller. */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_int_reg_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow                                                          (not used in O2P) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper                                                          This interrupt can occur with received PARTIAL                                                          packets that are truncated to SKIP bytes or                                                          smaller. */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure                                                          (not used in O2P) */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC                                                          (not used in O2P) */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_int_reg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_int_reg_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_int_reg_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pip_int_reg_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper                                                          This interrupt can occur with received PARTIAL                                                          packets that are truncated to SKIP bytes or                                                          smaller. */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_pip_int_reg_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length<=4B when CRC                                                          stripping in IPD is enable */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper                                                          This interrupt can occur with received PARTIAL                                                          packets that are truncated to SKIP bytes or                                                          smaller. */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pip_int_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_int_reg_s
name|cn56xx
decl_stmt|;
struct|struct
name|cvmx_pip_int_reg_cn56xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow (see PIP_BCK_PRS[HIWATER]) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper                                                          This interrupt can occur with received PARTIAL                                                          packets that are truncated to SKIP bytes or                                                          smaller. */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC                                                          (Disabled in 56xx) */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xxp1
struct|;
struct|struct
name|cvmx_pip_int_reg_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length<=4B when CRC                                                          stripping in IPD is enable */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in back end memory */
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error in front end memory */
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
comment|/**< Todo list overflow (see PIP_BCK_PRS[HIWATER]) */
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
comment|/**< Packet was engulfed by skipper                                                          This interrupt can occur with received PARTIAL                                                          packets that are truncated to SKIP bytes or                                                          smaller. */
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
comment|/**< A bad tag was sent from IPD */
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
comment|/**< Non-existent port */
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
comment|/**< PIP asserted backpressure */
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
comment|/**< PIP calculated bad CRC */
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
comment|/**< Packet Dropped due to QOS */
else|#
directive|else
name|uint64_t
name|pktdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crcerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bckprs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtnxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|badtag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skprunt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|todoovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|feperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|beperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|punyerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_pip_int_reg_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_int_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_int_reg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_int_reg
name|cvmx_pip_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_ip_offset  *  * PIP_IP_OFFSET = Location of the IP in the workQ entry  *  * An 8-byte offset to find the start of the IP header in the data portion of IP workQ entires  *  * Notes:  * In normal configurations, OFFSET must be set in the 0..4 range to allow the  * entire IP and TCP/UDP headers to be buffered in HW and calculate the L4  * checksum for TCP/UDP packets.  *  * The MAX value of OFFSET is determined by the the types of packets that can  * be sent to PIP as follows...  *  * Packet Type              MAX OFFSET  * IPv4/TCP/UDP             7  * IPv6/TCP/UDP             5  * IPv6/without L4 parsing  6  *  * If the L4 can be ignored, then the MAX OFFSET for IPv6 packets can increase  * to 6.  Here are the following programming restrictions for IPv6 packets and  * OFFSET==6:  *  *  . PIP_GBL_CTL[TCP_FLAG] == 0  *  . PIP_GBL_CTL[L4_LEN]   == 0  *  . PIP_GBL_CTL[L4_CHK]   == 0  *  . PIP_GBL_CTL[L4_PRT]   == 0  *  . PIP_GBL_CTL[L4_MAL]   == 0  *  . PIP_DEC_IPSEC[TCP]    == 0  *  . PIP_DEC_IPSEC[UDP]    == 0  *  . PIP_PRT_TAG[IP6_DPRT] == 0  *  . PIP_PRT_TAG[IP6_SPRT] == 0  *  . PIP_PRT_TAG[TCP6_TAG] == 0  *  . PIP_GBL_CFG[TAG_SYN]  == 0  */
end_comment

begin_union
union|union
name|cvmx_pip_ip_offset
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_ip_offset_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|3
decl_stmt|;
comment|/**< Number of 8B ticks to include in workQ entry                                                           prior to IP data                                                          - 0:  0 Bytes / IP start at WORD4 of workQ entry                                                          - 1:  8 Bytes / IP start at WORD5 of workQ entry                                                          - 2: 16 Bytes / IP start at WORD6 of workQ entry                                                          - 3: 24 Bytes / IP start at WORD7 of workQ entry                                                          - 4: 32 Bytes / IP start at WORD8 of workQ entry                                                          - 5: 40 Bytes / IP start at WORD9 of workQ entry                                                          - 6: 48 Bytes / IP start at WORD10 of workQ entry                                                          - 7: 56 Bytes / IP start at WORD11 of workQ entry */
else|#
directive|else
name|uint64_t
name|offset
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_ip_offset_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_ip_offset
name|cvmx_pip_ip_offset_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_prt_cfg#  *  * PIP_PRT_CFGX = Per port config information  *  */
end_comment

begin_union
union|union
name|cvmx_pip_prt_cfgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_prt_cfgx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_53_63
range|:
literal|11
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for pkts with                                                          padding in the client data */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for DSA/VLAN                                                          pkts */
name|uint64_t
name|lenerr_en
range|:
literal|1
decl_stmt|;
comment|/**< L2 length error check enable                                                          Frame was received with length error                                                           Typically, this check will not be enabled for                                                           incoming packets on the PCIe ports. */
name|uint64_t
name|maxerr_en
range|:
literal|1
decl_stmt|;
comment|/**< Max frame error check enable                                                          Frame was received with length> max_length */
name|uint64_t
name|minerr_en
range|:
literal|1
decl_stmt|;
comment|/**< Min frame error check enable                                                          Frame was received with length< min_length                                                           Typically, this check will not be enabled for                                                           incoming packets on the PCIe ports. */
name|uint64_t
name|grp_wat_47
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable                                                          (Watchers 4-7) */
name|uint64_t
name|qos_wat_47
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable                                                          (Watchers 4-7) */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
comment|/**< Allow the IPD to RED drop a packet.                                                          Normally, IPD will never drop a packet that PIP                                                          indicates is RAW.                                                          0=never drop RAW packets based on RED algorithm                                                          1=allow RAW packet drops based on RED algorithm */
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
comment|/**< Which of the 4 PIP_TAG_INC to use when                                                          calculating mask tag hash */
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
comment|/**< Dynamically calculate RS based on pkt size and                                                          configuration.  If DYN_RS is set then                                                          PKT_INST_HDR[RS] is not used.  When using 2-byte                                                          instruction header words, either DYN_RS or                                                          PIP_GBL_CTL[IGNRS] should be set. */
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
comment|/**< 8-byte INST_HDR is present on all packets                                                          (not for PCI prts, 32-35)                                                          Must be zero in DSA mode */
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable */
name|uint64_t
name|hg_qos
range|:
literal|1
decl_stmt|;
comment|/**< When set, uses the HiGig priority bits as a                                                          lookup into the HG_QOS_TABLE (PIP_HG_PRI_QOS)                                                          to determine the QOS value                                                          HG_QOS must not be set when HIGIG_EN=0 */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Default QOS level of the port */
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable                                                          (Watchers 0-3) */
name|uint64_t
name|qos_vsel
range|:
literal|1
decl_stmt|;
comment|/**< Which QOS in PIP_QOS_VLAN to use                                                          0 = PIP_QOS_VLAN[QOS]                                                          1 = PIP_QOS_VLAN[QOS1] */
name|uint64_t
name|qos_vod
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN over Diffserv                                                          if DSA/VLAN exists, it is used                                                          else if IP exists, Diffserv is used                                                          else the per port default is used                                                          Watchers are still highest priority */
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
comment|/**< QOS Diffserv */
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
comment|/**< CRC Checking enabled */
name|uint64_t
name|higig_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable HiGig parsing                                                          Should not be set for PCIe ports (ports 32-35)                                                          Should not be set for ports in which PTP_MODE=1                                                          When HIGIG_EN=1:                                                           DSA_EN field below must be zero                                                           SKIP field below is both Skip I size and the                                                             size of the HiGig* header (12 or 16 bytes) */
name|uint64_t
name|dsa_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable DSA tag parsing                                                          When DSA_EN=1:                                                           HIGIG_EN field above must be zero                                                           SKIP field below is size of DSA tag (4, 8, or                                                             12 bytes) rather than the size of Skip I                                                           total SKIP (Skip I + header + Skip II                                                             must be zero                                                           INST_HDR field above must be zero (non-PCIe                                                             ports)                                                           For PCIe ports, NPEI_PKT*_INSTR_HDR[USE_IHDR]                                                             and PCIE_INST_HDR[R] should be clear                                                           MODE field below must be "skip to L2" */
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode                                                          0 = no packet inspection (Uninterpreted)                                                          1 = L2 parsing / skip to L2                                                          2 = IP parsing / skip to L3                                                          3 = (illegal)                                                          Must be 2 ("skip to L2") when in DSA mode. */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
comment|/**< Optional Skip I amount for packets.  Does not                                                          apply to packets on PCI ports when a PKT_INST_HDR                                                          is present.  See section 7.2.7 - Legal Skip                                                          Values for further details.                                                          In DSA mode, indicates the DSA header length, not                                                            Skip I size. (Must be 4,8,or 12)                                                          In HIGIG mode, indicates both the Skip I size and                                                            the HiGig header size (Must be 12 or 16).                                                          If PTP_MODE, the 8B timestamp is prepended to the                                                           packet.  SKIP should be increased by 8 to                                                           compensate for the additional timestamp field. */
else|#
directive|else
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dsa_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|higig_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_vod
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_vsel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|hg_qos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_wat_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|grp_wat_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|minerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_53_63
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_prt_cfgx_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
comment|/**< Allow the IPD to RED drop a packet.                                                          Normally, IPD will never drop a packet that PIP                                                          indicates is RAW.                                                          0=never drop RAW packets based on RED algorithm                                                          1=allow RAW packet drops based on RED algorithm */
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
comment|/**< Which of the 4 PIP_TAG_INC to use when                                                          calculating mask tag hash */
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
comment|/**< Dynamically calculate RS based on pkt size and                                                          configuration.  If DYN_RS is set then                                                          PKT_INST_HDR[RS] is not used.  When using 2-byte                                                          instruction header words, either DYN_RS or                                                          PIP_GBL_CTL[IGNRS] should be set. */
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
comment|/**< 8-byte INST_HDR is present on all packets                                                          (not for PCI prts, 32-35) */
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Default QOS level of the port */
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
comment|/**< QOS Diffserv */
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode                                                          0 = no packet inspection (Uninterpreted)                                                          1 = L2 parsing / skip to L2                                                          2 = IP parsing / skip to L3                                                          3 = PCI Raw (illegal for software to set) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
comment|/**< Optional Skip I amount for packets.  Does not                                                          apply to packets on PCI ports when a PKT_INST_HDR                                                          is present.  See section 7.2.7 - Legal Skip                                                          Values for further details. */
else|#
directive|else
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_prt_cfgx_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_pip_prt_cfgx_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
comment|/**< Allow the IPD to RED drop a packet.                                                          Normally, IPD will never drop a packet that PIP                                                          indicates is RAW.                                                          0=never drop RAW packets based on RED algorithm                                                          1=allow RAW packet drops based on RED algorithm */
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
comment|/**< Which of the 4 PIP_TAG_INC to use when                                                          calculating mask tag hash */
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
comment|/**< Dynamically calculate RS based on pkt size and                                                          configuration.  If DYN_RS is set then                                                          PKT_INST_HDR[RS] is not used.  When using 2-byte                                                          instruction header words, either DYN_RS or                                                          PIP_GBL_CTL[IGNRS] should be set. */
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
comment|/**< 8-byte INST_HDR is present on all packets                                                          (not for PCI prts, 32-35) */
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Default QOS level of the port */
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
comment|/**< QOS Diffserv */
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
comment|/**< CRC Checking enabled (for ports 0-31 only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode                                                          0 = no packet inspection (Uninterpreted)                                                          1 = L2 parsing / skip to L2                                                          2 = IP parsing / skip to L3                                                          3 = PCI Raw (illegal for software to set) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
comment|/**< Optional Skip I amount for packets.  Does not                                                          apply to packets on PCI ports when a PKT_INST_HDR                                                          is present.  See section 7.2.7 - Legal Skip                                                          Values for further details. */
else|#
directive|else
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_pip_prt_cfgx_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_pip_prt_cfgx_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_53_63
range|:
literal|11
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for pkts with                                                          padding in the client data */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|lenerr_en
range|:
literal|1
decl_stmt|;
comment|/**< L2 length error check enable                                                          Frame was received with length error */
name|uint64_t
name|maxerr_en
range|:
literal|1
decl_stmt|;
comment|/**< Max frame error check enable                                                          Frame was received with length> max_length */
name|uint64_t
name|minerr_en
range|:
literal|1
decl_stmt|;
comment|/**< Min frame error check enable                                                          Frame was received with length< min_length */
name|uint64_t
name|grp_wat_47
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable                                                          (Watchers 4-7) */
name|uint64_t
name|qos_wat_47
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable                                                          (Watchers 4-7) */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
comment|/**< Allow the IPD to RED drop a packet.                                                          Normally, IPD will never drop a packet that PIP                                                          indicates is RAW.                                                          0=never drop RAW packets based on RED algorithm                                                          1=allow RAW packet drops based on RED algorithm */
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
comment|/**< Which of the 4 PIP_TAG_INC to use when                                                          calculating mask tag hash */
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
comment|/**< Dynamically calculate RS based on pkt size and                                                          configuration.  If DYN_RS is set then                                                          PKT_INST_HDR[RS] is not used.  When using 2-byte                                                          instruction header words, either DYN_RS or                                                          PIP_GBL_CTL[IGNRS] should be set. */
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
comment|/**< 8-byte INST_HDR is present on all packets                                                          (not for PCI prts, 32-35) */
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Default QOS level of the port */
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable                                                          (Watchers 0-3) */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_vod
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN over Diffserv                                                          if VLAN exists, it is used                                                          else if IP exists, Diffserv is used                                                          else the per port default is used                                                          Watchers are still highest priority */
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
comment|/**< QOS Diffserv */
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
comment|/**< CRC Checking enabled                                                          (Disabled in 5020) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode                                                          0 = no packet inspection (Uninterpreted)                                                          1 = L2 parsing / skip to L2                                                          2 = IP parsing / skip to L3                                                          3 = PCI Raw (illegal for software to set) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
comment|/**< Optional Skip I amount for packets.  Does not                                                          apply to packets on PCI ports when a PKT_INST_HDR                                                          is present.  See section 7.2.7 - Legal Skip                                                          Values for further details. */
else|#
directive|else
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_vod
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_wat_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|grp_wat_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|minerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_53_63
range|:
literal|11
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_pip_prt_cfgx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_cfgx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_prt_cfgx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_cfgx_cn50xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_pip_prt_cfgx_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
comment|/**< Allow the IPD to RED drop a packet.                                                          Normally, IPD will never drop a packet that PIP                                                          indicates is RAW.                                                          0=never drop RAW packets based on RED algorithm                                                          1=allow RAW packet drops based on RED algorithm */
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
comment|/**< Which of the 4 PIP_TAG_INC to use when                                                          calculating mask tag hash */
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
comment|/**< Dynamically calculate RS based on pkt size and                                                          configuration.  If DYN_RS is set then                                                          PKT_INST_HDR[RS] is not used.  When using 2-byte                                                          instruction header words, either DYN_RS or                                                          PIP_GBL_CTL[IGNRS] should be set. */
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
comment|/**< 8-byte INST_HDR is present on all packets                                                          (not for PCI prts, 32-35) */
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
comment|/**< GRP Watcher enable */
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Default QOS level of the port */
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
comment|/**< QOS Watcher enable */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_vod
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN over Diffserv                                                          if VLAN exists, it is used                                                          else if IP exists, Diffserv is used                                                          else the per port default is used                                                          Watchers are still highest priority */
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
comment|/**< QOS Diffserv */
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
comment|/**< QOS VLAN */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
comment|/**< CRC Checking enabled (for ports 0-31 only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
comment|/**< Parse Mode                                                          0 = no packet inspection (Uninterpreted)                                                          1 = L2 parsing / skip to L2                                                          2 = IP parsing / skip to L3                                                          3 = PCI Raw (illegal for software to set) */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
comment|/**< Optional Skip I amount for packets.  Does not                                                          apply to packets on PCI ports when a PKT_INST_HDR                                                          is present.  See section 7.2.7 - Legal Skip                                                          Values for further details. */
else|#
directive|else
name|uint64_t
name|skip
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|cvmx_pip_port_parse_mode_t
name|mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|crc_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|qos_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_diff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_vod
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_27_27
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp_wat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|inst_hdr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dyn_rs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_inc
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rawdrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_pip_prt_cfgx_cn58xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_prt_cfgx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_cfgx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_prt_cfgx
name|cvmx_pip_prt_cfgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_prt_tag#  *  * PIP_PRT_TAGX = Per port config information  *  */
end_comment

begin_union
union|union
name|cvmx_pip_prt_tagx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_prt_tagx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|grptagbase
range|:
literal|4
decl_stmt|;
comment|/**< Offset to use when computing group from tag bits                                                          when GRPTAG is set. */
name|uint64_t
name|grptagmask
range|:
literal|4
decl_stmt|;
comment|/**< Which bits of the tag to exclude when computing                                                          group when GRPTAG is set. */
name|uint64_t
name|grptag
range|:
literal|1
decl_stmt|;
comment|/**< When set, use the lower bit of the tag to compute                                                          the group in the work queue entry                                                          GRP = WQE[TAG[3:0]]& ~GRPTAGMASK + GRPTAGBASE */
name|uint64_t
name|grptag_mskip
range|:
literal|1
decl_stmt|;
comment|/**< When set, GRPTAG will be used regardless if the                                                          packet IS_IP. */
name|uint64_t
name|tag_mode
range|:
literal|2
decl_stmt|;
comment|/**< Which tag algorithm to use                                                          0 = always use tuple tag algorithm                                                          1 = always use mask tag algorithm                                                          2 = if packet is IP, use tuple else use mask                                                          3 = tuple XOR mask */
name|uint64_t
name|inc_vs
range|:
literal|2
decl_stmt|;
comment|/**< determines the DSA/VLAN ID (VID) to be included in                                                          tuple tag when VLAN stacking is detected                                                          0 = do not include VID in tuple tag generation                                                          1 = include VID (VLAN0) in hash                                                          2 = include VID (VLAN1) in hash                                                          3 = include VID ([VLAN0,VLAN1]) in hash */
name|uint64_t
name|inc_vlan
range|:
literal|1
decl_stmt|;
comment|/**< when set, the DSA/VLAN ID is included in tuple tag                                                          when VLAN stacking is not detected                                                          0 = do not include VID in tuple tag generation                                                          1 = include VID in hash */
name|uint64_t
name|inc_prt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the port is included in tuple tag */
name|uint64_t
name|ip6_dprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP dst port is                                                          included in tuple tag for IPv6 packets */
name|uint64_t
name|ip4_dprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP dst port is                                                          included in tuple tag for IPv4 */
name|uint64_t
name|ip6_sprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP src port is                                                          included in tuple tag for IPv6 packets */
name|uint64_t
name|ip4_sprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP src port is                                                          included in tuple tag for IPv4 */
name|uint64_t
name|ip6_nxth_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv6 includes next header in tuple                                                          tag hash */
name|uint64_t
name|ip4_pctl_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv4 includes protocol in tuple                                                          tag hash */
name|uint64_t
name|ip6_dst_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv6 includes dst address in tuple                                                          tag hash */
name|uint64_t
name|ip4_dst_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv4 includes dst address in tuple                                                          tag hash */
name|uint64_t
name|ip6_src_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv6 includes src address in tuple                                                          tag hash */
name|uint64_t
name|ip4_src_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv4 includes src address in tuple                                                          tag hash */
name|cvmx_pow_tag_type_t
name|tcp6_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets the tag_type of a TCP packet (IPv6)                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|tcp4_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets the tag_type of a TCP packet (IPv4)                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|ip6_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets whether IPv6 packet tag type                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|ip4_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets whether IPv4 packet tag type                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|non_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets whether non-IP packet tag type                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< 4-bit value indicating the group to schedule to */
else|#
directive|else
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|cvmx_pow_tag_type_t
name|non_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|ip4_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|ip6_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|tcp4_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|tcp6_tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ip4_src_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_src_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_dst_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_dst_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_pctl_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_nxth_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_sprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_sprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_dprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_dprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc_prt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc_vs
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tag_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|grptag_mskip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grptag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grptagmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|grptagbase
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_prt_tagx_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|grptagbase
range|:
literal|4
decl_stmt|;
comment|/**< Offset to use when computing group from tag bits                                                          when GRPTAG is set. */
name|uint64_t
name|grptagmask
range|:
literal|4
decl_stmt|;
comment|/**< Which bits of the tag to exclude when computing                                                          group when GRPTAG is set. */
name|uint64_t
name|grptag
range|:
literal|1
decl_stmt|;
comment|/**< When set, use the lower bit of the tag to compute                                                          the group in the work queue entry                                                          GRP = WQE[TAG[3:0]]& ~GRPTAGMASK + GRPTAGBASE */
name|uint64_t
name|reserved_30_30
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tag_mode
range|:
literal|2
decl_stmt|;
comment|/**< Which tag algorithm to use                                                          0 = always use tuple tag algorithm                                                          1 = always use mask tag algorithm                                                          2 = if packet is IP, use tuple else use mask                                                          3 = tuple XOR mask */
name|uint64_t
name|inc_vs
range|:
literal|2
decl_stmt|;
comment|/**< determines the VLAN ID (VID) to be included in                                                          tuple tag when VLAN stacking is detected                                                          0 = do not include VID in tuple tag generation                                                          1 = include VID (VLAN0) in hash                                                          2 = include VID (VLAN1) in hash                                                          3 = include VID ([VLAN0,VLAN1]) in hash */
name|uint64_t
name|inc_vlan
range|:
literal|1
decl_stmt|;
comment|/**< when set, the VLAN ID is included in tuple tag                                                          when VLAN stacking is not detected                                                          0 = do not include VID in tuple tag generation                                                          1 = include VID in hash */
name|uint64_t
name|inc_prt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the port is included in tuple tag */
name|uint64_t
name|ip6_dprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP dst port is                                                          included in tuple tag for IPv6 packets */
name|uint64_t
name|ip4_dprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP dst port is                                                          included in tuple tag for IPv4 */
name|uint64_t
name|ip6_sprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP src port is                                                          included in tuple tag for IPv6 packets */
name|uint64_t
name|ip4_sprt_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether the TCP/UDP src port is                                                          included in tuple tag for IPv4 */
name|uint64_t
name|ip6_nxth_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv6 includes next header in tuple                                                          tag hash */
name|uint64_t
name|ip4_pctl_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv4 includes protocol in tuple                                                          tag hash */
name|uint64_t
name|ip6_dst_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv6 includes dst address in tuple                                                          tag hash */
name|uint64_t
name|ip4_dst_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv4 includes dst address in tuple                                                          tag hash */
name|uint64_t
name|ip6_src_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv6 includes src address in tuple                                                          tag hash */
name|uint64_t
name|ip4_src_flag
range|:
literal|1
decl_stmt|;
comment|/**< sets whether ipv4 includes src address in tuple                                                          tag hash */
name|cvmx_pow_tag_type_t
name|tcp6_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets the tag_type of a TCP packet (IPv6)                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|tcp4_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets the tag_type of a TCP packet (IPv4)                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|ip6_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets whether IPv6 packet tag type                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|ip4_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets whether IPv4 packet tag type                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|cvmx_pow_tag_type_t
name|non_tag_type
range|:
literal|2
decl_stmt|;
comment|/**< sets whether non-IP packet tag type                                                          0 = ordered tags                                                          1 = atomic tags                                                          2 = Null tags */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< 4-bit value indicating the group to schedule to */
else|#
directive|else
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|cvmx_pow_tag_type_t
name|non_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|ip4_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|ip6_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|tcp4_tag_type
range|:
literal|2
decl_stmt|;
name|cvmx_pow_tag_type_t
name|tcp6_tag_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ip4_src_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_src_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_dst_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_dst_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_pctl_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_nxth_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_sprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_sprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip4_dprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ip6_dprt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc_prt_flag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc_vlan
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inc_vs
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tag_mode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_30_30
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grptag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grptagmask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|grptagbase
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_prt_tagx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_prt_tagx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_prt_tagx
name|cvmx_pip_prt_tagx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_qos_diff#  *  * PIP_QOS_DIFFX = QOS Diffserv Tables  *  */
end_comment

begin_union
union|union
name|cvmx_pip_qos_diffx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_qos_diffx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Diffserv QOS level */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_diffx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_qos_diffx
name|cvmx_pip_qos_diffx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_qos_vlan#  *  * PIP_QOS_VLANX = QOS VLAN Tables  *  * If the PIP indentifies a packet is DSA/VLAN tagged, then the QOS  * can be set based on the DSA/VLAN user priority.  These eight register  * comprise the QOS values for all DSA/VLAN user priority values.  */
end_comment

begin_union
union|union
name|cvmx_pip_qos_vlanx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_qos_vlanx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|qos1
range|:
literal|3
decl_stmt|;
comment|/**< DSA/VLAN QOS level                                                          Selected when PIP_PRT_CFGx[QOS_VSEL] = 1 */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< DSA/VLAN QOS level                                                          Selected when PIP_PRT_CFGx[QOS_VSEL] = 0 */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_qos_vlanx_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< VLAN QOS level */
else|#
directive|else
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_vlanx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_qos_vlanx
name|cvmx_pip_qos_vlanx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_qos_watch#  *  * PIP_QOS_WATCHX = QOS Watcher Tables  *  * Sets up the Configuration CSRs for the four QOS Watchers.  * Each Watcher can be set to look for a specific protocol,  * TCP/UDP destination port, or Ethertype to override the  * default QOS value.  */
end_comment

begin_union
union|union
name|cvmx_pip_qos_watchx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_qos_watchx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Mask off a range of values */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The GRP number of the watcher */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< The QOS level of the watcher */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|cvmx_pip_qos_watch_types
name|match_type
range|:
literal|3
decl_stmt|;
comment|/**< The field for the watcher match against                                                          0   = disable across all ports                                                          1   = protocol (ipv4)                                                              = next_header (ipv6)                                                          2   = TCP destination port                                                          3   = UDP destination port                                                          4   = Ether type                                                          5-7 = Reserved */
name|uint64_t
name|match_value
range|:
literal|16
decl_stmt|;
comment|/**< The value to watch for */
else|#
directive|else
name|uint64_t
name|match_value
range|:
literal|16
decl_stmt|;
name|cvmx_pip_qos_watch_types
name|match_type
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pip_qos_watchx_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Mask off a range of values */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< The GRP number of the watcher */
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< The QOS level of the watcher */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|cvmx_pip_qos_watch_types
name|match_type
range|:
literal|2
decl_stmt|;
comment|/**< The field for the watcher match against                                                          0 = disable across all ports                                                          1 = protocol (ipv4)                                                            = next_header (ipv6)                                                          2 = TCP destination port                                                          3 = UDP destination port */
name|uint64_t
name|match_value
range|:
literal|16
decl_stmt|;
comment|/**< The value to watch for */
else|#
directive|else
name|uint64_t
name|match_value
range|:
literal|16
decl_stmt|;
name|cvmx_pip_qos_watch_types
name|match_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_23_23
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_pip_qos_watchx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_qos_watchx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_qos_watchx
name|cvmx_pip_qos_watchx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_raw_word  *  * PIP_RAW_WORD = The RAW Word2 of the workQ entry.  *  * The RAW Word2 to be inserted into the workQ entry of RAWFULL packets.  */
end_comment

begin_union
union|union
name|cvmx_pip_raw_word
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_raw_word_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|word
range|:
literal|56
decl_stmt|;
comment|/**< Word2 of the workQ entry                                                          The 8-bit bufs field is still set by HW (IPD) */
else|#
directive|else
name|uint64_t
name|word
range|:
literal|56
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_raw_word_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_raw_word_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_raw_word
name|cvmx_pip_raw_word_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_sft_rst  *  * PIP_SFT_RST = PIP Soft Reset  *  * When written to a '1', resets the pip block  *  * Notes:  * When RST is set to a '1' by SW, PIP will get a short reset pulse (3 cycles  * in duration).  Although this will reset much of PIP's internal state, some  * CSRs will not reset.  *  * . PIP_BIST_STATUS  * . PIP_STAT0_PRT*  * . PIP_STAT1_PRT*  * . PIP_STAT2_PRT*  * . PIP_STAT3_PRT*  * . PIP_STAT4_PRT*  * . PIP_STAT5_PRT*  * . PIP_STAT6_PRT*  * . PIP_STAT7_PRT*  * . PIP_STAT8_PRT*  * . PIP_STAT9_PRT*  * . PIP_XSTAT0_PRT*  * . PIP_XSTAT1_PRT*  * . PIP_XSTAT2_PRT*  * . PIP_XSTAT3_PRT*  * . PIP_XSTAT4_PRT*  * . PIP_XSTAT5_PRT*  * . PIP_XSTAT6_PRT*  * . PIP_XSTAT7_PRT*  * . PIP_XSTAT8_PRT*  * . PIP_XSTAT9_PRT*  * . PIP_STAT_INB_PKTS*  * . PIP_STAT_INB_OCTS*  * . PIP_STAT_INB_ERRS*  * . PIP_TAG_INC*  */
end_comment

begin_union
union|union
name|cvmx_pip_sft_rst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_sft_rst_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|rst
range|:
literal|1
decl_stmt|;
comment|/**< Soft Reset */
else|#
directive|else
name|uint64_t
name|rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_sft_rst_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_sft_rst
name|cvmx_pip_sft_rst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat0_prt#  *  * PIP Statistics Counters  *  * Note: special stat counter behavior  *  * 1) Read and write operations must arbitrate for the statistics resources  *     along with the packet engines which are incrementing the counters.  *     In order to not drop packet information, the packet HW is always a  *     higher priority and the CSR requests will only be satisified when  *     there are idle cycles.  This can potentially cause long delays if the  *     system becomes full.  *  * 2) stat counters can be cleared in two ways.  If PIP_STAT_CTL[RDCLR] is  *     set, then all read accesses will clear the register.  In addition,  *     any write to a stats register will also reset the register to zero.  *     Please note that the clearing operations must obey rule \#1 above.  *  * 3) all counters are wrapping - software must ensure they are read periodically  *  * 4) The counters accumulate statistics for packets that are sent to PKI.  If  *    PTP_MODE is enabled, the 8B timestamp is prepended to the packet.  This  *    additional 8B of data is captured in the octet counts.  * PIP_STAT0_PRT = PIP_STAT_DRP_PKTS / PIP_STAT_DRP_OCTS  */
end_comment

begin_union
union|union
name|cvmx_pip_stat0_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat0_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|drp_pkts
range|:
literal|32
decl_stmt|;
comment|/**< Inbound packets marked to be dropped by the IPD                                                          QOS widget per port */
name|uint64_t
name|drp_octs
range|:
literal|32
decl_stmt|;
comment|/**< Inbound octets marked to be dropped by the IPD                                                          QOS widget per port */
else|#
directive|else
name|uint64_t
name|drp_octs
range|:
literal|32
decl_stmt|;
name|uint64_t
name|drp_pkts
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat0_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat0_prtx
name|cvmx_pip_stat0_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat1_prt#  *  * PIP_STAT1_PRTX = PIP_STAT_OCTS  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat1_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat1_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
comment|/**< Number of octets received by PIP (good and bad) */
else|#
directive|else
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat1_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat1_prtx
name|cvmx_pip_stat1_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat2_prt#  *  * PIP_STAT2_PRTX = PIP_STAT_PKTS     / PIP_STAT_RAW  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat2_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat2_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets processed by PIP */
name|uint64_t
name|raw
range|:
literal|32
decl_stmt|;
comment|/**< RAWFULL + RAWSCH Packets without an L1/L2 error                                                          received by PIP per port */
else|#
directive|else
name|uint64_t
name|raw
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat2_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat2_prtx
name|cvmx_pip_stat2_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat3_prt#  *  * PIP_STAT3_PRTX = PIP_STAT_BCST     / PIP_STAT_MCST  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat3_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat3_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of indentified L2 broadcast packets                                                          Does not include multicast packets                                                          Only includes packets whose parse mode is                                                          SKIP_TO_L2. */
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of indentified L2 multicast packets                                                          Does not include broadcast packets                                                          Only includes packets whose parse mode is                                                          SKIP_TO_L2. */
else|#
directive|else
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat3_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat3_prtx
name|cvmx_pip_stat3_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat4_prt#  *  * PIP_STAT4_PRTX = PIP_STAT_HIST1    / PIP_STAT_HIST0  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat4_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat4_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|h65to127
range|:
literal|32
decl_stmt|;
comment|/**< Number of 65-127B packets */
name|uint64_t
name|h64
range|:
literal|32
decl_stmt|;
comment|/**< Number of 1-64B packets */
else|#
directive|else
name|uint64_t
name|h64
range|:
literal|32
decl_stmt|;
name|uint64_t
name|h65to127
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat4_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat4_prtx
name|cvmx_pip_stat4_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat5_prt#  *  * PIP_STAT5_PRTX = PIP_STAT_HIST3    / PIP_STAT_HIST2  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat5_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat5_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|h256to511
range|:
literal|32
decl_stmt|;
comment|/**< Number of 256-511B packets */
name|uint64_t
name|h128to255
range|:
literal|32
decl_stmt|;
comment|/**< Number of 128-255B packets */
else|#
directive|else
name|uint64_t
name|h128to255
range|:
literal|32
decl_stmt|;
name|uint64_t
name|h256to511
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat5_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat5_prtx
name|cvmx_pip_stat5_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat6_prt#  *  * PIP_STAT6_PRTX = PIP_STAT_HIST5    / PIP_STAT_HIST4  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat6_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat6_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|h1024to1518
range|:
literal|32
decl_stmt|;
comment|/**< Number of 1024-1518B packets */
name|uint64_t
name|h512to1023
range|:
literal|32
decl_stmt|;
comment|/**< Number of 512-1023B packets */
else|#
directive|else
name|uint64_t
name|h512to1023
range|:
literal|32
decl_stmt|;
name|uint64_t
name|h1024to1518
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat6_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat6_prtx
name|cvmx_pip_stat6_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat7_prt#  *  * PIP_STAT7_PRTX = PIP_STAT_FCS      / PIP_STAT_HIST6  *  *  * Notes:  * Note: FCS is not checked on the PCI ports 32..35.  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat7_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat7_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|fcs
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with FCS or Align opcode errors */
name|uint64_t
name|h1519
range|:
literal|32
decl_stmt|;
comment|/**< Number of 1519-max packets */
else|#
directive|else
name|uint64_t
name|h1519
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcs
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat7_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat7_prtx
name|cvmx_pip_stat7_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat8_prt#  *  * PIP_STAT8_PRTX = PIP_STAT_FRAG     / PIP_STAT_UNDER  *  *  * Notes:  * Note: FCS is not checked on the PCI ports 32..35.  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat8_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat8_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|frag
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length< min and FCS error */
name|uint64_t
name|undersz
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length< min */
else|#
directive|else
name|uint64_t
name|undersz
range|:
literal|32
decl_stmt|;
name|uint64_t
name|frag
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat8_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat8_prtx
name|cvmx_pip_stat8_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat9_prt#  *  * PIP_STAT9_PRTX = PIP_STAT_JABBER   / PIP_STAT_OVER  *  *  * Notes:  * Note: FCS is not checked on the PCI ports 32..35.  *  */
end_comment

begin_union
union|union
name|cvmx_pip_stat9_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat9_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|jabber
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length> max and FCS error */
name|uint64_t
name|oversz
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length> max */
else|#
directive|else
name|uint64_t
name|oversz
range|:
literal|32
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat9_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat9_prtx
name|cvmx_pip_stat9_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat_ctl  *  * PIP_STAT_CTL = PIP's Stat Control Register  *  * Controls how the PIP statistics counters are handled.  */
end_comment

begin_union
union|union
name|cvmx_pip_stat_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|rdclr
range|:
literal|1
decl_stmt|;
comment|/**< Stat registers are read and clear                                                          0 = stat registers hold value when read                                                          1 = stat registers are cleared when read */
else|#
directive|else
name|uint64_t
name|rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat_ctl
name|cvmx_pip_stat_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat_inb_errs#  *  * PIP_STAT_INB_ERRSX = Inbound error packets received by PIP per port  *  * Inbound stats collect all data sent to PIP from all packet interfaces.  * Its the raw counts of everything that comes into the block.  The counts  * will reflect all error packets and packets dropped by the PKI RED engine.  * These counts are intended for system debug, but could convey useful  * information in production systems.  */
end_comment

begin_union
union|union
name|cvmx_pip_stat_inb_errsx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat_inb_errsx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|errs
range|:
literal|16
decl_stmt|;
comment|/**< Number of packets with errors                                                          received by PIP */
else|#
directive|else
name|uint64_t
name|errs
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_errsx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat_inb_errsx
name|cvmx_pip_stat_inb_errsx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat_inb_octs#  *  * PIP_STAT_INB_OCTSX = Inbound octets received by PIP per port  *  * Inbound stats collect all data sent to PIP from all packet interfaces.  * Its the raw counts of everything that comes into the block.  The counts  * will reflect all error packets and packets dropped by the PKI RED engine.  * These counts are intended for system debug, but could convey useful  * information in production systems. The OCTS will include the bytes from  * timestamp fields in PTP_MODE.  */
end_comment

begin_union
union|union
name|cvmx_pip_stat_inb_octsx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat_inb_octsx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
comment|/**< Total number of octets from all packets received                                                          by PIP */
else|#
directive|else
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_octsx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat_inb_octsx
name|cvmx_pip_stat_inb_octsx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_stat_inb_pkts#  *  * PIP_STAT_INB_PKTSX = Inbound packets received by PIP per port  *  * Inbound stats collect all data sent to PIP from all packet interfaces.  * Its the raw counts of everything that comes into the block.  The counts  * will reflect all error packets and packets dropped by the PKI RED engine.  * These counts are intended for system debug, but could convey useful  * information in production systems.  */
end_comment

begin_union
union|union
name|cvmx_pip_stat_inb_pktsx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_stat_inb_pktsx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets without errors                                                          received by PIP */
else|#
directive|else
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_stat_inb_pktsx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_stat_inb_pktsx
name|cvmx_pip_stat_inb_pktsx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_tag_inc#  *  * PIP_TAG_INC = Which bytes to include in the new tag hash algorithm  *  * # $PIP_TAG_INCX = 0x300+X X=(0..63) RegType=(RSL) RtlReg=(pip_tag_inc_csr_direct_TestbuilderTask)  */
end_comment

begin_union
union|union
name|cvmx_pip_tag_incx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_tag_incx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
comment|/**< Which bytes to include in mask tag algorithm                                                          Broken into 4, 16-entry masks to cover 128B                                                          PIP_PRT_CFG[TAG_INC] selects 1 of 4 to use                                                          registers  0-15 map to PIP_PRT_CFG[TAG_INC] == 0                                                          registers 16-31 map to PIP_PRT_CFG[TAG_INC] == 1                                                          registers 32-47 map to PIP_PRT_CFG[TAG_INC] == 2                                                          registers 48-63 map to PIP_PRT_CFG[TAG_INC] == 3                                                          [7] coresponds to the MSB of the 8B word                                                          [0] coresponds to the LSB of the 8B word                                                          If PTP_MODE, the 8B timestamp is prepended to the                                                           packet.  The EN byte masks should be adjusted to                                                           compensate for the additional timestamp field. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_incx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_tag_incx
name|cvmx_pip_tag_incx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_tag_mask  *  * PIP_TAG_MASK = Mask bit in the tag generation  *  */
end_comment

begin_union
union|union
name|cvmx_pip_tag_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_tag_mask_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< When set, MASK clears individual bits of lower 16                                                          bits of the computed tag.  Does not effect RAW                                                          or INSTR HDR packets. */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_mask_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_tag_mask
name|cvmx_pip_tag_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_tag_secret  *  * PIP_TAG_SECRET = Initial value in tag generation  *  * The source and destination IV's provide a mechanism for each Octeon to be unique.  */
end_comment

begin_union
union|union
name|cvmx_pip_tag_secret
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_tag_secret_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dst
range|:
literal|16
decl_stmt|;
comment|/**< Secret for the destination tuple tag CRC calc */
name|uint64_t
name|src
range|:
literal|16
decl_stmt|;
comment|/**< Secret for the source tuple tag CRC calc */
else|#
directive|else
name|uint64_t
name|src
range|:
literal|16
decl_stmt|;
name|uint64_t
name|dst
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_tag_secret_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_tag_secret
name|cvmx_pip_tag_secret_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_todo_entry  *  * PIP_TODO_ENTRY = Head entry of the Todo list (debug only)  *  * Summary of the current packet that has completed and waiting to be processed  */
end_comment

begin_union
union|union
name|cvmx_pip_todo_entry
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_todo_entry_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
comment|/**< Entry is valid */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry
range|:
literal|62
decl_stmt|;
comment|/**< Todo list entry summary */
else|#
directive|else
name|uint64_t
name|entry
range|:
literal|62
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_todo_entry_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_todo_entry
name|cvmx_pip_todo_entry_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat0_prt#  *  * PIP_XSTAT0_PRT = PIP_XSTAT_DRP_PKTS / PIP_XSTAT_DRP_OCTS  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat0_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat0_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|drp_pkts
range|:
literal|32
decl_stmt|;
comment|/**< Inbound packets marked to be dropped by the IPD                                                          QOS widget per port */
name|uint64_t
name|drp_octs
range|:
literal|32
decl_stmt|;
comment|/**< Inbound octets marked to be dropped by the IPD                                                          QOS widget per port */
else|#
directive|else
name|uint64_t
name|drp_octs
range|:
literal|32
decl_stmt|;
name|uint64_t
name|drp_pkts
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat0_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat0_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat0_prtx
name|cvmx_pip_xstat0_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat1_prt#  *  * PIP_XSTAT1_PRTX = PIP_XSTAT_OCTS  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat1_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat1_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
comment|/**< Number of octets received by PIP (good and bad) */
else|#
directive|else
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat1_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat1_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat1_prtx
name|cvmx_pip_xstat1_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat2_prt#  *  * PIP_XSTAT2_PRTX = PIP_XSTAT_PKTS     / PIP_XSTAT_RAW  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat2_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat2_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets processed by PIP */
name|uint64_t
name|raw
range|:
literal|32
decl_stmt|;
comment|/**< RAWFULL + RAWSCH Packets without an L1/L2 error                                                          received by PIP per port */
else|#
directive|else
name|uint64_t
name|raw
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat2_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat2_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat2_prtx
name|cvmx_pip_xstat2_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat3_prt#  *  * PIP_XSTAT3_PRTX = PIP_XSTAT_BCST     / PIP_XSTAT_MCST  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat3_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat3_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of indentified L2 broadcast packets                                                          Does not include multicast packets                                                          Only includes packets whose parse mode is                                                          SKIP_TO_L2. */
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of indentified L2 multicast packets                                                          Does not include broadcast packets                                                          Only includes packets whose parse mode is                                                          SKIP_TO_L2. */
else|#
directive|else
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat3_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat3_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat3_prtx
name|cvmx_pip_xstat3_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat4_prt#  *  * PIP_XSTAT4_PRTX = PIP_XSTAT_HIST1    / PIP_XSTAT_HIST0  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat4_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat4_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|h65to127
range|:
literal|32
decl_stmt|;
comment|/**< Number of 65-127B packets */
name|uint64_t
name|h64
range|:
literal|32
decl_stmt|;
comment|/**< Number of 1-64B packets */
else|#
directive|else
name|uint64_t
name|h64
range|:
literal|32
decl_stmt|;
name|uint64_t
name|h65to127
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat4_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat4_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat4_prtx
name|cvmx_pip_xstat4_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat5_prt#  *  * PIP_XSTAT5_PRTX = PIP_XSTAT_HIST3    / PIP_XSTAT_HIST2  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat5_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat5_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|h256to511
range|:
literal|32
decl_stmt|;
comment|/**< Number of 256-511B packets */
name|uint64_t
name|h128to255
range|:
literal|32
decl_stmt|;
comment|/**< Number of 128-255B packets */
else|#
directive|else
name|uint64_t
name|h128to255
range|:
literal|32
decl_stmt|;
name|uint64_t
name|h256to511
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat5_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat5_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat5_prtx
name|cvmx_pip_xstat5_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat6_prt#  *  * PIP_XSTAT6_PRTX = PIP_XSTAT_HIST5    / PIP_XSTAT_HIST4  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat6_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat6_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|h1024to1518
range|:
literal|32
decl_stmt|;
comment|/**< Number of 1024-1518B packets */
name|uint64_t
name|h512to1023
range|:
literal|32
decl_stmt|;
comment|/**< Number of 512-1023B packets */
else|#
directive|else
name|uint64_t
name|h512to1023
range|:
literal|32
decl_stmt|;
name|uint64_t
name|h1024to1518
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat6_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat6_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat6_prtx
name|cvmx_pip_xstat6_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat7_prt#  *  * PIP_XSTAT7_PRTX = PIP_XSTAT_FCS      / PIP_XSTAT_HIST6  *  *  * Notes:  * Note: FCS is not checked on the PCI ports 32..35.  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat7_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat7_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|fcs
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with FCS or Align opcode errors */
name|uint64_t
name|h1519
range|:
literal|32
decl_stmt|;
comment|/**< Number of 1519-max packets */
else|#
directive|else
name|uint64_t
name|h1519
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fcs
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat7_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat7_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat7_prtx
name|cvmx_pip_xstat7_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat8_prt#  *  * PIP_XSTAT8_PRTX = PIP_XSTAT_FRAG     / PIP_XSTAT_UNDER  *  *  * Notes:  * Note: FCS is not checked on the PCI ports 32..35.  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat8_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat8_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|frag
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length< min and FCS error */
name|uint64_t
name|undersz
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length< min */
else|#
directive|else
name|uint64_t
name|undersz
range|:
literal|32
decl_stmt|;
name|uint64_t
name|frag
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat8_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat8_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat8_prtx
name|cvmx_pip_xstat8_prtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pip_xstat9_prt#  *  * PIP_XSTAT9_PRTX = PIP_XSTAT_JABBER   / PIP_XSTAT_OVER  *  *  * Notes:  * Note: FCS is not checked on the PCI ports 32..35.  *  */
end_comment

begin_union
union|union
name|cvmx_pip_xstat9_prtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pip_xstat9_prtx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|jabber
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length> max and FCS error */
name|uint64_t
name|oversz
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets with length> max */
else|#
directive|else
name|uint64_t
name|oversz
range|:
literal|32
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pip_xstat9_prtx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pip_xstat9_prtx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pip_xstat9_prtx
name|cvmx_pip_xstat9_prtx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

