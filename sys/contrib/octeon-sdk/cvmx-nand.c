begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the NAND flash controller.  * See cvmx-nand.h for usage documentation and notes.  *  *<hr>$Revision: 35726 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-nand.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ndf-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-swap.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootmem.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-nand.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__U_BOOT__
argument_list|)
operator|&&
name|defined
argument_list|(
name|CONFIG_HW_WATCHDOG
argument_list|)
end_if

begin_include
include|#
directive|include
file|<watchdog.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|WATCHDOG_RESET
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NAND_COMMAND_READ_ID
value|0x90
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_READ_PARAM_PAGE
value|0xec
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_RESET
value|0xff
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_STATUS
value|0x70
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_READ
value|0x00
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_READ_FIN
value|0x30
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_ERASE
value|0x60
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_ERASE_FIN
value|0xd0
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_PROGRAM
value|0x80
end_define

begin_define
define|#
directive|define
name|NAND_COMMAND_PROGRAM_FIN
value|0x10
end_define

begin_define
define|#
directive|define
name|NAND_TIMEOUT_USECS_READ
value|100000
end_define

begin_define
define|#
directive|define
name|NAND_TIMEOUT_USECS_WRITE
value|1000000
end_define

begin_define
define|#
directive|define
name|NAND_TIMEOUT_USECS_BLOCK_ERASE
value|1000000
end_define

begin_define
define|#
directive|define
name|CVMX_NAND_ROUNDUP
parameter_list|(
name|_Dividend
parameter_list|,
name|_Divisor
parameter_list|)
value|(((_Dividend)+((_Divisor)-1))/(_Divisor))
end_define

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof (X) __x = (X);                \            typeof (Y) __y = (Y);                \                 (__x< __y) ? __x : __y; })
end_define

begin_undef
undef|#
directive|undef
name|max
end_undef

begin_define
define|#
directive|define
name|max
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|)
define|\
value|({ typeof (X) __x = (X);                \            typeof (Y) __y = (Y);                \                 (__x> __y) ? __x : __y; })
end_define

begin_comment
comment|/* Structure to store the parameters that we care about that ** describe the ONFI speed modes.  This is used to configure ** the flash timing to match what is reported in the ** parameter page of the ONFI flash chip. */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|twp
decl_stmt|;
name|int
name|twh
decl_stmt|;
name|int
name|twc
decl_stmt|;
name|int
name|tclh
decl_stmt|;
name|int
name|tals
decl_stmt|;
block|}
name|onfi_speed_mode_desc_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|onfi_speed_mode_desc_t
name|onfi_speed_modes
index|[]
init|=
block|{
block|{
literal|50
block|,
literal|30
block|,
literal|100
block|,
literal|20
block|,
literal|50
block|}
block|,
comment|/* Mode 0 */
block|{
literal|25
block|,
literal|15
block|,
literal|45
block|,
literal|10
block|,
literal|25
block|}
block|,
comment|/* Mode 1 */
block|{
literal|17
block|,
literal|15
block|,
literal|35
block|,
literal|10
block|,
literal|15
block|}
block|,
comment|/* Mode 2 */
block|{
literal|15
block|,
literal|10
block|,
literal|30
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* Mode 3 */
block|{
literal|12
block|,
literal|10
block|,
literal|25
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* Mode 4, requires EDO timings */
block|{
literal|10
block|,
literal|7
block|,
literal|20
block|,
literal|5
block|,
literal|10
block|}
block|,
comment|/* Mode 5, requries EDO timings */
block|{
literal|10
block|,
literal|10
block|,
literal|25
block|,
literal|5
block|,
literal|12
block|}
block|,
comment|/* Mode 6, requires EDO timings */
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
block|{
name|CVMX_NAND_STATE_16BIT
init|=
literal|1
operator|<<
literal|0
block|, }
name|cvmx_nand_state_flags_t
typedef|;
end_typedef

begin_comment
comment|/**  * Structure used to store data about the NAND devices hooked  * to the bootbus.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|page_size
decl_stmt|;
name|int
name|oob_size
decl_stmt|;
name|int
name|pages_per_block
decl_stmt|;
name|int
name|blocks
decl_stmt|;
name|int
name|tim_mult
decl_stmt|;
name|int
name|tim_par
index|[
literal|8
index|]
decl_stmt|;
name|int
name|clen
index|[
literal|4
index|]
decl_stmt|;
name|int
name|alen
index|[
literal|4
index|]
decl_stmt|;
name|int
name|rdn
index|[
literal|4
index|]
decl_stmt|;
name|int
name|wrn
index|[
literal|2
index|]
decl_stmt|;
name|int
name|onfi_timing
decl_stmt|;
name|cvmx_nand_state_flags_t
name|flags
decl_stmt|;
block|}
name|cvmx_nand_state_t
typedef|;
end_typedef

begin_comment
comment|/**  * Array indexed by bootbus chip select with information  * about NAND devices.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__U_BOOT__
argument_list|)
end_if

begin_comment
comment|/* For u-boot nand boot we need to play some tricks to be able ** to use this early in boot.  We put them in a special section that is merged ** with the text segment.  (Using the text segment directly results in an assembler warning.) */
end_comment

begin_comment
comment|/*#define USE_DATA_IN_TEXT*/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_DATA_IN_TEXT
end_ifdef

begin_decl_stmt
specifier|static
name|uint8_t
name|cvmx_nand_buffer
index|[
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
index|]
name|__attribute__
argument_list|(
operator|(
name|aligned
argument_list|(
literal|8
argument_list|)
operator|)
argument_list|)
name|__attribute__
argument_list|(
operator|(
name|section
argument_list|(
literal|".data_in_text"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cvmx_nand_state_t
name|cvmx_nand_state
index|[
literal|8
index|]
name|__attribute__
argument_list|(
operator|(
name|section
argument_list|(
literal|".data_in_text"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cvmx_nand_state_t
name|cvmx_nand_default
name|__attribute__
argument_list|(
operator|(
name|section
argument_list|(
literal|".data_in_text"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cvmx_nand_initialize_flags_t
name|cvmx_nand_flags
name|__attribute__
argument_list|(
operator|(
name|section
argument_list|(
literal|".data_in_text"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_indent
name|__attribute__
argument_list|(
operator|(
name|section
argument_list|(
literal|".data_in_text"
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_nand_state_t
name|cvmx_nand_state
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_nand_state_t
name|cvmx_nand_default
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_nand_initialize_flags_t
name|cvmx_nand_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|uint8_t
modifier|*
name|cvmx_nand_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug_indent
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|CVMX_SHARED
specifier|const
name|char
modifier|*
name|cvmx_nand_opcode_labels
index|[]
init|=
block|{
literal|"NOP"
block|,
comment|/* 0 */
literal|"Timing"
block|,
comment|/* 1 */
literal|"Wait"
block|,
comment|/* 2 */
literal|"Chip Enable / Disable"
block|,
comment|/* 3 */
literal|"CLE"
block|,
comment|/* 4 */
literal|"ALE"
block|,
comment|/* 5 */
literal|"6 - Unknown"
block|,
comment|/* 6 */
literal|"7 - Unknown"
block|,
comment|/* 7 */
literal|"Write"
block|,
comment|/* 8 */
literal|"Read"
block|,
comment|/* 9 */
literal|"Read EDO"
block|,
comment|/* 10 */
literal|"Wait Status"
block|,
comment|/* 11 */
literal|"12 - Unknown"
block|,
comment|/* 12 */
literal|"13 - Unknown"
block|,
comment|/* 13 */
literal|"14 - Unknown"
block|,
comment|/* 14 */
literal|"Bus Aquire / Release"
comment|/* 15 */
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_comment
comment|/* This macro logs out whenever a function is called if debugging is on */
end_comment

begin_define
define|#
directive|define
name|CVMX_NAND_LOG_CALLED
parameter_list|()
define|\
value|if (cvmx_unlikely(cvmx_nand_flags& CVMX_NAND_INITIALIZE_FLAGS_DEBUG)) \         cvmx_dprintf("%*s%s: called\n", 2*debug_indent++, "", __FUNCTION__);
end_define

begin_comment
comment|/* This macro logs out each function parameter if debugging is on */
end_comment

begin_define
define|#
directive|define
name|CVMX_NAND_LOG_PARAM
parameter_list|(
name|format
parameter_list|,
name|param
parameter_list|)
define|\
value|if (cvmx_unlikely(cvmx_nand_flags& CVMX_NAND_INITIALIZE_FLAGS_DEBUG)) \         cvmx_dprintf("%*s%s: param %s = " format "\n", 2*debug_indent, "", __FUNCTION__, #param, param);
end_define

begin_comment
comment|/* This macro logs out when a function returns a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_NAND_RETURN
parameter_list|(
name|v
parameter_list|)
define|\
value|do {                                                                \         typeof(v) r = v;                                                \         if (cvmx_unlikely(cvmx_nand_flags& CVMX_NAND_INITIALIZE_FLAGS_DEBUG))         \             cvmx_dprintf("%*s%s: returned %s(%d)\n", 2*--debug_indent, "", __FUNCTION__, #v, r); \         return r;                                                       \     } while (0);
end_define

begin_comment
comment|/* This macro logs out when a function doesn't return a value */
end_comment

begin_define
define|#
directive|define
name|CVMX_NAND_RETURN_NOTHING
parameter_list|()
define|\
value|do {                                                                \         if (cvmx_unlikely(cvmx_nand_flags& CVMX_NAND_INITIALIZE_FLAGS_DEBUG))         \             cvmx_dprintf("%*s%s: returned\n", 2*--debug_indent, "", __FUNCTION__); \         return;                                                         \     } while (0);
end_define

begin_comment
comment|/* Compute the CRC for the ONFI parameter page.  Adapted from sample code ** in the specification. */
end_comment

begin_function
specifier|static
name|uint16_t
name|__onfi_parameter_crc_compute
parameter_list|(
name|uint8_t
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|int
name|order
init|=
literal|16
decl_stmt|;
comment|// Order of the CRC-16
name|unsigned
name|long
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|,
name|bit
decl_stmt|;
name|unsigned
name|long
name|crc
init|=
literal|0x4F4E
decl_stmt|;
comment|// Initialize the shift register with 0x4F4E
name|unsigned
name|long
name|crcmask
init|=
operator|(
operator|(
operator|(
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|order
operator|-
literal|1
operator|)
operator|)
operator|-
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
decl_stmt|;
name|unsigned
name|long
name|crchighbit
init|=
operator|(
name|unsigned
name|long
operator|)
literal|1
operator|<<
operator|(
name|order
operator|-
literal|1
operator|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|254
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|long
operator|)
name|data
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0x80
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
control|)
block|{
name|bit
operator|=
name|crc
operator|&
name|crchighbit
expr_stmt|;
name|crc
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|&
name|j
condition|)
name|bit
operator|^=
name|crchighbit
expr_stmt|;
if|if
condition|(
name|bit
condition|)
name|crc
operator|^=
literal|0x8005
expr_stmt|;
block|}
name|crc
operator|&=
name|crcmask
expr_stmt|;
block|}
return|return
operator|(
name|crc
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Validate the ONFI parameter page and return a pointer to  * the config values.  *  * @param param_page Pointer to the raw NAND data returned after a parameter page read. It will  *                   contain at least 4 copies of the parameter structure.  *  * @return Pointer to a validated paramter page, or NULL if one couldn't be found.  */
end_comment

begin_function
specifier|static
name|cvmx_nand_onfi_param_page_t
modifier|*
name|__cvmx_nand_onfi_process
parameter_list|(
name|cvmx_nand_onfi_param_page_t
name|param_page
index|[
literal|4
index|]
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
literal|4
condition|;
name|index
operator|++
control|)
block|{
name|uint16_t
name|crc
init|=
name|__onfi_parameter_crc_compute
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|param_page
index|[
name|index
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|crc
operator|==
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|crc
argument_list|)
condition|)
break|break;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Paramter page %d is corrupt. (Expected CRC: 0x%04x, computed: 0x%04x)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|index
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|crc
argument_list|)
argument_list|,
name|crc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|index
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: All parameter pages fail CRC check.  Checking to see if any look sane.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memcmp
argument_list|(
name|param_page
argument_list|,
name|param_page
operator|+
literal|1
argument_list|,
literal|256
argument_list|)
condition|)
block|{
comment|/* First and second copies match, now check some values */
if|if
condition|(
name|param_page
index|[
literal|0
index|]
operator|.
name|pages_per_block
operator|!=
literal|0
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|pages_per_block
operator|!=
literal|0xFFFFFFFF
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|page_data_bytes
operator|!=
literal|0
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|page_data_bytes
operator|!=
literal|0xFFFFFFFF
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|page_spare_bytes
operator|!=
literal|0
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|page_spare_bytes
operator|!=
literal|0xFFFF
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|blocks_per_lun
operator|!=
literal|0
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|blocks_per_lun
operator|!=
literal|0xFFFFFFFF
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|timing_mode
operator|!=
literal|0
operator|&&
name|param_page
index|[
literal|0
index|]
operator|.
name|timing_mode
operator|!=
literal|0xFFFF
condition|)
block|{
comment|/* Looks like we have enough values to use */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Page 0 looks sane, using even though CRC fails.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|index
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|index
operator|==
literal|4
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: WARNING: ONFI part but no valid ONFI parameter pages found.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%*sONFI Information (from copy %d in param page)\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|debug_indent
operator|++
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sonfi = %c%c%c%c\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|onfi
index|[
literal|0
index|]
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|onfi
index|[
literal|1
index|]
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|onfi
index|[
literal|2
index|]
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|onfi
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*srevision_number = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|revision_number
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sfeatures = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|features
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*soptional_commands = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|optional_commands
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*smanufacturer = %12.12s\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|manufacturer
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*smodel = %20.20s\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|model
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sjedec_id = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|jedec_id
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sdate_code = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|date_code
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spage_data_bytes = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|cvmx_le32_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|page_data_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spage_spare_bytes = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|page_spare_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spartial_page_data_bytes = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|cvmx_le32_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|partial_page_data_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spartial_page_spare_bytes = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|partial_page_spare_bytes
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spages_per_block = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|cvmx_le32_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|pages_per_block
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sblocks_per_lun = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
operator|(
name|int
operator|)
name|cvmx_le32_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|blocks_per_lun
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*snumber_lun = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|number_lun
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*saddress_cycles = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|address_cycles
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sbits_per_cell = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|bits_per_cell
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sbad_block_per_lun = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|bad_block_per_lun
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sblock_endurance = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|block_endurance
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sgood_blocks = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|good_blocks
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sgood_block_endurance = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|good_block_endurance
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sprograms_per_page = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|programs_per_page
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spartial_program_attrib = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|partial_program_attrib
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sbits_ecc = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|bits_ecc
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sinterleaved_address_bits = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|interleaved_address_bits
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*sinterleaved_attrib = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|interleaved_attrib
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*spin_capacitance = %u\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|pin_capacitance
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*stiming_mode = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|timing_mode
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*scache_timing_mode = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|cache_timing_mode
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*st_prog = %d us\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|t_prog
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*st_bers = %u us\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|t_bers
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*st_r = %u us\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|t_r
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*st_ccs = %u ns\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|t_ccs
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*svendor_revision = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|cvmx_le16_to_cpu
argument_list|(
name|param_page
index|[
name|index
index|]
operator|.
name|vendor_revision
argument_list|)
argument_list|)
expr_stmt|;
comment|//uint8_t vendor_specific[88];    /**< Byte 166-253: Vendor specific */
name|cvmx_dprintf
argument_list|(
literal|"%*scrc = 0x%x\n"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|param_page
index|[
name|index
index|]
operator|.
name|crc
argument_list|)
expr_stmt|;
name|debug_indent
operator|--
expr_stmt|;
block|}
return|return
name|param_page
operator|+
name|index
return|;
block|}
end_function

begin_function
name|void
name|__set_onfi_timing_mode
parameter_list|(
name|int
modifier|*
name|tim_par
parameter_list|,
name|int
name|clocks_us
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
specifier|const
name|onfi_speed_mode_desc_t
modifier|*
name|mp
init|=
operator|&
name|onfi_speed_modes
index|[
name|mode
index|]
decl_stmt|;
comment|/* use shorter name to fill in timing array */
name|int
name|margin
decl_stmt|;
name|int
name|pulse_adjust
decl_stmt|;
if|if
condition|(
name|mode
operator|>
literal|6
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: invalid ONFI timing mode: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|mode
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Adjust the read/write pulse duty cycle to make it more even.  The cycle time     ** requirement is longer than the sum of the high low times, so we exend both the high     ** and low times to meet the cycle time requirement.     */
name|pulse_adjust
operator|=
operator|(
operator|(
name|mp
operator|->
name|twc
operator|-
name|mp
operator|->
name|twh
operator|-
name|mp
operator|->
name|twp
operator|)
operator|/
literal|2
operator|+
literal|1
operator|)
operator|*
name|clocks_us
expr_stmt|;
comment|/* Add a small margin to all timings. */
name|margin
operator|=
literal|2
operator|*
name|clocks_us
expr_stmt|;
comment|/* Update timing parameters based on supported mode */
name|tim_par
index|[
literal|1
index|]
operator|=
name|CVMX_NAND_ROUNDUP
argument_list|(
name|mp
operator|->
name|twp
operator|*
name|clocks_us
operator|+
name|margin
operator|+
name|pulse_adjust
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* Twp, WE# pulse width */
name|tim_par
index|[
literal|2
index|]
operator|=
name|CVMX_NAND_ROUNDUP
argument_list|(
name|max
argument_list|(
name|mp
operator|->
name|twh
argument_list|,
name|mp
operator|->
name|twc
operator|-
name|mp
operator|->
name|twp
argument_list|)
operator|*
name|clocks_us
operator|+
name|margin
operator|+
name|pulse_adjust
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tw, WE# pulse width high */
name|tim_par
index|[
literal|3
index|]
operator|=
name|CVMX_NAND_ROUNDUP
argument_list|(
name|mp
operator|->
name|tclh
operator|*
name|clocks_us
operator|+
name|margin
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tclh, CLE hold time */
name|tim_par
index|[
literal|4
index|]
operator|=
name|CVMX_NAND_ROUNDUP
argument_list|(
name|mp
operator|->
name|tals
operator|*
name|clocks_us
operator|+
name|margin
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* Tals, ALE setup time */
name|tim_par
index|[
literal|5
index|]
operator|=
name|tim_par
index|[
literal|3
index|]
expr_stmt|;
comment|/* Talh, ALE hold time */
name|tim_par
index|[
literal|6
index|]
operator|=
name|tim_par
index|[
literal|1
index|]
expr_stmt|;
comment|/* Trp, RE# pulse width*/
name|tim_par
index|[
literal|7
index|]
operator|=
name|tim_par
index|[
literal|2
index|]
expr_stmt|;
comment|/* Treh, RE# high hold time */
block|}
end_function

begin_comment
comment|/* Internal helper function to set chip configuration to use default values */
end_comment

begin_function
specifier|static
name|void
name|__set_chip_defaults
parameter_list|(
name|int
name|chip
parameter_list|,
name|int
name|clocks_us
parameter_list|)
block|{
if|if
condition|(
operator|!
name|cvmx_nand_default
operator|.
name|page_size
condition|)
return|return;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|=
name|cvmx_nand_default
operator|.
name|page_size
expr_stmt|;
comment|/* NAND page size in bytes */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|=
name|cvmx_nand_default
operator|.
name|oob_size
expr_stmt|;
comment|/* NAND OOB (spare) size in bytes (per page) */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
operator|=
name|cvmx_nand_default
operator|.
name|pages_per_block
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
operator|=
name|cvmx_nand_default
operator|.
name|blocks
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
operator|=
name|cvmx_nand_default
operator|.
name|onfi_timing
expr_stmt|;
name|__set_onfi_timing_mode
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
argument_list|,
name|clocks_us
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: Using default NAND parameters.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%s: Defaults: page size: %d, OOB size: %d, pages per block %d, blocks: %d, timing mode: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Do the proper wait for the ready/busy signal.  First wait ** for busy to be valid, then wait for busy to de-assert. */
end_comment

begin_function
specifier|static
name|int
name|__wait_for_busy_done
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|cvmx_nand_cmd_t
name|cmd
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|two
operator|=
literal|2
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|r_b
operator|=
literal|0
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|n
operator|=
literal|2
expr_stmt|;
comment|/* Wait for RB to be valied (tWB).     ** Use 5 * tWC as proxy.  In some modes this is     ** much longer than required, but does not affect performance     ** since we will wait much longer for busy to de-assert.     */
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|r_b
operator|=
literal|1
expr_stmt|;
comment|/* Now wait for busy to be de-asserted */
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Called to initialize the NAND controller for use. Note that  * you must be running out of L2 or memory and not NAND before  * calling this function.  * When probing for NAND chips, this function attempts to autoconfigure based on the NAND parts detected.  * It currently supports autodetection for ONFI parts (with valid parameter pages), and some Samsung NAND  * parts (decoding ID bits.)  If autoconfiguration fails, the defaults set with __set_chip_defaults()  * prior to calling cvmx_nand_initialize() are used.  * If defaults are set and the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is provided, the defaults are used  * for all chips in the active_chips mask.  *  * @param flags  Optional initialization flags  *               If the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is passed, chips are not probed,  *               and the default parameters (if set with cvmx_nand_set_defaults) are used for all chips  *               in the active_chips mask.  * @param active_chips  *               Each bit in this parameter represents a chip select that might  *               contain NAND flash. Any chip select present in this bitmask may  *               be connected to NAND. It is normally safe to pass 0xff here and  *               let the API probe all 8 chip selects.  *  * @return Zero on success, a negative cvmx_nand_status error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_initialize
parameter_list|(
name|cvmx_nand_initialize_flags_t
name|flags
parameter_list|,
name|int
name|active_chips
parameter_list|)
block|{
name|int
name|chip
decl_stmt|;
name|int
name|start_chip
decl_stmt|;
name|int
name|stop_chip
decl_stmt|;
name|uint64_t
name|clocks_us
decl_stmt|;
name|union
name|cvmx_ndf_misc
name|ndf_misc
decl_stmt|;
name|uint8_t
name|nand_id_buffer
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_NAND
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_DEVICE
argument_list|)
expr_stmt|;
name|cvmx_nand_flags
operator|=
name|flags
expr_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cvmx_nand_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_nand_state
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|USE_DATA_IN_TEXT
comment|/* cvmx_nand_buffer is statically allocated in the TEXT_IN_DATA case */
if|if
condition|(
operator|!
name|cvmx_nand_buffer
condition|)
block|{
name|cvmx_nand_buffer
operator|=
name|cvmx_bootmem_alloc_named_flags
argument_list|(
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
argument_list|,
literal|128
argument_list|,
literal|"__nand_buffer"
argument_list|,
name|CVMX_BOOTMEM_FLAG_END_ALLOC
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cvmx_nand_buffer
condition|)
block|{
specifier|const
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|block_desc
init|=
name|cvmx_bootmem_find_named_block
argument_list|(
literal|"__nand_buffer"
argument_list|)
decl_stmt|;
if|if
condition|(
name|block_desc
condition|)
name|cvmx_nand_buffer
operator|=
name|cvmx_phys_to_ptr
argument_list|(
name|block_desc
operator|->
name|base_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cvmx_nand_buffer
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Disable boot mode and reset the fifo */
name|ndf_misc
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_NDF_MISC
argument_list|)
expr_stmt|;
name|ndf_misc
operator|.
name|s
operator|.
name|rd_cmd
operator|=
literal|0
expr_stmt|;
name|ndf_misc
operator|.
name|s
operator|.
name|bt_dma
operator|=
literal|0
expr_stmt|;
name|ndf_misc
operator|.
name|s
operator|.
name|bt_dis
operator|=
literal|1
expr_stmt|;
name|ndf_misc
operator|.
name|s
operator|.
name|ex_dis
operator|=
literal|0
expr_stmt|;
name|ndf_misc
operator|.
name|s
operator|.
name|rst_ff
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_MISC
argument_list|,
name|ndf_misc
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_NDF_MISC
argument_list|)
expr_stmt|;
comment|/* Bring the fifo out of reset */
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ndf_misc
operator|.
name|s
operator|.
name|rst_ff
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_MISC
argument_list|,
name|ndf_misc
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_NDF_MISC
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Clear the ECC counter */
comment|//cvmx_write_csr(CVMX_NDF_ECC_CNT, cvmx_read_csr(CVMX_NDF_ECC_CNT));
comment|/* Clear the interrupt state */
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_INT
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_NDF_INT
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_NDF_DMA_INT
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_NDF_DMA_INT
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_NDF_DMA_INT_EN
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The simulator crashes if you access non existant devices. Assume         only chip select 1 is connected to NAND */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
name|start_chip
operator|=
literal|1
expr_stmt|;
name|stop_chip
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|start_chip
operator|=
literal|0
expr_stmt|;
name|stop_chip
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Figure out how many clocks are in one microsecond, rounding up */
name|clocks_us
operator|=
name|CVMX_NAND_ROUNDUP
argument_list|(
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_SCLK
argument_list|)
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
comment|/* If the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is set, then     ** use the supplied default values to configured the chips in the     ** active_chips mask */
if|if
condition|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE
condition|)
block|{
if|if
condition|(
name|cvmx_nand_default
operator|.
name|page_size
condition|)
block|{
for|for
control|(
name|chip
operator|=
name|start_chip
init|;
name|chip
operator|<
name|stop_chip
condition|;
name|chip
operator|++
control|)
block|{
comment|/* Skip chip selects that the caller didn't supply in the active chip bits */
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|chip
operator|)
operator|&
name|active_chips
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|__set_chip_defaults
argument_list|(
name|chip
argument_list|,
name|clocks_us
argument_list|)
expr_stmt|;
block|}
block|}
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
comment|/* Probe and see what NAND flash we can find */
for|for
control|(
name|chip
operator|=
name|start_chip
init|;
name|chip
operator|<
name|stop_chip
condition|;
name|chip
operator|++
control|)
block|{
name|union
name|cvmx_mio_boot_reg_cfgx
name|mio_boot_reg_cfg
decl_stmt|;
name|cvmx_nand_onfi_param_page_t
modifier|*
name|onfi_param_page
decl_stmt|;
name|int
name|probe_failed
decl_stmt|;
name|int
name|width_16
decl_stmt|;
comment|/* Skip chip selects that the caller didn't supply in the active chip bits */
if|if
condition|(
operator|(
operator|(
literal|1
operator|<<
name|chip
operator|)
operator|&
name|active_chips
operator|)
operator|==
literal|0
condition|)
continue|continue;
name|mio_boot_reg_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_BOOT_REG_CFGX
argument_list|(
name|chip
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enabled regions can't be connected to NAND flash */
if|if
condition|(
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|en
condition|)
continue|continue;
comment|/* Start out with some sane, but slow, defaults */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|=
literal|0
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|=
literal|64
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
operator|=
literal|64
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
operator|=
literal|100
expr_stmt|;
comment|/* Set timing mode to ONFI mode 0 for initial accesses */
name|__set_onfi_timing_mode
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
argument_list|,
name|clocks_us
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Put the index of which timing parameter to use.  The indexes are into the tim_par         ** which match the indexes of the 8 timing parameters that the hardware supports.         ** Index 0 is not software controlled, and is fixed by hardware. */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Command doesn't need to be held before WE */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Twp, WE# pulse width */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|2
index|]
operator|=
literal|3
expr_stmt|;
comment|/* Tclh, CLE hold time */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|3
index|]
operator|=
literal|1
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|0
index|]
operator|=
literal|4
expr_stmt|;
comment|/* Tals, ALE setup time */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Twp, WE# pulse width */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|2
index|]
operator|=
literal|2
expr_stmt|;
comment|/* Twh, WE# pulse width high */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|3
index|]
operator|=
literal|5
expr_stmt|;
comment|/* Talh, ALE hold time */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|1
index|]
operator|=
literal|6
expr_stmt|;
comment|/* Trp, RE# pulse width*/
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|2
index|]
operator|=
literal|7
expr_stmt|;
comment|/* Treh, RE# high hold time */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|wrn
index|[
literal|0
index|]
operator|=
literal|1
expr_stmt|;
comment|/* Twp, WE# pulse width */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|wrn
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
comment|/* Twh, WE# pulse width high */
comment|/* Probe and see if we get an answer.  Read more than required, as in         ** 16 bit mode only every other byte is valid.         ** Here we probe twice, once in 8 bit mode, and once in 16 bit mode to autodetect         ** the width.         */
name|probe_failed
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|width_16
operator|=
literal|0
init|;
name|width_16
operator|<=
literal|1
operator|&&
name|probe_failed
condition|;
name|width_16
operator|++
control|)
block|{
name|probe_failed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|width_16
condition|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator||=
name|CVMX_NAND_STATE_16BIT
expr_stmt|;
name|memset
argument_list|(
name|cvmx_nand_buffer
argument_list|,
literal|0xff
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_read_id
argument_list|(
name|chip
argument_list|,
literal|0x0
argument_list|,
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_nand_buffer
argument_list|)
argument_list|,
literal|16
argument_list|)
operator|<
literal|16
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Failed to probe chip %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|probe_failed
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|cvmx_nand_buffer
operator|==
literal|0xffffffff
operator|||
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|cvmx_nand_buffer
operator|==
literal|0x0
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Probe returned nothing for chip %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|probe_failed
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Neither 8 or 16 bit mode worked, so go on to next chip select */
if|if
condition|(
name|probe_failed
condition|)
continue|continue;
comment|/* Save copy of ID for later use */
name|memcpy
argument_list|(
name|nand_id_buffer
argument_list|,
name|cvmx_nand_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|nand_id_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: NAND chip %d has ID 0x%08llx\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|chip
argument_list|,
operator|(
name|unsigned
name|long
name|long
name|int
operator|)
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_nand_buffer
argument_list|)
expr_stmt|;
comment|/* Read more than required, as in 16 bit mode only every other byte is valid. */
if|if
condition|(
name|cvmx_nand_read_id
argument_list|(
name|chip
argument_list|,
literal|0x20
argument_list|,
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_nand_buffer
argument_list|)
argument_list|,
literal|8
argument_list|)
operator|<
literal|8
condition|)
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Failed to probe chip %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|chip
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
operator|(
name|cvmx_nand_buffer
index|[
literal|0
index|]
operator|==
literal|'O'
operator|)
operator|&&
operator|(
name|cvmx_nand_buffer
index|[
literal|1
index|]
operator|==
literal|'N'
operator|)
operator|&&
operator|(
name|cvmx_nand_buffer
index|[
literal|2
index|]
operator|==
literal|'F'
operator|)
operator|&&
operator|(
name|cvmx_nand_buffer
index|[
literal|3
index|]
operator|==
literal|'I'
operator|)
operator|)
condition|)
block|{
comment|/* We have an ONFI part, so read the parameter page */
name|cvmx_nand_read_param_page
argument_list|(
name|chip
argument_list|,
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_nand_buffer
argument_list|)
argument_list|,
literal|2048
argument_list|)
expr_stmt|;
name|onfi_param_page
operator|=
name|__cvmx_nand_onfi_process
argument_list|(
operator|(
name|cvmx_nand_onfi_param_page_t
operator|*
operator|)
name|cvmx_nand_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|onfi_param_page
condition|)
block|{
comment|/* ONFI NAND parts are described by a parameter page.  Here we extract the configuration values                 ** from the parameter page that we need to access the chip. */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|=
name|cvmx_le32_to_cpu
argument_list|(
name|onfi_param_page
operator|->
name|page_data_bytes
argument_list|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|=
name|cvmx_le16_to_cpu
argument_list|(
name|onfi_param_page
operator|->
name|page_spare_bytes
argument_list|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
operator|=
name|cvmx_le32_to_cpu
argument_list|(
name|onfi_param_page
operator|->
name|pages_per_block
argument_list|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
operator|=
name|cvmx_le32_to_cpu
argument_list|(
name|onfi_param_page
operator|->
name|blocks_per_lun
argument_list|)
operator|*
name|onfi_param_page
operator|->
name|number_lun
expr_stmt|;
if|if
condition|(
name|cvmx_le16_to_cpu
argument_list|(
name|onfi_param_page
operator|->
name|timing_mode
argument_list|)
operator|<=
literal|0x3f
condition|)
block|{
name|int
name|mode_mask
init|=
name|cvmx_le16_to_cpu
argument_list|(
name|onfi_param_page
operator|->
name|timing_mode
argument_list|)
decl_stmt|;
name|int
name|mode
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|6
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mode_mask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|mode
operator|=
name|i
expr_stmt|;
block|}
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: Invalid timing mode (%d) in ONFI parameter page, ignoring\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Using ONFI timing mode: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
name|__set_onfi_timing_mode
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
argument_list|,
name|clocks_us
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|+
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|>
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: ERROR: Page size (%d) + OOB size (%d) is greater than max size (%d)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
argument_list|,
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|CVMX_NAND_ERROR
operator|)
return|;
block|}
comment|/* We have completed setup for this ONFI chip, so go on to next chip. */
continue|continue;
block|}
else|else
block|{
comment|/* Parameter page is not valid */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: ONFI paramater page missing or invalid.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We have a non-ONFI part. */
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Chip %d doesn't support ONFI.\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
name|nand_id_buffer
index|[
literal|0
index|]
operator|==
literal|0xEC
condition|)
block|{
comment|/* We have a Samsung part, so decode part info from ID bytes */
name|uint64_t
name|nand_size_bits
init|=
operator|(
literal|64
operator|*
literal|1024
operator|*
literal|1024ULL
operator|)
operator|<<
operator|(
operator|(
name|nand_id_buffer
index|[
literal|4
index|]
operator|&
literal|0x70
operator|)
operator|>>
literal|4
operator|)
decl_stmt|;
comment|/* Plane size */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|=
literal|1024
operator|<<
operator|(
name|nand_id_buffer
index|[
literal|3
index|]
operator|&
literal|0x3
operator|)
expr_stmt|;
comment|/* NAND page size in bytes */
comment|/* NAND OOB (spare) size in bytes (per page) */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|=
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|/
literal|512
operator|)
operator|*
operator|(
operator|(
name|nand_id_buffer
index|[
literal|3
index|]
operator|&
literal|4
operator|)
condition|?
literal|16
else|:
literal|8
operator|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
operator|=
operator|(
literal|0x10000
operator|<<
operator|(
operator|(
name|nand_id_buffer
index|[
literal|3
index|]
operator|&
literal|0x30
operator|)
operator|>>
literal|4
operator|)
operator|)
operator|/
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
expr_stmt|;
name|nand_size_bits
operator|*=
literal|1
operator|<<
operator|(
operator|(
name|nand_id_buffer
index|[
literal|4
index|]
operator|&
literal|0xc
operator|)
operator|>>
literal|2
operator|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|/
literal|64
expr_stmt|;
if|if
condition|(
name|nand_id_buffer
index|[
literal|3
index|]
operator|&
literal|0x4
condition|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|*=
literal|2
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
operator|=
name|nand_size_bits
operator|/
operator|(
literal|8ULL
operator|*
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|*
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
operator|)
expr_stmt|;
switch|switch
condition|(
name|nand_id_buffer
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|0xD3
case|:
comment|/* K9F8G08U0M */
case|case
literal|0xDC
case|:
comment|/* K9F4G08U0B */
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
operator|=
literal|6
expr_stmt|;
break|break;
default|default:
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
operator|=
literal|2
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: Samsung NAND chip detected, using parameters decoded from ID bytes.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%s: Defaults: page size: %d, OOB size: %d, pages per block %d, part size: %d MBytes, timing mode: %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
argument_list|,
call|(
name|int
call|)
argument_list|(
name|nand_size_bits
operator|/
operator|(
literal|8
operator|*
literal|1024
operator|*
literal|1024
operator|)
argument_list|)
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
block|}
name|__set_onfi_timing_mode
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
argument_list|,
name|clocks_us
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|+
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
operator|>
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"%s: ERROR: Page size (%d) + OOB size (%d) is greater than max size (%d)\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
argument_list|,
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
argument_list|,
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
name|CVMX_NAND_ERROR
operator|)
return|;
block|}
comment|/* We have completed setup for this Samsung chip, so go on to next chip. */
continue|continue;
block|}
block|}
comment|/*  We were not able to automatically identify the NAND chip parameters.  If default values were configured,         ** use them. */
if|if
condition|(
name|cvmx_nand_default
operator|.
name|page_size
condition|)
block|{
name|__set_chip_defaults
argument_list|(
name|chip
argument_list|,
name|clocks_us
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%s: Unable to determine NAND parameters, and no defaults supplied.\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_initialize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Call to shutdown the NAND controller after all transactions  * are done. In most setups this will never be called.  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|memset
argument_list|(
operator|&
name|cvmx_nand_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_nand_state
argument_list|)
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Returns a bitmask representing the chip selects that are  * connected to NAND chips. This can be called after the  * initialize to determine the actual number of NAND chips  * found. Each bit in the response coresponds to a chip select.  *  * @return Zero if no NAND chips were found. Otherwise a bit is set for  *         each chip select (1<<chip).  */
end_comment

begin_function
name|int
name|cvmx_nand_get_active_chips
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|chip
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
for|for
control|(
name|chip
operator|=
literal|0
init|;
name|chip
operator|<
literal|8
condition|;
name|chip
operator|++
control|)
block|{
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
condition|)
name|result
operator||=
literal|1
operator|<<
name|chip
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_get_active_chips
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Override the timing parameters for a NAND chip  *  * @param chip     Chip select to override  * @param tim_mult  * @param tim_par  * @param clen  * @param alen  * @param rdn  * @param wrn  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_set_timing
parameter_list|(
name|int
name|chip
parameter_list|,
name|int
name|tim_mult
parameter_list|,
name|int
name|tim_par
index|[
literal|8
index|]
parameter_list|,
name|int
name|clen
index|[
literal|4
index|]
parameter_list|,
name|int
name|alen
index|[
literal|4
index|]
parameter_list|,
name|int
name|rdn
index|[
literal|4
index|]
parameter_list|,
name|int
name|wrn
index|[
literal|2
index|]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_mult
operator|=
name|tim_mult
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
name|i
index|]
operator|=
name|tim_par
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
name|i
index|]
operator|=
name|clen
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
name|i
index|]
operator|=
name|alen
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
name|i
index|]
operator|=
name|rdn
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|wrn
index|[
name|i
index|]
operator|=
name|wrn
index|[
name|i
index|]
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Get the number of free bytes in the NAND command queue  *  * @return Number of bytes in queue  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_nand_get_free_cmd_bytes
parameter_list|(
name|void
parameter_list|)
block|{
name|union
name|cvmx_ndf_misc
name|ndf_misc
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|ndf_misc
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_NDF_MISC
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
operator|(
name|int
operator|)
name|ndf_misc
operator|.
name|s
operator|.
name|fr_byt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Submit a command to the NAND command queue. Generally this  * will not be used directly. Instead most programs will use the other  * higher level NAND functions.  *  * @param cmd    Command to submit  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_submit
parameter_list|(
name|cvmx_nand_cmd_t
name|cmd
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|cmd
operator|.
name|u64
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|cmd
operator|.
name|u64
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%s"
argument_list|,
name|cvmx_nand_opcode_labels
index|[
name|cmd
operator|.
name|s
operator|.
name|op_code
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
operator|.
name|s
operator|.
name|op_code
condition|)
block|{
comment|/* All these commands fit in one 64bit word */
case|case
literal|0
case|:
comment|/* NOP */
case|case
literal|1
case|:
comment|/* Timing */
case|case
literal|2
case|:
comment|/* WAIT */
case|case
literal|3
case|:
comment|/* Chip Enable/Disable */
case|case
literal|4
case|:
comment|/* CLE */
case|case
literal|8
case|:
comment|/* Write */
case|case
literal|9
case|:
comment|/* Read */
case|case
literal|10
case|:
comment|/* Read EDO */
case|case
literal|15
case|:
comment|/* Bus Aquire/Release */
if|if
condition|(
name|__cvmx_nand_get_free_cmd_bytes
argument_list|()
operator|<
literal|8
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_CMD
argument_list|,
name|cmd
operator|.
name|u64
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
case|case
literal|5
case|:
comment|/* ALE commands take either one or two 64bit words */
if|if
condition|(
name|cmd
operator|.
name|ale
operator|.
name|adr_byte_num
operator|<
literal|5
condition|)
block|{
if|if
condition|(
name|__cvmx_nand_get_free_cmd_bytes
argument_list|()
operator|<
literal|8
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_CMD
argument_list|,
name|cmd
operator|.
name|u64
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__cvmx_nand_get_free_cmd_bytes
argument_list|()
operator|<
literal|16
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_CMD
argument_list|,
name|cmd
operator|.
name|u64
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_CMD
argument_list|,
name|cmd
operator|.
name|u64
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
case|case
literal|11
case|:
comment|/* Wait status commands take two 64bit words */
if|if
condition|(
name|__cvmx_nand_get_free_cmd_bytes
argument_list|()
operator|<
literal|16
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_CMD
argument_list|,
name|cmd
operator|.
name|u64
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_CMD
argument_list|,
name|cmd
operator|.
name|u64
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
default|default:
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Get the number of bits required to encode the column bits. This  * does not include padding to align on a byte boundary.  *  * @param chip   NAND chip to get data for  *  * @return Number of column bits  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_nand_get_column_bits
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
return|return
name|cvmx_pop
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Get the number of bits required to encode the row bits. This  * does not include padding to align on a byte boundary.  *  * @param chip   NAND chip to get data for  *  * @return Number of row bits  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_nand_get_row_bits
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
return|return
name|cvmx_pop
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
operator|-
literal|1
argument_list|)
operator|+
name|cvmx_pop
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Get the number of address cycles required for this NAND part.  * This include column bits, padding, page bits, and block bits.  *  * @param chip   NAND chip to get data for  *  * @return Number of address cycles on the bus  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_nand_get_address_cycles
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|int
name|address_bits
init|=
operator|(
operator|(
name|__cvmx_nand_get_column_bits
argument_list|(
name|chip
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|<<
literal|3
decl_stmt|;
name|address_bits
operator|+=
operator|(
operator|(
name|__cvmx_nand_get_row_bits
argument_list|(
name|chip
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|<<
literal|3
expr_stmt|;
return|return
operator|(
name|address_bits
operator|+
literal|7
operator|)
operator|>>
literal|3
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Build the set of command common to most transactions  * @param chip      NAND chip to program  * @param cmd_data  NAND command for CLE cycle 1  * @param num_address_cycles  *                  Number of address cycles to put on the bus  * @param nand_address  *                  Data to be put on the bus. It is translated according to  *                  the rules in the file information section.  *  * @param cmd_data2 If non zero, adds a second CLE cycle used by a number of NAND  *                  transactions.  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
specifier|static
specifier|inline
name|cvmx_nand_status_t
name|__cvmx_nand_build_pre_cmd
parameter_list|(
name|int
name|chip
parameter_list|,
name|int
name|cmd_data
parameter_list|,
name|int
name|num_address_cycles
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|int
name|cmd_data2
parameter_list|)
block|{
name|cvmx_nand_status_t
name|result
decl_stmt|;
name|cvmx_nand_cmd_t
name|cmd
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
comment|/* Send timing parameters */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|one
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_mult
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_mult
expr_stmt|;
comment|/* tim_par[0] unused */
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|2
index|]
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par3
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|3
index|]
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par4
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|4
index|]
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par5
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|5
index|]
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par6
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|6
index|]
expr_stmt|;
name|cmd
operator|.
name|set_tm_par
operator|.
name|tim_par7
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|tim_par
index|[
literal|7
index|]
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Send bus select */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|bus_acq
operator|.
name|fifteen
operator|=
literal|15
expr_stmt|;
name|cmd
operator|.
name|bus_acq
operator|.
name|one
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Send chip select */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|chip_en
operator|.
name|chip
operator|=
name|chip
expr_stmt|;
name|cmd
operator|.
name|chip_en
operator|.
name|one
operator|=
literal|1
expr_stmt|;
name|cmd
operator|.
name|chip_en
operator|.
name|three
operator|=
literal|3
expr_stmt|;
name|cmd
operator|.
name|chip_en
operator|.
name|width
operator|=
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator|&
name|CVMX_NAND_STATE_16BIT
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Send wait, fixed time     ** This meets chip enable to command latch enable timing.     ** This is tCS - tCLS from the ONFI spec.     ** Use tWP as a proxy, as this is adequate for     ** all ONFI 1.0 timing modes. */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|two
operator|=
literal|2
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|n
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Send CLE */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|cmd_data
operator|=
name|cmd_data
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|0
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen3
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|2
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|four
operator|=
literal|4
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Send ALE */
if|if
condition|(
name|num_address_cycles
condition|)
block|{
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|adr_byte_num
operator|=
name|num_address_cycles
expr_stmt|;
if|if
condition|(
name|num_address_cycles
operator|<
name|__cvmx_nand_get_address_cycles
argument_list|(
name|chip
argument_list|)
condition|)
block|{
name|cmd
operator|.
name|ale
operator|.
name|adr_bytes_l
operator|=
name|nand_address
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|adr_bytes_h
operator|=
name|nand_address
operator|>>
literal|32
expr_stmt|;
block|}
else|else
block|{
name|int
name|column_bits
init|=
name|__cvmx_nand_get_column_bits
argument_list|(
name|chip
argument_list|)
decl_stmt|;
name|int
name|column_shift
init|=
operator|(
operator|(
name|column_bits
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|<<
literal|3
decl_stmt|;
name|int
name|column
init|=
name|nand_address
operator|&
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|-
literal|1
operator|)
decl_stmt|;
name|int
name|row
init|=
name|nand_address
operator|>>
name|column_bits
decl_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|adr_bytes_l
operator|=
name|column
operator|+
operator|(
name|row
operator|<<
name|column_shift
operator|)
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|adr_bytes_h
operator|=
name|row
operator|>>
operator|(
literal|32
operator|-
name|column_shift
operator|)
expr_stmt|;
block|}
name|cmd
operator|.
name|ale
operator|.
name|alen1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|0
index|]
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|alen2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|alen3
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|2
index|]
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|alen4
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|alen
index|[
literal|3
index|]
expr_stmt|;
name|cmd
operator|.
name|ale
operator|.
name|five
operator|=
literal|5
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
comment|/* Send CLE 2 */
if|if
condition|(
name|cmd_data2
condition|)
block|{
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|cmd_data
operator|=
name|cmd_data2
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|0
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen3
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|2
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|four
operator|=
literal|4
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
block|}
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Build the set of command common to most transactions  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
specifier|static
specifier|inline
name|cvmx_nand_status_t
name|__cvmx_nand_build_post_cmd
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_nand_status_t
name|result
decl_stmt|;
name|cvmx_nand_cmd_t
name|cmd
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
comment|/* Send chip deselect */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|chip_dis
operator|.
name|three
operator|=
literal|3
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Send bus release */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|bus_rel
operator|.
name|fifteen
operator|=
literal|15
expr_stmt|;
name|result
operator|=
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* Ring the doorbell */
name|cvmx_write_csr
argument_list|(
name|CVMX_NDF_DRBELL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Setup the NAND DMA engine for a transfer  *  * @param chip     Chip select for NAND flash  * @param is_write Non zero if this is a write  * @param buffer_address  *                 Physical memory address to DMA to/from  * @param buffer_length  *                 Length of the DMA in bytes  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_nand_setup_dma
parameter_list|(
name|int
name|chip
parameter_list|,
name|int
name|is_write
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|union
name|cvmx_mio_ndf_dma_cfg
name|ndf_dma_cfg
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|is_write
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|ndf_dma_cfg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ndf_dma_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|ndf_dma_cfg
operator|.
name|s
operator|.
name|rw
operator|=
name|is_write
expr_stmt|;
comment|/* One means DMA reads from memory and writes to flash */
name|ndf_dma_cfg
operator|.
name|s
operator|.
name|clr
operator|=
literal|0
expr_stmt|;
name|ndf_dma_cfg
operator|.
name|s
operator|.
name|size
operator|=
operator|(
operator|(
name|buffer_length
operator|+
literal|7
operator|)
operator|>>
literal|3
operator|)
operator|-
literal|1
expr_stmt|;
name|ndf_dma_cfg
operator|.
name|s
operator|.
name|adr
operator|=
name|buffer_address
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_NDF_DMA_CFG
argument_list|,
name|ndf_dma_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN_NOTHING
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Dump a buffer out in hex for debug  *  * @param buffer_address  *               Starting physical address  * @param buffer_length  *               Number of bytes to display  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_nand_hex_dump
parameter_list|(
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|uint8_t
modifier|*
name|buffer
init|=
name|cvmx_phys_to_ptr
argument_list|(
name|buffer_address
argument_list|)
decl_stmt|;
name|int
name|offset
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|buffer_length
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%*s%04x:"
argument_list|,
literal|2
operator|*
name|debug_indent
argument_list|,
literal|""
argument_list|,
name|offset
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
name|cvmx_dprintf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|i
operator|<
name|buffer_length
condition|)
name|cvmx_dprintf
argument_list|(
literal|"%02x"
argument_list|,
literal|0xff
operator|&
name|buffer
index|[
name|offset
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|cvmx_dprintf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|offset
operator|+=
literal|32
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Perform a low level NAND read command  *  * @param chip   Chip to read from  * @param nand_command1  *               First command cycle value  * @param address_cycles  *               Number of address cycles after comand 1  * @param nand_address  *               NAND address to use for address cycles  * @param nand_command2  *               NAND command cycle 2 if not zero  * @param buffer_address  *               Physical address to DMA into  * @param buffer_length  *               Length of the transfer in bytes  *  * @return Number of bytes transfered or a negative error code  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_nand_low_level_read
parameter_list|(
name|int
name|chip
parameter_list|,
name|int
name|nand_command1
parameter_list|,
name|int
name|address_cycles
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|int
name|nand_command2
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|cvmx_nand_cmd_t
name|cmd
decl_stmt|;
name|union
name|cvmx_mio_ndf_dma_cfg
name|ndf_dma_cfg
decl_stmt|;
name|int
name|bytes
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|nand_command1
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|address_cycles
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|nand_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%x"
argument_list|,
name|nand_command2
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_address
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_address
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_length
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_length
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Build the command and address cycles */
if|if
condition|(
name|__cvmx_nand_build_pre_cmd
argument_list|(
name|chip
argument_list|,
name|nand_command1
argument_list|,
name|address_cycles
argument_list|,
name|nand_address
argument_list|,
name|nand_command2
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Send WAIT.  This waits for some time, then     ** waits for busy to be de-asserted. */
if|if
condition|(
name|__wait_for_busy_done
argument_list|(
name|chip
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Wait for tRR after busy de-asserts.     ** Use 2* tALS as proxy.  This is overkill in     ** the slow modes, but not bad in the faster ones. */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|two
operator|=
literal|2
expr_stmt|;
name|cmd
operator|.
name|wait
operator|.
name|n
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Send READ */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|rd
operator|.
name|data_bytes
operator|=
name|buffer_length
expr_stmt|;
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|onfi_timing
operator|>=
literal|4
condition|)
name|cmd
operator|.
name|rd
operator|.
name|nine
operator|=
literal|10
expr_stmt|;
comment|/* READ_EDO command is required for ONFI timing modes 4 and 5 */
else|else
name|cmd
operator|.
name|rd
operator|.
name|nine
operator|=
literal|9
expr_stmt|;
name|cmd
operator|.
name|rd
operator|.
name|rdn1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|0
index|]
expr_stmt|;
name|cmd
operator|.
name|rd
operator|.
name|rdn2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|.
name|rd
operator|.
name|rdn3
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|2
index|]
expr_stmt|;
name|cmd
operator|.
name|rd
operator|.
name|rdn4
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|rdn
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|__cvmx_nand_setup_dma
argument_list|(
name|chip
argument_list|,
literal|0
argument_list|,
name|buffer_address
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_nand_build_post_cmd
argument_list|()
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|WATCHDOG_RESET
argument_list|()
expr_stmt|;
comment|/* Wait for the DMA to complete */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_MIO_NDF_DMA_CFG
argument_list|,
name|cvmx_mio_ndf_dma_cfg_t
argument_list|,
name|en
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|NAND_TIMEOUT_USECS_READ
argument_list|)
condition|)
block|{
name|WATCHDOG_RESET
argument_list|()
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_TIMEOUT
argument_list|)
expr_stmt|;
block|}
comment|/* Return the number of bytes transfered */
name|ndf_dma_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_NDF_DMA_CFG
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|ndf_dma_cfg
operator|.
name|s
operator|.
name|adr
operator|-
name|buffer_address
expr_stmt|;
if|if
condition|(
name|cvmx_unlikely
argument_list|(
name|cvmx_nand_flags
operator|&
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
argument_list|)
condition|)
name|__cvmx_nand_hex_dump
argument_list|(
name|buffer_address
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read a page from NAND. If the buffer has room, the out of band  * data will be included.  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               Location in NAND to read. See description in file comment  * @param buffer_address  *               Physical address to store the result at  * @param buffer_length  *               Number of bytes to read  *  * @return Bytes read on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_page_read
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|nand_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_address
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_address
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_length
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_length
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* For 16 bit mode, addresses within a page are word address, rather than byte addresses */
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator|&
name|CVMX_NAND_STATE_16BIT
condition|)
name|nand_address
operator|=
operator|(
name|nand_address
operator|&
operator|~
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|nand_address
operator|&
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|bytes
operator|=
name|__cvmx_nand_low_level_read
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_READ
argument_list|,
name|__cvmx_nand_get_address_cycles
argument_list|(
name|chip
argument_list|)
argument_list|,
name|nand_address
argument_list|,
name|NAND_COMMAND_READ_FIN
argument_list|,
name|buffer_address
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_page_read
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Write a page to NAND. The buffer must contain the entire page  * including the out of band data.  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               Location in NAND to write. See description in file comment  * @param buffer_address  *               Physical address to read the data from  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_page_write
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|)
block|{
name|cvmx_nand_cmd_t
name|cmd
decl_stmt|;
name|int
name|buffer_length
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|nand_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_address
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_address
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* For 16 bit mode, addresses within a page are word address, rather than byte addresses */
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator|&
name|CVMX_NAND_STATE_16BIT
condition|)
name|nand_address
operator|=
operator|(
name|nand_address
operator|&
operator|~
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
operator||
operator|(
operator|(
name|nand_address
operator|&
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|-
literal|1
operator|)
operator|)
operator|>>
literal|1
operator|)
expr_stmt|;
name|buffer_length
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
operator|+
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
expr_stmt|;
comment|/* The NAND DMA engine always does transfers in 8 byte blocks, so round the buffer size down     ** to a multiple of 8, otherwise we will transfer too much data to the NAND chip.     ** Note this prevents the last few bytes of the OOB being written.  If these bytes     ** need to be written, then this check needs to be removed, but this will result in     ** extra write cycles beyond the end of the OOB. */
name|buffer_length
operator|&=
operator|~
literal|0x7
expr_stmt|;
comment|/* Build the command and address cycles */
if|if
condition|(
name|__cvmx_nand_build_pre_cmd
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_PROGRAM
argument_list|,
name|__cvmx_nand_get_address_cycles
argument_list|(
name|chip
argument_list|)
argument_list|,
name|nand_address
argument_list|,
literal|0
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Send WRITE */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|wr
operator|.
name|data_bytes
operator|=
name|buffer_length
expr_stmt|;
name|cmd
operator|.
name|wr
operator|.
name|eight
operator|=
literal|8
expr_stmt|;
name|cmd
operator|.
name|wr
operator|.
name|wrn1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|wrn
index|[
literal|0
index|]
expr_stmt|;
name|cmd
operator|.
name|wr
operator|.
name|wrn2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|wrn
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Send WRITE command */
name|memset
argument_list|(
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|cmd_data
operator|=
name|NAND_COMMAND_PROGRAM_FIN
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen1
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|0
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen2
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|1
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|clen3
operator|=
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|clen
index|[
literal|2
index|]
expr_stmt|;
name|cmd
operator|.
name|cle
operator|.
name|four
operator|=
literal|4
expr_stmt|;
if|if
condition|(
name|cvmx_nand_submit
argument_list|(
name|cmd
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|__cvmx_nand_setup_dma
argument_list|(
name|chip
argument_list|,
literal|1
argument_list|,
name|buffer_address
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
comment|/* WAIT for R_B to signal program is complete  */
if|if
condition|(
name|__wait_for_busy_done
argument_list|(
name|chip
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_nand_build_post_cmd
argument_list|()
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Wait for the DMA to complete */
name|WATCHDOG_RESET
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_MIO_NDF_DMA_CFG
argument_list|,
name|cvmx_mio_ndf_dma_cfg_t
argument_list|,
name|en
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|NAND_TIMEOUT_USECS_WRITE
argument_list|)
condition|)
block|{
name|WATCHDOG_RESET
argument_list|()
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_TIMEOUT
argument_list|)
expr_stmt|;
block|}
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_page_write
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Erase a NAND block. A single block contains multiple pages.  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               Location in NAND to erase. See description in file comment  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_block_erase
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|nand_address
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
comment|/* Build the command and address cycles */
if|if
condition|(
name|__cvmx_nand_build_pre_cmd
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_ERASE
argument_list|,
operator|(
name|__cvmx_nand_get_row_bits
argument_list|(
name|chip
argument_list|)
operator|+
literal|7
operator|)
operator|>>
literal|3
argument_list|,
name|nand_address
operator|>>
name|__cvmx_nand_get_column_bits
argument_list|(
name|chip
argument_list|)
argument_list|,
name|NAND_COMMAND_ERASE_FIN
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* WAIT for R_B to signal erase is complete  */
if|if
condition|(
name|__wait_for_busy_done
argument_list|(
name|chip
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_nand_build_post_cmd
argument_list|()
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* Wait for the command queue to be idle, which means the wait is done */
name|WATCHDOG_RESET
argument_list|()
expr_stmt|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_NDF_ST_REG
argument_list|,
name|cvmx_ndf_st_reg_t
argument_list|,
name|exe_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
name|NAND_TIMEOUT_USECS_BLOCK_ERASE
argument_list|)
condition|)
block|{
name|WATCHDOG_RESET
argument_list|()
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_TIMEOUT
argument_list|)
expr_stmt|;
block|}
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_block_erase
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Some reads (read ID, read parameter page) only use the low 8 bits of the bus ** in 16 bit mode.  We remove the unused bytes so that the data we present to the ** caller is as expected (same as 8 bit mode.) */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_nand_fixup_16bit_id_reads
parameter_list|(
name|uint8_t
modifier|*
name|buf
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
comment|/* Decimate data, taking only every other byte. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|buffer_length
operator|/
literal|2
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|buf
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read the NAND ID information  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               NAND address to read ID from. Usually this is either 0x0 or 0x20.  * @param buffer_address  *               Physical address to store data in  * @param buffer_length  *               Length of the buffer. Usually this is 4-8 bytes.  For 16 bit mode, this must be twice  *               as large as the actual expected data.  *  * @return Bytes read on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_read_id
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|nand_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_address
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_address
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_length
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|__cvmx_nand_low_level_read
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_READ_ID
argument_list|,
literal|1
argument_list|,
name|nand_address
argument_list|,
literal|0
argument_list|,
name|buffer_address
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator|&
name|CVMX_NAND_STATE_16BIT
condition|)
name|__cvmx_nand_fixup_16bit_id_reads
argument_list|(
name|cvmx_phys_to_ptr
argument_list|(
name|buffer_address
argument_list|)
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_read_id
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Read the NAND parameter page  *  * @param chip   Chip select for NAND flash  * @param buffer_address  *               Physical address to store data in  * @param buffer_length  *               Length of the buffer.  Usually 1024 bytes for 8 bit, 2048 for 16 bit mode.  *  * @return Bytes read on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_read_param_page
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|int
name|bytes
decl_stmt|;
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"0x%llx"
argument_list|,
operator|(
name|ULL
operator|)
name|buffer_address
argument_list|)
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_address
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_address
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer_length
operator|&
literal|7
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buffer_length
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|bytes
operator|=
name|__cvmx_nand_low_level_read
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_READ_PARAM_PAGE
argument_list|,
literal|1
argument_list|,
literal|0x0
argument_list|,
literal|0
argument_list|,
name|buffer_address
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator|&
name|CVMX_NAND_STATE_16BIT
condition|)
name|__cvmx_nand_fixup_16bit_id_reads
argument_list|(
name|cvmx_phys_to_ptr
argument_list|(
name|buffer_address
argument_list|)
argument_list|,
name|buffer_length
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|bytes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the status of the NAND flash  *  * @param chip   Chip select for NAND flash  *  * @return NAND status or a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_get_status
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|int
name|offset
init|=
operator|!
operator|!
operator|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|flags
operator|&
name|CVMX_NAND_STATE_16BIT
operator|)
decl_stmt|;
comment|/* Normalize flag to 0/1 */
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cvmx_nand_buffer
operator|+
name|offset
operator|)
operator|=
literal|0xff
expr_stmt|;
name|status
operator|=
name|__cvmx_nand_low_level_read
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_STATUS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|cvmx_ptr_to_phys
argument_list|(
name|cvmx_nand_buffer
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|>
literal|0
condition|)
name|status
operator|=
operator|*
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|cvmx_nand_buffer
operator|+
name|offset
operator|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_get_status
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the page size, excluding out of band data. This  function  * will return zero for chip selects not connected to NAND.  *  * @param chip   Chip select for NAND flash  *  * @return Page size in bytes or a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_get_page_size
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the OOB size.  *  * @param chip   Chip select for NAND flash  *  * @return OOB in bytes or a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_get_oob_size
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|oob_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the number of pages per NAND block  *  * @param chip   Chip select for NAND flash  *  * @return Number of pages in each block or a negative cvmx_nand_status_t error  *         code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_get_pages_per_block
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|pages_per_block
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Get the number of blocks in the NAND flash  *  * @param chip   Chip select for NAND flash  *  * @return Number of blocks or a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|int
name|cvmx_nand_get_blocks
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|blocks
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Reset the NAND flash  *  * @param chip   Chip select for NAND flash  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
end_comment

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_reset
parameter_list|(
name|int
name|chip
parameter_list|)
block|{
name|CVMX_NAND_LOG_CALLED
argument_list|()
expr_stmt|;
name|CVMX_NAND_LOG_PARAM
argument_list|(
literal|"%d"
argument_list|,
name|chip
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chip
operator|<
literal|0
operator|)
operator|||
operator|(
name|chip
operator|>
literal|7
operator|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_nand_state
index|[
name|chip
index|]
operator|.
name|page_size
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_nand_build_pre_cmd
argument_list|(
name|chip
argument_list|,
name|NAND_COMMAND_RESET
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
comment|/* WAIT for R_B to signal reset is complete  */
if|if
condition|(
name|__wait_for_busy_done
argument_list|(
name|chip
argument_list|)
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_nand_build_post_cmd
argument_list|()
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_NO_MEMORY
argument_list|)
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_nand_reset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * This function computes the Octeon specific ECC data used by the NAND boot  * feature.  *  * @param block  pointer to 256 bytes of data  * @param eccp   pointer to where 8 bytes of ECC data will be stored  */
end_comment

begin_function
name|void
name|cvmx_nand_compute_boot_ecc
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|eccp
parameter_list|)
block|{
name|unsigned
name|char
name|pd0
decl_stmt|,
name|pd1
decl_stmt|,
name|pd2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|pd0
operator|=
name|pd1
operator|=
name|pd2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD0<0> */
name|pd0
operator|^=
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|)
operator|&
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD0<1> */
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD0<2> */
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
comment|/* PD0<3> */
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
comment|/* PD0<4> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
comment|/* PD0<5> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
comment|/* PD0<6> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
comment|/* PD0<7> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
comment|/* PD1<0> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|pd1
operator|^=
operator|(
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
comment|/* PD1<1> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|pd1
operator|^=
operator|(
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
comment|/* PD1<2> */
name|pd1
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* PD1<3> */
comment|/* PD1<4> */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD1<5> */
name|pd1
operator|^=
operator|(
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD1<6> */
name|pd1
operator|^=
operator|(
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD1<7> */
name|pd1
operator|^=
operator|(
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
comment|/* PD2<0> */
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
comment|/* PD2<1> */
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
comment|/* PD2<2> */
for|for
control|(
name|j
operator|=
literal|4
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
comment|/* PD2<3> */
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
comment|/* PD2<4> */
for|for
control|(
name|j
operator|=
literal|16
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
comment|/* PD2<5> */
for|for
control|(
name|j
operator|=
literal|32
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
comment|/* PD2<6> */
for|for
control|(
name|j
operator|=
literal|64
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|128
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD2<7> */
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
name|eccp
index|[
literal|0
index|]
operator|=
name|pd0
expr_stmt|;
name|eccp
index|[
literal|1
index|]
operator|=
name|pd1
expr_stmt|;
name|eccp
index|[
literal|2
index|]
operator|=
name|pd2
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Check an Octeon ECC block, fixing errors if possible  *  * @param block  Pointer to block to check  *  * @return Zero if block has no errors, one if errors were corrected, two  *         if the errors could not be corrected.  */
end_comment

begin_function
name|int
name|cvmx_nand_correct_boot_ecc
parameter_list|(
name|uint8_t
modifier|*
name|block
parameter_list|)
block|{
name|unsigned
name|char
name|pd0
decl_stmt|,
name|pd1
decl_stmt|,
name|pd2
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|unsigned
name|char
name|xorpd0
decl_stmt|,
name|xorpd1
decl_stmt|,
name|xorpd2
decl_stmt|;
name|int
name|xor_num
decl_stmt|;
name|unsigned
name|int
name|check
decl_stmt|;
asm|asm
specifier|volatile
asm|("pref 0,0(%0);pref 0,128(%0);pref 0,256(%0)\n" :: "r" (block));
name|pd0
operator|=
name|pd1
operator|=
name|pd2
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD0<0> */
name|pd0
operator|^=
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|)
operator|&
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD0<1> */
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD0<2> */
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
comment|/* PD0<3> */
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
comment|/* PD0<4> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|2
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
comment|/* PD0<5> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
comment|/* PD0<6> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
comment|/* PD0<7> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|pd0
operator|^=
operator|(
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
comment|/* PD1<0> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|pd1
operator|^=
operator|(
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
comment|/* PD1<1> */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|pd1
operator|^=
operator|(
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
comment|/* PD1<2> */
name|pd1
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
comment|/* PD1<3> */
comment|/* PD1<4> */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD1<5> */
name|pd1
operator|^=
operator|(
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD1<6> */
name|pd1
operator|^=
operator|(
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD1<7> */
name|pd1
operator|^=
operator|(
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|128
condition|;
name|i
operator|++
control|)
comment|/* PD2<0> */
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|2
operator|*
name|i
operator|+
literal|1
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
comment|/* PD2<1> */
for|for
control|(
name|j
operator|=
literal|2
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|4
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
comment|/* PD2<2> */
for|for
control|(
name|j
operator|=
literal|4
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|8
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
comment|/* PD2<3> */
for|for
control|(
name|j
operator|=
literal|8
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|16
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
comment|/* PD2<4> */
for|for
control|(
name|j
operator|=
literal|16
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|32
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|4
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
comment|/* PD2<5> */
for|for
control|(
name|j
operator|=
literal|32
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|64
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
comment|/* PD2<6> */
for|for
control|(
name|j
operator|=
literal|64
init|;
name|j
operator|<
literal|128
condition|;
name|j
operator|++
control|)
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
literal|128
operator|*
name|i
operator|+
name|j
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|6
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|128
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
comment|/* PD2<7> */
name|pd2
operator|^=
operator|(
operator|(
name|block
index|[
name|i
index|]
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|1
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|2
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|3
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|4
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|5
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|6
operator|)
operator|^
operator|(
name|block
index|[
name|i
index|]
operator|>>
literal|7
operator|)
operator|)
operator|&
literal|1
operator|)
operator|<<
literal|7
expr_stmt|;
name|xorpd0
operator|=
name|pd0
operator|^
name|block
index|[
literal|256
index|]
expr_stmt|;
name|xorpd1
operator|=
name|pd1
operator|^
name|block
index|[
literal|257
index|]
expr_stmt|;
name|xorpd2
operator|=
name|pd2
operator|^
name|block
index|[
literal|258
index|]
expr_stmt|;
name|xor_num
operator|=
name|__builtin_popcount
argument_list|(
operator|(
name|xorpd0
operator|<<
literal|16
operator|)
operator||
operator|(
name|xorpd1
operator|<<
literal|8
operator|)
operator||
name|xorpd2
argument_list|)
expr_stmt|;
name|check
operator|=
operator|(
operator|(
operator|(
name|xorpd1
operator|&
literal|7
operator|)
operator|<<
literal|8
operator|)
operator||
name|xorpd0
operator|)
operator|^
operator|(
operator|(
name|xorpd2
operator|<<
literal|3
operator|)
operator||
operator|(
name|xorpd1
operator|>>
literal|5
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|xor_num
operator|==
literal|0
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
operator|(
name|xor_num
operator|>
literal|1
operator|)
operator|&&
operator|(
name|check
operator|!=
literal|0x7FF
operator|)
condition|)
return|return
literal|2
return|;
if|if
condition|(
name|check
operator|==
literal|0x7FF
condition|)
block|{
comment|/* Correct the error */
name|block
index|[
name|xorpd2
index|]
operator|^=
literal|1
operator|<<
operator|(
name|xorpd1
operator|>>
literal|5
operator|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
name|cvmx_nand_status_t
name|cvmx_nand_set_defaults
parameter_list|(
name|int
name|page_size
parameter_list|,
name|int
name|oob_size
parameter_list|,
name|int
name|pages_per_block
parameter_list|,
name|int
name|blocks
parameter_list|,
name|int
name|onfi_timing_mode
parameter_list|)
block|{
if|if
condition|(
operator|!
name|page_size
operator|||
operator|!
name|oob_size
operator|||
operator|!
name|pages_per_block
operator|||
operator|!
name|blocks
operator|||
name|onfi_timing_mode
operator|>
literal|5
condition|)
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_INVALID_PARAM
argument_list|)
expr_stmt|;
name|cvmx_nand_default
operator|.
name|page_size
operator|=
name|page_size
expr_stmt|;
name|cvmx_nand_default
operator|.
name|oob_size
operator|=
name|oob_size
expr_stmt|;
name|cvmx_nand_default
operator|.
name|pages_per_block
operator|=
name|pages_per_block
expr_stmt|;
name|cvmx_nand_default
operator|.
name|blocks
operator|=
name|blocks
expr_stmt|;
name|cvmx_nand_default
operator|.
name|onfi_timing
operator|=
name|onfi_timing_mode
expr_stmt|;
name|CVMX_NAND_RETURN
argument_list|(
name|CVMX_NAND_SUCCESS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

