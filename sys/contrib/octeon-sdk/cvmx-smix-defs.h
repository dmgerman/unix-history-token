begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-smix-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon smix.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SMIX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SMIX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SMIX_CLK
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SMIX_CLK(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001818ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|256
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SMIX_CLK
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001818ull) + ((offset)& 1) * 256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SMIX_CMD
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SMIX_CMD(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001800ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|256
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SMIX_CMD
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001800ull) + ((offset)& 1) * 256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SMIX_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SMIX_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001820ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|256
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SMIX_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001820ull) + ((offset)& 1) * 256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SMIX_RD_DAT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SMIX_RD_DAT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001810ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|256
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SMIX_RD_DAT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001810ull) + ((offset)& 1) * 256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_SMIX_WR_DAT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_SMIX_WR_DAT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001808ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|256
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_SMIX_WR_DAT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001808ull) + ((offset)& 1) * 256)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_smi#_clk  *  * SMI_CLK = Clock Control Register  *  */
end_comment

begin_union
union|union
name|cvmx_smix_clk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_smix_clk_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
comment|/**< IEEE operating mode                                                          0=Clause 22 complient                                                          1=Clause 45 complient */
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|sample_hi
range|:
literal|5
decl_stmt|;
comment|/**< When to sample read data (extended bits) */
name|uint64_t
name|sample_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Data sampling mode                                                          According to the 802.3 spec, on reads, the STA                                                          transitions MDC and the PHY drives MDIO with                                                          some delay relative to that edge.  This is edge1.                                                          The STA then samples MDIO on the next rising edge                                                          of MDC.  This is edge2. Octeon can sample the                                                          read data relative to either edge.                                                           0=[SAMPLE_HI,SAMPLE] specify the sample time                                                             relative to edge2                                                           1=[SAMPLE_HI,SAMPLE] specify the sample time                                                             relative to edge1 */
name|uint64_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_idle
range|:
literal|1
decl_stmt|;
comment|/**< Do not toggle MDC on idle cycles */
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
comment|/**< Send PREAMBLE on SMI transacton                                                          PREAMBLE must be set 1 when MODE=1 in order                                                          for the receiving PHY to correctly frame the                                                          transaction. */
name|uint64_t
name|sample
range|:
literal|4
decl_stmt|;
comment|/**< When to sample read data                                                          (number of eclks after the rising edge of mdc)                                                          ( [SAMPLE_HI,SAMPLE]> 1 )                                                          ( [SAMPLE_HI, SAMPLE] + 3<= 2*PHASE ) */
name|uint64_t
name|phase
range|:
literal|8
decl_stmt|;
comment|/**< MDC Clock Phase                                                          (number of eclks that make up an mdc phase)                                                          (PHASE> 2) */
else|#
directive|else
name|uint64_t
name|phase
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sample
range|:
literal|4
decl_stmt|;
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sample_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sample_hi
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_23
range|:
literal|3
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_smix_clk_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|sample_hi
range|:
literal|5
decl_stmt|;
comment|/**< When to sample read data (extended bits) */
name|uint64_t
name|sample_mode
range|:
literal|1
decl_stmt|;
comment|/**< Read Data sampling mode                                                          According to the 802.3 spec, on reads, the STA                                                          transitions MDC and the PHY drives MDIO with                                                          some delay relative to that edge.  This is edge1.                                                          The STA then samples MDIO on the next rising edge                                                          of MDC.  This is edge2. Octeon can sample the                                                          read data relative to either edge.                                                           0=[SAMPLE_HI,SAMPLE] specify the sample time                                                             relative to edge2                                                           1=[SAMPLE_HI,SAMPLE] specify the sample time                                                             relative to edge1 */
name|uint64_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_idle
range|:
literal|1
decl_stmt|;
comment|/**< Do not toggle MDC on idle cycles */
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
comment|/**< Send PREAMBLE on SMI transacton */
name|uint64_t
name|sample
range|:
literal|4
decl_stmt|;
comment|/**< When to sample read data                                                          (number of eclks after the rising edge of mdc)                                                          ( [SAMPLE_HI,SAMPLE]> 1 )                                                          ( [SAMPLE_HI, SAMPLE] + 3<= 2*PHASE ) */
name|uint64_t
name|phase
range|:
literal|8
decl_stmt|;
comment|/**< MDC Clock Phase                                                          (number of eclks that make up an mdc phase)                                                          (PHASE> 2) */
else|#
directive|else
name|uint64_t
name|phase
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sample
range|:
literal|4
decl_stmt|;
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_14
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sample_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sample_hi
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_smix_clk_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_smix_clk_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_smix_clk_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_smix_clk
name|cvmx_smix_clk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_smi#_cmd  *  * SMI_CMD = Force a Read/Write command to the PHY  *  *  * Notes:  * Writes to this register will create SMI xactions.  Software will poll on (depending on the xaction type).  *  */
end_comment

begin_union
union|union
name|cvmx_smix_cmd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_smix_cmd_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|phy_op
range|:
literal|2
decl_stmt|;
comment|/**< PHY Opcode depending on SMI_CLK[MODE]                                                          SMI_CLK[MODE] == 0 (<=1Gbs / Clause 22)                                                           x0=write                                                           x1=read                                                          SMI_CLK[MODE] == 1 (>1Gbs / Clause 45)                                                           00=address                                                           01=write                                                           11=read                                                           10=post-read-increment-address */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|phy_adr
range|:
literal|5
decl_stmt|;
comment|/**< PHY Address */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reg_adr
range|:
literal|5
decl_stmt|;
comment|/**< PHY Register Offset */
else|#
directive|else
name|uint64_t
name|reg_adr
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|phy_adr
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|phy_op
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_smix_cmd_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|phy_op
range|:
literal|1
decl_stmt|;
comment|/**< PHY Opcode                                                          0=write                                                          1=read */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|phy_adr
range|:
literal|5
decl_stmt|;
comment|/**< PHY Address */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reg_adr
range|:
literal|5
decl_stmt|;
comment|/**< PHY Register Offset */
else|#
directive|else
name|uint64_t
name|reg_adr
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|phy_adr
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|phy_op
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_smix_cmd_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_smix_cmd_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_smix_cmd_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_smix_cmd
name|cvmx_smix_cmd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_smi#_en  *  * SMI_EN = Enable the SMI interface  *  */
end_comment

begin_union
union|union
name|cvmx_smix_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_smix_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface enable                                                          0=SMI Interface is down / no transactions, no MDC                                                          1=SMI Interface is up */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_smix_en_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_smix_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_smix_en
name|cvmx_smix_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_smi#_rd_dat  *  * SMI_RD_DAT = SMI Read Data  *  *  * Notes:  * VAL will assert when the read xaction completes.  A read to this register  * will clear VAL.  PENDING indicates that an SMI RD transaction is in flight.  */
end_comment

begin_union
union|union
name|cvmx_smix_rd_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_smix_rd_dat_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|pending
range|:
literal|1
decl_stmt|;
comment|/**< Read Xaction Pending */
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
comment|/**< Read Data Valid */
name|uint64_t
name|dat
range|:
literal|16
decl_stmt|;
comment|/**< Read Data */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|16
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pending
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_smix_rd_dat_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_smix_rd_dat
name|cvmx_smix_rd_dat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_smi#_wr_dat  *  * SMI_WR_DAT = SMI Write Data  *  *  * Notes:  * VAL will assert when the write xaction completes.  A read to this register  * will clear VAL.  PENDING indicates that an SMI WR transaction is in flight.  */
end_comment

begin_union
union|union
name|cvmx_smix_wr_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_smix_wr_dat_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|pending
range|:
literal|1
decl_stmt|;
comment|/**< Write Xaction Pending */
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
comment|/**< Write Data Valid */
name|uint64_t
name|dat
range|:
literal|16
decl_stmt|;
comment|/**< Write Data */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|16
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pending
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_smix_wr_dat_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_smix_wr_dat
name|cvmx_smix_wr_dat_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

