begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Module to support operations on bitmap of cores. Coremask can be used to  * select a specific core, a group of cores, or all available cores, for  * initialization and differentiation of roles within a single shared binary  * executable image.  *  *<hr>$Revision: 49448 $<hr>  *  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-coremask.h"
end_include

begin_define
define|#
directive|define
name|CVMX_COREMASK_MAX_SYNCS
value|20
end_define

begin_comment
comment|/* maximum number of coremasks for barrier sync */
end_comment

begin_comment
comment|/**  * This structure defines the private state maintained by coremask module.  *  */
end_comment

begin_expr_stmt
name|CVMX_SHARED
specifier|static
expr|struct
block|{
name|cvmx_spinlock_t
name|lock
block|;
comment|/**< mutex spinlock */
block|struct
block|{
name|unsigned
name|int
name|coremask
block|;
comment|/**< coremask specified for barrier */
name|unsigned
name|int
name|checkin
block|;
comment|/**< bitmask of cores checking in */
specifier|volatile
name|unsigned
name|int
name|exit
block|;
comment|/**< variable to poll for exit condition */
block|}
name|s
index|[
name|CVMX_COREMASK_MAX_SYNCS
index|]
block|;  }
name|state
operator|=
block|{
block|{
name|CVMX_SPINLOCK_UNLOCKED_VAL
block|}
block|,
block|{
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
block|, }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Wait (stall) until all cores in the given coremask has reached this point  * in the program execution before proceeding.  *  * @param  coremask  the group of cores performing the barrier sync  *  */
end_comment

begin_function
name|void
name|cvmx_coremask_barrier_sync
parameter_list|(
name|unsigned
name|int
name|coremask
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|target
decl_stmt|;
name|assert
argument_list|(
name|coremask
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|state
operator|.
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_COREMASK_MAX_SYNCS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|coremask
operator|==
literal|0
condition|)
block|{
comment|/* end of existing coremask list, create new entry, fall-thru */
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|coremask
operator|=
name|coremask
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|coremask
operator|==
name|coremask
condition|)
block|{
name|target
operator|=
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|exit
operator|+
literal|1
expr_stmt|;
comment|/* wrap-around at 32b */
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|checkin
operator||=
name|cvmx_coremask_core
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|checkin
operator|==
name|coremask
condition|)
block|{
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|checkin
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|exit
operator|=
name|target
expr_stmt|;
comment|/* signal exit condition */
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|state
operator|.
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|state
operator|.
name|s
index|[
name|i
index|]
operator|.
name|exit
operator|!=
name|target
condition|)
empty_stmt|;
return|return;
block|}
block|}
comment|/* error condition - coremask array overflowed */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|state
operator|.
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

