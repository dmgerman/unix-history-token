begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-uctlx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon uctlx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_UCTLX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_UCTLX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_BIST_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_BIST_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F0000A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_BIST_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F0000A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_CLK_RST_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_CLK_RST_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_CLK_RST_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_EHCI_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_EHCI_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_EHCI_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_EHCI_FLA
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_EHCI_FLA(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F0000A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_EHCI_FLA
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F0000A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_ERTO_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_ERTO_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_ERTO_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_IF_ENA
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_IF_ENA(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_IF_ENA
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_INT_ENA
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_INT_ENA(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_INT_ENA
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_INT_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_INT_REG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_INT_REG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_OHCI_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_OHCI_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_OHCI_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_ORTO_CTL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_ORTO_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000098ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_ORTO_CTL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000098ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_PPAF_WM
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_PPAF_WM(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_PPAF_WM
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_UPHY_CTL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_UPHY_CTL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_UPHY_CTL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_UCTLX_UPHY_PORTX_CTL_STATUS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_UCTLX_UPHY_PORTX_CTL_STATUS(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x000118006F000010ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x0ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_UCTLX_UPHY_PORTX_CTL_STATUS
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x000118006F000010ull) + (((offset)& 1) + ((block_id)& 0) * 0x0ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_uctl#_bist_status  *  * UCTL_BIST_STATUS = UCTL Bist Status  *  * Results from BIST runs of UCTL's memories.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_bist_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|data_bis
range|:
literal|1
decl_stmt|;
comment|/**< UAHC EHCI Data Ram Bist Status */
name|uint64_t
name|desc_bis
range|:
literal|1
decl_stmt|;
comment|/**< UAHC EHCI Descriptor Ram Bist Status */
name|uint64_t
name|erbm_bis
range|:
literal|1
decl_stmt|;
comment|/**< UCTL EHCI Read Buffer Memory Bist Status */
name|uint64_t
name|orbm_bis
range|:
literal|1
decl_stmt|;
comment|/**< UCTL OHCI Read Buffer Memory Bist Status */
name|uint64_t
name|wrbm_bis
range|:
literal|1
decl_stmt|;
comment|/**< UCTL Write Buffer Memory Bist Sta */
name|uint64_t
name|ppaf_bis
range|:
literal|1
decl_stmt|;
comment|/**< PP Access FIFO Memory Bist Status */
else|#
directive|else
name|uint64_t
name|ppaf_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wrbm_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orbm_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|erbm_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|desc_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|data_bis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_bist_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_bist_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_bist_status
name|cvmx_uctlx_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_clk_rst_ctl  *  * CLK_RST_CTL = Clock and Reset Control Reigster  * This register controls the frequceny of hclk and resets for hclk and phy clocks. It also controls Simulation modes and Bists.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_clk_rst_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_clk_rst_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
comment|/**< Clear BIST on the HCLK memories */
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
comment|/**< Starts BIST on the HCLK memories during 0-to-1                                                          transition. */
name|uint64_t
name|ehci_sm
range|:
literal|1
decl_stmt|;
comment|/**< Only set it during simulation time. When set to 1,                                                          this bit sets the PHY in a non-driving mode so the                                                          EHCI can detect device connection.                                                          Note: it must not be set to 1, during normal                                                          operation. */
name|uint64_t
name|ohci_clkcktrst
range|:
literal|1
decl_stmt|;
comment|/**< Clear clock reset. Active low.  OHCI initial reset                                                          signal for the DPLL block. This is only needed by                                                          simulation. The duration of the reset  in simulation                                                          must be the same as HRST.                                                          Note: it must be set to 1 during normal operation. */
name|uint64_t
name|ohci_sm
range|:
literal|1
decl_stmt|;
comment|/**< OHCI Simulation Mode. It selects the counter value                                                           for simulation or real time for 1 ms.                                                          - 0: counter full 1ms; 1: simulation time. */
name|uint64_t
name|ohci_susp_lgcy
range|:
literal|1
decl_stmt|;
comment|/**< OHCI Clock Control Signal. Note: This bit must be                                                          set to 0 if the OHCI 48/12Mhz clocks must be                                                          suspended when the EHCI and OHCI controllers are                                                          not active. */
name|uint64_t
name|app_start_clk
range|:
literal|1
decl_stmt|;
comment|/**< OHCI Clock Control Signal. When the OHCI clocks are                                                          suspended, the system has to assert this signal to                                                          start the clocks (12 and 48 Mhz). */
name|uint64_t
name|o_clkdiv_rst
range|:
literal|1
decl_stmt|;
comment|/**< OHCI 12Mhz  clock divider reset. Active low. When                                                          set to 0, divider is held in reset.                                                          The reset to the divider is also asserted when core                                                          reset is asserted. */
name|uint64_t
name|h_clkdiv_byp
range|:
literal|1
decl_stmt|;
comment|/**< Used to enable the bypass input to the USB_CLK_DIV */
name|uint64_t
name|h_clkdiv_rst
range|:
literal|1
decl_stmt|;
comment|/**< Host clock divider reset. Active low. When set to 0,                                                          divider is held in reset. This must be set to 0                                                          before change H_DIV0 and H_DIV1.                                                          The reset to the divider is also asserted when core                                                          reset is asserted. */
name|uint64_t
name|h_clkdiv_en
range|:
literal|1
decl_stmt|;
comment|/**< Hclk enable. When set to 1, the hclk is gernerated. */
name|uint64_t
name|o_clkdiv_en
range|:
literal|1
decl_stmt|;
comment|/**< OHCI 48Mhz/12MHz clock enable. When set to 1, the                                                          clocks are gernerated. */
name|uint64_t
name|h_div
range|:
literal|4
decl_stmt|;
comment|/**< The hclk frequency is sclk frequency divided by                                                          H_DIV. The maximum frequency of hclk is 200Mhz.                                                          The minimum frequency of hclk is no less than the                                                          UTMI clock frequency which is 60Mhz. After writing a                                                          value to this field, the software should read the                                                          field for the value written. The [H_ENABLE] field of                                                          this register should not be set until after this                                                          field is set and  then read.                                                          Only the following values are valid:                                                             1, 2, 3, 4, 6, 8, 12.                                                          All other values are reserved and will be coded as                                                          following:                                                             0        -> 1                                                             5        -> 4                                                             7        -> 6                                                             9,10,11  -> 8                                                             13,14,15 -> 12 */
name|uint64_t
name|p_refclk_sel
range|:
literal|2
decl_stmt|;
comment|/**< PHY PLL Reference Clock Select.                                                          - 00: uses 12Mhz crystal at USB_XO and USB_XI;                                                          - 01: uses 12/24/48Mhz 2.5V clock source at USB_XO.                                                              USB_XI should be tied to GND.                                                          1x: Reserved. */
name|uint64_t
name|p_refclk_div
range|:
literal|2
decl_stmt|;
comment|/**< PHY Reference Clock Frequency Select.                                                          - 00: 12MHz, 01: 24Mhz, 10: 48Mhz, 11: Reserved.                                                          Note: This value must be set during POR is active.                                                          If a crystal is used as a reference clock,this field                                                          must be set to 12 MHz. Values 01 and 10 are reserved                                                          when a crystal is used. */
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
comment|/**< PHY Common Block Power-Down Control.                                                          - 1: The XO, Bias, and PLL blocks are powered down in                                                              Suspend mode.                                                          - 0: The XO, Bias, and PLL blocks remain powered in                                                              suspend mode.                                                           Note: This bit must be set to 0 during POR is active                                                           in current design. */
name|uint64_t
name|p_por
range|:
literal|1
decl_stmt|;
comment|/**< Power on reset for PHY. Resets all the PHY's                                                          registers and state machines. */
name|uint64_t
name|p_prst
range|:
literal|1
decl_stmt|;
comment|/**< PHY Clock Reset. The is the value for phy_rst_n,                                                          utmi_rst_n[1] and utmi_rst_n[0]. It is synchronized                                                          to each clock domain to generate the corresponding                                                          reset signal. This should not be set to 1 until the                                                          time it takes for six clock cycles (HCLK and                                                          PHY CLK, which ever is slower) has passed. */
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
comment|/**< Host Clock Reset. This is the value for hreset_n.                                                          This should not be set to 1 until 12ms after PHY CLK                                                          is stable. */
else|#
directive|else
name|uint64_t
name|hrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_prst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_por
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_com_on
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|p_refclk_div
range|:
literal|2
decl_stmt|;
name|uint64_t
name|p_refclk_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|h_div
range|:
literal|4
decl_stmt|;
name|uint64_t
name|o_clkdiv_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|h_clkdiv_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|h_clkdiv_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|h_clkdiv_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|o_clkdiv_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|app_start_clk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ohci_susp_lgcy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ohci_sm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ohci_clkcktrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ehci_sm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_clk_rst_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_clk_rst_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_clk_rst_ctl
name|cvmx_uctlx_clk_rst_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_ehci_ctl  *  * UCTL_EHCI_CTL = UCTL EHCI Control Register  * This register controls the general behavior of UCTL EHCI datapath.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_ehci_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_ehci_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|desc_rbm
range|:
literal|1
decl_stmt|;
comment|/**< Descriptor Read Burst Mode on AHB bus                                                          - 1: A read burst can be interruprted after 16 AHB                                                              clock cycle                                                          - 0: A read burst will not be interrupted until it                                                              finishes or no more data available */
name|uint64_t
name|reg_nb
range|:
literal|1
decl_stmt|;
comment|/**< 1: EHCI register access will not be blocked by EHCI                                                           buffer/descriptor access on AHB                                                          - 0: Buffer/descriptor and register access will be                                                              mutually exclusive */
name|uint64_t
name|l2c_dc
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, set the commit bit in the descriptor                                                          store commands to L2C. */
name|uint64_t
name|l2c_bc
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, set the commit bit in the buffer                                                          store commands to L2C. */
name|uint64_t
name|l2c_0pag
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, sets the zero-page bit in store                                                          command to  L2C. */
name|uint64_t
name|l2c_stt
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, use STT when store to L2C. */
name|uint64_t
name|l2c_buff_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for buffer from/to the L2C.                                                          IN:       A-B-C-D-E-F-G-H                                                          OUT0:  A-B-C-D-E-F-G-H                                                          OUT1:  H-G-F-E-D-C-B-A                                                          OUT2:  D-C-B-A-H-G-F-E                                                          OUT3:  E-F-G-H-A-B-C-D */
name|uint64_t
name|l2c_desc_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for descriptor from/to the L2C.                                                          IN:        A-B-C-D-E-F-G-H                                                          OUT0:  A-B-C-D-E-F-G-H                                                          OUT1:  H-G-F-E-D-C-B-A                                                          OUT2:  D-C-B-A-H-G-F-E                                                          OUT3:  E-F-G-H-A-B-C-D */
name|uint64_t
name|inv_reg_a2
range|:
literal|1
decl_stmt|;
comment|/**< UAHC register address  bit<2> invert. When set to 1,                                                          for a 32-bit NCB I/O register access, the address                                                          offset will be flipped between 0x4 and 0x0. */
name|uint64_t
name|ehci_64b_addr_en
range|:
literal|1
decl_stmt|;
comment|/**< EHCI AHB Master 64-bit Addressing Enable.                                                          - 1: enable ehci 64-bit addressing mode;                                                          - 0: disable ehci 64-bit addressing mode.                                                           When ehci 64-bit addressing mode is disabled,                                                           UCTL_EHCI_CTL[L2C_ADDR_MSB] is used as the address                                                           bit[39:32]. */
name|uint64_t
name|l2c_addr_msb
range|:
literal|8
decl_stmt|;
comment|/**< This is the bit [39:32] of an address sent to L2C                                                          for ehci whenUCTL_EHCI_CFG[EHCI_64B_ADDR_EN=0]). */
else|#
directive|else
name|uint64_t
name|l2c_addr_msb
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ehci_64b_addr_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_reg_a2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_desc_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l2c_buff_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l2c_stt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_0pag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_bc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_dc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reg_nb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|desc_rbm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_ehci_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_ehci_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_ehci_ctl
name|cvmx_uctlx_ehci_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_ehci_fla  *  * UCTL_EHCI_FLA = UCTL EHCI Frame Length Adjument Register  * This register configures the EHCI Frame Length Adjustment.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_ehci_fla
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_ehci_fla_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|fla
range|:
literal|6
decl_stmt|;
comment|/**< EHCI Frame Length Adjustment. This feature                                                          adjusts any offset from the clock source that drives                                                          the uSOF counter.  The default value is 32(0x20),                                                          which gives an SOF cycle time of 60,0000 (each                                                          microframe has 60,000 bit times).                                                          Note: keep this value to 0x20 (decimal 32) for no                                                          offset. */
else|#
directive|else
name|uint64_t
name|fla
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_ehci_fla_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_ehci_fla_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_ehci_fla
name|cvmx_uctlx_ehci_fla_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_erto_ctl  *  * UCTL_ERTO_CTL = UCTL EHCI Readbuffer TimeOut Control Register  * This register controls timeout for EHCI Readbuffer.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_erto_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_erto_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|to_val
range|:
literal|27
decl_stmt|;
comment|/**< Read buffer timeout value                                                          (value 0 means timeout disabled) */
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_4
range|:
literal|5
decl_stmt|;
name|uint64_t
name|to_val
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_erto_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_erto_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_erto_ctl
name|cvmx_uctlx_erto_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_if_ena  *  * UCTL_IF_ENA = UCTL Interface Enable Register  *  * Register to enable the uctl interface clock.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_if_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_if_ena_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Turns on the USB UCTL interface clock */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_if_ena_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_if_ena_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_if_ena
name|cvmx_uctlx_if_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_int_ena  *  * UCTL_INT_ENA = UCTL Interrupt Enable Register  *  * Register to enable individual interrupt source in corresponding to UCTL_INT_REG  */
end_comment

begin_union
union|union
name|cvmx_uctlx_int_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_int_ena_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ec_ovf_e
range|:
literal|1
decl_stmt|;
comment|/**< Ehci Commit OVerFlow Error */
name|uint64_t
name|oc_ovf_e
range|:
literal|1
decl_stmt|;
comment|/**< Ohci Commit OVerFlow Error */
name|uint64_t
name|wb_pop_e
range|:
literal|1
decl_stmt|;
comment|/**< Write Buffer FIFO Poped When Empty */
name|uint64_t
name|wb_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< Write Buffer FIFO Pushed When Full */
name|uint64_t
name|cf_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< Command FIFO Pushed When Full */
name|uint64_t
name|or_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< OHCI Read Buffer FIFO Pushed When Full */
name|uint64_t
name|er_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< EHCI Read Buffer FIFO Pushed When Full */
name|uint64_t
name|pp_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< PP Access FIFO  Pushed When Full */
else|#
directive|else
name|uint64_t
name|pp_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|er_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|or_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cf_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wb_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wb_pop_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oc_ovf_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ec_ovf_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_int_ena_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_int_ena_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_int_ena
name|cvmx_uctlx_int_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_int_reg  *  * UCTL_INT_REG = UCTL Interrupt Register  *  * Summary of different bits of RSL interrupt status.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_int_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ec_ovf_e
range|:
literal|1
decl_stmt|;
comment|/**< Ehci Commit OVerFlow Error                                                          When the error happenes, the whole NCB system needs                                                          to be reset. */
name|uint64_t
name|oc_ovf_e
range|:
literal|1
decl_stmt|;
comment|/**< Ohci Commit OVerFlow Error                                                          When the error happenes, the whole NCB system needs                                                          to be reset. */
name|uint64_t
name|wb_pop_e
range|:
literal|1
decl_stmt|;
comment|/**< Write Buffer FIFO Poped When Empty */
name|uint64_t
name|wb_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< Write Buffer FIFO Pushed When Full */
name|uint64_t
name|cf_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< Command FIFO Pushed When Full */
name|uint64_t
name|or_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< OHCI Read Buffer FIFO Pushed When Full */
name|uint64_t
name|er_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< EHCI Read Buffer FIFO Pushed When Full */
name|uint64_t
name|pp_psh_f
range|:
literal|1
decl_stmt|;
comment|/**< PP Access FIFO  Pushed When Full */
else|#
directive|else
name|uint64_t
name|pp_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|er_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|or_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cf_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wb_psh_f
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wb_pop_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oc_ovf_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ec_ovf_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_int_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_int_reg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_int_reg
name|cvmx_uctlx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_ohci_ctl  *  * RSL registers starting from 0x10 can be accessed only after hclk is active and hreset is deasserted.  *  * UCTL_OHCI_CTL = UCTL OHCI Control Register  * This register controls the general behavior of UCTL OHCI datapath.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_ohci_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_ohci_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|reg_nb
range|:
literal|1
decl_stmt|;
comment|/**< 1: OHCI register access will not be blocked by EHCI                                                           buffer/descriptor access on AHB                                                          - 0: Buffer/descriptor and register access will be                                                              mutually exclusive */
name|uint64_t
name|l2c_dc
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, set the commit bit in the descriptor                                                          store commands to L2C. */
name|uint64_t
name|l2c_bc
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, set the commit bit in the buffer                                                          store commands to L2C. */
name|uint64_t
name|l2c_0pag
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, sets the zero-page bit in store                                                          command to  L2C. */
name|uint64_t
name|l2c_stt
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1, use STT when store to L2C. */
name|uint64_t
name|l2c_buff_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for buffer from/to the L2C.                                                          IN:       A-B-C-D-E-F-G-H                                                          OUT0:  A-B-C-D-E-F-G-H                                                          OUT1:  H-G-F-E-D-C-B-A                                                          OUT2:  D-C-B-A-H-G-F-E                                                          OUT3:  E-F-G-H-A-B-C-D */
name|uint64_t
name|l2c_desc_emod
range|:
literal|2
decl_stmt|;
comment|/**< Endian format for descriptor from/to the L2C.                                                          IN:        A-B-C-D-E-F-G-H                                                          OUT0:  A-B-C-D-E-F-G-H                                                          OUT1:  H-G-F-E-D-C-B-A                                                          OUT2:  D-C-B-A-H-G-F-E                                                          OUT3:  E-F-G-H-A-B-C-D */
name|uint64_t
name|inv_reg_a2
range|:
literal|1
decl_stmt|;
comment|/**< UAHC register address  bit<2> invert. When set to 1,                                                          for a 32-bit NCB I/O register access, the address                                                          offset will be flipped between 0x4 and 0x0. */
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_addr_msb
range|:
literal|8
decl_stmt|;
comment|/**< This is the bit [39:32] of an address sent to L2C                                                          for ohci. */
else|#
directive|else
name|uint64_t
name|l2c_addr_msb
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_reg_a2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_desc_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l2c_buff_emod
range|:
literal|2
decl_stmt|;
name|uint64_t
name|l2c_stt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_0pag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_bc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_dc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reg_nb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_ohci_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_ohci_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_ohci_ctl
name|cvmx_uctlx_ohci_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_orto_ctl  *  * UCTL_ORTO_CTL = UCTL OHCI Readbuffer TimeOut Control Register  * This register controls timeout for OHCI Readbuffer.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_orto_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_orto_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|to_val
range|:
literal|24
decl_stmt|;
comment|/**< Read buffer timeout value                                                          (value 0 means timeout disabled) */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|to_val
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_orto_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_orto_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_orto_ctl
name|cvmx_uctlx_orto_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_ppaf_wm  *  * UCTL_PPAF_WM = UCTL PP Access FIFO WaterMark Register  *  * Register to set PP access FIFO full watermark.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_ppaf_wm
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_ppaf_wm_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|wm
range|:
literal|5
decl_stmt|;
comment|/**< Number of entries when PP Access FIFO will assert                                                          full (back pressure) */
else|#
directive|else
name|uint64_t
name|wm
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_ppaf_wm_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_ppaf_wm_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_ppaf_wm
name|cvmx_uctlx_ppaf_wm_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_uphy_ctl_status  *  * UPHY_CTL_STATUS = USB PHY Control and Status Reigster  * This register controls the USB PHY test and Bist.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_uphy_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_uphy_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
comment|/**< PHY BIST DONE.  Asserted at the end of the PHY BIST                                                          sequence. */
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
comment|/**< PHY BIST Error.  Valid when BIST_ENB is high.                                                          Indicates an internal error was detected during the                                                          BIST sequence. */
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
comment|/**< High-Speed BIST Enable */
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
comment|/**< Full-Speed BIST Enable */
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
comment|/**< Low-Speed BIST Enable */
name|uint64_t
name|siddq
range|:
literal|1
decl_stmt|;
comment|/**< Drives the PHY SIDDQ input. Normally should be set                                                          to zero. Customers not using USB PHY interface                                                          should do the following:                                                            Provide 3.3V to USB_VDD33 Tie USB_REXT to 3.3V                                                            supply and Set SIDDQ to 1. */
name|uint64_t
name|vtest_en
range|:
literal|1
decl_stmt|;
comment|/**< Analog Test Pin Enable.                                                          1 = The PHY's ANALOG _TEST pin is enabled for the                                                              input and output of applicable analog test                                                              signals.                                                          0 = The ANALOG_TEST pin is disabled. */
name|uint64_t
name|uphy_bist
range|:
literal|1
decl_stmt|;
comment|/**< When set to 1,  it makes sure that during PHY BIST,                                                          utmi_txvld == 0. */
name|uint64_t
name|bist_en
range|:
literal|1
decl_stmt|;
comment|/**< PHY BIST ENABLE */
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset Input from ATE. This is a test signal. When                                                          the USB core is powered up (not in suspend mode), an                                                          automatic tester can use this to disable PHYCLOCK                                                          and FREECLK, then re-enable them with an aligned                                                          phase.                                                          - 1:  PHYCLOCKs and FREECLK outputs are disable.                                                          - 0: PHYCLOCKs and FREECLK are available within a                                                              specific period after ATERESET is de-asserted. */
else|#
directive|else
name|uint64_t
name|ate_reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|uphy_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vtest_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|siddq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|hsbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bist_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_uphy_ctl_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_uphy_ctl_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_uphy_ctl_status
name|cvmx_uctlx_uphy_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_uctl#_uphy_port#_ctl_status  *  * UPHY_PORTX_CTL_STATUS = USB PHY Port X Control and Status Reigsters  * This register controls the each port of the USB PHY.  */
end_comment

begin_union
union|union
name|cvmx_uctlx_uphy_portx_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_uctlx_uphy_portx_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
comment|/**< PHY test data out. Presents either interlly                                                          generated signals or test register contenets, based                                                          upon the value of TDATA_SEL */
name|uint64_t
name|txbiststuffenh
range|:
literal|1
decl_stmt|;
comment|/**< High-Byte Transmit Bit-Stuffing Enable. It must be                                                          set to 1'b1 in normal operation. */
name|uint64_t
name|txbiststuffen
range|:
literal|1
decl_stmt|;
comment|/**< Low-Byte Transmit Bit-Stuffing Enable. It must be                                                          set to 1'b1 in normal operation. */
name|uint64_t
name|dmpulldown
range|:
literal|1
decl_stmt|;
comment|/**< D- Pull-Down Resistor Enable. It must be set to 1'b1                                                          in normal operation. */
name|uint64_t
name|dppulldown
range|:
literal|1
decl_stmt|;
comment|/**< D+ Pull-Down Resistor Enable. It must be set to 1'b1                                                          in normal operation. */
name|uint64_t
name|vbusvldext
range|:
literal|1
decl_stmt|;
comment|/**< In host mode, this input is not used and can be tied                                                          to 1'b0. */
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
comment|/**< Per-port reset */
name|uint64_t
name|txhsvxtune
range|:
literal|2
decl_stmt|;
comment|/**< Transmitter High-Speed Crossover Adjustment */
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
comment|/**< HS DC Voltage Level Adjustment */
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
comment|/**< HS Transmitter Rise/Fall Time Adjustment */
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
comment|/**< HS transmitter pre-emphasis enable. */
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
comment|/**< FS/LS Source Impedance Adjustment */
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
comment|/**< Squelch Threshold Adjustment */
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
comment|/**< Disconnect Threshold Adjustment */
name|uint64_t
name|loop_en
range|:
literal|1
decl_stmt|;
comment|/**< Port Loop back Test Enable                                                          - 1: During data transmission, the receive logic is                                                              enabled                                                          - 0: During data transmission, the receive logic is                                                              disabled */
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
comment|/**< PHY port test clock, used to load TDATA_IN to the                                                          UPHY. */
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
comment|/**< Test Data out select                                                          - 1: Mode-defined test register contents are output                                                          - 0: internally generated signals are output */
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
comment|/**< Mode address for test interface. Specifies the                                                          register address for writing to or reading from the                                                          PHY test interface register. */
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
comment|/**< Internal testing Register input data and select.                                                          This is a test bus. Data presents on [3:0] and the                                                          corresponding select (enable) presents on bits[7:4]. */
else|#
directive|else
name|uint64_t
name|tdata_in
range|:
literal|8
decl_stmt|;
name|uint64_t
name|taddr_in
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdata_sel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|compdistune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|sqrxtune
range|:
literal|3
decl_stmt|;
name|uint64_t
name|txfslstune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpreemphasistune
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txrisetune
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txvreftune
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txhsvxtune
range|:
literal|2
decl_stmt|;
name|uint64_t
name|portreset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbusvldext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dppulldown
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmpulldown
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txbiststuffen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txbiststuffenh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tdata_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_43_63
range|:
literal|21
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_uctlx_uphy_portx_ctl_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_uctlx_uphy_portx_ctl_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_uctlx_uphy_portx_ctl_status
name|cvmx_uctlx_uphy_portx_ctl_status_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

