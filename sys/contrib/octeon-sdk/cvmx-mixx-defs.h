begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-mixx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon mixx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_MIXX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_MIXX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_BIST
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_BIST(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100078ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_BIST
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100078ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100020ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_INTENA
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_INTENA(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_INTENA
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100050ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_IRCNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_IRCNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_IRCNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100030ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_IRHWM
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_IRHWM(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_IRHWM
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100028ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_IRING1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_IRING1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_IRING1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100010ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_IRING2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_IRING2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_IRING2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100018ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_ISR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_ISR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_ISR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100048ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_ORCNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_ORCNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_ORCNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100040ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_ORHWM
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_ORHWM(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_ORHWM
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100038ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_ORING1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_ORING1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_ORING1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100000ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_ORING2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_ORING2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_ORING2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100008ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_REMCNT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_REMCNT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100058ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_REMCNT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100058ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_TSCTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_TSCTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100068ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_TSCTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100068ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIXX_TSTAMP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIXX_TSTAMP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000100060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIXX_TSTAMP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001070000100060ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_mix#_bist  *  * MIX_BIST = MIX BIST Register  *  * Description:  *  NOTE: To read the MIX_BIST register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_bist
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_bist_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|opfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for AGO OPF Buffer RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mrgdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for AGI MRG Buffer RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|mrqdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for NBR CSR RdReq RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ipfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MIX Inbound Packet RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|irfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MIX I-Ring Entry RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|orfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MIX O-Ring Entry RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|orfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrqdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrgdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|opfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mixx_bist_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|mrqdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for NBR CSR RdReq RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ipfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MIX Inbound Packet RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|irfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MIX I-Ring Entry RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|orfdat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for MIX O-Ring Entry RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|orfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipfdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mrqdat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mixx_bist_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_bist_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_bist_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_bist_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_bist_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_bist
name|cvmx_mixx_bist_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_ctl  *  * MIX_CTL = MIX Control Register  *  * Description:  *  NOTE: To write to the MIX_CTL register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_CTL register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|ts_thresh
range|:
literal|4
decl_stmt|;
comment|/**< TimeStamp Interrupt Threshold                                                          When the \#of pending Timestamp interrupts (MIX_TSCTL[TSCNT]                                                          is greater than MIX_CTL[TS_THRESH], then a programmable                                                          TimeStamp Interrupt is issued (see MIX_INTR[TS]                                                          MIX_INTENA[TSENA]).                                                          SWNOTE: For o63, since the implementation only supports                                                          4 oustanding timestamp interrupts, this field should                                                          only be programmed from [0..3]. */
name|uint64_t
name|crc_strip
range|:
literal|1
decl_stmt|;
comment|/**< HW CRC Strip Enable                                                          When enabled, the last 4 bytes(CRC) of the ingress packet                                                          are not included in cumulative packet byte length.                                                          In other words, the cumulative LEN field for all                                                          I-Ring Buffer Entries associated with a given ingress                                                          packet will be 4 bytes less (so that the final 4B HW CRC                                                          packet data is not processed by software). */
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< MIX Busy Status bit                                                          MIX will assert busy status any time there are:                                                            1) L2/DRAM reads in-flight (NCB-arb to read                                                               response)                                                            2) L2/DRAM writes in-flight (NCB-arb to write                                                               data is sent.                                                            3) L2/DRAM write commits in-flight (NCB-arb to write                                                               commit response).                                                          NOTE: After MIX_CTL[EN]=0, the MIX will eventually                                                          complete any "inflight" transactions, at which point the                                                          BUSY will de-assert. */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< MIX Enable bit                                                          When EN=0, MIX will no longer arbitrate for                                                          any new L2/DRAM read/write requests on the NCB Bus.                                                          MIX will complete any requests that are currently                                                          pended for the NCB Bus. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< MIX Soft Reset                                                           When SW writes a '1' to MIX_CTL[RESET], the                                                           MII-MIX/AGL logic will execute a soft reset.                                                           NOTE: During a soft reset, CSR accesses are not effected.                                                           However, the values of the CSR fields will be effected by                                                           soft reset (except MIX_CTL[RESET] itself).                                                           NOTE: After power-on, the MII-AGL/MIX are held in reset                                                           until the MIX_CTL[RESET] is written to zero.                                                           The intended "soft reset" sequence is: (please also                                                           refer to HRM Section 12.6.2 on MIX/AGL Block Reset).                                                              1) Write MIX_CTL[EN]=0                                                                 [To prevent any NEW transactions from being started]                                                              2) Wait for MIX_CTL[BUSY]=0                                                                 [To indicate that all inflight transactions have                                                                  completed]                                                              3) Write MIX_CTL[RESET]=1, followed by a MIX_CTL CSR read                                                                 and wait for the result.                                                              4) Re-Initialize the MIX/AGL just as would be done                                                                 for a hard reset.                                                          NOTE: Once the MII has been soft-reset, please refer to HRM Section                                                          12.6.1 MIX/AGL BringUp Sequence to complete the MIX/AGL                                                          re-initialization sequence. */
name|uint64_t
name|lendian
range|:
literal|1
decl_stmt|;
comment|/**< Packet Little Endian Mode                                                          (0: Big Endian Mode/1: Little Endian Mode)                                                          When the mode is set, MIX will byte-swap packet data                                                          loads/stores at the MIX/NCB boundary. */
name|uint64_t
name|nbtarb
range|:
literal|1
decl_stmt|;
comment|/**< MIX CB-Request Arbitration Mode.                                                          When set to zero, the arbiter is fixed priority with                                                          the following priority scheme:                                                              Highest Priority: I-Ring Packet Write Request                                                                                O-Ring Packet Read Request                                                                                I-Ring Entry Write Request                                                                                I-Ring Entry Read Request                                                                                O-Ring Entry Read Request                                                          When set to one, the arbiter is round robin. */
name|uint64_t
name|mrq_hwm
range|:
literal|2
decl_stmt|;
comment|/**< MIX CB-Request FIFO Programmable High Water Mark.                                                          The MRQ contains 16 CB-Requests which are CSR Rd/Wr                                                          Requests. If the MRQ backs up with "HWM" entries,                                                          then new CB-Requests are 'stalled'.                                                             [0]: HWM = 11                                                             [1]: HWM = 10                                                             [2]: HWM = 9                                                             [3]: HWM = 8                                                          NOTE: This must only be written at power-on/boot time. */
else|#
directive|else
name|uint64_t
name|mrq_hwm
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nbtarb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lendian
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc_strip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ts_thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mixx_ctl_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|crc_strip
range|:
literal|1
decl_stmt|;
comment|/**< HW CRC Strip Enable                                                          When enabled, the last 4 bytes(CRC) of the ingress packet                                                          are not included in cumulative packet byte length.                                                          In other words, the cumulative LEN field for all                                                          I-Ring Buffer Entries associated with a given ingress                                                          packet will be 4 bytes less (so that the final 4B HW CRC                                                          packet data is not processed by software). */
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< MIX Busy Status bit                                                          MIX will assert busy status any time there are:                                                            1) L2/DRAM reads in-flight (NCB-arb to read                                                               response)                                                            2) L2/DRAM writes in-flight (NCB-arb to write                                                               data is sent.                                                            3) L2/DRAM write commits in-flight (NCB-arb to write                                                               commit response).                                                          NOTE: After MIX_CTL[EN]=0, the MIX will eventually                                                          complete any "inflight" transactions, at which point the                                                          BUSY will de-assert. */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< MIX Enable bit                                                          When EN=0, MIX will no longer arbitrate for                                                          any new L2/DRAM read/write requests on the NCB Bus.                                                          MIX will complete any requests that are currently                                                          pended for the NCB Bus. */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< MIX Soft Reset                                                           When SW writes a '1' to MIX_CTL[RESET], the                                                           MII-MIX/AGL logic will execute a soft reset.                                                           NOTE: During a soft reset, CSR accesses are not effected.                                                           However, the values of the CSR fields will be effected by                                                           soft reset (except MIX_CTL[RESET] itself).                                                           NOTE: After power-on, the MII-AGL/MIX are held in reset                                                           until the MIX_CTL[RESET] is written to zero.                                                           The intended "soft reset" sequence is: (please also                                                           refer to HRM Section 12.6.2 on MIX/AGL Block Reset).                                                              1) Write MIX_CTL[EN]=0                                                                 [To prevent any NEW transactions from being started]                                                              2) Wait for MIX_CTL[BUSY]=0                                                                 [To indicate that all inflight transactions have                                                                  completed]                                                              3) Write MIX_CTL[RESET]=1, followed by a MIX_CTL CSR read                                                                 and wait for the result.                                                              4) Re-Initialize the MIX/AGL just as would be done                                                                 for a hard reset.                                                          NOTE: Once the MII has been soft-reset, please refer to HRM Section                                                          12.6.1 MIX/AGL BringUp Sequence to complete the MIX/AGL                                                          re-initialization sequence. */
name|uint64_t
name|lendian
range|:
literal|1
decl_stmt|;
comment|/**< Packet Little Endian Mode                                                          (0: Big Endian Mode/1: Little Endian Mode)                                                          When the mode is set, MIX will byte-swap packet data                                                          loads/stores at the MIX/NCB boundary. */
name|uint64_t
name|nbtarb
range|:
literal|1
decl_stmt|;
comment|/**< MIX CB-Request Arbitration Mode.                                                          When set to zero, the arbiter is fixed priority with                                                          the following priority scheme:                                                              Highest Priority: I-Ring Packet Write Request                                                                                O-Ring Packet Read Request                                                                                I-Ring Entry Write Request                                                                                I-Ring Entry Read Request                                                                                O-Ring Entry Read Request                                                          When set to one, the arbiter is round robin. */
name|uint64_t
name|mrq_hwm
range|:
literal|2
decl_stmt|;
comment|/**< MIX CB-Request FIFO Programmable High Water Mark.                                                          The MRQ contains 16 CB-Requests which are CSR Rd/Wr                                                          Requests. If the MRQ backs up with "HWM" entries,                                                          then new CB-Requests are 'stalled'.                                                             [0]: HWM = 11                                                             [1]: HWM = 10                                                             [2]: HWM = 9                                                             [3]: HWM = 8                                                          NOTE: This must only be written at power-on/boot time. */
else|#
directive|else
name|uint64_t
name|mrq_hwm
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nbtarb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lendian
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc_strip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mixx_ctl_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_ctl_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_ctl_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_ctl
name|cvmx_mixx_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_intena  *  * MIX_INTENA = MIX Local Interrupt Enable Mask Register  *  * Description:  *  NOTE: To write to the MIX_INTENA register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_INTENA register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_intena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_intena_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|tsena
range|:
literal|1
decl_stmt|;
comment|/**< TimeStamp Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Outbound Ring with Timestamp                                                          event (see: MIX_ISR[TS]). */
name|uint64_t
name|orunena
range|:
literal|1
decl_stmt|;
comment|/**< ORCNT UnderFlow Detected Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an ORCNT underflow condition                                                          MIX_ISR[ORUN]. */
name|uint64_t
name|irunena
range|:
literal|1
decl_stmt|;
comment|/**< IRCNT UnderFlow Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an IRCNT underflow condition                                                          MIX_ISR[IRUN]. */
name|uint64_t
name|data_drpena
range|:
literal|1
decl_stmt|;
comment|/**< Data was dropped due to RX FIFO full Interrupt                                                          enable. If both the global interrupt mask bits                                                          (CIU_INTx_EN*[MII]) and the local interrupt mask                                                          bit(DATA_DRPENA) is set, than an interrupt is                                                          reported for this event. */
name|uint64_t
name|ithena
range|:
literal|1
decl_stmt|;
comment|/**< Inbound Ring Threshold Exceeded Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Inbound Ring Threshold                                                          Exceeded event(IRTHRESH). */
name|uint64_t
name|othena
range|:
literal|1
decl_stmt|;
comment|/**< Outbound Ring Threshold Exceeded Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Outbound Ring Threshold                                                          Exceeded event(ORTHRESH). */
name|uint64_t
name|ivfena
range|:
literal|1
decl_stmt|;
comment|/**< Inbound DoorBell(IDBELL) Overflow Detected                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Inbound Doorbell Overflow                                                          event(IDBOVF). */
name|uint64_t
name|ovfena
range|:
literal|1
decl_stmt|;
comment|/**< Outbound DoorBell(ODBELL) Overflow Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Outbound Doorbell Overflow                                                          event(ODBOVF). */
else|#
directive|else
name|uint64_t
name|ovfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ivfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|othena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ithena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|data_drpena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irunena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orunena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tsena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mixx_intena_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|orunena
range|:
literal|1
decl_stmt|;
comment|/**< ORCNT UnderFlow Detected                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an ORCNT underflow condition                                                          MIX_ISR[ORUN]. */
name|uint64_t
name|irunena
range|:
literal|1
decl_stmt|;
comment|/**< IRCNT UnderFlow Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an IRCNT underflow condition                                                          MIX_ISR[IRUN]. */
name|uint64_t
name|data_drpena
range|:
literal|1
decl_stmt|;
comment|/**< Data was dropped due to RX FIFO full Interrupt                                                          enable. If both the global interrupt mask bits                                                          (CIU_INTx_EN*[MII]) and the local interrupt mask                                                          bit(DATA_DRPENA) is set, than an interrupt is                                                          reported for this event. */
name|uint64_t
name|ithena
range|:
literal|1
decl_stmt|;
comment|/**< Inbound Ring Threshold Exceeded Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Inbound Ring Threshold                                                          Exceeded event(IRTHRESH). */
name|uint64_t
name|othena
range|:
literal|1
decl_stmt|;
comment|/**< Outbound Ring Threshold Exceeded Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Outbound Ring Threshold                                                          Exceeded event(ORTHRESH). */
name|uint64_t
name|ivfena
range|:
literal|1
decl_stmt|;
comment|/**< Inbound DoorBell(IDBELL) Overflow Detected                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Inbound Doorbell Overflow                                                          event(IDBOVF). */
name|uint64_t
name|ovfena
range|:
literal|1
decl_stmt|;
comment|/**< Outbound DoorBell(ODBELL) Overflow Interrupt Enable                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Outbound Doorbell Overflow                                                          event(ODBOVF). */
else|#
directive|else
name|uint64_t
name|ovfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ivfena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|othena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ithena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|data_drpena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irunena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orunena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mixx_intena_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_intena_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_intena_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_intena_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_intena_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_intena
name|cvmx_mixx_intena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_ircnt  *  * MIX_IRCNT = MIX I-Ring Pending Packet Counter  *  * Description:  *  NOTE: To write to the MIX_IRCNT register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_IRCNT register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_ircnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_ircnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|ircnt
range|:
literal|20
decl_stmt|;
comment|/**< Pending \# of I-Ring Packets.                                                          Whenever HW writes a completion code of Done, Trunc,                                                          CRCErr or Err, it increments the IRCNT (to indicate                                                          to SW the \# of pending Input packets in system memory).                                                          NOTE: The HW guarantees that the completion code write                                                          is always visible in system memory BEFORE it increments                                                          the IRCNT.                                                          Reads of IRCNT return the current inbound packet count.                                                          Writes of IRCNT decrement the count by the value                                                          written.                                                          This register is used to generate interrupts to alert                                                          SW of pending inbound MIX packets in system memory.                                                          NOTE: In the case of inbound packets that span multiple                                                          I-Ring entries, SW must keep track of the \# of I-Ring Entries                                                          associated with a given inbound packet to reclaim the                                                          proper \# of I-Ring Entries for re-use. */
else|#
directive|else
name|uint64_t
name|ircnt
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_ircnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_ircnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_ircnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_ircnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_ircnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_ircnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_ircnt
name|cvmx_mixx_ircnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_irhwm  *  * MIX_IRHWM = MIX I-Ring High-Water Mark Threshold Register  *  * Description:  *  NOTE: To write to the MIX_IHWM register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_IHWM register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_irhwm
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_irhwm_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ibplwm
range|:
literal|20
decl_stmt|;
comment|/**< I-Ring BackPressure Low Water Mark Threshold.                                                          When the \#of available I-Ring Entries (IDBELL)                                                          is less than IBPLWM, the AGL-MAC will:                                                            a) In full-duplex mode: send periodic PAUSE packets.                                                            b) In half-duplex mode: Force collisions.                                                          This programmable mechanism is provided as a means                                                          to backpressure input traffic 'early' enough (so                                                          that packets are not 'dropped' by OCTEON). */
name|uint64_t
name|irhwm
range|:
literal|20
decl_stmt|;
comment|/**< I-Ring Entry High Water Mark Threshold.                                                          Used to determine when the \# of Inbound packets                                                          in system memory(MIX_IRCNT[IRCNT]) exceeds this IRHWM                                                          threshold.                                                          NOTE: The power-on value of the CIU_INTx_EN*[MII]                                                          interrupt enable bits is zero and must be enabled                                                          to allow interrupts to be reported. */
else|#
directive|else
name|uint64_t
name|irhwm
range|:
literal|20
decl_stmt|;
name|uint64_t
name|ibplwm
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_irhwm_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_irhwm_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_irhwm_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_irhwm_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_irhwm_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_irhwm_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_irhwm
name|cvmx_mixx_irhwm_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_iring1  *  * MIX_IRING1 = MIX Inbound Ring Register \#1  *  * Description:  *  NOTE: To write to the MIX_IRING1 register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_IRING1 register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_iring1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_iring1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|20
decl_stmt|;
comment|/**< Represents the Inbound Ring Buffer's Size(in 8B                                                          words). The ring can be as large as 1M entries.                                                          NOTE: This CSR MUST BE setup written by SW poweron                                                          (when IDBELL/IRCNT=0). */
name|uint64_t
name|ibase
range|:
literal|37
decl_stmt|;
comment|/**< Represents the 8B-aligned base address of the first                                                          Inbound Ring entry in system memory.                                                          NOTE: SW MUST ONLY write to this register during                                                          power-on/boot code. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ibase
range|:
literal|37
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mixx_iring1_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|20
decl_stmt|;
comment|/**< Represents the Inbound Ring Buffer's Size(in 8B                                                          words). The ring can be as large as 1M entries.                                                          NOTE: This CSR MUST BE setup written by SW poweron                                                          (when IDBELL/IRCNT=0). */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ibase
range|:
literal|33
decl_stmt|;
comment|/**< Represents the 8B-aligned base address of the first                                                          Inbound Ring entry in system memory.                                                          NOTE: SW MUST ONLY write to this register during                                                          power-on/boot code. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ibase
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|isize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mixx_iring1_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_iring1_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_iring1_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_iring1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_iring1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_iring1
name|cvmx_mixx_iring1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_iring2  *  * MIX_IRING2 = MIX Inbound Ring Register \#2  *  * Description:  *  NOTE: To write to the MIX_IRING2 register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_IRING2 register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_iring2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_iring2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
name|uint64_t
name|itlptr
range|:
literal|20
decl_stmt|;
comment|/**< The Inbound Ring Tail Pointer selects the I-Ring                                                          Entry that the HW will process next. After the HW                                                          completes receiving an inbound packet, it increments                                                          the I-Ring Tail Pointer. [NOTE: The I-Ring Tail                                                          Pointer HW increment is always modulo ISIZE.                                                          NOTE: This field is 'read-only' to SW. */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|idbell
range|:
literal|20
decl_stmt|;
comment|/**< Represents the cumulative total of pending                                                          Inbound Ring Buffer Entries. Each I-Ring                                                          Buffer Entry contains 1) an L2/DRAM byte pointer                                                          along with a 2) a Byte Length.                                                          After SW inserts a new entry into the I-Ring Buffer,                                                          it "rings the doorbell for the inbound ring". When                                                          the MIX HW receives the doorbell ring, it advances                                                          the doorbell count for the I-Ring.                                                          SW must never cause the doorbell count for the                                                          I-Ring to exceed the size of the I-ring(ISIZE).                                                          A read of the CSR indicates the current doorbell                                                          count. */
else|#
directive|else
name|uint64_t
name|idbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|itlptr
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_iring2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_iring2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_iring2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_iring2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_iring2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_iring2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_iring2
name|cvmx_mixx_iring2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_isr  *  * MIX_ISR = MIX Interrupt/Status Register  *  * Description:  *  NOTE: To write to the MIX_ISR register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_ISR register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_isr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_isr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ts
range|:
literal|1
decl_stmt|;
comment|/**< TimeStamp Interrupt                                                          When the \#of pending Timestamp Interrupts (MIX_TSCTL[TSCNT])                                                          is greater than the TimeStamp Interrupt Threshold                                                          (MIX_CTL[TS_THRESH]) value this interrupt bit is set.                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and this local interrupt mask bit is set, than an                                                          interrupt is reported for an Outbound Ring with Timestamp                                                          event (see: MIX_INTENA[TSENA]). */
name|uint64_t
name|orun
range|:
literal|1
decl_stmt|;
comment|/**< ORCNT UnderFlow Detected                                                          If SW writes a larger value than what is currently                                                          in the MIX_ORCNT[ORCNT], then HW will report the                                                          underflow condition.                                                          NOTE: The MIX_ORCNT[IOCNT] will clamp to to zero.                                                          NOTE: If an ORUN underflow condition is detected,                                                          the integrity of the MIX/AGL HW state has                                                          been compromised. To recover, SW must issue a                                                          software reset sequence (see: MIX_CTL[RESET] */
name|uint64_t
name|irun
range|:
literal|1
decl_stmt|;
comment|/**< IRCNT UnderFlow Detected                                                          If SW writes a larger value than what is currently                                                          in the MIX_IRCNT[IRCNT], then HW will report the                                                          underflow condition.                                                          NOTE: The MIX_IRCNT[IRCNT] will clamp to to zero.                                                          NOTE: If an IRUN underflow condition is detected,                                                          the integrity of the MIX/AGL HW state has                                                          been compromised. To recover, SW must issue a                                                          software reset sequence (see: MIX_CTL[RESET] */
name|uint64_t
name|data_drp
range|:
literal|1
decl_stmt|;
comment|/**< Data was dropped due to RX FIFO full                                                          If this does occur, the DATA_DRP is set and the                                                          CIU_INTx_SUM0,4[MII] bits are set.                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(DATA_DRPENA) is set, than an                                                          interrupt is reported for this event. */
name|uint64_t
name|irthresh
range|:
literal|1
decl_stmt|;
comment|/**< Inbound Ring Packet Threshold Exceeded                                                          When the pending \#inbound packets in system                                                          memory(IRCNT) has exceeded a programmable threshold                                                          (IRHWM), then this bit is set. If this does occur,                                                          the IRTHRESH is set and the CIU_INTx_SUM0,4[MII] bits                                                          are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(ITHENA) is set, than an                                                          interrupt is reported for this event. */
name|uint64_t
name|orthresh
range|:
literal|1
decl_stmt|;
comment|/**< Outbound Ring Packet Threshold Exceeded                                                          When the pending \#outbound packets in system                                                          memory(ORCNT) has exceeded a programmable threshold                                                          (ORHWM), then this bit is set. If this does occur,                                                          the ORTHRESH is set and the CIU_INTx_SUM0,4[MII] bits                                                          are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(OTHENA) is set, than an                                                          interrupt is reported for this event. */
name|uint64_t
name|idblovf
range|:
literal|1
decl_stmt|;
comment|/**< Inbound DoorBell(IDBELL) Overflow Detected                                                          If SW attempts to write to the MIX_IRING2[IDBELL]                                                          with a value greater than the remaining \#of                                                          I-Ring Buffer Entries (MIX_REMCNT[IREMCNT]), then                                                          the following occurs:                                                          1) The  MIX_IRING2[IDBELL] write is IGNORED                                                          2) The ODBLOVF is set and the CIU_INTx_SUM0,4[MII]                                                             bits are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(IVFENA) is set, than an                                                          interrupt is reported for this event.                                                          SW should keep track of the \#I-Ring Entries in use                                                          (ie: cumulative \# of IDBELL writes),  and ensure that                                                          future IDBELL writes don't exceed the size of the                                                          I-Ring Buffer (MIX_IRING2[ISIZE]).                                                          SW must reclaim I-Ring Entries by keeping track of the                                                          \#IRing-Entries, and writing to the MIX_IRCNT[IRCNT].                                                          NOTE: The MIX_IRCNT[IRCNT] register represents the                                                          total \#packets(not IRing Entries) and SW must further                                                          keep track of the \# of I-Ring Entries associated with                                                          each packet as they are processed.                                                          NOTE: There is no recovery from an IDBLOVF Interrupt.                                                          If it occurs, it's an indication that SW has                                                          overwritten the I-Ring buffer, and the only recourse                                                          is a HW reset. */
name|uint64_t
name|odblovf
range|:
literal|1
decl_stmt|;
comment|/**< Outbound DoorBell(ODBELL) Overflow Detected                                                          If SW attempts to write to the MIX_ORING2[ODBELL]                                                          with a value greater than the remaining \#of                                                          O-Ring Buffer Entries (MIX_REMCNT[OREMCNT]), then                                                          the following occurs:                                                          1) The  MIX_ORING2[ODBELL] write is IGNORED                                                          2) The ODBLOVF is set and the CIU_INTx_SUM0,4[MII]                                                             bits are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(OVFENA) is set, than an                                                          interrupt is reported for this event.                                                          SW should keep track of the \#I-Ring Entries in use                                                          (ie: cumulative \# of ODBELL writes),  and ensure that                                                          future ODBELL writes don't exceed the size of the                                                          O-Ring Buffer (MIX_ORING2[OSIZE]).                                                          SW must reclaim O-Ring Entries by writing to the                                                          MIX_ORCNT[ORCNT]. .                                                          NOTE: There is no recovery from an ODBLOVF Interrupt.                                                          If it occurs, it's an indication that SW has                                                          overwritten the O-Ring buffer, and the only recourse                                                          is a HW reset. */
else|#
directive|else
name|uint64_t
name|odblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orthresh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irthresh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|data_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mixx_isr_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|orun
range|:
literal|1
decl_stmt|;
comment|/**< ORCNT UnderFlow Detected                                                          If SW writes a larger value than what is currently                                                          in the MIX_ORCNT[ORCNT], then HW will report the                                                          underflow condition.                                                          NOTE: The MIX_ORCNT[IOCNT] will clamp to to zero.                                                          NOTE: If an ORUN underflow condition is detected,                                                          the integrity of the MIX/AGL HW state has                                                          been compromised. To recover, SW must issue a                                                          software reset sequence (see: MIX_CTL[RESET] */
name|uint64_t
name|irun
range|:
literal|1
decl_stmt|;
comment|/**< IRCNT UnderFlow Detected                                                          If SW writes a larger value than what is currently                                                          in the MIX_IRCNT[IRCNT], then HW will report the                                                          underflow condition.                                                          NOTE: The MIX_IRCNT[IRCNT] will clamp to to zero.                                                          NOTE: If an IRUN underflow condition is detected,                                                          the integrity of the MIX/AGL HW state has                                                          been compromised. To recover, SW must issue a                                                          software reset sequence (see: MIX_CTL[RESET] */
name|uint64_t
name|data_drp
range|:
literal|1
decl_stmt|;
comment|/**< Data was dropped due to RX FIFO full                                                          If this does occur, the DATA_DRP is set and the                                                          CIU_INTx_SUM0,4[MII] bits are set.                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(DATA_DRPENA) is set, than an                                                          interrupt is reported for this event. */
name|uint64_t
name|irthresh
range|:
literal|1
decl_stmt|;
comment|/**< Inbound Ring Packet Threshold Exceeded                                                          When the pending \#inbound packets in system                                                          memory(IRCNT) has exceeded a programmable threshold                                                          (IRHWM), then this bit is set. If this does occur,                                                          the IRTHRESH is set and the CIU_INTx_SUM0,4[MII] bits                                                          are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(ITHENA) is set, than an                                                          interrupt is reported for this event. */
name|uint64_t
name|orthresh
range|:
literal|1
decl_stmt|;
comment|/**< Outbound Ring Packet Threshold Exceeded                                                          When the pending \#outbound packets in system                                                          memory(ORCNT) has exceeded a programmable threshold                                                          (ORHWM), then this bit is set. If this does occur,                                                          the ORTHRESH is set and the CIU_INTx_SUM0,4[MII] bits                                                          are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(OTHENA) is set, than an                                                          interrupt is reported for this event. */
name|uint64_t
name|idblovf
range|:
literal|1
decl_stmt|;
comment|/**< Inbound DoorBell(IDBELL) Overflow Detected                                                          If SW attempts to write to the MIX_IRING2[IDBELL]                                                          with a value greater than the remaining \#of                                                          I-Ring Buffer Entries (MIX_REMCNT[IREMCNT]), then                                                          the following occurs:                                                          1) The  MIX_IRING2[IDBELL] write is IGNORED                                                          2) The ODBLOVF is set and the CIU_INTx_SUM0,4[MII]                                                             bits are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(IVFENA) is set, than an                                                          interrupt is reported for this event.                                                          SW should keep track of the \#I-Ring Entries in use                                                          (ie: cumulative \# of IDBELL writes),  and ensure that                                                          future IDBELL writes don't exceed the size of the                                                          I-Ring Buffer (MIX_IRING2[ISIZE]).                                                          SW must reclaim I-Ring Entries by keeping track of the                                                          \#IRing-Entries, and writing to the MIX_IRCNT[IRCNT].                                                          NOTE: The MIX_IRCNT[IRCNT] register represents the                                                          total \#packets(not IRing Entries) and SW must further                                                          keep track of the \# of I-Ring Entries associated with                                                          each packet as they are processed.                                                          NOTE: There is no recovery from an IDBLOVF Interrupt.                                                          If it occurs, it's an indication that SW has                                                          overwritten the I-Ring buffer, and the only recourse                                                          is a HW reset. */
name|uint64_t
name|odblovf
range|:
literal|1
decl_stmt|;
comment|/**< Outbound DoorBell(ODBELL) Overflow Detected                                                          If SW attempts to write to the MIX_ORING2[ODBELL]                                                          with a value greater than the remaining \#of                                                          O-Ring Buffer Entries (MIX_REMCNT[OREMCNT]), then                                                          the following occurs:                                                          1) The  MIX_ORING2[ODBELL] write is IGNORED                                                          2) The ODBLOVF is set and the CIU_INTx_SUM0,4[MII]                                                             bits are set if ((MIX_ISR& MIX_INTENA) != 0)).                                                          If both the global interrupt mask bits (CIU_INTx_EN*[MII])                                                          and the local interrupt mask bit(OVFENA) is set, than an                                                          interrupt is reported for this event.                                                          SW should keep track of the \#I-Ring Entries in use                                                          (ie: cumulative \# of ODBELL writes),  and ensure that                                                          future ODBELL writes don't exceed the size of the                                                          O-Ring Buffer (MIX_ORING2[OSIZE]).                                                          SW must reclaim O-Ring Entries by writing to the                                                          MIX_ORCNT[ORCNT]. .                                                          NOTE: There is no recovery from an ODBLOVF Interrupt.                                                          If it occurs, it's an indication that SW has                                                          overwritten the O-Ring buffer, and the only recourse                                                          is a HW reset. */
else|#
directive|else
name|uint64_t
name|odblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|idblovf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orthresh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irthresh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|data_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|irun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mixx_isr_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_isr_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_isr_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_isr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_isr_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_isr
name|cvmx_mixx_isr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_orcnt  *  * MIX_ORCNT = MIX O-Ring Packets Sent Counter  *  * Description:  *  NOTE: To write to the MIX_ORCNT register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_ORCNT register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_orcnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_orcnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|orcnt
range|:
literal|20
decl_stmt|;
comment|/**< Pending \# of O-Ring Packets.                                                          Whenever HW removes a packet from the O-Ring, it                                                          increments the ORCNT (to indicate to SW the \# of                                                          Output packets in system memory that can be reclaimed).                                                          Reads of ORCNT return the current count.                                                          Writes of ORCNT decrement the count by the value                                                          written.                                                          This register is used to generate interrupts to alert                                                          SW of pending outbound MIX packets that have been                                                          removed from system memory. (see MIX_ISR[ORTHRESH]                                                          description for more details).                                                          NOTE: For outbound packets, the \# of O-Ring Packets                                                          is equal to the \# of O-Ring Entries. */
else|#
directive|else
name|uint64_t
name|orcnt
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_orcnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_orcnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_orcnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_orcnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_orcnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_orcnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_orcnt
name|cvmx_mixx_orcnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_orhwm  *  * MIX_ORHWM = MIX O-Ring High-Water Mark Threshold Register  *  * Description:  *  NOTE: To write to the MIX_ORHWM register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_ORHWM register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_orhwm
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_orhwm_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|orhwm
range|:
literal|20
decl_stmt|;
comment|/**< O-Ring Entry High Water Mark Threshold.                                                          Used to determine when the \# of Outbound packets                                                          in system memory that can be reclaimed                                                          (MIX_ORCNT[ORCNT]) exceeds this ORHWM threshold.                                                          NOTE: The power-on value of the CIU_INTx_EN*[MII]                                                          interrupt enable bits is zero and must be enabled                                                          to allow interrupts to be reported. */
else|#
directive|else
name|uint64_t
name|orhwm
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_orhwm_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_orhwm_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_orhwm_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_orhwm_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_orhwm_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_orhwm_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_orhwm
name|cvmx_mixx_orhwm_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_oring1  *  * MIX_ORING1 = MIX Outbound Ring Register \#1  *  * Description:  *  NOTE: To write to the MIX_ORING1 register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_ORING1 register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_oring1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_oring1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|osize
range|:
literal|20
decl_stmt|;
comment|/**< Represents the Outbound Ring Buffer's Size(in 8B                                                          words). The ring can be as large as 1M entries.                                                          NOTE: This CSR MUST BE setup written by SW poweron                                                          (when ODBELL/ORCNT=0). */
name|uint64_t
name|obase
range|:
literal|37
decl_stmt|;
comment|/**< Represents the 8B-aligned base address of the first                                                          Outbound Ring(O-Ring) Entry in system memory.                                                          NOTE: SW MUST ONLY write to this register during                                                          power-on/boot code. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|obase
range|:
literal|37
decl_stmt|;
name|uint64_t
name|osize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mixx_oring1_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|osize
range|:
literal|20
decl_stmt|;
comment|/**< Represents the Outbound Ring Buffer's Size(in 8B                                                          words). The ring can be as large as 1M entries.                                                          NOTE: This CSR MUST BE setup written by SW poweron                                                          (when ODBELL/ORCNT=0). */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|obase
range|:
literal|33
decl_stmt|;
comment|/**< Represents the 8B-aligned base address of the first                                                          Outbound Ring(O-Ring) Entry in system memory.                                                          NOTE: SW MUST ONLY write to this register during                                                          power-on/boot code. */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|obase
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|osize
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mixx_oring1_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_oring1_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_oring1_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_oring1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_oring1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_oring1
name|cvmx_mixx_oring1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_oring2  *  * MIX_ORING2 = MIX Outbound Ring Register \#2  *  * Description:  *  NOTE: To write to the MIX_ORING2 register, a device would issue an IOBST directed at the MIO.  *        To read the MIX_ORING2 register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_oring2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_oring2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
name|uint64_t
name|otlptr
range|:
literal|20
decl_stmt|;
comment|/**< The Outbound Ring Tail Pointer selects the O-Ring                                                          Entry that the HW will process next. After the HW                                                          completes sending an outbound packet, it increments                                                          the O-Ring Tail Pointer. [NOTE: The O-Ring Tail                                                          Pointer HW increment is always modulo                                                          MIX_ORING2[OSIZE].                                                          NOTE: This field is 'read-only' to SW. */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|odbell
range|:
literal|20
decl_stmt|;
comment|/**< Represents the cumulative total of pending                                                          Outbound Ring(O-Ring) Buffer Entries. Each O-Ring                                                          Buffer Entry contains 1) an L2/DRAM byte pointer                                                          along with a 2) a Byte Length.                                                          After SW inserts new entries into the O-Ring Buffer,                                                          it "rings the doorbell with the count of the newly                                                          inserted entries". When the MIX HW receives the                                                          doorbell ring, it increments the current doorbell                                                          count by the CSR write value.                                                          SW must never cause the doorbell count for the                                                          O-Ring to exceed the size of the ring(OSIZE).                                                          A read of the CSR indicates the current doorbell                                                          count. */
else|#
directive|else
name|uint64_t
name|odbell
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|otlptr
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_oring2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_oring2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_oring2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_oring2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_oring2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_oring2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_oring2
name|cvmx_mixx_oring2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_remcnt  *  * MIX_REMCNT = MIX Ring Buffer Remainder Counts (useful for HW debug only)  *  * Description:  *  NOTE: To read the MIX_REMCNT register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_remcnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_remcnt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
name|uint64_t
name|iremcnt
range|:
literal|20
decl_stmt|;
comment|/**< Remaining I-Ring Buffer Count                                                          Reflects the \# of unused/remaining I-Ring Entries                                                          that HW  currently detects in the I-Ring Buffer.                                                          HW uses this value to detect I-Ring Doorbell overflows.                                                          (see: MIX_ISR[IDBLOVF])                                                          When SW writes the MIX_IRING1[ISIZE], the IREMCNT                                                          is loaded with MIX_IRING2[ISIZE] value. (NOTE: ISIZE should only                                                          be written at power-on, when it's known that there are                                                          no I-Ring Entries currently in use by HW).                                                          When SW writes to the IDBELL register, the IREMCNT                                                          is decremented by the CSR write value.                                                          When HW issues an IRing Write Request(onto NCB Bus),                                                          the IREMCNT is incremented by 1. */
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|oremcnt
range|:
literal|20
decl_stmt|;
comment|/**< Remaining O-Ring Buffer Count                                                          Reflects the \# of unused/remaining O-Ring Entries                                                          that HW  currently detects in the O-Ring Buffer.                                                          HW uses this value to detect O-Ring Doorbell overflows.                                                          (see: MIX_ISR[ODBLOVF])                                                          When SW writes the MIX_IRING1[OSIZE], the OREMCNT                                                          is loaded with MIX_ORING2[OSIZE] value. (NOTE: OSIZE should only                                                          be written at power-on, when it's known that there are                                                          no O-Ring Entries currently in use by HW).                                                          When SW writes to the ODBELL register, the OREMCNT                                                          is decremented by the CSR write value.                                                          When SW writes to MIX_[OREMCNT], the OREMCNT is decremented                                                          by the CSR write value. */
else|#
directive|else
name|uint64_t
name|oremcnt
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_20_31
range|:
literal|12
decl_stmt|;
name|uint64_t
name|iremcnt
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_52_63
range|:
literal|12
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_remcnt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mixx_remcnt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_remcnt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mixx_remcnt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mixx_remcnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_remcnt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_remcnt
name|cvmx_mixx_remcnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_tsctl  *  * MIX_TSCTL = MIX TimeStamp Control Register  *  * Description:  *  NOTE: To read the MIX_TSCTL register, a device would issue an IOBLD64 directed at the MIO.  *  * Notes:  * SW can read the MIX_TSCTL register to determine the \#pending timestamp interrupts(TSCNT)  * as well as the \#outstanding timestamp requests in flight(TSTOT), as well as the \#of available  * timestamp entries (TSAVL) in the timestamp fifo.  * A write to the MIX_TSCTL register will advance the MIX*_TSTAMP fifo head ptr by 1, and  * also decrements the MIX*_TSCTL[TSCNT] and MIX*_TSCTL[TSTOT] pending count(s) by 1.  * For example, if SW reads MIX*_TSCTL[TSCNT]=2 (2 pending timestamp interrupts), it would immediately  * issue this sequence:  *      1) MIX*_TSTAMP[TSTAMP] read followed by MIX*_TSCTL write  *            [gets timestamp value/pops timestamp fifo and decrements pending count(s) by 1]  *      2) MIX*_TSTAMP[TSTAMP] read followed by MIX*_TSCTL write  *            [gets timestamp value/pops timestamp fifo and decrements pending count(s) by 1]  *  * SWNOTE: A MIX_TSCTL write when MIX_TSCTL[TSCNT]=0 (ie: TimeStamp Fifo empty), then the write is ignored.  */
end_comment

begin_union
union|union
name|cvmx_mixx_tsctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_tsctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
name|uint64_t
name|tsavl
range|:
literal|5
decl_stmt|;
comment|/**< # of MIX TimeStamp Entries Available for use                                                          For o63: TSAVL MAX=4 (implementation                                                          depth of timestamp fifo)                                                          TSAVL = [IMPLEMENTATION_DEPTH=4(MAX) - TSCNT] */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tstot
range|:
literal|5
decl_stmt|;
comment|/**< # of pending MIX TimeStamp Requests in-flight                                                          For o63: TSTOT must never exceed MAX=4 (implementation                                                          depth of timestamp fifo) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tscnt
range|:
literal|5
decl_stmt|;
comment|/**< # of pending MIX TimeStamp Interrupts                                                          For o63: TSCNT must never exceed MAX=4 (implementation                                                          depth of timestamp fifo) */
else|#
directive|else
name|uint64_t
name|tscnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tstot
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tsavl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_63
range|:
literal|43
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_tsctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_tsctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_tsctl
name|cvmx_mixx_tsctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mix#_tstamp  *  * MIX_TSTAMP = MIX TimeStamp Register  *  * Description:  *  NOTE: To read the MIX_TSTAMP register, a device would issue an IOBLD64 directed at the MIO.  */
end_comment

begin_union
union|union
name|cvmx_mixx_tstamp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mixx_tstamp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|tstamp
range|:
literal|64
decl_stmt|;
comment|/**< MIX TimeStamp Value                                                           When SW sets up an ORING Entry with [47]=1(TSTAMP),                                                           The packet is tagged with a specal SOP w/TSTAMP flag                                                           as it is sent to the AGL.                                                           Later the AGL will send "sample" strobe(s) to capture                                                           a global 64bit timestamp value followed by a "commit"                                                           strobe which writes the last sampled value into the                                                           outbound Timestamp fifo (max depth=4) and increments                                                           the MIX_TSCTL[TSCNT] register to indicate the total                                                           \#of pending Timestamp interrupts.                                                           If the \#pending Timestamp interrupts (MIX_TSCTL[TSCNT])                                                           is greater than the MIX_CTL[TS_THRESH] value, then                                                           a programmable interrupt is also triggered (see:                                                           MIX_ISR[TS] MIX_INTENA[TSENA]).                                                           SW will then read the MIX*_TSTAMP[TSTAMP]                                                           register value, and MUST THEN write the MIX_TSCTL                                                           register, which will decrement MIX_TSCTL[TSCNT] register,                                                           to indicate that a single timestamp interrupt has                                                           been serviced.                                                           NOTE: The MIO-MIX HW tracks upto MAX=4 outstanding                                                           timestamped outbound packets at a time. All subsequent                                                           ORING Entries w/SOP-TSTAMP will be stalled until                                                           SW can service the 4 outstanding interrupts.                                                           SW can read the MIX_TSCTL register to determine the                                                           \#pending timestamp interrupts(TSCNT) as well as the                                                           \#outstanding timestamp requests in flight(TSTOT), as                                                           well as the \#of available timestamp entries (TSAVL).                                                          SW NOTE: A MIX_TSTAMP read when MIX_TSCTL[TSCNT]=0, will                                                          result in a return value of all zeroes. SW should only                                                          read this register when MIX_ISR[TS]=1 (or when                                                          MIX_TSCTL[TSCNT] != 0) to retrieve the timestamp value                                                          recorded by HW. If SW reads the TSTAMP when HW has not                                                          recorded a valid timestamp, then an  all zeroes value is                                                          returned. */
else|#
directive|else
name|uint64_t
name|tstamp
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mixx_tstamp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mixx_tstamp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mixx_tstamp
name|cvmx_mixx_tstamp_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

