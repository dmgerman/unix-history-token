begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the hardware Free Pool Allocator.  *  *<hr>$Revision: 70030 $<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_FPA_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_FPA_H__
end_define

begin_include
include|#
directive|include
file|"cvmx-scratch.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"cvmx-fpa-defs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|CVMX_FPA_NUM_POOLS
value|8
define|#
directive|define
name|CVMX_FPA_MIN_BLOCK_SIZE
value|128
define|#
directive|define
name|CVMX_FPA_ALIGNMENT
value|128
comment|/**  * Structure describing the data format used for stores to the FPA.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|scraddr
range|:
literal|8
decl_stmt|;
comment|/**< the (64-bit word) location in scratchpad to write to (if len != 0) */
name|uint64_t
name|len
range|:
literal|8
decl_stmt|;
comment|/**< the number of words in the response (0 => no response) */
name|uint64_t
name|did
range|:
literal|8
decl_stmt|;
comment|/**< the ID of the device on the non-coherent bus */
name|uint64_t
name|addr
range|:
literal|40
decl_stmt|;
comment|/**< the address that will appear in the first tick on the NCB bus */
block|}
name|s
struct|;
block|}
name|cvmx_fpa_iobdma_data_t
typedef|;
comment|/**  * Structure describing the current state of a FPA pool.  */
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/**< Name it was created under */
name|uint64_t
name|size
decl_stmt|;
comment|/**< Size of each block */
name|void
modifier|*
name|base
decl_stmt|;
comment|/**< The base memory address of whole block */
name|uint64_t
name|starting_element_count
decl_stmt|;
comment|/**< The number of elements in the pool at creation */
block|}
name|cvmx_fpa_pool_info_t
typedef|;
comment|/**  * Current state of all the pools. Use access functions  * instead of using it directly.  */
specifier|extern
name|cvmx_fpa_pool_info_t
name|cvmx_fpa_pool_info
index|[
name|CVMX_FPA_NUM_POOLS
index|]
decl_stmt|;
comment|/* CSR typedefs have been moved to cvmx-fpa-defs.h */
comment|/**  * Return the name of the pool  *  * @param pool   Pool to get the name of  * @return The name  */
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|cvmx_fpa_get_name
parameter_list|(
name|uint64_t
name|pool
parameter_list|)
block|{
return|return
name|cvmx_fpa_pool_info
index|[
name|pool
index|]
operator|.
name|name
return|;
block|}
comment|/**  * Return the base of the pool  *  * @param pool   Pool to get the base of  * @return The base  */
specifier|static
specifier|inline
name|void
modifier|*
name|cvmx_fpa_get_base
parameter_list|(
name|uint64_t
name|pool
parameter_list|)
block|{
return|return
name|cvmx_fpa_pool_info
index|[
name|pool
index|]
operator|.
name|base
return|;
block|}
comment|/**  * Check if a pointer belongs to an FPA pool. Return non-zero  * if the supplied pointer is inside the memory controlled by  * an FPA pool.  *  * @param pool   Pool to check  * @param ptr    Pointer to check  * @return Non-zero if pointer is in the pool. Zero if not  */
specifier|static
specifier|inline
name|int
name|cvmx_fpa_is_member
parameter_list|(
name|uint64_t
name|pool
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|ptr
operator|>=
name|cvmx_fpa_pool_info
index|[
name|pool
index|]
operator|.
name|base
operator|)
operator|&&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|cvmx_fpa_pool_info
index|[
name|pool
index|]
operator|.
name|base
operator|)
operator|)
operator|+
name|cvmx_fpa_pool_info
index|[
name|pool
index|]
operator|.
name|size
operator|*
name|cvmx_fpa_pool_info
index|[
name|pool
index|]
operator|.
name|starting_element_count
operator|)
operator|)
return|;
block|}
comment|/**  * Enable the FPA for use. Must be performed after any CSR  * configuration but before any other FPA functions.  */
specifier|static
specifier|inline
name|void
name|cvmx_fpa_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_fpa_ctl_status_t
name|status
decl_stmt|;
name|status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_FPA_CTL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|s
operator|.
name|enb
condition|)
block|{
comment|/* 	 * CN68XXP1 should not reset the FPA (doing so may break the 	 * SSO, so we may end up enabling it more than once.  Just 	 * return and don't spew messages. 	 */
return|return;
block|}
name|status
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|status
operator|.
name|s
operator|.
name|enb
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_FPA_CTL_STATUS
argument_list|,
name|status
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Reset FPA to disable. Make sure buffers from all FPA pools are freed   * before disabling FPA.  */
specifier|static
specifier|inline
name|void
name|cvmx_fpa_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_fpa_ctl_status_t
name|status
decl_stmt|;
name|status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_FPA_CTL_STATUS
argument_list|)
expr_stmt|;
name|status
operator|.
name|s
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_FPA_CTL_STATUS
argument_list|,
name|status
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Get a new block from the FPA  *  * @param pool   Pool to get the block from  * @return Pointer to the block or NULL on failure  */
specifier|static
specifier|inline
name|void
modifier|*
name|cvmx_fpa_alloc
parameter_list|(
name|uint64_t
name|pool
parameter_list|)
block|{
name|uint64_t
name|address
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|address
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ADDR_DID
argument_list|(
name|CVMX_FULL_DID
argument_list|(
name|CVMX_OCT_DID_FPA
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|address
argument_list|)
condition|)
block|{
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|address
argument_list|)
return|;
block|}
else|else
block|{
comment|/* If pointers are available, continuously retry.  */
if|if
condition|(
name|cvmx_read_csr
argument_list|(
name|CVMX_FPA_QUEX_AVAILABLE
argument_list|(
name|pool
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|cvmx_wait
argument_list|(
literal|50
argument_list|)
expr_stmt|;
else|else
return|return
name|NULL
return|;
block|}
block|}
block|}
comment|/**  * Asynchronously get a new block from the FPA  *  * The result of cvmx_fpa_async_alloc() may be retrieved using  * cvmx_fpa_async_alloc_finish().  *  * @param scr_addr Local scratch address to put response in.  This is a byte address,  *                  but must be 8 byte aligned.  * @param pool      Pool to get the block from  */
specifier|static
specifier|inline
name|void
name|cvmx_fpa_async_alloc
parameter_list|(
name|uint64_t
name|scr_addr
parameter_list|,
name|uint64_t
name|pool
parameter_list|)
block|{
name|cvmx_fpa_iobdma_data_t
name|data
decl_stmt|;
comment|/* Hardware only uses 64 bit aligned locations, so convert from byte address    ** to 64-bit index    */
name|data
operator|.
name|s
operator|.
name|scraddr
operator|=
name|scr_addr
operator|>>
literal|3
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|len
operator|=
literal|1
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|did
operator|=
name|CVMX_FULL_DID
argument_list|(
name|CVMX_OCT_DID_FPA
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|addr
operator|=
literal|0
expr_stmt|;
name|cvmx_send_single
argument_list|(
name|data
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/**  * Retrieve the result of cvmx_fpa_async_alloc  *  * @param scr_addr The Local scratch address.  Must be the same value  * passed to cvmx_fpa_async_alloc().  *  * @param pool Pool the block came from.  Must be the same value  * passed to cvmx_fpa_async_alloc.  *  * @return Pointer to the block or NULL on failure  */
specifier|static
specifier|inline
name|void
modifier|*
name|cvmx_fpa_async_alloc_finish
parameter_list|(
name|uint64_t
name|scr_addr
parameter_list|,
name|uint64_t
name|pool
parameter_list|)
block|{
name|uint64_t
name|address
decl_stmt|;
name|CVMX_SYNCIOBDMA
expr_stmt|;
name|address
operator|=
name|cvmx_scratch_read64
argument_list|(
name|scr_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
name|address
argument_list|)
condition|)
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|address
argument_list|)
return|;
else|else
return|return
name|cvmx_fpa_alloc
argument_list|(
name|pool
argument_list|)
return|;
block|}
comment|/**  * Free a block allocated with a FPA pool.  * Does NOT provide memory ordering in cases where the memory block was modified by the core.  *  * @param ptr    Block to free  * @param pool   Pool to put it in  * @param num_cache_lines  *               Cache lines to invalidate  */
specifier|static
specifier|inline
name|void
name|cvmx_fpa_free_nosync
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uint64_t
name|pool
parameter_list|,
name|uint64_t
name|num_cache_lines
parameter_list|)
block|{
name|cvmx_addr_t
name|newptr
decl_stmt|;
name|newptr
operator|.
name|u64
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|newptr
operator|.
name|sfilldidspace
operator|.
name|didspace
operator|=
name|CVMX_ADDR_DIDSPACE
argument_list|(
name|CVMX_FULL_DID
argument_list|(
name|CVMX_OCT_DID_FPA
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|("" : : : "memory");
comment|/* Prevent GCC from reordering around free */
comment|/* value written is number of cache lines not written back */
name|cvmx_write_io
argument_list|(
name|newptr
operator|.
name|u64
argument_list|,
name|num_cache_lines
argument_list|)
expr_stmt|;
block|}
comment|/**  * Free a block allocated with a FPA pool.  Provides required memory  * ordering in cases where memory block was modified by core.  *  * @param ptr    Block to free  * @param pool   Pool to put it in  * @param num_cache_lines  *               Cache lines to invalidate  */
specifier|static
specifier|inline
name|void
name|cvmx_fpa_free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uint64_t
name|pool
parameter_list|,
name|uint64_t
name|num_cache_lines
parameter_list|)
block|{
name|cvmx_addr_t
name|newptr
decl_stmt|;
name|newptr
operator|.
name|u64
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|newptr
operator|.
name|sfilldidspace
operator|.
name|didspace
operator|=
name|CVMX_ADDR_DIDSPACE
argument_list|(
name|CVMX_FULL_DID
argument_list|(
name|CVMX_OCT_DID_FPA
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that any previous writes to memory go out before we free this buffer.     ** This also serves as a barrier to prevent GCC from reordering operations to after     ** the free. */
name|CVMX_SYNCWS
expr_stmt|;
comment|/* value written is number of cache lines not written back */
name|cvmx_write_io
argument_list|(
name|newptr
operator|.
name|u64
argument_list|,
name|num_cache_lines
argument_list|)
expr_stmt|;
block|}
comment|/**  * Setup a FPA pool to control a new block of memory.  * This can only be called once per pool. Make sure proper  * locking enforces this.  *  * @param pool       Pool to initialize  *                   0<= pool< 8  * @param name       Constant character string to name this pool.  *                   String is not copied.  * @param buffer     Pointer to the block of memory to use. This must be  *                   accessable by all processors and external hardware.  * @param block_size Size for each block controlled by the FPA  * @param num_blocks Number of blocks  *  * @return 0 on Success,  *         -1 on failure  */
specifier|extern
name|int
name|cvmx_fpa_setup_pool
parameter_list|(
name|uint64_t
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|uint64_t
name|block_size
parameter_list|,
name|uint64_t
name|num_blocks
parameter_list|)
function_decl|;
comment|/**  * Shutdown a Memory pool and validate that it had all of  * the buffers originally placed in it. This should only be  * called by one processor after all hardware has finished  * using the pool. Most like you will want to have called  * cvmx_helper_shutdown_packet_io_global() before this  * function to make sure all FPA buffers are out of the packet  * IO hardware.  *  * @param pool   Pool to shutdown  *  * @return Zero on success  *         - Positive is count of missing buffers  *         - Negative is too many buffers or corrupted pointers  */
specifier|extern
name|uint64_t
name|cvmx_fpa_shutdown_pool
parameter_list|(
name|uint64_t
name|pool
parameter_list|)
function_decl|;
comment|/**  * Get the size of blocks controlled by the pool  * This is resolved to a constant at compile time.  *  * @param pool   Pool to access  * @return Size of the block in bytes  */
name|uint64_t
name|cvmx_fpa_get_block_size
parameter_list|(
name|uint64_t
name|pool
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __CVM_FPA_H__ */
end_comment

end_unit

