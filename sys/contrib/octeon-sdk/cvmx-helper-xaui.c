begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Functions for XAUI initialization, configuration,  * and monitoring.  *  *<hr>$Revision: 42417 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * @INTERNAL  * Probe a XAUI interface and determine the number of ports  * connected to it. The XAUI interface should still be down  * after this call.  *  * @param interface Interface to probe  *  * @return Number of ports on the interface. Zero to disable.  */
end_comment

begin_function
name|int
name|__cvmx_helper_xaui_probe
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_gmxx_hg2_control_t
name|gmx_hg2_control
decl_stmt|;
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
comment|/* Due to errata GMX-700 on CN56XXp1.x and CN52XXp1.x, the interface         needs to be enabled before IPD otherwise per port backpressure         may not work properly */
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|,
name|mode
operator|.
name|u64
argument_list|)
expr_stmt|;
name|__cvmx_helper_setup_gmx
argument_list|(
name|interface
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Setup PKO to support 16 ports for HiGig2 virtual ports. We're pointing         all of the PKO packet ports for this interface to the XAUI. This allows         us to use HiGig2 backpressure per port */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_pko_mem_port_ptrs_t
name|pko_mem_port_ptrs
decl_stmt|;
name|pko_mem_port_ptrs
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* We set each PKO port to have equal priority in a round robin             fashion */
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|static_p
operator|=
literal|0
expr_stmt|;
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|qos_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* All PKO ports map to the same XAUI hardware port */
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|eid
operator|=
name|interface
operator|*
literal|4
expr_stmt|;
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|pid
operator|=
name|interface
operator|*
literal|16
operator|+
name|i
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_MEM_PORT_PTRS
argument_list|,
name|pko_mem_port_ptrs
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* If HiGig2 is enabled return 16 ports, otherwise return 1 port */
name|gmx_hg2_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_HG2_CONTROL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmx_hg2_control
operator|.
name|s
operator|.
name|hg2tx_en
condition|)
return|return
literal|16
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Bringup and enable a XAUI interface. After this call packet  * I/O should be fully functional. This is called with IPD  * enabled but PKO disabled.  *  * @param interface Interface to bring up  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_xaui_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|cvmx_pcsxx_control1_reg_t
name|xauiCtl
decl_stmt|;
name|cvmx_pcsxx_misc_ctl_reg_t
name|xauiMiscCtl
decl_stmt|;
name|cvmx_gmxx_tx_xaui_ctl_t
name|gmxXauiTxCtl
decl_stmt|;
name|cvmx_gmxx_rxx_int_en_t
name|gmx_rx_int_en
decl_stmt|;
name|cvmx_gmxx_tx_int_en_t
name|gmx_tx_int_en
decl_stmt|;
name|cvmx_pcsxx_int_en_reg_t
name|pcsx_int_en_reg
decl_stmt|;
comment|/* (1) Interface has already been enabled. */
comment|/* (2) Disable GMX. */
name|xauiMiscCtl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|xauiMiscCtl
operator|.
name|s
operator|.
name|gmxeno
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|xauiMiscCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* (3) Disable GMX and PCSX interrupts. */
name|gmx_rx_int_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|gmx_tx_int_en
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|pcsx_int_en_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_INT_EN_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_EN_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* (4) Bring up the PCSX and GMX reconciliation layer. */
comment|/* (4)a Set polarity and lane swapping. */
comment|/* (4)b */
name|gmxXauiTxCtl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxXauiTxCtl
operator|.
name|s
operator|.
name|dic_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable better IFG packing and improves performance */
name|gmxXauiTxCtl
operator|.
name|s
operator|.
name|uni_en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxXauiTxCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* (4)c Aply reset sequence */
name|xauiCtl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|xauiCtl
operator|.
name|s
operator|.
name|lo_pwr
operator|=
literal|0
expr_stmt|;
name|xauiCtl
operator|.
name|s
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|xauiCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for PCS to come out of reset */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_control1_reg_t
argument_list|,
name|reset
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Wait for PCS to be aligned */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_10GBX_STATUS_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_10gbx_status_reg_t
argument_list|,
name|alignd
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Wait for RX to be ready */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_RX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_rx_xaui_ctl_t
argument_list|,
name|status
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* (6) Configure GMX */
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for GMX RX to be idle */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|rx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Wait for GMX TX to be idle */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|tx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* GMX configure */
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_PRTS
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* (7) Clear out any error state */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wait for receive link */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_STATUS1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_status1_reg_t
argument_list|,
name|rcv_lnk
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_STATUS2_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_status2_reg_t
argument_list|,
name|xmtflt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_STATUS2_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_status2_reg_t
argument_list|,
name|rcvflt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_rx_int_en
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmx_tx_int_en
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_EN_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|pcsx_int_en_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_helper_link_autoconf
argument_list|(
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (8) Enable packet reception */
name|xauiMiscCtl
operator|.
name|s
operator|.
name|gmxeno
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|xauiMiscCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return the link state of an IPD/PKO port as returned by  * auto negotiation. The result of this function may not match  * Octeon's link config if auto negotiation has changed since  * the last call to cvmx_helper_link_set().  *  * @param ipd_port IPD/PKO port to query  *  * @return Link state  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_xaui_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_gmxx_tx_xaui_ctl_t
name|gmxx_tx_xaui_ctl
decl_stmt|;
name|cvmx_gmxx_rx_xaui_ctl_t
name|gmxx_rx_xaui_ctl
decl_stmt|;
name|cvmx_pcsxx_status1_reg_t
name|pcsxx_status1_reg
decl_stmt|;
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|gmxx_tx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_rx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsxx_status1_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_STATUS1_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Only return a link if both RX and TX are happy */
if|if
condition|(
operator|(
name|gmxx_tx_xaui_ctl
operator|.
name|s
operator|.
name|ls
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gmxx_rx_xaui_ctl
operator|.
name|s
operator|.
name|status
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pcsxx_status1_reg
operator|.
name|s
operator|.
name|rcv_lnk
operator|==
literal|1
operator|)
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10000
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable GMX and PCSX interrupts. */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_EN_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure an IPD/PKO port for the specified link state. This  * function does not influence auto negotiation at the PHY level.  * The passed link state must always match the link state returned  * by cvmx_helper_link_get(). It is normally best to use  * cvmx_helper_link_autoconf() instead.  *  * @param ipd_port  IPD/PKO port to configure  * @param link_info The new link state  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_xaui_link_set
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_gmxx_tx_xaui_ctl_t
name|gmxx_tx_xaui_ctl
decl_stmt|;
name|cvmx_gmxx_rx_xaui_ctl_t
name|gmxx_rx_xaui_ctl
decl_stmt|;
name|gmxx_tx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_rx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the link shouldn't be up, then just return */
if|if
condition|(
operator|!
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
return|return
literal|0
return|;
comment|/* Do nothing if both RX and TX are happy */
if|if
condition|(
operator|(
name|gmxx_tx_xaui_ctl
operator|.
name|s
operator|.
name|ls
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gmxx_rx_xaui_ctl
operator|.
name|s
operator|.
name|status
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Bring the link up */
return|return
name|__cvmx_helper_xaui_enable
argument_list|(
name|interface
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure a port for internal and/or external loopback. Internal loopback  * causes packets sent by the port to be received by Octeon. External loopback  * causes packets received from the wire to sent out again.  *  * @param ipd_port IPD/PKO port to loopback.  * @param enable_internal  *                 Non zero if you want internal loopback  * @param enable_external  *                 Non zero if you want external loopback  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|extern
name|int
name|__cvmx_helper_xaui_configure_loopback
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|int
name|enable_internal
parameter_list|,
name|int
name|enable_external
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_pcsxx_control1_reg_t
name|pcsxx_control1_reg
decl_stmt|;
name|cvmx_gmxx_xaui_ext_loopback_t
name|gmxx_xaui_ext_loopback
decl_stmt|;
comment|/* Set the internal loop */
name|pcsxx_control1_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsxx_control1_reg
operator|.
name|s
operator|.
name|loopbck1
operator|=
name|enable_internal
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|pcsxx_control1_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Set the external loop */
name|gmxx_xaui_ext_loopback
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_XAUI_EXT_LOOPBACK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_xaui_ext_loopback
operator|.
name|s
operator|.
name|en
operator|=
name|enable_external
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_XAUI_EXT_LOOPBACK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxx_xaui_ext_loopback
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Take the link through a reset */
return|return
name|__cvmx_helper_xaui_enable
argument_list|(
name|interface
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
end_comment

end_unit

