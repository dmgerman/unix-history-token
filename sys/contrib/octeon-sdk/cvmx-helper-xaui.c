begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Functions for XAUI initialization, configuration,  * and monitoring.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-qlm.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-cfg.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcsx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcsxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ciu-defs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-cfg.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-qlm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-qlm.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_function
name|int
name|__cvmx_helper_xaui_enumerate
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|union
name|cvmx_gmxx_hg2_control
name|gmx_hg2_control
decl_stmt|;
comment|/* If HiGig2 is enabled return 16 ports, otherwise return 1 port */
name|gmx_hg2_control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_HG2_CONTROL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gmx_hg2_control
operator|.
name|s
operator|.
name|hg2tx_en
condition|)
return|return
literal|16
return|;
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Probe a XAUI interface and determine the number of ports  * connected to it. The XAUI interface should still be down  * after this call.  *  * @param interface Interface to probe  *  * @return Number of ports on the interface. Zero to disable.  */
end_comment

begin_function
name|int
name|__cvmx_helper_xaui_probe
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_gmxx_inf_mode_t
name|mode
decl_stmt|;
comment|/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be programmed */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_0
argument_list|)
condition|)
block|{
name|cvmx_ciu_qlm2_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM2
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|0x5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x1a
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM2
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* CN63XX Pass 2.0 and 2.1 errata G-15273 requires the QLM De-emphasis be         programmed when using a 156.25Mhz ref clock */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_0
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_1
argument_list|)
condition|)
block|{
comment|/* Read the QLM speed pins */
name|cvmx_mio_rst_boot_t
name|mio_rst_boot
decl_stmt|;
name|mio_rst_boot
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_BOOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|mio_rst_boot
operator|.
name|cn63xx
operator|.
name|qlm2_spd
operator|==
literal|0xb
condition|)
block|{
name|cvmx_ciu_qlm2_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM2
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|0xa
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x1f
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM2
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if QLM is configured correct for XAUI/RXAUI, verify the         speed as well as mode */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|int
name|qlm
decl_stmt|,
name|status
decl_stmt|;
name|qlm
operator|=
name|cvmx_qlm_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|status
operator|=
name|cvmx_qlm_get_status
argument_list|(
name|qlm
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
literal|2
operator|&&
name|status
operator|!=
literal|10
condition|)
return|return
literal|0
return|;
block|}
comment|/* Due to errata GMX-700 on CN56XXp1.x and CN52XXp1.x, the interface         needs to be enabled before IPD otherwise per port backpressure         may not work properly */
name|mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|mode
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_INF_MODE
argument_list|(
name|interface
argument_list|)
argument_list|,
name|mode
operator|.
name|u64
argument_list|)
expr_stmt|;
name|__cvmx_helper_setup_gmx
argument_list|(
name|interface
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
comment|/* Setup PKO to support 16 ports for HiGig2 virtual ports. We're pointing 	    all of the PKO packet ports for this interface to the XAUI. This allows 	    us to use HiGig2 backpressure per port */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_pko_mem_port_ptrs_t
name|pko_mem_port_ptrs
decl_stmt|;
name|pko_mem_port_ptrs
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* We set each PKO port to have equal priority in a round robin 	        fashion */
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|static_p
operator|=
literal|0
expr_stmt|;
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|qos_mask
operator|=
literal|0xff
expr_stmt|;
comment|/* All PKO ports map to the same XAUI hardware port */
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|eid
operator|=
name|interface
operator|*
literal|4
expr_stmt|;
name|pko_mem_port_ptrs
operator|.
name|s
operator|.
name|pid
operator|=
name|interface
operator|*
literal|16
operator|+
name|i
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_MEM_PORT_PTRS
argument_list|,
name|pko_mem_port_ptrs
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|__cvmx_helper_xaui_enumerate
argument_list|(
name|interface
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Bringup XAUI interface. After this call packet I/O should be   * fully functional.  *  * @param interface Interface to bring up  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_helper_xaui_link_init
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_gmxx_prtx_cfg_t
name|gmx_cfg
decl_stmt|;
name|cvmx_pcsxx_control1_reg_t
name|xauiCtl
decl_stmt|;
name|cvmx_pcsxx_misc_ctl_reg_t
name|xauiMiscCtl
decl_stmt|;
name|cvmx_gmxx_tx_xaui_ctl_t
name|gmxXauiTxCtl
decl_stmt|;
comment|/* (1) Interface has already been enabled. */
comment|/* (2) Disable GMX. */
name|xauiMiscCtl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|xauiMiscCtl
operator|.
name|s
operator|.
name|gmxeno
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|xauiMiscCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* (3) Disable GMX and PCSX interrupts. */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_EN_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
comment|/* (4) Bring up the PCSX and GMX reconciliation layer. */
comment|/* (4)a Set polarity and lane swapping. */
comment|/* (4)b */
name|gmxXauiTxCtl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxXauiTxCtl
operator|.
name|s
operator|.
name|dic_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable better IFG packing and improves performance */
name|gmxXauiTxCtl
operator|.
name|s
operator|.
name|uni_en
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxXauiTxCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* (4)c Aply reset sequence */
name|xauiCtl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|xauiCtl
operator|.
name|s
operator|.
name|lo_pwr
operator|=
literal|0
expr_stmt|;
comment|/* Errata G-15618 requires disabling PCS soft reset in some OCTEON II models. */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_0
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_1
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX_PASS1_X
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|xauiCtl
operator|.
name|s
operator|.
name|reset
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|xauiCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for PCS to come out of reset */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_control1_reg_t
argument_list|,
name|reset
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Wait for PCS to be aligned */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_10GBX_STATUS_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_10gbx_status_reg_t
argument_list|,
name|alignd
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Wait for RX to be ready */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_RX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_rx_xaui_ctl_t
argument_list|,
name|status
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* (6) Configure GMX */
comment|/* Wait for GMX RX to be idle */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|rx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Wait for GMX TX to be idle */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|cvmx_gmxx_prtx_cfg_t
argument_list|,
name|tx_idle
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* GMX configure */
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|speed
operator|=
literal|1
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|slottime
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_PRTS
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_SLOT
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_BURST
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|8192
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for receive link */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_STATUS1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_status1_reg_t
argument_list|,
name|rcv_lnk
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_STATUS2_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_status2_reg_t
argument_list|,
name|xmtflt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PCSXX_STATUS2_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|cvmx_pcsxx_status2_reg_t
argument_list|,
name|rcvflt
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|10000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* (8) Enable packet reception */
name|xauiMiscCtl
operator|.
name|s
operator|.
name|gmxeno
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|xauiMiscCtl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Clear all error interrupts before enabling the interface. */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_REG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
operator|~
literal|0x0ull
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|~
literal|0x0ull
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
operator|~
literal|0x0ull
argument_list|)
expr_stmt|;
comment|/* Enable GMX */
name|gmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Bringup and enable a XAUI interface. After this call packet  * I/O should be fully functional. This is called with IPD  * enabled but PKO disabled.  *  * @param interface Interface to bring up  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_xaui_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
comment|/* Setup PKND and BPID */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|cvmx_gmxx_bpid_msk_t
name|bpid_msk
decl_stmt|;
name|cvmx_gmxx_bpid_mapx_t
name|bpid_map
decl_stmt|;
name|cvmx_gmxx_prtx_cfg_t
name|gmxx_prtx_cfg
decl_stmt|;
name|cvmx_gmxx_txx_append_t
name|gmxx_txx_append_cfg
decl_stmt|;
comment|/* Setup PKIND */
name|gmxx_prtx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_prtx_cfg
operator|.
name|s
operator|.
name|pknd
operator|=
name|cvmx_helper_get_pknd
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_PRTX_CFG
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_prtx_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup BPID */
name|bpid_map
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_BPID_MAPX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|bpid_map
operator|.
name|s
operator|.
name|val
operator|=
literal|1
expr_stmt|;
name|bpid_map
operator|.
name|s
operator|.
name|bpid
operator|=
name|cvmx_helper_get_bpid
argument_list|(
name|interface
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_BPID_MAPX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|bpid_map
operator|.
name|u64
argument_list|)
expr_stmt|;
name|bpid_msk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_BPID_MSK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|bpid_msk
operator|.
name|s
operator|.
name|msk_or
operator||=
literal|1
expr_stmt|;
name|bpid_msk
operator|.
name|s
operator|.
name|msk_and
operator|&=
operator|~
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_BPID_MSK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|bpid_msk
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* CN68XX adds the padding and FCS in PKO, not GMX */
name|gmxx_txx_append_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TXX_APPEND
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_txx_append_cfg
operator|.
name|s
operator|.
name|fcs
operator|=
literal|0
expr_stmt|;
name|gmxx_txx_append_cfg
operator|.
name|s
operator|.
name|pad
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_APPEND
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmxx_txx_append_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|__cvmx_helper_xaui_link_init
argument_list|(
name|interface
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Return the link state of an IPD/PKO port as returned by  * auto negotiation. The result of this function may not match  * Octeon's link config if auto negotiation has changed since  * the last call to cvmx_helper_link_set().  *  * @param ipd_port IPD/PKO port to query  *  * @return Link state  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_xaui_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_gmxx_tx_xaui_ctl_t
name|gmxx_tx_xaui_ctl
decl_stmt|;
name|cvmx_gmxx_rx_xaui_ctl_t
name|gmxx_rx_xaui_ctl
decl_stmt|;
name|cvmx_pcsxx_status1_reg_t
name|pcsxx_status1_reg
decl_stmt|;
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|gmxx_tx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_rx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsxx_status1_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_STATUS1_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Only return a link if both RX and TX are happy */
if|if
condition|(
operator|(
name|gmxx_tx_xaui_ctl
operator|.
name|s
operator|.
name|ls
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gmxx_rx_xaui_ctl
operator|.
name|s
operator|.
name|status
operator|==
literal|0
operator|)
operator|&&
operator|(
name|pcsxx_status1_reg
operator|.
name|s
operator|.
name|rcv_lnk
operator|==
literal|1
operator|)
condition|)
block|{
name|cvmx_pcsxx_misc_ctl_reg_t
name|misc_ctl
decl_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_mio_qlmx_cfg_t
name|qlm_cfg
decl_stmt|;
name|int
name|lanes
decl_stmt|;
name|int
name|qlm
init|=
operator|(
name|interface
operator|==
literal|1
operator|)
condition|?
literal|0
else|:
name|interface
decl_stmt|;
name|qlm_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_QLMX_CFG
argument_list|(
name|qlm
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
name|cvmx_qlm_get_gbaud_mhz
argument_list|(
name|qlm
argument_list|)
operator|*
literal|8
operator|/
literal|10
expr_stmt|;
name|lanes
operator|=
operator|(
name|qlm_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|7
operator|)
condition|?
literal|2
else|:
literal|4
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|*=
name|lanes
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|int
name|qlm
init|=
name|cvmx_qlm_interface
argument_list|(
name|interface
argument_list|)
decl_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
name|cvmx_qlm_get_gbaud_mhz
argument_list|(
name|qlm
argument_list|)
operator|*
literal|8
operator|/
literal|10
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|*=
literal|4
expr_stmt|;
block|}
else|else
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10000
expr_stmt|;
name|misc_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_MISC_CTL_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|misc_ctl
operator|.
name|s
operator|.
name|gmxeno
condition|)
name|__cvmx_helper_xaui_link_init
argument_list|(
name|interface
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Disable GMX and PCSX interrupts. */
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RXX_INT_EN
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_INT_EN
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_INT_EN_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure an IPD/PKO port for the specified link state. This  * function does not influence auto negotiation at the PHY level.  * The passed link state must always match the link state returned  * by cvmx_helper_link_get(). It is normally best to use  * cvmx_helper_link_autoconf() instead.  *  * @param ipd_port  IPD/PKO port to configure  * @param link_info The new link state  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_xaui_link_set
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_gmxx_tx_xaui_ctl_t
name|gmxx_tx_xaui_ctl
decl_stmt|;
name|cvmx_gmxx_rx_xaui_ctl_t
name|gmxx_rx_xaui_ctl
decl_stmt|;
name|gmxx_tx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_rx_xaui_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RX_XAUI_CTL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the link shouldn't be up, then just return */
if|if
condition|(
operator|!
name|link_info
operator|.
name|s
operator|.
name|link_up
condition|)
return|return
literal|0
return|;
comment|/* Do nothing if both RX and TX are happy */
if|if
condition|(
operator|(
name|gmxx_tx_xaui_ctl
operator|.
name|s
operator|.
name|ls
operator|==
literal|0
operator|)
operator|&&
operator|(
name|gmxx_rx_xaui_ctl
operator|.
name|s
operator|.
name|status
operator|==
literal|0
operator|)
condition|)
return|return
literal|0
return|;
comment|/* Bring the link up */
return|return
name|__cvmx_helper_xaui_link_init
argument_list|(
name|interface
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Configure a port for internal and/or external loopback. Internal loopback  * causes packets sent by the port to be received by Octeon. External loopback  * causes packets received from the wire to sent out again.  *  * @param ipd_port IPD/PKO port to loopback.  * @param enable_internal  *                 Non zero if you want internal loopback  * @param enable_external  *                 Non zero if you want external loopback  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|extern
name|int
name|__cvmx_helper_xaui_configure_loopback
parameter_list|(
name|int
name|ipd_port
parameter_list|,
name|int
name|enable_internal
parameter_list|,
name|int
name|enable_external
parameter_list|)
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|cvmx_pcsxx_control1_reg_t
name|pcsxx_control1_reg
decl_stmt|;
name|cvmx_gmxx_xaui_ext_loopback_t
name|gmxx_xaui_ext_loopback
decl_stmt|;
comment|/* Set the internal loop */
name|pcsxx_control1_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|pcsxx_control1_reg
operator|.
name|s
operator|.
name|loopbck1
operator|=
name|enable_internal
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PCSXX_CONTROL1_REG
argument_list|(
name|interface
argument_list|)
argument_list|,
name|pcsxx_control1_reg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Set the external loop */
name|gmxx_xaui_ext_loopback
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_XAUI_EXT_LOOPBACK
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmxx_xaui_ext_loopback
operator|.
name|s
operator|.
name|en
operator|=
name|enable_external
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_XAUI_EXT_LOOPBACK
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmxx_xaui_ext_loopback
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Take the link through a reset */
return|return
name|__cvmx_helper_xaui_link_init
argument_list|(
name|interface
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_PKO_FUNCTIONS */
end_comment

end_unit

