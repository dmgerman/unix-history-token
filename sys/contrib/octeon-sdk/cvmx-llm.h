begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * interface to the low latency DRAM  *  *<hr>$Revision: 70030 $<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_LLM_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_LLM_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
define|#
directive|define
name|ENABLE_DEPRECATED
comment|/* Set to enable the old 18/36 bit names */
typedef|typedef
enum|enum
block|{
name|CVMX_LLM_REPLICATION_NONE
init|=
literal|0
block|,
name|CVMX_LLM_REPLICATION_2X
init|=
literal|1
block|,
comment|// on both interfaces, or 2x if only one interface
name|CVMX_LLM_REPLICATION_4X
init|=
literal|2
block|,
comment|// both interfaces, 2x, or 4x if only one interface
name|CVMX_LLM_REPLICATION_8X
init|=
literal|3
block|,
comment|// both interfaces, 4x,  or 8x if only one interface
block|}
name|cvmx_llm_replication_t
typedef|;
comment|/**  * This structure defines the address used to the low-latency memory.  * This address format is used for both loads and stores.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|mbz
range|:
literal|30
decl_stmt|;
name|cvmx_llm_replication_t
name|repl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|address
range|:
literal|32
decl_stmt|;
comment|// address<1:0> mbz, address<31:30> mbz
block|}
name|s
struct|;
block|}
name|cvmx_llm_address_t
typedef|;
comment|/**  * This structure defines the data format in the low-latency memory  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
comment|/**      * this format defines the format returned on a load      *   a load returns the 32/36-bits in memory, plus xxor = even_parity(dat<35:0>)      *   typically, dat<35> = parity(dat<34:0>), so the xor bit directly indicates parity error      *   Note that the data field size is 36 bits on the 36XX/38XX, and 32 bits on the 31XX      */
struct|struct
block|{
name|uint64_t
name|mbz1
range|:
literal|27
decl_stmt|;
name|uint64_t
name|xxor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mbz
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|32
decl_stmt|;
block|}
name|cn31xx
struct|;
struct|struct
block|{
name|uint64_t
name|mbz
range|:
literal|27
decl_stmt|;
name|uint64_t
name|xxor
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|36
decl_stmt|;
block|}
name|s
struct|;
comment|/**      *  This format defines what should be used if parity is desired.  Hardware returns      *  the XOR of all the bits in the 36/32 bit data word, so for parity software must use      * one of the data field bits as a parity bit.      */
struct|struct
name|cn31xx_par_struct
block|{
name|uint64_t
name|mbz
range|:
literal|32
decl_stmt|;
name|uint64_t
name|par
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|31
decl_stmt|;
block|}
name|cn31xx_par
struct|;
struct|struct
name|cn38xx_par_struct
block|{
name|uint64_t
name|mbz
range|:
literal|28
decl_stmt|;
name|uint64_t
name|par
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|35
decl_stmt|;
block|}
name|cn38xx_par
struct|;
if|#
directive|if
operator|!
name|OCTEON_IS_COMMON_BINARY
argument_list|()
if|#
directive|if
name|CVMX_COMPILED_FOR
argument_list|(
name|OCTEON_CN31XX
argument_list|)
name|struct
name|cn31xx_par_struct
name|spar
decl_stmt|;
else|#
directive|else
name|struct
name|cn38xx_par_struct
name|spar
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
name|cvmx_llm_data_t
typedef|;
define|#
directive|define
name|CVMX_LLM_NARROW_DATA_WIDTH
value|((CVMX_COMPILED_FOR(OCTEON_CN31XX)) ? 32 : 36)
comment|/**  * Calculate the parity value of a number  *  * @param value  * @return parity value  */
specifier|static
specifier|inline
name|uint64_t
name|cvmx_llm_parity
parameter_list|(
name|uint64_t
name|value
parameter_list|)
block|{
name|uint64_t
name|result
decl_stmt|;
name|CVMX_DPOP
argument_list|(
name|result
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/**  * Calculate the ECC needed for 36b LLM mode  *  * @param value  * @return  ECC value  */
specifier|static
specifier|inline
name|int
name|cvmx_llm_ecc
parameter_list|(
name|uint64_t
name|value
parameter_list|)
block|{
comment|/* FIXME: This needs a re-write */
specifier|static
specifier|const
name|uint32_t
name|ecc_code_29
index|[
literal|7
index|]
init|=
block|{
literal|0x08962595
block|,
literal|0x112a4aaa
block|,
literal|0x024c934f
block|,
literal|0x04711c73
block|,
literal|0x0781e07c
block|,
literal|0x1801ff80
block|,
literal|0x1ffe0000
block|}
decl_stmt|;
name|uint64_t
name|pop0
decl_stmt|,
name|pop1
decl_stmt|,
name|pop2
decl_stmt|,
name|pop3
decl_stmt|,
name|pop4
decl_stmt|,
name|pop5
decl_stmt|,
name|pop6
decl_stmt|;
name|pop0
operator|=
name|ecc_code_29
index|[
literal|0
index|]
expr_stmt|;
name|pop1
operator|=
name|ecc_code_29
index|[
literal|1
index|]
expr_stmt|;
name|pop2
operator|=
name|ecc_code_29
index|[
literal|2
index|]
expr_stmt|;
name|pop0
operator|&=
name|value
expr_stmt|;
name|pop3
operator|=
name|ecc_code_29
index|[
literal|3
index|]
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop0
argument_list|,
name|pop0
argument_list|)
expr_stmt|;
name|pop4
operator|=
name|ecc_code_29
index|[
literal|4
index|]
expr_stmt|;
name|pop1
operator|&=
name|value
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop1
argument_list|,
name|pop1
argument_list|)
expr_stmt|;
name|pop2
operator|&=
name|value
expr_stmt|;
name|pop5
operator|=
name|ecc_code_29
index|[
literal|5
index|]
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop2
argument_list|,
name|pop2
argument_list|)
expr_stmt|;
name|pop6
operator|=
name|ecc_code_29
index|[
literal|6
index|]
expr_stmt|;
name|pop3
operator|&=
name|value
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop3
argument_list|,
name|pop3
argument_list|)
expr_stmt|;
name|pop4
operator|&=
name|value
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop4
argument_list|,
name|pop4
argument_list|)
expr_stmt|;
name|pop5
operator|&=
name|value
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop5
argument_list|,
name|pop5
argument_list|)
expr_stmt|;
name|pop6
operator|&=
name|value
expr_stmt|;
name|CVMX_DPOP
argument_list|(
name|pop6
argument_list|,
name|pop6
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|pop6
operator|&
literal|1
operator|)
operator|<<
literal|6
operator|)
operator||
operator|(
operator|(
name|pop5
operator|&
literal|1
operator|)
operator|<<
literal|5
operator|)
operator||
operator|(
operator|(
name|pop4
operator|&
literal|1
operator|)
operator|<<
literal|4
operator|)
operator||
operator|(
operator|(
name|pop3
operator|&
literal|1
operator|)
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
name|pop2
operator|&
literal|1
operator|)
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|pop1
operator|&
literal|1
operator|)
operator|<<
literal|1
operator|)
operator||
operator|(
name|pop0
operator|&
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|ENABLE_DEPRECATED
comment|/* These macros are provided to provide compatibility with code that uses ** the old names for the llm access functions.  The names were changed ** when support for the 31XX llm was added, as the widths differ between Octeon Models. ** The wide/narrow names are preferred, and should be used in all new code */
define|#
directive|define
name|cvmx_llm_write36
value|cvmx_llm_write_narrow
define|#
directive|define
name|cvmx_llm_read36
value|cvmx_llm_read_narrow
define|#
directive|define
name|cvmx_llm_write64
value|cvmx_llm_write_wide
define|#
directive|define
name|cvmx_llm_read64
value|cvmx_llm_read_wide
endif|#
directive|endif
comment|/**  * Write to LLM memory - 36 bit  *  * @param address Address in LLM to write. Consecutive writes increment the  *                address by 4. The replication mode is also encoded in this  *                address.  * @param value   Value to write to LLM. Only the low 36 bits will be used.  * @param set     Which of the two coprocessor 2 register sets to use for the  *                write. May be used to get two outstanding LLM access at once  *                per core. Range: 0-1  */
specifier|static
specifier|inline
name|void
name|cvmx_llm_write_narrow
parameter_list|(
name|cvmx_llm_address_t
name|address
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|cvmx_llm_data_t
name|data
decl_stmt|;
name|data
operator|.
name|s
operator|.
name|mbz
operator|=
literal|0
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|dat
operator|=
name|value
expr_stmt|;
name|data
operator|.
name|s
operator|.
name|xxor
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|CVMX_MT_LLM_DATA
argument_list|(
literal|1
argument_list|,
name|data
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_MT_LLM_WRITE_ADDR_INTERNAL
argument_list|(
literal|1
argument_list|,
name|address
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CVMX_MT_LLM_DATA
argument_list|(
literal|0
argument_list|,
name|data
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_MT_LLM_WRITE_ADDR_INTERNAL
argument_list|(
literal|0
argument_list|,
name|address
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Write to LLM memory - 64 bit  *  * @param address Address in LLM to write. Consecutive writes increment the  *                address by 8. The replication mode is also encoded in this  *                address.  * @param value   Value to write to LLM.  * @param set     Which of the two coprocessor 2 register sets to use for the  *                write. May be used to get two outstanding LLM access at once  *                per core. Range: 0-1  */
specifier|static
specifier|inline
name|void
name|cvmx_llm_write_wide
parameter_list|(
name|cvmx_llm_address_t
name|address
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|int
name|set
parameter_list|)
block|{
if|if
condition|(
name|set
condition|)
block|{
name|CVMX_MT_LLM_DATA
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|CVMX_MT_LLM_WRITE64_ADDR_INTERNAL
argument_list|(
literal|1
argument_list|,
name|address
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CVMX_MT_LLM_DATA
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|CVMX_MT_LLM_WRITE64_ADDR_INTERNAL
argument_list|(
literal|0
argument_list|,
name|address
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Read from LLM memory - 36 bit  *  * @param address Address in LLM to read. Consecutive reads increment the  *                address by 4. The replication mode is also encoded in this  *                address.  * @param set     Which of the two coprocessor 2 register sets to use for the  *                write. May be used to get two outstanding LLM access at once  *                per core. Range: 0-1  * @return The lower 36 bits contain the result of the read  */
specifier|static
specifier|inline
name|cvmx_llm_data_t
name|cvmx_llm_read_narrow
parameter_list|(
name|cvmx_llm_address_t
name|address
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|cvmx_llm_data_t
name|value
decl_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|CVMX_MT_LLM_READ_ADDR
argument_list|(
literal|1
argument_list|,
name|address
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_MF_LLM_DATA
argument_list|(
literal|1
argument_list|,
name|value
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CVMX_MT_LLM_READ_ADDR
argument_list|(
literal|0
argument_list|,
name|address
operator|.
name|u64
argument_list|)
expr_stmt|;
name|CVMX_MF_LLM_DATA
argument_list|(
literal|0
argument_list|,
name|value
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
comment|/**  * Read from LLM memory - 64 bit  *  * @param address Address in LLM to read. Consecutive reads increment the  *                address by 8. The replication mode is also encoded in this  *                address.  * @param set     Which of the two coprocessor 2 register sets to use for the  *                write. May be used to get two outstanding LLM access at once  *                per core. Range: 0-1  * @return The result of the read  */
specifier|static
specifier|inline
name|uint64_t
name|cvmx_llm_read_wide
parameter_list|(
name|cvmx_llm_address_t
name|address
parameter_list|,
name|int
name|set
parameter_list|)
block|{
name|uint64_t
name|value
decl_stmt|;
if|if
condition|(
name|set
condition|)
block|{
name|CVMX_MT_LLM_READ64_ADDR
argument_list|(
literal|1
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|CVMX_MF_LLM_DATA
argument_list|(
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|CVMX_MT_LLM_READ64_ADDR
argument_list|(
literal|0
argument_list|,
name|address
argument_list|)
expr_stmt|;
name|CVMX_MF_LLM_DATA
argument_list|(
literal|0
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|value
return|;
block|}
define|#
directive|define
name|RLD_INIT_DELAY
value|(1<<18)
comment|/* This structure describes the RLDRAM configuration for a board.  This structure ** must be populated with the correct values and passed to the initialization function. */
typedef|typedef
struct|struct
block|{
name|uint32_t
name|cpu_hz
decl_stmt|;
comment|/* CPU frequency in Hz */
name|char
name|addr_rld0_fb_str
index|[
literal|100
index|]
decl_stmt|;
comment|/* String describing RLDRAM connections on rld 0 front (0) bunk*/
name|char
name|addr_rld0_bb_str
index|[
literal|100
index|]
decl_stmt|;
comment|/* String describing RLDRAM connections on rld 0 back (1) bunk*/
name|char
name|addr_rld1_fb_str
index|[
literal|100
index|]
decl_stmt|;
comment|/* String describing RLDRAM connections on rld 1 front (0) bunk*/
name|char
name|addr_rld1_bb_str
index|[
literal|100
index|]
decl_stmt|;
comment|/* String describing RLDRAM connections on rld 1 back (1) bunk*/
name|uint8_t
name|rld0_bunks
decl_stmt|;
comment|/* Number of bunks on rld 0 (0 is disabled) */
name|uint8_t
name|rld1_bunks
decl_stmt|;
comment|/* Number of bunks on rld 1 (0 is disabled) */
name|uint16_t
name|rld0_mbytes
decl_stmt|;
comment|/* mbytes on rld 0 */
name|uint16_t
name|rld1_mbytes
decl_stmt|;
comment|/* mbytes on rld 1 */
name|uint16_t
name|max_rld_clock_mhz
decl_stmt|;
comment|/* Maximum RLD clock in MHz, only used for CN58XX */
block|}
name|llm_descriptor_t
typedef|;
comment|/**  * Initialize LLM memory controller.  This must be done  * before the low latency memory can be used.  * This is simply a wrapper around cvmx_llm_initialize_desc(),  * and is deprecated.  *  * @return -1 on error  *         0 on success  */
name|int
name|cvmx_llm_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Initialize LLM memory controller.  This must be done  * before the low latency memory can be used.  *  * @param llm_desc_ptr  *              Pointer to descriptor structure. If NULL  *              is passed, a default setting is used if available.  *  * @return -1 on error  *         Size of llm in bytes on success  */
name|int
name|cvmx_llm_initialize_desc
parameter_list|(
name|llm_descriptor_t
modifier|*
name|llm_desc_ptr
parameter_list|)
function_decl|;
comment|/**  * Gets the default llm descriptor for the board code is being run on.  *  * @param llm_desc_ptr  *               Pointer to descriptor structure to be filled in.  Contents are only  *               valid after successful completion.  Must not be NULL.  *  * @return -1 on error  *         0 on success  */
name|int
name|cvmx_llm_get_default_descriptor
parameter_list|(
name|llm_descriptor_t
modifier|*
name|llm_desc_ptr
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  __CVM_LLM_H__ */
end_comment

end_unit

