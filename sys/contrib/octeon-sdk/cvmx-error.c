begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the Octeon extended error status.  *  *<hr>$Revision: 44252 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error-custom.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pcie.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-srio.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ciu2-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dfm-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-lmcx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error-custom.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pcie.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-srio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_TABLE_SIZE
value|1024
end_define

begin_comment
comment|/* Max number of error status bits we can support */
end_comment

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cnf71xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn68xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn68xxp1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn66xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn63xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn63xxp1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn61xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn58xxp1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn58xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn56xxp1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn56xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn50xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn52xxp1
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn52xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn38xxp2
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn38xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn31xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|cvmx_error_initialize_cn30xx
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Each entry in this array represents a status bit function or chain */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_error_info_t
name|__cvmx_error_table
index|[
name|MAX_TABLE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|int
name|__cvmx_error_table_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_error_flags_t
name|__cvmx_error_flags
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|REG_MATCH
parameter_list|(
name|h
parameter_list|,
name|reg_type
parameter_list|,
name|status_addr
parameter_list|,
name|status_mask
parameter_list|)
define|\
value|((h->reg_type == reg_type)&& (h->status_addr == status_addr)&& (h->status_mask == status_mask))
end_define

begin_comment
comment|/**  * @INTERNAL  * Read a status or enable register from the hardware  *  * @param reg_type Register type to read  * @param addr     Address to read  *  * @return Result of the read  */
end_comment

begin_function
specifier|static
name|uint64_t
name|__cvmx_error_read_hw
parameter_list|(
name|cvmx_error_register_t
name|reg_type
parameter_list|,
name|uint64_t
name|addr
parameter_list|)
block|{
switch|switch
condition|(
name|reg_type
condition|)
block|{
case|case
name|__CVMX_ERROR_REGISTER_NONE
case|:
return|return
literal|0
return|;
case|case
name|CVMX_ERROR_REGISTER_IO64
case|:
return|return
name|cvmx_read_csr
argument_list|(
name|addr
argument_list|)
return|;
case|case
name|CVMX_ERROR_REGISTER_IO32
case|:
return|return
name|cvmx_read64_uint32
argument_list|(
name|addr
operator|^
literal|4
argument_list|)
return|;
case|case
name|CVMX_ERROR_REGISTER_PCICONFIG
case|:
return|return
name|cvmx_pcie_cfgx_read
argument_list|(
name|addr
operator|>>
literal|32
argument_list|,
name|addr
operator|&
literal|0xffffffffull
argument_list|)
return|;
case|case
name|CVMX_ERROR_REGISTER_SRIOMAINT
case|:
block|{
name|uint32_t
name|r
decl_stmt|;
if|if
condition|(
name|cvmx_srio_config_read32
argument_list|(
name|addr
operator|>>
literal|32
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|addr
operator|&
literal|0xffffffffull
argument_list|,
operator|&
name|r
argument_list|)
condition|)
return|return
literal|0
return|;
else|else
return|return
name|r
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write a status or enable register to the hardware  *  * @param reg_type Register type to write  * @param addr     Address to write  * @param value    Value to write  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_error_write_hw
parameter_list|(
name|cvmx_error_register_t
name|reg_type
parameter_list|,
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
switch|switch
condition|(
name|reg_type
condition|)
block|{
case|case
name|__CVMX_ERROR_REGISTER_NONE
case|:
return|return;
case|case
name|CVMX_ERROR_REGISTER_IO64
case|:
name|cvmx_write_csr
argument_list|(
name|addr
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|CVMX_ERROR_REGISTER_IO32
case|:
name|cvmx_write64_uint32
argument_list|(
name|addr
operator|^
literal|4
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|CVMX_ERROR_REGISTER_PCICONFIG
case|:
name|cvmx_pcie_cfgx_write
argument_list|(
name|addr
operator|>>
literal|32
argument_list|,
name|addr
operator|&
literal|0xffffffffull
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
case|case
name|CVMX_ERROR_REGISTER_SRIOMAINT
case|:
block|{
name|cvmx_srio_config_write32
argument_list|(
name|addr
operator|>>
literal|32
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|addr
operator|&
literal|0xffffffffull
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Function for processing non leaf error status registers. This function  * calls all handlers for this passed register and all children linked  * to it.  *  * @param info   Error register to check  *  * @return Number of error status bits found or zero if no bits were set.  */
end_comment

begin_function
name|int
name|__cvmx_error_decode
parameter_list|(
specifier|const
name|cvmx_error_info_t
modifier|*
name|info
parameter_list|)
block|{
name|uint64_t
name|status
decl_stmt|;
name|uint64_t
name|enable
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|handled
init|=
literal|0
decl_stmt|;
comment|/* Read the status and enable state */
name|status
operator|=
name|__cvmx_error_read_hw
argument_list|(
name|info
operator|->
name|reg_type
argument_list|,
name|info
operator|->
name|status_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|enable_addr
condition|)
name|enable
operator|=
name|__cvmx_error_read_hw
argument_list|(
name|info
operator|->
name|reg_type
argument_list|,
name|info
operator|->
name|enable_addr
argument_list|)
expr_stmt|;
else|else
name|enable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
name|uint64_t
name|masked_status
init|=
name|status
decl_stmt|;
comment|/* If this is a child of the current register then recurse and process             the child */
if|if
condition|(
operator|(
name|h
operator|->
name|parent
operator|.
name|reg_type
operator|==
name|info
operator|->
name|reg_type
operator|)
operator|&&
operator|(
name|h
operator|->
name|parent
operator|.
name|status_addr
operator|==
name|info
operator|->
name|status_addr
operator|)
operator|&&
operator|(
name|status
operator|&
name|h
operator|->
name|parent
operator|.
name|status_mask
operator|)
condition|)
name|handled
operator|+=
name|__cvmx_error_decode
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|h
operator|->
name|reg_type
operator|!=
name|info
operator|->
name|reg_type
operator|)
operator|||
operator|(
name|h
operator|->
name|status_addr
operator|!=
name|info
operator|->
name|status_addr
operator|)
condition|)
continue|continue;
comment|/* If the corresponding enable bit is not set then we have nothing to do */
if|if
condition|(
name|h
operator|->
name|enable_addr
operator|&&
name|h
operator|->
name|enable_mask
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|enable
operator|&
name|h
operator|->
name|enable_mask
operator|)
condition|)
continue|continue;
block|}
comment|/* Apply the mask to eliminate irrelevant bits */
if|if
condition|(
name|h
operator|->
name|status_mask
condition|)
name|masked_status
operator|&=
name|h
operator|->
name|status_mask
expr_stmt|;
comment|/* Finally call the handler function unless it is this function */
if|if
condition|(
name|masked_status
operator|&&
name|h
operator|->
name|func
operator|&&
operator|(
name|h
operator|->
name|func
operator|!=
name|__cvmx_error_decode
operator|)
condition|)
name|handled
operator|+=
name|h
operator|->
name|func
argument_list|(
name|h
argument_list|)
expr_stmt|;
block|}
comment|/* Ths should be the total errors found */
return|return
name|handled
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * This error bit handler simply prints a message and clears the status bit  *  * @param info   Error register to check  *  * @return  */
end_comment

begin_function
name|int
name|__cvmx_error_display
parameter_list|(
specifier|const
name|cvmx_error_info_t
modifier|*
name|info
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|message
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
operator|(
name|long
operator|)
name|info
operator|->
name|user_info
decl_stmt|;
comment|/* This assumes that all bits in the status register are RO or R/W1C */
name|__cvmx_error_write_hw
argument_list|(
name|info
operator|->
name|reg_type
argument_list|,
name|info
operator|->
name|status_addr
argument_list|,
name|info
operator|->
name|status_mask
argument_list|)
expr_stmt|;
name|cvmx_safe_printf
argument_list|(
literal|"%s"
argument_list|,
name|message
argument_list|)
expr_stmt|;
comment|/* Clear the source to reduce the chance for spurious interrupts.  */
comment|/* CN68XX has an CIU-15786 errata that accessing the ACK registers      * can stop interrupts from propagating      */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU2_INTR_CIU_READY
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU2_ACK_PPX_IP4
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Initalize the error status system. This should be called once  * before any other functions are called. This function adds default  * handlers for most all error events but does not enable them. Later  * calls to cvmx_error_enable() are needed.  *  * @param flags  Optional flags.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_error_initialize
parameter_list|(
name|cvmx_error_flags_t
name|flags
parameter_list|)
block|{
name|__cvmx_error_flags
operator|=
name|flags
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cnf71xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn68xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX_PASS1_X
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn68xxp1
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn66xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn63xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn63xxp1
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn61xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX_PASS1_X
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn58xxp1
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn58xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn56xxp1
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn56xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn50xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn52xxp1
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn52xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX_PASS2
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn38xxp2
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn38xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn31xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|cvmx_error_initialize_cn30xx
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
block|}
else|else
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx_error_initialize() needs update for this Octeon model\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|__cvmx_error_custom_initialize
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Enable all of the purely internal error sources by default */
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_INTERNAL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* According to workaround for errata KEY-14814 in cn63xx, clearing         SLI_INT_SUM[RML_TO] after enabling KEY interrupts */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_INT_SUM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Enable DDR error reporting based on the memory controllers */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|cvmx_l2c_cfg_t
name|l2c_cfg
decl_stmt|;
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_cfg
operator|.
name|s
operator|.
name|dpres0
condition|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_LMC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_cfg
operator|.
name|s
operator|.
name|dpres1
condition|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_LMC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_LMC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Enable error interrupts for other LMC only if it is        available. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_lmcx_dll_ctl2_t
name|ctl2
decl_stmt|;
name|ctl2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_LMCX_DLL_CTL2
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl2
operator|.
name|s
operator|.
name|intf_en
condition|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_LMC
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Enable DFM error reporting based on feature availablility */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_DFM
argument_list|)
condition|)
block|{
comment|/* Only configure interrupts if DFM clock is enabled. */
name|cvmx_dfm_fnt_sclk_t
name|dfm_fnt_sclk
decl_stmt|;
name|dfm_fnt_sclk
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DFM_FNT_SCLK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dfm_fnt_sclk
operator|.
name|s
operator|.
name|sclkdis
condition|)
block|{
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_DFM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Old PCI parts don't have a common PCI init, so enable error         reporting if the bootloader told us we are a PCI host. PCIe         is handled when cvmx_pcie_rc_initialize is called */
if|if
condition|(
operator|!
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PCIE
argument_list|)
operator|&&
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|bootloader_config_flags
operator|&
name|CVMX_BOOTINFO_CFG_FLAG_PCI_HOST
operator|)
condition|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_PCI
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Call poll once to clear out any pending interrupts */
name|cvmx_error_poll
argument_list|()
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Poll the error status registers and call the appropriate error  * handlers. This should be called in the RSL interrupt handler  * for your application or operating system.  *  * @return Number of error handlers called. Zero means this call  *         found no errors and was spurious.  */
end_comment

begin_function
name|int
name|cvmx_error_poll
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* Call all handlers that don't have a parent */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|__cvmx_error_table
index|[
name|i
index|]
operator|.
name|parent
operator|.
name|reg_type
operator|==
name|__CVMX_ERROR_REGISTER_NONE
condition|)
name|count
operator|+=
name|__cvmx_error_decode
argument_list|(
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**  * Register to be called when an error status bit is set. Most users  * will not need to call this function as cvmx_error_initialize()  * registers default handlers for most error conditions. This function  * is normally used to add more handlers without changing the existing  * handlers.  *  * @param new_info Information about the handler for a error register. The  *                 structure passed is copied and can be destroyed after the  *                 call. All members of the structure must be populated, even the  *                 parent information.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_error_add
parameter_list|(
specifier|const
name|cvmx_error_info_t
modifier|*
name|new_info
parameter_list|)
block|{
if|if
condition|(
name|__cvmx_error_table_size
operator|>=
name|MAX_TABLE_SIZE
condition|)
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx-error table full\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__cvmx_error_table
index|[
name|__cvmx_error_table_size
index|]
operator|=
operator|*
name|new_info
expr_stmt|;
name|__cvmx_error_table_size
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Remove all handlers for a status register and mask. Normally  * this function should not be called. Instead a new handler should be  * installed to replace the existing handler. In the even that all  * reporting of a error bit should be removed, then use this  * function.  *  * @param reg_type Type of the status register to remove  * @param status_addr  *                 Status register to remove.  * @param status_mask  *                 All handlers for this status register with this mask will be  *                 removed.  * @param old_info If not NULL, this is filled with information about the handler  *                 that was removed.  *  * @return Zero on success, negative on failure (not found).  */
end_comment

begin_function
name|int
name|cvmx_error_remove
parameter_list|(
name|cvmx_error_register_t
name|reg_type
parameter_list|,
name|uint64_t
name|status_addr
parameter_list|,
name|uint64_t
name|status_mask
parameter_list|,
name|cvmx_error_info_t
modifier|*
name|old_info
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|REG_MATCH
argument_list|(
name|h
argument_list|,
name|reg_type
argument_list|,
name|status_addr
argument_list|,
name|status_mask
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|old_info
condition|)
operator|*
name|old_info
operator|=
operator|*
name|h
expr_stmt|;
name|memset
argument_list|(
name|h
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|h
argument_list|)
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
literal|0
return|;
else|else
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx-error remove couldn't find requested register\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Change the function and user_info for an existing error status  * register. This function should be used to replace the default  * handler with an application specific version as needed.  *  * @param reg_type Type of the status register to change  * @param status_addr  *                 Status register to change.  * @param status_mask  *                 All handlers for this status register with this mask will be  *                 changed.  * @param new_func New function to use to handle the error status  * @param new_user_info  *                 New user info parameter for the function  * @param old_func If not NULL, the old function is returned. Useful for restoring  *                 the old handler.  * @param old_user_info  *                 If not NULL, the old user info parameter.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_error_change_handler
parameter_list|(
name|cvmx_error_register_t
name|reg_type
parameter_list|,
name|uint64_t
name|status_addr
parameter_list|,
name|uint64_t
name|status_mask
parameter_list|,
name|cvmx_error_func_t
name|new_func
parameter_list|,
name|uint64_t
name|new_user_info
parameter_list|,
name|cvmx_error_func_t
modifier|*
name|old_func
parameter_list|,
name|uint64_t
modifier|*
name|old_user_info
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|REG_MATCH
argument_list|(
name|h
argument_list|,
name|reg_type
argument_list|,
name|status_addr
argument_list|,
name|status_mask
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|old_func
condition|)
operator|*
name|old_func
operator|=
name|h
operator|->
name|func
expr_stmt|;
if|if
condition|(
name|old_user_info
condition|)
operator|*
name|old_user_info
operator|=
name|h
operator|->
name|user_info
expr_stmt|;
name|h
operator|->
name|func
operator|=
name|new_func
expr_stmt|;
name|h
operator|->
name|user_info
operator|=
name|new_user_info
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
literal|0
return|;
else|else
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx-error change couldn't find requested register\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Enable all error registers for a logical group. This should be  * called whenever a logical group is brought online.  *  * @param group  Logical group to enable  * @param group_index  *               Index for the group as defined in the cvmx_error_group_t  *               comments.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_error_enable_group
parameter_list|(
name|cvmx_error_group_t
name|group
parameter_list|,
name|int
name|group_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|enable
decl_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
comment|/* SGMII and XAUI has different ipd_port, use the same group_index            for both the interfaces */
switch|switch
condition|(
name|group_index
condition|)
block|{
case|case
literal|0x840
case|:
name|group_index
operator|=
literal|0x800
expr_stmt|;
break|break;
case|case
literal|0xa40
case|:
name|group_index
operator|=
literal|0xa00
expr_stmt|;
break|break;
case|case
literal|0xb40
case|:
name|group_index
operator|=
literal|0xb00
expr_stmt|;
break|break;
case|case
literal|0xc40
case|:
name|group_index
operator|=
literal|0xc00
expr_stmt|;
break|break;
block|}
comment|/* Skip entries that have a different group or group index. We             also skip entries that don't have an enable */
if|if
condition|(
operator|(
name|h
operator|->
name|group
operator|!=
name|group
operator|)
operator|||
operator|(
name|h
operator|->
name|group_index
operator|!=
name|group_index
operator|)
operator|||
operator|(
operator|!
name|h
operator|->
name|enable_addr
operator|)
condition|)
continue|continue;
comment|/* Skip entries that have flags that don't match the user's             selected flags */
if|if
condition|(
name|h
operator|->
name|flags
operator|&&
operator|(
name|h
operator|->
name|flags
operator|!=
operator|(
name|h
operator|->
name|flags
operator|&
name|__cvmx_error_flags
operator|)
operator|)
condition|)
continue|continue;
comment|/* Update the enables for this entry */
name|enable
operator|=
name|__cvmx_error_read_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|reg_type
operator|==
name|CVMX_ERROR_REGISTER_PCICONFIG
condition|)
name|enable
operator|&=
operator|~
name|h
operator|->
name|enable_mask
expr_stmt|;
comment|/* PCI bits have reversed polarity */
else|else
name|enable
operator||=
name|h
operator|->
name|enable_mask
expr_stmt|;
name|__cvmx_error_write_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Disable all error registers for a logical group. This should be  * called whenever a logical group is brought offline. Many blocks  * will report spurious errors when offline unless this function  * is called.  *  * @param group  Logical group to disable  * @param group_index  *               Index for the group as defined in the cvmx_error_group_t  *               comments.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_error_disable_group
parameter_list|(
name|cvmx_error_group_t
name|group
parameter_list|,
name|int
name|group_index
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|enable
decl_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
comment|/* SGMII and XAUI has different ipd_port, use the same group_index            for both the interfaces */
switch|switch
condition|(
name|group_index
condition|)
block|{
case|case
literal|0x840
case|:
name|group_index
operator|=
literal|0x800
expr_stmt|;
break|break;
case|case
literal|0xa40
case|:
name|group_index
operator|=
literal|0xa00
expr_stmt|;
break|break;
case|case
literal|0xb40
case|:
name|group_index
operator|=
literal|0xb00
expr_stmt|;
break|break;
case|case
literal|0xc40
case|:
name|group_index
operator|=
literal|0xc00
expr_stmt|;
break|break;
block|}
comment|/* Skip entries that have a different group or group index. We             also skip entries that don't have an enable */
if|if
condition|(
operator|(
name|h
operator|->
name|group
operator|!=
name|group
operator|)
operator|||
operator|(
name|h
operator|->
name|group_index
operator|!=
name|group_index
operator|)
operator|||
operator|(
operator|!
name|h
operator|->
name|enable_addr
operator|)
condition|)
continue|continue;
comment|/* Update the enables for this entry */
name|enable
operator|=
name|__cvmx_error_read_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|reg_type
operator|==
name|CVMX_ERROR_REGISTER_PCICONFIG
condition|)
name|enable
operator||=
name|h
operator|->
name|enable_mask
expr_stmt|;
comment|/* PCI bits have reversed polarity */
else|else
name|enable
operator|&=
operator|~
name|h
operator|->
name|enable_mask
expr_stmt|;
name|__cvmx_error_write_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|,
name|enable
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Enable all handlers for a specific status register mask.  *  * @param reg_type Type of the status register  * @param status_addr  *                 Status register address  * @param status_mask  *                 All handlers for this status register with this mask will be  *                 enabled.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_error_enable
parameter_list|(
name|cvmx_error_register_t
name|reg_type
parameter_list|,
name|uint64_t
name|status_addr
parameter_list|,
name|uint64_t
name|status_mask
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|enable
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|REG_MATCH
argument_list|(
name|h
argument_list|,
name|reg_type
argument_list|,
name|status_addr
argument_list|,
name|status_mask
argument_list|)
operator|||
operator|!
name|h
operator|->
name|enable_addr
condition|)
continue|continue;
name|enable
operator|=
name|__cvmx_error_read_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|reg_type
operator|==
name|CVMX_ERROR_REGISTER_PCICONFIG
condition|)
name|enable
operator|&=
operator|~
name|h
operator|->
name|enable_mask
expr_stmt|;
comment|/* PCI bits have reversed polarity */
else|else
name|enable
operator||=
name|h
operator|->
name|enable_mask
expr_stmt|;
name|__cvmx_error_write_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|h
operator|->
name|flags
operator|&=
operator|~
name|CVMX_ERROR_FLAGS_DISABLED
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
literal|0
return|;
else|else
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx-error enable couldn't find requested register\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Disable all handlers for a specific status register and mask.  *  * @param reg_type Type of the status register  * @param status_addr  *                 Status register address  * @param status_mask  *                 All handlers for this status register with this mask will be  *                 disabled.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_error_disable
parameter_list|(
name|cvmx_error_register_t
name|reg_type
parameter_list|,
name|uint64_t
name|status_addr
parameter_list|,
name|uint64_t
name|status_mask
parameter_list|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|enable
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_error_info_t
modifier|*
name|h
init|=
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|REG_MATCH
argument_list|(
name|h
argument_list|,
name|reg_type
argument_list|,
name|status_addr
argument_list|,
name|status_mask
argument_list|)
operator|||
operator|!
name|h
operator|->
name|enable_addr
condition|)
continue|continue;
name|enable
operator|=
name|__cvmx_error_read_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|reg_type
operator|==
name|CVMX_ERROR_REGISTER_PCICONFIG
condition|)
name|enable
operator||=
name|h
operator|->
name|enable_mask
expr_stmt|;
comment|/* PCI bits have reversed polarity */
else|else
name|enable
operator|&=
operator|~
name|h
operator|->
name|enable_mask
expr_stmt|;
name|__cvmx_error_write_hw
argument_list|(
name|h
operator|->
name|reg_type
argument_list|,
name|h
operator|->
name|enable_addr
argument_list|,
name|enable
argument_list|)
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|CVMX_ERROR_FLAGS_DISABLED
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
return|return
literal|0
return|;
else|else
block|{
name|cvmx_warn
argument_list|(
literal|"cvmx-error disable couldn't find requested register\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * Find the handler for a specific status register and mask  *  * @param status_addr  *                Status register address  *  * @return  Return the handler on success or null on failure.  */
end_comment

begin_function
name|cvmx_error_info_t
modifier|*
name|cvmx_error_get_index
parameter_list|(
name|uint64_t
name|status_addr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|__cvmx_error_table_size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|__cvmx_error_table
index|[
name|i
index|]
operator|.
name|status_addr
operator|==
name|status_addr
condition|)
return|return
operator|&
name|__cvmx_error_table
index|[
name|i
index|]
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

end_unit

