begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-agl-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon agl.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_AGL_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_AGL_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_BAD_REG
value|CVMX_AGL_GMX_BAD_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_BAD_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_BAD_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000518ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_BAD_REG
value|(CVMX_ADD_IO_SEG(0x00011800E0000518ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_BIST
value|CVMX_AGL_GMX_BIST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_BIST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_BIST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000400ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_BIST
value|(CVMX_ADD_IO_SEG(0x00011800E0000400ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_DRV_CTL
value|CVMX_AGL_GMX_DRV_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_DRV_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_DRV_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00007F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_DRV_CTL
value|(CVMX_ADD_IO_SEG(0x00011800E00007F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_INF_MODE
value|CVMX_AGL_GMX_INF_MODE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_INF_MODE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_INF_MODE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00007F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_INF_MODE
value|(CVMX_ADD_IO_SEG(0x00011800E00007F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_PRTX_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_PRTX_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_PRTX_CFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000010ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000180ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000180ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000188ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000188ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000190ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000190ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000198ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000198ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM4(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00001A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM4
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00001A0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM5(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00001A8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM5
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00001A8ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CAM_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CAM_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000108ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CAM_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000108ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_ADR_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_ADR_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000100ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_ADR_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000100ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_DECISION
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_DECISION(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_DECISION
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000040ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_FRM_CHK
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_FRM_CHK(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_FRM_CHK
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000020ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_FRM_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_FRM_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_FRM_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000018ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_FRM_MAX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_FRM_MAX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_FRM_MAX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000030ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_FRM_MIN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_FRM_MIN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_FRM_MIN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000028ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_IFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_IFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000058ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_IFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000058ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_INT_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_INT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_INT_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000008ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_INT_REG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_INT_REG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_INT_REG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000000ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_JABBER
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_JABBER(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_JABBER
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000038ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_PAUSE_DROP_TIME
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_PAUSE_DROP_TIME(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000068ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_PAUSE_DROP_TIME
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000068ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_RX_INBND
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_RX_INBND(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_RX_INBND
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000060ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000050ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_OCTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_OCTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000088ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_OCTS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000088ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_OCTS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_OCTS_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000098ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_OCTS_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000098ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_OCTS_DMAC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_OCTS_DMAC(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00000A8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_OCTS_DMAC
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00000A8ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_OCTS_DRP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_OCTS_DRP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00000B8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_OCTS_DRP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00000B8ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_PKTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_PKTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_PKTS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000080ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_PKTS_BAD
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_PKTS_BAD(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00000C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_PKTS_BAD
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00000C0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_PKTS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_PKTS_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000090ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_PKTS_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000090ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_PKTS_DMAC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_PKTS_DMAC(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00000A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_PKTS_DMAC
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00000A0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_STATS_PKTS_DRP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_STATS_PKTS_DRP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00000B0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_STATS_PKTS_DRP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00000B0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RXX_UDD_SKP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RXX_UDD_SKP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RXX_UDD_SKP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000048ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RX_BP_DROPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RX_BP_DROPX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000420ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_BP_DROPX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000420ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RX_BP_OFFX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RX_BP_OFFX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000460ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_BP_OFFX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000460ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RX_BP_ONX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RX_BP_ONX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000440ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_BP_ONX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000440ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_PRT_INFO
value|CVMX_AGL_GMX_RX_PRT_INFO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RX_PRT_INFO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RX_PRT_INFO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00004E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_PRT_INFO
value|(CVMX_ADD_IO_SEG(0x00011800E00004E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_TX_STATUS
value|CVMX_AGL_GMX_RX_TX_STATUS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_RX_TX_STATUS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_RX_TX_STATUS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00007E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_RX_TX_STATUS
value|(CVMX_ADD_IO_SEG(0x00011800E00007E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_SMACX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_SMACX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000230ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_SMACX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000230ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_STAT_BP
value|CVMX_AGL_GMX_STAT_BP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_STAT_BP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_STAT_BP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000520ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_STAT_BP
value|(CVMX_ADD_IO_SEG(0x00011800E0000520ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_APPEND
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_APPEND(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000218ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_APPEND
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000218ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_CLK
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_CLK(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000208ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_CLK
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000208ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000270ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000270ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_MIN_PKT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_MIN_PKT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000240ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_MIN_PKT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000240ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_PAUSE_PKT_INTERVAL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_PAUSE_PKT_INTERVAL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000248ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_PAUSE_PKT_INTERVAL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000248ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_PAUSE_PKT_TIME
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_PAUSE_PKT_TIME(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000238ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_PAUSE_PKT_TIME
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000238ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_PAUSE_TOGO
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_PAUSE_TOGO(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000258ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_PAUSE_TOGO
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000258ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_PAUSE_ZERO
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_PAUSE_ZERO(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000260ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_PAUSE_ZERO
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000260ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_SOFT_PAUSE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_SOFT_PAUSE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000250ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_SOFT_PAUSE
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000250ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000280ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000280ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000288ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000288ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000290ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000290ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000298ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000298ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT4(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00002A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT4
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00002A0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT5(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00002A8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT5
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00002A8ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT6
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT6(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00002B0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT6
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00002B0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT7
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT7(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00002B8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT7
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00002B8ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT8
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT8(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00002C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT8
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00002C0ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STAT9
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STAT9(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00002C8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STAT9
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E00002C8ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_STATS_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_STATS_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000268ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_STATS_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000268ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TXX_THRESH
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TXX_THRESH(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000210ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|2048
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TXX_THRESH
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0000210ull) + ((offset)& 1) * 2048)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_BP
value|CVMX_AGL_GMX_TX_BP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_BP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_BP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00004D0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_BP
value|(CVMX_ADD_IO_SEG(0x00011800E00004D0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_COL_ATTEMPT
value|CVMX_AGL_GMX_TX_COL_ATTEMPT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_COL_ATTEMPT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_COL_ATTEMPT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000498ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_COL_ATTEMPT
value|(CVMX_ADD_IO_SEG(0x00011800E0000498ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_IFG
value|CVMX_AGL_GMX_TX_IFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_IFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_IFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000488ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_IFG
value|(CVMX_ADD_IO_SEG(0x00011800E0000488ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_INT_EN
value|CVMX_AGL_GMX_TX_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000508ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_INT_EN
value|(CVMX_ADD_IO_SEG(0x00011800E0000508ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_INT_REG
value|CVMX_AGL_GMX_TX_INT_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_INT_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_INT_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000500ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_INT_REG
value|(CVMX_ADD_IO_SEG(0x00011800E0000500ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_JAM
value|CVMX_AGL_GMX_TX_JAM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_JAM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_JAM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0000490ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_JAM
value|(CVMX_ADD_IO_SEG(0x00011800E0000490ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_LFSR
value|CVMX_AGL_GMX_TX_LFSR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_LFSR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_LFSR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00004F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_LFSR
value|(CVMX_ADD_IO_SEG(0x00011800E00004F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_OVR_BP
value|CVMX_AGL_GMX_TX_OVR_BP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_OVR_BP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_OVR_BP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00004C8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_OVR_BP
value|(CVMX_ADD_IO_SEG(0x00011800E00004C8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_PAUSE_PKT_DMAC
value|CVMX_AGL_GMX_TX_PAUSE_PKT_DMAC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_PAUSE_PKT_DMAC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_PAUSE_PKT_DMAC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00004A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_PAUSE_PKT_DMAC
value|(CVMX_ADD_IO_SEG(0x00011800E00004A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_PAUSE_PKT_TYPE
value|CVMX_AGL_GMX_TX_PAUSE_PKT_TYPE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_GMX_TX_PAUSE_PKT_TYPE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_GMX_TX_PAUSE_PKT_TYPE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E00004A8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_GMX_TX_PAUSE_PKT_TYPE
value|(CVMX_ADD_IO_SEG(0x00011800E00004A8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_AGL_PRTX_CTL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_AGL_PRTX_CTL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800E0002000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_AGL_PRTX_CTL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800E0002000ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_agl_gmx_bad_reg  *  * AGL_GMX_BAD_REG = A collection of things that have gone very, very wrong  *  *  * Notes:  * OUT_OVR[0], LOSTSTAT[0], OVRFLW, TXPOP, TXPSH    will be reset when MIX0_CTL[RESET] is set to 1.  * OUT_OVR[1], LOSTSTAT[1], OVRFLW1, TXPOP1, TXPSH1 will be reset when MIX1_CTL[RESET] is set to 1.  * STATOVR will be reset when both MIX0/1_CTL[RESET] are set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_bad_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_bad_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|txpsh1
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO overflow (MII1) */
name|uint64_t
name|txpop1
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO underflow (MII1) */
name|uint64_t
name|ovrflw1
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO overflow (MII1) */
name|uint64_t
name|txpsh
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO overflow (MII0) */
name|uint64_t
name|txpop
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO underflow (MII0) */
name|uint64_t
name|ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO overflow (MII0) */
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics overflow */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|2
decl_stmt|;
comment|/**< TX Statistics data was over-written                                                          In MII/RGMII, one bit per port                                                          TX Stats are corrupted */
name|uint64_t
name|reserved_4_21
range|:
literal|18
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|2
decl_stmt|;
comment|/**< Outbound data FIFO overflow */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_21
range|:
literal|18
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrflw1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_bad_reg_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|txpsh1
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO overflow (MII1) */
name|uint64_t
name|txpop1
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO underflow (MII1) */
name|uint64_t
name|ovrflw1
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO overflow (MII1) */
name|uint64_t
name|txpsh
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO overflow (MII0) */
name|uint64_t
name|txpop
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO underflow (MII0) */
name|uint64_t
name|ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO overflow (MII0) */
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics overflow */
name|uint64_t
name|reserved_23_25
range|:
literal|3
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics data was over-written                                                          TX Stats are corrupted */
name|uint64_t
name|reserved_4_21
range|:
literal|18
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|2
decl_stmt|;
comment|/**< Outbound data FIFO overflow */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_21
range|:
literal|18
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_25
range|:
literal|3
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrflw1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_bad_reg_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_bad_reg_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO overflow */
name|uint64_t
name|txpop
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO underflow */
name|uint64_t
name|ovrflw
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO overflow */
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics overflow */
name|uint64_t
name|reserved_23_25
range|:
literal|3
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|1
decl_stmt|;
comment|/**< TX Statistics data was over-written                                                          TX Stats are corrupted */
name|uint64_t
name|reserved_3_21
range|:
literal|19
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|1
decl_stmt|;
comment|/**< Outbound data FIFO overflow */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|out_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_21
range|:
literal|19
decl_stmt|;
name|uint64_t
name|loststat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_23_25
range|:
literal|3
decl_stmt|;
name|uint64_t
name|statovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ovrflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_bad_reg_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_bad_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_bad_reg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_bad_reg
name|cvmx_agl_gmx_bad_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_bist  *  * AGL_GMX_BIST = GMX BIST Results  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_bist
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_bist_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|status
range|:
literal|25
decl_stmt|;
comment|/**< BIST Results.                                                          HW sets a bit in BIST for for memory that fails                                                          - 0: gmx#.inb.fif_bnk0                                                          - 1: gmx#.inb.fif_bnk1                                                          - 2: gmx#.inb.fif_bnk2                                                          - 3: gmx#.inb.fif_bnk3                                                          - 4: gmx#.inb.fif_bnk_ext0                                                          - 5: gmx#.inb.fif_bnk_ext1                                                          - 6: gmx#.inb.fif_bnk_ext2                                                          - 7: gmx#.inb.fif_bnk_ext3                                                          - 8: gmx#.outb.fif.fif_bnk0                                                          - 9: gmx#.outb.fif.fif_bnk1                                                          - 10: RAZ                                                          - 11: RAZ                                                          - 12: gmx#.outb.fif.fif_bnk_ext0                                                          - 13: gmx#.outb.fif.fif_bnk_ext1                                                          - 14: RAZ                                                          - 15: RAZ                                                          - 16: gmx#.csr.gmi0.srf8x64m1_bist                                                          - 17: gmx#.csr.gmi1.srf8x64m1_bist                                                          - 18: RAZ                                                          - 19: RAZ                                                          - 20: gmx#.csr.drf20x32m2_bist                                                          - 21: gmx#.csr.drf20x48m2_bist                                                          - 22: gmx#.outb.stat.drf16x27m1_bist                                                          - 23: gmx#.outb.stat.drf40x64m1_bist                                                          - 24: RAZ */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_bist_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|status
range|:
literal|10
decl_stmt|;
comment|/**< BIST Results.                                                           HW sets a bit in BIST for for memory that fails                                                          - 0: gmx#.inb.drf128x78m1_bist                                                          - 1: gmx#.outb.fif.drf128x71m1_bist                                                          - 2: gmx#.csr.gmi0.srf8x64m1_bist                                                          - 3: gmx#.csr.gmi1.srf8x64m1_bist                                                          - 4: 0                                                          - 5: 0                                                          - 6: gmx#.csr.drf20x80m1_bist                                                          - 7: gmx#.outb.stat.drf16x27m1_bist                                                          - 8: gmx#.outb.stat.drf40x64m1_bist                                                          - 9: 0 */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_bist_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_bist_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_bist_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_bist_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_bist_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_bist
name|cvmx_agl_gmx_bist_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_drv_ctl  *  * AGL_GMX_DRV_CTL = GMX Drive Control  *  *  * Notes:  * NCTL, PCTL, BYP_EN    will be reset when MIX0_CTL[RESET] is set to 1.  * NCTL1, PCTL1, BYP_EN1 will be reset when MIX1_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_drv_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_drv_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|byp_en1
range|:
literal|1
decl_stmt|;
comment|/**< Compensation Controller Bypass Enable (MII1) */
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl1
range|:
literal|5
decl_stmt|;
comment|/**< AGL PCTL (MII1) */
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl1
range|:
literal|5
decl_stmt|;
comment|/**< AGL NCTL (MII1) */
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|byp_en
range|:
literal|1
decl_stmt|;
comment|/**< Compensation Controller Bypass Enable */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< AGL PCTL */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< AGL NCTL */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|byp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|nctl1
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_37_39
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl1
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_45_47
range|:
literal|3
decl_stmt|;
name|uint64_t
name|byp_en1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_drv_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_drv_ctl_s
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_drv_ctl_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|byp_en
range|:
literal|1
decl_stmt|;
comment|/**< Compensation Controller Bypass Enable */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< AGL PCTL */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< AGL NCTL */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|byp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_drv_ctl_cn56xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_drv_ctl
name|cvmx_agl_gmx_drv_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_inf_mode  *  * AGL_GMX_INF_MODE = Interface Mode  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_inf_mode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_inf_mode_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Interface Enable */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_inf_mode_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_inf_mode_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_inf_mode_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_inf_mode_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_inf_mode
name|cvmx_agl_gmx_inf_mode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_prt#_cfg  *  * AGL_GMX_PRT_CFG = Port description  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_prtx_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_prtx_cfg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|tx_idle
range|:
literal|1
decl_stmt|;
comment|/**< TX Machine is idle */
name|uint64_t
name|rx_idle
range|:
literal|1
decl_stmt|;
comment|/**< RX Machine is idle */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|speed_msb
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed MSB [SPEED_MSB:SPEED]                                                          10 = 10Mbs operation                                                          00 = 100Mbs operation                                                          01 = 1000Mbs operation                                                          11 = Reserved */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|burst
range|:
literal|1
decl_stmt|;
comment|/**< Half-Duplex Burst Enable                                                          Only valid for 1000Mbs half-duplex operation                                                           0 = burst length of 0x2000 (halfdup / 1000Mbs)                                                           1 = burst length of 0x0    (all other modes) */
name|uint64_t
name|tx_en
range|:
literal|1
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to send                                                          RMGII traffic.   When this bit clear on a given                                                          port, then all packet cycles will appear as                                                          inter-frame cycles. */
name|uint64_t
name|rx_en
range|:
literal|1
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to receive                                                          RMGII traffic.  When this bit clear on a given                                                          port, then the all packet cycles will appear as                                                          inter-frame cycles. */
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
comment|/**< Slot Time for Half-Duplex operation                                                          0 = 512 bitimes (10/100Mbs operation)                                                          1 = 4096 bitimes (1000Mbs operation) */
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< Duplex                                                          0 = Half Duplex (collisions/extentions/bursts)                                                          1 = Full Duplex */
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed LSB [SPEED_MSB:SPEED]                                                          10 = 10Mbs operation                                                          00 = 100Mbs operation                                                          01 = 1000Mbs operation                                                          11 = Reserved */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Link Enable                                                          When EN is clear, packets will not be received                                                          or transmitted (including PAUSE and JAM packets).                                                          If EN is cleared while a packet is currently                                                          being received or transmitted, the packet will                                                          be allowed to complete before the bus is idled.                                                          On the RX side, subsequent packets in a burst                                                          will be ignored. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|burst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed_msb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rx_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_idle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_prtx_cfg_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|tx_en
range|:
literal|1
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to send                                                          RMGII traffic.   When this bit clear on a given                                                          port, then all MII cycles will appear as                                                          inter-frame cycles. */
name|uint64_t
name|rx_en
range|:
literal|1
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to receive                                                          RMGII traffic.  When this bit clear on a given                                                          port, then the all MII cycles will appear as                                                          inter-frame cycles. */
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
comment|/**< Slot Time for Half-Duplex operation                                                          0 = 512 bitimes (10/100Mbs operation)                                                          1 = Reserved */
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< Duplex                                                          0 = Half Duplex (collisions/extentions/bursts)                                                          1 = Full Duplex */
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
comment|/**< Link Speed                                                          0 = 10/100Mbs operation                                                          1 = Reserved */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Link Enable                                                          When EN is clear, packets will not be received                                                          or transmitted (including PAUSE and JAM packets).                                                          If EN is cleared while a packet is currently                                                          being received or transmitted, the packet will                                                          be allowed to complete before the bus is idled.                                                          On the RX side, subsequent packets in a burst                                                          will be ignored. */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|1
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slottime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_prtx_cfg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_prtx_cfg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_prtx_cfg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_prtx_cfg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_prtx_cfg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_prtx_cfg
name|cvmx_agl_gmx_prtx_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam0  *  * AGL_GMX_RX_ADR_CAM = Address Filtering Control  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                          Each entry contributes 8bits to one of 8 matchers                                                          Write transactions to AGL_GMX_RX_ADR_CAM will not                                                          change the CSR when AGL_GMX_PRT_CFG[EN] is enabled                                                          The CAM matches against unicst or multicst DMAC                                                          addresses. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam0
name|cvmx_agl_gmx_rxx_adr_cam0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam1  *  * AGL_GMX_RX_ADR_CAM = Address Filtering Control  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                          Each entry contributes 8bits to one of 8 matchers                                                          Write transactions to AGL_GMX_RX_ADR_CAM will not                                                          change the CSR when AGL_GMX_PRT_CFG[EN] is enabled                                                          The CAM matches against unicst or multicst DMAC                                                          addresses. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam1
name|cvmx_agl_gmx_rxx_adr_cam1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam2  *  * AGL_GMX_RX_ADR_CAM = Address Filtering Control  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                          Each entry contributes 8bits to one of 8 matchers                                                          Write transactions to AGL_GMX_RX_ADR_CAM will not                                                          change the CSR when AGL_GMX_PRT_CFG[EN] is enabled                                                          The CAM matches against unicst or multicst DMAC                                                          addresses. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam2
name|cvmx_agl_gmx_rxx_adr_cam2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam3  *  * AGL_GMX_RX_ADR_CAM = Address Filtering Control  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                          Each entry contributes 8bits to one of 8 matchers                                                          Write transactions to AGL_GMX_RX_ADR_CAM will not                                                          change the CSR when AGL_GMX_PRT_CFG[EN] is enabled                                                          The CAM matches against unicst or multicst DMAC                                                          addresses. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam3_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam3
name|cvmx_agl_gmx_rxx_adr_cam3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam4  *  * AGL_GMX_RX_ADR_CAM = Address Filtering Control  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                          Each entry contributes 8bits to one of 8 matchers                                                          Write transactions to AGL_GMX_RX_ADR_CAM will not                                                          change the CSR when AGL_GMX_PRT_CFG[EN] is enabled                                                          The CAM matches against unicst or multicst DMAC                                                          addresses. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam4_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam4
name|cvmx_agl_gmx_rxx_adr_cam4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam5  *  * AGL_GMX_RX_ADR_CAM = Address Filtering Control  *  *  * Notes:  * Not reset when MIX*_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
comment|/**< The DMAC address to match on                                                          Each entry contributes 8bits to one of 8 matchers                                                          Write transactions to AGL_GMX_RX_ADR_CAM will not                                                          change the CSR when AGL_GMX_PRT_CFG[EN] is enabled                                                          The CAM matches against unicst or multicst DMAC                                                          addresses. */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam5_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam5
name|cvmx_agl_gmx_rxx_adr_cam5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_cam_en  *  * AGL_GMX_RX_ADR_CAM_EN = Address Filtering Control Enable  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_cam_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
comment|/**< CAM Entry Enables */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_cam_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_cam_en
name|cvmx_agl_gmx_rxx_adr_cam_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_adr_ctl  *  * AGL_GMX_RX_ADR_CTL = Address Filtering Control  *  *  * Notes:  * * ALGORITHM  *   Here is some pseudo code that represents the address filter behavior.  *  *      @verbatim  *      bool dmac_addr_filter(uint8 prt, uint48 dmac) [  *        ASSERT(prt>= 0&& prt<= 3);  *        if (is_bcst(dmac))                               // broadcast accept  *          return (AGL_GMX_RX[prt]_ADR_CTL[BCST] ? ACCEPT : REJECT);  *        if (is_mcst(dmac)& AGL_GMX_RX[prt]_ADR_CTL[MCST] == 1)   // multicast reject  *          return REJECT;  *        if (is_mcst(dmac)& AGL_GMX_RX[prt]_ADR_CTL[MCST] == 2)   // multicast accept  *          return ACCEPT;  *  *        cam_hit = 0;  *  *        for (i=0; i<8; i++) [  *          if (AGL_GMX_RX[prt]_ADR_CAM_EN[EN<i>] == 0)  *            continue;  *          uint48 unswizzled_mac_adr = 0x0;  *          for (j=5; j>=0; j--) [  *             unswizzled_mac_adr = (unswizzled_mac_adr<< 8) | AGL_GMX_RX[prt]_ADR_CAM[j][ADR<i*8+7:i*8>];  *          ]  *          if (unswizzled_mac_adr == dmac) [  *            cam_hit = 1;  *            break;  *          ]  *        ]  *  *        if (cam_hit)  *          return (AGL_GMX_RX[prt]_ADR_CTL[CAM_MODE] ? ACCEPT : REJECT);  *        else  *          return (AGL_GMX_RX[prt]_ADR_CTL[CAM_MODE] ? REJECT : ACCEPT);  *      ]  *      @endverbatim  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_adr_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|cam_mode
range|:
literal|1
decl_stmt|;
comment|/**< Allow or deny DMAC address filter                                                          0 = reject the packet on DMAC address match                                                          1 = accept the packet on DMAC address match */
name|uint64_t
name|mcst
range|:
literal|2
decl_stmt|;
comment|/**< Multicast Mode                                                          0 = Use the Address Filter CAM                                                          1 = Force reject all multicast packets                                                          2 = Force accept all multicast packets                                                          3 = Reserved */
name|uint64_t
name|bcst
range|:
literal|1
decl_stmt|;
comment|/**< Accept All Broadcast Packets */
else|#
directive|else
name|uint64_t
name|bcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mcst
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cam_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_adr_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_adr_ctl
name|cvmx_agl_gmx_rxx_adr_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_decision  *  * AGL_GMX_RX_DECISION = The byte count to decide when to accept or filter a packet  *  *  * Notes:  * As each byte in a packet is received by GMX, the L2 byte count is compared  * against the AGL_GMX_RX_DECISION[CNT].  The L2 byte count is the number of bytes  * from the beginning of the L2 header (DMAC).  In normal operation, the L2  * header begins after the PREAMBLE+SFD (AGL_GMX_RX_FRM_CTL[PRE_CHK]=1) and any  * optional UDD skip data (AGL_GMX_RX_UDD_SKP[LEN]).  *  * When AGL_GMX_RX_FRM_CTL[PRE_CHK] is clear, PREAMBLE+SFD are prepended to the  * packet and would require UDD skip length to account for them.  *  *                                                 L2 Size  * Port Mode<=AGL_GMX_RX_DECISION bytes (default=24)>AGL_GMX_RX_DECISION bytes (default=24)  *  * MII/Full Duplex       accept packet                             apply filters  *                       no filtering is applied                   accept packet based on DMAC and PAUSE packet filters  *  * MII/Half Duplex       drop packet                               apply filters  *                       packet is unconditionally dropped         accept packet based on DMAC  *  * where l2_size = MAX(0, total_packet_size - AGL_GMX_RX_UDD_SKP[LEN] - ((AGL_GMX_RX_FRM_CTL[PRE_CHK]==1)*8)  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_decision
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_decision_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|5
decl_stmt|;
comment|/**< The byte count to decide when to accept or filter                                                          a packet. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_decision_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_decision_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_decision_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_decision_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_decision_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_decision_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_decision
name|cvmx_agl_gmx_rxx_decision_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_frm_chk  *  * AGL_GMX_RX_FRM_CHK = Which frame errors will set the ERR bit of the frame  *  *  * Notes:  * If AGL_GMX_RX_UDD_SKP[LEN] != 0, then LENERR will be forced to zero in HW.  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_frm_chk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_frm_chk_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with packet data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_rxx_frm_chk_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with MII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_rxx_frm_chk_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_chk_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_chk_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_chk_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_chk_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_frm_chk
name|cvmx_agl_gmx_rxx_frm_chk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_frm_ctl  *  * AGL_GMX_RX_FRM_CTL = Frame Control  *  *  * Notes:  * * PRE_STRP  *   When PRE_CHK is set (indicating that the PREAMBLE will be sent), PRE_STRP  *   determines if the PREAMBLE+SFD bytes are thrown away or sent to the Octane  *   core as part of the packet.  *  *   In either mode, the PREAMBLE+SFD bytes are not counted toward the packet  *   size when checking against the MIN and MAX bounds.  Furthermore, the bytes  *   are skipped when locating the start of the L2 header for DMAC and Control  *   frame recognition.  *  * * CTL_BCK/CTL_DRP  *   These bits control how the HW handles incoming PAUSE packets.  Here are  *   the most common modes of operation:  *     CTL_BCK=1,CTL_DRP=1   - HW does it all  *     CTL_BCK=0,CTL_DRP=0   - SW sees all pause frames  *     CTL_BCK=0,CTL_DRP=1   - all pause frames are completely ignored  *  *   These control bits should be set to CTL_BCK=0,CTL_DRP=0 in halfdup mode.  *   Since PAUSE packets only apply to fulldup operation, any PAUSE packet  *   would constitute an exception which should be handled by the processing  *   cores.  PAUSE packets should not be forwarded.  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_frm_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_frm_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|ptp_mode
range|:
literal|1
decl_stmt|;
comment|/**< Timestamp mode                                                          When PTP_MODE is set, a 64-bit timestamp will be                                                          prepended to every incoming packet. The timestamp                                                          bytes are added to the packet in such a way as to                                                          not modify the packet's receive byte count.  This                                                          implies that the AGL_GMX_RX_JABBER,                                                          AGL_GMX_RX_FRM_MIN, AGL_GMX_RX_FRM_MAX,                                                          AGL_GMX_RX_DECISION, AGL_GMX_RX_UDD_SKP, and the                                                          AGL_GMX_RX_STATS_* do not require any adjustment                                                          as they operate on the received packet size.                                                          If PTP_MODE=1 and PRE_CHK=1, PRE_STRP must be 1. */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
comment|/**< When set, do not modify the MOD bits on NULL ticks                                                          due to PARITAL packets */
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PRE_STRP should be set to                                                          account for the variable nature of the PREAMBLE.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for non-min                                                          sized pkts with padding in the client data */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE checking is less strict.                                                          AGL will begin the frame at the first SFD.                                                          PRE_FREE must be set if PRE_ALIGN is set.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped                                                          PRE_STRP must be set if PRE_ALIGN is set.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send a valid 802.3                                                          PREAMBLE to begin every frame. AGL checks that a                                                          valid PREAMBLE is received (based on PRE_FREE).                                                          When a problem does occur within the PREAMBLE                                                          seqeunce, the frame is marked as bad and not sent                                                          into the core.  The AGL_GMX_RX_INT_REG[PCTERR]                                                          interrupt is also raised. */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|null_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptp_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_rxx_frm_ctl_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE parser aligns the the SFD byte                                                          regardless of the number of previous PREAMBLE                                                          nibbles.  In this mode, PREAMBLE can be consumed                                                          by the HW so when PRE_ALIGN is set, PRE_FREE,                                                          PRE_STRP must be set for correct operation.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for non-min                                                          sized pkts with padding in the client data */
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the length check for VLAN pkts */
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
comment|/**< When set, PREAMBLE checking is  less strict.                                                          0 - 254 cycles of PREAMBLE followed by SFD                                                          PRE_FREE must be set if PRE_ALIGN is set.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match station SMAC */
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
comment|/**< Control Pause Frames can match globally assign                                                          Multicast address */
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
comment|/**< Forward pause information to TX block */
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
comment|/**< Drop Control Pause Frames */
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
comment|/**< Strip off the preamble (when present)                                                          0=PREAMBLE+SFD is sent to core as part of frame                                                          1=PREAMBLE+SFD is dropped                                                          PRE_STRP must be set if PRE_ALIGN is set.                                                          PRE_CHK must be set to enable this and all                                                          PREAMBLE features. */
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
comment|/**< This port is configured to send PREAMBLE+SFD                                                          to begin every frame.  GMX checks that the                                                          PREAMBLE is sent correctly */
else|#
directive|else
name|uint64_t
name|pre_chk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_strp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_bck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_mcst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctl_smac
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_free
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vlan_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad_len
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pre_align
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_rxx_frm_ctl_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_ctl_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_ctl_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_frm_ctl
name|cvmx_agl_gmx_rxx_frm_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_frm_max  *  * AGL_GMX_RX_FRM_MAX = Frame Max length  *  *  * Notes:  * When changing the LEN field, be sure that LEN does not exceed  * AGL_GMX_RX_JABBER[CNT]. Failure to meet this constraint will cause packets that  * are within the maximum length parameter to be rejected because they exceed  * the AGL_GMX_RX_JABBER[CNT] limit.  *  * Notes:  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_frm_max
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_frm_max_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for Max-sized frame check                                                          AGL_GMX_RXn_FRM_CHK[MAXERR] enables the check                                                          for port n.                                                          If enabled, failing packets set the MAXERR                                                          interrupt and the MIX opcode is set to OVER_FCS                                                          (0x3, if packet has bad FCS) or OVER_ERR (0x4, if                                                          packet has good FCS).                                                          LEN<= AGL_GMX_RX_JABBER[CNT] */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_frm_max_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_max_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_max_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_max_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_max_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_max_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_frm_max
name|cvmx_agl_gmx_rxx_frm_max_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_frm_min  *  * AGL_GMX_RX_FRM_MIN = Frame Min length  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_frm_min
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_frm_min_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for Min-sized frame check                                                          AGL_GMX_RXn_FRM_CHK[MINERR] enables the check                                                          for port n.                                                          If enabled, failing packets set the MINERR                                                          interrupt and the MIX opcode is set to UNDER_FCS                                                          (0x6, if packet has bad FCS) or UNDER_ERR (0x8,                                                          if packet has good FCS). */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_frm_min_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_min_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_min_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_min_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_min_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_frm_min_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_frm_min
name|cvmx_agl_gmx_rxx_frm_min_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_ifg  *  * AGL_GMX_RX_IFG = RX Min IFG  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_ifg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_ifg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|ifg
range|:
literal|4
decl_stmt|;
comment|/**< Min IFG (in IFG*8 bits) between packets used to                                                          determine IFGERR. Normally IFG is 96 bits.                                                          Note in some operating modes, IFG cycles can be                                                          inserted or removed in order to achieve clock rate                                                          adaptation. For these reasons, the default value                                                          is slightly conservative and does not check upto                                                          the full 96 bits of IFG. */
else|#
directive|else
name|uint64_t
name|ifg
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_ifg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_ifg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_ifg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_ifg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_ifg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_ifg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_ifg
name|cvmx_agl_gmx_rxx_ifg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_int_en  *  * AGL_GMX_RX_INT_EN = Interrupt Enable  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_int_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkDuplex             |             NS */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkSpeed              |             NS */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RMGII inbound LinkStatus             |             NS */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Packet reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble)              |             NS */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_rxx_int_en_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< MII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with RMGII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_rxx_int_en_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_en_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_en_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_int_en
name|cvmx_agl_gmx_rxx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_int_reg  *  * AGL_GMX_RX_INT_REG = Interrupt Register  *  *  * Notes:  * (1) exceptions will only be raised to the control processor if the  *     corresponding bit in the AGL_GMX_RX_INT_EN register is set.  *  * (2) exception conditions 10:0 can also set the rcv/opcode in the received  *     packet's workQ entry.  The AGL_GMX_RX_FRM_CHK register provides a bit mask  *     for configuring which conditions set the error.  *  * (3) in half duplex operation, the expectation is that collisions will appear  *     as MINERRs.  *  * (4) JABBER - An RX Jabber error indicates that a packet was received which  *              is longer than the maximum allowed packet as defined by the  *              system.  GMX will truncate the packet at the JABBER count.  *              Failure to do so could lead to system instabilty.  *  * (6) MAXERR - for untagged frames, the total frame DA+SA+TL+DATA+PAD+FCS>  *              AGL_GMX_RX_FRM_MAX.  For tagged frames, DA+SA+VLAN+TL+DATA+PAD+FCS  *> AGL_GMX_RX_FRM_MAX + 4*VLAN_VAL + 4*VLAN_STACKED.  *  * (7) MINERR - total frame DA+SA+TL+DATA+PAD+FCS< AGL_GMX_RX_FRM_MIN.  *  * (8) ALNERR - Indicates that the packet received was not an integer number of  *              bytes.  If FCS checking is enabled, ALNERR will only assert if  *              the FCS is bad.  If FCS checking is disabled, ALNERR will  *              assert in all non-integer frame cases.  *  * (9) Collisions - Collisions can only occur in half-duplex mode.  A collision  *                  is assumed by the receiver when the received  *                  frame< AGL_GMX_RX_FRM_MIN - this is normally a MINERR  *  * (A) LENERR - Length errors occur when the received packet does not match the  *              length field.  LENERR is only checked for packets between 64  *              and 1500 bytes.  For untagged frames, the length must exact  *              match.  For tagged frames the length or length+4 must match.  *  * (B) PCTERR - checks that the frame begins with a valid PREAMBLE sequence.  *              Does not check the number of PREAMBLE cycles.  *  * (C) OVRERR - Not to be included in the HRM  *  *              OVRERR is an architectural assertion check internal to GMX to  *              make sure no assumption was violated.  In a correctly operating  *              system, this interrupt can never fire.  *  *              GMX has an internal arbiter which selects which of 4 ports to  *              buffer in the main RX FIFO.  If we normally buffer 8 bytes,  *              then each port will typically push a tick every 8 cycles - if  *              the packet interface is going as fast as possible.  If there  *              are four ports, they push every two cycles.  So that's the  *              assumption.  That the inbound module will always be able to  *              consume the tick before another is produced.  If that doesn't  *              happen - that's when OVRERR will assert.  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_int_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RGMII inbound LinkDuplex             |             NS */
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RGMII inbound LinkSpeed              |             NS */
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
comment|/**< Change in the RGMII inbound LinkStatus             |             NS */
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< Packet reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert */
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
comment|/**< Nibble error (hi_nibble != lo_nibble)              |             NS */
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with Packet Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
comment|/**< Carrier extend error */
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|carext
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|niberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_spd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|phy_dupx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_rxx_int_reg_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
comment|/**< Pause packet was dropped due to full GMX RX FIFO */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
comment|/**< Interframe Gap Violation                                                          Does not necessarily indicate a failure */
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
comment|/**< Collision Detection */
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
comment|/**< False carrier error or extend error after slottime */
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
comment|/**< MII reserved opcodes */
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
comment|/**< Bad Preamble / Protocol */
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
comment|/**< Internal Data Aggregation Overflow                                                          This interrupt should never assert */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
comment|/**< Skipper error */
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with MII Data reception error */
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length error */
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with an alignment error */
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with FCS/CRC error */
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> sys_length */
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length> max_length */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
comment|/**< Frame was received with length< min_length */
else|#
directive|else
name|uint64_t
name|minerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jabber
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcserr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alnerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lenerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skperr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcterr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsverr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|falerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|coldet
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ifgerr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pause_drp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_rxx_int_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_int_reg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_int_reg
name|cvmx_agl_gmx_rxx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_jabber  *  * AGL_GMX_RX_JABBER = The max size packet after which GMX will truncate  *  *  * Notes:  * CNT must be 8-byte aligned such that CNT[2:0] == 0  *  *   The packet that will be sent to the packet input logic will have an  *   additionl 8 bytes if AGL_GMX_RX_FRM_CTL[PRE_CHK] is set and  *   AGL_GMX_RX_FRM_CTL[PRE_STRP] is clear.  The max packet that will be sent is  *   defined as...  *  *        max_sized_packet = AGL_GMX_RX_JABBER[CNT]+((AGL_GMX_RX_FRM_CTL[PRE_CHK]& !AGL_GMX_RX_FRM_CTL[PRE_STRP])*8)  *  *   Be sure the CNT field value is at least as large as the  *   AGL_GMX_RX_FRM_MAX[LEN] value. Failure to meet this constraint will cause  *   packets that are within the AGL_GMX_RX_FRM_MAX[LEN] length to be rejected  *   because they exceed the CNT limit.  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_jabber
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_jabber_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for jabber check                                                          Failing packets set the JABBER interrupt and are                                                          optionally sent with opcode==JABBER                                                          GMX will truncate the packet to CNT bytes                                                          CNT>= AGL_GMX_RX_FRM_MAX[LEN] */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_jabber_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_jabber_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_jabber_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_jabber_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_jabber_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_jabber_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_jabber
name|cvmx_agl_gmx_rxx_jabber_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_pause_drop_time  *  * AGL_GMX_RX_PAUSE_DROP_TIME = The TIME field in a PAUSE Packet which was dropped due to GMX RX FIFO full condition  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_pause_drop_time
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|status
range|:
literal|16
decl_stmt|;
comment|/**< Time extracted from the dropped PAUSE packet */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_pause_drop_time_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_pause_drop_time
name|cvmx_agl_gmx_rxx_pause_drop_time_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_rx_inbnd  *  * AGL_GMX_RX_INBND = RGMII InBand Link Status  *  *  * Notes:  * These fields are only valid if the attached PHY is operating in RGMII mode  * and supports the optional in-band status (see section 3.4.1 of the RGMII  * specification, version 1.3 for more information).  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_rx_inbnd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_rx_inbnd_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
comment|/**< RGMII Inbound LinkDuplex                           |             NS                                                          0=half-duplex                                                          1=full-duplex */
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
comment|/**< RGMII Inbound LinkSpeed                            |             NS                                                          00=2.5MHz                                                          01=25MHz                                                          10=125MHz                                                          11=Reserved */
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
comment|/**< RGMII Inbound LinkStatus                           |             NS                                                          0=down                                                          1=up */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
name|uint64_t
name|speed
range|:
literal|2
decl_stmt|;
name|uint64_t
name|duplex
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_rx_inbnd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_rx_inbnd_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_rx_inbnd
name|cvmx_agl_gmx_rxx_rx_inbnd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_ctl  *  * AGL_GMX_RX_STATS_CTL = RX Stats Control register  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
comment|/**< RX Stats registers will clear on reads */
else|#
directive|else
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_ctl
name|cvmx_agl_gmx_rxx_stats_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_octs  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_octs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of received good packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_octs
name|cvmx_agl_gmx_rxx_stats_octs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_octs_ctl  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_octs_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of received pause packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_octs_ctl
name|cvmx_agl_gmx_rxx_stats_octs_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_octs_dmac  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_octs_dmac
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of filtered dmac packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_dmac_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_octs_dmac
name|cvmx_agl_gmx_rxx_stats_octs_dmac_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_octs_drp  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_octs_drp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
comment|/**< Octet count of dropped packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_octs_drp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_octs_drp
name|cvmx_agl_gmx_rxx_stats_octs_drp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_pkts  *  * AGL_GMX_RX_STATS_PKTS  *  * Count of good received packets - packets that are not recognized as PAUSE  * packets, dropped due the DMAC filter, dropped due FIFO full status, or  * have any other OPCODE (FCS, Length, etc).  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_pkts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of received good packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_pkts
name|cvmx_agl_gmx_rxx_stats_pkts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_pkts_bad  *  * AGL_GMX_RX_STATS_PKTS_BAD  *  * Count of all packets received with some error that were not dropped  * either due to the dmac filter or lack of room in the receive FIFO.  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_pkts_bad
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of bad packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_bad_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_pkts_bad
name|cvmx_agl_gmx_rxx_stats_pkts_bad_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_pkts_ctl  *  * AGL_GMX_RX_STATS_PKTS_CTL  *  * Count of all packets received that were recognized as Flow Control or  * PAUSE packets.  PAUSE packets with any kind of error are counted in  * AGL_GMX_RX_STATS_PKTS_BAD.  Pause packets can be optionally dropped or  * forwarded based on the AGL_GMX_RX_FRM_CTL[CTL_DRP] bit.  This count  * increments regardless of whether the packet is dropped.  Pause packets  * will never be counted in AGL_GMX_RX_STATS_PKTS.  Packets dropped due the dmac  * filter will be counted in AGL_GMX_RX_STATS_PKTS_DMAC and not here.  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_pkts_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of received pause packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_pkts_ctl
name|cvmx_agl_gmx_rxx_stats_pkts_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_pkts_dmac  *  * AGL_GMX_RX_STATS_PKTS_DMAC  *  * Count of all packets received that were dropped by the dmac filter.  * Packets that match the DMAC will be dropped and counted here regardless  * of if they were bad packets.  These packets will never be counted in  * AGL_GMX_RX_STATS_PKTS.  *  * Some packets that were not able to satisify the DECISION_CNT may not  * actually be dropped by Octeon, but they will be counted here as if they  * were dropped.  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_pkts_dmac
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of filtered dmac packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_pkts_dmac
name|cvmx_agl_gmx_rxx_stats_pkts_dmac_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_stats_pkts_drp  *  * AGL_GMX_RX_STATS_PKTS_DRP  *  * Count of all packets received that were dropped due to a full receive  * FIFO.  This counts good and bad packets received - all packets dropped by  * the FIFO.  It does not count packets dropped by the dmac or pause packet  * filters.  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_RX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_stats_pkts_drp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
comment|/**< Count of dropped packets */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_stats_pkts_drp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_stats_pkts_drp
name|cvmx_agl_gmx_rxx_stats_pkts_drp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx#_udd_skp  *  * AGL_GMX_RX_UDD_SKP = Amount of User-defined data before the start of the L2 data  *  *  * Notes:  * (1) The skip bytes are part of the packet and will be sent down the NCB  *     packet interface and will be handled by PKI.  *  * (2) The system can determine if the UDD bytes are included in the FCS check  *     by using the FCSSEL field - if the FCS check is enabled.  *  * (3) Assume that the preamble/sfd is always at the start of the frame - even  *     before UDD bytes.  In most cases, there will be no preamble in these  *     cases since it will be MII to MII communication without a PHY  *     involved.  *  * (4) We can still do address filtering and control packet filtering is the  *     user desires.  *  * (5) UDD_SKP must be 0 in half-duplex operation unless  *     AGL_GMX_RX_FRM_CTL[PRE_CHK] is clear.  If AGL_GMX_RX_FRM_CTL[PRE_CHK] is set,  *     then UDD_SKP will normally be 8.  *  * (6) In all cases, the UDD bytes will be sent down the packet interface as  *     part of the packet.  The UDD bytes are never stripped from the actual  *     packet.  *  * (7) If LEN != 0, then AGL_GMX_RX_FRM_CHK[LENERR] will be disabled and AGL_GMX_RX_INT_REG[LENERR] will be zero  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rxx_udd_skp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|fcssel
range|:
literal|1
decl_stmt|;
comment|/**< Include the skip bytes in the FCS calculation                                                          0 = all skip bytes are included in FCS                                                          1 = the skip bytes are not included in FCS */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
comment|/**< Amount of User-defined data before the start of                                                          the L2 data.  Zero means L2 comes first.                                                          Max value is 64. */
else|#
directive|else
name|uint64_t
name|len
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcssel
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rxx_udd_skp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rxx_udd_skp
name|cvmx_agl_gmx_rxx_udd_skp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx_bp_drop#  *  * AGL_GMX_RX_BP_DROP = FIFO mark for packet drop  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rx_bp_dropx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
comment|/**< Number of 8B ticks to reserve in the RX FIFO.                                                          When the FIFO exceeds this count, packets will                                                          be dropped and not buffered.                                                          MARK should typically be programmed to 2.                                                          Failure to program correctly can lead to system                                                          instability. */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_dropx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rx_bp_dropx
name|cvmx_agl_gmx_rx_bp_dropx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx_bp_off#  *  * AGL_GMX_RX_BP_OFF = Lowater mark for packet drop  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rx_bp_offx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_bp_offx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
comment|/**< Water mark (8B ticks) to deassert backpressure */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rx_bp_offx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_offx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_offx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_offx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_offx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_offx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rx_bp_offx
name|cvmx_agl_gmx_rx_bp_offx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx_bp_on#  *  * AGL_GMX_RX_BP_ON = Hiwater mark for port/interface backpressure  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rx_bp_onx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_bp_onx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|9
decl_stmt|;
comment|/**< Hiwater mark (8B ticks) for backpressure. */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rx_bp_onx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_onx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_onx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_onx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_onx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_bp_onx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rx_bp_onx
name|cvmx_agl_gmx_rx_bp_onx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx_prt_info  *  * AGL_GMX_RX_PRT_INFO = state information for the ports  *  *  * Notes:  * COMMIT[0], DROP[0] will be reset when MIX0_CTL[RESET] is set to 1.  * COMMIT[1], DROP[1] will be reset when MIX1_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rx_prt_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_prt_info_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|2
decl_stmt|;
comment|/**< Port indication that data was dropped */
name|uint64_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint64_t
name|commit
range|:
literal|2
decl_stmt|;
comment|/**< Port indication that SOP was accepted */
else|#
directive|else
name|uint64_t
name|commit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rx_prt_info_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_prt_info_s
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_prt_info_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|1
decl_stmt|;
comment|/**< Port indication that data was dropped */
name|uint64_t
name|reserved_1_15
range|:
literal|15
decl_stmt|;
name|uint64_t
name|commit
range|:
literal|1
decl_stmt|;
comment|/**< Port indication that SOP was accepted */
else|#
directive|else
name|uint64_t
name|commit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_15
range|:
literal|15
decl_stmt|;
name|uint64_t
name|drop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_rx_prt_info_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_prt_info_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_prt_info_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rx_prt_info
name|cvmx_agl_gmx_rx_prt_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_rx_tx_status  *  * AGL_GMX_RX_TX_STATUS = GMX RX/TX Status  *  *  * Notes:  * RX[0], TX[0] will be reset when MIX0_CTL[RESET] is set to 1.  * RX[1], TX[1] will be reset when MIX1_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_rx_tx_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_tx_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|tx
range|:
literal|2
decl_stmt|;
comment|/**< Transmit data since last read */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx
range|:
literal|2
decl_stmt|;
comment|/**< Receive data since last read */
else|#
directive|else
name|uint64_t
name|rx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|tx
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_rx_tx_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_tx_status_s
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_rx_tx_status_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|tx
range|:
literal|1
decl_stmt|;
comment|/**< Transmit data since last read */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rx
range|:
literal|1
decl_stmt|;
comment|/**< Receive data since last read */
else|#
directive|else
name|uint64_t
name|rx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_rx_tx_status_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_tx_status_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_rx_tx_status_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_rx_tx_status
name|cvmx_agl_gmx_rx_tx_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_smac#  *  * AGL_GMX_SMAC = Packet SMAC  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_smacx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_smacx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|smac
range|:
literal|48
decl_stmt|;
comment|/**< The SMAC field is used for generating and                                                          accepting Control Pause packets */
else|#
directive|else
name|uint64_t
name|smac
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_smacx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_smacx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_smacx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_smacx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_smacx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_smacx_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_smacx
name|cvmx_agl_gmx_smacx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_stat_bp  *  * AGL_GMX_STAT_BP = Number of cycles that the TX/Stats block has help up operation  *  *  * Notes:  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_stat_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_stat_bp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
comment|/**< Current BP state */
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of cycles that BP has been asserted                                                          Saturating counter */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_stat_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_stat_bp_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_stat_bp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_stat_bp_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_stat_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_stat_bp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_stat_bp
name|cvmx_agl_gmx_stat_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_append  *  * AGL_GMX_TX_APPEND = Packet TX Append Control  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_append
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_append_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|force_fcs
range|:
literal|1
decl_stmt|;
comment|/**< Append the Ethernet FCS on each pause packet                                                          when FCS is clear.  Pause packets are normally                                                          padded to 60 bytes.  If                                                          AGL_GMX_TX_MIN_PKT[MIN_SIZE] exceeds 59, then                                                          FORCE_FCS will not be used. */
name|uint64_t
name|fcs
range|:
literal|1
decl_stmt|;
comment|/**< Append the Ethernet FCS on each packet */
name|uint64_t
name|pad
range|:
literal|1
decl_stmt|;
comment|/**< Append PAD bytes such that min sized */
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
comment|/**< Prepend the Ethernet preamble on each transfer */
else|#
directive|else
name|uint64_t
name|preamble
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|force_fcs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_append_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_append_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_append_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_append_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_append_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_append_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_append
name|cvmx_agl_gmx_txx_append_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_clk  *  * AGL_GMX_TX_CLK = RGMII TX Clock Generation Register  *  *  * Notes:  * Normal Programming Values:  *  (1) RGMII, 1000Mbs   (AGL_GMX_PRT_CFG[SPEED]==1), CLK_CNT == 1  *  (2) RGMII, 10/100Mbs (AGL_GMX_PRT_CFG[SPEED]==0), CLK_CNT == 50/5  *  (3) MII,   10/100Mbs (AGL_GMX_PRT_CFG[SPEED]==0), CLK_CNT == 1  *  * RGMII Example:  *  Given a 125MHz PLL reference clock...  *   CLK_CNT ==  1 ==> 125.0MHz TXC clock period (8ns* 1)  *   CLK_CNT ==  5 ==>  25.0MHz TXC clock period (8ns* 5)  *   CLK_CNT == 50 ==>   2.5MHz TXC clock period (8ns*50)  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_clk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_clk_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|clk_cnt
range|:
literal|6
decl_stmt|;
comment|/**< Controls the RGMII TXC frequency                   |             NS                                                          TXC(period) =                                                           rgm_ref_clk(period)*CLK_CNT */
else|#
directive|else
name|uint64_t
name|clk_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_clk_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_clk_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_clk
name|cvmx_agl_gmx_txx_clk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_ctl  *  * AGL_GMX_TX_CTL = TX Control register  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|xsdef_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables the excessive deferral check for stats                                                          and interrupts */
name|uint64_t
name|xscol_en
range|:
literal|1
decl_stmt|;
comment|/**< Enables the excessive collision check for stats                                                          and interrupts */
else|#
directive|else
name|uint64_t
name|xscol_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xsdef_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_ctl
name|cvmx_agl_gmx_txx_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_min_pkt  *  * AGL_GMX_TX_MIN_PKT = Packet TX Min Size Packet (PAD upto min size)  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_min_pkt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_min_pkt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|min_size
range|:
literal|8
decl_stmt|;
comment|/**< Min frame in bytes before the FCS is applied                                                          Padding is only appened when                                                          AGL_GMX_TX_APPEND[PAD] for the coresponding packet                                                          port is set. Packets will be padded to                                                          MIN_SIZE+1 The reset value will pad to 60 bytes. */
else|#
directive|else
name|uint64_t
name|min_size
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_min_pkt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_min_pkt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_min_pkt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_min_pkt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_min_pkt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_min_pkt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_min_pkt
name|cvmx_agl_gmx_txx_min_pkt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_pause_pkt_interval  *  * AGL_GMX_TX_PAUSE_PKT_INTERVAL = Packet TX Pause Packet transmission interval - how often PAUSE packets will be sent  *  *  * Notes:  * Choosing proper values of AGL_GMX_TX_PAUSE_PKT_TIME[TIME] and  * AGL_GMX_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system  * designer.  It is suggested that TIME be much greater than INTERVAL and  * AGL_GMX_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE  * count and then when the backpressure condition is lifted, a PAUSE packet  * with TIME==0 will be sent indicating that Octane is ready for additional  * data.  *  * If the system chooses to not set AGL_GMX_TX_PAUSE_ZERO[SEND], then it is  * suggested that TIME and INTERVAL are programmed such that they satisify the  * following rule...  *  *    INTERVAL<= TIME - (largest_pkt_size + IFG + pause_pkt_size)  *  * where largest_pkt_size is that largest packet that the system can send  * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size  * of the PAUSE packet (normally 64B).  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_pause_pkt_interval
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|interval
range|:
literal|16
decl_stmt|;
comment|/**< Arbitrate for a pause packet every (INTERVAL*512)                                                          bit-times.                                                          Normally, 0< INTERVAL< AGL_GMX_TX_PAUSE_PKT_TIME                                                          INTERVAL=0, will only send a single PAUSE packet                                                          for each backpressure event */
else|#
directive|else
name|uint64_t
name|interval
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_interval_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_pause_pkt_interval
name|cvmx_agl_gmx_txx_pause_pkt_interval_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_pause_pkt_time  *  * AGL_GMX_TX_PAUSE_PKT_TIME = Packet TX Pause Packet pause_time field  *  *  * Notes:  * Choosing proper values of AGL_GMX_TX_PAUSE_PKT_TIME[TIME] and  * AGL_GMX_TX_PAUSE_PKT_INTERVAL[INTERVAL] can be challenging to the system  * designer.  It is suggested that TIME be much greater than INTERVAL and  * AGL_GMX_TX_PAUSE_ZERO[SEND] be set.  This allows a periodic refresh of the PAUSE  * count and then when the backpressure condition is lifted, a PAUSE packet  * with TIME==0 will be sent indicating that Octane is ready for additional  * data.  *  * If the system chooses to not set AGL_GMX_TX_PAUSE_ZERO[SEND], then it is  * suggested that TIME and INTERVAL are programmed such that they satisify the  * following rule...  *  *    INTERVAL<= TIME - (largest_pkt_size + IFG + pause_pkt_size)  *  * where largest_pkt_size is that largest packet that the system can send  * (normally 1518B), IFG is the interframe gap and pause_pkt_size is the size  * of the PAUSE packet (normally 64B).  *  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_pause_pkt_time
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< The pause_time field placed is outbnd pause pkts                                                          pause_time is in 512 bit-times                                                          Normally, TIME> AGL_GMX_TX_PAUSE_PKT_INTERVAL */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_pkt_time_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_pause_pkt_time
name|cvmx_agl_gmx_txx_pause_pkt_time_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_pause_togo  *  * AGL_GMX_TX_PAUSE_TOGO = Packet TX Amount of time remaining to backpressure  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_pause_togo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_pause_togo_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< Amount of time remaining to backpressure */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_pause_togo_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_togo_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_togo_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_togo_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_togo_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_togo_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_pause_togo
name|cvmx_agl_gmx_txx_pause_togo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_pause_zero  *  * AGL_GMX_TX_PAUSE_ZERO = Packet TX Amount of time remaining to backpressure  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_pause_zero
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_pause_zero_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|send
range|:
literal|1
decl_stmt|;
comment|/**< When backpressure condition clear, send PAUSE                                                          packet with pause_time of zero to enable the                                                          channel */
else|#
directive|else
name|uint64_t
name|send
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_pause_zero_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_zero_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_zero_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_zero_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_zero_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_pause_zero_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_pause_zero
name|cvmx_agl_gmx_txx_pause_zero_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_soft_pause  *  * AGL_GMX_TX_SOFT_PAUSE = Packet TX Software Pause  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_soft_pause
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_soft_pause_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
comment|/**< Back off the TX bus for (TIME*512) bit-times                                                          for full-duplex operation only */
else|#
directive|else
name|uint64_t
name|time
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_soft_pause_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_soft_pause_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_soft_pause_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_soft_pause_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_soft_pause_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_soft_pause_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_soft_pause
name|cvmx_agl_gmx_txx_soft_pause_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat0  *  * AGL_GMX_TX_STAT0 = AGL_GMX_TX_STATS_XSDEF / AGL_GMX_TX_STATS_XSCOL  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat0_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|xsdef
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets dropped (never successfully                                                          sent) due to excessive deferal */
name|uint64_t
name|xscol
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets dropped (never successfully                                                          sent) due to excessive collision.  Defined by                                                          AGL_GMX_TX_COL_ATTEMPT[LIMIT]. */
else|#
directive|else
name|uint64_t
name|xscol
range|:
literal|32
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat0_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat0
name|cvmx_agl_gmx_txx_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat1  *  * AGL_GMX_TX_STAT1 = AGL_GMX_TX_STATS_SCOL  / AGL_GMX_TX_STATS_MCOL  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat1_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|scol
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with a single collision */
name|uint64_t
name|mcol
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with multiple collisions                                                          but< AGL_GMX_TX_COL_ATTEMPT[LIMIT]. */
else|#
directive|else
name|uint64_t
name|mcol
range|:
literal|32
decl_stmt|;
name|uint64_t
name|scol
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat1_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat1
name|cvmx_agl_gmx_txx_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat2  *  * AGL_GMX_TX_STAT2 = AGL_GMX_TX_STATS_OCTS  *  *  * Notes:  * - Octect counts are the sum of all data transmitted on the wire including  *   packet data, pad bytes, fcs bytes, pause bytes, and jam bytes.  The octect  *   counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
comment|/**< Number of total octets sent on the interface.                                                          Does not count octets from frames that were                                                          truncated due to collisions in halfdup mode. */
else|#
directive|else
name|uint64_t
name|octs
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat2_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat2
name|cvmx_agl_gmx_txx_stat2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat3  *  * AGL_GMX_TX_STAT3 = AGL_GMX_TX_STATS_PKTS  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat3_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
comment|/**< Number of total frames sent on the interface.                                                          Does not count frames that were truncated due to                                                           collisions in halfdup mode. */
else|#
directive|else
name|uint64_t
name|pkts
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat3_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat3
name|cvmx_agl_gmx_txx_stat3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat4  *  * AGL_GMX_TX_STAT4 = AGL_GMX_TX_STATS_HIST1 (64) / AGL_GMX_TX_STATS_HIST0 (<64)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat4_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|hist1
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of 64. */
name|uint64_t
name|hist0
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count                                                          of< 64. */
else|#
directive|else
name|uint64_t
name|hist0
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist1
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat4_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat4_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat4_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat4
name|cvmx_agl_gmx_txx_stat4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat5  *  * AGL_GMX_TX_STAT5 = AGL_GMX_TX_STATS_HIST3 (128- 255) / AGL_GMX_TX_STATS_HIST2 (65- 127)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat5_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|hist3
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          128 - 255. */
name|uint64_t
name|hist2
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          65 - 127. */
else|#
directive|else
name|uint64_t
name|hist2
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist3
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat5_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat5_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat5_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat5_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat5_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat5_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat5
name|cvmx_agl_gmx_txx_stat5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat6  *  * AGL_GMX_TX_STAT6 = AGL_GMX_TX_STATS_HIST5 (512-1023) / AGL_GMX_TX_STATS_HIST4 (256-511)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat6_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|hist5
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          512 - 1023. */
name|uint64_t
name|hist4
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          256 - 511. */
else|#
directive|else
name|uint64_t
name|hist4
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist5
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat6_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat6_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat6_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat6_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat6_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat6_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat6
name|cvmx_agl_gmx_txx_stat6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat7  *  * AGL_GMX_TX_STAT7 = AGL_GMX_TX_STATS_HIST7 (1024-1518) / AGL_GMX_TX_STATS_HIST6 (>1518)  *  *  * Notes:  * - Packet length is the sum of all data transmitted on the wire for the given  *   packet including packet data, pad bytes, fcs bytes, pause bytes, and jam  *   bytes.  The octect counts do not include PREAMBLE byte or EXTEND cycles.  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat7_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|hist7
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count                                                          of> 1518. */
name|uint64_t
name|hist6
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent with an octet count of                                                          1024 - 1518. */
else|#
directive|else
name|uint64_t
name|hist6
range|:
literal|32
decl_stmt|;
name|uint64_t
name|hist7
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat7_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat7_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat7_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat7_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat7_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat7_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat7
name|cvmx_agl_gmx_txx_stat7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat8  *  * AGL_GMX_TX_STAT8 = AGL_GMX_TX_STATS_MCST  / AGL_GMX_TX_STATS_BCST  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Note, GMX determines if the packet is MCST or BCST from the DMAC of the  *   packet.  GMX assumes that the DMAC lies in the first 6 bytes of the packet  *   as per the 802.3 frame definition.  If the system requires additional data  *   before the L2 header, then the MCST and BCST counters may not reflect  *   reality and should be ignored by software.  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat8
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat8_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent to multicast DMAC.                                                          Does not include BCST packets. */
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
comment|/**< Number of packets sent to broadcast DMAC.                                                          Does not include MCST packets. */
else|#
directive|else
name|uint64_t
name|bcst
range|:
literal|32
decl_stmt|;
name|uint64_t
name|mcst
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat8_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat8_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat8_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat8_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat8_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat8_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat8
name|cvmx_agl_gmx_txx_stat8_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stat9  *  * AGL_GMX_TX_STAT9 = AGL_GMX_TX_STATS_UNDFLW / AGL_GMX_TX_STATS_CTL  *  *  * Notes:  * - Cleared either by a write (of any value) or a read when AGL_GMX_TX_STATS_CTL[RD_CLR] is set  * - Counters will wrap  * - Not reset when MIX*_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stat9
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stat9_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|undflw
range|:
literal|32
decl_stmt|;
comment|/**< Number of underflow packets */
name|uint64_t
name|ctl
range|:
literal|32
decl_stmt|;
comment|/**< Number of Control packets (PAUSE flow control)                                                          generated by GMX.  It does not include control                                                          packets forwarded or generated by the PP's. */
else|#
directive|else
name|uint64_t
name|ctl
range|:
literal|32
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stat9_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat9_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat9_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat9_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat9_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stat9_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stat9
name|cvmx_agl_gmx_txx_stat9_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_stats_ctl  *  * AGL_GMX_TX_STATS_CTL = TX Stats Control register  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_stats_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
comment|/**< Stats registers will clear on reads */
else|#
directive|else
name|uint64_t
name|rd_clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_stats_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_stats_ctl
name|cvmx_agl_gmx_txx_stats_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx#_thresh  *  * AGL_GMX_TX_THRESH = Packet TX Threshold  *  *  * Notes:  * Additionally reset when MIX<prt>_CTL[RESET] is set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_txx_thresh
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_txx_thresh_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|6
decl_stmt|;
comment|/**< Number of 16B ticks to accumulate in the TX FIFO                                                          before sending on the packet interface                                                          This register should be large enough to prevent                                                          underflow on the packet interface and must never                                                          be set below 4.  This register cannot exceed the                                                          the TX FIFO depth which is 128, 8B entries. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_txx_thresh_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_thresh_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_thresh_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_thresh_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_thresh_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_txx_thresh_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_txx_thresh
name|cvmx_agl_gmx_txx_thresh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_bp  *  * AGL_GMX_TX_BP = Packet TX BackPressure Register  *  *  * Notes:  * BP[0] will be reset when MIX0_CTL[RESET] is set to 1.  * BP[1] will be reset when MIX1_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_bp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
comment|/**< Port BackPressure status                                                          0=Port is available                                                          1=Port should be back pressured */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_bp_s
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_bp_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
comment|/**< Port BackPressure status                                                          0=Port is available                                                          1=Port should be back pressured */
else|#
directive|else
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_tx_bp_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_bp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_bp
name|cvmx_agl_gmx_tx_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_col_attempt  *  * AGL_GMX_TX_COL_ATTEMPT = Packet TX collision attempts before dropping frame  *  *  * Notes:  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_col_attempt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_col_attempt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|limit
range|:
literal|5
decl_stmt|;
comment|/**< Collision Attempts */
else|#
directive|else
name|uint64_t
name|limit
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_col_attempt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_col_attempt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_col_attempt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_col_attempt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_col_attempt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_col_attempt_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_col_attempt
name|cvmx_agl_gmx_tx_col_attempt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_ifg  *  * Common  *  *  * AGL_GMX_TX_IFG = Packet TX Interframe Gap  *  * Notes:  * Notes:  * * Programming IFG1 and IFG2.  *  *   For half-duplex systems that require IEEE 802.3 compatibility, IFG1 must  *   be in the range of 1-8, IFG2 must be in the range of 4-12, and the  *   IFG1+IFG2 sum must be 12.  *  *   For full-duplex systems that require IEEE 802.3 compatibility, IFG1 must  *   be in the range of 1-11, IFG2 must be in the range of 1-11, and the  *   IFG1+IFG2 sum must be 12.  *  *   For all other systems, IFG1 and IFG2 can be any value in the range of  *   1-15.  Allowing for a total possible IFG sum of 2-30.  *  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_ifg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_ifg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ifg2
range|:
literal|4
decl_stmt|;
comment|/**< 1/3 of the interframe gap timing                                                          If CRS is detected during IFG2, then the                                                          interFrameSpacing timer is not reset and a frame                                                          is transmited once the timer expires. */
name|uint64_t
name|ifg1
range|:
literal|4
decl_stmt|;
comment|/**< 2/3 of the interframe gap timing                                                          If CRS is detected during IFG1, then the                                                          interFrameSpacing timer is reset and a frame is                                                          not transmited. */
else|#
directive|else
name|uint64_t
name|ifg1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ifg2
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_ifg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ifg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ifg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ifg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ifg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ifg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_ifg
name|cvmx_agl_gmx_tx_ifg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_int_en  *  * AGL_GMX_TX_INT_EN = Interrupt Enable  *  *  * Notes:  * UNDFLW[0], XSCOL[0], XSDEF[0], LATE_COL[0], PTP_LOST[0] will be reset when MIX0_CTL[RESET] is set to 1.  * UNDFLW[1], XSCOL[1], XSDEF[1], LATE_COL[1], PTP_LOST[1] will be reset when MIX1_CTL[RESET] is set to 1.  * PKO_NXA will bee reset when both MIX0/1_CTL[RESET] are set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_int_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive deferral (halfdup mode only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive collisions (halfdup mode only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_tx_int_en_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive deferral (MII/halfdup mode only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive collisions (MII/halfdup mode only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
comment|/**< TX Underflow (MII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_tx_int_en_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_int_en_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|1
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|1
decl_stmt|;
comment|/**< TX Excessive deferral (MII/halfdup mode only) */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|1
decl_stmt|;
comment|/**< TX Excessive collisions (MII/halfdup mode only) */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|1
decl_stmt|;
comment|/**< TX Underflow (MII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_tx_int_en_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_int_en_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_int_en
name|cvmx_agl_gmx_tx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_int_reg  *  * AGL_GMX_TX_INT_REG = Interrupt Register  *  *  * Notes:  * UNDFLW[0], XSCOL[0], XSDEF[0], LATE_COL[0], PTP_LOST[0] will be reset when MIX0_CTL[RESET] is set to 1.  * UNDFLW[1], XSCOL[1], XSDEF[1], LATE_COL[1], PTP_LOST[1] will be reset when MIX1_CTL[RESET] is set to 1.  * PKO_NXA will bee reset when both MIX0/1_CTL[RESET] are set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_int_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
comment|/**< A packet with a PTP request was not able to be                                                          sent due to XSCOL */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive deferral (halfdup mode only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive collisions (halfdup mode only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
comment|/**< TX Underflow */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ptp_lost
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_agl_gmx_tx_int_reg_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive deferral (MII/halfdup mode only) */
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
comment|/**< TX Excessive collisions (MII/halfdup mode only) */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
comment|/**< TX Underflow (MII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_11
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_agl_gmx_tx_int_reg_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_int_reg_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|1
decl_stmt|;
comment|/**< TX Late Collision */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|1
decl_stmt|;
comment|/**< TX Excessive deferral (MII/halfdup mode only) */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|1
decl_stmt|;
comment|/**< TX Excessive collisions (MII/halfdup mode only) */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|1
decl_stmt|;
comment|/**< TX Underflow (MII mode only) */
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
comment|/**< Port address out-of-range from PKO Interface */
else|#
directive|else
name|uint64_t
name|pko_nxa
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|undflw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|xscol
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|xsdef
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|late_col
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_tx_int_reg_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_int_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_int_reg_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_int_reg
name|cvmx_agl_gmx_tx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_jam  *  * AGL_GMX_TX_JAM = Packet TX Jam Pattern  *  *  * Notes:  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_jam
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_jam_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|jam
range|:
literal|8
decl_stmt|;
comment|/**< Jam pattern */
else|#
directive|else
name|uint64_t
name|jam
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_jam_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_jam_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_jam_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_jam_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_jam_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_jam_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_jam
name|cvmx_agl_gmx_tx_jam_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_lfsr  *  * AGL_GMX_TX_LFSR = LFSR used to implement truncated binary exponential backoff  *  *  * Notes:  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_lfsr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_lfsr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|lfsr
range|:
literal|16
decl_stmt|;
comment|/**< The current state of the LFSR used to feed random                                                          numbers to compute truncated binary exponential                                                          backoff. */
else|#
directive|else
name|uint64_t
name|lfsr
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_lfsr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_lfsr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_lfsr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_lfsr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_lfsr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_lfsr_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_lfsr
name|cvmx_agl_gmx_tx_lfsr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_ovr_bp  *  * AGL_GMX_TX_OVR_BP = Packet TX Override BackPressure  *  *  * Notes:  * IGN_FULL[0], BP[0], EN[0] will be reset when MIX0_CTL[RESET] is set to 1.  * IGN_FULL[1], BP[1], EN[1] will be reset when MIX1_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_ovr_bp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_ovr_bp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|en
range|:
literal|2
decl_stmt|;
comment|/**< Per port Enable back pressure override */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
comment|/**< Port BackPressure status to use                                                          0=Port is available                                                          1=Port should be back pressured */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ign_full
range|:
literal|2
decl_stmt|;
comment|/**< Ignore the RX FIFO full when computing BP */
else|#
directive|else
name|uint64_t
name|ign_full
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|en
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_ovr_bp_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ovr_bp_s
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_ovr_bp_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Per port Enable back pressure override */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
comment|/**< Port BackPressure status to use                                                          0=Port is available                                                          1=Port should be back pressured */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ign_full
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the RX FIFO full when computing BP */
else|#
directive|else
name|uint64_t
name|ign_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_agl_gmx_tx_ovr_bp_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ovr_bp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_ovr_bp_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_ovr_bp
name|cvmx_agl_gmx_tx_ovr_bp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_pause_pkt_dmac  *  * AGL_GMX_TX_PAUSE_PKT_DMAC = Packet TX Pause Packet DMAC field  *  *  * Notes:  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_pause_pkt_dmac
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|dmac
range|:
literal|48
decl_stmt|;
comment|/**< The DMAC field placed is outbnd pause pkts */
else|#
directive|else
name|uint64_t
name|dmac
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_dmac_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_pause_pkt_dmac
name|cvmx_agl_gmx_tx_pause_pkt_dmac_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_gmx_tx_pause_pkt_type  *  * AGL_GMX_TX_PAUSE_PKT_TYPE = Packet TX Pause Packet TYPE field  *  *  * Notes:  * Additionally reset when both MIX0/1_CTL[RESET] are set to 1.  *  */
end_comment

begin_union
union|union
name|cvmx_agl_gmx_tx_pause_pkt_type
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|type
range|:
literal|16
decl_stmt|;
comment|/**< The TYPE field placed is outbnd pause pkts */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_gmx_tx_pause_pkt_type_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_gmx_tx_pause_pkt_type
name|cvmx_agl_gmx_tx_pause_pkt_type_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_agl_prt#_ctl  *  * AGL_PRT_CTL = AGL Port Control  *  *  * Notes:  * AGL_PRT0_CTL will be reset when MIX0_CTL[RESET] is set to 1.  * AGL_PRT1_CTL will be reset when MIX1_CTL[RESET] is set to 1.  */
end_comment

begin_union
union|union
name|cvmx_agl_prtx_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_agl_prtx_ctl_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|drv_byp
range|:
literal|1
decl_stmt|;
comment|/**< Bypass the compensation controller and use                                                          DRV_NCTL and DRV_PCTL                                                          Note: the reset value was changed from pass1                                                          to pass2. */
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmp_pctl
range|:
literal|6
decl_stmt|;
comment|/**< PCTL drive strength from the compensation ctl */
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cmp_nctl
range|:
literal|6
decl_stmt|;
comment|/**< NCTL drive strength from the compensation ctl */
name|uint64_t
name|reserved_46_47
range|:
literal|2
decl_stmt|;
name|uint64_t
name|drv_pctl
range|:
literal|6
decl_stmt|;
comment|/**< PCTL drive strength to use in bypass mode                                                          Reset value of 19 is for 50 ohm termination */
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|drv_nctl
range|:
literal|6
decl_stmt|;
comment|/**< NCTL drive strength to use in bypass mode                                                          Reset value of 15 is for 50 ohm termination */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clk_set
range|:
literal|5
decl_stmt|;
comment|/**< The clock delay as determined by the DLL */
name|uint64_t
name|clkrx_byp
range|:
literal|1
decl_stmt|;
comment|/**< Bypass the RX clock delay setting                                                          Skews RXC from RXD,RXCTL in RGMII mode                                                          By default, HW internally shifts the RXC clock                                                          to sample RXD,RXCTL assuming clock and data and                                                          sourced synchronously from the link partner.                                                          In MII mode, the CLKRX_BYP is forced to 1. */
name|uint64_t
name|reserved_21_22
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clkrx_set
range|:
literal|5
decl_stmt|;
comment|/**< RX clock delay setting to use in bypass mode                                                          Skews RXC from RXD in RGMII mode */
name|uint64_t
name|clktx_byp
range|:
literal|1
decl_stmt|;
comment|/**< Bypass the TX clock delay setting                                                          Skews TXC from TXD,TXCTL in RGMII mode                                                          Skews RXC from RXD,RXCTL in RGMII mode                                                          By default, clock and data and sourced                                                          synchronously.                                                          In MII mode, the CLKRX_BYP is forced to 1. */
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clktx_set
range|:
literal|5
decl_stmt|;
comment|/**< TX clock delay setting to use in bypass mode                                                          Skews TXC from TXD in RGMII mode */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dllrst
range|:
literal|1
decl_stmt|;
comment|/**< DLL Reset */
name|uint64_t
name|comp
range|:
literal|1
decl_stmt|;
comment|/**< Compensation Enable */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Port Enable                                                          Note: the reset value was changed from pass1                                                          to pass2. */
name|uint64_t
name|clkrst
range|:
literal|1
decl_stmt|;
comment|/**< Clock Tree Reset */
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
comment|/**< Port Mode                                                          MODE must be set the same for all ports in which                                                          AGL_PRTx_CTL[ENABLE] is set.                                                          0=RGMII                                                          1=MII */
else|#
directive|else
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clkrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|comp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dllrst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clktx_set
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_14
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clktx_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clkrx_set
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_21_22
range|:
literal|2
decl_stmt|;
name|uint64_t
name|clkrx_byp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clk_set
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|drv_nctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_38_39
range|:
literal|2
decl_stmt|;
name|uint64_t
name|drv_pctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_46_47
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cmp_nctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_55
range|:
literal|2
decl_stmt|;
name|uint64_t
name|cmp_pctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_62_62
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drv_byp
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_agl_prtx_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_agl_prtx_ctl_s
name|cn63xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_agl_prtx_ctl
name|cvmx_agl_prtx_ctl_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

