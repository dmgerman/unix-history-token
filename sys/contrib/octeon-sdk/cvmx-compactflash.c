begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-compactflash.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)>(b))?(a):(b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FLASH_RoundUP
parameter_list|(
name|_Dividend
parameter_list|,
name|_Divisor
parameter_list|)
value|(((_Dividend)+(_Divisor-1))/(_Divisor))
end_define

begin_comment
comment|/**  * Convert nanosecond based time to setting used in the  * boot bus timing register, based on timing multiple  *   *   */
end_comment

begin_function
specifier|static
name|uint32_t
name|ns_to_tim_reg
parameter_list|(
name|int
name|tim_mult
parameter_list|,
name|uint32_t
name|nsecs
parameter_list|)
block|{
name|uint32_t
name|val
decl_stmt|;
comment|/* Compute # of eclock periods to get desired duration in nanoseconds */
name|val
operator|=
name|FLASH_RoundUP
argument_list|(
name|nsecs
operator|*
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000000
operator|)
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
comment|/* Factor in timing multiple, if not 1 */
if|if
condition|(
name|tim_mult
operator|!=
literal|1
condition|)
name|val
operator|=
name|FLASH_RoundUP
argument_list|(
name|val
argument_list|,
name|tim_mult
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_compactflash_generate_dma_tim
parameter_list|(
name|int
name|tim_mult
parameter_list|,
name|uint16_t
modifier|*
name|ident_data
parameter_list|,
name|int
modifier|*
name|mwdma_mode_ptr
parameter_list|)
block|{
name|cvmx_mio_boot_dma_timx_t
name|dma_tim
decl_stmt|;
name|int
name|oe_a
decl_stmt|;
name|int
name|oe_n
decl_stmt|;
name|int
name|dma_acks
decl_stmt|;
name|int
name|dma_ackh
decl_stmt|;
name|int
name|dma_arq
decl_stmt|;
name|int
name|pause
decl_stmt|;
name|int
name|To
decl_stmt|,
name|Tkr
decl_stmt|,
name|Td
decl_stmt|;
name|int
name|mwdma_mode
init|=
operator|-
literal|1
decl_stmt|;
name|uint16_t
name|word53_field_valid
decl_stmt|;
name|uint16_t
name|word63_mwdma
decl_stmt|;
name|uint16_t
name|word163_adv_timing_info
decl_stmt|;
if|if
condition|(
operator|!
name|ident_data
condition|)
return|return
literal|0
return|;
name|word53_field_valid
operator|=
name|ident_data
index|[
literal|53
index|]
expr_stmt|;
name|word63_mwdma
operator|=
name|ident_data
index|[
literal|63
index|]
expr_stmt|;
name|word163_adv_timing_info
operator|=
name|ident_data
index|[
literal|163
index|]
expr_stmt|;
name|dma_tim
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Check for basic MWDMA modes */
if|if
condition|(
name|word53_field_valid
operator|&
literal|0x2
condition|)
block|{
if|if
condition|(
name|word63_mwdma
operator|&
literal|0x4
condition|)
name|mwdma_mode
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|word63_mwdma
operator|&
literal|0x2
condition|)
name|mwdma_mode
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|word63_mwdma
operator|&
literal|0x1
condition|)
name|mwdma_mode
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Check for advanced MWDMA modes */
switch|switch
condition|(
operator|(
name|word163_adv_timing_info
operator|>>
literal|3
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|1
case|:
name|mwdma_mode
operator|=
literal|3
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mwdma_mode
operator|=
literal|4
expr_stmt|;
break|break;
default|default:
break|break;
block|}
comment|/* DMA is not supported by this card */
if|if
condition|(
name|mwdma_mode
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* Now set up the DMA timing */
switch|switch
condition|(
name|tim_mult
condition|)
block|{
case|case
literal|1
case|:
name|dma_tim
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|dma_tim
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|dma_tim
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|dma_tim
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|cvmx_dprintf
argument_list|(
literal|"ERROR: invalid boot bus dma tim_mult setting\n"
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|mwdma_mode
condition|)
block|{
case|case
literal|4
case|:
name|To
operator|=
literal|80
expr_stmt|;
name|Td
operator|=
literal|55
expr_stmt|;
name|Tkr
operator|=
literal|20
expr_stmt|;
name|oe_a
operator|=
name|Td
operator|+
literal|20
expr_stmt|;
comment|// Td (Seem to need more margin here....
name|oe_n
operator|=
name|MAX
argument_list|(
name|To
operator|-
name|oe_a
argument_list|,
name|Tkr
argument_list|)
expr_stmt|;
comment|// Tkr from cf spec, lengthened to meet To
comment|// oe_n + oe_h must be>= To (cycle time)
name|dma_acks
operator|=
literal|0
expr_stmt|;
comment|//Ti
name|dma_ackh
operator|=
literal|5
expr_stmt|;
comment|// Tj
name|dma_arq
operator|=
literal|8
expr_stmt|;
comment|// not spec'ed, value in eclocks, not affected by tim_mult
name|pause
operator|=
literal|25
operator|-
name|dma_arq
operator|*
literal|1000
operator|/
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000000
operator|)
expr_stmt|;
comment|// Tz
break|break;
case|case
literal|3
case|:
name|To
operator|=
literal|100
expr_stmt|;
name|Td
operator|=
literal|65
expr_stmt|;
name|Tkr
operator|=
literal|20
expr_stmt|;
name|oe_a
operator|=
name|Td
operator|+
literal|20
expr_stmt|;
comment|// Td (Seem to need more margin here....
name|oe_n
operator|=
name|MAX
argument_list|(
name|To
operator|-
name|oe_a
argument_list|,
name|Tkr
argument_list|)
expr_stmt|;
comment|// Tkr from cf spec, lengthened to meet To
comment|// oe_n + oe_h must be>= To (cycle time)
name|dma_acks
operator|=
literal|0
expr_stmt|;
comment|//Ti
name|dma_ackh
operator|=
literal|5
expr_stmt|;
comment|// Tj
name|dma_arq
operator|=
literal|8
expr_stmt|;
comment|// not spec'ed, value in eclocks, not affected by tim_mult
name|pause
operator|=
literal|25
operator|-
name|dma_arq
operator|*
literal|1000
operator|/
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000000
operator|)
expr_stmt|;
comment|// Tz
break|break;
case|case
literal|2
case|:
comment|// +20 works
comment|// +10 works
comment|// + 10 + 0 fails
comment|// n=40, a=80 works
name|To
operator|=
literal|120
expr_stmt|;
name|Td
operator|=
literal|70
expr_stmt|;
name|Tkr
operator|=
literal|25
expr_stmt|;
comment|// oe_a 0 fudge doesn't work; 10 seems to
name|oe_a
operator|=
name|Td
operator|+
literal|20
operator|+
literal|10
expr_stmt|;
comment|// Td (Seem to need more margin here....
name|oe_n
operator|=
name|MAX
argument_list|(
name|To
operator|-
name|oe_a
argument_list|,
name|Tkr
argument_list|)
operator|+
literal|10
expr_stmt|;
comment|// Tkr from cf spec, lengthened to meet To
comment|// oe_n 0 fudge fails;;; 10 boots
comment|// 20 ns fudge needed on dma_acks
comment|// oe_n + oe_h must be>= To (cycle time)
name|dma_acks
operator|=
literal|0
operator|+
literal|20
expr_stmt|;
comment|//Ti
name|dma_ackh
operator|=
literal|5
expr_stmt|;
comment|// Tj
name|dma_arq
operator|=
literal|8
expr_stmt|;
comment|// not spec'ed, value in eclocks, not affected by tim_mult
name|pause
operator|=
literal|25
operator|-
name|dma_arq
operator|*
literal|1000
operator|/
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
operator|/
literal|1000000
operator|)
expr_stmt|;
comment|// Tz
comment|// no fudge needed on pause
break|break;
case|case
literal|1
case|:
case|case
literal|0
case|:
default|default:
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unsupported DMA mode: %d\n"
argument_list|,
name|mwdma_mode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
if|if
condition|(
name|mwdma_mode_ptr
condition|)
operator|*
name|mwdma_mode_ptr
operator|=
name|mwdma_mode
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|dmack_pi
operator|=
literal|1
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|oe_n
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|oe_n
argument_list|)
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|oe_a
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|oe_a
argument_list|)
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|dmack_s
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|dma_acks
argument_list|)
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|dmack_h
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|dma_ackh
argument_list|)
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|dmarq
operator|=
name|dma_arq
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|pause
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|pause
argument_list|)
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|rd_dly
operator|=
literal|0
expr_stmt|;
comment|/* Sample right on edge */
comment|/*  writes only */
name|dma_tim
operator|.
name|s
operator|.
name|we_n
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|oe_n
argument_list|)
expr_stmt|;
name|dma_tim
operator|.
name|s
operator|.
name|we_a
operator|=
name|ns_to_tim_reg
argument_list|(
name|tim_mult
argument_list|,
name|oe_a
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|cvmx_dprintf("ns to ticks (mult %d) of %d is: %d\n", TIM_MULT, 60, ns_to_tim_reg(60)); 	cvmx_dprintf("oe_n: %d, oe_a: %d, dmack_s: %d, dmack_h: %d, dmarq: %d, pause: %d\n", 	   dma_tim.s.oe_n, dma_tim.s.oe_a, dma_tim.s.dmack_s, dma_tim.s.dmack_h, dma_tim.s.dmarq, dma_tim.s.pause);
endif|#
directive|endif
return|return
operator|(
name|dma_tim
operator|.
name|u64
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Setup timing and region config to support a specific IDE PIO  * mode over the bootbus.  *  * @param cs0      Bootbus region number connected to CS0 on the IDE device  * @param cs1      Bootbus region number connected to CS1 on the IDE device  * @param pio_mode PIO mode to set (0-6)  */
end_comment

begin_function
name|void
name|cvmx_compactflash_set_piomode
parameter_list|(
name|int
name|cs0
parameter_list|,
name|int
name|cs1
parameter_list|,
name|int
name|pio_mode
parameter_list|)
block|{
name|cvmx_mio_boot_reg_cfgx_t
name|mio_boot_reg_cfg
decl_stmt|;
name|cvmx_mio_boot_reg_timx_t
name|mio_boot_reg_tim
decl_stmt|;
name|int
name|cs
decl_stmt|;
name|int
name|clocks_us
decl_stmt|;
comment|/* Number of clock cycles per microsec */
name|int
name|tim_mult
decl_stmt|;
name|int
name|use_iordy
decl_stmt|;
comment|/* Set for PIO0-4, not set for PIO5-6 */
name|int
name|t1
decl_stmt|;
comment|/* These t names are timing parameters from the ATA spec */
name|int
name|t2
decl_stmt|;
name|int
name|t2i
decl_stmt|;
name|int
name|t4
decl_stmt|;
name|int
name|t6
decl_stmt|;
name|int
name|t6z
decl_stmt|;
name|int
name|t9
decl_stmt|;
comment|/* PIO modes 0-4 all allow the device to deassert IORDY to slow down         the host */
name|use_iordy
operator|=
literal|1
expr_stmt|;
comment|/* Use the PIO mode to determine timing parameters */
switch|switch
condition|(
name|pio_mode
condition|)
block|{
case|case
literal|6
case|:
comment|/* CF spec say IORDY should be ignore in PIO 5 */
name|use_iordy
operator|=
literal|0
expr_stmt|;
name|t1
operator|=
literal|10
expr_stmt|;
name|t2
operator|=
literal|55
expr_stmt|;
name|t2i
operator|=
literal|20
expr_stmt|;
name|t4
operator|=
literal|5
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|20
expr_stmt|;
name|t9
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* CF spec say IORDY should be ignore in PIO 6 */
name|use_iordy
operator|=
literal|0
expr_stmt|;
name|t1
operator|=
literal|15
expr_stmt|;
name|t2
operator|=
literal|65
expr_stmt|;
name|t2i
operator|=
literal|25
expr_stmt|;
name|t4
operator|=
literal|5
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|20
expr_stmt|;
name|t9
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|t1
operator|=
literal|25
expr_stmt|;
name|t2
operator|=
literal|70
expr_stmt|;
name|t2i
operator|=
literal|25
expr_stmt|;
name|t4
operator|=
literal|10
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|30
expr_stmt|;
name|t9
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|t1
operator|=
literal|30
expr_stmt|;
name|t2
operator|=
literal|80
expr_stmt|;
name|t2i
operator|=
literal|70
expr_stmt|;
name|t4
operator|=
literal|10
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|30
expr_stmt|;
name|t9
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|t1
operator|=
literal|30
expr_stmt|;
name|t2
operator|=
literal|100
expr_stmt|;
name|t2i
operator|=
literal|0
expr_stmt|;
name|t4
operator|=
literal|15
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|30
expr_stmt|;
name|t9
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|t1
operator|=
literal|50
expr_stmt|;
name|t2
operator|=
literal|125
expr_stmt|;
name|t2i
operator|=
literal|0
expr_stmt|;
name|t4
operator|=
literal|20
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|30
expr_stmt|;
name|t9
operator|=
literal|15
expr_stmt|;
break|break;
default|default:
name|t1
operator|=
literal|70
expr_stmt|;
name|t2
operator|=
literal|165
expr_stmt|;
name|t2i
operator|=
literal|0
expr_stmt|;
name|t4
operator|=
literal|30
expr_stmt|;
name|t6
operator|=
literal|5
expr_stmt|;
name|t6z
operator|=
literal|30
expr_stmt|;
name|t9
operator|=
literal|20
expr_stmt|;
break|break;
block|}
comment|/* Convert times in ns to clock cycles, rounding up */
name|clocks_us
operator|=
name|FLASH_RoundUP
argument_list|(
operator|(
name|uint64_t
operator|)
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
argument_list|,
literal|1000000
argument_list|)
expr_stmt|;
comment|/* Convert times in clock cycles, rounding up. Octeon parameters are in         minus one notation, so take off one after the conversion */
name|t1
operator|=
name|FLASH_RoundUP
argument_list|(
name|t1
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t1
condition|)
name|t1
operator|--
expr_stmt|;
name|t2
operator|=
name|FLASH_RoundUP
argument_list|(
name|t2
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|t2
operator|--
expr_stmt|;
name|t2i
operator|=
name|FLASH_RoundUP
argument_list|(
name|t2i
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2i
condition|)
name|t2i
operator|--
expr_stmt|;
name|t4
operator|=
name|FLASH_RoundUP
argument_list|(
name|t4
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t4
condition|)
name|t4
operator|--
expr_stmt|;
name|t6
operator|=
name|FLASH_RoundUP
argument_list|(
name|t6
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t6
condition|)
name|t6
operator|--
expr_stmt|;
name|t6z
operator|=
name|FLASH_RoundUP
argument_list|(
name|t6z
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t6z
condition|)
name|t6z
operator|--
expr_stmt|;
name|t9
operator|=
name|FLASH_RoundUP
argument_list|(
name|t9
operator|*
name|clocks_us
argument_list|,
literal|1000
argument_list|)
expr_stmt|;
if|if
condition|(
name|t9
condition|)
name|t9
operator|--
expr_stmt|;
comment|/* Start using a scale factor of one cycle. Keep doubling it until         the parameters fit in their fields. Since t2 is the largest number,         we only need to check it */
name|tim_mult
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|t2
operator|>=
literal|1
operator|<<
literal|6
condition|)
block|{
name|t1
operator|=
name|FLASH_RoundUP
argument_list|(
name|t1
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t2
operator|=
name|FLASH_RoundUP
argument_list|(
name|t2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t2i
operator|=
name|FLASH_RoundUP
argument_list|(
name|t2i
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t4
operator|=
name|FLASH_RoundUP
argument_list|(
name|t4
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t6
operator|=
name|FLASH_RoundUP
argument_list|(
name|t6
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t6z
operator|=
name|FLASH_RoundUP
argument_list|(
name|t6z
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|t9
operator|=
name|FLASH_RoundUP
argument_list|(
name|t9
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|tim_mult
operator|*=
literal|2
expr_stmt|;
block|}
name|cs
operator|=
name|cs0
expr_stmt|;
do|do
block|{
name|mio_boot_reg_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_BOOT_REG_CFGX
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|dmack
operator|=
literal|0
expr_stmt|;
comment|/* Don't assert DMACK on access */
switch|switch
condition|(
name|tim_mult
condition|)
block|{
case|case
literal|1
case|:
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|8
case|:
default|default:
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|tim_mult
operator|=
literal|3
expr_stmt|;
break|break;
block|}
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|rd_dly
operator|=
literal|0
expr_stmt|;
comment|/* Sample on falling edge of BOOT_OE */
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|sam
operator|=
literal|0
expr_stmt|;
comment|/* Don't combine write and output enable */
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|we_ext
operator|=
literal|0
expr_stmt|;
comment|/* No write enable extension */
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|oe_ext
operator|=
literal|0
expr_stmt|;
comment|/* No read enable extension */
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|en
operator|=
literal|1
expr_stmt|;
comment|/* Enable this region */
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|orbit
operator|=
literal|0
expr_stmt|;
comment|/* Don't combine with previos region */
name|mio_boot_reg_cfg
operator|.
name|s
operator|.
name|width
operator|=
literal|1
expr_stmt|;
comment|/* 16 bits wide */
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_BOOT_REG_CFGX
argument_list|(
name|cs
argument_list|)
argument_list|,
name|mio_boot_reg_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|cs0
condition|)
name|cs
operator|=
name|cs1
expr_stmt|;
else|else
name|cs
operator|=
name|cs0
expr_stmt|;
block|}
do|while
condition|(
name|cs
operator|!=
name|cs0
condition|)
do|;
name|mio_boot_reg_tim
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|pagem
operator|=
literal|0
expr_stmt|;
comment|/* Disable page mode */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|waitm
operator|=
name|use_iordy
expr_stmt|;
comment|/* Enable dynamic timing */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|pages
operator|=
literal|0
expr_stmt|;
comment|/* Pages are disabled */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|ale
operator|=
literal|8
expr_stmt|;
comment|/* If someone uses ALE, this seems to work */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|page
operator|=
literal|0
expr_stmt|;
comment|/* Not used */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|wait
operator|=
literal|0
expr_stmt|;
comment|/* Time after IORDY to coninue to assert the data */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|pause
operator|=
literal|0
expr_stmt|;
comment|/* Time after CE that signals stay valid */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|wr_hld
operator|=
name|t9
expr_stmt|;
comment|/* How long to hold after a write */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|rd_hld
operator|=
name|t9
expr_stmt|;
comment|/* How long to wait after a read for device to tristate */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|we
operator|=
name|t2
expr_stmt|;
comment|/* How long write enable is asserted */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|oe
operator|=
name|t2
expr_stmt|;
comment|/* How long read enable is asserted */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|ce
operator|=
name|t1
expr_stmt|;
comment|/* Time after CE that read/write starts */
name|mio_boot_reg_tim
operator|.
name|s
operator|.
name|adr
operator|=
literal|1
expr_stmt|;
comment|/* Time before CE that address is valid */
comment|/* Program the bootbus region timing for both chip selects */
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_BOOT_REG_TIMX
argument_list|(
name|cs0
argument_list|)
argument_list|,
name|mio_boot_reg_tim
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_BOOT_REG_TIMX
argument_list|(
name|cs1
argument_list|)
argument_list|,
name|mio_boot_reg_tim
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

