begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2007, Cavium Networks. All rights reserved.  *  * This software file (the "File") is owned and distributed by Cavium  * Networks ("Cavium") under the following dual licensing option: The dual  * licensing option gives you, the licensee, the choice between the following  * alternative licensing terms.  Once you have made an election to use the  * File under one of the following alternative licensing terms (license  * types) you are bound by the respective terms and you may distribute the  * file (or any derivative thereof), to the extent allowed by the respective  * licensing term, only if you (i) delete this introductory statement  * regarding the dual licensing option from the file you will distribute,  * (ii) delete the licensing term that you have elected NOT to use from the  * file you will distribute and (iii) follow the respective licensing term  * that you have elected to use with respect to the correct attribution or  * licensing term that you have to include with your distribution.  *  * ***  * OCTEON SDK License Type 2:  *  * IMPORTANT: Read this Agreement carefully before clicking on the "I accept"  * button to download the Software and/or before using the Software.  This  * License Agreement (the "Agreement") is a legal agreement between you,  * either an individual or a single legal entity ("You" or "you"), and Cavium  * Networks ("Cavium").  This Agreement governs your use of the Cavium  * software that can be downloaded after accepting this Agreement and/or that  * is accompanied by this Agreement (the "Software").  You must accept the  * terms of this Agreement before downloading and/or using the Software.  By  * clicking on the "I accept" button to download and/or by using the  * Software, you are indicating that you have read and understood, and assent  * to be bound by, the terms of this Agreement.  If you do not agree to the  * terms of the Agreement, you are not granted any rights whatsoever in the  * Software.  If you are not willing to be bound by these terms and  * conditions, you should not use or cease all use of the Software.  This  * Software is the property of Cavium Networks and constitutes the  * proprietary information of Cavium Networks.  You agree to take reasonable  * steps to prevent the disclosure, unauthorized use or unauthorized  * distribution of the Software to any third party.  *  * License Grant.  Subject to the terms and conditions of this Agreement,  * Cavium grants you a nonexclusive, non-transferable, worldwide, fully-paid  * and royalty-free license to  *  * (a) install, reproduce, and execute the executable version of the Software  * solely for your internal use and only (a) on hardware manufactured by  * Cavium, or (b) software of Cavium that simulates Cavium hardware;  *  * (b) create derivative works of any portions of the Software provided to  * you by Cavium in source code form, which portions enable features of the  * Cavium hardware products you or your licensees are entitled to use,  * provided that any such derivative works must be used only (a) on hardware  * manufactured by Cavium, or (b) software of Cavium that simulates Cavium  * hardware; and  *  * (c) distribute derivative works you created in accordance with clause (b)  * above, only in executable form and only if such distribution (i)  * reproduces the copyright notice that can be found at the very end of this  * Agreement and (ii) is pursuant to a binding license agreement that  * contains terms no less restrictive and no less protective of Cavium than  * this Agreement.  You will immediately notify Cavium if you become aware of  * any breach of any such license agreement.  *  * Restrictions.  The rights granted to you in this Agreement are subject to  * the following restrictions: Except as expressly set forth in this  * Agreement (a) you will not license, sell, rent, lease, transfer, assign,  * display, host, outsource, disclose or otherwise commercially exploit or  * make the Software, or any derivatives you create under this Agreement,  * available to any third party; (b) you will not modify or create derivative  * works of any part of the Software; (c) you will not access or use the  * Software in order to create similar or competitive products, components,  * or services; and (d), no part of the Software may be copied (except for  * the making of a single archival copy), reproduced, distributed,  * republished, downloaded, displayed, posted or transmitted in any form or  * by any means.  *  * Ownership.  You acknowledge and agree that, subject to the license grant  * contained in this Agreement and as between you and Cavium (a) Cavium owns  * all copies of and intellectual property rights to the Software, however  * made, and retains all rights in and to the Software, including all  * intellectual property rights therein, and (b) you own all the derivate  * works of the Software created by you under this Agreement, subject to  * Cavium's rights in the Software.  There are no implied licenses under this  * Agreement, and any rights not expressly granted to your hereunder are  * reserved by Cavium.  You will not, at any time, contest anywhere in the  * world Cavium's ownership of the intellectual property rights in and to the  * Software.  *  * Disclaimer of Warranties.  The Software is provided to you free of charge,  * and on an "As-Is" basis.  Cavium provides no technical support, warranties  * or remedies for the Software.  Cavium and its suppliers disclaim all  * express, implied or statutory warranties relating to the Software,  * including but not limited to, merchantability, fitness for a particular  * purpose, title, and non-infringement.  Cavium does not warrant that the  * Software and the use thereof will be error-free, that defects will be  * corrected, or that the Software is free of viruses or other harmful  * components.  If applicable law requires any warranties with respect to the  * Software, all such warranties are limited in duration to thirty (30) days  * from the date of download or first use, whichever comes first.  *  * Limitation of Liability.  Neither Cavium nor its suppliers shall be  * responsible or liable with respect to any subject matter of this Agreement  * or terms or conditions related thereto under any contract, negligence,  * strict liability or other theory (a) for loss or inaccuracy of data or  * cost of procurement of substitute goods, services or technology, or (b)  * for any indirect, incidental or consequential damages including, but not  * limited to loss of revenues and loss of profits.  Cavium's aggregate  * cumulative liability hereunder shall not exceed the greater of Fifty U.S.  * Dollars (U.S.$50.00) or the amount paid by you for the Software that  * caused the damage.  Certain states and/or jurisdictions do not allow the  * exclusion of implied warranties or limitation of liability for incidental  * or consequential damages, so the exclusions set forth above may not apply  * to you.  *  * Basis of Bargain.  The warranty disclaimer and limitation of liability set  * forth above are fundamental elements of the basis of the agreement between  * Cavium and you.  Cavium would not provide the Software without such  * limitations.  The warranty disclaimer and limitation of liability inure to  * the benefit of Cavium and Cavium's suppliers.  *  * Term and Termination.  This Agreement and the licenses granted hereunder  * are effective on the date you accept the terms of this Agreement, download  * the Software, or use the Software, whichever comes first, and shall  * continue unless this Agreement is terminated pursuant to this section.  * This Agreement immediately terminates in the event that you materially  * breach any of the terms hereof.  You may terminate this Agreement at any  * time, with or without cause, by destroying any copies of the Software in  * your possession.  Upon termination, the license granted hereunder shall  * terminate but the Sections titled "Restrictions", "Ownership", "Disclaimer  * of Warranties", "Limitation of Liability", "Basis of Bargain", "Term and  * Termination", "Export", and "Miscellaneous" will remain in effect.  *  * Export.  The Software and related technology are subject to U.S.  export  * control laws and may be subject to export or import regulations in other  * countries.  You agree to strictly comply with all such laws and  * regulations and acknowledges that you have the responsibility to obtain  * authorization to export, re-export, or import the Software and related  * technology, as may be required.  You will indemnify and hold Cavium  * harmless from any and all claims, losses, liabilities, damages, fines,  * penalties, costs and expenses (including attorney's fees) arising from or  * relating to any breach by you of your obligations under this section.  * Your obligations under this section shall survive the expiration or  * termination of this Agreement.  *  * Miscellaneous.  Neither the rights nor the obligations arising under this  * Agreement are assignable by you, and any such attempted assignment or  * transfer shall be void and without effect.  This Agreement shall be  * governed by and construed in accordance with the laws of the State of  * California without regard to any conflicts of laws provisions that would  * require application of the laws of another jurisdiction.  Any action under  * or relating to this Agreement shall be brought in the state and federal  * courts located in California, with venue in the courts located in Santa  * Clara County and each party hereby submits to the personal jurisdiction of  * such courts; provided, however, that nothing herein will operate to  * prohibit or restrict Cavium from filing for and obtaining injunctive  * relief from any court of competent jurisdiction.  The United Nations  * Convention on Contracts for the International Sale of Goods shall not  * apply to this Agreement.  In the event that any provision of this  * Agreement is found to be contrary to law, then such provision shall be  * construed as nearly as possible to reflect the intention of the parties,  * with the other provisions remaining in full force and effect.  Any notice  * to you may be provided by email.  This Agreement constitutes the entire  * agreement between the parties and supersedes all prior or contemporaneous,  * agreements, understandings and communications between the parties, whether  * written or oral, pertaining to the subject matter hereof.  Any  * modifications of this Agreement must be in writing and agreed to by both  * parties.  *  * Copyright (c) 2003-2007, Cavium Networks. All rights reserved.  *  * ***  *  * OCTEON SDK License Type 4:  *  * Author: Cavium Networks  *  * Contact: support@caviumnetworks.com  * This file is part of the OCTEON SDK  *  * Copyright (c) 2007 Cavium Networks  *  * This file is free software; you can redistribute it and/or modify  * it under the terms of the GNU General Public License, Version 2, as published by  * the Free Software Foundation.  *  * This file is distributed in the hope that it will be useful,  * but AS-IS and WITHOUT ANY WARRANTY; without even the implied warranty of  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE, TITLE, or NONINFRINGEMENT.  * See the GNU General Public License for more details.  * it under the terms of the GNU General Public License, Version 2, as published by  * the Free Software Foundation.  *  * You should have received a copy of the GNU General Public License  * along with this file; if not, write to the Free Software  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA  * or visit http://www.gnu.org/licenses/.  *  * This file may also be available under a different license from Cavium.  * Contact Cavium Networks for more information  ***********************license end**************************************/
end_comment

begin_comment
comment|/*  * This code is an example of using twsi core in raw mode, bypasing High   * Level Controller (HLC). It is recommended to use HLC if only possible as   * it is more efficient and robust mechanism.   * The example code shows use of twsi for generating long (more that 8 bytes HLC limit)   * read - write transactions using 7-bit addressing. Different types of   * transactions can be generated if needed. Make sure that commands written to twsi core   * follow core state transitions outlinged in OCTEON documentation. The core state is   * reported in stat register after the command colpletion. In each state core will accept  *  only the allowed commands.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<cvmx.h>
end_include

begin_include
include|#
directive|include
file|<cvmx-csr-typedefs.h>
end_include

begin_include
include|#
directive|include
file|"cvmx-twsi-raw.h"
end_include

begin_comment
comment|/*  * uint8_t cvmx_twsix_read_ctr(int twsi_id, uint8_t reg)  * twsi core register read  * twsi_id - twsi core index  * reg 0 - 8-bit register  * returns 8-bit register contetn  */
end_comment

begin_function
name|uint8_t
name|cvmx_twsix_read_ctr
parameter_list|(
name|int
name|twsi_id
parameter_list|,
name|uint8_t
name|reg
parameter_list|)
block|{
name|cvmx_mio_twsx_sw_twsi_t
name|sw_twsi_val
decl_stmt|;
name|sw_twsi_val
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|v
operator|=
literal|1
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|op
operator|=
literal|6
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|eop_ia
operator|=
name|reg
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|r
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_TWSX_SW_TWSI
argument_list|(
name|twsi_id
argument_list|)
argument_list|,
name|sw_twsi_val
operator|.
name|u64
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|cvmx_mio_twsx_sw_twsi_t
call|)
argument_list|(
name|sw_twsi_val
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_TWSX_SW_TWSI
argument_list|(
name|twsi_id
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|.
name|s
operator|.
name|v
condition|)
empty_stmt|;
return|return
name|sw_twsi_val
operator|.
name|s
operator|.
name|d
return|;
block|}
end_function

begin_comment
comment|/*  * uint8_t cvmx_twsix_write_ctr(int twsi_id, uint8_t reg, uint8_t data)  *  * twsi core register write  * twsi_id - twsi core index  * reg 0 - 8-bit register  * data - data to write  * returns 0;  */
end_comment

begin_function
name|int
name|cvmx_twsix_write_ctr
parameter_list|(
name|int
name|twsi_id
parameter_list|,
name|uint8_t
name|reg
parameter_list|,
name|uint8_t
name|data
parameter_list|)
block|{
name|cvmx_mio_twsx_sw_twsi_t
name|sw_twsi_val
decl_stmt|;
name|sw_twsi_val
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|v
operator|=
literal|1
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|op
operator|=
literal|6
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|eop_ia
operator|=
name|reg
expr_stmt|;
name|sw_twsi_val
operator|.
name|s
operator|.
name|d
operator|=
name|data
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_TWSX_SW_TWSI
argument_list|(
name|twsi_id
argument_list|)
argument_list|,
name|sw_twsi_val
operator|.
name|u64
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
call|(
name|cvmx_mio_twsx_sw_twsi_t
call|)
argument_list|(
name|sw_twsi_val
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_TWSX_SW_TWSI
argument_list|(
name|twsi_id
argument_list|)
argument_list|)
argument_list|)
operator|)
operator|.
name|s
operator|.
name|v
condition|)
empty_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * cvmx_twsi_wait_iflg(int twsi_id)  * cvmx_twsi_wait_stop(int twsi_id)  *  * Helper functions.   * Busy wait for interrupt flag or stop bit on control register. This implementation is for OS-less   * application. With OS services available it could be implemented with semaphore  * block and interrupt wake up.   * TWSI_WAIT for loop must be defined large enough to allow on-wire transaction to finish - that is   * about 10 twsi clocks  */
end_comment

begin_define
define|#
directive|define
name|TWSI_WAIT
value|10000000
end_define

begin_function
specifier|static
specifier|inline
name|int
name|cvmx_twsi_wait_iflg
parameter_list|(
name|int
name|twsi_id
parameter_list|)
block|{
name|octeon_twsi_ctl_t
name|ctl_reg
decl_stmt|;
name|int
name|wait
init|=
name|TWSI_WAIT
decl_stmt|;
do|do
block|{
name|ctl_reg
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ctl_reg
operator|.
name|s
operator|.
name|iflg
operator|==
literal|0
operator|)
operator|&&
operator|(
name|wait
operator|--
operator|>
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|cvmx_twsi_wait_stop
parameter_list|(
name|int
name|twsi_id
parameter_list|)
block|{
name|octeon_twsi_ctl_t
name|ctl_reg
decl_stmt|;
name|int
name|wait
init|=
name|TWSI_WAIT
decl_stmt|;
do|do
block|{
name|ctl_reg
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|ctl_reg
operator|.
name|s
operator|.
name|stp
operator|==
literal|1
operator|)
operator|&&
operator|(
name|wait
operator|--
operator|>
literal|0
operator|)
condition|)
do|;
if|if
condition|(
name|wait
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * uint8_t octeon_twsi_read_byte(int twsi_id, uint8_t* byte, int ack)   * uint8_t octeon_twsi_write_byte(int twsi_id, uint8_t byte)  *  * helper functions - read or write byte to data reg and reads the TWSI core status  */
end_comment

begin_function
specifier|static
name|uint8_t
name|octeon_twsi_read_byte
parameter_list|(
name|int
name|twsi_id
parameter_list|,
name|uint8_t
modifier|*
name|byte
parameter_list|,
name|int
name|ack
parameter_list|)
block|{
name|octeon_twsi_ctl_t
name|ctl_reg
decl_stmt|;
name|octeon_twsi_data_t
name|data
decl_stmt|;
name|octeon_twsi_stat_t
name|stat
decl_stmt|;
comment|/* clear interrupt flag, set aak for requested ACK signal level */
name|ctl_reg
operator|.
name|u8
operator|=
literal|0
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|aak
operator|=
operator|(
name|ack
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|enab
operator|=
literal|1
expr_stmt|;
name|cvmx_twsix_write_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|,
name|ctl_reg
operator|.
name|u8
argument_list|)
expr_stmt|;
comment|/* wait for  twsi_ctl[iflg] to be set */
if|if
condition|(
name|cvmx_twsi_wait_iflg
argument_list|(
name|twsi_id
argument_list|)
condition|)
goto|goto
name|error
goto|;
comment|/* read the byte */
name|data
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_DATA_REG
argument_list|)
expr_stmt|;
operator|*
name|byte
operator|=
name|data
operator|.
name|s
operator|.
name|data
expr_stmt|;
name|error
label|:
comment|/* read the status */
name|stat
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_STAT_REG
argument_list|)
expr_stmt|;
return|return
name|stat
operator|.
name|s
operator|.
name|stat
return|;
block|}
end_function

begin_function
specifier|static
name|uint8_t
name|octeon_twsi_write_byte
parameter_list|(
name|int
name|twsi_id
parameter_list|,
name|uint8_t
name|byte
parameter_list|)
block|{
name|octeon_twsi_ctl_t
name|ctl_reg
decl_stmt|;
name|octeon_twsi_data_t
name|data
decl_stmt|;
name|octeon_twsi_stat_t
name|stat
decl_stmt|;
comment|/* tx data byte - write to twsi_data reg, then clear twsi_ctl[iflg] */
name|data
operator|.
name|s
operator|.
name|data
operator|=
name|byte
expr_stmt|;
name|cvmx_twsix_write_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_DATA_REG
argument_list|,
name|data
operator|.
name|u8
argument_list|)
expr_stmt|;
name|ctl_reg
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|)
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|iflg
operator|=
literal|0
expr_stmt|;
name|cvmx_twsix_write_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|,
name|ctl_reg
operator|.
name|u8
argument_list|)
expr_stmt|;
comment|/* wait for  twsi_ctl[iflg] to be set */
if|if
condition|(
name|cvmx_twsi_wait_iflg
argument_list|(
name|twsi_id
argument_list|)
condition|)
goto|goto
name|error
goto|;
name|error
label|:
comment|/* read the status */
name|stat
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_STAT_REG
argument_list|)
expr_stmt|;
return|return
name|stat
operator|.
name|s
operator|.
name|stat
return|;
block|}
end_function

begin_comment
comment|/*  * int octeon_i2c_xfer_msg_raw(struct i2c_msg *msg)  *  * Send (read or write) a message with 7-bit address device over direct control of   * TWSI core, bypassind HLC. Will try to finish the transaction on failure, so core state  * expected to be idle with HLC enabled on exit.  *  * dev - TWSI controller index (0 for cores with single controler)  * msg - message to transfer  * returns 0 on success, TWSI core state on error. Will try to finish the transaction on failure, so core state expected to be idle  */
end_comment

begin_function
name|int
name|octeon_i2c_xfer_msg_raw
parameter_list|(
name|int
name|twsi_id
parameter_list|,
name|struct
name|i2c_msg
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|octeon_twsi_ctl_t
name|ctl_reg
decl_stmt|;
name|octeon_twsi_addr_t
name|addr
decl_stmt|;
name|octeon_twsi_stat_t
name|stat
decl_stmt|;
name|int
name|is_read
init|=
name|msg
operator|->
name|flags
operator|&
name|I2C_M_RD
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
comment|/* check the core state, quit if not idle */
name|stat
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_STAT_REG
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|!=
name|TWSI_IDLE
condition|)
block|{
name|msg
operator|->
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|stat
operator|.
name|s
operator|.
name|stat
return|;
block|}
comment|/* first send start - set twsi_ctl[sta] to 1 */
name|ctl_reg
operator|.
name|u8
operator|=
literal|0
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|enab
operator|=
literal|1
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|sta
operator|=
literal|1
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|iflg
operator|=
literal|0
expr_stmt|;
name|cvmx_twsix_write_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|,
name|ctl_reg
operator|.
name|u8
argument_list|)
expr_stmt|;
comment|/* wait for  twsi_ctl[iflg] to be set */
if|if
condition|(
name|cvmx_twsi_wait_iflg
argument_list|(
name|twsi_id
argument_list|)
condition|)
goto|goto
name|stop
goto|;
comment|/* Write 7-bit addr to twsi_data; set read bit */
name|addr
operator|.
name|s
operator|.
name|slave_addr7
operator|=
name|msg
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|is_read
condition|)
name|addr
operator|.
name|s
operator|.
name|r
operator|=
literal|1
expr_stmt|;
else|else
name|addr
operator|.
name|s
operator|.
name|r
operator|=
literal|0
expr_stmt|;
name|stat
operator|.
name|s
operator|.
name|stat
operator|=
name|octeon_twsi_write_byte
argument_list|(
name|twsi_id
argument_list|,
name|addr
operator|.
name|u8
argument_list|)
expr_stmt|;
comment|/* Data read loop */
if|if
condition|(
name|is_read
condition|)
block|{
comment|/* any status but ACK_RXED means failure - we try to send stop and go idle */
if|if
condition|(
operator|!
operator|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|==
name|TWSI_ADDR_R_TX_ACK_RXED
operator|)
condition|)
block|{
name|ret
operator|=
name|stat
operator|.
name|s
operator|.
name|stat
expr_stmt|;
name|msg
operator|->
name|len
operator|=
literal|0
expr_stmt|;
goto|goto
name|stop
goto|;
block|}
comment|/* We read data from the buffer and send ACK back.        The last byte we read with negative ACK */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|len
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|stat
operator|.
name|s
operator|.
name|stat
operator|=
name|octeon_twsi_read_byte
argument_list|(
name|twsi_id
argument_list|,
operator|&
name|msg
operator|->
name|buf
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|!=
name|TWSI_DATA_RX_ACK_TXED
condition|)
goto|goto
name|stop
goto|;
block|}
comment|/* last read we send negACK */
name|stat
operator|.
name|s
operator|.
name|stat
operator|=
name|octeon_twsi_read_byte
argument_list|(
name|twsi_id
argument_list|,
operator|&
name|msg
operator|->
name|buf
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|!=
name|TWSI_DATA_RX_NACK_TXED
condition|)
return|return
name|stat
operator|.
name|s
operator|.
name|stat
return|;
block|}
comment|/* read loop */
comment|/* Data write loop */
else|else
block|{
comment|/* any status but ACK_RXED means failure - we try to send stop and go idle */
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|!=
name|TWSI_ADDR_W_TX_ACK_RXED
condition|)
block|{
name|ret
operator|=
name|stat
operator|.
name|s
operator|.
name|stat
expr_stmt|;
name|msg
operator|->
name|len
operator|=
literal|0
expr_stmt|;
goto|goto
name|stop
goto|;
block|}
comment|/* We write data to the buffer and check for ACK. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|msg
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|stat
operator|.
name|s
operator|.
name|stat
operator|=
name|octeon_twsi_write_byte
argument_list|(
name|twsi_id
argument_list|,
name|msg
operator|->
name|buf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|==
name|TWSI_DATA_TX_NACK_RXED
condition|)
block|{
comment|/* Negative ACK means slave can not RX more */
name|msg
operator|->
name|len
operator|=
name|i
operator|-
literal|1
expr_stmt|;
goto|goto
name|stop
goto|;
block|}
elseif|else
if|if
condition|(
name|stat
operator|.
name|s
operator|.
name|stat
operator|!=
name|TWSI_DATA_TX_ACK_RXED
condition|)
block|{
comment|/* lost arbitration? try to send stop and go idle. This current byte likely was not written */
name|msg
operator|->
name|len
operator|=
operator|(
name|i
operator|-
literal|2
operator|)
operator|>
literal|0
condition|?
operator|(
name|i
operator|-
literal|2
operator|)
else|:
literal|0
expr_stmt|;
goto|goto
name|stop
goto|;
block|}
block|}
block|}
comment|/* write loop */
name|stop
label|:
name|ctl_reg
operator|.
name|u8
operator|=
name|cvmx_twsix_read_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|)
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|stp
operator|=
literal|1
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|iflg
operator|=
literal|0
expr_stmt|;
name|cvmx_twsix_write_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|,
name|ctl_reg
operator|.
name|u8
argument_list|)
expr_stmt|;
comment|/* wait for  twsi_ctl[stp] to clear */
name|cvmx_twsi_wait_stop
argument_list|(
name|twsi_id
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|stat.u8 = cvmx_twsix_read_ctr(twsi_id, TWSI_STAT_REG);     if(stat.s.stat == TWSI_IDLE)
endif|#
directive|endif
comment|/* Leave TWSI core with HLC eabled */
block|{
name|ctl_reg
operator|.
name|u8
operator|=
literal|0
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|ce
operator|=
literal|1
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|enab
operator|=
literal|1
expr_stmt|;
name|ctl_reg
operator|.
name|s
operator|.
name|aak
operator|=
literal|1
expr_stmt|;
name|cvmx_twsix_write_ctr
argument_list|(
name|twsi_id
argument_list|,
name|TWSI_CTL_REG
argument_list|,
name|ctl_reg
operator|.
name|u8
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

end_unit

