begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Support library for the hardware work queue timers.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-tim.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_comment
comment|/* CSR typedefs have been moved to cvmx-tim-defs.h */
end_comment

begin_comment
comment|/**  * Global structure holding the state of all timers.  */
end_comment

begin_decl_stmt
name|CVMX_SHARED
name|cvmx_tim_t
name|cvmx_tim
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_TIMER_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * Setup a timer for use. Must be called before the timer  * can be used.  *  * @param tick      Time between each bucket in microseconds. This must not be  *                  smaller than 1024/(clock frequency in MHz).  * @param max_ticks The maximum number of ticks the timer must be able  *                  to schedule in the future. There are guaranteed to be enough  *                  timer buckets such that:  *                  number of buckets>= max_ticks.  * @return Zero on success. Negative on error. Failures are possible  *         if the number of buckets needed is too large or memory  *         allocation fails for creating the buckets.  */
end_comment

begin_function
name|int
name|cvmx_tim_setup
parameter_list|(
name|uint64_t
name|tick
parameter_list|,
name|uint64_t
name|max_ticks
parameter_list|)
block|{
name|uint64_t
name|timer_id
decl_stmt|;
name|int
name|error
init|=
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|tim_clock_hz
init|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_TIM
argument_list|)
decl_stmt|;
name|uint64_t
name|hw_tick_ns
decl_stmt|;
name|uint64_t
name|hw_tick_ns_allowed
decl_stmt|;
name|uint64_t
name|tick_ns
init|=
literal|1000
operator|*
name|tick
decl_stmt|;
name|int
name|i
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|int
name|timer_thr
init|=
literal|1024
decl_stmt|;
comment|/* for the simulator */
if|if
condition|(
name|tim_clock_hz
operator|==
literal|0
condition|)
name|tim_clock_hz
operator|=
literal|800000000
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_tim_fr_rn_tt_t
name|fr_tt
decl_stmt|;
name|fr_tt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_FR_RN_TT
argument_list|)
expr_stmt|;
name|timer_thr
operator|=
name|fr_tt
operator|.
name|s
operator|.
name|fr_rn_tt
expr_stmt|;
block|}
name|hw_tick_ns
operator|=
name|timer_thr
operator|*
literal|1000000000ull
operator|/
name|tim_clock_hz
expr_stmt|;
comment|/*      * Double the minimal allowed tick to 2 * HW tick.  tick between      * (hw_tick_ns, 2*hw_tick_ns) will set config_ring1.s.interval      * to zero, or 1024 cycles. This is not enough time for the timer unit      * to fetch the bucket data, Resulting in timer ring error interrupt      * be always generated. Avoid such setting in software.      */
name|hw_tick_ns_allowed
operator|=
name|hw_tick_ns
operator|*
literal|2
expr_stmt|;
comment|/* Make sure the timers are stopped */
name|cvmx_tim_stop
argument_list|()
expr_stmt|;
comment|/* Reinitialize out timer state */
name|memset
argument_list|(
operator|&
name|cvmx_tim
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_tim
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tick_ns
operator|<
name|hw_tick_ns_allowed
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_tim_setup: Requested tick %lu(ns) is smaller than"
literal|" the minimal ticks allowed by hardware %lu(ns)\n"
argument_list|,
name|tick_ns
argument_list|,
name|hw_tick_ns_allowed
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
elseif|else
if|if
condition|(
name|tick_ns
operator|>
literal|4194304
operator|*
name|hw_tick_ns
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_tim_setup: Requested tick %lu(ns) is greater than"
literal|" the max ticks %lu(ns)\n"
argument_list|,
name|tick_ns
argument_list|,
name|hw_tick_ns
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
literal|20
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|tick_ns
operator|<
operator|(
name|hw_tick_ns
operator|<<
name|i
operator|)
condition|)
break|break;
block|}
name|cvmx_tim
operator|.
name|max_ticks
operator|=
operator|(
name|uint32_t
operator|)
name|max_ticks
expr_stmt|;
name|cvmx_tim
operator|.
name|bucket_shift
operator|=
call|(
name|uint32_t
call|)
argument_list|(
name|i
operator|-
literal|1
operator|+
literal|10
argument_list|)
expr_stmt|;
name|cvmx_tim
operator|.
name|tick_cycles
operator|=
name|tick
operator|*
name|tim_clock_hz
operator|/
literal|1000000
expr_stmt|;
name|temp
operator|=
operator|(
name|max_ticks
operator|*
name|cvmx_tim
operator|.
name|tick_cycles
operator|)
operator|>>
name|cvmx_tim
operator|.
name|bucket_shift
expr_stmt|;
comment|/* round up to nearest power of 2 */
name|temp
operator|-=
literal|1
expr_stmt|;
name|temp
operator|=
name|temp
operator||
operator|(
name|temp
operator|>>
literal|1
operator|)
expr_stmt|;
name|temp
operator|=
name|temp
operator||
operator|(
name|temp
operator|>>
literal|2
operator|)
expr_stmt|;
name|temp
operator|=
name|temp
operator||
operator|(
name|temp
operator|>>
literal|4
operator|)
expr_stmt|;
name|temp
operator|=
name|temp
operator||
operator|(
name|temp
operator|>>
literal|8
operator|)
expr_stmt|;
name|temp
operator|=
name|temp
operator||
operator|(
name|temp
operator|>>
literal|16
operator|)
expr_stmt|;
name|cvmx_tim
operator|.
name|num_buckets
operator|=
name|temp
operator|+
literal|1
expr_stmt|;
comment|/* ensure input params fall into permitted ranges */
if|if
condition|(
operator|(
name|cvmx_tim
operator|.
name|num_buckets
operator|<
literal|3
operator|)
operator|||
name|cvmx_tim
operator|.
name|num_buckets
operator|>
literal|1048576
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_tim_setup: num_buckets out of range\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
comment|/* Allocate the timer buckets from hardware addressable memory */
name|cvmx_tim
operator|.
name|bucket
operator|=
name|cvmx_bootmem_alloc
argument_list|(
name|CVMX_TIM_NUM_TIMERS
operator|*
name|cvmx_tim
operator|.
name|num_buckets
operator|*
sizeof|sizeof
argument_list|(
name|cvmx_tim_bucket_entry_t
argument_list|)
argument_list|,
name|CVMX_CACHE_LINE_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_tim
operator|.
name|bucket
operator|==
name|NULL
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_tim_setup: allocation problem\n"
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
name|memset
argument_list|(
name|cvmx_tim
operator|.
name|bucket
argument_list|,
literal|0
argument_list|,
name|CVMX_TIM_NUM_TIMERS
operator|*
name|cvmx_tim
operator|.
name|num_buckets
operator|*
sizeof|sizeof
argument_list|(
name|cvmx_tim_bucket_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_tim
operator|.
name|start_time
operator|=
literal|0
expr_stmt|;
comment|/* Loop through all timers */
for|for
control|(
name|timer_id
operator|=
literal|0
init|;
name|timer_id
operator|<
name|CVMX_TIM_NUM_TIMERS
condition|;
name|timer_id
operator|++
control|)
block|{
name|int
name|interval
init|=
operator|(
operator|(
literal|1
operator|<<
operator|(
name|cvmx_tim
operator|.
name|bucket_shift
operator|-
literal|10
operator|)
operator|)
operator|-
literal|1
operator|)
decl_stmt|;
name|cvmx_tim_bucket_entry_t
modifier|*
name|bucket
init|=
name|cvmx_tim
operator|.
name|bucket
operator|+
name|timer_id
operator|*
name|cvmx_tim
operator|.
name|num_buckets
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_tim_ringx_ctl0_t
name|ring_ctl0
decl_stmt|;
name|cvmx_tim_ringx_ctl1_t
name|ring_ctl1
decl_stmt|;
name|cvmx_tim_ringx_ctl2_t
name|ring_ctl2
decl_stmt|;
name|cvmx_tim_reg_flags_t
name|reg_flags
decl_stmt|;
comment|/* Tell the hardware where about the bucket array */
name|ring_ctl2
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ring_ctl2
operator|.
name|s
operator|.
name|csize
operator|=
name|CVMX_FPA_TIMER_POOL_SIZE
operator|/
literal|8
expr_stmt|;
name|ring_ctl2
operator|.
name|s
operator|.
name|base
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|bucket
argument_list|)
operator|>>
literal|5
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_RINGX_CTL2
argument_list|(
name|timer_id
argument_list|)
argument_list|,
name|ring_ctl2
operator|.
name|u64
argument_list|)
expr_stmt|;
name|reg_flags
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_REG_FLAGS
argument_list|)
expr_stmt|;
name|ring_ctl1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ring_ctl1
operator|.
name|s
operator|.
name|cpool
operator|=
operator|(
operator|(
name|reg_flags
operator|.
name|s
operator|.
name|ena_dfb
operator|==
literal|0
operator|)
condition|?
name|CVMX_FPA_TIMER_POOL
else|:
literal|0
operator|)
expr_stmt|;
name|ring_ctl1
operator|.
name|s
operator|.
name|bsize
operator|=
name|cvmx_tim
operator|.
name|num_buckets
operator|-
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_RINGX_CTL1
argument_list|(
name|timer_id
argument_list|)
argument_list|,
name|ring_ctl1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ring_ctl0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ring_ctl0
operator|.
name|s
operator|.
name|timercount
operator|=
name|interval
operator|+
name|timer_id
operator|*
name|interval
operator|/
name|CVMX_TIM_NUM_TIMERS
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_RINGX_CTL0
argument_list|(
name|timer_id
argument_list|)
argument_list|,
name|ring_ctl0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ring_ctl0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_RINGX_CTL0
argument_list|(
name|timer_id
argument_list|)
argument_list|)
expr_stmt|;
name|ring_ctl0
operator|.
name|s
operator|.
name|ena
operator|=
literal|1
expr_stmt|;
name|ring_ctl0
operator|.
name|s
operator|.
name|interval
operator|=
name|interval
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_RINGX_CTL0
argument_list|(
name|timer_id
argument_list|)
argument_list|,
name|ring_ctl0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ring_ctl0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_RINGX_CTL0
argument_list|(
name|timer_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_tim_mem_ring0_t
name|config_ring0
decl_stmt|;
name|cvmx_tim_mem_ring1_t
name|config_ring1
decl_stmt|;
comment|/* Tell the hardware where about the bucket array */
name|config_ring0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|config_ring0
operator|.
name|s
operator|.
name|first_bucket
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|bucket
argument_list|)
operator|>>
literal|5
expr_stmt|;
name|config_ring0
operator|.
name|s
operator|.
name|num_buckets
operator|=
name|cvmx_tim
operator|.
name|num_buckets
operator|-
literal|1
expr_stmt|;
name|config_ring0
operator|.
name|s
operator|.
name|ring
operator|=
name|timer_id
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_MEM_RING0
argument_list|,
name|config_ring0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Tell the hardware the size of each chunk block in pointers */
name|config_ring1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|config_ring1
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|config_ring1
operator|.
name|s
operator|.
name|pool
operator|=
name|CVMX_FPA_TIMER_POOL
expr_stmt|;
name|config_ring1
operator|.
name|s
operator|.
name|words_per_chunk
operator|=
name|CVMX_FPA_TIMER_POOL_SIZE
operator|/
literal|8
expr_stmt|;
name|config_ring1
operator|.
name|s
operator|.
name|interval
operator|=
name|interval
expr_stmt|;
name|config_ring1
operator|.
name|s
operator|.
name|ring
operator|=
name|timer_id
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_MEM_RING1
argument_list|,
name|config_ring1
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Start the hardware timer processing  */
end_comment

begin_function
name|void
name|cvmx_tim_start
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_tim_control_t
name|control
decl_stmt|;
name|control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_REG_FLAGS
argument_list|)
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|enable_dwb
operator|=
literal|1
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|enable_timers
operator|=
literal|1
expr_stmt|;
comment|/* Remember when we started the timers */
name|cvmx_tim
operator|.
name|start_time
operator|=
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_TIM
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_REG_FLAGS
argument_list|,
name|control
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Stop the hardware timer processing. Timers stay configured.  */
end_comment

begin_function
name|void
name|cvmx_tim_stop
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_tim_control_t
name|control
decl_stmt|;
name|control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TIM_REG_FLAGS
argument_list|)
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|enable_dwb
operator|=
literal|0
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|enable_timers
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TIM_REG_FLAGS
argument_list|,
name|control
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Stop the timer. After this the timer must be setup again  * before use.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_TIMER_FUNCTIONS
end_ifdef

begin_function
name|void
name|cvmx_tim_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|bucket
decl_stmt|;
name|uint64_t
name|timer_id
decl_stmt|;
name|uint64_t
name|entries_per_chunk
decl_stmt|;
comment|/* Make sure the timers are stopped */
name|cvmx_tim_stop
argument_list|()
expr_stmt|;
name|entries_per_chunk
operator|=
name|CVMX_FPA_TIMER_POOL_SIZE
operator|/
literal|8
operator|-
literal|1
expr_stmt|;
comment|/* Now walk all buckets freeing the chunks */
for|for
control|(
name|timer_id
operator|=
literal|0
init|;
name|timer_id
operator|<
name|CVMX_TIM_NUM_TIMERS
condition|;
name|timer_id
operator|++
control|)
block|{
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|cvmx_tim
operator|.
name|num_buckets
condition|;
name|bucket
operator|++
control|)
block|{
name|uint64_t
name|chunk_addr
decl_stmt|;
name|uint64_t
name|next_chunk_addr
decl_stmt|;
name|cvmx_tim_bucket_entry_t
modifier|*
name|bucket_ptr
init|=
name|cvmx_tim
operator|.
name|bucket
operator|+
name|timer_id
operator|*
name|cvmx_tim
operator|.
name|num_buckets
operator|+
name|bucket
decl_stmt|;
name|CVMX_PREFETCH128
argument_list|(
name|CAST64
argument_list|(
name|bucket_ptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prefetch the next cacheline for future buckets */
comment|/* Each bucket contains a list of chunks */
name|chunk_addr
operator|=
name|bucket_ptr
operator|->
name|first_chunk_addr
expr_stmt|;
while|while
condition|(
name|bucket_ptr
operator|->
name|num_entries
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"Freeing Timer Chunk 0x%llx\n"
argument_list|,
name|CAST64
argument_list|(
name|chunk_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Read next chunk pointer from end of the current chunk */
name|next_chunk_addr
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|chunk_addr
operator|+
name|CVMX_FPA_TIMER_POOL_SIZE
operator|-
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_fpa_free
argument_list|(
name|cvmx_phys_to_ptr
argument_list|(
name|chunk_addr
argument_list|)
argument_list|,
name|CVMX_FPA_TIMER_POOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|chunk_addr
operator|=
name|next_chunk_addr
expr_stmt|;
if|if
condition|(
name|bucket_ptr
operator|->
name|num_entries
operator|>
name|entries_per_chunk
condition|)
name|bucket_ptr
operator|->
name|num_entries
operator|-=
name|entries_per_chunk
expr_stmt|;
else|else
name|bucket_ptr
operator|->
name|num_entries
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

