begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Implementation of spinlocks.  *  *<hr>$Revision: 49448 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SPINLOCK_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SPINLOCK_H__
end_define

begin_include
include|#
directive|include
file|"cvmx-asm.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* Spinlocks for Octeon */
comment|// define these to enable recursive spinlock debugging
comment|//#define CVMX_SPINLOCK_DEBUG
comment|/**  * Spinlocks for Octeon  */
typedef|typedef
struct|struct
block|{
specifier|volatile
name|uint32_t
name|value
decl_stmt|;
block|}
name|cvmx_spinlock_t
typedef|;
comment|// note - macros not expanded in inline ASM, so values hardcoded
define|#
directive|define
name|CVMX_SPINLOCK_UNLOCKED_VAL
value|0
define|#
directive|define
name|CVMX_SPINLOCK_LOCKED_VAL
value|1
define|#
directive|define
name|CVMX_SPINLOCK_UNLOCKED_INITIALIZER
value|{CVMX_SPINLOCK_UNLOCKED_VAL}
comment|/**  * Initialize a spinlock  *  * @param lock   Lock to initialize  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_init
parameter_list|(
name|cvmx_spinlock_t
modifier|*
name|lock
parameter_list|)
block|{
name|lock
operator|->
name|value
operator|=
name|CVMX_SPINLOCK_UNLOCKED_VAL
expr_stmt|;
block|}
comment|/**  * Return non-zero if the spinlock is currently locked  *  * @param lock   Lock to check  * @return Non-zero if locked  */
specifier|static
specifier|inline
name|int
name|cvmx_spinlock_locked
parameter_list|(
name|cvmx_spinlock_t
modifier|*
name|lock
parameter_list|)
block|{
return|return
operator|(
name|lock
operator|->
name|value
operator|!=
name|CVMX_SPINLOCK_UNLOCKED_VAL
operator|)
return|;
block|}
comment|/**  * Releases lock  *  * @param lock   pointer to lock structure  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_unlock
parameter_list|(
name|cvmx_spinlock_t
modifier|*
name|lock
parameter_list|)
block|{
name|CVMX_SYNCWS
expr_stmt|;
name|lock
operator|->
name|value
operator|=
literal|0
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
block|}
comment|/**  * Attempts to take the lock, but does not spin if lock is not available.  * May take some time to acquire the lock even if it is available  * due to the ll/sc not succeeding.  *  * @param lock   pointer to lock structure  *  * @return 0: lock successfully taken  *         1: lock not taken, held by someone else  * These return values match the Linux semantics.  */
specifier|static
specifier|inline
name|unsigned
name|int
name|cvmx_spinlock_trylock
parameter_list|(
name|cvmx_spinlock_t
modifier|*
name|lock
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|(     ".set noreorder         \n"     "1: ll   %[tmp], %[val] \n"     "   bnez %[tmp], 2f     \n"
comment|// if lock held, fail immediately
asm|"   li   %[tmp], 1      \n"     "   sc   %[tmp], %[val] \n"     "   beqz %[tmp], 1b     \n"     "   li   %[tmp], 0      \n"     "2:                     \n"     ".set reorder           \n"     : [val] "+m" (lock->value), [tmp] "=&r" (tmp)     :     : "memory");
return|return
operator|(
operator|!
operator|!
name|tmp
operator|)
return|;
comment|/* normalize to 0 or 1 */
block|}
comment|/**  * Gets lock, spins until lock is taken  *  * @param lock   pointer to lock structure  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_lock
parameter_list|(
name|cvmx_spinlock_t
modifier|*
name|lock
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|(     ".set noreorder         \n"     "1: ll   %[tmp], %[val]  \n"     "   bnez %[tmp], 1b     \n"     "   li   %[tmp], 1      \n"     "   sc   %[tmp], %[val] \n"     "   beqz %[tmp], 1b     \n"     "   nop                \n"     ".set reorder           \n"     : [val] "+m" (lock->value), [tmp] "=&r" (tmp)     :     : "memory");
block|}
comment|/** ********************************************************************  * Bit spinlocks  * These spinlocks use a single bit (bit 31) of a 32 bit word for locking.  * The rest of the bits in the word are left undisturbed.  This enables more  * compact data structures as only 1 bit is consumed for the lock.  *  */
comment|/**  * Gets lock, spins until lock is taken  * Preserves the low 31 bits of the 32 bit  * word used for the lock.  *  *  * @param word  word to lock bit 31 of  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_bit_lock
parameter_list|(
name|uint32_t
modifier|*
name|word
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
name|unsigned
name|int
name|sav
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|(     ".set noreorder         \n"     ".set noat              \n"     "1: ll    %[tmp], %[val]  \n"     "   bbit1 %[tmp], 31, 1b    \n"     "   li    $at, 1      \n"     "   ins   %[tmp], $at, 31, 1  \n"     "   sc    %[tmp], %[val] \n"     "   beqz  %[tmp], 1b     \n"     "   nop                \n"     ".set at              \n"     ".set reorder           \n"     : [val] "+m" (*word), [tmp] "=&r" (tmp), [sav] "=&r" (sav)     :     : "memory");
block|}
comment|/**  * Attempts to get lock, returns immediately with success/failure  * Preserves the low 31 bits of the 32 bit  * word used for the lock.  *  *  * @param word  word to lock bit 31 of  * @return 0: lock successfully taken  *         1: lock not taken, held by someone else  * These return values match the Linux semantics.  */
specifier|static
specifier|inline
name|unsigned
name|int
name|cvmx_spinlock_bit_trylock
parameter_list|(
name|uint32_t
modifier|*
name|word
parameter_list|)
block|{
name|unsigned
name|int
name|tmp
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|(     ".set noreorder         \n"     ".set noat              \n"     "1: ll    %[tmp], %[val] \n"     "   bbit1 %[tmp], 31, 2f     \n"
comment|// if lock held, fail immediately
asm|"   li    $at, 1      \n"     "   ins   %[tmp], $at, 31, 1  \n"     "   sc    %[tmp], %[val] \n"     "   beqz  %[tmp], 1b     \n"     "   li    %[tmp], 0      \n"     "2:                     \n"     ".set at              \n"     ".set reorder           \n"     : [val] "+m" (*word), [tmp] "=&r" (tmp)     :     : "memory");
return|return
operator|(
operator|!
operator|!
name|tmp
operator|)
return|;
comment|/* normalize to 0 or 1 */
block|}
comment|/**  * Releases bit lock  *  * Unconditionally clears bit 31 of the lock word.  Note that this is  * done non-atomically, as this implementation assumes that the rest  * of the bits in the word are protected by the lock.  *  * @param word  word to unlock bit 31 in  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_bit_unlock
parameter_list|(
name|uint32_t
modifier|*
name|word
parameter_list|)
block|{
name|CVMX_SYNCWS
expr_stmt|;
operator|*
name|word
operator|&=
operator|~
operator|(
literal|1UL
operator|<<
literal|31
operator|)
expr_stmt|;
name|CVMX_SYNCWS
expr_stmt|;
block|}
comment|/** ********************************************************************  * Recursive spinlocks  */
typedef|typedef
struct|struct
block|{
specifier|volatile
name|unsigned
name|int
name|value
decl_stmt|;
specifier|volatile
name|unsigned
name|int
name|core_num
decl_stmt|;
block|}
name|cvmx_spinlock_rec_t
typedef|;
comment|/**  * Initialize a recursive spinlock  *  * @param lock   Lock to initialize  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_rec_init
parameter_list|(
name|cvmx_spinlock_rec_t
modifier|*
name|lock
parameter_list|)
block|{
name|lock
operator|->
name|value
operator|=
name|CVMX_SPINLOCK_UNLOCKED_VAL
expr_stmt|;
block|}
comment|/**  * Return non-zero if the recursive spinlock is currently locked  *  * @param lock   Lock to check  * @return Non-zero if locked  */
specifier|static
specifier|inline
name|int
name|cvmx_spinlock_rec_locked
parameter_list|(
name|cvmx_spinlock_rec_t
modifier|*
name|lock
parameter_list|)
block|{
return|return
operator|(
name|lock
operator|->
name|value
operator|!=
name|CVMX_SPINLOCK_UNLOCKED_VAL
operator|)
return|;
block|}
comment|/** * Unlocks one level of recursive spinlock.  Lock is not unlocked * unless this is the final unlock call for that spinlock * * @param lock   ptr to recursive spinlock structure */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_rec_unlock
parameter_list|(
name|cvmx_spinlock_rec_t
modifier|*
name|lock
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|CVMX_SPINLOCK_DEBUG
define|#
directive|define
name|cvmx_spinlock_rec_unlock
parameter_list|(
name|x
parameter_list|)
value|_int_cvmx_spinlock_rec_unlock((x), __FILE__, __LINE__)
specifier|static
specifier|inline
name|void
name|_int_cvmx_spinlock_rec_unlock
argument_list|(
name|cvmx_spinlock_rec_t
operator|*
name|lock
argument_list|,
name|char
operator|*
name|filename
argument_list|,
name|int
name|linenum
argument_list|)
else|#
directive|else
decl|static
specifier|inline
namespace|void
name|cvmx_spinlock_rec_unlock
namespace|(
name|cvmx_spinlock_rec_t
modifier|*
name|lock
decl_stmt|)
endif|#
directive|endif
block|{
name|unsigned
name|int
name|temp
decl_stmt|,
name|result
decl_stmt|;
name|int
name|core_num
decl_stmt|;
name|core_num
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_SPINLOCK_DEBUG
block|{
if|if
condition|(
name|lock
operator|->
name|core_num
operator|!=
name|core_num
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Recursive spinlock release attemped by non-owner! file: %s, line: %d\n"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
endif|#
directive|endif
asm|__asm__
specifier|__volatile__
asm|( 		".set  noreorder                 \n" 		"     addi  %[tmp], %[pid], 0x80 \n" 		"     sw    %[tmp], %[lid]       # set lid to invalid value\n"                 CVMX_SYNCWS_STR 		"1:   ll    %[tmp], %[val]       \n" 		"     addu  %[res], %[tmp], -1   # decrement lock count\n" 		"     sc    %[res], %[val]       \n" 		"     beqz  %[res], 1b           \n" 		"     nop                        \n" 		"     beq   %[tmp], %[res], 2f   # res is 1 on successful sc       \n" 		"     nop                        \n" 		"     sw   %[pid], %[lid]        # set lid to pid, only if lock still held\n" 		"2:                         \n"                 CVMX_SYNCWS_STR 		".set  reorder                   \n" 		: [res] "=&r" (result), [tmp] "=&r" (temp), [val] "+m" (lock->value), [lid] "+m" (lock->core_num) 		: [pid] "r" (core_num) 		: "memory");
ifdef|#
directive|ifdef
name|CVMX_SPINLOCK_DEBUG
block|{
if|if
condition|(
name|lock
operator|->
name|value
operator|==
operator|~
literal|0UL
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Recursive spinlock released too many times! file: %s, line: %d\n"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/**  * Takes recursive spinlock for a given core.  A core can take the lock multiple  * times, and the lock is released only when the corresponding number of  * unlocks have taken place.  *  * NOTE: This assumes only one thread per core, and that the core ID is used as  * the lock 'key'.  (This implementation cannot be generalized to allow  * multiple threads to use the same key (core id) .)  *  * @param lock   address of recursive spinlock structure.  Note that this is  *               distinct from the standard spinlock  */
specifier|static
specifier|inline
name|void
name|cvmx_spinlock_rec_lock
parameter_list|(
name|cvmx_spinlock_rec_t
modifier|*
name|lock
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|CVMX_SPINLOCK_DEBUG
define|#
directive|define
name|cvmx_spinlock_rec_lock
parameter_list|(
name|x
parameter_list|)
value|_int_cvmx_spinlock_rec_lock((x), __FILE__, __LINE__)
specifier|static
specifier|inline
name|void
name|_int_cvmx_spinlock_rec_lock
argument_list|(
name|cvmx_spinlock_rec_t
operator|*
name|lock
argument_list|,
name|char
operator|*
name|filename
argument_list|,
name|int
name|linenum
argument_list|)
else|#
directive|else
decl|static
specifier|inline
namespace|void
name|cvmx_spinlock_rec_lock
namespace|(
name|cvmx_spinlock_rec_t
modifier|*
name|lock
decl_stmt|)
endif|#
directive|endif
block|{
specifier|volatile
name|unsigned
name|int
name|tmp
decl_stmt|;
specifier|volatile
name|int
name|core_num
decl_stmt|;
name|core_num
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
asm|__asm__
specifier|__volatile__
asm|( 		".set  noreorder              \n" 		"1: ll   %[tmp], %[val]       # load the count\n" 		"   bnez %[tmp], 2f           # if count!=zero branch to 2\n" 		"   addu %[tmp], %[tmp], 1    \n" 		"   sc   %[tmp], %[val]       \n" 		"   beqz %[tmp], 1b           # go back if not success\n" 		"   nop                       \n" 		"   j    3f                   # go to write core_num \n" 		"2: lw   %[tmp], %[lid]       # load the core_num \n" 		"   bne  %[tmp], %[pid], 1b   # core_num no match, restart\n" 		"   nop                       \n" 		"   lw   %[tmp], %[val]       \n" 		"   addu %[tmp], %[tmp], 1    \n" 		"   sw   %[tmp], %[val]       # update the count\n" 		"3: sw   %[pid], %[lid]       # store the core_num\n"                 CVMX_SYNCWS_STR 		".set  reorder                \n" 		: [tmp] "=&r" (tmp), [val] "+m" (lock->value), [lid] "+m" (lock->core_num) 		: [pid] "r" (core_num) 		: "memory");
ifdef|#
directive|ifdef
name|CVMX_SPINLOCK_DEBUG
if|if
condition|(
name|lock
operator|->
name|core_num
operator|!=
name|core_num
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_spinlock_rec_lock: lock taken, but core_num is incorrect. file: %s, line: %d\n"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CVMX_SPINLOCK_H__ */
end_comment

end_unit

