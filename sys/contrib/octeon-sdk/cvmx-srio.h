begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to SRIO  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_SRIO_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_SRIO_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/**  * Enumeration of the type of operations that can be performed  * by a mapped write operation.  */
typedef|typedef
enum|enum
block|{
name|CVMX_SRIO_WRITE_MODE_NWRITE
init|=
literal|0
block|,
comment|/**< Only create NWrite operations */
name|CVMX_SRIO_WRITE_MODE_NWRITE_RESP
init|=
literal|1
block|,
comment|/**< Create NWrite with response */
name|CVMX_SRIO_WRITE_MODE_AUTO
init|=
literal|2
block|,
comment|/**< Intelligently breaks writes into multiple transactions based on alignment */
name|CVMX_SRIO_WRITE_MODE_AUTO_RESP
init|=
literal|3
block|,
comment|/**< CVMX_SRIO_WRITE_MODE_WRITE followed with a response */
name|CVMX_SRIO_WRITE_MODE_MAINTENANCE
init|=
literal|6
block|,
comment|/**< Create a MAINTENANCE transaction. Use cvmx_srio_config_write32() instead */
name|CVMX_SRIO_WRITE_MODE_PORT
init|=
literal|7
comment|/**< Port Write? */
block|}
name|cvmx_srio_write_mode_t
typedef|;
comment|/**  * Enumeration of the type of operations that can be performed  * by a mapped read operation.  */
typedef|typedef
enum|enum
block|{
name|CVMX_SRIO_READ_MODE_NORMAL
init|=
literal|0
block|,
comment|/**< Perform a normal read */
name|CVMX_SRIO_READ_MODE_ATOMIC_SET
init|=
literal|2
block|,
comment|/**< Atomically sets bits in data on remote device */
name|CVMX_SRIO_READ_MODE_ATOMIC_CLEAR
init|=
literal|3
block|,
comment|/**< Atomically clears bits in data on remote device */
name|CVMX_SRIO_READ_MODE_ATOMIC_INCREMENT
init|=
literal|4
block|,
comment|/**< Atomically increments data on remote device */
name|CVMX_SRIO_READ_MODE_ATOMIC_DECREMENT
init|=
literal|5
block|,
comment|/**< Atomically decrements data on remote device */
name|CVMX_SRIO_READ_MODE_MAINTENANCE
init|=
literal|6
comment|/**< Create a MAINTENANCE transaction. Use cvmx_srio_config_read32() instead */
block|}
name|cvmx_srio_read_mode_t
typedef|;
comment|/**  * Initialization flags for SRIO  */
typedef|typedef
enum|enum
block|{
name|CVMX_SRIO_INITIALIZE_DEBUG
init|=
literal|1
block|, }
name|cvmx_srio_initialize_flags_t
typedef|;
comment|/**  * The possible results from a doorbell operation  */
typedef|typedef
enum|enum
block|{
name|CVMX_SRIO_DOORBELL_DONE
block|,
comment|/**< The doorbell is complete */
name|CVMX_SRIO_DOORBELL_NONE
block|,
comment|/**< There wasn't an outstanding doorbell */
name|CVMX_SRIO_DOORBELL_BUSY
block|,
comment|/**< The doorbell is still processing */
name|CVMX_SRIO_DOORBELL_RETRY
block|,
comment|/**< The doorbell needs to be retried */
name|CVMX_SRIO_DOORBELL_ERROR
block|,
comment|/**< The doorbell failed with an error */
name|CVMX_SRIO_DOORBELL_TMOUT
comment|/**< The doorbell failed due to timeout */
block|}
name|cvmx_srio_doorbell_status_t
typedef|;
comment|/**  * This structure represents the SRIO header received from SRIO on  * the top of every received message. This header passes through  * IPD/PIP unmodified.  */
typedef|typedef
struct|struct
block|{
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|prio
range|:
literal|2
decl_stmt|;
comment|/**< The sRIO prio (priority) field in the                                     first sRIO message segment received for the                                     message. */
name|uint64_t
name|tt
range|:
literal|1
decl_stmt|;
comment|/**< When set, indicates that the first sRIO                                     message segment received for the message had                                     16-bit source and destination ID's. When                                     clear, indicates 8-bit ID were present. */
name|uint64_t
name|dis
range|:
literal|1
decl_stmt|;
comment|/**< When set, indicates that the destination                                     ID in the first sRIO message segment received                                     for the message matched the 63xx's secondary                                     ID. When clear, indicates that the destination                                     ID in the first sRIO message segment                                     received for the message matched the 63xx's                                     primary ID. Note that the full destination                                     ID in the received sRIO message can be                                     determined via the combination of                                     WORD0[DIS] in the sRIO inbound message                                     header and WORD1[iprt] in the work queue                                     entry created by PIP/IPD. */
name|uint64_t
name|ssize
range|:
literal|4
decl_stmt|;
comment|/**< The RIO ssize (standard message packet data                                     size) field used for the message. */
name|uint64_t
name|sid
range|:
literal|16
decl_stmt|;
comment|/**< The source ID in the first sRIO message                                     segment received for the message. When TT is                                     clear, the most-significant 8 bits are zero. */
name|uint64_t
name|xmbox
range|:
literal|4
decl_stmt|;
comment|/**< The RIO xmbox (recipient mailbox extension)                                     field in the first sRIO message segment                                     received for the message. Always zero for                                     multi-segment messages. */
name|uint64_t
name|mbox
range|:
literal|2
decl_stmt|;
comment|/**< The RIO mbox (recipient mailbox) field in                                     the first sRIO message segment received for                                     the message. */
name|uint64_t
name|letter
range|:
literal|2
decl_stmt|;
comment|/**< The RIO letter (slot within a mailbox)                                     field in the first sRIO message segment                                     received for the message. */
name|uint64_t
name|seq
range|:
literal|32
decl_stmt|;
comment|/**< A sequence number. Whenever the OCTEON                                     63xx sRIO hardware accepts the first sRIO                                     segment of either a message or doorbell, it                                     samples the current value of a counter                                     register and increments the counter                                     register. SEQ is the value sampled for the                                     message. The counter increments once per                                     message/doorbell. SEQ can be used to                                     determine the relative order of                                     packets/doorbells. Note that the SEQ-implied                                     order may differ from the order that the                                     WQE's are received by software for a number                                     of reasons, including the fact that the WQE                                     is not created until the end of the message,                                     while SEQ is sampled when the first segment. */
else|#
directive|else
name|uint64_t
name|seq
range|:
literal|32
decl_stmt|;
name|uint64_t
name|letter
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mbox
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xmbox
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|16
decl_stmt|;
name|uint64_t
name|ssize
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prio
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
block|}
name|word0
union|;
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|r
range|:
literal|1
decl_stmt|;
comment|/**< When set, WORD1[R]/PKT_INST_HDR[R] selects                                     either RAWFULL or RAWSCHED special PIP                                     instruction form. WORD1[R] may commonly be                                     set so that WORD1[QOS,GRP] will be directly                                     used by the PIP hardware. */
name|uint64_t
name|reserved_62_58
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pm
range|:
literal|2
decl_stmt|;
comment|/**< WORD1[PM]/PKT_INST_HDR[PM] selects the PIP                                     parse mode (uninterpreted, skip-to-L2,                                     skip-to-IP), and chooses between                                     RAWFULL/RAWSCHED when WORD1[R] is set. */
name|uint64_t
name|reserved_55
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sl
range|:
literal|7
decl_stmt|;
comment|/**< WORD1[SL]/PKT_INST_HDR[SL] selects the                                     skip II length. WORD1[SL] may typically be                                     set to 8 (or larger) so that PIP skips this                                     WORD1. */
name|uint64_t
name|reserved_47_46
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
comment|/**< WORD1[NQOS] must not be set when WORD1[R]                                     is clear and PIP interprets WORD1 as a                                     PKT_INST_HDR. When set, WORD1[NQOS]/PKT_INST_HDR[NQOS]                                     prevents PIP from directly using                                     WORD1[QOS]/PKT_INST_HDR[QOS] for the QOS                                     value in the work queue entry created by                                     PIP. WORD1[NQOS] may commonly be clear so                                     that WORD1[QOS] will be directly used by the                                     PIP hardware. PKT_INST_HDR[NQOS] is new to                                     63xx - this functionality did not exist in                                     prior OCTEON's. */
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
comment|/**< WORD1[NGRP] must not be set when WORD1[R]                                     is clear and PIP interprets WORD1 as a                                     PKT_INST_HDR. When set, WORD1[NGRP]/PKT_INST_HDR[NGRP]                                     prevents PIP from directly using                                     WORD1[GRP]/PKT_INST_HDR[GRP] for the GRP                                     value in the work queue entry created by                                     PIP. WORD1[NGRP] may commonly be clear so                                     that WORD1[GRP] will be directly used by the                                     PIP hardware. PKT_INST_HDR[NGRP] is new to                                     63xx - this functionality did not exist in                                     prior OCTEON's. */
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
comment|/**< WORD1[NTT] must not be set when WORD1[R]                                     is clear and PIP interprets WORD1 as a                                     PKT_INST_HDR. When set, WORD1[NTT]/PKT_INST_HDR[NTT]                                     prevents PIP from directly using                                     WORD1[TT]/PKT_INST_HDR[TT] for the TT value                                     in the work queue entry created by PIP.                                     PKT_INST_HDR[NTT] is new to 63xx - this                                     functionality did not exist in prior OCTEON's. */
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
comment|/**< WORD1[NTAG] must not be set when WORD1[R]                                     is clear and PIP interprets WORD1 as a                                     PKT_INST_HDR. When set, WORD1[NTAG]/PKT_INST_HDR[NTAG]                                     prevents PIP from directly using                                     WORD1[TAG]/PKT_INST_HDR[TAG] for the TAG                                     value in the work queue entry created by PIP.                                     PKT_INST_HDR[NTAG] is new to 63xx - this                                     functionality did not exist in prior OCTEON's. */
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
comment|/**< Created by the hardware from an entry in a                                     256-entry table. The 8-bit value                                     WORD0[PRIO,TT,DIS,MBOX,LETTER] selects the                                     table entry. When WORD1[R] is set and WORD1[NQOS]                                     is clear, WORD1[QOS] becomes the QOS value                                     in the work queue entry created by PIP. The                                     QOS value in the work queue entry determines                                     the priority that SSO/POW will schedule the                                     work, and can also control how/if the sRIO                                     message gets dropped by PIP/IPD. The 256-entry                                     table is unique to each sRIO core, but                                     shared by the two controllers associated                                     with the sRIO core. */
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
comment|/**< Created by the hardware from an entry in a                                     256-entry table. The 8-bit value                                     WORD0[PRIO,TT,DIS,MBOX,LETTER] selects the                                     table entry. When WORD1[R] is set and WORD1[NGRP]                                     is clear, WORD1[GRP] becomes the GRP value                                     in the work queue entry created by PIP. The                                     GRP value in the work queue entry can direct                                     the work to particular cores or particular                                     groups of cores. The 256-entry table is                                     unique to each sRIO core, but shared by the                                     two controllers associated with the sRIO core. */
name|uint64_t
name|rs
range|:
literal|1
decl_stmt|;
comment|/**< In some configurations, enables the sRIO                                     message to be buffered solely in the work                                     queue entry, and not otherwise in L2/DRAM. */
name|uint64_t
name|tt
range|:
literal|2
decl_stmt|;
comment|/**< When WORD1[R] is set and WORD1[NTT] is                                     clear, WORD1[TT]/PKT_INST_HDR[TT] becomes                                     the TT value in the work queue entry created                                     by PIP. The TT and TAG values in the work                                     queue entry determine the scheduling/synchronization                                     constraints for the work (no constraints,                                     tag order, atomic tag order). */
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< Created by the hardware from a CSR                                     associated with the sRIO inbound message                                     controller. When WORD1[R] is set and WORD1[NTAG]                                     is clear, WORD1[TAG]/PKT_INST_HDR[TAG]                                     becomes the TAG value in the work queue                                     entry created by PIP. The TT and TAG values                                     in the work queue entry determine the                                     scheduling/synchronization constraints for                                     the work (no constraints, tag order, atomic                                     tag order). */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rs
range|:
literal|1
decl_stmt|;
name|uint64_t
name|grp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qos
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ntag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ntt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ngrp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nqos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_47_46
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sl
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_55
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_62_58
range|:
literal|5
decl_stmt|;
name|uint64_t
name|r
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
block|}
name|word1
union|;
block|}
name|cvmx_srio_rx_message_header_t
typedef|;
comment|/**  * This structure represents the SRIO header required on the front  * of PKO packets destine for SRIO message queues.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|prio
range|:
literal|2
decl_stmt|;
comment|/**< The sRIO prio (priority) field for all                                     segments in the message. */
name|uint64_t
name|tt
range|:
literal|1
decl_stmt|;
comment|/**< When set, the sRIO message segments use a                                     16-bit source and destination ID for all the                                     segments in the message. When clear, the                                     message segments use an 8-bit ID. */
name|uint64_t
name|sis
range|:
literal|1
decl_stmt|;
comment|/**< When set, the sRIO message segments use the                                     63xx's secondary ID as the source ID. When                                     clear, the sRIO message segments use the                                     primary ID as the source ID. */
name|uint64_t
name|ssize
range|:
literal|4
decl_stmt|;
comment|/**< The RIO ssize (standard message segment                                     data size) field used for the message. */
name|uint64_t
name|did
range|:
literal|16
decl_stmt|;
comment|/**< The destination ID in the sRIO message                                     segments of the message. When TT is clear,                                     the most-significant 8 bits must be zero. */
name|uint64_t
name|xmbox
range|:
literal|4
decl_stmt|;
comment|/**< The RIO xmbox (recipient mailbox extension)                                     field in the sRIO message segment for a                                     single-segment message. Must be zero for                                     multi-segment messages. */
name|uint64_t
name|mbox
range|:
literal|2
decl_stmt|;
comment|/**< The RIO mbox (recipient mailbox) field in                                     the sRIO message segments of the message. */
name|uint64_t
name|letter
range|:
literal|2
decl_stmt|;
comment|/**< The RIO letter (slot within mailbox) field                                     in the sRIO message segments of the message                                     when LNS is clear. When LNS is set, this                                     LETTER field is not used and must be zero. */
name|uint64_t
name|reserved_31_2
range|:
literal|30
decl_stmt|;
name|uint64_t
name|lns
range|:
literal|1
decl_stmt|;
comment|/**< When set, the outbound message controller                                     will dynamically selects an sRIO letter                                     field for the message (based on LETTER_SP or                                     LETTER_MP - see appendix A), and the LETTER                                     field in this sRIO outbound message                                     descriptor is unused. When clear, the LETTER                                     field in this sRIO outbound message                                     descriptor selects the sRIO letter used for                                     the message. */
name|uint64_t
name|intr
range|:
literal|1
decl_stmt|;
comment|/**< When set, the outbound message controller                                     will set an interrupt bit after all sRIO                                     segments of the message receive a message                                     DONE response. If the message transfer has                                     errors, the interrupt bit is not set (but                                     others are). */
else|#
directive|else
name|uint64_t
name|intr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_2
range|:
literal|30
decl_stmt|;
name|uint64_t
name|letter
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mbox
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xmbox
range|:
literal|4
decl_stmt|;
name|uint64_t
name|did
range|:
literal|16
decl_stmt|;
name|uint64_t
name|ssize
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prio
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
block|}
name|cvmx_srio_tx_message_header_t
typedef|;
comment|/**  * Reset SRIO to link partner  *  * @param srio_port  SRIO port to initialize  *  * @return Zero on success  */
name|int
name|cvmx_srio_link_rst
parameter_list|(
name|int
name|srio_port
parameter_list|)
function_decl|;
comment|/**  * Initialize a SRIO port for use.  *  * @param srio_port SRIO port to initialize  * @param flags     Optional flags  *  * @return Zero on success  */
name|int
name|cvmx_srio_initialize
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_srio_initialize_flags_t
name|flags
parameter_list|)
function_decl|;
comment|/**  * Read 32bits from a Device's config space  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID, or -1 for the local Octeon.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param result    Result of the read. This will be unmodified on failure.  *  * @return Zero on success, negative on failure.  */
name|int
name|cvmx_srio_config_read32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint8_t
name|hopcount
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
function_decl|;
comment|/**  * Write 32bits to a Device's config space  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID, or -1 for the local Octeon.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param data      Data to write.  *  * @return Zero on success, negative on failure.  */
name|int
name|cvmx_srio_config_write32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint8_t
name|hopcount
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|data
parameter_list|)
function_decl|;
comment|/**  * Send a RapidIO doorbell to a remote device  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param priority  Doorbell priority (0-3)  * @param data      Data for doorbell.  *  * @return Zero on success, negative on failure.  */
name|int
name|cvmx_srio_send_doorbell
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|int
name|priority
parameter_list|,
name|uint16_t
name|data
parameter_list|)
function_decl|;
comment|/**  * Get the status of the last doorbell sent. If the dooorbell  * hardware is done, then the status is cleared to get ready for  * the next doorbell (or retry).  *  * @param srio_port SRIO port to check doorbell on  *  * @return Doorbell status  */
name|cvmx_srio_doorbell_status_t
name|cvmx_srio_send_doorbell_status
parameter_list|(
name|int
name|srio_port
parameter_list|)
function_decl|;
comment|/**  * Read a received doorbell and report data about it.  *  * @param srio_port SRIO port to check for the received doorbell  * @param destid_index  *                  Which Octeon destination ID was the doorbell for  * @param sequence_num  *                  Sequence number of doorbell (32bits)  * @param srcid     RapidIO source ID of the doorbell sender  * @param priority  Priority of the doorbell (0-3)  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param data      Data in the doorbell (16 bits)  *  * @return Doorbell status. Either DONE, NONE, or ERROR.  */
name|cvmx_srio_doorbell_status_t
name|cvmx_srio_receive_doorbell
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
modifier|*
name|destid_index
parameter_list|,
name|uint32_t
modifier|*
name|sequence_num
parameter_list|,
name|int
modifier|*
name|srcid
parameter_list|,
name|int
modifier|*
name|priority
parameter_list|,
name|int
modifier|*
name|is16bit
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
function_decl|;
comment|/**  * Receive a packet from the Soft Packet FIFO (SPF).  *  * @param srio_port SRIO port to read the packet from.  * @param buffer    Buffer to receive the packet.  * @param buffer_length  *                  Length of the buffer in bytes.  *  * @return Returns the length of the packet read. Negative on failure.  *         Zero if no packets are available.  */
name|int
name|cvmx_srio_receive_spf
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|)
function_decl|;
comment|/**  * Map a remote device's memory region into Octeon's physical  * address area. The caller can then map this into a core using  * the TLB or XKPHYS.  *  * @param srio_port SRIO port to map the device on  * @param write_op  Type of operation to perform on a write to the device.  *                  Normally should be CVMX_SRIO_WRITE_MODE_AUTO.  * @param write_priority  *                  SRIO priority of writes (0-3)  * @param read_op   Type of operation to perform on reads to the device.  *                  Normally should be CVMX_SRIO_READ_MODE_NORMAL.  * @param read_priority  *                  SRIO priority of reads (0-3)  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param base      Device base address to start the mapping  * @param size      Size of the mapping in bytes  *  * @return Octeon 64bit physical address that accesses the remote device,  *         or zero on failure.  */
name|uint64_t
name|cvmx_srio_physical_map
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_srio_write_mode_t
name|write_op
parameter_list|,
name|int
name|write_priority
parameter_list|,
name|cvmx_srio_read_mode_t
name|read_op
parameter_list|,
name|int
name|read_priority
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
comment|/**  * Unmap a physical address window created by cvmx_srio_phys_map().  *  * @param physical_address  *               Physical address returned by cvmx_srio_phys_map().  * @param size   Size used on original call.  *  * @return Zero on success, negative on failure.  */
name|int
name|cvmx_srio_physical_unmap
parameter_list|(
name|uint64_t
name|physical_address
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
comment|/**  * fill out outbound message descriptor  *  * @param buf_ptr     pointer to a buffer pointer. the buffer pointer points  *                    to a chain of buffers that hold an outbound srio packet.  *                    the packet can take the format of (1) a pip/ipd inbound  *                    message or (2) an application-generated outbound message  * @param desc_ptr    pointer to an outbound message descriptor. should be null  *                    if *buf_ptr is in the format (1)  *  * @return           0 on success; negative of failure.  */
name|int
name|cvmx_srio_omsg_desc
parameter_list|(
name|uint64_t
name|port
parameter_list|,
name|cvmx_buf_ptr_t
modifier|*
name|buf_ptr
parameter_list|,
name|cvmx_srio_tx_message_header_t
modifier|*
name|desc_ptr
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

