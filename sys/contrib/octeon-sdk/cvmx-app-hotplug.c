begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Provides APIs for applications to register for hotplug. It also provides   * APIs for requesting shutdown of a running target application.   *  *<hr>$Revision: $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-app-hotplug.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-debug.h"
end_include

begin_comment
comment|//#define DEBUG 1
end_comment

begin_decl_stmt
specifier|static
name|cvmx_app_hotplug_global_t
modifier|*
name|hotplug_global_ptr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifndef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_app_hotplug_sync_lock
init|=
block|{
name|CVMX_SPINLOCK_UNLOCKED_VAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_app_hotplug_lock
init|=
block|{
name|CVMX_SPINLOCK_UNLOCKED_VAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_app_hotplug_info_t
modifier|*
name|cvmx_app_hotplug_info_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|__cvmx_app_hotplug_shutdown
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__cvmx_app_hotplug_sync
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__cvmx_app_hotplug_reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Declaring this array here is a compile time check to ensure that the    size of  cvmx_app_hotplug_info_t is 1024. If the size is not 1024    the size of the array will be -1 and this results in a compilation    error */
end_comment

begin_decl_stmt
name|char
name|__hotplug_info_check
index|[
operator|(
sizeof|sizeof
argument_list|(
name|cvmx_app_hotplug_info_t
argument_list|)
operator|==
literal|1024
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * This routine registers an application for hotplug. It installs a handler for  * any incoming shutdown request. It also registers a callback routine from the  * application. This callback is invoked when the application receives a   * shutdown notification.   *  * This routine only needs to be called once per application.   *  * @param fn      Callback routine from the application.   * @param arg     Argument to the application callback routine.   * @return        Return 0 on success, -1 on failure  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_register
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Find the list of applications launched by bootoct utility. */
if|if
condition|(
operator|!
operator|(
name|cvmx_app_hotplug_info_ptr
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|core_mask
argument_list|)
operator|)
condition|)
block|{
comment|/* Application not launched by bootoct? */
name|printf
argument_list|(
literal|"ERROR: cmvx_app_hotplug_register() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Register the callback */
name|cvmx_app_hotplug_info_ptr
operator|->
name|data
operator|=
name|CAST64
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|->
name|shutdown_callback
operator|=
name|CAST64
argument_list|(
name|fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cvmx_app_hotplug_register(): coremask 0x%x valid %d\n"
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|coremask
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|valid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|,
name|__cvmx_app_hotplug_shutdown
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine deprecates the the cvmx_app_hotplug_register method. This  * registers application for hotplug and the application will have CPU  * hotplug callbacks. Various callbacks are specified in cb.  * cvmx_app_hotplug_callbacks_t documents the callbacks  *  * This routine only needs to be called once per application.  *  * @param cb      Callback routine from the application.  * @param arg     Argument to the application callback routins  * @param app_shutdown   When set to 1 the application will invoke core_shutdown                          on each core. When set to 0 core shutdown will be                          called invoked automatically after invoking the                          application callback.  * @return        Return index of app on success, -1 on failure  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_register_cb
parameter_list|(
name|cvmx_app_hotplug_callbacks_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|app_shutdown
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|app_info
decl_stmt|;
comment|/* Find the list of applications launched by bootoct utility. */
name|app_info
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|core_mask
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|=
name|app_info
expr_stmt|;
if|if
condition|(
operator|!
name|app_info
condition|)
block|{
comment|/* Application not launched by bootoct? */
name|printf
argument_list|(
literal|"ERROR: cmvx_app_hotplug_register() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Register the callback */
name|app_info
operator|->
name|data
operator|=
name|CAST64
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|app_info
operator|->
name|shutdown_callback
operator|=
name|CAST64
argument_list|(
name|cb
operator|->
name|shutdown_callback
argument_list|)
expr_stmt|;
name|app_info
operator|->
name|cores_added_callback
operator|=
name|CAST64
argument_list|(
name|cb
operator|->
name|cores_added_callback
argument_list|)
expr_stmt|;
name|app_info
operator|->
name|cores_removed_callback
operator|=
name|CAST64
argument_list|(
name|cb
operator|->
name|cores_removed_callback
argument_list|)
expr_stmt|;
name|app_info
operator|->
name|unplug_callback
operator|=
name|CAST64
argument_list|(
name|cb
operator|->
name|unplug_core_callback
argument_list|)
expr_stmt|;
name|app_info
operator|->
name|hotplug_start
operator|=
name|CAST64
argument_list|(
name|cb
operator|->
name|hotplug_start
argument_list|)
expr_stmt|;
name|app_info
operator|->
name|app_shutdown
operator|=
name|app_shutdown
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cvmx_app_hotplug_register(): coremask 0x%x valid %d\n"
argument_list|,
name|app_info
operator|->
name|coremask
argument_list|,
name|app_info
operator|->
name|valid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|,
name|__cvmx_app_hotplug_shutdown
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|cvmx_app_hotplug_remove_self_from_core_mask
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|uint32_t
name|core_mask
init|=
literal|1ull
operator|<<
name|core
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|->
name|coremask
operator|=
name|cvmx_app_hotplug_info_ptr
operator|->
name|coremask
operator|&
operator|~
name|core_mask
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator|=
name|cvmx_app_hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator|&
operator|~
name|core_mask
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** *  Returns 1 if the running core is being unplugged, else it returns 0. */
end_comment

begin_function
name|int
name|is_core_being_unplugged
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|cvmx_app_hotplug_info_ptr
operator|->
name|unplug_cores
operator|&
operator|(
literal|1ull
operator|<<
name|cvmx_get_core_num
argument_list|()
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Activate the current application core for receiving hotplug shutdown requests.  *  * This routine makes sure that each core belonging to the application is enabled   * to receive the shutdown notification and also provides a barrier sync to make  * sure that all cores are ready.   */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_activate
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|cnt
init|=
literal|0
decl_stmt|;
name|uint64_t
name|cnt_interval
init|=
literal|10000000
decl_stmt|;
while|while
condition|(
operator|!
name|cvmx_app_hotplug_info_ptr
condition|)
block|{
name|cnt
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cnt
operator|%
name|cnt_interval
operator|)
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"waiting for cnt=%lld\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_app_hotplug_info_ptr
operator|->
name|hplugged_cores
operator|&
operator|(
literal|1ull
operator|<<
name|cvmx_get_core_num
argument_list|()
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"core=%d : is being hotplugged \n"
argument_list|,
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|sys_info_ptr
operator|->
name|core_mask
operator||=
literal|1ull
operator|<<
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|__cvmx_app_hotplug_sync
argument_list|()
expr_stmt|;
block|}
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_app_hotplug_info_ptr
condition|)
block|{
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ERROR: This application is not registered for hotplug\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Enable the interrupt before we mark the core as activated */
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator||=
operator|(
literal|1ull
operator|<<
name|cvmx_get_core_num
argument_list|()
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cvmx_app_hotplug_activate(): coremask 0x%x valid %d sizeof %d\n"
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|coremask
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|valid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cvmx_app_hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine is only required if cvmx_app_hotplug_shutdown_request() was called  * with wait=0. This routine waits for the application shutdown to complete.   *  * @param coremask     Coremask the application is running on.   * @return             0 on success, -1 on error  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_shutdown_complete
parameter_list|(
name|uint32_t
name|coremask
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|hotplug_info_ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hotplug_info_ptr
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|coremask
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for coremask: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
operator|!
name|hotplug_info_ptr
operator|->
name|shutdown_done
condition|)
empty_stmt|;
comment|/* Clean up the hotplug info region for this app */
name|bzero
argument_list|(
name|hotplug_info_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Disable recognition of any incoming shutdown request.   */
end_comment

begin_function
name|void
name|cvmx_app_hotplug_shutdown_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_interrupt_mask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Re-enable recognition of incoming shutdown requests.  */
end_comment

begin_function
name|void
name|cvmx_app_hotplug_shutdown_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/** *  Request shutdown of the currently running core. Should be *  called by the application when it has been registered with *  app_shutdown option set to 1. */
end_comment

begin_function
name|void
name|cvmx_app_hotplug_core_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|uint32_t
name|flags
decl_stmt|;
if|if
condition|(
name|cvmx_app_hotplug_info_ptr
operator|->
name|shutdown_cores
condition|)
block|{
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|__cvmx_app_hotplug_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|cvmx_app_hotplug_info_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cvmx_app_hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"__cvmx_app_hotplug_shutdown(): setting shutdown done! \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_app_hotplug_info_ptr
operator|->
name|shutdown_done
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Tell the debugger that this application is finishing.  */
name|cvmx_debug_finish
argument_list|()
expr_stmt|;
name|flags
operator|=
name|cvmx_interrupt_disable_save
argument_list|()
expr_stmt|;
name|__cvmx_app_hotplug_sync
argument_list|()
expr_stmt|;
comment|/* Reset the core */
name|__cvmx_app_hotplug_reset
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|cvmx_sysinfo_remove_self_from_core_mask
argument_list|()
expr_stmt|;
name|cvmx_app_hotplug_remove_self_from_core_mask
argument_list|()
expr_stmt|;
name|flags
operator|=
name|cvmx_interrupt_disable_save
argument_list|()
expr_stmt|;
name|__cvmx_app_hotplug_reset
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ISR for the incoming shutdown request interrupt.  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_app_hotplug_shutdown
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|uint64_t
name|mbox
decl_stmt|;
name|cvmx_app_hotplug_info_t
modifier|*
name|ai
init|=
name|cvmx_app_hotplug_info_ptr
decl_stmt|;
name|int
name|dbg
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dbg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|cvmx_interrupt_mask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
name|mbox
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_MBOX_CLRX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_MBOX_CLRX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
name|mbox
argument_list|)
expr_stmt|;
comment|/* Make sure the write above completes */
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_MBOX_CLRX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_app_hotplug_info_ptr
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Application is not registered for hotplug!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ai
operator|->
name|hotplug_activated_coremask
operator|!=
name|sys_info_ptr
operator|->
name|core_mask
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Shutdown requested when not all app cores have "
literal|"activated hotplug\n"
literal|"Application coremask: 0x%x Hotplug "
literal|"coremask: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sys_info_ptr
operator|->
name|core_mask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ai
operator|->
name|hotplug_activated_coremask
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mbox
operator|&
literal|1ull
condition|)
block|{
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"Shutting down application .\n"
argument_list|)
expr_stmt|;
comment|/* Call the application's own callback function */
if|if
condition|(
name|ai
operator|->
name|shutdown_callback
condition|)
block|{
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
operator|(
name|long
operator|)
name|ai
operator|->
name|shutdown_callback
operator|)
operator|(
name|CASTPTR
argument_list|(
name|void
operator|*
argument_list|,
name|ai
operator|->
name|data
argument_list|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ERROR : Shutdown callback has not been registered\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ai
operator|->
name|app_shutdown
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core = %d Invoking app shutdown\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_core_shutdown
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mbox
operator|&
literal|2ull
condition|)
block|{
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|int
name|unplug
init|=
name|is_core_being_unplugged
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core=%d Unplug event \n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|unplug
condition|)
block|{
comment|/* Call the application's own callback function */
if|if
condition|(
name|ai
operator|->
name|unplug_callback
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core=%d Calling unplug callback\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
operator|(
name|long
operator|)
name|ai
operator|->
name|unplug_callback
operator|)
operator|(
name|CASTPTR
argument_list|(
name|void
operator|*
argument_list|,
name|ai
operator|->
name|data
argument_list|)
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ai
operator|->
name|app_shutdown
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core = %d Invoking app shutdown\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_core_shutdown
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ai
operator|->
name|cores_removed_callback
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core=%d Calling cores removed callback\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|uint32_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
operator|(
name|long
operator|)
name|ai
operator|->
name|cores_removed_callback
operator|)
operator|(
name|ai
operator|->
name|unplug_cores
operator|,
name|CASTPTR
argument_list|(
name|void
operator|*
argument_list|,
name|ai
operator|->
name|data
argument_list|)
operator|)
expr_stmt|;
block|}
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|mbox
operator|&
literal|4ull
condition|)
block|{
name|int
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core=%d Add cores event \n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|cores_added_callback
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"%s : core=%d Calling cores added callback\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|core
argument_list|)
expr_stmt|;
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|uint32_t
argument_list|,
name|void
operator|*
argument_list|)
operator|)
operator|(
name|long
operator|)
name|ai
operator|->
name|cores_added_callback
operator|)
operator|(
name|ai
operator|->
name|hplugged_cores
operator|,
name|CASTPTR
argument_list|(
name|void
operator|*
argument_list|,
name|ai
operator|->
name|data
argument_list|)
operator|)
expr_stmt|;
block|}
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"ERROR: unexpected mbox=%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mbox
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|__cvmx_app_hotplug_reset
parameter_list|(
name|void
parameter_list|)
block|{
define|#
directive|define
name|IDLE_CORE_BLOCK_NAME
value|"idle-core-loop"
define|#
directive|define
name|HPLUG_MAKE_XKPHYS
parameter_list|(
name|x
parameter_list|)
value|((1ULL<< 63) | (x))
name|uint64_t
name|reset_addr
decl_stmt|;
specifier|const
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|block_desc
decl_stmt|;
name|block_desc
operator|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|IDLE_CORE_BLOCK_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_desc
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Named block(%s) is not created\n"
argument_list|,
name|IDLE_CORE_BLOCK_NAME
argument_list|)
expr_stmt|;
comment|/* loop here, should not happen */
asm|__asm__
specifier|volatile
asm|(                           ".set noreorder      \n"                           "\tsync               \n"                           "\tnop               \n"                           "1:\twait            \n"                           "\tb 1b              \n"                           "\tnop               \n"                           ".set reorder        \n"                           ::                           );
block|}
name|reset_addr
operator|=
name|HPLUG_MAKE_XKPHYS
argument_list|(
name|block_desc
operator|->
name|base_addr
argument_list|)
expr_stmt|;
asm|asm
specifier|volatile
asm|("       .set push                \n"                   "       .set mips64              \n"                   "       .set noreorder           \n"                   "       move  $2, %[addr]        \n"                   "       jr    $2                 \n"                   "       nop                      \n"                   "       .set pop "                   :: [addr] "r"(reset_addr)                   : "$2");
comment|/*Should never reach here*/
while|while
condition|(
literal|1
condition|)
empty_stmt|;
block|}
end_function

begin_comment
comment|/*   * We need a separate sync operation from cvmx_coremask_barrier_sync() to  * avoid a deadlock on state.lock, since the application itself maybe doing a  * cvmx_coremask_barrier_sync().   */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_app_hotplug_sync
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|CVMX_SHARED
specifier|volatile
name|uint32_t
name|sync_coremask
init|=
literal|0
decl_stmt|;
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_app_hotplug_sync_lock
argument_list|)
expr_stmt|;
name|sync_coremask
operator||=
name|cvmx_coremask_core
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_sync_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|sync_coremask
operator|!=
name|sys_info_ptr
operator|->
name|core_mask
condition|)
empty_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_app_hotplug_sync_lock
argument_list|)
expr_stmt|;
name|sync_coremask
operator|=
literal|0
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_BUILD_FOR_LINUX_USER */
end_comment

begin_comment
comment|/** *  Returns 1 if the running core is being hotplugged, else it returns 0. */
end_comment

begin_function
name|int
name|is_core_being_hot_plugged
parameter_list|(
name|void
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_USER
if|if
condition|(
operator|!
name|cvmx_app_hotplug_info_ptr
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|cvmx_app_hotplug_info_ptr
operator|->
name|hplugged_cores
operator|&
operator|(
literal|1ull
operator|<<
name|cvmx_get_core_num
argument_list|()
operator|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
else|#
directive|else
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|cvmx_app_hotplug_global_t
modifier|*
name|cvmx_app_get_hotplug_global_ptr
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|struct
name|cvmx_bootmem_named_block_desc
modifier|*
name|block_desc
decl_stmt|;
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
if|if
condition|(
name|hotplug_global_ptr
operator|!=
literal|0
condition|)
return|return
name|hotplug_global_ptr
return|;
name|block_desc
operator|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|CVMX_APP_HOTPLUG_INFO_REGION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_desc
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Hotplug info region is not setup\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
block|{
name|size_t
name|pg_sz
init|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
decl_stmt|,
name|size
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/mem"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*          * We need to mmap() this memory, since this was allocated from the           * kernel bootup code and does not reside in the RESERVE32 region.          */
name|size
operator|=
name|CVMX_APP_HOTPLUG_INFO_REGION_SIZE
operator|+
name|pg_sz
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|block_desc
operator|->
name|base_addr
operator|&
operator|~
operator|(
name|pg_sz
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vaddr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"mmap"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hgp
operator|=
operator|(
name|cvmx_app_hotplug_global_t
operator|*
operator|)
operator|(
name|vaddr
operator|+
operator|(
name|block_desc
operator|->
name|base_addr
operator|&
operator|(
name|pg_sz
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|hgp
operator|=
name|CASTPTR
argument_list|(
name|void
argument_list|,
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|block_desc
operator|->
name|base_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hotplug_global_ptr
operator|=
name|hgp
expr_stmt|;
return|return
name|hgp
return|;
block|}
end_function

begin_comment
comment|/**  * Return the hotplug info structure (cvmx_app_hotplug_info_t) pointer for the   * application running on the given coremask.   *  * @param coremask     Coremask of application.   * @return             Returns hotplug info struct on success, NULL on failure  *  */
end_comment

begin_function
name|cvmx_app_hotplug_info_t
modifier|*
name|cvmx_app_hotplug_get_info
parameter_list|(
name|uint32_t
name|coremask
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|hip
decl_stmt|;
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dbg
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dbg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|hgp
operator|=
name|cvmx_app_get_hotplug_global_ptr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hgp
condition|)
return|return
name|NULL
return|;
name|hip
operator|=
name|hgp
operator|->
name|hotplug_info_array
expr_stmt|;
comment|/* Look for the current app's info */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_APP_HOTPLUG_MAX_APPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hip
index|[
name|i
index|]
operator|.
name|coremask
operator|==
name|coremask
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"cvmx_app_hotplug_get_info(): coremask match %d -- coremask 0x%x, valid %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hip
index|[
name|i
index|]
operator|.
name|coremask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hip
index|[
name|i
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
operator|&
name|hip
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Return the hotplug application index structure for the application running on the   * given coremask.   *  * @param coremask     Coremask of application.   * @return             Returns hotplug application index on success. -1 on failure  *                       */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_get_index
parameter_list|(
name|uint32_t
name|coremask
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|hip
decl_stmt|;
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|dbg
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|dbg
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|hgp
operator|=
name|cvmx_app_get_hotplug_global_ptr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hgp
condition|)
return|return
operator|-
literal|1
return|;
name|hip
operator|=
name|hgp
operator|->
name|hotplug_info_array
expr_stmt|;
comment|/* Look for the current app's info */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_APP_HOTPLUG_MAX_APPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hip
index|[
name|i
index|]
operator|.
name|coremask
operator|==
name|coremask
condition|)
block|{
if|if
condition|(
name|dbg
condition|)
name|printf
argument_list|(
literal|"cvmx_app_hotplug_get_info(): coremask match %d -- coremask 0x%x valid %d\n"
argument_list|,
name|i
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hip
index|[
name|i
index|]
operator|.
name|coremask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hip
index|[
name|i
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
return|return
name|i
return|;
block|}
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|void
name|print_hot_plug_info
parameter_list|(
name|cvmx_app_hotplug_info_t
modifier|*
name|hpinfo
parameter_list|)
block|{
name|printf
argument_list|(
literal|"name=%s coremask=%08x hotplugged coremask=%08x valid=%d\n"
argument_list|,
name|hpinfo
operator|->
name|app_name
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hpinfo
operator|->
name|coremask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hpinfo
operator|->
name|hotplug_activated_coremask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|hpinfo
operator|->
name|valid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the hotplug info structure (cvmx_app_hotplug_info_t) pointer for the   * application with the specified index.  *  * @param index        index of application.   * @return             Returns hotplug info struct on success, NULL on failure  *  */
end_comment

begin_function
name|cvmx_app_hotplug_info_t
modifier|*
name|cvmx_app_hotplug_get_info_at_index
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|hip
decl_stmt|;
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|hgp
operator|=
name|cvmx_app_get_hotplug_global_ptr
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|hgp
condition|)
return|return
name|NULL
return|;
name|hip
operator|=
name|hgp
operator|->
name|hotplug_info_array
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"cvmx_app_hotplug_get_info(): hotplug_info phy addr 0x%llx ptr %p\n"
argument_list|,
name|block_desc
operator|->
name|base_addr
argument_list|,
name|hgp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|index
operator|<
name|CVMX_APP_HOTPLUG_MAX_APPS
condition|)
block|{
if|if
condition|(
name|hip
index|[
name|index
index|]
operator|.
name|valid
condition|)
block|{
comment|//print_hot_plug_info(&hip[index] );
return|return
operator|&
name|hip
index|[
name|index
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * Determines if SE application at the index specified is hotpluggable.  *  * @param index        index of application.  * @return             Returns -1  on error.  *                     0 -> The application is not hotpluggable  *                     1 -> The application is hotpluggable */
end_comment

begin_function
name|int
name|is_app_hotpluggable
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|ai
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ai
operator|=
name|cvmx_app_hotplug_get_info_at_index
argument_list|(
name|index
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for app at index=%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ai
operator|->
name|hotplug_activated_coremask
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine sends a shutdown request to a running target application.   *  * @param coremask     Coremask the application is running on.   * @param wait         1 - Wait for shutdown completion  *                     0 - Do not wait  * @return             0 on success, -1 on error  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_shutdown_request
parameter_list|(
name|uint32_t
name|coremask
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_app_hotplug_info_t
modifier|*
name|hotplug_info_ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hotplug_info_ptr
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|coremask
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for coremask: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|hotplug_info_ptr
operator|->
name|shutdown_cores
operator|=
name|coremask
expr_stmt|;
if|if
condition|(
operator|!
name|hotplug_info_ptr
operator|->
name|shutdown_callback
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Target application has not registered for hotplug!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator|!=
name|coremask
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Not all application cores have activated hotplug\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Send IPIs to all application cores to request shutdown */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_MAX_CORES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coremask
operator|&
operator|(
literal|1ull
operator|<<
name|i
operator|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_MBOX_SETX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
condition|)
block|{
while|while
condition|(
operator|!
name|hotplug_info_ptr
operator|->
name|shutdown_done
condition|)
empty_stmt|;
comment|/* Clean up the hotplug info region for this application */
name|bzero
argument_list|(
name|hotplug_info_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine invokes the invoked the cores_added callbacks.  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_call_add_cores_callback
parameter_list|(
name|int
name|index
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|ai
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ai
operator|=
name|cvmx_app_hotplug_get_info_at_index
argument_list|(
name|index
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for app at index=%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Send IPIs to all application cores to request add_cores callback*/
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_MAX_CORES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|coremask
operator|&
operator|(
literal|1ull
operator|<<
name|i
operator|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_MBOX_SETX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine sends a request to a running target application  * to unplug a specified set cores  * @param index        is the index of the target application  * @param coremask     Coremask of the cores to be unplugged from the app.  * @param wait         1 - Wait for shutdown completion  *                     0 - Do not wait  * @return             0 on success, -1 on error  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_unplug_cores
parameter_list|(
name|int
name|index
parameter_list|,
name|uint32_t
name|coremask
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|ai
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|ai
operator|=
name|cvmx_app_hotplug_get_info_at_index
argument_list|(
name|index
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for app at index=%d\n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|ai
operator|->
name|unplug_cores
operator|=
name|coremask
expr_stmt|;
if|#
directive|if
literal|0
block|if (!ai->shutdown_callback)     {         printf("\nERROR: Target application has not registered for hotplug!\n");         return -1;     }
endif|#
directive|endif
if|if
condition|(
operator|(
name|ai
operator|->
name|coremask
operator||
name|coremask
operator|)
operator|!=
name|ai
operator|->
name|coremask
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Not all cores requested are a part of the app "
literal|"r=%08x:%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ai
operator|->
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ai
operator|->
name|coremask
operator|==
name|coremask
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Trying to remove all cores in app. "
literal|"r=%08x:%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ai
operator|->
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Send IPIs to all application cores to request unplug/remove_cores        callback */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_MAX_CORES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ai
operator|->
name|coremask
operator|&
operator|(
literal|1ull
operator|<<
name|i
operator|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_MBOX_SETX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (wait)     {         while (!ai->shutdown_done);
comment|/* Clean up the hotplug info region for this application */
block|bzero(ai, sizeof(*ai));     }
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Returns 1 if any app is currently being currently booted , hotplugged or  * shutdown. Only one app can be under a boot, hotplug or shutdown condition.  * Before booting an app this methods should be used to check whether boot or  * shutdown activity is in progress and proceed with the boot or shutdown only  * when there is no other activity.  *  */
end_comment

begin_function
name|int
name|is_app_under_boot_or_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|hgp
operator|=
name|cvmx_app_get_hotplug_global_ptr
argument_list|()
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|hgp
operator|->
name|hotplug_global_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|hgp
operator|->
name|app_under_boot
operator|||
name|hgp
operator|->
name|app_under_shutdown
condition|)
name|ret
operator|=
literal|1
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|hgp
operator|->
name|hotplug_global_lock
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Sets or clear the app_under_boot value. This when set signifies that an app  * is being currently booted or hotplugged with a new core.  *  *  * @param val     sets the app_under_boot to the specified value. This should be  *                set to 1 while app any is being booted and cleared after the  *                application has booted up.  *  */
end_comment

begin_function
name|void
name|set_app_unber_boot
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|hgp
operator|=
name|cvmx_app_get_hotplug_global_ptr
argument_list|()
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|hgp
operator|->
name|hotplug_global_lock
argument_list|)
expr_stmt|;
name|hgp
operator|->
name|app_under_boot
operator|=
name|val
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|hgp
operator|->
name|hotplug_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Sets or clear the app_under_shutdown value. This when set signifies that an  * app is being currently shutdown or some cores of an app are being shutdown.  *  * @param val     sets the app_under_shutdown to the specified value. This  *                should be set to 1 while any app is being shutdown and cleared  *                after the shutdown of the app is complete.  *  */
end_comment

begin_function
name|void
name|set_app_under_shutdown
parameter_list|(
name|int
name|val
parameter_list|)
block|{
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|hgp
operator|=
name|cvmx_app_get_hotplug_global_ptr
argument_list|()
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|hgp
operator|->
name|hotplug_global_lock
argument_list|)
expr_stmt|;
name|hgp
operator|->
name|app_under_shutdown
operator|=
name|val
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|hgp
operator|->
name|hotplug_global_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

