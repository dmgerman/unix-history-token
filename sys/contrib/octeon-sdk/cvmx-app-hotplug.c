begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Provides APIs for applications to register for hotplug. It also provides   * APIs for requesting shutdown of a running target application.   *  *<hr>$Revision: $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-app-hotplug.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_comment
comment|//#define DEBUG 1
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifndef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_app_hotplug_sync_lock
init|=
block|{
name|CVMX_SPINLOCK_UNLOCKED_VAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_app_hotplug_lock
init|=
block|{
name|CVMX_SPINLOCK_UNLOCKED_VAL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_app_hotplug_info_t
modifier|*
name|cvmx_app_hotplug_info_ptr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|__cvmx_app_hotplug_shutdown
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__cvmx_app_hotplug_sync
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__cvmx_app_hotplug_reset
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/**  * This routine registers an application for hotplug. It installs a handler for  * any incoming shutdown request. It also registers a callback routine from the  * application. This callback is invoked when the application receives a   * shutdown notification.   *  * This routine only needs to be called once per application.   *  * @param fn      Callback routine from the application.   * @param arg     Argument to the application callback routine.   * @return        Return 0 on success, -1 on failure  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_register
parameter_list|(
name|void
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* Find the list of applications launched by bootoct utility. */
if|if
condition|(
operator|!
operator|(
name|cvmx_app_hotplug_info_ptr
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|core_mask
argument_list|)
operator|)
condition|)
block|{
comment|/* Application not launched by bootoct? */
name|printf
argument_list|(
literal|"ERROR: cmvx_app_hotplug_register() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Register the callback */
name|cvmx_app_hotplug_info_ptr
operator|->
name|data
operator|=
name|CAST64
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|->
name|shutdown_callback
operator|=
name|CAST64
argument_list|(
name|fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_app_hotplug_register(): coremask 0x%x valid %d\n"
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|coremask
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|valid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_interrupt_register
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|,
name|__cvmx_app_hotplug_shutdown
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Activate the current application core for receiving hotplug shutdown requests.   *  * This routine makes sure that each core belonging to the application is enabled   * to receive the shutdown notification and also provides a barrier sync to make  * sure that all cores are ready.   */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_activate
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Make sure all application cores are activating */
name|__cvmx_app_hotplug_sync
argument_list|()
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_app_hotplug_info_ptr
condition|)
block|{
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"ERROR: This application is not registered for hotplug\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Enable the interrupt before we mark the core as activated */
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
name|cvmx_app_hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator||=
operator|(
literal|1
operator|<<
name|cvmx_get_core_num
argument_list|()
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_app_hotplug_activate(): coremask 0x%x valid %d sizeof %d\n"
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|coremask
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|valid
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cvmx_app_hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * This routine is only required if cvmx_app_hotplug_shutdown_request() was called  * with wait=0. This routine waits for the application shutdown to complete.   *  * @param coremask     Coremask the application is running on.   * @return             0 on success, -1 on error  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_shutdown_complete
parameter_list|(
name|uint32_t
name|coremask
parameter_list|)
block|{
name|cvmx_app_hotplug_info_t
modifier|*
name|hotplug_info_ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hotplug_info_ptr
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|coremask
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for coremask: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
operator|!
name|hotplug_info_ptr
operator|->
name|shutdown_done
condition|)
empty_stmt|;
comment|/* Clean up the hotplug info region for this app */
name|bzero
argument_list|(
name|hotplug_info_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Disable recognition of any incoming shutdown request.   */
end_comment

begin_function
name|void
name|cvmx_app_hotplug_shutdown_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_interrupt_mask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Re-enable recognition of incoming shutdown requests.  */
end_comment

begin_function
name|void
name|cvmx_app_hotplug_shutdown_enable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_interrupt_unmask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ISR for the incoming shutdown request interrupt.   */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_app_hotplug_shutdown
parameter_list|(
name|int
name|irq_number
parameter_list|,
name|uint64_t
name|registers
index|[
literal|32
index|]
parameter_list|,
name|void
modifier|*
name|user_arg
parameter_list|)
block|{
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|cvmx_interrupt_mask_irq
argument_list|(
name|CVMX_IRQ_MBOX0
argument_list|)
expr_stmt|;
comment|/* Clear the interrupt */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_MBOX_CLRX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Make sure the write above completes */
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_MBOX_CLRX
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_app_hotplug_info_ptr
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Application is not registered for hotplug!\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cvmx_app_hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator|!=
name|sys_info_ptr
operator|->
name|core_mask
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Shutdown requested when not all app cores have activated hotplug\n"
literal|"Application coremask: 0x%x Hotplug coremask: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|sys_info_ptr
operator|->
name|core_mask
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|cvmx_app_hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Call the application's own callback function */
operator|(
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
operator|(
name|long
operator|)
name|cvmx_app_hotplug_info_ptr
operator|->
name|shutdown_callback
operator|)
operator|(
name|CASTPTR
argument_list|(
name|void
operator|*
argument_list|,
name|cvmx_app_hotplug_info_ptr
operator|->
name|data
argument_list|)
operator|)
expr_stmt|;
name|__cvmx_app_hotplug_sync
argument_list|()
expr_stmt|;
if|if
condition|(
name|cvmx_coremask_first_core
argument_list|(
name|sys_info_ptr
operator|->
name|core_mask
argument_list|)
condition|)
block|{
name|bzero
argument_list|(
name|cvmx_app_hotplug_info_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cvmx_app_hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"__cvmx_app_hotplug_shutdown(): setting shutdown done! \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_app_hotplug_info_ptr
operator|->
name|shutdown_done
operator|=
literal|1
expr_stmt|;
block|}
name|flags
operator|=
name|cvmx_interrupt_disable_save
argument_list|()
expr_stmt|;
name|__cvmx_app_hotplug_sync
argument_list|()
expr_stmt|;
comment|/* Reset the core */
name|__cvmx_app_hotplug_reset
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reset the core. We just jump back to the reset vector for now.   */
end_comment

begin_function
name|void
name|__cvmx_app_hotplug_reset
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Code from SecondaryCoreLoop from bootloader, sleep until we recieve        a NMI. */
asm|__asm__
specifier|volatile
asm|(         ".set noreorder      \n" 	"\tsync               \n" 	"\tnop               \n"         "1:\twait            \n"         "\tb 1b              \n" 	"\tnop               \n"              	".set reorder        \n" 	::      );
block|}
end_function

begin_comment
comment|/*   * We need a separate sync operation from cvmx_coremask_barrier_sync() to  * avoid a deadlock on state.lock, since the application itself maybe doing a  * cvmx_coremask_barrier_sync().   */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_app_hotplug_sync
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|CVMX_SHARED
specifier|volatile
name|uint32_t
name|sync_coremask
init|=
literal|0
decl_stmt|;
name|cvmx_sysinfo_t
modifier|*
name|sys_info_ptr
init|=
name|cvmx_sysinfo_get
argument_list|()
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_app_hotplug_sync_lock
argument_list|)
expr_stmt|;
name|sync_coremask
operator||=
name|cvmx_coremask_core
argument_list|(
name|cvmx_get_core_num
argument_list|()
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_app_hotplug_sync_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|sync_coremask
operator|!=
name|sys_info_ptr
operator|->
name|core_mask
condition|)
empty_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_BUILD_FOR_LINUX_USER */
end_comment

begin_comment
comment|/**  * Return the hotplug info structure (cvmx_app_hotplug_info_t) pointer for the   * application running on the given coremask.   *  * @param coremask     Coremask of application.   * @return             Returns hotplug info struct on success, NULL on failure  *  */
end_comment

begin_function
name|cvmx_app_hotplug_info_t
modifier|*
name|cvmx_app_hotplug_get_info
parameter_list|(
name|uint32_t
name|coremask
parameter_list|)
block|{
specifier|const
name|struct
name|cvmx_bootmem_named_block_desc
modifier|*
name|block_desc
decl_stmt|;
name|cvmx_app_hotplug_info_t
modifier|*
name|hip
decl_stmt|;
name|cvmx_app_hotplug_global_t
modifier|*
name|hgp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|block_desc
operator|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|CVMX_APP_HOTPLUG_INFO_REGION_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|block_desc
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: Hotplug info region is not setup\n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
else|else
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
block|{
name|size_t
name|pg_sz
init|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
decl_stmt|,
name|size
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
literal|"/dev/mem"
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"open"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/*          * We need to mmap() this memory, since this was allocated from the           * kernel bootup code and does not reside in the RESERVE32 region.          */
name|size
operator|=
name|CVMX_APP_HOTPLUG_INFO_REGION_SIZE
operator|+
name|pg_sz
operator|-
literal|1
expr_stmt|;
name|offset
operator|=
name|block_desc
operator|->
name|base_addr
operator|&
operator|~
operator|(
name|pg_sz
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|vaddr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
name|offset
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|perror
argument_list|(
literal|"mmap"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hgp
operator|=
operator|(
name|cvmx_app_hotplug_global_t
operator|*
operator|)
operator|(
name|vaddr
operator|+
operator|(
name|block_desc
operator|->
name|base_addr
operator|&
operator|(
name|pg_sz
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|#
directive|else
name|hgp
operator|=
name|cvmx_phys_to_ptr
argument_list|(
name|block_desc
operator|->
name|base_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hip
operator|=
name|hgp
operator|->
name|hotplug_info_array
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_app_hotplug_get_info(): hotplug_info phy addr 0x%llx ptr %p\n"
argument_list|,
name|block_desc
operator|->
name|base_addr
argument_list|,
name|hgp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Look for the current app's info */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_APP_HOTPLUG_MAX_APPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|hip
index|[
name|i
index|]
operator|.
name|coremask
operator|==
name|coremask
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_app_hotplug_get_info(): coremask match %d -- coremask 0x%x valid %d\n"
argument_list|,
name|i
argument_list|,
name|hip
index|[
name|i
index|]
operator|.
name|coremask
argument_list|,
name|hip
index|[
name|i
index|]
operator|.
name|valid
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
name|hip
index|[
name|i
index|]
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * This routine sends a shutdown request to a running target application.   *  * @param coremask     Coremask the application is running on.   * @param wait         1 - Wait for shutdown completion  *                     0 - Do not wait  * @return             0 on success, -1 on error  *  */
end_comment

begin_function
name|int
name|cvmx_app_hotplug_shutdown_request
parameter_list|(
name|uint32_t
name|coremask
parameter_list|,
name|int
name|wait
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_app_hotplug_info_t
modifier|*
name|hotplug_info_ptr
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|hotplug_info_ptr
operator|=
name|cvmx_app_hotplug_get_info
argument_list|(
name|coremask
argument_list|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Failed to get hotplug info for coremask: 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
operator|!
name|hotplug_info_ptr
operator|->
name|shutdown_callback
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Target application has not registered for hotplug!\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|hotplug_info_ptr
operator|->
name|hotplug_activated_coremask
operator|!=
name|coremask
condition|)
block|{
name|printf
argument_list|(
literal|"\nERROR: Not all application cores have activated hotplug\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Send IPIs to all application cores to request shutdown */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_MAX_CORES
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|coremask
operator|&
operator|(
literal|1
operator|<<
name|i
operator|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_MBOX_SETX
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|wait
condition|)
block|{
while|while
condition|(
operator|!
name|hotplug_info_ptr
operator|->
name|shutdown_done
condition|)
empty_stmt|;
comment|/* Clean up the hotplug info region for this application */
name|bzero
argument_list|(
name|hotplug_info_ptr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hotplug_info_ptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

