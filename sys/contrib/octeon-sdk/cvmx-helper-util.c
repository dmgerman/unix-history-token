begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Small helper utilities.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<linux/slab.h>
include|\  #include<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pip.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ipd.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sli-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-cfg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-fpa.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pip.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ilk.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ipd.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-gmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spi.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-util.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-version.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-ilk.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-cfg.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_HELPER_FUNCTIONS
end_ifdef

begin_struct
struct|struct
name|cvmx_iface
block|{
name|int
name|cvif_ipd_nports
decl_stmt|;
name|int
name|cvif_has_fcs
decl_stmt|;
comment|/* PKO fcs for this interface. */
name|enum
name|cvmx_pko_padding
name|cvif_padding
decl_stmt|;
name|cvmx_helper_link_info_t
modifier|*
name|cvif_ipd_port_link_info
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * This has to be static as u-boot expects to probe an interface and  * gets the number of its ports.  */
end_comment

begin_expr_stmt
specifier|static
name|CVMX_SHARED
expr|struct
name|cvmx_iface
name|cvmx_interfaces
index|[
name|CVMX_HELPER_MAX_IFACE
index|]
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifndef

begin_comment
comment|/**  * Get the version of the CVMX libraries.  *  * @return Version string. Note this buffer is allocated statically  *         and will be shared by all callers.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cvmx_helper_get_version
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|OCTEON_SDK_VERSION_STRING
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Convert a interface mode into a human readable string  *  * @param mode   Mode to convert  *  * @return String  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|cvmx_helper_interface_mode_to_string
parameter_list|(
name|cvmx_helper_interface_mode_t
name|mode
parameter_list|)
block|{
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|CVMX_HELPER_INTERFACE_MODE_DISABLED
case|:
return|return
literal|"DISABLED"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RGMII
case|:
return|return
literal|"RGMII"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_GMII
case|:
return|return
literal|"GMII"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SPI
case|:
return|return
literal|"SPI"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_PCIE
case|:
return|return
literal|"PCIE"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_XAUI
case|:
return|return
literal|"XAUI"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_RXAUI
case|:
return|return
literal|"RXAUI"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SGMII
case|:
return|return
literal|"SGMII"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_PICMG
case|:
return|return
literal|"PICMG"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_NPI
case|:
return|return
literal|"NPI"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_LOOP
case|:
return|return
literal|"LOOP"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_SRIO
case|:
return|return
literal|"SRIO"
return|;
case|case
name|CVMX_HELPER_INTERFACE_MODE_ILK
case|:
return|return
literal|"ILK"
return|;
block|}
return|return
literal|"UNKNOWN"
return|;
block|}
end_function

begin_comment
comment|/**  * Debug routine to dump the packet structure to the console  *  * @param work   Work queue entry containing the packet to dump  * @return  */
end_comment

begin_function
name|int
name|cvmx_helper_dump_packet
parameter_list|(
name|cvmx_wqe_t
modifier|*
name|work
parameter_list|)
block|{
name|uint64_t
name|count
decl_stmt|;
name|uint64_t
name|remaining_bytes
decl_stmt|;
name|cvmx_buf_ptr_t
name|buffer_ptr
decl_stmt|;
name|uint64_t
name|start_of_buffer
decl_stmt|;
name|uint8_t
modifier|*
name|data_address
decl_stmt|;
name|uint8_t
modifier|*
name|end_of_data
decl_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Packet Length:   %u\n"
argument_list|,
name|cvmx_wqe_get_len
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Input Port:  %u\n"
argument_list|,
name|cvmx_wqe_get_port
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    QoS:         %u\n"
argument_list|,
name|cvmx_wqe_get_qos
argument_list|(
name|work
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffers:     %u\n"
argument_list|,
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|bufs
operator|==
literal|0
condition|)
block|{
name|cvmx_ipd_wqe_fpa_queue_t
name|wqe_pool
decl_stmt|;
name|wqe_pool
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_WQE_FPA_QUEUE
argument_list|)
expr_stmt|;
name|buffer_ptr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|buffer_ptr
operator|.
name|s
operator|.
name|pool
operator|=
name|wqe_pool
operator|.
name|s
operator|.
name|wqe_pool
expr_stmt|;
name|buffer_ptr
operator|.
name|s
operator|.
name|size
operator|=
literal|128
expr_stmt|;
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
operator|=
name|cvmx_ptr_to_phys
argument_list|(
name|work
operator|->
name|packet_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_likely
argument_list|(
operator|!
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|not_IP
argument_list|)
condition|)
block|{
name|cvmx_pip_ip_offset_t
name|pip_ip_offset
decl_stmt|;
name|pip_ip_offset
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_IP_OFFSET
argument_list|)
expr_stmt|;
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
operator|+=
operator|(
name|pip_ip_offset
operator|.
name|s
operator|.
name|offset
operator|<<
literal|3
operator|)
operator|-
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|ip_offset
expr_stmt|;
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
operator|+=
operator|(
name|work
operator|->
name|word2
operator|.
name|s
operator|.
name|is_v6
operator|^
literal|1
operator|)
operator|<<
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* WARNING: This code assume that the packet is not RAW. If it was,                 we would use PIP_GBL_CFG[RAW_SHF] instead of                 PIP_GBL_CFG[NIP_SHF] */
name|cvmx_pip_gbl_cfg_t
name|pip_gbl_cfg
decl_stmt|;
name|pip_gbl_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PIP_GBL_CFG
argument_list|)
expr_stmt|;
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
operator|+=
name|pip_gbl_cfg
operator|.
name|s
operator|.
name|nip_shf
expr_stmt|;
block|}
block|}
else|else
name|buffer_ptr
operator|=
name|work
operator|->
name|packet_ptr
expr_stmt|;
name|remaining_bytes
operator|=
name|cvmx_wqe_get_len
argument_list|(
name|work
argument_list|)
expr_stmt|;
while|while
condition|(
name|remaining_bytes
condition|)
block|{
name|start_of_buffer
operator|=
operator|(
operator|(
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
operator|>>
literal|7
operator|)
operator|-
name|buffer_ptr
operator|.
name|s
operator|.
name|back
operator|)
operator|<<
literal|7
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffer Start:%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|start_of_buffer
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffer I   : %u\n"
argument_list|,
name|buffer_ptr
operator|.
name|s
operator|.
name|i
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffer Back: %u\n"
argument_list|,
name|buffer_ptr
operator|.
name|s
operator|.
name|back
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffer Pool: %u\n"
argument_list|,
name|buffer_ptr
operator|.
name|s
operator|.
name|pool
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffer Data: %llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"    Buffer Size: %u\n"
argument_list|,
name|buffer_ptr
operator|.
name|s
operator|.
name|size
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\t\t"
argument_list|)
expr_stmt|;
name|data_address
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
argument_list|)
expr_stmt|;
name|end_of_data
operator|=
name|data_address
operator|+
name|buffer_ptr
operator|.
name|s
operator|.
name|size
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|data_address
operator|<
name|end_of_data
condition|)
block|{
if|if
condition|(
name|remaining_bytes
operator|==
literal|0
condition|)
break|break;
else|else
name|remaining_bytes
operator|--
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"%02x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|data_address
argument_list|)
expr_stmt|;
name|data_address
operator|++
expr_stmt|;
if|if
condition|(
name|remaining_bytes
operator|&&
operator|(
name|count
operator|==
literal|7
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"\n\t\t"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|count
operator|++
expr_stmt|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|remaining_bytes
condition|)
name|buffer_ptr
operator|=
operator|*
operator|(
name|cvmx_buf_ptr_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|buffer_ptr
operator|.
name|s
operator|.
name|addr
operator|-
literal|8
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Setup Random Early Drop on a specific input queue  *  * @param queue  Input queue to setup RED on (0-7)  * @param pass_thresh  *               Packets will begin slowly dropping when there are less than  *               this many packet buffers free in FPA 0.  * @param drop_thresh  *               All incomming packets will be dropped when there are less  *               than this many free packet buffers in FPA 0.  * @return Zero on success. Negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_setup_red_queue
parameter_list|(
name|int
name|queue
parameter_list|,
name|int
name|pass_thresh
parameter_list|,
name|int
name|drop_thresh
parameter_list|)
block|{
name|cvmx_ipd_qosx_red_marks_t
name|red_marks
decl_stmt|;
name|cvmx_ipd_red_quex_param_t
name|red_param
decl_stmt|;
comment|/* Set RED to begin dropping packets when there are pass_thresh buffers         left. It will linearly drop more packets until reaching drop_thresh         buffers */
name|red_marks
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|red_marks
operator|.
name|s
operator|.
name|drop
operator|=
name|drop_thresh
expr_stmt|;
name|red_marks
operator|.
name|s
operator|.
name|pass
operator|=
name|pass_thresh
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_QOSX_RED_MARKS
argument_list|(
name|queue
argument_list|)
argument_list|,
name|red_marks
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Use the actual queue 0 counter, not the average */
name|red_param
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|red_param
operator|.
name|s
operator|.
name|prb_con
operator|=
operator|(
literal|255ul
operator|<<
literal|24
operator|)
operator|/
operator|(
name|red_marks
operator|.
name|s
operator|.
name|pass
operator|-
name|red_marks
operator|.
name|s
operator|.
name|drop
operator|)
expr_stmt|;
name|red_param
operator|.
name|s
operator|.
name|avg_con
operator|=
literal|1
expr_stmt|;
name|red_param
operator|.
name|s
operator|.
name|new_con
operator|=
literal|255
expr_stmt|;
name|red_param
operator|.
name|s
operator|.
name|use_pcnt
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_RED_QUEX_PARAM
argument_list|(
name|queue
argument_list|)
argument_list|,
name|red_param
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Setup Random Early Drop to automatically begin dropping packets.  *  * @param pass_thresh  *               Packets will begin slowly dropping when there are less than  *               this many packet buffers free in FPA 0.  * @param drop_thresh  *               All incomming packets will be dropped when there are less  *               than this many free packet buffers in FPA 0.  * @return Zero on success. Negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_setup_red
parameter_list|(
name|int
name|pass_thresh
parameter_list|,
name|int
name|drop_thresh
parameter_list|)
block|{
name|int
name|queue
decl_stmt|;
name|int
name|interface
decl_stmt|;
name|int
name|port
decl_stmt|;
comment|/*      * Disable backpressure based on queued buffers. It needs SW support      */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|int
name|bpid
decl_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|CVMX_HELPER_MAX_GMX
condition|;
name|interface
operator|++
control|)
block|{
name|int
name|num_ports
decl_stmt|;
name|num_ports
operator|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
expr_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
block|{
name|bpid
operator|=
name|cvmx_helper_get_bpid
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpid
operator|==
name|CVMX_INVALID_BPID
condition|)
name|cvmx_dprintf
argument_list|(
literal|"setup_red: cvmx_helper_get_bpid(%d, %d) = %d\n"
argument_list|,
name|interface
argument_list|,
name|port
argument_list|,
name|cvmx_helper_get_bpid
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_BPIDX_MBUF_TH
argument_list|(
name|bpid
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|cvmx_ipd_portx_bp_page_cnt_t
name|page_cnt
decl_stmt|;
name|page_cnt
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|page_cnt
operator|.
name|s
operator|.
name|bp_enb
operator|=
literal|0
expr_stmt|;
name|page_cnt
operator|.
name|s
operator|.
name|page_cnt
operator|=
literal|100
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|CVMX_HELPER_MAX_GMX
condition|;
name|interface
operator|++
control|)
block|{
for|for
control|(
name|port
operator|=
name|cvmx_helper_get_first_ipd_port
argument_list|(
name|interface
argument_list|)
init|;
name|port
operator|<
name|cvmx_helper_get_last_ipd_port
argument_list|(
name|interface
argument_list|)
condition|;
name|port
operator|++
control|)
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_PORTX_BP_PAGE_CNT
argument_list|(
name|port
argument_list|)
argument_list|,
name|page_cnt
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|queue
operator|=
literal|0
init|;
name|queue
operator|<
literal|8
condition|;
name|queue
operator|++
control|)
name|cvmx_helper_setup_red_queue
argument_list|(
name|queue
argument_list|,
name|pass_thresh
argument_list|,
name|drop_thresh
argument_list|)
expr_stmt|;
comment|/*      * Shutoff the dropping based on the per port page count. SW isn't      * decrementing it right now      */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_ON_BP_DROP_PKTX
argument_list|(
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_BP_PRT_RED_END
argument_list|,
literal|0
argument_list|)
expr_stmt|;
define|#
directive|define
name|IPD_RED_AVG_DLY
value|1000
define|#
directive|define
name|IPD_RED_PRB_DLY
value|1000
comment|/*      * Setting up avg_dly and prb_dly, enable bits      */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
name|cvmx_ipd_red_delay_t
name|red_delay
decl_stmt|;
name|cvmx_ipd_red_bpid_enablex_t
name|red_bpid_enable
decl_stmt|;
name|red_delay
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|red_delay
operator|.
name|s
operator|.
name|avg_dly
operator|=
name|IPD_RED_AVG_DLY
expr_stmt|;
name|red_delay
operator|.
name|s
operator|.
name|prb_dly
operator|=
name|IPD_RED_PRB_DLY
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_RED_DELAY
argument_list|,
name|red_delay
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 	 * Only enable the gmx ports 	 */
name|red_bpid_enable
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|interface
operator|=
literal|0
init|;
name|interface
operator|<
name|CVMX_HELPER_MAX_GMX
condition|;
name|interface
operator|++
control|)
block|{
name|int
name|num_ports
init|=
name|cvmx_helper_ports_on_interface
argument_list|(
name|interface
argument_list|)
decl_stmt|;
for|for
control|(
name|port
operator|=
literal|0
init|;
name|port
operator|<
name|num_ports
condition|;
name|port
operator|++
control|)
name|red_bpid_enable
operator|.
name|u64
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
literal|1
operator|)
operator|<<
name|cvmx_helper_get_bpid
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
operator|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_RED_BPID_ENABLEX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|red_bpid_enable
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ipd_red_port_enable_t
name|red_port_enable
decl_stmt|;
name|red_port_enable
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|red_port_enable
operator|.
name|s
operator|.
name|prt_enb
operator|=
literal|0xfffffffffull
expr_stmt|;
name|red_port_enable
operator|.
name|s
operator|.
name|avg_dly
operator|=
name|IPD_RED_AVG_DLY
expr_stmt|;
name|red_port_enable
operator|.
name|s
operator|.
name|prb_dly
operator|=
name|IPD_RED_PRB_DLY
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_RED_PORT_ENABLE
argument_list|,
name|red_port_enable
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* 	 * Shutoff the dropping of packets based on RED for SRIO ports 	 */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_SRIO
argument_list|)
condition|)
block|{
name|cvmx_ipd_red_port_enable2_t
name|red_port_enable2
decl_stmt|;
name|red_port_enable2
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|red_port_enable2
operator|.
name|s
operator|.
name|prt_enb
operator|=
literal|0xf0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_RED_PORT_ENABLE2
argument_list|,
name|red_port_enable2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_setup_red
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Setup the common GMX settings that determine the number of  * ports. These setting apply to almost all configurations of all  * chips.  *  * @param interface Interface to configure  * @param num_ports Number of ports on the interface  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_setup_gmx
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|num_ports
parameter_list|)
block|{
name|cvmx_gmxx_tx_prts_t
name|gmx_tx_prts
decl_stmt|;
name|cvmx_gmxx_rx_prts_t
name|gmx_rx_prts
decl_stmt|;
name|cvmx_pko_reg_gmx_port_mode_t
name|pko_mode
decl_stmt|;
name|cvmx_gmxx_txx_thresh_t
name|gmx_tx_thresh
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/*      * Tell GMX the number of TX ports on this interface      */
name|gmx_tx_prts
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TX_PRTS
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_tx_prts
operator|.
name|s
operator|.
name|prts
operator|=
name|num_ports
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TX_PRTS
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmx_tx_prts
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/*      * Tell GMX the number of RX ports on this interface.  This only applies      * to GMII and XAUI ports      */
if|if
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_RGMII
operator|||
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_SGMII
operator|||
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_GMII
operator|||
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_XAUI
condition|)
block|{
if|if
condition|(
name|num_ports
operator|>
literal|4
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"__cvmx_helper_setup_gmx: Illegal num_ports\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gmx_rx_prts
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RX_PRTS
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|gmx_rx_prts
operator|.
name|s
operator|.
name|prts
operator|=
name|num_ports
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_RX_PRTS
argument_list|(
name|interface
argument_list|)
argument_list|,
name|gmx_rx_prts
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/*       * Skip setting CVMX_PKO_REG_GMX_PORT_MODE on 30XX, 31XX, 50XX,      * and 68XX.      */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
comment|/* Tell PKO the number of ports on this interface */
name|pko_mode
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PKO_REG_GMX_PORT_MODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|num_ports
operator|==
literal|1
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode0
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|==
literal|2
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode0
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|<=
literal|4
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode0
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|<=
literal|8
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode0
operator|=
literal|1
expr_stmt|;
else|else
name|pko_mode
operator|.
name|s
operator|.
name|mode0
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|num_ports
operator|==
literal|1
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode1
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|==
literal|2
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode1
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|<=
literal|4
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode1
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|<=
literal|8
condition|)
name|pko_mode
operator|.
name|s
operator|.
name|mode1
operator|=
literal|1
expr_stmt|;
else|else
name|pko_mode
operator|.
name|s
operator|.
name|mode1
operator|=
literal|0
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PKO_REG_GMX_PORT_MODE
argument_list|,
name|pko_mode
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/*       * Set GMX to buffer as much data as possible before starting      * transmit. This reduces the chances that we have a TX under run      * due to memory contention. Any packet that fits entirely in the      * GMX FIFO can never have an under run regardless of memory load.      */
name|gmx_tx_thresh
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TXX_THRESH
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
comment|/* These chips have a fixed max threshold of 0x40 */
name|gmx_tx_thresh
operator|.
name|s
operator|.
name|cnt
operator|=
literal|0x40
expr_stmt|;
else|else
block|{
comment|/* ccn - common cnt numberator */
name|int
name|ccn
init|=
literal|0x100
decl_stmt|;
comment|/* Choose the max value for the number of ports */
if|if
condition|(
name|num_ports
operator|<=
literal|1
condition|)
name|gmx_tx_thresh
operator|.
name|s
operator|.
name|cnt
operator|=
name|ccn
operator|/
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|num_ports
operator|==
literal|2
condition|)
name|gmx_tx_thresh
operator|.
name|s
operator|.
name|cnt
operator|=
name|ccn
operator|/
literal|2
expr_stmt|;
else|else
name|gmx_tx_thresh
operator|.
name|s
operator|.
name|cnt
operator|=
name|ccn
operator|/
literal|4
expr_stmt|;
block|}
comment|/*      * SPI and XAUI can have lots of ports but the GMX hardware only ever has      * a max of 4      */
if|if
condition|(
name|num_ports
operator|>
literal|4
condition|)
name|num_ports
operator|=
literal|4
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_THRESH
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|gmx_tx_thresh
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/*      * For o68, we need to setup the pipes      */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
name|interface
operator|<
name|CVMX_HELPER_MAX_GMX
condition|)
block|{
name|cvmx_gmxx_txx_pipe_t
name|config
decl_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|num_ports
condition|;
name|index
operator|++
control|)
block|{
name|config
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__cvmx_helper_cfg_pko_port_base
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|config
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_TXX_PIPE
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|config
operator|.
name|s
operator|.
name|nump
operator|=
name|__cvmx_helper_cfg_pko_port_num
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|config
operator|.
name|s
operator|.
name|base
operator|=
name|__cvmx_helper_cfg_pko_port_base
argument_list|(
name|interface
argument_list|,
name|index
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_GMXX_TXX_PIPE
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|,
name|config
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_helper_get_pko_port
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|port
parameter_list|)
block|{
return|return
name|cvmx_pko_get_base_pko_port
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_pko_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvmx_helper_get_ipd_port
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
if|if
condition|(
name|interface
operator|>=
literal|0
operator|&&
name|interface
operator|<=
literal|4
condition|)
block|{
name|cvmx_helper_interface_mode_t
name|mode
init|=
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_XAUI
operator|||
name|mode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_RXAUI
condition|)
return|return
literal|0x840
operator|+
operator|(
name|interface
operator|*
literal|0x100
operator|)
return|;
else|else
return|return
literal|0x800
operator|+
operator|(
name|interface
operator|*
literal|0x100
operator|)
operator|+
operator|(
name|port
operator|*
literal|16
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|interface
operator|==
literal|5
operator|||
name|interface
operator|==
literal|6
condition|)
return|return
literal|0x400
operator|+
operator|(
name|interface
operator|-
literal|5
operator|)
operator|*
literal|0x100
operator|+
name|port
return|;
elseif|else
if|if
condition|(
name|interface
operator|==
literal|7
condition|)
return|return
literal|0x100
operator|+
name|port
return|;
elseif|else
if|if
condition|(
name|interface
operator|==
literal|8
condition|)
return|return
name|port
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
switch|switch
condition|(
name|interface
condition|)
block|{
case|case
literal|0
case|:
return|return
name|port
return|;
case|case
literal|1
case|:
return|return
name|port
operator|+
literal|16
return|;
case|case
literal|2
case|:
return|return
name|port
operator|+
literal|32
return|;
case|case
literal|3
case|:
return|return
name|port
operator|+
literal|36
return|;
case|case
literal|4
case|:
return|return
name|port
operator|+
literal|40
return|;
case|case
literal|5
case|:
return|return
name|port
operator|+
literal|42
return|;
case|case
literal|6
case|:
return|return
name|port
operator|+
literal|44
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_ipd_port
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|__cvmx_helper_get_num_ipd_ports
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|struct
name|cvmx_iface
modifier|*
name|piface
decl_stmt|;
if|if
condition|(
name|interface
operator|>=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|piface
operator|=
operator|&
name|cvmx_interfaces
index|[
name|interface
index|]
expr_stmt|;
return|return
name|piface
operator|->
name|cvif_ipd_nports
return|;
block|}
end_function

begin_function
name|enum
name|cvmx_pko_padding
name|__cvmx_helper_get_pko_padding
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|struct
name|cvmx_iface
modifier|*
name|piface
decl_stmt|;
if|if
condition|(
name|interface
operator|>=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
condition|)
return|return
name|CVMX_PKO_PADDING_NONE
return|;
name|piface
operator|=
operator|&
name|cvmx_interfaces
index|[
name|interface
index|]
expr_stmt|;
return|return
name|piface
operator|->
name|cvif_padding
return|;
block|}
end_function

begin_function
name|int
name|__cvmx_helper_init_interface
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|num_ipd_ports
parameter_list|,
name|int
name|has_fcs
parameter_list|,
name|enum
name|cvmx_pko_padding
name|pad
parameter_list|)
block|{
name|struct
name|cvmx_iface
modifier|*
name|piface
decl_stmt|;
name|int
name|sz
decl_stmt|;
if|if
condition|(
name|interface
operator|>=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|piface
operator|=
operator|&
name|cvmx_interfaces
index|[
name|interface
index|]
expr_stmt|;
name|piface
operator|->
name|cvif_ipd_nports
operator|=
name|num_ipd_ports
expr_stmt|;
name|piface
operator|->
name|cvif_padding
operator|=
name|pad
expr_stmt|;
name|piface
operator|->
name|cvif_has_fcs
operator|=
name|has_fcs
expr_stmt|;
comment|/*      * allocate the per-ipd_port link_info structure      */
name|sz
operator|=
name|piface
operator|->
name|cvif_ipd_nports
operator|*
sizeof|sizeof
argument_list|(
name|cvmx_helper_link_info_t
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
if|if
condition|(
name|sz
operator|==
literal|0
condition|)
name|sz
operator|=
sizeof|sizeof
argument_list|(
name|cvmx_helper_link_info_t
argument_list|)
expr_stmt|;
name|piface
operator|->
name|cvif_ipd_port_link_info
operator|=
operator|(
name|cvmx_helper_link_info_t
operator|*
operator|)
name|kmalloc
argument_list|(
name|sz
argument_list|,
name|GFP_KERNEL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZERO_OR_NULL_PTR
argument_list|(
name|piface
operator|->
name|cvif_ipd_port_link_info
argument_list|)
condition|)
name|panic
argument_list|(
literal|"Cannot allocate memory in __cvmx_helper_init_interface."
argument_list|)
expr_stmt|;
else|#
directive|else
name|piface
operator|->
name|cvif_ipd_port_link_info
operator|=
operator|(
name|cvmx_helper_link_info_t
operator|*
operator|)
name|cvmx_bootmem_alloc
argument_list|(
name|sz
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_helper_link_info_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|piface
operator|->
name|cvif_ipd_port_link_info
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Initialize 'em */
block|{
name|int
name|i
decl_stmt|;
name|cvmx_helper_link_info_t
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|piface
operator|->
name|cvif_ipd_port_link_info
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|piface
operator|->
name|cvif_ipd_nports
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|p
operator|)
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Shut down the interfaces; free the resources.  * @INTERNAL  */
end_comment

begin_function
name|void
name|__cvmx_helper_shutdown_interfaces
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|nifaces
decl_stmt|;
comment|/* number of interfaces */
name|struct
name|cvmx_iface
modifier|*
name|piface
decl_stmt|;
name|nifaces
operator|=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nifaces
condition|;
name|i
operator|++
control|)
block|{
name|piface
operator|=
name|cvmx_interfaces
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|piface
operator|->
name|cvif_ipd_port_link_info
condition|)
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
name|kfree
argument_list|(
name|piface
operator|->
name|cvif_ipd_port_link_info
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* 	     * For SE apps, bootmem was meant to be allocated and never 	     * freed. 	     */
endif|#
directive|endif
name|piface
operator|->
name|cvif_ipd_port_link_info
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|__cvmx_helper_set_link_info
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|port
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
name|struct
name|cvmx_iface
modifier|*
name|piface
decl_stmt|;
if|if
condition|(
name|interface
operator|>=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
name|piface
operator|=
operator|&
name|cvmx_interfaces
index|[
name|interface
index|]
expr_stmt|;
if|if
condition|(
name|piface
operator|->
name|cvif_ipd_port_link_info
condition|)
block|{
name|piface
operator|->
name|cvif_ipd_port_link_info
index|[
name|port
index|]
operator|=
name|link_info
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_get_link_info
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|struct
name|cvmx_iface
modifier|*
name|piface
decl_stmt|;
name|cvmx_helper_link_info_t
name|err
decl_stmt|;
name|err
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|interface
operator|>=
name|cvmx_helper_get_number_of_interfaces
argument_list|()
condition|)
return|return
name|err
return|;
name|piface
operator|=
operator|&
name|cvmx_interfaces
index|[
name|interface
index|]
expr_stmt|;
if|if
condition|(
name|piface
operator|->
name|cvif_ipd_port_link_info
condition|)
return|return
name|piface
operator|->
name|cvif_ipd_port_link_info
index|[
name|port
index|]
return|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|int
name|__cvmx_helper_get_has_fcs
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
return|return
name|cvmx_interfaces
index|[
name|interface
index|]
operator|.
name|cvif_has_fcs
return|;
block|}
end_function

begin_function
name|int
name|cvmx_helper_get_pknd
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
return|return
name|__cvmx_helper_cfg_pknd
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
return|;
return|return
name|CVMX_INVALID_PKND
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_pknd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvmx_helper_get_bpid
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
return|return
name|__cvmx_helper_cfg_bpid
argument_list|(
name|interface
argument_list|,
name|port
argument_list|)
return|;
return|return
name|CVMX_INVALID_BPID
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_bpid
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Display interface statistics.  *  * @param port IPD/PKO port number  *  * @return none  */
end_comment

begin_function
name|void
name|cvmx_helper_show_stats
parameter_list|(
name|int
name|port
parameter_list|)
block|{
name|cvmx_pip_port_status_t
name|status
decl_stmt|;
name|cvmx_pko_port_status_t
name|pko_status
decl_stmt|;
comment|/* ILK stats */
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_ILK
argument_list|)
condition|)
name|__cvmx_helper_ilk_show_stats
argument_list|()
expr_stmt|;
comment|/* PIP stats */
name|cvmx_pip_get_port_status
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"port %d: the number of packets - ipd: %d\n"
argument_list|,
name|port
argument_list|,
operator|(
name|int
operator|)
name|status
operator|.
name|packets
argument_list|)
expr_stmt|;
comment|/* PKO stats */
name|cvmx_pko_get_port_status
argument_list|(
name|port
argument_list|,
literal|0
argument_list|,
operator|&
name|pko_status
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"port %d: the number of packets - pko: %d\n"
argument_list|,
name|port
argument_list|,
operator|(
name|int
operator|)
name|pko_status
operator|.
name|packets
argument_list|)
expr_stmt|;
comment|/* TODO: other stats */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_HELPER_FUNCTIONS */
end_comment

begin_comment
comment|/**  * Returns the interface number for an IPD/PKO port number.  *  * @param ipd_port IPD/PKO port number  *  * @return Interface number  */
end_comment

begin_function
name|int
name|cvmx_helper_get_interface_num
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
if|if
condition|(
name|ipd_port
operator|>=
literal|0x800
operator|&&
name|ipd_port
operator|<
literal|0x900
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0x900
operator|&&
name|ipd_port
operator|<
literal|0xa00
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0xa00
operator|&&
name|ipd_port
operator|<
literal|0xb00
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0xb00
operator|&&
name|ipd_port
operator|<
literal|0xc00
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0xc00
operator|&&
name|ipd_port
operator|<
literal|0xd00
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0x400
operator|&&
name|ipd_port
operator|<
literal|0x500
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0x500
operator|&&
name|ipd_port
operator|<
literal|0x600
condition|)
return|return
literal|6
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0x100
operator|&&
name|ipd_port
operator|<
literal|0x120
condition|)
return|return
literal|7
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|8
condition|)
return|return
literal|8
return|;
block|}
else|else
block|{
if|if
condition|(
name|ipd_port
operator|<
literal|16
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|32
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|36
condition|)
return|return
literal|2
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|40
condition|)
return|return
literal|3
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|42
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|44
condition|)
return|return
literal|5
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|46
condition|)
return|return
literal|6
return|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"cvmx_helper_get_interface_num: Illegal IPD port number %d\n"
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_interface_num
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Returns the interface index number for an IPD/PKO port  * number.  *  * @param ipd_port IPD/PKO port number  *  * @return Interface index number  */
end_comment

begin_function
name|int
name|cvmx_helper_get_interface_index_num
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
if|if
condition|(
name|octeon_has_feature
argument_list|(
name|OCTEON_FEATURE_PKND
argument_list|)
condition|)
block|{
if|if
condition|(
name|ipd_port
operator|>=
literal|0x800
operator|&&
name|ipd_port
operator|<
literal|0xd00
condition|)
block|{
name|int
name|port
init|=
operator|(
operator|(
name|ipd_port
operator|&
literal|0xff
operator|)
operator|>>
literal|6
operator|)
decl_stmt|;
return|return
operator|(
operator|(
name|port
operator|)
condition|?
operator|(
name|port
operator|-
literal|1
operator|)
else|:
operator|(
operator|(
name|ipd_port
operator|&
literal|0xff
operator|)
operator|>>
literal|4
operator|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0x400
operator|&&
name|ipd_port
operator|<
literal|0x600
condition|)
return|return
operator|(
name|ipd_port
operator|&
literal|0xff
operator|)
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|0x100
operator|&&
name|ipd_port
operator|<
literal|0x120
condition|)
return|return
operator|(
name|ipd_port
operator|&
literal|0xff
operator|)
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|8
condition|)
return|return
name|ipd_port
return|;
else|else
name|cvmx_dprintf
argument_list|(
literal|"cvmx_helper_get_interface_index_num: Illegal IPD port number %d\n"
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|ipd_port
operator|<
literal|32
condition|)
return|return
name|ipd_port
operator|&
literal|15
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|40
condition|)
return|return
name|ipd_port
operator|&
literal|3
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|44
condition|)
return|return
name|ipd_port
operator|&
literal|1
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|<
literal|46
condition|)
return|return
name|ipd_port
operator|&
literal|1
return|;
else|else
name|cvmx_dprintf
argument_list|(
literal|"cvmx_helper_get_interface_index_num: Illegal IPD port number\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_get_interface_index_num
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

