begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * This header defines the CVMX interface to the NAND flash controller. The  * basic operations common to all NAND devices are supported by this API, but  * many more advanced functions are not support. The low level hardware supports  * all types of transactions, but this API only implements the must commonly  * used operations. This API performs no locking, so it is the responsibility of  * the caller to make sure only one thread of execution is accessing the NAND  * controller at a time. Most applications should not use this API directly but  * instead use a flash logical layer supplied through a secondary system. For  * example, the Linux MTD layer provides a driver for running JFFS2 on top of  * NAND flash.  *  *<h2>Selecting the NAND Chip</h2>  *  * Octeon's NAND controller assumes a single NAND chip is connected to a boot  * bus chip select. Throughout this API, NAND chips are referred to by the chip  * select they are connected to (0-7). Chip select 0 will only be a NAND chip  * when you are booting from NAND flash.  *  *<h2>NAND Addressing</h2>  *  * Various functions in cvmx-nand use addresses to index into NAND flash. All  * functions us a uniform address translation scheme to map the passed address  * into a NAND block, page, and column. In NAND flash a page represents the  * basic unit of reads and writes. Each page contains a power of two number of  * bytes and some number of extra out of band (OOB) bytes. A fixed number of  * pages fit into each NAND block. Here is the mapping of bits in the cvmx-nand  * address to the NAND hardware:  *<pre>  * 63     56      48      40      32      24      16       8      0  * +-------+-------+-------+-------+-------+-------+-------+------+  * |                                 64 bit cvmx-nand nand_address|  * +------------------------------------------------+----+--------+  * |                                          block |page| column |  * +-------+-------+-------+-------+-------+--------+----+--------+  * 63     56      48      40      32      24      16       8      0  *</pre>  * Basically the block, page, and column addresses are packet together. Before  * being sent out the NAND pins for addressing the column is padded out to an  * even number of bytes. This means that column address are 2 bytes, or 2  * address cycles, for page sizes between 512 and 65536 bytes. Page sizes  * between 128KB and 16MB would use 3 column address cycles. NAND device  * normally either have 32 or 64 pages per block, needing either 5 or 6 address  * bits respectively. This means you have 10 bits for block address using 4  * address cycles, or 18 for 5 address cycles. Using the cvmx-nand addressing  * scheme, it is not possible to directly index the OOB data. Instead you can  * access it by reading or writing more data than the normal page size would  * allow. Logically the OOB data is appended onto the the page data. For  * example, this means that a read of 65 bytes from a column address of 0x7ff  * would yield byte 2047 of the page and then 64 bytes of OOB data.  *  *<hr>$Revision: 35726 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_NAND_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_NAND_H__
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* Maxium PAGE + OOB size supported.  This is used to size ** buffers, some that must be statically allocated. */
define|#
directive|define
name|CVMX_NAND_MAX_PAGE_AND_OOB_SIZE
value|(4096 + 256)
comment|/* Block size for boot ECC */
define|#
directive|define
name|CVMX_NAND_BOOT_ECC_BLOCK_SIZE
value|(256)
comment|/* ECC bytes for each block */
define|#
directive|define
name|CVMX_NAND_BOOT_ECC_ECC_SIZE
value|(8)
comment|/**  * Flags to be passed to the initialize function  */
typedef|typedef
enum|enum
block|{
name|CVMX_NAND_INITIALIZE_FLAGS_16BIT
init|=
literal|1
operator|<<
literal|0
block|,
name|CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE
init|=
literal|1
operator|<<
literal|1
block|,
name|CVMX_NAND_INITIALIZE_FLAGS_DEBUG
init|=
literal|1
operator|<<
literal|15
block|, }
name|cvmx_nand_initialize_flags_t
typedef|;
comment|/**  * Return codes from NAND functions  */
typedef|typedef
enum|enum
block|{
name|CVMX_NAND_SUCCESS
init|=
literal|0
block|,
name|CVMX_NAND_NO_MEMORY
init|=
operator|-
literal|1
block|,
name|CVMX_NAND_BUSY
init|=
operator|-
literal|2
block|,
name|CVMX_NAND_INVALID_PARAM
init|=
operator|-
literal|3
block|,
name|CVMX_NAND_TIMEOUT
init|=
operator|-
literal|4
block|,
name|CVMX_NAND_ERROR
init|=
operator|-
literal|5
block|,
name|CVMX_NAND_NO_DEVICE
init|=
operator|-
literal|6
block|, }
name|cvmx_nand_status_t
typedef|;
comment|/**  * NAND NOP command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_nop_t
typedef|;
comment|/**  * NAND SET_TM_PAR command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|tim_par7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_par6
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_par5
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_par4
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_par3
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_par2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_par1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tim_mult
range|:
literal|4
decl_stmt|;
name|uint64_t
name|one
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_set_tm_par_t
typedef|;
comment|/**  * NAND WAIT command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|n
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|r_b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|two
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_wait_t
typedef|;
comment|/**  * NAND CHIP_EN command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|width
range|:
literal|2
decl_stmt|;
name|uint64_t
name|one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|three
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_chip_en_t
typedef|;
comment|/**  * NAND CHIP_DIS command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|three
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_chip_dis_t
typedef|;
comment|/**  * NAND CLE command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|clen3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cmd_data
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|four
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_cle_t
typedef|;
comment|/**  * NAND ALE command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_96_127
range|:
literal|32
decl_stmt|;
name|uint64_t
name|adr_bytes_h
range|:
literal|32
decl_stmt|;
name|uint64_t
name|adr_bytes_l
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|alen4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|alen3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|alen2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|alen1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|adr_byte_num
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|five
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_ale_t
typedef|;
comment|/**  * NAND WR command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|wrn2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wrn1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_20_24
range|:
literal|4
decl_stmt|;
name|uint64_t
name|data_bytes
range|:
literal|16
decl_stmt|;
name|uint64_t
name|eight
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_wr_t
typedef|;
comment|/**  * NAND RD command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rdn4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|data_bytes
range|:
literal|16
decl_stmt|;
name|uint64_t
name|nine
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_rd_t
typedef|;
comment|/**  * NAND RD_EDO command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|rdn4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|data_bytes
range|:
literal|16
decl_stmt|;
name|uint64_t
name|ten
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_rd_edo_t
typedef|;
comment|/**  * NAND WAIT_STATUS command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|rdn4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|comp_byte
range|:
literal|8
decl_stmt|;
name|uint64_t
name|and_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nine
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_28_95
range|:
literal|64
decl_stmt|;
name|uint64_t
name|clen4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|data
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|eleven
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_wait_status_t
typedef|;
comment|/**  * NAND WAIT_STATUS_ALE command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|rdn4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rdn1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|comp_byte
range|:
literal|8
decl_stmt|;
name|uint64_t
name|and_mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nine
range|:
literal|4
decl_stmt|;
name|uint64_t
name|adr_bytes
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|alen4
range|:
literal|3
decl_stmt|;
name|uint64_t
name|alen3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|alen2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|alen1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_44_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|adr_byte_num
range|:
literal|4
decl_stmt|;
name|uint64_t
name|five
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_25_31
range|:
literal|7
decl_stmt|;
name|uint64_t
name|clen3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|clen1
range|:
literal|3
decl_stmt|;
name|uint64_t
name|data
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|eleven
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_wait_status_ale_t
typedef|;
comment|/**  * NAND BUS_ACQ command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|one
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fifteen
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_bus_acq_t
typedef|;
comment|/**  * NAND BUS_REL command definition  */
typedef|typedef
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|zero
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fifteen
range|:
literal|4
decl_stmt|;
block|}
name|cvmx_nand_cmd_bus_rel_t
typedef|;
comment|/**  * NAND command union of all possible commands  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
index|[
literal|2
index|]
decl_stmt|;
name|cvmx_nand_cmd_nop_t
name|nop
decl_stmt|;
name|cvmx_nand_cmd_set_tm_par_t
name|set_tm_par
decl_stmt|;
name|cvmx_nand_cmd_wait_t
name|wait
decl_stmt|;
name|cvmx_nand_cmd_chip_en_t
name|chip_en
decl_stmt|;
name|cvmx_nand_cmd_chip_dis_t
name|chip_dis
decl_stmt|;
name|cvmx_nand_cmd_cle_t
name|cle
decl_stmt|;
name|cvmx_nand_cmd_ale_t
name|ale
decl_stmt|;
name|cvmx_nand_cmd_rd_t
name|rd
decl_stmt|;
name|cvmx_nand_cmd_rd_edo_t
name|rd_edo
decl_stmt|;
name|cvmx_nand_cmd_wr_t
name|wr
decl_stmt|;
name|cvmx_nand_cmd_wait_status_t
name|wait_status
decl_stmt|;
name|cvmx_nand_cmd_wait_status_ale_t
name|wait_status_ale
decl_stmt|;
name|cvmx_nand_cmd_bus_acq_t
name|bus_acq
decl_stmt|;
name|cvmx_nand_cmd_bus_rel_t
name|bus_rel
decl_stmt|;
struct|struct
block|{
name|uint64_t
name|reserved_64_127
range|:
literal|64
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|op_code
range|:
literal|4
decl_stmt|;
block|}
name|s
struct|;
block|}
name|cvmx_nand_cmd_t
typedef|;
typedef|typedef
name|struct
name|__attribute__
argument_list|(
operator|(
name|packed
operator|)
argument_list|)
block|{
name|char
name|onfi
index|[
literal|4
index|]
block|;
comment|/**< Bytes 0-3: The ASCII characters 'O', 'N', 'F', 'I' */
name|uint16_t
name|revision_number
block|;
comment|/**< Bytes 4-5: ONFI revision number                                         - 2-15 Reserved (0)                                         - 1    1 = supports ONFI version 1.0                                         - 0    Reserved (0) */
name|uint16_t
name|features
block|;
comment|/**< Bytes 6-7: Features supported                                         - 5-15    Reserved (0)                                         - 4       1 = supports odd to even page Copyback                                         - 3       1 = supports interleaved operations                                         - 2       1 = supports non-sequential page programming                                         - 1       1 = supports multiple LUN operations                                         - 0       1 = supports 16-bit data bus width */
name|uint16_t
name|optional_commands
block|;
comment|/**< Bytes 8-9: Optional commands supported                                         - 6-15   Reserved (0)                                         - 5      1 = supports Read Unique ID                                         - 4      1 = supports Copyback                                         - 3      1 = supports Read Status Enhanced                                         - 2      1 = supports Get Features and Set Features                                         - 1      1 = supports Read Cache commands                                         - 0      1 = supports Page Cache Program command */
name|uint8_t
name|reserved_10_31
index|[
literal|22
index|]
block|;
comment|/**< Bytes 10-31: Reserved */
name|char
name|manufacturer
index|[
literal|12
index|]
block|;
comment|/**< Bytes 32-43: Device manufacturer (12 ASCII characters) */
name|char
name|model
index|[
literal|20
index|]
block|;
comment|/**< Bytes 40-63: Device model (20 ASCII characters) */
name|uint8_t
name|jedec_id
block|;
comment|/**< Byte 64: JEDEC manufacturer ID */
name|uint16_t
name|date_code
block|;
comment|/**< Byte 65-66: Date code */
name|uint8_t
name|reserved_67_79
index|[
literal|13
index|]
block|;
comment|/**< Bytes 67-79: Reserved */
name|uint32_t
name|page_data_bytes
block|;
comment|/**< Bytes 80-83: Number of data bytes per page */
name|uint16_t
name|page_spare_bytes
block|;
comment|/**< Bytes 84-85: Number of spare bytes per page */
name|uint32_t
name|partial_page_data_bytes
block|;
comment|/**< Bytes 86-89: Number of data bytes per partial page */
name|uint16_t
name|partial_page_spare_bytes
block|;
comment|/**< Bytes 90-91: Number of spare bytes per partial page */
name|uint32_t
name|pages_per_block
block|;
comment|/**< Bytes 92-95: Number of pages per block */
name|uint32_t
name|blocks_per_lun
block|;
comment|/**< Bytes 96-99: Number of blocks per logical unit (LUN) */
name|uint8_t
name|number_lun
block|;
comment|/**< Byte 100: Number of logical units (LUNs) */
name|uint8_t
name|address_cycles
block|;
comment|/**< Byte 101: Number of address cycles                                         - 4-7     Column address cycles                                         - 0-3     Row address cycles */
name|uint8_t
name|bits_per_cell
block|;
comment|/**< Byte 102: Number of bits per cell */
name|uint16_t
name|bad_block_per_lun
block|;
comment|/**< Bytes 103-104: Bad blocks maximum per LUN */
name|uint16_t
name|block_endurance
block|;
comment|/**< Bytes 105-106: Block endurance */
name|uint8_t
name|good_blocks
block|;
comment|/**< Byte 107: Guaranteed valid blocks at beginning of target */
name|uint16_t
name|good_block_endurance
block|;
comment|/**< Bytes 108-109: Block endurance for guaranteed valid blocks */
name|uint8_t
name|programs_per_page
block|;
comment|/**< Byte 110: Number of programs per page */
name|uint8_t
name|partial_program_attrib
block|;
comment|/**< Byte 111: Partial programming attributes                                         - 5-7    Reserved                                         - 4      1 = partial page layout is partial page data followed by partial page spare                                         - 1-3    Reserved                                         - 0      1 = partial page programming has constraints */
name|uint8_t
name|bits_ecc
block|;
comment|/**< Byte 112: Number of bits ECC correctability */
name|uint8_t
name|interleaved_address_bits
block|;
comment|/**< Byte 113: Number of interleaved address bits                                             - 4-7    Reserved (0)                                             - 0-3    Number of interleaved address bits */
name|uint8_t
name|interleaved_attrib
block|;
comment|/**< Byte 114: Interleaved operation attributes                                         - 4-7    Reserved (0)                                         - 3      Address restrictions for program cache                                         - 2      1 = program cache supported                                         - 1      1 = no block address restrictions                                         - 0      Overlapped / concurrent interleaving support */
name|uint8_t
name|reserved_115_127
index|[
literal|13
index|]
block|;
comment|/**< Bytes 115-127: Reserved (0) */
name|uint8_t
name|pin_capacitance
block|;
comment|/**< Byte 128: I/O pin capacitance */
name|uint16_t
name|timing_mode
block|;
comment|/**< Byte 129-130: Timing mode support                                         - 6-15   Reserved (0)                                         - 5      1 = supports timing mode 5                                         - 4      1 = supports timing mode 4                                         - 3      1 = supports timing mode 3                                         - 2      1 = supports timing mode 2                                         - 1      1 = supports timing mode 1                                         - 0      1 = supports timing mode 0, shall be 1 */
name|uint16_t
name|cache_timing_mode
block|;
comment|/**< Byte 131-132: Program cache timing mode support                                         - 6-15   Reserved (0)                                         - 5      1 = supports timing mode 5                                         - 4      1 = supports timing mode 4                                         - 3      1 = supports timing mode 3                                         - 2      1 = supports timing mode 2                                         - 1      1 = supports timing mode 1                                         - 0      1 = supports timing mode 0 */
name|uint16_t
name|t_prog
block|;
comment|/**< Byte 133-134: Maximum page program time (us) */
name|uint16_t
name|t_bers
block|;
comment|/**< Byte 135-136: Maximum block erase time (us) */
name|uint16_t
name|t_r
block|;
comment|/**< Byte 137-148: Maximum page read time (us) */
name|uint16_t
name|t_ccs
block|;
comment|/**< Byte 139-140: Minimum change column setup time (ns) */
name|uint8_t
name|reserved_141_163
index|[
literal|23
index|]
block|;
comment|/**< Byte 141-163: Reserved (0) */
name|uint16_t
name|vendor_revision
block|;
comment|/**< Byte 164-165: Vendor specific Revision number */
name|uint8_t
name|vendor_specific
index|[
literal|88
index|]
block|;
comment|/**< Byte 166-253: Vendor specific */
name|uint16_t
name|crc
block|;
comment|/**< Byte 254-255: Integrity CRC */
block|}
name|cvmx_nand_onfi_param_page_t
expr_stmt|;
comment|/**  * Called to initialize the NAND controller for use. Note that  * you must be running out of L2 or memory and not NAND before  * calling this function.  * When probing for NAND chips, this function attempts to autoconfigure based on the NAND parts detected.  * It currently supports autodetection for ONFI parts (with valid parameter pages), and some Samsung NAND  * parts (decoding ID bits.)  If autoconfiguration fails, the defaults set with __set_chip_defaults()  * prior to calling cvmx_nand_initialize() are used.  * If defaults are set and the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is provided, the defaults are used  * for all chips in the active_chips mask.  *  * @param flags  Optional initialization flags  *               If the CVMX_NAND_INITIALIZE_FLAGS_DONT_PROBE flag is passed, chips are not probed,  *               and the default parameters (if set with cvmx_nand_set_defaults) are used for all chips  *               in the active_chips mask.  * @param active_chips  *               Each bit in this parameter represents a chip select that might  *               contain NAND flash. Any chip select present in this bitmask may  *               be connected to NAND. It is normally safe to pass 0xff here and  *               let the API probe all 8 chip selects.  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_initialize
parameter_list|(
name|cvmx_nand_initialize_flags_t
name|flags
parameter_list|,
name|int
name|active_chips
parameter_list|)
function_decl|;
comment|/**  * This function may be called before cvmx_nand_initialize to set default values that will be used  * for NAND chips that do not identify themselves in a way that allows autoconfiguration. (ONFI chip with  * missing parameter page, for example.)  * The parameters set by this function will be used by _all_ non-autoconfigured NAND chips.  *  *  *   NOTE:  This function signature is _NOT_ stable, and will change in the future as required to support  *          various NAND chips.  *  * @param page_size page size in bytes  * @param oob_size  Out of band size in bytes (per page)  * @param pages_per_block  *                  number of pages per block  * @param blocks    Total number of blocks in device  * @param onfi_timing_mode  *                  ONFI timing mode  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_set_defaults
parameter_list|(
name|int
name|page_size
parameter_list|,
name|int
name|oob_size
parameter_list|,
name|int
name|pages_per_block
parameter_list|,
name|int
name|blocks
parameter_list|,
name|int
name|onfi_timing_mode
parameter_list|)
function_decl|;
comment|/**  * Call to shutdown the NAND controller after all transactions  * are done. In most setups this will never be called.  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_shutdown
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Returns a bitmask representing the chip selects that are  * connected to NAND chips. This can be called after the  * initialize to determine the actual number of NAND chips  * found. Each bit in the response coresponds to a chip select.  *  * @return Zero if no NAND chips were found. Otherwise a bit is set for  *         each chip select (1<<chip).  */
specifier|extern
name|int
name|cvmx_nand_get_active_chips
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Override the timing parameters for a NAND chip  *  * @param chip     Chip select to override  * @param tim_mult  * @param tim_par  * @param clen  * @param alen  * @param rdn  * @param wrn  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_set_timing
parameter_list|(
name|int
name|chip
parameter_list|,
name|int
name|tim_mult
parameter_list|,
name|int
name|tim_par
index|[
literal|7
index|]
parameter_list|,
name|int
name|clen
index|[
literal|4
index|]
parameter_list|,
name|int
name|alen
index|[
literal|4
index|]
parameter_list|,
name|int
name|rdn
index|[
literal|4
index|]
parameter_list|,
name|int
name|wrn
index|[
literal|2
index|]
parameter_list|)
function_decl|;
comment|/**  * Submit a command to the NAND command queue. Generally this  * will not be used directly. Instead most programs will use the other  * higher level NAND functions.  *  * @param cmd    Command to submit  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_submit
parameter_list|(
name|cvmx_nand_cmd_t
name|cmd
parameter_list|)
function_decl|;
comment|/**  * Read a page from NAND. If the buffer has room, the out of band  * data will be included.  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               Location in NAND to read. See description in file comment  * @param buffer_address  *               Physical address to store the result at  * @param buffer_length  *               Number of bytes to read  *  * @return Bytes read on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_page_read
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
function_decl|;
comment|/**  * Write a page to NAND. The buffer must contain the entire page  * including the out of band data.  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               Location in NAND to write. See description in file comment  * @param buffer_address  *               Physical address to read the data from  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_page_write
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|)
function_decl|;
comment|/**  * Erase a NAND block. A single block contains multiple pages.  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               Location in NAND to erase. See description in file comment  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_block_erase
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|)
function_decl|;
comment|/**  * Read the NAND ID information  *  * @param chip   Chip select for NAND flash  * @param nand_address  *               NAND address to read ID from. Usually this is either 0x0 or 0x20.  * @param buffer_address  *               Physical address to store data in  * @param buffer_length  *               Length of the buffer. Usually this is 4 bytes  *  * @return Bytes read on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_read_id
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|nand_address
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
function_decl|;
comment|/**  * Read the NAND parameter page  *  * @param chip   Chip select for NAND flash  * @param buffer_address  *               Physical address to store data in  * @param buffer_length  *               Length of the buffer. Usually this is 4 bytes  *  * @return Bytes read on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_read_param_page
parameter_list|(
name|int
name|chip
parameter_list|,
name|uint64_t
name|buffer_address
parameter_list|,
name|int
name|buffer_length
parameter_list|)
function_decl|;
comment|/**  * Get the status of the NAND flash  *  * @param chip   Chip select for NAND flash  *  * @return NAND status or a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_get_status
parameter_list|(
name|int
name|chip
parameter_list|)
function_decl|;
comment|/**  * Get the page size, excluding out of band data. This  function  * will return zero for chip selects not connected to NAND.  *  * @param chip   Chip select for NAND flash  *  * @return Page size in bytes or a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_get_page_size
parameter_list|(
name|int
name|chip
parameter_list|)
function_decl|;
comment|/**  * Get the OOB size.  *  * @param chip   Chip select for NAND flash  *  * @return OOB in bytes or a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_get_oob_size
parameter_list|(
name|int
name|chip
parameter_list|)
function_decl|;
comment|/**  * Get the number of pages per NAND block  *  * @param chip   Chip select for NAND flash  *  * @return Numboer of pages in each block or a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_get_pages_per_block
parameter_list|(
name|int
name|chip
parameter_list|)
function_decl|;
comment|/**  * Get the number of blocks in the NAND flash  *  * @param chip   Chip select for NAND flash  *  * @return Number of blocks or a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|int
name|cvmx_nand_get_blocks
parameter_list|(
name|int
name|chip
parameter_list|)
function_decl|;
comment|/**  * Reset the NAND flash  *  * @param chip   Chip select for NAND flash  *  * @return Zero on success, a negative cvmx_nand_status_t error code on failure  */
specifier|extern
name|cvmx_nand_status_t
name|cvmx_nand_reset
parameter_list|(
name|int
name|chip
parameter_list|)
function_decl|;
comment|/**  * This function computes the Octeon specific ECC data used by the NAND boot  * feature.  *  * @param block  pointer to 256 bytes of data  * @param eccp   pointer to where 8 bytes of ECC data will be stored  */
specifier|extern
name|void
name|cvmx_nand_compute_boot_ecc
parameter_list|(
name|unsigned
name|char
modifier|*
name|block
parameter_list|,
name|unsigned
name|char
modifier|*
name|eccp
parameter_list|)
function_decl|;
specifier|extern
name|int
name|cvmx_nand_correct_boot_ecc
parameter_list|(
name|uint8_t
modifier|*
name|block
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __CVMX_NAND_H__ */
end_comment

end_unit

