begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *   cvmx-shmem supplies the cross application shared memory implementation  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-tlb.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-shmem.h"
end_include

begin_comment
comment|//#define DEBUG
end_comment

begin_decl_stmt
name|struct
name|cvmx_shmem_smdr
modifier|*
name|__smdr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|__cvmx_shmem_devmemfd
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* fd for /dev/mem */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|__CHECK_APP_SMDR
value|do { \                 if (__smdr == NULL) { \                     cvmx_dprintf("cvmx_shmem: %s is not set up, Quit line %d \n", \                         CVMX_SHMEM_DSCPTR_NAME, __LINE__ ); \                     exit(-1); \                 } \               }while(0)
end_define

begin_comment
comment|/**  * @INTERNAL  * Virtual sbrk, assigning virtual address in a global virtual address space.  *  * @param alignment   alignment requirement in bytes  * @param size        size in bytes  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|__cvmx_shmem_vsbrk_64
parameter_list|(
name|uint64_t
name|alignment
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|uint64_t
name|nbase_64
init|=
name|CAST64
argument_list|(
name|__smdr
operator|->
name|break64
argument_list|)
decl_stmt|;
name|void
modifier|*
name|nbase
init|=
name|NULL
decl_stmt|;
comment|/* Skip unaligned bytes */
if|if
condition|(
name|nbase_64
operator|&
name|alignment
condition|)
name|nbase_64
operator|+=
operator|~
operator|(
name|nbase_64
operator|&
name|alignment
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nbase_64
operator|+
name|size
operator|<
name|CVMX_SHMEM_VADDR64_END
condition|)
block|{
name|nbase
operator|=
name|CASTPTR
argument_list|(
name|void
operator|*
argument_list|,
name|nbase_64
argument_list|)
expr_stmt|;
name|__smdr
operator|->
name|break64
operator|=
name|nbase
operator|+
name|size
expr_stmt|;
block|}
return|return
name|nbase
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize all SMDR entries, only need to be called once  *  * @param smdr pointer to the SMDR  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__smdr_new
parameter_list|(
name|struct
name|cvmx_shmem_smdr
modifier|*
name|smdr
parameter_list|)
block|{
if|if
condition|(
name|smdr
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_spinlock_init
argument_list|(
operator|&
name|smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_SHMEM_NUM_DSCPTR
condition|;
name|i
operator|++
control|)
block|{
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|owner
operator|=
name|CVMX_SHMEM_OWNER_NONE
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|is_named_block
operator|=
literal|0
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|use_count
operator|=
literal|0
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|name
operator|=
name|NULL
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|vaddr
operator|=
name|NULL
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|paddr
operator|=
literal|0
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|smdr
operator|->
name|shmd
index|[
name|i
index|]
operator|.
name|alignment
operator|=
literal|0
expr_stmt|;
block|}
empty_stmt|;
comment|/* Init vaddr */
name|smdr
operator|->
name|break64
operator|=
operator|(
name|void
operator|*
operator|)
name|CVMX_SHMEM_VADDR64_START
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure the shmem descriptor region is created */
name|__CHECK_APP_SMDR
expr_stmt|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * @INTERNAL  * Initialize __smdr pointer, if SMDR exits already. If not, create a new  * one.  Once SMDR is created (as a bootmem named block), it is persistent.  */
end_comment

begin_function
specifier|static
specifier|inline
name|struct
name|cvmx_shmem_smdr
modifier|*
name|__smdr_init
parameter_list|()
block|{
specifier|const
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|smdr_nblk
init|=
name|NULL
decl_stmt|;
name|size_t
name|smdr_size
init|=
sizeof|sizeof
argument_list|(
operator|*
name|__smdr
argument_list|)
decl_stmt|;
name|char
modifier|*
name|smdr_name
init|=
name|CVMX_SHMEM_DSCPTR_NAME
decl_stmt|;
name|__smdr
operator|=
operator|(
expr|struct
name|cvmx_shmem_smdr
operator|*
operator|)
name|cvmx_bootmem_alloc_named
argument_list|(
name|smdr_size
argument_list|,
literal|0x10000
argument_list|,
name|smdr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|__smdr
condition|)
name|__smdr_new
argument_list|(
name|__smdr
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Check if SMDR exists already */
name|smdr_nblk
operator|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|smdr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|smdr_nblk
condition|)
block|{
name|__smdr
operator|=
operator|(
expr|struct
name|cvmx_shmem_smdr
operator|*
operator|)
operator|(
name|cvmx_phys_to_ptr
argument_list|(
name|smdr_nblk
operator|->
name|base_addr
argument_list|)
operator|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|smdr_nblk
operator|->
name|size
operator|!=
name|smdr_size
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SMDR named block is created by another "
literal|"application with different size %lu, "
literal|"expecting %lu \n"
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|smdr_nblk
operator|->
name|size
argument_list|,
operator|(
name|long
name|unsigned
name|int
operator|)
name|smdr_size
argument_list|)
expr_stmt|;
name|__smdr
operator|=
name|NULL
expr_stmt|;
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|__smdr
condition|)
name|cvmx_dprintf
argument_list|(
literal|"cvmx_shmem: Failed to allocate or find SMDR from bootmem \n"
argument_list|)
expr_stmt|;
return|return
name|__smdr
return|;
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/**  * @INTERNAL  * Generic Iterator function for all SMDR entries  *  * @param void(*f)(dscptr) the function to be invoked for every descriptor  * @param param  *  * @return the descriptor iterator stopped at.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|__smdr_iterator
argument_list|(
expr|struct
name|cvmx_shmem_dscptr
operator|*
call|(
modifier|*
name|f
call|)
argument_list|(
expr|struct
name|cvmx_shmem_dscptr
operator|*
name|dscptr
argument_list|,
name|void
operator|*
name|p
argument_list|)
argument_list|,
name|void
operator|*
name|param
argument_list|)
block|{
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|d
decl_stmt|,
modifier|*
name|dscptr
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|__CHECK_APP_SMDR
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_SHMEM_NUM_DSCPTR
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|&
name|__smdr
operator|->
name|shmd
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|dscptr
operator|=
call|(
modifier|*
name|f
call|)
argument_list|(
name|d
argument_list|,
name|param
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
comment|/* stop iteration */
block|}
return|return
name|dscptr
return|;
block|}
end_decl_stmt

begin_comment
comment|/**  * @INTERNAL  * SMDR name match functor. to be used for iterator.  *  * @param dscptr  descriptor passed in by the iterator  * @param   name    string to match against  *  * @return !NULL   descriptor matched  *     NULL    not match  */
end_comment

begin_function
specifier|static
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|__cvmx_shmem_smdr_match_name
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|void
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|name_to_match
init|=
operator|(
name|char
operator|*
operator|)
name|name
decl_stmt|;
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dscptr
operator|->
name|owner
operator|==
name|CVMX_SHMEM_OWNER_NONE
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|dscptr
operator|->
name|name
argument_list|,
name|name_to_match
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|dscptr
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Find by name  *  * @param   name    string to match against  *  * @return !NULL    descriptor matched  *          NULL    not match  */
end_comment

begin_function
specifier|static
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|__cvmx_shmem_smdr_find_by_name
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|__smdr_iterator
argument_list|(
name|__cvmx_shmem_smdr_match_name
argument_list|,
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * SMDR is free functor. to be used for iterator.  *  * @param dscptr  descriptor passed in by the iterator  * @param nouse  *  * @return !NULL  descriptor is free  *          NULL  descriptor is not free  */
end_comment

begin_function
specifier|static
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|__cvmx_shmem_smdr_is_free
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|void
modifier|*
name|nouse
parameter_list|)
block|{
if|if
condition|(
name|dscptr
operator|->
name|owner
operator|==
name|CVMX_SHMEM_OWNER_NONE
condition|)
return|return
name|dscptr
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Search SMDR to find the first free descriptor  *  * @return !NULL   free descriptor found  *     NULL    nothing found  */
end_comment

begin_function
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|__cvmx_shmem_smdr_find_free_dscptr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|__smdr_iterator
argument_list|(
name|__cvmx_shmem_smdr_is_free
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * free a descriptor  *  * @param dscptr  descriptor to be freed  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_shmem_smdr_free
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|)
block|{
name|dscptr
operator|->
name|owner
operator|=
name|CVMX_SHMEM_OWNER_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Per core shmem init function  *  * @return  cvmx_shmem_smdr*   pointer to __smdr  */
end_comment

begin_function
name|struct
name|cvmx_shmem_smdr
modifier|*
name|cvmx_shmem_init
parameter_list|()
block|{
return|return
name|__smdr_init
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/**  * Open shared memory based on named block  *  * @return  dscptr descriptor of the opened named block  */
end_comment

begin_function
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|cvmx_shmem_named_block_open
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|size
parameter_list|,
name|int
name|oflag
parameter_list|)
block|{
specifier|const
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|shmem_nblk
init|=
name|NULL
decl_stmt|;
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
init|=
name|NULL
decl_stmt|;
name|int
name|nblk_allocated
init|=
literal|0
decl_stmt|;
comment|/* Assume we don't need to allocate a new                                bootmem block */
name|void
modifier|*
name|vaddr
init|=
name|NULL
decl_stmt|;
specifier|const
name|uint64_t
name|size_4k
init|=
literal|4
operator|*
literal|1024
decl_stmt|,
name|size_512mb
init|=
literal|512
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
name|__CHECK_APP_SMDR
expr_stmt|;
comment|/* Check size, Make sure it is minimal 4K, no bigger than 512MB */
if|if
condition|(
name|size
operator|>
name|size_512mb
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Shared memory size can not be bigger than 512MB \n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|size
operator|<
name|size_4k
condition|)
name|size
operator|=
name|size_4k
expr_stmt|;
name|size
operator|=
name|__upper_power_of_two
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|shmem_nblk
operator|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|shmem_nblk
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|oflag
operator|&
name|CVMX_SHMEM_O_CREAT
operator|)
condition|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
comment|/* The named block does not exist, create it if caller specifies           the O_CREAT flag */
name|nblk_allocated
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|cvmx_bootmem_alloc_named
argument_list|(
name|size
argument_list|,
name|size
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|shmem_nblk
operator|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem-dbg:"
literal|"creating a new block %s: blk %p, shmem_nblk %p \n"
argument_list|,
name|name
argument_list|,
name|p
argument_list|,
name|shmem_nblk
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|shmem_nblk
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
comment|/* We are now holding a valid named block */
name|dscptr
operator|=
name|__cvmx_shmem_smdr_find_by_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|dscptr
condition|)
block|{
if|if
condition|(
name|nblk_allocated
condition|)
block|{
comment|/* name conflict between bootmem name space and SMDR name space */
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem: SMDR descriptor name conflict, %s \n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
comment|/* Make sure size and alignment matches with existing descriptor */
if|if
condition|(
operator|(
name|size
operator|!=
name|dscptr
operator|->
name|size
operator|)
operator|||
operator|(
name|size
operator|!=
name|dscptr
operator|->
name|alignment
operator|)
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
comment|/* Create a new descriptor */
name|dscptr
operator|=
name|__cvmx_shmem_smdr_find_free_dscptr
argument_list|()
expr_stmt|;
if|if
condition|(
name|dscptr
condition|)
goto|goto
name|init
goto|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem: SMDR out of descriptors \n"
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
comment|/* Maintain the reference count */
if|if
condition|(
name|dscptr
operator|!=
name|NULL
condition|)
name|dscptr
operator|->
name|use_count
operator|+=
literal|1
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|dscptr
return|;
name|err
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem-dbg: named block open failed \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dscptr
condition|)
name|__cvmx_shmem_smdr_free
argument_list|(
name|dscptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|shmem_nblk
operator|&&
name|nblk_allocated
condition|)
name|cvmx_bootmem_free_named
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
name|init
label|:
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem-dbg: init SMDR descriptor %p \n"
argument_list|,
name|dscptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Assign vaddr for single address space mapping */
name|vaddr
operator|=
name|__cvmx_shmem_vsbrk_64
argument_list|(
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|vaddr
operator|==
name|NULL
condition|)
block|{
comment|/* Failed to allocate virtual address, clean up */
goto|goto
name|err
goto|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cmvx-shmem-dbg: allocated vaddr %p \n"
argument_list|,
name|vaddr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dscptr
operator|->
name|vaddr
operator|=
name|vaddr
expr_stmt|;
comment|/* Store descriptor information,  name, alignment,size... */
name|dscptr
operator|->
name|owner
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|dscptr
operator|->
name|is_named_block
operator|=
literal|1
expr_stmt|;
name|dscptr
operator|->
name|use_count
operator|=
literal|1
expr_stmt|;
name|dscptr
operator|->
name|name
operator|=
name|shmem_nblk
operator|->
name|name
expr_stmt|;
name|dscptr
operator|->
name|paddr
operator|=
name|shmem_nblk
operator|->
name|base_addr
expr_stmt|;
name|dscptr
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|dscptr
operator|->
name|alignment
operator|=
name|size
expr_stmt|;
comment|/* Store permission bits */
if|if
condition|(
name|oflag
operator|&
name|CVMX_SHMEM_O_WRONLY
condition|)
name|dscptr
operator|->
name|p_wronly
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|oflag
operator|&
name|CVMX_SHMEM_O_RDWR
condition|)
name|dscptr
operator|->
name|p_rdwr
operator|=
literal|1
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
name|dscptr
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  *  *  For stand along SE application only.  *  *  Add TLB mapping to map the shared memory  *  *  @param dscptr  shared memory descriptor  *  @param pflag   protection flags  *  *  @return vaddr  the virtual address mapped for the shared memory  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifndef

begin_function
name|void
modifier|*
name|__cvmx_shmem_map_standalone
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|pflag
parameter_list|)
block|{
name|int
name|free_index
decl_stmt|;
comment|/* Find a free tlb entry */
name|free_index
operator|=
name|cvmx_tlb_allocate_runtime_entry
argument_list|()
expr_stmt|;
if|if
condition|(
name|free_index
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem: shmem_map failed, out TLB entries \n"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cmvx-shmem-dbg:"
literal|"shmem_map TLB %d: vaddr %p paddr %lx, size %x \n"
argument_list|,
name|free_index
argument_list|,
name|dscptr
operator|->
name|vaddr
argument_list|,
name|dscptr
operator|->
name|paddr
argument_list|,
name|dscptr
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_tlb_write_runtime_entry
argument_list|(
name|free_index
argument_list|,
name|CAST64
argument_list|(
name|dscptr
operator|->
name|vaddr
argument_list|)
argument_list|,
name|dscptr
operator|->
name|paddr
argument_list|,
name|dscptr
operator|->
name|size
argument_list|,
name|TLB_DIRTY
operator||
name|TLB_VALID
operator||
name|TLB_GLOBAL
argument_list|)
expr_stmt|;
return|return
name|dscptr
operator|->
name|vaddr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  *  *  For Linux user application only  *  *  Add mmap the shared memory  *  *  @param dscptr  shared memory descriptor  *  @param pflag   protection flags  *  *  @return vaddr  the virtual address mapped for the shared memory  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|__cvmx_shmem_map_linux
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|pflag
parameter_list|)
block|{
name|void
modifier|*
name|vaddr
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|__cvmx_shmem_devmemfd
operator|==
literal|0
condition|)
block|{
name|__cvmx_shmem_devmemfd
operator|=
name|open
argument_list|(
literal|"/dev/mem"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_shmem_devmemfd
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Failed to open /dev/mem\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|vaddr
operator|=
name|mmap
argument_list|(
name|dscptr
operator|->
name|vaddr
argument_list|,
name|dscptr
operator|->
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|__cvmx_shmem_devmemfd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure the mmap maps to the same virtual address specified in      * descriptor      */
if|if
condition|(
operator|(
name|vaddr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|vaddr
operator|!=
name|dscptr
operator|->
name|vaddr
operator|)
condition|)
block|{
name|munmap
argument_list|(
name|vaddr
argument_list|,
name|dscptr
operator|->
name|size
argument_list|)
expr_stmt|;
name|vaddr
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|vaddr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *  cvmx_shmem API  *  *  Add mapping for the shared memory  *  *  @param dscptr  shared memory descriptor  *  @param pflag   protection flags  *  *  @return vaddr  the virtual address mapped for the shared memory  */
end_comment

begin_function
name|void
modifier|*
name|cvmx_shmem_map
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|pflag
parameter_list|)
block|{
name|void
modifier|*
name|vaddr
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
name|vaddr
operator|=
name|__cvmx_shmem_map_linux
argument_list|(
name|dscptr
argument_list|,
name|pflag
argument_list|)
expr_stmt|;
else|#
directive|else
name|vaddr
operator|=
name|__cvmx_shmem_map_standalone
argument_list|(
name|dscptr
argument_list|,
name|pflag
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|vaddr
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  *  *  For Linux user application only  *  *  ummap the shared memory  *  *  @param dscptr  shared memory descriptor  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_shmem_unmap_linux
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|)
block|{
if|if
condition|(
name|__cvmx_shmem_devmemfd
operator|&&
name|dscptr
condition|)
name|munmap
argument_list|(
name|dscptr
operator|->
name|vaddr
argument_list|,
name|dscptr
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  *  *  For stand along SE application only.  *  *  ummap the shared memory  *  *  @param dscptr  shared memory descriptor  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifndef

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_shmem_unmap_standalone
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|)
block|{
name|int
name|index
decl_stmt|;
name|index
operator|=
name|cvmx_tlb_lookup
argument_list|(
name|CAST64
argument_list|(
name|dscptr
operator|->
name|vaddr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cmvx-shmem-dbg:"
literal|"shmem_unmap TLB %d \n"
argument_list|,
name|index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_tlb_free_runtime_entry
argument_list|(
name|index
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *  ummap the shared memory  *  *  @param dscptr  shared memory descriptor  *  */
end_comment

begin_function
name|void
name|cvmx_shmem_unmap
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
name|__cvmx_shmem_unmap_linux
argument_list|(
name|dscptr
argument_list|)
expr_stmt|;
else|#
directive|else
name|__cvmx_shmem_unmap_standalone
argument_list|(
name|dscptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  *  *  Common implementation of closing a descriptor.  *  *  @param dscptr  shared memory descriptor  *  @param remove  1:  remove the descriptor and named block if this  *                  this is the last user of the descriptor  *             0:  do not remove  *  @return  0:   Success  *          !0:   Failed  *  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_shmem_close_dscptr
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|dscptr
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dscptr
operator|->
name|use_count
operator|>
literal|0
condition|)
name|dscptr
operator|->
name|use_count
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|dscptr
operator|->
name|use_count
operator|==
literal|0
operator|)
operator|&&
name|remove
condition|)
block|{
comment|/* Free this descriptor */
name|__cvmx_shmem_smdr_free
argument_list|(
name|dscptr
argument_list|)
expr_stmt|;
comment|/* Free named block if this is the last user, and the block            is created by the application */
if|if
condition|(
name|dscptr
operator|->
name|is_named_block
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx-shmem-dbg: remove named block %s \n"
argument_list|,
name|dscptr
operator|->
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cvmx_bootmem_phy_named_block_free
argument_list|(
name|dscptr
operator|->
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|dscptr
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  *  *  For stand along SE application only.  *  *  close a descriptor.  *  *  @param dscptr  shared memory descriptor  *  @param remove  1:  remove the descriptor and named block if this  *                  this is the last user of the descriptor  *             0:  do not remove  *  @return  0:   Success  *          !0:   Failed  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifndef

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_shmem_close_standalone
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
return|return
name|__cvmx_shmem_close_dscptr
argument_list|(
name|dscptr
argument_list|,
name|remove
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  *  *  For Linux user application only.  *  *  close a descriptor.  *  *  @param dscptr  shared memory descriptor  *  @param remove  1:  remove the descriptor and named block if this  *                  this is the last user of the descriptor  *             0:  do not remove  *  @return  0:   Success  *          !0:   Failed  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
end_ifdef

begin_function
name|int
name|__cvmx_shmem_close_linux
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|__cvmx_shmem_close_dscptr
argument_list|(
name|dscptr
argument_list|,
name|remove
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|__cvmx_shmem_devmemfd
condition|)
block|{
name|close
argument_list|(
name|__cvmx_shmem_devmemfd
argument_list|)
expr_stmt|;
name|__cvmx_shmem_devmemfd
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *  *  close a descriptor.  *  *  @param dscptr  shared memory descriptor  *  @param remove  1:  remove the descriptor and named block if this  *                  this is the last user of the descriptor  *             0:  do not remove  *  @return  0:   Success  *          !0:   Failed  *  */
end_comment

begin_function
name|int
name|cvmx_shmem_close
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|int
name|remove
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_USER
name|ret
operator|=
name|__cvmx_shmem_close_linux
argument_list|(
name|dscptr
argument_list|,
name|remove
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|__cvmx_shmem_close_standalone
argument_list|(
name|dscptr
argument_list|,
name|remove
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|ret
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/**  * @INTERNAL  *  SMDR non-free descriptor dump functor. to be used for iterator.  *  * @param dscptr  descriptor passed in by the iterator  *  * @return NULL  always  */
end_comment

begin_function
specifier|static
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|__cvmx_shmem_smdr_display_dscptr
parameter_list|(
name|struct
name|cvmx_shmem_dscptr
modifier|*
name|dscptr
parameter_list|,
name|void
modifier|*
name|nouse
parameter_list|)
block|{
if|if
condition|(
operator|(
name|dscptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|dscptr
operator|->
name|owner
operator|!=
name|CVMX_SHMEM_OWNER_NONE
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"  %s: phy: %lx, size %d, alignment %lx, virt %p use_count %d\n"
argument_list|,
name|dscptr
operator|->
name|name
argument_list|,
name|dscptr
operator|->
name|paddr
argument_list|,
name|dscptr
operator|->
name|size
argument_list|,
name|dscptr
operator|->
name|alignment
argument_list|,
name|dscptr
operator|->
name|vaddr
argument_list|,
name|dscptr
operator|->
name|use_count
argument_list|)
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  *  SMDR descriptor show  *  *  list all non-free descriptors  */
end_comment

begin_function
name|void
name|cvmx_shmem_show
parameter_list|(
name|void
parameter_list|)
block|{
name|__CHECK_APP_SMDR
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"SMDR descriptor list: \n"
argument_list|)
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|__smdr_iterator
argument_list|(
name|__cvmx_shmem_smdr_display_dscptr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|__smdr
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

end_unit

