begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-led-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon led.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_LED_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_LED_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_BLINK
value|CVMX_LED_BLINK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_BLINK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_BLINK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A48ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_BLINK
value|(CVMX_ADD_IO_SEG(0x0001180000001A48ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_CLK_PHASE
value|CVMX_LED_CLK_PHASE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_CLK_PHASE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_CLK_PHASE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A08ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_CLK_PHASE
value|(CVMX_ADD_IO_SEG(0x0001180000001A08ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_CYLON
value|CVMX_LED_CYLON_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_CYLON_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_CYLON not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001AF8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_CYLON
value|(CVMX_ADD_IO_SEG(0x0001180000001AF8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_DBG
value|CVMX_LED_DBG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_DBG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_DBG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A18ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_DBG
value|(CVMX_ADD_IO_SEG(0x0001180000001A18ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_EN
value|CVMX_LED_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A00ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_EN
value|(CVMX_ADD_IO_SEG(0x0001180000001A00ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_POLARITY
value|CVMX_LED_POLARITY_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_POLARITY_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_POLARITY not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A50ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_POLARITY
value|(CVMX_ADD_IO_SEG(0x0001180000001A50ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_PRT
value|CVMX_LED_PRT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_PRT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_PRT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A10ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_PRT
value|(CVMX_ADD_IO_SEG(0x0001180000001A10ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_LED_PRT_FMT
value|CVMX_LED_PRT_FMT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_PRT_FMT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_PRT_FMT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A30ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_PRT_FMT
value|(CVMX_ADD_IO_SEG(0x0001180000001A30ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_PRT_STATUSX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_PRT_STATUSX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A80ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_PRT_STATUSX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001A80ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_UDD_CNTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_UDD_CNTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A20ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_UDD_CNTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001A20ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_UDD_DATX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_UDD_DATX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001A38ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_UDD_DATX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001A38ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_UDD_DAT_CLRX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_UDD_DAT_CLRX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001AC8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_UDD_DAT_CLRX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001AC8ull) + ((offset)& 1) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_LED_UDD_DAT_SETX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_LED_UDD_DAT_SETX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001AC0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_LED_UDD_DAT_SETX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001AC0ull) + ((offset)& 1) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_led_blink  *  * LED_BLINK = LED Blink Rate (in led_clks)  *  */
end_comment

begin_union
union|union
name|cvmx_led_blink
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_blink_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rate
range|:
literal|8
decl_stmt|;
comment|/**< LED Blink rate in led_latch clks                                                          RATE must be> 0 */
else|#
directive|else
name|uint64_t
name|rate
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_blink_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_blink_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_blink_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_blink_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_blink_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_blink_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_blink
name|cvmx_led_blink_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_clk_phase  *  * LED_CLK_PHASE = LED Clock Phase (in 64 eclks)  *  *  * Notes:  * Example:  * Given a 2ns eclk, an LED_CLK_PHASE[PHASE] = 1, indicates that each  * led_clk phase is 64 eclks, or 128ns.  The led_clk period is 2*phase,  * or 256ns which is 3.9MHz.  The default value of 4, yields an led_clk  * period of 64*4*2ns*2 = 1024ns or ~1MHz (977KHz).  */
end_comment

begin_union
union|union
name|cvmx_led_clk_phase
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_clk_phase_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|phase
range|:
literal|7
decl_stmt|;
comment|/**< Number of 64 eclks in order to create the led_clk */
else|#
directive|else
name|uint64_t
name|phase
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_clk_phase_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_clk_phase_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_clk_phase_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_clk_phase_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_clk_phase_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_clk_phase_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_clk_phase
name|cvmx_led_clk_phase_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_cylon  *  * LED_CYLON = LED CYLON Effect (should remain undocumented)  *  */
end_comment

begin_union
union|union
name|cvmx_led_cylon
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_cylon_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|rate
range|:
literal|16
decl_stmt|;
comment|/**< LED Cylon Effect when RATE!=0                                                          Changes at RATE*LATCH period */
else|#
directive|else
name|uint64_t
name|rate
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_cylon_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_cylon_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_cylon_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_cylon_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_cylon_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_cylon_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_cylon
name|cvmx_led_cylon_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_dbg  *  * LED_DBG = LED Debug Port information  *  */
end_comment

begin_union
union|union
name|cvmx_led_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_dbg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|dbg_en
range|:
literal|1
decl_stmt|;
comment|/**< Add Debug Port Data to the LED shift chain                                                          Debug Data is shifted out LSB to MSB */
else|#
directive|else
name|uint64_t
name|dbg_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_dbg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_dbg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_dbg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_dbg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_dbg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_dbg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_dbg
name|cvmx_led_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_en  *  * LED_EN = LED Interface Enable  *  *  * Notes:  * The LED interface is comprised of a shift chain with a parallel latch.  LED  * data is shifted out on each fallingg edge of led_clk and then captured by  * led_lat.  *  * The LED shift chain is comprised of the following...  *  *      32  - UDD header  *      6x8 - per port status  *      17  - debug port  *      32  - UDD trailer  *  * for a total of 129 bits.  *  * UDD header is programmable from 0-32 bits (LED_UDD_CNT0) and will shift out  * LSB to MSB (LED_UDD_DAT0[0], LED_UDD_DAT0[1],  * ... LED_UDD_DAT0[LED_UDD_CNT0].  *  * The per port status is also variable.  Systems can control which ports send  * data (LED_PRT) as well as the status content (LED_PRT_FMT and  * LED_PRT_STATUS*).  When multiple ports are enabled, they come out in lowest  * port to highest port (prt0, prt1, ...).  *  * The debug port data can also be added to the LED chain (LED_DBG).  When  * enabled, the debug data shifts out LSB to MSB.  *  * The UDD trailer data is identical to the header data, but uses LED_UDD_CNT1  * and LED_UDD_DAT1.  */
end_comment

begin_union
union|union
name|cvmx_led_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Enable the LED interface shift-chain */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_en_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_en_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_en
name|cvmx_led_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_polarity  *  * LED_POLARITY = LED Polarity  *  */
end_comment

begin_union
union|union
name|cvmx_led_polarity
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_polarity_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|polarity
range|:
literal|1
decl_stmt|;
comment|/**< LED active polarity                                                          0 = active HIGH LED                                                          1 = active LOW LED (invert led_dat) */
else|#
directive|else
name|uint64_t
name|polarity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_polarity_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_polarity_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_polarity_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_polarity_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_polarity_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_polarity_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_polarity
name|cvmx_led_polarity_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_prt  *  * LED_PRT = LED Port status information  *  *  * Notes:  * Note:  * the PRT vector enables information of the 8 RGMII ports connected to  * Octane.  It does not reflect the actual programmed PHY addresses.  */
end_comment

begin_union
union|union
name|cvmx_led_prt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_prt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|prt_en
range|:
literal|8
decl_stmt|;
comment|/**< Which ports are enabled to display status                                                          PRT_EN<3:0> coresponds to RGMII ports 3-0 on int0                                                          PRT_EN<7:4> coresponds to RGMII ports 7-4 on int1                                                          Only applies when interface is in RGMII mode                                                          The status format is defined by LED_PRT_FMT */
else|#
directive|else
name|uint64_t
name|prt_en
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_prt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_prt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_prt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_prt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_prt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_prt_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_prt
name|cvmx_led_prt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_prt_fmt  *  * LED_PRT_FMT = LED Port Status Infomation Format  *  *  * Notes:  * TX: RGMII TX block is sending packet data or extends on the port  * RX: RGMII RX block has received non-idle cycle  *  * For short transfers, LEDs will remain on for at least one blink cycle  */
end_comment

begin_union
union|union
name|cvmx_led_prt_fmt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_prt_fmt_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|format
range|:
literal|4
decl_stmt|;
comment|/**< Port Status Information for each enabled port in                                                          LED_PRT.  The formats are below                                                          0x0: [ LED_PRT_STATUS[0]            ]                                                          0x1: [ LED_PRT_STATUS[1:0]          ]                                                          0x2: [ LED_PRT_STATUS[3:0]          ]                                                          0x3: [ LED_PRT_STATUS[5:0]          ]                                                          0x4: [ (RX|TX), LED_PRT_STATUS[0]   ]                                                          0x5: [ (RX|TX), LED_PRT_STATUS[1:0] ]                                                          0x6: [ (RX|TX), LED_PRT_STATUS[3:0] ]                                                          0x8: [ Tx, Rx, LED_PRT_STATUS[0]    ]                                                          0x9: [ Tx, Rx, LED_PRT_STATUS[1:0]  ]                                                          0xa: [ Tx, Rx, LED_PRT_STATUS[3:0]  ] */
else|#
directive|else
name|uint64_t
name|format
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_prt_fmt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_prt_fmt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_prt_fmt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_prt_fmt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_prt_fmt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_prt_fmt_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_prt_fmt
name|cvmx_led_prt_fmt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_prt_status#  *  * LED_PRT_STATUS = LED Port Status information  *  */
end_comment

begin_union
union|union
name|cvmx_led_prt_statusx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_prt_statusx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|status
range|:
literal|6
decl_stmt|;
comment|/**< Bits that software can set to be added to the                                                          LED shift chain - depending on LED_PRT_FMT                                                          LED_PRT_STATUS(3..0) corespond to RGMII ports 3-0                                                           on interface0                                                          LED_PRT_STATUS(7..4) corespond to RGMII ports 7-4                                                           on interface1                                                          Only applies when interface is in RGMII mode */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_prt_statusx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_prt_statusx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_prt_statusx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_prt_statusx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_prt_statusx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_prt_statusx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_prt_statusx
name|cvmx_led_prt_statusx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_udd_cnt#  *  * LED_UDD_CNT = LED UDD Counts  *  */
end_comment

begin_union
union|union
name|cvmx_led_udd_cntx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_udd_cntx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|6
decl_stmt|;
comment|/**< Number of bits of user-defined data to include in                                                          the LED shift chain.  Legal values: 0-32. */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_udd_cntx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_udd_cntx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_udd_cntx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_udd_cntx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_udd_cntx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_udd_cntx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_udd_cntx
name|cvmx_led_udd_cntx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_udd_dat#  *  * LED_UDD_DAT = User defined data (header or trailer)  *  *  * Notes:  * Bits come out LSB to MSB on the shift chain.  If LED_UDD_CNT is set to 4  * then the bits comes out LED_UDD_DAT[0], LED_UDD_DAT[1], LED_UDD_DAT[2],  * LED_UDD_DAT[3].  */
end_comment

begin_union
union|union
name|cvmx_led_udd_datx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_udd_datx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|32
decl_stmt|;
comment|/**< Header or trailer UDD data to be displayed on                                                          the LED shift chain.  Number of bits to include                                                          is controled by LED_UDD_CNT */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_udd_datx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_udd_datx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_udd_datx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_udd_datx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_udd_datx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_udd_datx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_udd_datx
name|cvmx_led_udd_datx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_udd_dat_clr#  *  * LED_UDD_DAT_CLR = User defined data (header or trailer)  *  */
end_comment

begin_union
union|union
name|cvmx_led_udd_dat_clrx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_udd_dat_clrx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|32
decl_stmt|;
comment|/**< Bitwise clear for the Header or trailer UDD data to                                                          be displayed on the LED shift chain. */
else|#
directive|else
name|uint64_t
name|clr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_udd_dat_clrx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_clrx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_clrx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_clrx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_clrx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_clrx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_udd_dat_clrx
name|cvmx_led_udd_dat_clrx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_led_udd_dat_set#  *  * LED_UDD_DAT_SET = User defined data (header or trailer)  *  */
end_comment

begin_union
union|union
name|cvmx_led_udd_dat_setx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_led_udd_dat_setx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|set
range|:
literal|32
decl_stmt|;
comment|/**< Bitwise set for the Header or trailer UDD data to                                                          be displayed on the LED shift chain. */
else|#
directive|else
name|uint64_t
name|set
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_led_udd_dat_setx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_setx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_setx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_setx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_setx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_led_udd_dat_setx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_led_udd_dat_setx
name|cvmx_led_udd_dat_setx_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

