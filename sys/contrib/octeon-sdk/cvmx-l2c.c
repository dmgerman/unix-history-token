begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Implementation of the Level 2 Cache (L2C) control,  * measurement, and debugging facilities.  *  *<hr>$Revision: 41586 $<hr>  *  */
end_comment

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-l2c.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/* This spinlock is used internally to ensure that only one core is performing ** certain L2 operations at a time. ** ** NOTE: This only protects calls from within a single application - if multiple applications ** or operating systems are running, then it is up to the user program to coordinate between them. */
end_comment

begin_decl_stmt
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_l2c_spinlock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|l2_size_half
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|val
init|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FUS3
argument_list|)
decl_stmt|;
return|return
operator|!
operator|!
operator|(
name|val
operator|&
operator|(
literal|1ull
operator|<<
literal|34
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_core_way_partition
parameter_list|(
name|uint32_t
name|core
parameter_list|)
block|{
name|uint32_t
name|field
decl_stmt|;
comment|/* Validate the core number */
if|if
condition|(
name|core
operator|>=
name|cvmx_octeon_num_cores
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Use the lower two bits of the coreNumber to determine the bit offset      * of the UMSK[] field in the L2C_SPAR register.      */
name|field
operator|=
operator|(
name|core
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
comment|/* Return the UMSK[] field from the appropriate L2C_SPAR register based      * on the coreNumber.      */
switch|switch
condition|(
name|core
operator|&
literal|0xC
condition|)
block|{
case|case
literal|0x0
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
case|case
literal|0x4
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
case|case
literal|0x8
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
case|case
literal|0xC
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_core_way_partition
parameter_list|(
name|uint32_t
name|core
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|field
decl_stmt|;
name|uint32_t
name|valid_mask
decl_stmt|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
comment|/* A UMSK setting which blocks all L2C Ways is an error. */
if|if
condition|(
name|mask
operator|==
name|valid_mask
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Validate the core number */
if|if
condition|(
name|core
operator|>=
name|cvmx_octeon_num_cores
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check to make sure current mask& new mask don't block all ways */
if|if
condition|(
operator|(
operator|(
name|mask
operator||
name|cvmx_l2c_get_core_way_partition
argument_list|(
name|core
argument_list|)
operator|)
operator|&
name|valid_mask
operator|)
operator|==
name|valid_mask
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Use the lower two bits of core to determine the bit offset of the      * UMSK[] field in the L2C_SPAR register.      */
name|field
operator|=
operator|(
name|core
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
comment|/* Assign the new mask setting to the UMSK[] field in the appropriate      * L2C_SPAR register based on the core_num.      *      */
switch|switch
condition|(
name|core
operator|&
literal|0xC
condition|)
block|{
case|case
literal|0x0
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xC
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_hw_way_partition
parameter_list|(
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|valid_mask
decl_stmt|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
comment|/* A UMSK setting which blocks all L2C Ways is an error. */
if|if
condition|(
name|mask
operator|==
name|valid_mask
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Check to make sure current mask& new mask don't block all ways */
if|if
condition|(
operator|(
operator|(
name|mask
operator||
name|cvmx_l2c_get_hw_way_partition
argument_list|()
operator|)
operator|&
name|valid_mask
operator|)
operator|==
name|valid_mask
condition|)
return|return
operator|-
literal|1
return|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|)
operator|&
operator|~
literal|0xFF
operator|)
operator||
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_hw_way_partition
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|)
operator|&
operator|(
literal|0xFF
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_l2c_config_perf
parameter_list|(
name|uint32_t
name|counter
parameter_list|,
name|cvmx_l2c_event_t
name|event
parameter_list|,
name|uint32_t
name|clear_on_read
parameter_list|)
block|{
name|cvmx_l2c_pfctl_t
name|pfctl
decl_stmt|;
name|pfctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFCTL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt0sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt0ena
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
name|pfctl
operator|.
name|s
operator|.
name|cnt0rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt1sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt1ena
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
name|pfctl
operator|.
name|s
operator|.
name|cnt1rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt2sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt2ena
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
name|pfctl
operator|.
name|s
operator|.
name|cnt2rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
name|pfctl
operator|.
name|s
operator|.
name|cnt3sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt3ena
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cvmx_octeon_is_pass1
argument_list|()
condition|)
name|pfctl
operator|.
name|s
operator|.
name|cnt3rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_PFCTL
argument_list|,
name|pfctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_l2c_read_perf
parameter_list|(
name|uint32_t
name|counter
parameter_list|)
block|{
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC0
argument_list|)
operator|)
return|;
case|case
literal|1
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC1
argument_list|)
operator|)
return|;
case|case
literal|2
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC2
argument_list|)
operator|)
return|;
case|case
literal|3
case|:
default|default:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC3
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Helper function use to fault in cache lines for L2 cache locking  *  * @param addr   Address of base of memory region to read into L2 cache  * @param len    Length (in bytes) of region to fault in  */
end_comment

begin_function
specifier|static
name|void
name|fault_in
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|volatile
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|volatile
name|char
name|dummy
decl_stmt|;
comment|/* Adjust addr and length so we get all cache lines even for     ** small ranges spanning two cache lines */
name|len
operator|+=
name|addr
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|addr
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|CVMX_DCACHE_INVALIDATE
expr_stmt|;
comment|/* Invalidate L1 cache to make sure all loads result in data being in L2 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|dummy
operator|+=
operator|*
name|ptr
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|ptr
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_lock_line
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|cvmx_l2c_dbg_t
name|l2cdbg
decl_stmt|;
name|cvmx_l2c_lckbase_t
name|lckbase
decl_stmt|;
name|cvmx_l2c_lckoff_t
name|lckoff
decl_stmt|;
name|cvmx_l2t_err_t
name|l2t_err
decl_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|lckbase
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|lckoff
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
comment|/* Clear l2t error bits if set */
name|l2t_err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|l2t_err
operator|.
name|s
operator|.
name|lckerr
operator|=
literal|1
expr_stmt|;
name|l2t_err
operator|.
name|s
operator|.
name|lckerr2
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|l2t_err
operator|.
name|u64
argument_list|)
expr_stmt|;
name|addr
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
comment|/* Set this core as debug core */
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|lckoff
operator|.
name|s
operator|.
name|lck_offset
operator|=
literal|0
expr_stmt|;
comment|/* Only lock 1 line at a time */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKOFF
argument_list|,
name|lckoff
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKOFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|cvmx_l2c_cfg_t
call|)
argument_list|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
argument_list|)
operator|)
operator|.
name|s
operator|.
name|idxalias
condition|)
block|{
name|int
name|alias_shift
init|=
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|+
literal|2
operator|*
name|CVMX_L2_SET_BITS
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|addr_tmp
init|=
name|addr
operator|^
operator|(
name|addr
operator|&
operator|(
operator|(
literal|1
operator|<<
name|alias_shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
name|CVMX_L2_SET_BITS
decl_stmt|;
name|lckbase
operator|.
name|s
operator|.
name|lck_base
operator|=
name|addr_tmp
operator|>>
literal|7
expr_stmt|;
block|}
else|else
block|{
name|lckbase
operator|.
name|s
operator|.
name|lck_base
operator|=
name|addr
operator|>>
literal|7
expr_stmt|;
block|}
name|lckbase
operator|.
name|s
operator|.
name|lck_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|,
name|lckbase
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|)
expr_stmt|;
comment|// Make sure it gets there
name|fault_in
argument_list|(
name|addr
argument_list|,
name|CVMX_CACHE_LINE_SIZE
argument_list|)
expr_stmt|;
name|lckbase
operator|.
name|s
operator|.
name|lck_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|,
name|lckbase
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|)
expr_stmt|;
comment|// Make sure it gets there
comment|/* Stop being debug core */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|l2t_err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2t_err
operator|.
name|s
operator|.
name|lckerr
operator|||
name|l2t_err
operator|.
name|s
operator|.
name|lckerr2
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* We were unable to lock the line */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_lock_mem_region
parameter_list|(
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Round start/end to cache line boundaries */
name|len
operator|+=
name|start
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|start
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|CVMX_CACHE_LINE_MASK
operator|)
operator|&
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|retval
operator|+=
name|cvmx_l2c_lock_line
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_l2c_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|assoc
decl_stmt|,
name|set
decl_stmt|;
name|uint64_t
name|n_assoc
decl_stmt|,
name|n_set
decl_stmt|;
name|cvmx_l2c_dbg_t
name|l2cdbg
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|finv
operator|=
literal|1
expr_stmt|;
name|n_set
operator|=
name|CVMX_L2_SETS
expr_stmt|;
name|n_assoc
operator|=
name|l2_size_half
argument_list|()
condition|?
operator|(
name|CVMX_L2_ASSOC
operator|/
literal|2
operator|)
else|:
name|CVMX_L2_ASSOC
expr_stmt|;
for|for
control|(
name|set
operator|=
literal|0
init|;
name|set
operator|<
name|n_set
condition|;
name|set
operator|++
control|)
block|{
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|n_assoc
condition|;
name|assoc
operator|++
control|)
block|{
name|l2cdbg
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
comment|/* Enter debug mode, and make sure all other writes complete before we             ** enter debug mode */
name|CVMX_SYNCW
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|CVMX_PREPARE_FOR_STORE
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|set
operator|*
name|CVMX_CACHE_LINE_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
comment|/* Push STF out to L2 */
comment|/* Exit debug mode */
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_unlock_line
parameter_list|(
name|uint64_t
name|address
parameter_list|)
block|{
name|int
name|assoc
decl_stmt|;
name|cvmx_l2c_tag_t
name|tag
decl_stmt|;
name|cvmx_l2c_dbg_t
name|l2cdbg
decl_stmt|;
name|uint32_t
name|tag_addr
decl_stmt|;
name|uint32_t
name|index
init|=
name|cvmx_l2c_address_to_index
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
comment|/* Compute portion of address that is stored in tag */
name|tag_addr
operator|=
operator|(
operator|(
name|address
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|CVMX_L2_ASSOC
condition|;
name|assoc
operator|++
control|)
block|{
name|tag
operator|=
name|cvmx_get_l2c_tag
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|s
operator|.
name|V
operator|&&
operator|(
name|tag
operator|.
name|s
operator|.
name|addr
operator|==
name|tag_addr
operator|)
condition|)
block|{
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|finv
operator|=
literal|1
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Enter debug mode */
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|CVMX_PREPARE_FOR_STORE
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* Exit debug mode */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
return|return
name|tag
operator|.
name|s
operator|.
name|L
return|;
block|}
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_unlock_mem_region
parameter_list|(
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|int
name|num_unlocked
init|=
literal|0
decl_stmt|;
comment|/* Round start/end to cache line boundaries */
name|len
operator|+=
name|start
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|start
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|CVMX_CACHE_LINE_MASK
operator|)
operator|&
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|num_unlocked
operator|+=
name|cvmx_l2c_unlock_line
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
return|return
name|num_unlocked
return|;
block|}
end_function

begin_comment
comment|/* Internal l2c tag types.  These are converted to a generic structure ** that can be used on all chips */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
struct|struct
name|cvmx_l2c_tag_cn50xx
block|{
name|uint64_t
name|reserved
range|:
literal|40
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|20
decl_stmt|;
comment|// Phys mem addr (33..14)
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn30xx
block|{
name|uint64_t
name|reserved
range|:
literal|41
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|19
decl_stmt|;
comment|// Phys mem addr (33..15)
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn31xx
block|{
name|uint64_t
name|reserved
range|:
literal|42
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|18
decl_stmt|;
comment|// Phys mem addr (33..16)
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn38xx
block|{
name|uint64_t
name|reserved
range|:
literal|43
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|17
decl_stmt|;
comment|// Phys mem addr (33..17)
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn58xx
block|{
name|uint64_t
name|reserved
range|:
literal|44
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|16
decl_stmt|;
comment|// Phys mem addr (33..18)
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_l2c_tag_cn58xx
name|cn56xx
decl_stmt|;
comment|/* 2048 sets */
name|struct
name|cvmx_l2c_tag_cn31xx
name|cn52xx
decl_stmt|;
comment|/* 512 sets */
endif|#
directive|endif
block|}
name|__cvmx_l2c_tag_t
typedef|;
end_typedef

begin_comment
comment|/**  * @INTERNAL  * Function to read a L2C tag.  This code make the current core  * the 'debug core' for the L2.  This code must only be executed by  * 1 core at a time.  *  * @param assoc  Association (way) of the tag to dump  * @param index  Index of the cacheline  *  * @return The Octeon model specific tag structure.  This is translated by a wrapper  *         function to a generic form that is easier for applications to use.  */
end_comment

begin_function
specifier|static
name|__cvmx_l2c_tag_t
name|__read_l2_tag
parameter_list|(
name|uint64_t
name|assoc
parameter_list|,
name|uint64_t
name|index
parameter_list|)
block|{
name|uint64_t
name|debug_tag_addr
init|=
operator|(
operator|(
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator||
operator|(
name|index
operator|<<
literal|7
operator|)
operator|)
operator|+
literal|96
operator|)
decl_stmt|;
name|uint64_t
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|__cvmx_l2c_tag_t
name|tag_val
decl_stmt|;
name|uint64_t
name|dbg_addr
init|=
name|CVMX_L2C_DBG
decl_stmt|;
name|uint32_t
name|flags
decl_stmt|;
name|cvmx_l2c_dbg_t
name|debug_val
decl_stmt|;
name|debug_val
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* For low core count parts, the core number is always small enough     ** to stay in the correct field and not set any reserved bits */
name|debug_val
operator|.
name|s
operator|.
name|ppnum
operator|=
name|core
expr_stmt|;
name|debug_val
operator|.
name|s
operator|.
name|l2t
operator|=
literal|1
expr_stmt|;
name|debug_val
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* Make sure core is quiet (no prefetches, etc.) before entering debug mode */
name|CVMX_DCACHE_INVALIDATE
expr_stmt|;
comment|/* Flush L1 to make sure debug load misses L1 */
name|flags
operator|=
name|cvmx_interrupt_disable_save
argument_list|()
expr_stmt|;
comment|/* The following must be done in assembly as when in debug mode all data loads from     ** L2 return special debug data, not normal memory contents.  Also, interrupts must be disabled,     ** since if an interrupt occurs while in debug mode the ISR will get debug data from all its memory     ** reads instead of the contents of memory */
asm|asm
specifier|volatile
asm|(     "        .set push              \n"     "        .set mips64              \n"     "        .set noreorder           \n"     "        sd    %[dbg_val], 0(%[dbg_addr])  \n"
comment|/* Enter debug mode, wait for store */
asm|"        ld    $0, 0(%[dbg_addr]) \n"     "        ld    %[tag_val], 0(%[tag_addr]) \n"
comment|/* Read L2C tag data */
asm|"        sd    $0, 0(%[dbg_addr])  \n"
comment|/* Exit debug mode, wait for store */
asm|"        ld    $0, 0(%[dbg_addr]) \n"     "        cache 9, 0($0) \n"
comment|/* Invalidate dcache to discard debug data */
asm|"        .set pop             \n"     :[tag_val] "=r" (tag_val):  [dbg_addr] "r" (dbg_addr), [dbg_val] "r" (debug_val), [tag_addr] "r" (debug_tag_addr) : "memory");
name|cvmx_interrupt_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag_val
operator|)
return|;
block|}
end_function

begin_function
name|cvmx_l2c_tag_t
name|cvmx_l2c_get_tag
parameter_list|(
name|uint32_t
name|association
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|__cvmx_l2c_tag_t
name|tmp_tag
decl_stmt|;
name|cvmx_l2c_tag_t
name|tag
decl_stmt|;
name|tag
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|association
operator|>=
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_get_l2c_tag association out of range\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|index
operator|>=
name|cvmx_l2c_get_num_sets
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_get_l2c_tag index out of range (arg: %d, max: %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|index
argument_list|,
name|cvmx_l2c_get_num_sets
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
comment|/* __read_l2_tag is intended for internal use only */
name|tmp_tag
operator|=
name|__read_l2_tag
argument_list|(
name|association
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Convert all tag structure types to generic version, as it can represent all models */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|addr
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
return|return
name|tag
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|uint32_t
name|cvmx_l2c_address_to_index
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|addr
operator|>>
name|CVMX_L2C_IDX_ADDR_SHIFT
decl_stmt|;
name|cvmx_l2c_cfg_t
name|l2c_cfg
decl_stmt|;
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_cfg
operator|.
name|s
operator|.
name|idxalias
condition|)
block|{
name|idx
operator|^=
operator|(
operator|(
name|addr
operator|&
name|CVMX_L2C_ALIAS_MASK
operator|)
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
expr_stmt|;
block|}
name|idx
operator|&=
name|CVMX_L2C_IDX_MASK
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_cache_size_bytes
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cvmx_l2c_get_num_sets
argument_list|()
operator|*
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|*
name|CVMX_CACHE_LINE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return log base 2 of the number of sets in the L2 cache  * @return  */
end_comment

begin_function
name|int
name|cvmx_l2c_get_set_bits
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|l2_set_bits
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|11
expr_stmt|;
comment|/* 2048 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|10
expr_stmt|;
comment|/* 1024 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|9
expr_stmt|;
comment|/* 512 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|8
expr_stmt|;
comment|/* 256 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|7
expr_stmt|;
comment|/* 128 sets */
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|l2_set_bits
operator|=
literal|11
expr_stmt|;
comment|/* 2048 sets */
block|}
return|return
operator|(
name|l2_set_bits
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of sets in the L2 Cache */
end_comment

begin_function
name|int
name|cvmx_l2c_get_num_sets
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|<<
name|cvmx_l2c_get_set_bits
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of associations in the L2 Cache */
end_comment

begin_function
name|int
name|cvmx_l2c_get_num_assoc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|l2_assoc
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|l2_assoc
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Check to see if part of the cache is disabled */
if|if
condition|(
name|cvmx_fuse_read
argument_list|(
literal|265
argument_list|)
condition|)
name|l2_assoc
operator|=
name|l2_assoc
operator|>>
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|cvmx_fuse_read
argument_list|(
literal|264
argument_list|)
condition|)
name|l2_assoc
operator|=
name|l2_assoc
operator|>>
literal|1
expr_stmt|;
return|return
operator|(
name|l2_assoc
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * Flush a line from the L2 cache  * This should only be called from one core at a time, as this routine  * sets the core to the 'debug' core in order to flush the line.  *  * @param assoc  Association (or way) to flush  * @param index  Index to flush  */
end_comment

begin_function
name|void
name|cvmx_l2c_flush_line
parameter_list|(
name|uint32_t
name|assoc
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|cvmx_l2c_dbg_t
name|l2cdbg
decl_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|finv
operator|=
literal|1
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
comment|/* Enter debug mode, and make sure all other writes complete before we     ** enter debug mode */
asm|asm
specifier|volatile
asm|("sync \n"::: "memory");
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|CVMX_PREPARE_FOR_STORE
argument_list|(
operator|(
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
operator|+
operator|(
name|index
operator|)
operator|*
literal|128
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Exit debug mode */
asm|asm
specifier|volatile
asm|("sync \n"::: "memory");
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

