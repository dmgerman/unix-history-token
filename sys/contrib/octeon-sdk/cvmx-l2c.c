begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Implementation of the Level 2 Cache (L2C) control,  * measurement, and debugging facilities.  *  *<hr>$Revision: 52004 $<hr>  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-l2c.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-spinlock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-l2c.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/* This spinlock is used internally to ensure that only one core is performing ** certain L2 operations at a time. ** ** NOTE: This only protects calls from within a single application - if multiple applications ** or operating systems are running, then it is up to the user program to coordinate between them. */
end_comment

begin_decl_stmt
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_l2c_spinlock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_l2c_vrt_spinlock
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|cvmx_l2c_get_core_way_partition
parameter_list|(
name|uint32_t
name|core
parameter_list|)
block|{
name|uint32_t
name|field
decl_stmt|;
comment|/* Validate the core number */
if|if
condition|(
name|core
operator|>=
name|cvmx_octeon_num_cores
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_WPAR_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
return|;
comment|/* Use the lower two bits of the coreNumber to determine the bit offset      * of the UMSK[] field in the L2C_SPAR register.      */
name|field
operator|=
operator|(
name|core
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
comment|/* Return the UMSK[] field from the appropriate L2C_SPAR register based      * on the coreNumber.      */
switch|switch
condition|(
name|core
operator|&
literal|0xC
condition|)
block|{
case|case
literal|0x0
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
case|case
literal|0x4
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
case|case
literal|0x8
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
case|case
literal|0xC
case|:
return|return
operator|(
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_core_way_partition
parameter_list|(
name|uint32_t
name|core
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|field
decl_stmt|;
name|uint32_t
name|valid_mask
decl_stmt|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
comment|/* A UMSK setting which blocks all L2C Ways is an error on some chips */
if|if
condition|(
name|mask
operator|==
name|valid_mask
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Validate the core number */
if|if
condition|(
name|core
operator|>=
name|cvmx_octeon_num_cores
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_WPAR_PPX
argument_list|(
name|core
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Use the lower two bits of core to determine the bit offset of the      * UMSK[] field in the L2C_SPAR register.      */
name|field
operator|=
operator|(
name|core
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
comment|/* Assign the new mask setting to the UMSK[] field in the appropriate      * L2C_SPAR register based on the core_num.      *      */
switch|switch
condition|(
name|core
operator|&
literal|0xC
condition|)
block|{
case|case
literal|0x0
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xC
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_hw_way_partition
parameter_list|(
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|valid_mask
decl_stmt|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
comment|/* A UMSK setting which blocks all L2C Ways is an error on some chips */
if|if
condition|(
name|mask
operator|==
name|valid_mask
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_WPAR_IOBX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|)
operator|&
operator|~
literal|0xFF
operator|)
operator||
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_hw_way_partition
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_WPAR_IOBX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
return|;
else|else
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|)
operator|&
operator|(
literal|0xFF
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_l2c_config_perf
parameter_list|(
name|uint32_t
name|counter
parameter_list|,
name|cvmx_l2c_event_t
name|event
parameter_list|,
name|uint32_t
name|clear_on_read
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_pfctl_t
name|pfctl
decl_stmt|;
name|pfctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFCTL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt0sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt0ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt0rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt1sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt1ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt1rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt2sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt2ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt2rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
name|pfctl
operator|.
name|s
operator|.
name|cnt3sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt3ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt3rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_PFCTL
argument_list|,
name|pfctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_l2c_tadx_prf_t
name|l2c_tadx_prf
decl_stmt|;
name|int
name|tad
decl_stmt|;
name|cvmx_warn
argument_list|(
literal|"L2C performance counter events are different for this chip, mapping 'event' to cvmx_l2c_tad_event_t\n"
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|clear_on_read
argument_list|,
literal|"L2C counters don't support clear on read for this chip\n"
argument_list|)
expr_stmt|;
name|l2c_tadx_prf
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PRF
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt0sel
operator|=
name|event
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt1sel
operator|=
name|event
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt2sel
operator|=
name|event
expr_stmt|;
break|break;
default|default:
case|case
literal|3
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt3sel
operator|=
name|event
expr_stmt|;
break|break;
block|}
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_TADX_PRF
argument_list|(
name|tad
argument_list|)
argument_list|,
name|l2c_tadx_prf
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|cvmx_l2c_read_perf
parameter_list|(
name|uint32_t
name|counter
parameter_list|)
block|{
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC0
argument_list|)
operator|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC0
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
case|case
literal|1
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC1
argument_list|)
operator|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC1
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
case|case
literal|2
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC2
argument_list|)
operator|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC2
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
case|case
literal|3
case|:
default|default:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC3
argument_list|)
operator|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC3
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Helper function use to fault in cache lines for L2 cache locking  *  * @param addr   Address of base of memory region to read into L2 cache  * @param len    Length (in bytes) of region to fault in  */
end_comment

begin_function
specifier|static
name|void
name|fault_in
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|volatile
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|volatile
name|char
name|dummy
decl_stmt|;
comment|/* Adjust addr and length so we get all cache lines even for     ** small ranges spanning two cache lines */
name|len
operator|+=
name|addr
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|addr
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|CVMX_DCACHE_INVALIDATE
expr_stmt|;
comment|/* Invalidate L1 cache to make sure all loads result in data being in L2 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|dummy
operator|+=
operator|*
name|ptr
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|ptr
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_lock_line
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|int
name|shift
init|=
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
decl_stmt|;
name|uint64_t
name|assoc
init|=
name|cvmx_l2c_get_num_assoc
argument_list|()
decl_stmt|;
name|uint64_t
name|tag
init|=
name|addr
operator|>>
name|shift
decl_stmt|;
name|uint64_t
name|index
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|cvmx_l2c_address_to_index
argument_list|(
name|addr
argument_list|)
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
argument_list|)
decl_stmt|;
name|uint64_t
name|way
decl_stmt|;
name|cvmx_l2c_tadx_tag_t
name|l2c_tadx_tag
decl_stmt|;
name|CVMX_CACHE_LCKL2
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Make sure we were able to lock the line */
for|for
control|(
name|way
operator|=
literal|0
init|;
name|way
operator|<
name|assoc
condition|;
name|way
operator|++
control|)
block|{
name|CVMX_CACHE_LTGL2I
argument_list|(
name|index
operator||
operator|(
name|way
operator|<<
name|shift
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|// make sure CVMX_L2C_TADX_TAG is updated
name|l2c_tadx_tag
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_TAG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|valid
operator|&&
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|tag
operator|==
name|tag
condition|)
break|break;
block|}
comment|/* Check if a valid line is found */
if|if
condition|(
name|way
operator|>=
name|assoc
condition|)
block|{
comment|//cvmx_dprintf("ERROR: cvmx_l2c_lock_line: line not found for locking at 0x%llx address\n", (unsigned long long)addr);
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if lock bit is not set */
if|if
condition|(
operator|!
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|lock
condition|)
block|{
comment|//cvmx_dprintf("ERROR: cvmx_l2c_lock_line: Not able to lock at 0x%llx address\n", (unsigned long long)addr);
return|return
operator|-
literal|1
return|;
block|}
return|return
name|way
return|;
block|}
else|else
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|cvmx_l2c_dbg_t
name|l2cdbg
decl_stmt|;
name|cvmx_l2c_lckbase_t
name|lckbase
decl_stmt|;
name|cvmx_l2c_lckoff_t
name|lckoff
decl_stmt|;
name|cvmx_l2t_err_t
name|l2t_err
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|lckbase
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|lckoff
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Clear l2t error bits if set */
name|l2t_err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|l2t_err
operator|.
name|s
operator|.
name|lckerr
operator|=
literal|1
expr_stmt|;
name|l2t_err
operator|.
name|s
operator|.
name|lckerr2
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|l2t_err
operator|.
name|u64
argument_list|)
expr_stmt|;
name|addr
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
comment|/* Set this core as debug core */
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|lckoff
operator|.
name|s
operator|.
name|lck_offset
operator|=
literal|0
expr_stmt|;
comment|/* Only lock 1 line at a time */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKOFF
argument_list|,
name|lckoff
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKOFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
call|(
name|cvmx_l2c_cfg_t
call|)
argument_list|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
argument_list|)
operator|)
operator|.
name|s
operator|.
name|idxalias
condition|)
block|{
name|int
name|alias_shift
init|=
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|+
literal|2
operator|*
name|CVMX_L2_SET_BITS
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|addr_tmp
init|=
name|addr
operator|^
operator|(
name|addr
operator|&
operator|(
operator|(
literal|1
operator|<<
name|alias_shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
name|CVMX_L2_SET_BITS
decl_stmt|;
name|lckbase
operator|.
name|s
operator|.
name|lck_base
operator|=
name|addr_tmp
operator|>>
literal|7
expr_stmt|;
block|}
else|else
block|{
name|lckbase
operator|.
name|s
operator|.
name|lck_base
operator|=
name|addr
operator|>>
literal|7
expr_stmt|;
block|}
name|lckbase
operator|.
name|s
operator|.
name|lck_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|,
name|lckbase
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|)
expr_stmt|;
comment|// Make sure it gets there
name|fault_in
argument_list|(
name|addr
argument_list|,
name|CVMX_CACHE_LINE_SIZE
argument_list|)
expr_stmt|;
name|lckbase
operator|.
name|s
operator|.
name|lck_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|,
name|lckbase
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|)
expr_stmt|;
comment|// Make sure it gets there
comment|/* Stop being debug core */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|l2t_err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2t_err
operator|.
name|s
operator|.
name|lckerr
operator|||
name|l2t_err
operator|.
name|s
operator|.
name|lckerr2
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* We were unable to lock the line */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_lock_mem_region
parameter_list|(
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Round start/end to cache line boundaries */
name|len
operator|+=
name|start
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|start
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|CVMX_CACHE_LINE_MASK
operator|)
operator|&
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
name|retval
operator|+=
name|cvmx_l2c_lock_line
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_l2c_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|assoc
decl_stmt|,
name|set
decl_stmt|;
name|uint64_t
name|n_assoc
decl_stmt|,
name|n_set
decl_stmt|;
name|n_set
operator|=
name|cvmx_l2c_get_num_sets
argument_list|()
expr_stmt|;
name|n_assoc
operator|=
name|cvmx_l2c_get_num_assoc
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|uint64_t
name|address
decl_stmt|;
comment|/* These may look like constants, but they aren't... */
name|int
name|assoc_shift
init|=
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
decl_stmt|;
name|int
name|set_shift
init|=
name|CVMX_L2C_IDX_ADDR_SHIFT
decl_stmt|;
for|for
control|(
name|set
operator|=
literal|0
init|;
name|set
operator|<
name|n_set
condition|;
name|set
operator|++
control|)
block|{
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|n_assoc
condition|;
name|assoc
operator|++
control|)
block|{
name|address
operator|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|assoc
operator|<<
name|assoc_shift
operator|)
operator||
operator|(
name|set
operator|<<
name|set_shift
operator|)
argument_list|)
expr_stmt|;
name|CVMX_CACHE_WBIL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|set
operator|=
literal|0
init|;
name|set
operator|<
name|n_set
condition|;
name|set
operator|++
control|)
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|n_assoc
condition|;
name|assoc
operator|++
control|)
name|cvmx_l2c_flush_line
argument_list|(
name|assoc
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_unlock_line
parameter_list|(
name|uint64_t
name|address
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|int
name|assoc
decl_stmt|;
name|cvmx_l2c_tag_t
name|tag
decl_stmt|;
name|uint32_t
name|tag_addr
decl_stmt|;
name|uint32_t
name|index
init|=
name|cvmx_l2c_address_to_index
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|tag_addr
operator|=
operator|(
operator|(
name|address
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* For 63XX, we can flush a line by using the physical address directly,         ** so finding the cache line used by the address is only required to provide         ** the proper return value for the function.         */
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|CVMX_L2_ASSOC
condition|;
name|assoc
operator|++
control|)
block|{
name|tag
operator|=
name|cvmx_l2c_get_tag
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|s
operator|.
name|V
operator|&&
operator|(
name|tag
operator|.
name|s
operator|.
name|addr
operator|==
name|tag_addr
operator|)
condition|)
block|{
name|CVMX_CACHE_WBIL2
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tag
operator|.
name|s
operator|.
name|L
return|;
block|}
block|}
block|}
else|else
block|{
name|int
name|assoc
decl_stmt|;
name|cvmx_l2c_tag_t
name|tag
decl_stmt|;
name|uint32_t
name|tag_addr
decl_stmt|;
name|uint32_t
name|index
init|=
name|cvmx_l2c_address_to_index
argument_list|(
name|address
argument_list|)
decl_stmt|;
comment|/* Compute portion of address that is stored in tag */
name|tag_addr
operator|=
operator|(
operator|(
name|address
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|CVMX_L2_ASSOC
condition|;
name|assoc
operator|++
control|)
block|{
name|tag
operator|=
name|cvmx_l2c_get_tag
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|s
operator|.
name|V
operator|&&
operator|(
name|tag
operator|.
name|s
operator|.
name|addr
operator|==
name|tag_addr
operator|)
condition|)
block|{
name|cvmx_l2c_flush_line
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|tag
operator|.
name|s
operator|.
name|L
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_unlock_mem_region
parameter_list|(
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|int
name|num_unlocked
init|=
literal|0
decl_stmt|;
comment|/* Round start/end to cache line boundaries */
name|len
operator|+=
name|start
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|start
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|CVMX_CACHE_LINE_MASK
operator|)
operator|&
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|num_unlocked
operator|+=
name|cvmx_l2c_unlock_line
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
return|return
name|num_unlocked
return|;
block|}
end_function

begin_comment
comment|/* Internal l2c tag types.  These are converted to a generic structure ** that can be used on all chips */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
struct|struct
name|cvmx_l2c_tag_cn50xx
block|{
name|uint64_t
name|reserved
range|:
literal|40
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|20
decl_stmt|;
comment|// Phys mem addr (33..14)
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn30xx
block|{
name|uint64_t
name|reserved
range|:
literal|41
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|19
decl_stmt|;
comment|// Phys mem addr (33..15)
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn31xx
block|{
name|uint64_t
name|reserved
range|:
literal|42
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|18
decl_stmt|;
comment|// Phys mem addr (33..16)
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn38xx
block|{
name|uint64_t
name|reserved
range|:
literal|43
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|17
decl_stmt|;
comment|// Phys mem addr (33..17)
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn58xx
block|{
name|uint64_t
name|reserved
range|:
literal|44
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|// Line valid
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|// Line dirty
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|// Line locked
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|// Use, LRU eviction
name|uint64_t
name|addr
range|:
literal|16
decl_stmt|;
comment|// Phys mem addr (33..18)
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_l2c_tag_cn58xx
name|cn56xx
decl_stmt|;
comment|/* 2048 sets */
name|struct
name|cvmx_l2c_tag_cn31xx
name|cn52xx
decl_stmt|;
comment|/* 512 sets */
endif|#
directive|endif
block|}
name|__cvmx_l2c_tag_t
typedef|;
end_typedef

begin_comment
comment|/**  * @INTERNAL  * Function to read a L2C tag.  This code make the current core  * the 'debug core' for the L2.  This code must only be executed by  * 1 core at a time.  *  * @param assoc  Association (way) of the tag to dump  * @param index  Index of the cacheline  *  * @return The Octeon model specific tag structure.  This is translated by a wrapper  *         function to a generic form that is easier for applications to use.  */
end_comment

begin_function
specifier|static
name|__cvmx_l2c_tag_t
name|__read_l2_tag
parameter_list|(
name|uint64_t
name|assoc
parameter_list|,
name|uint64_t
name|index
parameter_list|)
block|{
name|uint64_t
name|debug_tag_addr
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|index
operator|<<
literal|7
operator|)
operator|+
literal|96
argument_list|)
decl_stmt|;
name|uint64_t
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|__cvmx_l2c_tag_t
name|tag_val
decl_stmt|;
name|uint64_t
name|dbg_addr
init|=
name|CVMX_L2C_DBG
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|cvmx_l2c_dbg_t
name|debug_val
decl_stmt|;
name|debug_val
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* For low core count parts, the core number is always small enough     ** to stay in the correct field and not set any reserved bits */
name|debug_val
operator|.
name|s
operator|.
name|ppnum
operator|=
name|core
expr_stmt|;
name|debug_val
operator|.
name|s
operator|.
name|l2t
operator|=
literal|1
expr_stmt|;
name|debug_val
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* Make sure core is quiet (no prefetches, etc.) before entering debug mode */
name|CVMX_DCACHE_INVALIDATE
expr_stmt|;
comment|/* Flush L1 to make sure debug load misses L1 */
name|cvmx_local_irq_save
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/* The following must be done in assembly as when in debug mode all data loads from     ** L2 return special debug data, not normal memory contents.  Also, interrupts must be disabled,     ** since if an interrupt occurs while in debug mode the ISR will get debug data from all its memory     ** reads instead of the contents of memory */
asm|asm
specifier|volatile
asm|(     "        .set push              \n"     "        .set mips64              \n"     "        .set noreorder           \n"     "        sd    %[dbg_val], 0(%[dbg_addr])  \n"
comment|/* Enter debug mode, wait for store */
asm|"        ld    $0, 0(%[dbg_addr]) \n"     "        ld    %[tag_val], 0(%[tag_addr]) \n"
comment|/* Read L2C tag data */
asm|"        sd    $0, 0(%[dbg_addr])  \n"
comment|/* Exit debug mode, wait for store */
asm|"        ld    $0, 0(%[dbg_addr]) \n"     "        cache 9, 0($0) \n"
comment|/* Invalidate dcache to discard debug data */
asm|"        .set pop             \n"     :[tag_val] "=r" (tag_val):  [dbg_addr] "r" (dbg_addr), [dbg_val] "r" (debug_val), [tag_addr] "r" (debug_tag_addr) : "memory");
name|cvmx_local_irq_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag_val
operator|)
return|;
block|}
end_function

begin_function
name|cvmx_l2c_tag_t
name|cvmx_l2c_get_tag
parameter_list|(
name|uint32_t
name|association
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|cvmx_l2c_tag_t
name|tag
decl_stmt|;
name|tag
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|association
operator|>=
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag association out of range\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|index
operator|>=
name|cvmx_l2c_get_num_sets
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|index
argument_list|,
name|cvmx_l2c_get_num_sets
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|tag
operator|)
return|;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|cvmx_l2c_tadx_tag_t
name|l2c_tadx_tag
decl_stmt|;
name|uint64_t
name|address
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|association
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator||
operator|(
name|index
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
argument_list|)
decl_stmt|;
comment|/* Use L2 cache Index load tag cache instruction, as hardware loads            the virtual tag for the L2 cache block with the contents of            L2C_TAD0_TAG register. */
name|CVMX_CACHE_LTGL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|// make sure CVMX_L2C_TADX_TAG is updated
name|l2c_tadx_tag
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_TAG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|valid
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|dirty
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|lock
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|use
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|tag
expr_stmt|;
block|}
else|else
block|{
name|__cvmx_l2c_tag_t
name|tmp_tag
decl_stmt|;
comment|/* __read_l2_tag is intended for internal use only */
name|tmp_tag
operator|=
name|__read_l2_tag
argument_list|(
name|association
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/* Convert all tag structure types to generic version, as it can represent all models */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|addr
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tag
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|uint32_t
name|cvmx_l2c_address_to_index
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|addr
operator|>>
name|CVMX_L2C_IDX_ADDR_SHIFT
decl_stmt|;
name|int
name|indxalias
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_ctl_t
name|l2c_ctl
decl_stmt|;
name|l2c_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CTL
argument_list|)
expr_stmt|;
name|indxalias
operator|=
operator|!
name|l2c_ctl
operator|.
name|s
operator|.
name|disidxalias
expr_stmt|;
block|}
else|else
block|{
name|cvmx_l2c_cfg_t
name|l2c_cfg
decl_stmt|;
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
name|indxalias
operator|=
name|l2c_cfg
operator|.
name|s
operator|.
name|idxalias
expr_stmt|;
block|}
if|if
condition|(
name|indxalias
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|uint32_t
name|a_14_12
init|=
operator|(
name|idx
operator|/
operator|(
name|CVMX_L2C_MEMBANK_SELECT_SIZE
operator|/
operator|(
literal|1
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
operator|)
operator|)
operator|&
literal|0x7
decl_stmt|;
name|idx
operator|^=
name|idx
operator|/
name|cvmx_l2c_get_num_sets
argument_list|()
expr_stmt|;
name|idx
operator|^=
name|a_14_12
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|^=
operator|(
operator|(
name|addr
operator|&
name|CVMX_L2C_ALIAS_MASK
operator|)
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
expr_stmt|;
block|}
block|}
name|idx
operator|&=
name|CVMX_L2C_IDX_MASK
expr_stmt|;
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_cache_size_bytes
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cvmx_l2c_get_num_sets
argument_list|()
operator|*
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|*
name|CVMX_CACHE_LINE_SIZE
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Return log base 2 of the number of sets in the L2 cache  * @return  */
end_comment

begin_function
name|int
name|cvmx_l2c_get_set_bits
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|l2_set_bits
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|11
expr_stmt|;
comment|/* 2048 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|10
expr_stmt|;
comment|/* 1024 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|9
expr_stmt|;
comment|/* 512 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|8
expr_stmt|;
comment|/* 256 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|7
expr_stmt|;
comment|/* 128 sets */
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|l2_set_bits
operator|=
literal|11
expr_stmt|;
comment|/* 2048 sets */
block|}
return|return
operator|(
name|l2_set_bits
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of sets in the L2 Cache */
end_comment

begin_function
name|int
name|cvmx_l2c_get_num_sets
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
literal|1
operator|<<
name|cvmx_l2c_get_set_bits
argument_list|()
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the number of associations in the L2 Cache */
end_comment

begin_function
name|int
name|cvmx_l2c_get_num_assoc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|l2_assoc
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
name|l2_assoc
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Check to see if part of the cache is disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|cvmx_mio_fus_dat3_t
name|mio_fus_dat3
decl_stmt|;
name|mio_fus_dat3
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_FUS_DAT3
argument_list|)
expr_stmt|;
comment|/* cvmx_mio_fus_dat3.s.l2c_crip fuses map as follows<2> will be not used for 63xx<1> disables 1/2 ways<0> disables 1/4 ways            They are cumulative, so for 63xx:<1><0>            0 0 16-way 2MB cache            0 1 12-way 1.5MB cache            1 0 8-way 1MB cache            1 1 4-way 512KB cache */
if|if
condition|(
name|mio_fus_dat3
operator|.
name|s
operator|.
name|l2c_crip
operator|==
literal|3
condition|)
name|l2_assoc
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|mio_fus_dat3
operator|.
name|s
operator|.
name|l2c_crip
operator|==
literal|2
condition|)
name|l2_assoc
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|mio_fus_dat3
operator|.
name|s
operator|.
name|l2c_crip
operator|==
literal|1
condition|)
name|l2_assoc
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|cvmx_l2d_fus3_t
name|val
decl_stmt|;
name|val
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FUS3
argument_list|)
expr_stmt|;
comment|/* Using shifts here, as bit position names are different for            each model but they all mean the same. */
if|if
condition|(
operator|(
name|val
operator|.
name|u64
operator|>>
literal|35
operator|)
operator|&
literal|0x1
condition|)
name|l2_assoc
operator|=
name|l2_assoc
operator|>>
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|.
name|u64
operator|>>
literal|34
operator|)
operator|&
literal|0x1
condition|)
name|l2_assoc
operator|=
name|l2_assoc
operator|>>
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|l2_assoc
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * Flush a line from the L2 cache  * This should only be called from one core at a time, as this routine  * sets the core to the 'debug' core in order to flush the line.  *  * @param assoc  Association (or way) to flush  * @param index  Index to flush  */
end_comment

begin_function
name|void
name|cvmx_l2c_flush_line
parameter_list|(
name|uint32_t
name|assoc
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
comment|/* Check the range of the index. */
if|if
condition|(
name|index
operator|>
operator|(
name|uint32_t
operator|)
name|cvmx_l2c_get_num_sets
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_flush_line index out of range.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check the range of association. */
if|if
condition|(
name|assoc
operator|>
operator|(
name|uint32_t
operator|)
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_flush_line association out of range.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|uint64_t
name|address
decl_stmt|;
comment|/* Create the address based on index and association.            Bits<20:17> select the way of the cache block involved in                        the operation            Bits<16:7> of the effect address select the index */
name|address
operator|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|assoc
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator||
operator|(
name|index
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|CVMX_CACHE_WBIL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_l2c_dbg_t
name|l2cdbg
decl_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|finv
operator|=
literal|1
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
comment|/* Enter debug mode, and make sure all other writes complete before we         ** enter debug mode */
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|CVMX_PREPARE_FOR_STORE
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|index
operator|*
name|CVMX_CACHE_LINE_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Exit debug mode */
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/* L2C Virtualization APIs. These APIs are based on Octeon II documentation. */
end_comment

begin_comment
comment|/**  * @INTERNAL  * Helper function to decode VALUE to number of allowed virtualization IDS.  * Returns L2C_VRT_CTL[NUMID].  *   * @param nvid     Number of virtual Ids.  * @return         On success decode to NUMID, or to -1 on failure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_l2c_vrt_decode_numid
parameter_list|(
name|int
name|nvid
parameter_list|)
block|{
name|int
name|bits
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|zero_bits
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
if|if
condition|(
name|nvid
operator|<
literal|1
operator|||
name|nvid
operator|>
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Invalid number of virtual ids(%d) requested, should be<= 64\n"
argument_list|,
name|nvid
argument_list|)
expr_stmt|;
return|return
name|bits
return|;
block|}
while|while
condition|(
name|nvid
condition|)
block|{
if|if
condition|(
operator|(
name|nvid
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|zero_bits
operator|++
expr_stmt|;
name|bits
operator|++
expr_stmt|;
name|nvid
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|==
literal|1
operator|||
operator|(
name|zero_bits
operator|&&
operator|(
operator|(
name|bits
operator|-
name|zero_bits
operator|)
operator|==
literal|1
operator|)
operator|)
condition|)
return|return
name|zero_bits
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Set maxium number of Virtual IDs allowed in a machine.   *  * @param nvid   Number of virtial ids allowed in a machine.  * @return       Return 0 on success or -1 on failure.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_set_max_virtids
parameter_list|(
name|int
name|nvid
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
condition|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Changing number of Virtual Machine IDs is not allowed after Virtualization is enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nvid
operator|<
literal|1
operator|||
name|nvid
operator|>
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_max_virtids: Invalid number of Virtual Machine IDs(%d) requested, max allowed %d\n"
argument_list|,
name|nvid
argument_list|,
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Calculate the numid based on nvid */
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
operator|=
name|__cvmx_l2c_vrt_decode_numid
argument_list|(
name|nvid
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get maxium number of virtual IDs allowed in a machine.  *  * @return  Return number of virtual machine IDs or -1 on failure.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_get_max_virtids
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|virtids
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|virtids
operator|=
literal|1
operator|<<
operator|(
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|virtids
operator|>
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_get_max_virtids: Invalid number of Virtual IDs initialized (%d)\n"
argument_list|,
name|virtids
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
name|virtids
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Helper function to decode VALUE to memory space coverage of L2C_VRT_MEM.  * Returns L2C_VRT_CTL[MEMSZ].  *   * @param memsz    Memory in GB.  * @return         On success, decode to MEMSZ, or on failure return -1.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_l2c_vrt_decode_memsize
parameter_list|(
name|int
name|memsz
parameter_list|)
block|{
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|int
name|zero_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
if|if
condition|(
name|memsz
operator|==
literal|0
operator|||
name|memsz
operator|>
name|CVMX_L2C_VRT_MAX_MEMSZ_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Invalid virtual memory size(%d) requested, should be<= %d\n"
argument_list|,
name|memsz
argument_list|,
name|CVMX_L2C_VRT_MAX_MEMSZ_ALLOWED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|memsz
condition|)
block|{
if|if
condition|(
operator|(
name|memsz
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|zero_bits
operator|++
expr_stmt|;
name|bits
operator|++
expr_stmt|;
name|memsz
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|==
literal|1
operator|||
operator|(
name|bits
operator|-
name|zero_bits
operator|)
operator|==
literal|1
condition|)
return|return
name|zero_bits
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Set the maxium size of memory space to be allocated for virtualization.  *  * @param memsz  Size of the virtual memory in GB  * @return       Return 0 on success or -1 on failure.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_set_max_memsz
parameter_list|(
name|int
name|memsz
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|int
name|decode
init|=
literal|0
decl_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_memsz: Changing the size of the memory after Virtualization is enabled is not allowed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|memsz
operator|>=
call|(
name|int
call|)
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|system_dram_size
operator|/
literal|1000000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_memsz: Invalid memory size (%d GB), greater than available on the chip\n"
argument_list|,
name|memsz
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|decode
operator|=
name|__cvmx_l2c_vrt_decode_memsize
argument_list|(
name|memsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
operator|==
operator|-
literal|1
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_memsz: Invalid memory size (%d GB), refer to L2C_VRT_CTL[MEMSZ] for more information\n"
argument_list|,
name|memsz
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|memsz
operator|=
name|decode
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Set a Virtual ID to a set of cores.  *  * @param virtid    Assign virtid to a set of cores.  * @param coremask  The group of cores to assign a unique virtual id.  * @return          Return 0 on success, otherwise -1.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_assign_virtid
parameter_list|(
name|int
name|virtid
parameter_list|,
name|uint32_t
name|coremask
parameter_list|)
block|{
name|uint32_t
name|core
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|max_virtid
init|=
name|cvmx_l2c_vrt_get_max_virtids
argument_list|()
decl_stmt|;
if|if
condition|(
name|virtid
operator|>
name|max_virtid
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_assign_virt_id: Max %d number of virtids are allowed, passed %d.\n"
argument_list|,
name|max_virtid
argument_list|,
name|virtid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|core
operator|<
name|cvmx_octeon_num_cores
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|coremask
operator|>>
name|core
operator|)
operator|&
literal|1
condition|)
block|{
name|cvmx_l2c_virtid_ppx_t
name|l2c_virtid_ppx
decl_stmt|;
name|cvmx_l2c_virtid_iobx_t
name|l2c_virtid_iobx
decl_stmt|;
name|l2c_virtid_ppx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the core already has a virtid assigned. */
if|if
condition|(
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_assign_virt_id: Changing virtid of core #%d to %d from %d.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|core
argument_list|,
name|virtid
argument_list|,
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* Flush L2 cache to avoid write errors */
name|cvmx_l2c_flush
argument_list|()
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|,
name|virtid
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* Set the IOB to normal mode. */
name|l2c_virtid_iobx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_IOBX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
name|l2c_virtid_iobx
operator|.
name|s
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|l2c_virtid_iobx
operator|.
name|s
operator|.
name|dwbid
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VIRTID_IOBX
argument_list|(
name|core
argument_list|)
argument_list|,
name|l2c_virtid_iobx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|core
operator|++
expr_stmt|;
block|}
comment|/* Invalid coremask passed. */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_assign_virt_id: Invalid coremask(0x%x) passed\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Remove a virt id assigned to a set of cores. Update the virtid mask and  * virtid stored for each core.   *  * @param virtid  Remove the specified Virtualization machine ID.  */
end_comment

begin_function
name|void
name|cvmx_l2c_vrt_remove_virtid
parameter_list|(
name|int
name|virtid
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|uint32_t
name|core
decl_stmt|;
name|cvmx_l2c_virtid_ppx_t
name|l2c_virtid_ppx
decl_stmt|;
for|for
control|(
name|core
operator|=
literal|0
init|;
name|core
operator|<
name|cvmx_octeon_num_cores
argument_list|()
condition|;
name|core
operator|++
control|)
block|{
name|l2c_virtid_ppx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtid
operator|==
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function to protect the memory region based on the granularity.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|__cvmx_l2c_vrt_get_granularity
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|gran
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|int
name|nvid
decl_stmt|;
name|uint64_t
name|szd
decl_stmt|;
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|nvid
operator|=
name|cvmx_l2c_vrt_get_max_virtids
argument_list|()
expr_stmt|;
name|szd
operator|=
operator|(
literal|1ull
operator|<<
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|memsz
operator|)
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|gran
operator|=
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|szd
operator|*
name|nvid
argument_list|)
operator|/
operator|(
literal|32ull
operator|*
literal|1024
operator|)
expr_stmt|;
block|}
return|return
name|gran
return|;
block|}
end_function

begin_comment
comment|/**  * Block a memory region to be updated for a given virtual id.  *  * @param start_addr   Starting address of memory region  * @param size         Size of the memory to protect  * @param virtid       Virtual ID to use  * @param mode         Allow/Disallow write access  *                        = 0,  Allow write access by virtid  *                        = 1,  Disallow write access by virtid  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_memprotect
parameter_list|(
name|uint64_t
name|start_addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|virtid
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
comment|/* Check the alignment of start address, should be aligned to the            granularity. */
name|uint64_t
name|gran
init|=
name|__cvmx_l2c_vrt_get_granularity
argument_list|()
decl_stmt|;
name|uint64_t
name|end_addr
init|=
name|start_addr
operator|+
name|size
decl_stmt|;
name|int
name|byte_offset
decl_stmt|,
name|virtid_offset
decl_stmt|;
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|cvmx_l2c_vrt_memx_t
name|l2c_vrt_mem
decl_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
comment|/* No need to protect if virtualization is not enabled */
if|if
condition|(
operator|!
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Virtualization is not enabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|virtid
operator|>
name|cvmx_l2c_vrt_get_max_virtids
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Virtualization id is greater than max allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* No need to protect if virtid is not assigned to a core */
block|{
name|cvmx_l2c_virtid_ppx_t
name|l2c_virtid_ppx
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|uint32_t
name|core
decl_stmt|;
for|for
control|(
name|core
operator|=
literal|0
init|;
name|core
operator|<
name|cvmx_octeon_num_cores
argument_list|()
condition|;
name|core
operator|++
control|)
block|{
name|l2c_virtid_ppx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
operator|==
name|virtid
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Virtualization id (%d) is not assigned to any core.\n"
argument_list|,
name|virtid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Make sure previous stores are through before protecting the memory. */
name|CVMX_SYNCW
expr_stmt|;
comment|/* If the L2/DRAM physical address is>= 512 MB, subtract 256 MB            to get the address to use. This is because L2C removes the 256MB             "hole" between DR0 and DR1. */
if|if
condition|(
name|start_addr
operator|>=
operator|(
literal|512
operator|*
literal|1024
operator|*
literal|1024
operator|)
condition|)
name|start_addr
operator|-=
literal|256
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|start_addr
operator|!=
operator|(
operator|(
name|start_addr
operator|+
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Start address is not aligned\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check the size of the memory to protect, should be aligned to the            granularity. */
if|if
condition|(
name|end_addr
operator|!=
operator|(
operator|(
name|end_addr
operator|+
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|end_addr
operator|=
operator|(
name|start_addr
operator|+
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|gran
operator|-
literal|1
operator|)
expr_stmt|;
name|size
operator|=
name|start_addr
operator|-
name|end_addr
expr_stmt|;
block|}
name|byte_offset
operator|=
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|memsz
operator|+
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
operator|+
literal|16
expr_stmt|;
name|virtid_offset
operator|=
literal|14
operator|-
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_vrt_spinlock
argument_list|)
expr_stmt|;
comment|/* Enable memory protection for each virtid for the specified range. */
while|while
condition|(
name|start_addr
operator|<
name|end_addr
condition|)
block|{
comment|/* When L2C virtualization is enabled and a bit is set in                 L2C_VRT_MEM(0..1023), then L2C prevents the selected virtual                 machine from storing to the selected L2C/DRAM region. */
name|int
name|offset
decl_stmt|,
name|position
decl_stmt|,
name|i
decl_stmt|;
name|int
name|l2c_vrt_mem_bit_index
init|=
name|start_addr
operator|>>
name|byte_offset
decl_stmt|;
name|l2c_vrt_mem_bit_index
operator||=
operator|(
name|virtid
operator|<<
name|virtid_offset
operator|)
expr_stmt|;
name|offset
operator|=
name|l2c_vrt_mem_bit_index
operator|>>
literal|5
expr_stmt|;
name|position
operator|=
name|l2c_vrt_mem_bit_index
operator|&
literal|0x1f
expr_stmt|;
name|l2c_vrt_mem
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_MEMX
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow/Disallow write access to memory. */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|data
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|position
operator|)
expr_stmt|;
else|else
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|data
operator||=
literal|1
operator|<<
name|position
expr_stmt|;
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|parity
operator|=
literal|0
expr_stmt|;
comment|/* PARITY<i> is the even parity of DATA<i*8+7:i*8>, which means                that each bit<i> in PARITY[0..3], is the XOR of all the bits                in the corresponding byte in DATA. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|mask
init|=
literal|0xffull
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|cvmx_pop
argument_list|(
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|data
operator|&
name|mask
argument_list|)
operator|&
literal|0x1
operator|)
condition|)
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|parity
operator||=
operator|(
literal|1ull
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_MEMX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|l2c_vrt_mem
operator|.
name|u64
argument_list|)
expr_stmt|;
name|start_addr
operator|+=
name|gran
expr_stmt|;
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_vrt_spinlock
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Enable virtualization.  *  * @param mode   Whether out of bound writes are an error.  */
end_comment

begin_function
name|void
name|cvmx_l2c_vrt_enable
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
comment|/* Enable global virtualization */
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|ooberr
operator|=
name|mode
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Disable virtualization.  */
end_comment

begin_function
name|void
name|cvmx_l2c_vrt_disable
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
condition|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
comment|/* Disable global virtualization */
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

