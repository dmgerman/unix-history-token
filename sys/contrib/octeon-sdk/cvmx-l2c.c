begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Implementation of the Level 2 Cache (L2C) control,  * measurement, and debugging facilities.  *  *<hr>$Revision: 70215 $<hr>  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-l2c.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-spinlock.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-l2c.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-interrupt.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/*  * This spinlock is used internally to ensure that only one core is  * performing certain L2 operations at a time.  *  * NOTE: This only protects calls from within a single application -  * if multiple applications or operating systems are running, then it  * is up to the user program to coordinate between them.  */
end_comment

begin_decl_stmt
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_l2c_spinlock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvmx_l2c_get_core_way_partition
parameter_list|(
name|uint32_t
name|core
parameter_list|)
block|{
name|uint32_t
name|field
decl_stmt|;
comment|/* Validate the core number */
if|if
condition|(
name|core
operator|>=
name|cvmx_octeon_num_cores
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_WPAR_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
operator|&
literal|0xffff
operator|)
return|;
comment|/*      * Use the lower two bits of the coreNumber to determine the      * bit offset of the UMSK[] field in the L2C_SPAR register.      */
name|field
operator|=
operator|(
name|core
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
comment|/*      * Return the UMSK[] field from the appropriate L2C_SPAR      * register based on the coreNumber.      */
switch|switch
condition|(
name|core
operator|&
literal|0xC
condition|)
block|{
case|case
literal|0x0
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
return|;
case|case
literal|0x4
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
return|;
case|case
literal|0x8
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
return|;
case|case
literal|0xC
case|:
return|return
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|)
operator|&
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator|>>
name|field
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_core_way_partition
parameter_list|(
name|uint32_t
name|core
parameter_list|,
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|field
decl_stmt|;
name|uint32_t
name|valid_mask
decl_stmt|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
comment|/* A UMSK setting which blocks all L2C Ways is an error on some chips */
if|if
condition|(
name|mask
operator|==
name|valid_mask
operator|&&
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Validate the core number */
if|if
condition|(
name|core
operator|>=
name|cvmx_octeon_num_cores
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_WPAR_PPX
argument_list|(
name|core
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*      * Use the lower two bits of core to determine the bit offset of the      * UMSK[] field in the L2C_SPAR register.      */
name|field
operator|=
operator|(
name|core
operator|&
literal|0x3
operator|)
operator|*
literal|8
expr_stmt|;
comment|/*      * Assign the new mask setting to the UMSK[] field in the appropriate      * L2C_SPAR register based on the core_num.      *      */
switch|switch
condition|(
name|core
operator|&
literal|0xC
condition|)
block|{
case|case
literal|0x0
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR0
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x4
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR1
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x8
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR2
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xC
case|:
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR3
argument_list|)
operator|&
operator|~
operator|(
literal|0xFF
operator|<<
name|field
operator|)
operator|)
operator||
name|mask
operator|<<
name|field
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_hw_way_partition
parameter_list|(
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|valid_mask
decl_stmt|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
comment|/* A UMSK setting which blocks all L2C Ways is an error on some chips */
if|if
condition|(
name|mask
operator|==
name|valid_mask
operator|&&
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_WPAR_IOBX
argument_list|(
literal|0
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|,
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|)
operator|&
operator|~
literal|0xFF
operator|)
operator||
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_hw_way_partition
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_WPAR_IOBX
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|&
literal|0xffff
return|;
else|else
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_SPAR4
argument_list|)
operator|&
operator|(
literal|0xFF
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_set_hw_way_partition2
parameter_list|(
name|uint32_t
name|mask
parameter_list|)
block|{
name|uint32_t
name|valid_mask
decl_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|valid_mask
operator|=
operator|(
literal|0x1
operator|<<
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|)
operator|-
literal|1
expr_stmt|;
name|mask
operator|&=
name|valid_mask
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_WPAR_IOBX
argument_list|(
literal|1
argument_list|)
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_hw_way_partition2
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_warn
argument_list|(
literal|"only one IOB on this chip"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_WPAR_IOBX
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|&
literal|0xffff
return|;
block|}
end_function

begin_function
name|void
name|cvmx_l2c_config_perf
parameter_list|(
name|uint32_t
name|counter
parameter_list|,
name|enum
name|cvmx_l2c_event
name|event
parameter_list|,
name|uint32_t
name|clear_on_read
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
block|{
name|union
name|cvmx_l2c_pfctl
name|pfctl
decl_stmt|;
name|pfctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFCTL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt0sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt0ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt0rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt1sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt1ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt1rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pfctl
operator|.
name|s
operator|.
name|cnt2sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt2ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt2rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
case|case
literal|3
case|:
default|default:
name|pfctl
operator|.
name|s
operator|.
name|cnt3sel
operator|=
name|event
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt3ena
operator|=
literal|1
expr_stmt|;
name|pfctl
operator|.
name|s
operator|.
name|cnt3rdclr
operator|=
name|clear_on_read
expr_stmt|;
break|break;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_PFCTL
argument_list|,
name|pfctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|union
name|cvmx_l2c_tadx_prf
name|l2c_tadx_prf
decl_stmt|;
name|int
name|tad
decl_stmt|;
name|cvmx_warn
argument_list|(
literal|"L2C performance counter events are different for this chip, mapping 'event' to cvmx_l2c_tad_event_t\n"
argument_list|)
expr_stmt|;
name|cvmx_warn_if
argument_list|(
name|clear_on_read
argument_list|,
literal|"L2C counters don't support clear on read for this chip\n"
argument_list|)
expr_stmt|;
name|l2c_tadx_prf
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PRF
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt0sel
operator|=
name|event
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt1sel
operator|=
name|event
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt2sel
operator|=
name|event
expr_stmt|;
break|break;
default|default:
case|case
literal|3
case|:
name|l2c_tadx_prf
operator|.
name|s
operator|.
name|cnt3sel
operator|=
name|event
expr_stmt|;
break|break;
block|}
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_TADX_PRF
argument_list|(
name|tad
argument_list|)
argument_list|,
name|l2c_tadx_prf
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|cvmx_l2c_read_perf
parameter_list|(
name|uint32_t
name|counter
parameter_list|)
block|{
switch|switch
condition|(
name|counter
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC0
argument_list|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC0
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
case|case
literal|1
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC1
argument_list|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC1
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
case|case
literal|2
case|:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC2
argument_list|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC2
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
case|case
literal|3
case|:
default|default:
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
condition|)
return|return
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_PFC3
argument_list|)
return|;
else|else
block|{
name|uint64_t
name|counter
init|=
literal|0
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
name|counter
operator|+=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_PFC3
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|counter
return|;
block|}
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Helper function use to fault in cache lines for L2 cache locking  *  * @param addr   Address of base of memory region to read into L2 cache  * @param len    Length (in bytes) of region to fault in  */
end_comment

begin_function
specifier|static
name|void
name|fault_in
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
specifier|volatile
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|volatile
name|char
name|dummy
init|=
literal|0
decl_stmt|;
comment|/*      * Adjust addr and length so we get all cache lines even for      * small ranges spanning two cache lines.      */
name|len
operator|+=
name|addr
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|addr
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|ptr
operator|=
operator|(
specifier|volatile
name|char
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/*      * Invalidate L1 cache to make sure all loads result in data      * being in L2.      */
name|CVMX_DCACHE_INVALIDATE
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|dummy
operator|+=
operator|*
name|ptr
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|ptr
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_lock_line
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|int
name|shift
init|=
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
decl_stmt|;
name|uint64_t
name|assoc
init|=
name|cvmx_l2c_get_num_assoc
argument_list|()
decl_stmt|;
name|uint32_t
name|tag
init|=
name|cvmx_l2c_v2_address_to_tag
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|uint64_t
name|indext
init|=
name|cvmx_l2c_address_to_index
argument_list|(
name|addr
argument_list|)
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
decl_stmt|;
name|uint64_t
name|index
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|indext
argument_list|)
decl_stmt|;
name|uint64_t
name|way
decl_stmt|;
name|uint32_t
name|tad
decl_stmt|;
name|union
name|cvmx_l2c_tadx_tag
name|l2c_tadx_tag
decl_stmt|;
if|if
condition|(
name|tag
operator|==
literal|0xFFFFFFFF
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_lock_line: addr 0x%llx in LMC hole."
literal|"\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|tad
operator|=
name|cvmx_l2c_address_to_tad
argument_list|(
name|addr
argument_list|)
expr_stmt|;
comment|/* cvmx_dprintf("shift=%d index=%lx tag=%x\n",shift, index, tag); */
name|CVMX_CACHE_LCKL2
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|addr
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
comment|/* Make sure we were able to lock the line */
for|for
control|(
name|way
operator|=
literal|0
init|;
name|way
operator|<
name|assoc
condition|;
name|way
operator|++
control|)
block|{
name|uint64_t
name|caddr
init|=
name|index
operator||
operator|(
name|way
operator|<<
name|shift
operator|)
decl_stmt|;
name|CVMX_CACHE_LTGL2I
argument_list|(
name|caddr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make sure CVMX_L2C_TADX_TAG is updated */
name|CVMX_SYNC
expr_stmt|;
name|l2c_tadx_tag
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_TAG
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|valid
operator|&&
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|tag
operator|==
name|tag
condition|)
break|break;
comment|/* cvmx_printf("caddr=%lx tad=%d tagu64=%lx valid=%x tag=%x \n", caddr,                tad, l2c_tadx_tag.u64, l2c_tadx_tag.s.valid, l2c_tadx_tag.s.tag); */
block|}
comment|/* Check if a valid line is found */
if|if
condition|(
name|way
operator|>=
name|assoc
condition|)
block|{
comment|/* cvmx_dprintf("ERROR: cvmx_l2c_lock_line: line not found for locking at"                          " 0x%llx address\n", (unsigned long long)addr); */
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check if lock bit is not set */
if|if
condition|(
operator|!
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|lock
condition|)
block|{
comment|/* cvmx_dprintf("ERROR: cvmx_l2c_lock_line: Not able to lock at "                "0x%llx address\n", (unsigned long long)addr); */
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
else|else
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|union
name|cvmx_l2c_dbg
name|l2cdbg
decl_stmt|;
name|union
name|cvmx_l2c_lckbase
name|lckbase
decl_stmt|;
name|union
name|cvmx_l2c_lckoff
name|lckoff
decl_stmt|;
name|union
name|cvmx_l2t_err
name|l2t_err
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|lckbase
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|lckoff
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Clear l2t error bits if set */
name|l2t_err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
name|l2t_err
operator|.
name|s
operator|.
name|lckerr
operator|=
literal|1
expr_stmt|;
name|l2t_err
operator|.
name|s
operator|.
name|lckerr2
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|,
name|l2t_err
operator|.
name|u64
argument_list|)
expr_stmt|;
name|addr
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
comment|/* Set this core as debug core */
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|lckoff
operator|.
name|s
operator|.
name|lck_offset
operator|=
literal|0
expr_stmt|;
comment|/* Only lock 1 line at a time */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKOFF
argument_list|,
name|lckoff
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKOFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
expr|union
name|cvmx_l2c_cfg
operator|)
operator|(
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
operator|)
operator|)
operator|.
name|s
operator|.
name|idxalias
condition|)
block|{
name|int
name|alias_shift
init|=
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|+
literal|2
operator|*
name|cvmx_l2c_get_set_bits
argument_list|()
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|addr_tmp
init|=
name|addr
operator|^
operator|(
name|addr
operator|&
operator|(
operator|(
literal|1
operator|<<
name|alias_shift
operator|)
operator|-
literal|1
operator|)
operator|)
operator|>>
name|cvmx_l2c_get_set_bits
argument_list|()
decl_stmt|;
name|lckbase
operator|.
name|s
operator|.
name|lck_base
operator|=
name|addr_tmp
operator|>>
literal|7
expr_stmt|;
block|}
else|else
block|{
name|lckbase
operator|.
name|s
operator|.
name|lck_base
operator|=
name|addr
operator|>>
literal|7
expr_stmt|;
block|}
name|lckbase
operator|.
name|s
operator|.
name|lck_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|,
name|lckbase
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Make sure it gets there */
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|)
expr_stmt|;
name|fault_in
argument_list|(
name|addr
argument_list|,
name|CVMX_CACHE_LINE_SIZE
argument_list|)
expr_stmt|;
name|lckbase
operator|.
name|s
operator|.
name|lck_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|,
name|lckbase
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Make sure it gets there */
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_LCKBASE
argument_list|)
expr_stmt|;
comment|/* Stop being debug core */
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|l2t_err
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2T_ERR
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2t_err
operator|.
name|s
operator|.
name|lckerr
operator|||
name|l2t_err
operator|.
name|s
operator|.
name|lckerr2
condition|)
name|retval
operator|=
literal|1
expr_stmt|;
comment|/* We were unable to lock the line */
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_lock_mem_region
parameter_list|(
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
comment|/* Round start/end to cache line boundaries */
name|len
operator|+=
name|start
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|start
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|CVMX_CACHE_LINE_MASK
operator|)
operator|&
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
while|while
condition|(
name|len
condition|)
block|{
if|if
condition|(
name|cvmx_l2c_lock_line
argument_list|(
name|start
argument_list|)
operator|!=
literal|0
condition|)
name|retval
operator|--
expr_stmt|;
name|start
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_function
name|void
name|cvmx_l2c_flush
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|assoc
decl_stmt|,
name|set
decl_stmt|;
name|uint64_t
name|n_assoc
decl_stmt|,
name|n_set
decl_stmt|;
name|n_set
operator|=
name|cvmx_l2c_get_num_sets
argument_list|()
expr_stmt|;
name|n_assoc
operator|=
name|cvmx_l2c_get_num_assoc
argument_list|()
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|uint64_t
name|address
decl_stmt|;
comment|/* These may look like constants, but they aren't... */
name|int
name|assoc_shift
init|=
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
decl_stmt|;
name|int
name|set_shift
init|=
name|CVMX_L2C_IDX_ADDR_SHIFT
decl_stmt|;
for|for
control|(
name|set
operator|=
literal|0
init|;
name|set
operator|<
name|n_set
condition|;
name|set
operator|++
control|)
block|{
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|n_assoc
condition|;
name|assoc
operator|++
control|)
block|{
name|address
operator|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|assoc
operator|<<
name|assoc_shift
operator|)
operator||
operator|(
name|set
operator|<<
name|set_shift
operator|)
argument_list|)
expr_stmt|;
name|CVMX_CACHE_WBIL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|set
operator|=
literal|0
init|;
name|set
operator|<
name|n_set
condition|;
name|set
operator|++
control|)
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|n_assoc
condition|;
name|assoc
operator|++
control|)
name|cvmx_l2c_flush_line
argument_list|(
name|assoc
argument_list|,
name|set
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|cvmx_l2c_unlock_line
parameter_list|(
name|uint64_t
name|address
parameter_list|)
block|{
name|uint32_t
name|tad
init|=
name|cvmx_l2c_address_to_tad
argument_list|(
name|address
argument_list|)
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|int
name|assoc
decl_stmt|;
name|union
name|cvmx_l2c_tag
name|tag
decl_stmt|;
name|uint32_t
name|tag_addr
decl_stmt|;
name|uint32_t
name|index
init|=
name|cvmx_l2c_address_to_index
argument_list|(
name|address
argument_list|)
decl_stmt|;
name|tag_addr
operator|=
operator|(
operator|(
name|address
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
comment|/*          * For OcteonII, we can flush a line by using the physical          * address directly, so finding the cache line used by          * the address is only required to provide the proper          * return value for the function.          */
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|;
name|assoc
operator|++
control|)
block|{
name|tag
operator|=
name|cvmx_l2c_get_tag_v2
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|,
name|tad
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|s
operator|.
name|V
operator|&&
operator|(
name|tag
operator|.
name|s
operator|.
name|addr
operator|==
name|tag_addr
operator|)
condition|)
block|{
name|CVMX_CACHE_WBIL2
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|address
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|tag
operator|.
name|s
operator|.
name|L
return|;
block|}
block|}
block|}
else|else
block|{
name|int
name|assoc
decl_stmt|;
name|union
name|cvmx_l2c_tag
name|tag
decl_stmt|;
name|uint32_t
name|tag_addr
decl_stmt|;
name|uint32_t
name|index
init|=
name|cvmx_l2c_address_to_index
argument_list|(
name|address
argument_list|)
decl_stmt|;
comment|/* Compute portion of address that is stored in tag */
name|tag_addr
operator|=
operator|(
operator|(
name|address
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
for|for
control|(
name|assoc
operator|=
literal|0
init|;
name|assoc
operator|<
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|;
name|assoc
operator|++
control|)
block|{
name|tag
operator|=
name|cvmx_l2c_get_tag_v2
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|,
name|tad
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag
operator|.
name|s
operator|.
name|V
operator|&&
operator|(
name|tag
operator|.
name|s
operator|.
name|addr
operator|==
name|tag_addr
operator|)
condition|)
block|{
name|cvmx_l2c_flush_line
argument_list|(
name|assoc
argument_list|,
name|index
argument_list|)
expr_stmt|;
return|return
name|tag
operator|.
name|s
operator|.
name|L
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_unlock_mem_region
parameter_list|(
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|len
parameter_list|)
block|{
name|int
name|num_unlocked
init|=
literal|0
decl_stmt|;
comment|/* Round start/end to cache line boundaries */
name|len
operator|+=
name|start
operator|&
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|start
operator|&=
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
name|len
operator|=
operator|(
name|len
operator|+
name|CVMX_CACHE_LINE_MASK
operator|)
operator|&
operator|~
name|CVMX_CACHE_LINE_MASK
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|num_unlocked
operator|+=
name|cvmx_l2c_unlock_line
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|start
operator|+=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
name|len
operator|-=
name|CVMX_CACHE_LINE_SIZE
expr_stmt|;
block|}
return|return
name|num_unlocked
return|;
block|}
end_function

begin_comment
comment|/*  * Internal l2c tag types.  These are converted to a generic structure  * that can be used on all chips.  */
end_comment

begin_union
union|union
name|__cvmx_l2c_tag
block|{
name|uint64_t
name|u64
decl_stmt|;
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
struct|struct
name|cvmx_l2c_tag_cn50xx
block|{
name|uint64_t
name|reserved
range|:
literal|40
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|addr
range|:
literal|20
decl_stmt|;
comment|/* Phys mem addr (33..14) */
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn30xx
block|{
name|uint64_t
name|reserved
range|:
literal|41
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|addr
range|:
literal|19
decl_stmt|;
comment|/* Phys mem addr (33..15) */
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn31xx
block|{
name|uint64_t
name|reserved
range|:
literal|42
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|addr
range|:
literal|18
decl_stmt|;
comment|/* Phys mem addr (33..16) */
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn38xx
block|{
name|uint64_t
name|reserved
range|:
literal|43
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|addr
range|:
literal|17
decl_stmt|;
comment|/* Phys mem addr (33..17) */
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn58xx
block|{
name|uint64_t
name|reserved
range|:
literal|44
decl_stmt|;
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|addr
range|:
literal|16
decl_stmt|;
comment|/* Phys mem addr (33..18) */
block|}
name|cn58xx
struct|;
else|#
directive|else
struct|struct
name|cvmx_l2c_tag_cn50xx
block|{
name|uint64_t
name|addr
range|:
literal|20
decl_stmt|;
comment|/* Phys mem addr (33..14) */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|reserved
range|:
literal|40
decl_stmt|;
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn30xx
block|{
name|uint64_t
name|addr
range|:
literal|19
decl_stmt|;
comment|/* Phys mem addr (33..15) */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|reserved
range|:
literal|41
decl_stmt|;
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn31xx
block|{
name|uint64_t
name|addr
range|:
literal|18
decl_stmt|;
comment|/* Phys mem addr (33..16) */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|reserved
range|:
literal|42
decl_stmt|;
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn38xx
block|{
name|uint64_t
name|addr
range|:
literal|17
decl_stmt|;
comment|/* Phys mem addr (33..17) */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|reserved
range|:
literal|43
decl_stmt|;
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_l2c_tag_cn58xx
block|{
name|uint64_t
name|addr
range|:
literal|16
decl_stmt|;
comment|/* Phys mem addr (33..18) */
name|uint64_t
name|U
range|:
literal|1
decl_stmt|;
comment|/* Use, LRU eviction */
name|uint64_t
name|L
range|:
literal|1
decl_stmt|;
comment|/* Line locked */
name|uint64_t
name|D
range|:
literal|1
decl_stmt|;
comment|/* Line dirty */
name|uint64_t
name|V
range|:
literal|1
decl_stmt|;
comment|/* Line valid */
name|uint64_t
name|reserved
range|:
literal|44
decl_stmt|;
block|}
name|cn58xx
struct|;
endif|#
directive|endif
name|struct
name|cvmx_l2c_tag_cn58xx
name|cn56xx
decl_stmt|;
comment|/* 2048 sets */
name|struct
name|cvmx_l2c_tag_cn31xx
name|cn52xx
decl_stmt|;
comment|/* 512 sets */
block|}
union|;
end_union

begin_comment
comment|/**  * @INTERNAL  * Function to read a L2C tag.  This code make the current core  * the 'debug core' for the L2.  This code must only be executed by  * 1 core at a time.  *  * @param assoc  Association (way) of the tag to dump  * @param index  Index of the cacheline  *  * @return The Octeon model specific tag structure.  This is  *         translated by a wrapper function to a generic form that is  *         easier for applications to use.  */
end_comment

begin_function
specifier|static
name|union
name|__cvmx_l2c_tag
name|__read_l2_tag
parameter_list|(
name|uint64_t
name|assoc
parameter_list|,
name|uint64_t
name|index
parameter_list|)
block|{
name|uint64_t
name|debug_tag_addr
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|index
operator|<<
literal|7
operator|)
operator|+
literal|96
argument_list|)
decl_stmt|;
name|uint64_t
name|core
init|=
name|cvmx_get_core_num
argument_list|()
decl_stmt|;
name|union
name|__cvmx_l2c_tag
name|tag_val
decl_stmt|;
name|uint64_t
name|dbg_addr
init|=
name|CVMX_L2C_DBG
decl_stmt|;
name|unsigned
name|long
name|flags
decl_stmt|;
name|union
name|cvmx_l2c_dbg
name|debug_val
decl_stmt|;
name|debug_val
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/*      * For low core count parts, the core number is always small      * enough to stay in the correct field and not set any      * reserved bits.      */
name|debug_val
operator|.
name|s
operator|.
name|ppnum
operator|=
name|core
expr_stmt|;
name|debug_val
operator|.
name|s
operator|.
name|l2t
operator|=
literal|1
expr_stmt|;
name|debug_val
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
name|cvmx_local_irq_save
argument_list|(
name|flags
argument_list|)
expr_stmt|;
comment|/*      * Make sure core is quiet (no prefetches, etc.) before      * entering debug mode.      */
name|CVMX_SYNC
expr_stmt|;
comment|/* Flush L1 to make sure debug load misses L1 */
name|CVMX_DCACHE_INVALIDATE
expr_stmt|;
comment|/*      * The following must be done in assembly as when in debug      * mode all data loads from L2 return special debug data, not      * normal memory contents.  Also, interrupts must be disabled,      * since if an interrupt occurs while in debug mode the ISR      * will get debug data from all its memory * reads instead of      * the contents of memory.      */
asm|asm
specifier|volatile
asm|(         ".set push\n\t"         ".set mips64\n\t"         ".set noreorder\n\t"         "sd    %[dbg_val], 0(%[dbg_addr])\n\t"
comment|/* Enter debug mode, wait for store */
asm|"ld    $0, 0(%[dbg_addr])\n\t"         "ld    %[tag_val], 0(%[tag_addr])\n\t"
comment|/* Read L2C tag data */
asm|"sd    $0, 0(%[dbg_addr])\n\t"
comment|/* Exit debug mode, wait for store */
asm|"ld    $0, 0(%[dbg_addr])\n\t"         "cache 9, 0($0)\n\t"
comment|/* Invalidate dcache to discard debug data */
asm|".set pop"         : [tag_val] "=r" (tag_val)         : [dbg_addr] "r" (dbg_addr), [dbg_val] "r" (debug_val), [tag_addr] "r" (debug_tag_addr)         : "memory");
name|cvmx_local_irq_restore
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|tag_val
return|;
block|}
end_function

begin_function
name|union
name|cvmx_l2c_tag
name|cvmx_l2c_get_tag_v2
parameter_list|(
name|uint32_t
name|association
parameter_list|,
name|uint32_t
name|index
parameter_list|,
name|uint32_t
name|tad
parameter_list|)
block|{
name|union
name|cvmx_l2c_tag
name|tag
decl_stmt|;
name|tag
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|association
operator|>=
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag association out of range\n"
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|index
operator|>=
name|cvmx_l2c_get_num_sets
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|index
argument_list|,
name|cvmx_l2c_get_num_sets
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|union
name|cvmx_l2c_tadx_tag
name|l2c_tadx_tag
decl_stmt|;
name|uint64_t
name|address
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|association
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator||
operator|(
name|index
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
argument_list|)
decl_stmt|;
comment|/*          * Use L2 cache Index load tag cache instruction, as          * hardware loads the virtual tag for the L2 cache          * block with the contents of L2C_TAD0_TAG          * register.          */
if|if
condition|(
name|tad
operator|>
name|CVMX_L2C_TADS
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag_v2: TAD#%d out of range\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|tad
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
name|CVMX_CACHE_LTGL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* make sure CVMX_L2C_TADX_TAG is updated */
name|l2c_tadx_tag
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_TAG
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|valid
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|dirty
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|lock
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|use
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|tag
expr_stmt|;
block|}
else|else
block|{
name|union
name|__cvmx_l2c_tag
name|tmp_tag
decl_stmt|;
comment|/* __read_l2_tag is intended for internal use only */
name|tmp_tag
operator|=
name|__read_l2_tag
argument_list|(
name|association
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/*          * Convert all tag structure types to generic version,          * as it can represent all models.          */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|addr
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tag
return|;
block|}
end_function

begin_function
name|union
name|cvmx_l2c_tag
name|cvmx_l2c_get_tag
parameter_list|(
name|uint32_t
name|association
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
name|union
name|cvmx_l2c_tag
name|tag
decl_stmt|;
name|tag
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|association
operator|>=
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag association out of range\n"
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
if|if
condition|(
operator|(
name|int
operator|)
name|index
operator|>=
name|cvmx_l2c_get_num_sets
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_get_tag index out of range (arg: %d, max: %d)\n"
argument_list|,
operator|(
name|int
operator|)
name|index
argument_list|,
name|cvmx_l2c_get_num_sets
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|union
name|cvmx_l2c_tadx_tag
name|l2c_tadx_tag
decl_stmt|;
name|uint64_t
name|address
init|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|association
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator||
operator|(
name|index
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Cannot use %s on OCTEON CN68XX, use cvmx_l2c_get_tag_v2 instead!\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
name|tag
return|;
block|}
comment|/*          * Use L2 cache Index load tag cache instruction, as          * hardware loads the virtual tag for the L2 cache          * block with the contents of L2C_TAD0_TAG          * register.          */
name|CVMX_CACHE_LTGL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_SYNC
expr_stmt|;
comment|/* make sure CVMX_L2C_TADX_TAG is updated */
name|l2c_tadx_tag
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_TADX_TAG
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|valid
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|dirty
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|lock
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|use
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|l2c_tadx_tag
operator|.
name|s
operator|.
name|tag
expr_stmt|;
block|}
else|else
block|{
name|union
name|__cvmx_l2c_tag
name|tmp_tag
decl_stmt|;
comment|/* __read_l2_tag is intended for internal use only */
name|tmp_tag
operator|=
name|__read_l2_tag
argument_list|(
name|association
argument_list|,
name|index
argument_list|)
expr_stmt|;
comment|/*          * Convert all tag structure types to generic version,          * as it can represent all models.          */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn58xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn38xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn31xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn30xx
operator|.
name|addr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
name|tag
operator|.
name|s
operator|.
name|V
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|V
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|D
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|D
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|L
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|L
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|U
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|U
expr_stmt|;
name|tag
operator|.
name|s
operator|.
name|addr
operator|=
name|tmp_tag
operator|.
name|cn50xx
operator|.
name|addr
expr_stmt|;
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|tag
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvmx_l2c_address_to_tad
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|uint32_t
name|tad
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|cvmx_l2c_ctl_t
name|l2c_ctl
decl_stmt|;
name|l2c_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|l2c_ctl
operator|.
name|s
operator|.
name|disidxalias
condition|)
block|{
name|tad
operator|=
operator|(
operator|(
name|addr
operator|>>
literal|7
operator|)
operator|^
operator|(
name|addr
operator|>>
literal|12
operator|)
operator|^
operator|(
name|addr
operator|>>
literal|18
operator|)
operator|)
operator|&
literal|3
expr_stmt|;
block|}
else|else
block|{
name|tad
operator|=
operator|(
name|addr
operator|>>
literal|7
operator|)
operator|&
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
name|tad
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|tad
return|;
block|}
end_function

begin_function
name|uint32_t
name|cvmx_l2c_v2_address_to_tag
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
define|#
directive|define
name|DR0_END
value|( (256 * 1024 * 1024) -1)
define|#
directive|define
name|DR1_START
value|(512 * 1024 * 1024)
define|#
directive|define
name|L2_HOLE
value|(256 * 1024 * 1024)
if|if
condition|(
operator|(
name|addr
operator|>
name|DR0_END
operator|)
operator|&&
operator|(
name|addr
operator|<
name|DR1_START
operator|)
condition|)
return|return
call|(
name|uint32_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|addr
operator|>
name|DR1_START
condition|)
name|addr
operator|=
name|addr
operator|-
name|L2_HOLE
expr_stmt|;
name|addr
operator|=
name|addr
operator|&
literal|0x7FFFFFFFFULL
expr_stmt|;
return|return
call|(
name|uint32_t
call|)
argument_list|(
name|addr
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
argument_list|)
return|;
block|}
end_function

begin_function
name|uint32_t
name|cvmx_l2c_address_to_index
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|uint64_t
name|idx
init|=
name|addr
operator|>>
name|CVMX_L2C_IDX_ADDR_SHIFT
decl_stmt|;
name|int
name|indxalias
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|union
name|cvmx_l2c_ctl
name|l2c_ctl
decl_stmt|;
name|l2c_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CTL
argument_list|)
expr_stmt|;
name|indxalias
operator|=
operator|!
name|l2c_ctl
operator|.
name|s
operator|.
name|disidxalias
expr_stmt|;
block|}
else|else
block|{
name|union
name|cvmx_l2c_cfg
name|l2c_cfg
decl_stmt|;
name|l2c_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_CFG
argument_list|)
expr_stmt|;
name|indxalias
operator|=
name|l2c_cfg
operator|.
name|s
operator|.
name|idxalias
expr_stmt|;
block|}
if|if
condition|(
name|indxalias
condition|)
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
block|{
name|uint32_t
name|a_14_12
init|=
operator|(
name|idx
operator|/
operator|(
name|CVMX_L2C_MEMBANK_SELECT_SIZE
operator|/
operator|(
literal|1
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
operator|)
operator|)
operator|&
literal|0x7
decl_stmt|;
name|idx
operator|^=
operator|(
name|idx
operator|/
name|cvmx_l2c_get_num_sets
argument_list|()
operator|)
operator|&
literal|0x3ff
expr_stmt|;
name|idx
operator|^=
name|a_14_12
operator|&
literal|0x3
expr_stmt|;
name|idx
operator|^=
name|a_14_12
operator|<<
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|uint32_t
name|a_14_12
init|=
operator|(
name|idx
operator|/
operator|(
name|CVMX_L2C_MEMBANK_SELECT_SIZE
operator|/
operator|(
literal|1
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
operator|)
operator|)
operator|&
literal|0x7
decl_stmt|;
name|idx
operator|^=
name|idx
operator|/
name|cvmx_l2c_get_num_sets
argument_list|()
expr_stmt|;
name|idx
operator|^=
name|a_14_12
expr_stmt|;
block|}
else|else
block|{
name|idx
operator|^=
operator|(
operator|(
name|addr
operator|&
name|CVMX_L2C_ALIAS_MASK
operator|)
operator|>>
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
expr_stmt|;
block|}
block|}
name|idx
operator|&=
name|CVMX_L2C_IDX_MASK
expr_stmt|;
return|return
name|idx
return|;
block|}
end_function

begin_function
name|int
name|cvmx_l2c_get_cache_size_bytes
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_l2c_get_num_sets
argument_list|()
operator|*
name|cvmx_l2c_get_num_assoc
argument_list|()
operator|*
name|CVMX_CACHE_LINE_SIZE
return|;
block|}
end_function

begin_comment
comment|/**  * Return log base 2 of the number of sets in the L2 cache  * @return  */
end_comment

begin_function
name|int
name|cvmx_l2c_get_set_bits
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|l2_set_bits
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|11
expr_stmt|;
comment|/* 2048 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|10
expr_stmt|;
comment|/* 1024 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|9
expr_stmt|;
comment|/* 512 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|8
expr_stmt|;
comment|/* 256 sets */
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
name|l2_set_bits
operator|=
literal|7
expr_stmt|;
comment|/* 128 sets */
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|l2_set_bits
operator|=
literal|11
expr_stmt|;
comment|/* 2048 sets */
block|}
return|return
name|l2_set_bits
return|;
block|}
end_function

begin_comment
comment|/* Return the number of sets in the L2 Cache */
end_comment

begin_function
name|int
name|cvmx_l2c_get_num_sets
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|1
operator|<<
name|cvmx_l2c_get_set_bits
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/* Return the number of associations in the L2 Cache */
end_comment

begin_function
name|int
name|cvmx_l2c_get_num_assoc
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|l2_assoc
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|16
expr_stmt|;
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2_assoc
operator|=
literal|4
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"Unsupported OCTEON Model in %s\n"
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
name|l2_assoc
operator|=
literal|8
expr_stmt|;
block|}
comment|/* Check to see if part of the cache is disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|union
name|cvmx_mio_fus_dat3
name|mio_fus_dat3
decl_stmt|;
name|mio_fus_dat3
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_FUS_DAT3
argument_list|)
expr_stmt|;
comment|/*          * cvmx_mio_fus_dat3.s.l2c_crip fuses map as follows          *<2> will be not used for 63xx          *<1> disables 1/2 ways          *<0> disables 1/4 ways          * They are cumulative, so for 63xx:          *<1><0>          * 0 0 16-way 2MB cache          * 0 1 12-way 1.5MB cache          * 1 0 8-way 1MB cache          * 1 1 4-way 512KB cache          */
if|if
condition|(
name|mio_fus_dat3
operator|.
name|cn63xx
operator|.
name|l2c_crip
operator|==
literal|3
condition|)
name|l2_assoc
operator|=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|mio_fus_dat3
operator|.
name|cn63xx
operator|.
name|l2c_crip
operator|==
literal|2
condition|)
name|l2_assoc
operator|=
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|mio_fus_dat3
operator|.
name|cn63xx
operator|.
name|l2c_crip
operator|==
literal|1
condition|)
name|l2_assoc
operator|=
literal|12
expr_stmt|;
block|}
else|else
block|{
name|union
name|cvmx_l2d_fus3
name|val
decl_stmt|;
name|val
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2D_FUS3
argument_list|)
expr_stmt|;
comment|/*          * Using shifts here, as bit position names are          * different for each model but they all mean the          * same.          */
if|if
condition|(
operator|(
name|val
operator|.
name|u64
operator|>>
literal|35
operator|)
operator|&
literal|0x1
condition|)
name|l2_assoc
operator|=
name|l2_assoc
operator|>>
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|val
operator|.
name|u64
operator|>>
literal|34
operator|)
operator|&
literal|0x1
condition|)
name|l2_assoc
operator|=
name|l2_assoc
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|l2_assoc
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * Flush a line from the L2 cache  * This should only be called from one core at a time, as this routine  * sets the core to the 'debug' core in order to flush the line.  *  * @param assoc  Association (or way) to flush  * @param index  Index to flush  */
end_comment

begin_function
name|void
name|cvmx_l2c_flush_line
parameter_list|(
name|uint32_t
name|assoc
parameter_list|,
name|uint32_t
name|index
parameter_list|)
block|{
comment|/* Check the range of the index. */
if|if
condition|(
name|index
operator|>
operator|(
name|uint32_t
operator|)
name|cvmx_l2c_get_num_sets
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_flush_line index out of range.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Check the range of association. */
if|if
condition|(
name|assoc
operator|>
operator|(
name|uint32_t
operator|)
name|cvmx_l2c_get_num_assoc
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: cvmx_l2c_flush_line association out of range.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|uint64_t
name|address
decl_stmt|;
comment|/* Create the address based on index and association.          * Bits<20:17> select the way of the cache block involved in          *             the operation          * Bits<16:7> of the effect address select the index          */
name|address
operator|=
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
operator|(
name|assoc
operator|<<
name|CVMX_L2C_TAG_ADDR_ALIAS_SHIFT
operator|)
operator||
operator|(
name|index
operator|<<
name|CVMX_L2C_IDX_ADDR_SHIFT
operator|)
argument_list|)
expr_stmt|;
name|CVMX_CACHE_WBIL2I
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|union
name|cvmx_l2c_dbg
name|l2cdbg
decl_stmt|;
name|l2cdbg
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
condition|)
name|l2cdbg
operator|.
name|s
operator|.
name|ppnum
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|finv
operator|=
literal|1
expr_stmt|;
name|l2cdbg
operator|.
name|s
operator|.
name|set
operator|=
name|assoc
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
comment|/*          * Enter debug mode, and make sure all other writes          * complete before we enter debug mode          */
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
name|l2cdbg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|CVMX_PREPARE_FOR_STORE
argument_list|(
name|CVMX_ADD_SEG
argument_list|(
name|CVMX_MIPS_SPACE_XKPHYS
argument_list|,
name|index
operator|*
name|CVMX_CACHE_LINE_SIZE
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Exit debug mode */
name|CVMX_SYNC
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_DBG
argument_list|)
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_spinlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Initialize the BIG address in L2C+DRAM to generate proper error  * on reading/writing to an non-existant memory location.   *  * @param mem_size  Amount of DRAM configured in MB.  * @param mode      Allow/Disallow reporting errors L2C_INT_SUM[BIGRD,BIGWR].  */
end_comment

begin_function
name|void
name|cvmx_l2c_set_big_size
parameter_list|(
name|uint64_t
name|mem_size
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|if
condition|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
operator|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_l2c_big_ctl_t
name|big_ctl
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|,
name|zero_bits
init|=
literal|0
decl_stmt|;
name|uint64_t
name|mem
decl_stmt|;
if|if
condition|(
name|mem_size
operator|>
operator|(
name|CVMX_L2C_MAX_MEMSZ_ALLOWED
operator|*
literal|1024
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Invalid memory size(%lld) requested, should be<= %lld\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mem_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|CVMX_L2C_MAX_MEMSZ_ALLOWED
operator|*
literal|1024
argument_list|)
expr_stmt|;
name|mem_size
operator|=
name|CVMX_L2C_MAX_MEMSZ_ALLOWED
operator|*
literal|1024
expr_stmt|;
block|}
name|mem
operator|=
name|mem_size
expr_stmt|;
while|while
condition|(
name|mem
condition|)
block|{
if|if
condition|(
operator|(
name|mem
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|zero_bits
operator|++
expr_stmt|;
name|bits
operator|++
expr_stmt|;
name|mem
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bits
operator|-
name|zero_bits
operator|)
operator|!=
literal|1
operator|||
operator|(
name|bits
operator|-
literal|9
operator|)
operator|<=
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Invalid DRAM size (%lld) requested, refer to L2C_BIG_CTL[maxdram] for valid options.\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|mem_size
argument_list|)
expr_stmt|;
return|return;
block|}
name|big_ctl
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|big_ctl
operator|.
name|s
operator|.
name|maxdram
operator|=
name|bits
operator|-
literal|9
expr_stmt|;
name|big_ctl
operator|.
name|s
operator|.
name|disable
operator|=
name|mode
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_BIG_CTL
argument_list|,
name|big_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
end_if

begin_comment
comment|/* L2C Virtualization APIs. These APIs are based on Octeon II documentation. */
end_comment

begin_comment
comment|/*  * These could be used by the Linux kernel, but currently are not, so  * disable them to save space.  */
end_comment

begin_comment
comment|/**  * @INTERNAL  * Helper function to decode VALUE to number of allowed virtualization IDS.  * Returns L2C_VRT_CTL[NUMID].  *  * @param nvid     Number of virtual Ids.  * @return         On success decode to NUMID, or to -1 on failure.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_l2c_vrt_decode_numid
parameter_list|(
name|int
name|nvid
parameter_list|)
block|{
name|int
name|bits
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|zero_bits
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|nvid
operator|<
literal|1
operator|||
name|nvid
operator|>
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Invalid number of virtual ids(%d) requested, should be<= 64\n"
argument_list|,
name|nvid
argument_list|)
expr_stmt|;
return|return
name|bits
return|;
block|}
while|while
condition|(
name|nvid
condition|)
block|{
if|if
condition|(
operator|(
name|nvid
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|zero_bits
operator|++
expr_stmt|;
name|bits
operator|++
expr_stmt|;
name|nvid
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|==
literal|1
operator|||
operator|(
name|zero_bits
operator|&&
operator|(
operator|(
name|bits
operator|-
name|zero_bits
operator|)
operator|==
literal|1
operator|)
operator|)
condition|)
return|return
name|zero_bits
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Set maxium number of Virtual IDs allowed in a machine.  *  * @param nvid   Number of virtial ids allowed in a machine.  * @return       Return 0 on success or -1 on failure.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_set_max_virtids
parameter_list|(
name|int
name|nvid
parameter_list|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Changing number of Virtual Machine IDs is not allowed after Virtualization is enabled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|nvid
operator|<
literal|1
operator|||
name|nvid
operator|>
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_max_virtids: Invalid number of Virtual Machine IDs(%d) requested, max allowed %d\n"
argument_list|,
name|nvid
argument_list|,
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Calculate the numid based on nvid */
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
operator|=
name|__cvmx_l2c_vrt_decode_numid
argument_list|(
name|nvid
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get maxium number of virtual IDs allowed in a machine.  *  * @return  Return number of virtual machine IDs or -1 on failure.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_get_max_virtids
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|virtids
decl_stmt|;
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|virtids
operator|=
literal|1
operator|<<
operator|(
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|virtids
operator|>
name|CVMX_L2C_VRT_MAX_VIRTID_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_get_max_virtids: Invalid number of Virtual IDs initialized (%d)\n"
argument_list|,
name|virtids
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|virtids
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Helper function to decode VALUE to memory space coverage of L2C_VRT_MEM.  * Returns L2C_VRT_CTL[MEMSZ].  *  * @param memsz    Memory in GB.  * @return         On success, decode to MEMSZ, or on failure return -1.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|__cvmx_l2c_vrt_decode_memsize
parameter_list|(
name|int
name|memsz
parameter_list|)
block|{
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|int
name|zero_bits
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|memsz
operator|==
literal|0
operator|||
name|memsz
operator|>
name|CVMX_L2C_MAX_MEMSZ_ALLOWED
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: Invalid virtual memory size(%d) requested, should be<= %d\n"
argument_list|,
name|memsz
argument_list|,
name|CVMX_L2C_MAX_MEMSZ_ALLOWED
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|memsz
condition|)
block|{
if|if
condition|(
operator|(
name|memsz
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|zero_bits
operator|++
expr_stmt|;
name|bits
operator|++
expr_stmt|;
name|memsz
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bits
operator|==
literal|1
operator|||
operator|(
name|bits
operator|-
name|zero_bits
operator|)
operator|==
literal|1
condition|)
return|return
name|zero_bits
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Set the maxium size of memory space to be allocated for virtualization.  *  * @param memsz  Size of the virtual memory in GB  * @return       Return 0 on success or -1 on failure.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_set_max_memsz
parameter_list|(
name|int
name|memsz
parameter_list|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|int
name|decode
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_memsz: Changing the size of the memory after Virtualization is enabled is not allowed.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|memsz
operator|>=
call|(
name|int
call|)
argument_list|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|system_dram_size
operator|/
literal|1000000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_memsz: Invalid memory size (%d GB), greater than available on the chip\n"
argument_list|,
name|memsz
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|decode
operator|=
name|__cvmx_l2c_vrt_decode_memsize
argument_list|(
name|memsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|decode
operator|==
operator|-
literal|1
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_set_memsz: Invalid memory size (%d GB), refer to L2C_VRT_CTL[MEMSZ] for more information\n"
argument_list|,
name|memsz
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|memsz
operator|=
name|decode
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Set a Virtual ID to a set of cores.  *  * @param virtid    Assign virtid to a set of cores.  * @param coremask  The group of cores to assign a unique virtual id.  * @return          Return 0 on success, otherwise -1.  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_assign_virtid
parameter_list|(
name|int
name|virtid
parameter_list|,
name|uint32_t
name|coremask
parameter_list|)
block|{
name|uint32_t
name|core
init|=
literal|0
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|;
name|int
name|max_virtid
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|max_virtid
operator|=
name|cvmx_l2c_vrt_get_max_virtids
argument_list|()
expr_stmt|;
if|if
condition|(
name|virtid
operator|>
name|max_virtid
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_assign_virt_id: Max %d number of virtids are allowed, passed %d.\n"
argument_list|,
name|max_virtid
argument_list|,
name|virtid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
while|while
condition|(
name|core
operator|<
name|cvmx_octeon_num_cores
argument_list|()
condition|)
block|{
if|if
condition|(
operator|(
name|coremask
operator|>>
name|core
operator|)
operator|&
literal|1
condition|)
block|{
name|cvmx_l2c_virtid_ppx_t
name|l2c_virtid_ppx
decl_stmt|;
name|cvmx_l2c_virtid_iobx_t
name|l2c_virtid_iobx
decl_stmt|;
name|l2c_virtid_ppx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check if the core already has a virtid assigned. */
if|if
condition|(
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_assign_virt_id: Changing virtid of core #%d to %d from %d.\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|core
argument_list|,
name|virtid
argument_list|,
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
argument_list|)
expr_stmt|;
comment|/* Flush L2 cache to avoid write errors */
name|cvmx_l2c_flush
argument_list|()
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|,
name|virtid
operator|&
literal|0x3f
argument_list|)
expr_stmt|;
comment|/* Set the IOB to normal mode. */
name|l2c_virtid_iobx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_IOBX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
name|l2c_virtid_iobx
operator|.
name|s
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|l2c_virtid_iobx
operator|.
name|s
operator|.
name|dwbid
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VIRTID_IOBX
argument_list|(
name|core
argument_list|)
argument_list|,
name|l2c_virtid_iobx
operator|.
name|u64
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|core
operator|++
expr_stmt|;
block|}
comment|/* Invalid coremask passed. */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_assign_virt_id: Invalid coremask(0x%x) passed\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|coremask
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Remove a virt id assigned to a set of cores. Update the virtid mask and  * virtid stored for each core.  *  * @param virtid  Remove the specified Virtualization machine ID.  */
end_comment

begin_function
name|void
name|cvmx_l2c_vrt_remove_virtid
parameter_list|(
name|int
name|virtid
parameter_list|)
block|{
name|uint32_t
name|core
decl_stmt|;
name|cvmx_l2c_virtid_ppx_t
name|l2c_virtid_ppx
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return;
for|for
control|(
name|core
operator|=
literal|0
init|;
name|core
operator|<
name|cvmx_octeon_num_cores
argument_list|()
condition|;
name|core
operator|++
control|)
block|{
name|l2c_virtid_ppx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|virtid
operator|==
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Helper function to protect the memory region based on the granularity.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|__cvmx_l2c_vrt_get_granularity
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|gran
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
block|{
name|int
name|nvid
decl_stmt|;
name|uint64_t
name|szd
decl_stmt|;
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|nvid
operator|=
name|cvmx_l2c_vrt_get_max_virtids
argument_list|()
expr_stmt|;
name|szd
operator|=
operator|(
literal|1ull
operator|<<
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|memsz
operator|)
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
name|gran
operator|=
call|(
name|unsigned
name|long
name|long
call|)
argument_list|(
name|szd
operator|*
name|nvid
argument_list|)
operator|/
operator|(
literal|32ull
operator|*
literal|1024
operator|)
expr_stmt|;
block|}
return|return
name|gran
return|;
block|}
end_function

begin_decl_stmt
name|CVMX_SHARED
name|cvmx_spinlock_t
name|cvmx_l2c_vrt_spinlock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Block a memory region to be updated for a given virtual id.  *  * @param start_addr   Starting address of memory region  * @param size         Size of the memory to protect  * @param virtid       Virtual ID to use  * @param mode         Allow/Disallow write access  *                        = 0,  Allow write access by virtid  *                        = 1,  Disallow write access by virtid  */
end_comment

begin_function
name|int
name|cvmx_l2c_vrt_memprotect
parameter_list|(
name|uint64_t
name|start_addr
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|virtid
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|uint64_t
name|gran
decl_stmt|;
name|uint64_t
name|end_addr
decl_stmt|;
name|int
name|byte_offset
decl_stmt|,
name|virtid_offset
decl_stmt|;
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
name|cvmx_l2c_vrt_memx_t
name|l2c_vrt_mem
decl_stmt|;
name|cvmx_l2c_virtid_ppx_t
name|l2c_virtid_ppx
decl_stmt|;
name|int
name|found
decl_stmt|;
name|uint32_t
name|core
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/*      * Check the alignment of start address, should be aligned to the      * granularity.      */
name|gran
operator|=
name|__cvmx_l2c_vrt_get_granularity
argument_list|()
expr_stmt|;
name|end_addr
operator|=
name|start_addr
operator|+
name|size
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
comment|/* No need to protect if virtualization is not enabled */
if|if
condition|(
operator|!
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Virtualization is not enabled.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|virtid
operator|>
name|cvmx_l2c_vrt_get_max_virtids
argument_list|()
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Virtualization id is greater than max allowed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* No need to protect if virtid is not assigned to a core */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|core
operator|=
literal|0
init|;
name|core
operator|<
name|cvmx_octeon_num_cores
argument_list|()
condition|;
name|core
operator|++
control|)
block|{
name|l2c_virtid_ppx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VIRTID_PPX
argument_list|(
name|core
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|l2c_virtid_ppx
operator|.
name|s
operator|.
name|id
operator|==
name|virtid
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Virtualization id (%d) is not assigned to any core.\n"
argument_list|,
name|virtid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Make sure previous stores are through before protecting the      * memory.      */
name|CVMX_SYNCW
expr_stmt|;
comment|/*      * If the L2/DRAM physical address is>= 512 MB, subtract 256      * MB to get the address to use. This is because L2C removes      * the 256MB "hole" between DR0 and DR1.      */
if|if
condition|(
name|start_addr
operator|>=
operator|(
literal|512
operator|*
literal|1024
operator|*
literal|1024
operator|)
condition|)
name|start_addr
operator|-=
literal|256
operator|*
literal|1024
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|start_addr
operator|!=
operator|(
operator|(
name|start_addr
operator|+
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"WARNING: cvmx_l2c_vrt_memprotect: Start address is not aligned\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*      * Check the size of the memory to protect, should be aligned      * to the granularity.      */
if|if
condition|(
name|end_addr
operator|!=
operator|(
operator|(
name|end_addr
operator|+
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|end_addr
operator|=
operator|(
name|start_addr
operator|+
operator|(
name|gran
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|gran
operator|-
literal|1
operator|)
expr_stmt|;
name|size
operator|=
name|start_addr
operator|-
name|end_addr
expr_stmt|;
block|}
name|byte_offset
operator|=
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|memsz
operator|+
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
operator|+
literal|16
expr_stmt|;
name|virtid_offset
operator|=
literal|14
operator|-
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|numid
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|&
name|cvmx_l2c_vrt_spinlock
argument_list|)
expr_stmt|;
comment|/* Enable memory protection for each virtid for the specified range. */
while|while
condition|(
name|start_addr
operator|<
name|end_addr
condition|)
block|{
comment|/*          * When L2C virtualization is enabled and a bit is set          * in L2C_VRT_MEM(0..1023), then L2C prevents the          * selected virtual machine from storing to the          * selected L2C/DRAM region.          */
name|int
name|offset
decl_stmt|,
name|position
decl_stmt|,
name|i
decl_stmt|;
name|int
name|l2c_vrt_mem_bit_index
init|=
name|start_addr
operator|>>
name|byte_offset
decl_stmt|;
name|l2c_vrt_mem_bit_index
operator||=
operator|(
name|virtid
operator|<<
name|virtid_offset
operator|)
expr_stmt|;
name|offset
operator|=
name|l2c_vrt_mem_bit_index
operator|>>
literal|5
expr_stmt|;
name|position
operator|=
name|l2c_vrt_mem_bit_index
operator|&
literal|0x1f
expr_stmt|;
name|l2c_vrt_mem
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_MEMX
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allow/Disallow write access to memory. */
if|if
condition|(
name|mode
operator|==
literal|0
condition|)
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|data
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|position
operator|)
expr_stmt|;
else|else
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|data
operator||=
literal|1
operator|<<
name|position
expr_stmt|;
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|parity
operator|=
literal|0
expr_stmt|;
comment|/* PARITY<i> is the even parity of DATA<i*8+7:i*8>, which means          * that each bit<i> in PARITY[0..3], is the XOR of all the bits          * in the corresponding byte in DATA.          */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|mask
init|=
literal|0xffull
operator|<<
operator|(
name|i
operator|*
literal|8
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|cvmx_pop
argument_list|(
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|data
operator|&
name|mask
argument_list|)
operator|&
literal|0x1
operator|)
condition|)
name|l2c_vrt_mem
operator|.
name|s
operator|.
name|parity
operator||=
operator|(
literal|1ull
operator|<<
name|i
operator|)
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_MEMX
argument_list|(
name|offset
argument_list|)
argument_list|,
name|l2c_vrt_mem
operator|.
name|u64
argument_list|)
expr_stmt|;
name|start_addr
operator|+=
name|gran
expr_stmt|;
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|&
name|cvmx_l2c_vrt_spinlock
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Enable virtualization.  *  * @param mode   Whether out of bound writes are an error.  */
end_comment

begin_function
name|void
name|cvmx_l2c_vrt_enable
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return;
comment|/* Enable global virtualization */
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|ooberr
operator|=
name|mode
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Disable virtualization.  */
end_comment

begin_function
name|void
name|cvmx_l2c_vrt_disable
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_l2c_vrt_ctl_t
name|l2c_vrt_ctl
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
condition|)
return|return;
comment|/* Disable global virtualization */
name|l2c_vrt_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|)
expr_stmt|;
name|l2c_vrt_ctl
operator|.
name|s
operator|.
name|enable
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_L2C_VRT_CTL
argument_list|,
name|l2c_vrt_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

