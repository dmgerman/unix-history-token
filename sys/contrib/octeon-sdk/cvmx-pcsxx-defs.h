begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pcsxx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pcsxx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PCSXX_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PCSXX_DEFS_H__
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_10GBX_STATUS_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000828ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000828ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000828ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_10GBX_STATUS_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000828ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_BIST_STATUS_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000870ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000870ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000870ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_BIST_STATUS_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000870ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_BIT_LOCK_STATUS_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000850ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000850ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000850ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_BIT_LOCK_STATUS_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000850ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_CONTROL1_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000800ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000800ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000800ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_CONTROL1_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000800ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_CONTROL2_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000818ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000818ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000818ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_CONTROL2_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000818ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_INT_EN_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000860ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000860ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000860ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_INT_EN_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000860ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_INT_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000858ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000858ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000858ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_INT_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000858ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_LOG_ANL_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000868ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000868ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000868ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_LOG_ANL_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000868ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_MISC_CTL_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000848ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000848ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000848ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_MISC_CTL_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000848ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_RX_SYNC_STATES_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000838ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000838ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000838ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_RX_SYNC_STATES_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000838ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_SPD_ABIL_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000810ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000810ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000810ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_SPD_ABIL_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000810ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_STATUS1_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000808ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000808ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000808ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_STATUS1_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000808ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_STATUS2_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000820ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000820ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000820ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_STATUS2_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000820ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_TX_RX_POLARITY_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000840ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000840ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000840ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_TX_RX_POLARITY_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000840ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PCSXX_TX_RX_STATES_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_get_octeon_family
argument_list|()
condition|)
block|{
case|case
name|OCTEON_CN56XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN66XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN61XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000830ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN52XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
case|case
name|OCTEON_CN63XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|==
literal|0
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000830ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|0
operator|)
operator|*
literal|0x8000000ull
return|;
break|break;
case|case
name|OCTEON_CN68XX
operator|&
name|OCTEON_FAMILY_MASK
case|:
if|if
condition|(
operator|(
name|block_id
operator|<=
literal|4
operator|)
condition|)
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000830ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
break|break;
block|}
name|cvmx_warn
argument_list|(
literal|"CVMX_PCSXX_TX_RX_STATES_REG (block_id = %lu) not supported on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000830ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|7
operator|)
operator|*
literal|0x1000000ull
return|;
block|}
end_function

begin_comment
comment|/**  * cvmx_pcsx#_10gbx_status_reg  *  * PCSX_10GBX_STATUS_REG = 10gbx_status_reg  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_10gbx_status_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_10gbx_status_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|alignd
range|:
literal|1
decl_stmt|;
comment|/**< 1=Lane alignment achieved, 0=Lanes not aligned */
name|uint64_t
name|pattst
range|:
literal|1
decl_stmt|;
comment|/**< Always at 0, no pattern testing capability */
name|uint64_t
name|reserved_4_10
range|:
literal|7
decl_stmt|;
name|uint64_t
name|l3sync
range|:
literal|1
decl_stmt|;
comment|/**< 1=Rcv lane 3 code grp synchronized, 0=not sync'ed */
name|uint64_t
name|l2sync
range|:
literal|1
decl_stmt|;
comment|/**< 1=Rcv lane 2 code grp synchronized, 0=not sync'ed */
name|uint64_t
name|l1sync
range|:
literal|1
decl_stmt|;
comment|/**< 1=Rcv lane 1 code grp synchronized, 0=not sync'ed */
name|uint64_t
name|l0sync
range|:
literal|1
decl_stmt|;
comment|/**< 1=Rcv lane 0 code grp synchronized, 0=not sync'ed */
else|#
directive|else
name|uint64_t
name|l0sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l1sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l3sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_10
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pattst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|alignd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_10gbx_status_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_10gbx_status_reg
name|cvmx_pcsxx_10gbx_status_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_bist_status_reg  *  * NOTE: Logic Analyzer is enabled with LA_EN for xaui only. PKT_SZ is effective only when LA_EN=1  * For normal operation(xaui), this bit must be 0. The dropped lane is used to send rxc[3:0].  * See pcs.csr  for sgmii/1000Base-X logic analyzer mode.  * For full description see document at .../rtl/pcs/readme_logic_analyzer.txt  *  *  *  PCSX Bist Status Register  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_bist_status_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_bist_status_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|bist_status
range|:
literal|1
decl_stmt|;
comment|/**< 1=bist failure, 0=bisted memory ok or bist in progress                                                          pcsx.tx_sm.drf8x36m1_async_bist */
else|#
directive|else
name|uint64_t
name|bist_status
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bist_status_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_bist_status_reg
name|cvmx_pcsxx_bist_status_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_bit_lock_status_reg  *  * LN_SWAP for XAUI is to simplify interconnection layout between devices  *  *  * PCSX Bit Lock Status Register  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_bit_lock_status_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|bitlck3
range|:
literal|1
decl_stmt|;
comment|/**< Receive Lane 3 bit lock status */
name|uint64_t
name|bitlck2
range|:
literal|1
decl_stmt|;
comment|/**< Receive Lane 2 bit lock status */
name|uint64_t
name|bitlck1
range|:
literal|1
decl_stmt|;
comment|/**< Receive Lane 1 bit lock status */
name|uint64_t
name|bitlck0
range|:
literal|1
decl_stmt|;
comment|/**< Receive Lane 0 bit lock status */
else|#
directive|else
name|uint64_t
name|bitlck0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlck1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlck2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlck3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_bit_lock_status_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_bit_lock_status_reg
name|cvmx_pcsxx_bit_lock_status_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_control1_reg  *  * NOTE: Logic Analyzer is enabled with LA_EN for the specified PCS lane only. PKT_SZ is effective only when LA_EN=1  * For normal operation(sgmii or 1000Base-X), this bit must be 0.  * See pcsx.csr for xaui logic analyzer mode.  * For full description see document at .../rtl/pcs/readme_logic_analyzer.txt  *  *  *  PCSX regs follow IEEE Std 802.3-2005, Section: 45.2.3  *  *  *  PCSX_CONTROL1_REG = Control Register1  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_control1_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_control1_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< 1=SW PCSX Reset, the bit will return to 0 after pcs                                                          has been reset. Takes 32 eclk cycles to reset pcs                                                          0=Normal operation */
name|uint64_t
name|loopbck1
range|:
literal|1
decl_stmt|;
comment|/**< 0=normal operation, 1=internal loopback mode                                                          xgmii tx data received from gmx tx port is returned                                                          back into gmx, xgmii rx port. */
name|uint64_t
name|spdsel1
range|:
literal|1
decl_stmt|;
comment|/**< See bit 6 description */
name|uint64_t
name|reserved_12_12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lo_pwr
range|:
literal|1
decl_stmt|;
comment|/**< 1=Power Down(HW reset), 0=Normal operation */
name|uint64_t
name|reserved_7_10
range|:
literal|4
decl_stmt|;
name|uint64_t
name|spdsel0
range|:
literal|1
decl_stmt|;
comment|/**< SPDSEL1 and SPDSEL0 are always at 1'b1. Write has                                                          no effect.                                                          [<6>,<13>]Link Speed selection                                                            1    1   Bits 5:2 select speed */
name|uint64_t
name|spd
range|:
literal|4
decl_stmt|;
comment|/**< Always select 10Gb/s, writes have no effect */
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|spdsel0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_10
range|:
literal|4
decl_stmt|;
name|uint64_t
name|lo_pwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|spdsel1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loopbck1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control1_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_control1_reg
name|cvmx_pcsxx_control1_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_control2_reg  *  * PCSX_CONTROL2_REG = Control Register2  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_control2_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_control2_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< Always 2'b01, 10GBASE-X only supported */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_control2_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_control2_reg
name|cvmx_pcsxx_control2_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_int_en_reg  *  * Note: DBG_SYNC is a edge triggered interrupt. When set it indicates PCS Synchronization state machine in  *       Figure 48-7 state diagram in IEEE Std 802.3-2005 changes state SYNC_ACQUIRED_1 to SYNC_ACQUIRED_2  *       indicating an invalid code group was received on one of the 4 receive lanes.  *       This interrupt should be always disabled and used only for link problem debugging help.  *  *  * PCSX Interrupt Enable Register  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_int_en_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_int_en_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|dbg_sync_en
range|:
literal|1
decl_stmt|;
comment|/**< Code Group sync failure debug help */
name|uint64_t
name|algnlos_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable ALGNLOS interrupt */
name|uint64_t
name|synlos_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable SYNLOS interrupt */
name|uint64_t
name|bitlckls_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable BITLCKLS interrupt */
name|uint64_t
name|rxsynbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable RXSYNBAD  interrupt */
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable RXBAD  interrupt */
name|uint64_t
name|txflt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable TXFLT   interrupt */
else|#
directive|else
name|uint64_t
name|txflt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxsynbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlckls_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|synlos_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|algnlos_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbg_sync_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pcsxx_int_en_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|algnlos_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable ALGNLOS interrupt */
name|uint64_t
name|synlos_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable SYNLOS interrupt */
name|uint64_t
name|bitlckls_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable BITLCKLS interrupt */
name|uint64_t
name|rxsynbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable RXSYNBAD  interrupt */
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable RXBAD  interrupt */
name|uint64_t
name|txflt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable TXFLT   interrupt */
else|#
directive|else
name|uint64_t
name|txflt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxsynbad_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlckls_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|synlos_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|algnlos_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pcsxx_int_en_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_en_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_int_en_reg
name|cvmx_pcsxx_int_en_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_int_reg  *  * PCSX Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|dbg_sync
range|:
literal|1
decl_stmt|;
comment|/**< Code Group sync failure debug help, see Note below */
name|uint64_t
name|algnlos
range|:
literal|1
decl_stmt|;
comment|/**< Set when XAUI lanes lose alignment */
name|uint64_t
name|synlos
range|:
literal|1
decl_stmt|;
comment|/**< Set when Code group sync lost on 1 or more  lanes */
name|uint64_t
name|bitlckls
range|:
literal|1
decl_stmt|;
comment|/**< Set when Bit lock lost on 1 or more xaui lanes */
name|uint64_t
name|rxsynbad
range|:
literal|1
decl_stmt|;
comment|/**< Set when RX code grp sync st machine in bad state                                                          in one of the 4 xaui lanes */
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
comment|/**< Set when RX state machine in bad state */
name|uint64_t
name|txflt
range|:
literal|1
decl_stmt|;
comment|/**< None defined at this time, always 0x0 */
else|#
directive|else
name|uint64_t
name|txflt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxsynbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlckls
range|:
literal|1
decl_stmt|;
name|uint64_t
name|synlos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|algnlos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbg_sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pcsxx_int_reg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|algnlos
range|:
literal|1
decl_stmt|;
comment|/**< Set when XAUI lanes lose alignment */
name|uint64_t
name|synlos
range|:
literal|1
decl_stmt|;
comment|/**< Set when Code group sync lost on 1 or more  lanes */
name|uint64_t
name|bitlckls
range|:
literal|1
decl_stmt|;
comment|/**< Set when Bit lock lost on 1 or more xaui lanes */
name|uint64_t
name|rxsynbad
range|:
literal|1
decl_stmt|;
comment|/**< Set when RX code grp sync st machine in bad state                                                          in one of the 4 xaui lanes */
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
comment|/**< Set when RX state machine in bad state */
name|uint64_t
name|txflt
range|:
literal|1
decl_stmt|;
comment|/**< None defined at this time, always 0x0 */
else|#
directive|else
name|uint64_t
name|txflt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxsynbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bitlckls
range|:
literal|1
decl_stmt|;
name|uint64_t
name|synlos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|algnlos
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_pcsxx_int_reg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_int_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_int_reg
name|cvmx_pcsxx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_log_anl_reg  *  * PCSX Logic Analyzer Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_log_anl_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_log_anl_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|enc_mode
range|:
literal|1
decl_stmt|;
comment|/**< 1=send xaui encoded data, 0=send xaui raw data to GMX                                                          See .../rtl/pcs/readme_logic_analyzer.txt for details */
name|uint64_t
name|drop_ln
range|:
literal|2
decl_stmt|;
comment|/**< xaui lane# to drop from logic analyzer packets                                                          [<5>,<4>]  Drop lane \#                                                           0    0   Drop lane 0 data                                                           0    1   Drop lane 1 data                                                           1    0   Drop lane 2 data                                                           1    1   Drop lane 3 data */
name|uint64_t
name|lafifovfl
range|:
literal|1
decl_stmt|;
comment|/**< 1=logic analyser fif overflowed one or more times                                                          during packetization.                                                          Write 1 to clear this bit */
name|uint64_t
name|la_en
range|:
literal|1
decl_stmt|;
comment|/**< 1= Logic Analyzer enabled, 0=Logic Analyzer disabled */
name|uint64_t
name|pkt_sz
range|:
literal|2
decl_stmt|;
comment|/**< [<1>,<0>]  Logic Analyzer Packet Size                                                          0    0   Packet size 1k bytes                                                          0    1   Packet size 4k bytes                                                          1    0   Packet size 8k bytes                                                          1    1   Packet size 16k bytes */
else|#
directive|else
name|uint64_t
name|pkt_sz
range|:
literal|2
decl_stmt|;
name|uint64_t
name|la_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lafifovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|drop_ln
range|:
literal|2
decl_stmt|;
name|uint64_t
name|enc_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_log_anl_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_log_anl_reg
name|cvmx_pcsxx_log_anl_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_misc_ctl_reg  *  * RX lane polarity vector [3:0] = XOR_RXPLRT<9:6>  ^  [4[RXPLRT<1>]];  *  * TX lane polarity vector [3:0] = XOR_TXPLRT<5:2>  ^  [4[TXPLRT<0>]];  *  * In short keep<1:0> to 2'b00, and use<5:2> and<9:6> fields to define per lane polarities  *  *  *  * PCSX Misc Control Register  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_misc_ctl_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_misc_ctl_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|tx_swap
range|:
literal|1
decl_stmt|;
comment|/**< 0=do not swap xaui lanes going out to qlm's                                                          1=swap lanes 3<-> 0   and   2<-> 1 */
name|uint64_t
name|rx_swap
range|:
literal|1
decl_stmt|;
comment|/**< 0=do not swap xaui lanes coming in from qlm's                                                          1=swap lanes 3<-> 0   and   2<-> 1 */
name|uint64_t
name|xaui
range|:
literal|1
decl_stmt|;
comment|/**< 1=XAUI mode selected, 0=not XAUI mode selected                                                          This bit represents pi_qlm1/3_cfg[1:0] pin status */
name|uint64_t
name|gmxeno
range|:
literal|1
decl_stmt|;
comment|/**< GMX port enable override, GMX en/dis status is held                                                          during data packet reception. */
else|#
directive|else
name|uint64_t
name|gmxeno
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xaui
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_swap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_swap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_misc_ctl_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_misc_ctl_reg
name|cvmx_pcsxx_misc_ctl_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_rx_sync_states_reg  *  * PCSX_RX_SYNC_STATES_REG = Receive Sync States Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_rx_sync_states_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|sync3st
range|:
literal|4
decl_stmt|;
comment|/**< Receive lane 3 code grp sync state machine state */
name|uint64_t
name|sync2st
range|:
literal|4
decl_stmt|;
comment|/**< Receive lane 2 code grp sync state machine state */
name|uint64_t
name|sync1st
range|:
literal|4
decl_stmt|;
comment|/**< Receive lane 1 code grp sync state machine state */
name|uint64_t
name|sync0st
range|:
literal|4
decl_stmt|;
comment|/**< Receive lane 0 code grp sync state machine state */
else|#
directive|else
name|uint64_t
name|sync0st
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sync1st
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sync2st
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sync3st
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_rx_sync_states_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_rx_sync_states_reg
name|cvmx_pcsxx_rx_sync_states_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_spd_abil_reg  *  * PCSX_SPD_ABIL_REG = Speed ability register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_spd_abil_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_spd_abil_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|tenpasst
range|:
literal|1
decl_stmt|;
comment|/**< Always 0, no 10PASS-TS/2BASE-TL capability support */
name|uint64_t
name|tengb
range|:
literal|1
decl_stmt|;
comment|/**< Always 1, 10Gb/s supported */
else|#
directive|else
name|uint64_t
name|tengb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tenpasst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_spd_abil_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_spd_abil_reg
name|cvmx_pcsxx_spd_abil_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_status1_reg  *  * PCSX_STATUS1_REG = Status Register1  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_status1_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_status1_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|flt
range|:
literal|1
decl_stmt|;
comment|/**< 1=Fault condition detected, 0=No fault condition                                                          This bit is a logical OR of Status2 reg bits 11,10 */
name|uint64_t
name|reserved_3_6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rcv_lnk
range|:
literal|1
decl_stmt|;
comment|/**< 1=Receive Link up, 0=Receive Link down                                                          Latching Low version of r_10gbx_status_reg[12],                                                          Link down status continues until SW read. */
name|uint64_t
name|lpable
range|:
literal|1
decl_stmt|;
comment|/**< Always set to 1 for Low Power ablility indication */
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lpable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcv_lnk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_6
range|:
literal|4
decl_stmt|;
name|uint64_t
name|flt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status1_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_status1_reg
name|cvmx_pcsxx_status1_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_status2_reg  *  * PCSX_STATUS2_REG = Status Register2  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_status2_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_status2_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|dev
range|:
literal|2
decl_stmt|;
comment|/**< Always at 2'b10, means a Device present at the addr */
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|xmtflt
range|:
literal|1
decl_stmt|;
comment|/**< 0=No xmit fault, 1=xmit fault. Implements latching                                                          High function until SW read. */
name|uint64_t
name|rcvflt
range|:
literal|1
decl_stmt|;
comment|/**< 0=No rcv fault, 1=rcv fault. Implements latching                                                          High function until SW read */
name|uint64_t
name|reserved_3_9
range|:
literal|7
decl_stmt|;
name|uint64_t
name|tengb_w
range|:
literal|1
decl_stmt|;
comment|/**< Always 0, no 10GBASE-W capability */
name|uint64_t
name|tengb_x
range|:
literal|1
decl_stmt|;
comment|/**< Always 1, 10GBASE-X capable */
name|uint64_t
name|tengb_r
range|:
literal|1
decl_stmt|;
comment|/**< Always 0, no 10GBASE-R capability */
else|#
directive|else
name|uint64_t
name|tengb_r
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tengb_x
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tengb_w
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_9
range|:
literal|7
decl_stmt|;
name|uint64_t
name|rcvflt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmtflt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dev
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_status2_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_status2_reg
name|cvmx_pcsxx_status2_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_tx_rx_polarity_reg  *  * PCSX_POLARITY_REG = TX_RX polarity reg  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_tx_rx_polarity_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|xor_rxplrt
range|:
literal|4
decl_stmt|;
comment|/**< Per lane RX polarity control */
name|uint64_t
name|xor_txplrt
range|:
literal|4
decl_stmt|;
comment|/**< Per lane TX polarity control */
name|uint64_t
name|rxplrt
range|:
literal|1
decl_stmt|;
comment|/**< 1 is inverted polarity, 0 is normal polarity */
name|uint64_t
name|txplrt
range|:
literal|1
decl_stmt|;
comment|/**< 1 is inverted polarity, 0 is normal polarity */
else|#
directive|else
name|uint64_t
name|txplrt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxplrt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xor_txplrt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xor_rxplrt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|rxplrt
range|:
literal|1
decl_stmt|;
comment|/**< 1 is inverted polarity, 0 is normal polarity */
name|uint64_t
name|txplrt
range|:
literal|1
decl_stmt|;
comment|/**< 1 is inverted polarity, 0 is normal polarity */
else|#
directive|else
name|uint64_t
name|txplrt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxplrt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_cn52xxp1
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_polarity_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_tx_rx_polarity_reg
name|cvmx_pcsxx_tx_rx_polarity_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pcsx#_tx_rx_states_reg  *  * PCSX_TX_RX_STATES_REG = Transmit Receive States Register  *  */
end_comment

begin_union
union|union
name|cvmx_pcsxx_tx_rx_states_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|term_err
range|:
literal|1
decl_stmt|;
comment|/**< 1=Check end function detected error in packet                                                          terminate ||T|| column or the one after it */
name|uint64_t
name|syn3bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 3 code grp sync state machine in bad state */
name|uint64_t
name|syn2bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 2 code grp sync state machine in bad state */
name|uint64_t
name|syn1bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 1 code grp sync state machine in bad state */
name|uint64_t
name|syn0bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 0 code grp sync state machine in bad state */
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
comment|/**< 1=Rcv state machine in a bad state, HW malfunction */
name|uint64_t
name|algn_st
range|:
literal|3
decl_stmt|;
comment|/**< Lane alignment state machine state state */
name|uint64_t
name|rx_st
range|:
literal|2
decl_stmt|;
comment|/**< Receive state machine state state */
name|uint64_t
name|tx_st
range|:
literal|3
decl_stmt|;
comment|/**< Transmit state machine state state */
else|#
directive|else
name|uint64_t
name|tx_st
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rx_st
range|:
literal|2
decl_stmt|;
name|uint64_t
name|algn_st
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn0bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn1bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn2bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn3bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|term_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_pcsxx_tx_rx_states_reg_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|syn3bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 3 code grp sync state machine in bad state */
name|uint64_t
name|syn2bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 2 code grp sync state machine in bad state */
name|uint64_t
name|syn1bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 1 code grp sync state machine in bad state */
name|uint64_t
name|syn0bad
range|:
literal|1
decl_stmt|;
comment|/**< 1=lane 0 code grp sync state machine in bad state */
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
comment|/**< 1=Rcv state machine in a bad state, HW malfunction */
name|uint64_t
name|algn_st
range|:
literal|3
decl_stmt|;
comment|/**< Lane alignment state machine state state */
name|uint64_t
name|rx_st
range|:
literal|2
decl_stmt|;
comment|/**< Receive state machine state state */
name|uint64_t
name|tx_st
range|:
literal|3
decl_stmt|;
comment|/**< Transmit state machine state state */
else|#
directive|else
name|uint64_t
name|tx_st
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rx_st
range|:
literal|2
decl_stmt|;
name|uint64_t
name|algn_st
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rxbad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn0bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn1bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn2bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|syn3bad
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_cn52xxp1
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_pcsxx_tx_rx_states_reg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pcsxx_tx_rx_states_reg
name|cvmx_pcsxx_tx_rx_states_reg_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

