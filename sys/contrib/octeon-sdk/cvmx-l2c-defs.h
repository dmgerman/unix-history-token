begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-l2c-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon l2c.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_L2C_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_L2C_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_BIG_CTL
value|CVMX_L2C_BIG_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BIG_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BIG_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BIG_CTL
value|(CVMX_ADD_IO_SEG(0x0001180080800030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_BST
value|CVMX_L2C_BST_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808007F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST
value|(CVMX_ADD_IO_SEG(0x00011800808007F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_BST0
value|CVMX_L2C_BST0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST0
value|(CVMX_ADD_IO_SEG(0x00011800800007F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_BST1
value|CVMX_L2C_BST1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST1
value|(CVMX_ADD_IO_SEG(0x00011800800007F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_BST2
value|CVMX_L2C_BST2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800007E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST2
value|(CVMX_ADD_IO_SEG(0x00011800800007E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST_MEMX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST_MEMX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080C007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST_MEMX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080C007F8ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST_TDTX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST_TDTX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A007F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST_TDTX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A007F0ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_BST_TTGX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_BST_TTGX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A007F8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_BST_TTGX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A007F8ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_CFG
value|CVMX_L2C_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_CFG
value|(CVMX_ADD_IO_SEG(0x0001180080000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_COP0_MAPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16128
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|16383
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1535
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16128
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|16383
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2559
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16128
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|16383
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8191
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16128
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|16383
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|||
operator|(
operator|(
name|offset
operator|>=
literal|16128
operator|)
operator|&&
operator|(
name|offset
operator|<=
literal|16383
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_COP0_MAPX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080940000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|16383
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_COP0_MAPX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080940000ull) + ((offset)& 16383) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_CTL
value|CVMX_L2C_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_CTL
value|(CVMX_ADD_IO_SEG(0x0001180080800000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_DBG
value|CVMX_L2C_DBG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_DBG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_DBG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_DBG
value|(CVMX_ADD_IO_SEG(0x0001180080000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_DUT
value|CVMX_L2C_DUT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_DUT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_DUT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000050ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_DUT
value|(CVMX_ADD_IO_SEG(0x0001180080000050ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_DUT_MAPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1535
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2559
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|8191
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_DUT_MAPX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080E00000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|8191
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_DUT_MAPX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080E00000ull) + ((offset)& 8191) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_ERR_TDTX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_ERR_TDTX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A007E0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_ERR_TDTX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A007E0ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_ERR_TTGX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_ERR_TTGX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A007E8ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_ERR_TTGX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A007E8ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_ERR_VBFX
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_ERR_VBFX(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080C007F0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_ERR_VBFX
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080C007F0ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_ERR_XMC
value|CVMX_L2C_ERR_XMC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_ERR_XMC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_ERR_XMC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808007D8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_ERR_XMC
value|(CVMX_ADD_IO_SEG(0x00011800808007D8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_GRPWRR0
value|CVMX_L2C_GRPWRR0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_GRPWRR0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_GRPWRR0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000C8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_GRPWRR0
value|(CVMX_ADD_IO_SEG(0x00011800800000C8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_GRPWRR1
value|CVMX_L2C_GRPWRR1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_GRPWRR1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_GRPWRR1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000D0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_GRPWRR1
value|(CVMX_ADD_IO_SEG(0x00011800800000D0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_INT_EN
value|CVMX_L2C_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000100ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001180080000100ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_INT_ENA
value|CVMX_L2C_INT_ENA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_INT_ENA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_INT_ENA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_INT_ENA
value|(CVMX_ADD_IO_SEG(0x0001180080800020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_INT_REG
value|CVMX_L2C_INT_REG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_INT_REG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_INT_REG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_INT_REG
value|(CVMX_ADD_IO_SEG(0x0001180080800018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_INT_STAT
value|CVMX_L2C_INT_STAT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_INT_STAT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_INT_STAT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000F8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_INT_STAT
value|(CVMX_ADD_IO_SEG(0x00011800800000F8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_IOCX_PFC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_IOCX_PFC(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800420ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_IOCX_PFC
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080800420ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_IORX_PFC
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_IORX_PFC(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800428ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_IORX_PFC
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080800428ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_LCKBASE
value|CVMX_L2C_LCKBASE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_LCKBASE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_LCKBASE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_LCKBASE
value|(CVMX_ADD_IO_SEG(0x0001180080000058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_LCKOFF
value|CVMX_L2C_LCKOFF_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_LCKOFF_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_LCKOFF not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_LCKOFF
value|(CVMX_ADD_IO_SEG(0x0001180080000060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_LFB0
value|CVMX_L2C_LFB0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_LFB0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_LFB0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_LFB0
value|(CVMX_ADD_IO_SEG(0x0001180080000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_LFB1
value|CVMX_L2C_LFB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_LFB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_LFB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000040ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_LFB1
value|(CVMX_ADD_IO_SEG(0x0001180080000040ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_LFB2
value|CVMX_L2C_LFB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_LFB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_LFB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000048ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_LFB2
value|(CVMX_ADD_IO_SEG(0x0001180080000048ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_LFB3
value|CVMX_L2C_LFB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_LFB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_LFB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_LFB3
value|(CVMX_ADD_IO_SEG(0x00011800800000B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_OOB
value|CVMX_L2C_OOB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_OOB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_OOB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000D8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_OOB
value|(CVMX_ADD_IO_SEG(0x00011800800000D8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_OOB1
value|CVMX_L2C_OOB1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_OOB1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_OOB1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_OOB1
value|(CVMX_ADD_IO_SEG(0x00011800800000E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_OOB2
value|CVMX_L2C_OOB2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_OOB2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_OOB2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_OOB2
value|(CVMX_ADD_IO_SEG(0x00011800800000E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_OOB3
value|CVMX_L2C_OOB3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_OOB3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_OOB3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_OOB3
value|(CVMX_ADD_IO_SEG(0x00011800800000F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_L2C_PFC0
value|CVMX_L2C_PFCX(0)
end_define

begin_define
define|#
directive|define
name|CVMX_L2C_PFC1
value|CVMX_L2C_PFCX(1)
end_define

begin_define
define|#
directive|define
name|CVMX_L2C_PFC2
value|CVMX_L2C_PFCX(2)
end_define

begin_define
define|#
directive|define
name|CVMX_L2C_PFC3
value|CVMX_L2C_PFCX(3)
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_PFCTL
value|CVMX_L2C_PFCTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_PFCTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_PFCTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_PFCTL
value|(CVMX_ADD_IO_SEG(0x0001180080000090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_PFCX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_PFCX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000098ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_PFCX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080000098ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_PPGRP
value|CVMX_L2C_PPGRP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_PPGRP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_PPGRP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800800000C0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_PPGRP
value|(CVMX_ADD_IO_SEG(0x00011800800000C0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_QOS_IOBX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_QOS_IOBX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080880200ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_QOS_IOBX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080880200ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_QOS_PPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|9
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_QOS_PPX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080880000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_QOS_PPX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080880000ull) + ((offset)& 31) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_QOS_WGT
value|CVMX_L2C_QOS_WGT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_QOS_WGT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_QOS_WGT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_QOS_WGT
value|(CVMX_ADD_IO_SEG(0x0001180080800008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_RSCX_PFC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_RSCX_PFC(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800410ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|64
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_RSCX_PFC
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080800410ull) + ((offset)& 3) * 64)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_RSDX_PFC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_RSDX_PFC(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800418ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|64
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_RSDX_PFC
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080800418ull) + ((offset)& 3) * 64)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR0
value|CVMX_L2C_SPAR0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_SPAR0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_SPAR0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000068ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR0
value|(CVMX_ADD_IO_SEG(0x0001180080000068ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR1
value|CVMX_L2C_SPAR1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_SPAR1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_SPAR1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000070ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR1
value|(CVMX_ADD_IO_SEG(0x0001180080000070ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR2
value|CVMX_L2C_SPAR2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_SPAR2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_SPAR2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000078ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR2
value|(CVMX_ADD_IO_SEG(0x0001180080000078ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR3
value|CVMX_L2C_SPAR3_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_SPAR3_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_SPAR3 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR3
value|(CVMX_ADD_IO_SEG(0x0001180080000080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR4
value|CVMX_L2C_SPAR4_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_SPAR4_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_SPAR4 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080000088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_SPAR4
value|(CVMX_ADD_IO_SEG(0x0001180080000088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_ECC0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_ECC0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_ECC0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00018ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_ECC1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_ECC1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00020ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_ECC1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00020ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_IEN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_IEN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_IEN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00000ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_INT
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_INT(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00028ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_INT
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00028ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_PFC0
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_PFC0(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_PFC0
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00400ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_PFC1
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_PFC1(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00408ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_PFC1
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00408ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_PFC2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_PFC2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00410ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_PFC2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00410ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_PFC3
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_PFC3(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00418ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_PFC3
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00418ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_PRF
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_PRF(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_PRF
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00008ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_TADX_TAG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_TADX_TAG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080A00010ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|3
operator|)
operator|*
literal|0x40000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_TADX_TAG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080A00010ull) + ((block_id)& 3) * 0x40000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_VER_ID
value|CVMX_L2C_VER_ID_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VER_ID_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VER_ID not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808007E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VER_ID
value|(CVMX_ADD_IO_SEG(0x00011800808007E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_VER_IOB
value|CVMX_L2C_VER_IOB_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VER_IOB_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VER_IOB not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808007F0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VER_IOB
value|(CVMX_ADD_IO_SEG(0x00011800808007F0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_VER_MSC
value|CVMX_L2C_VER_MSC_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VER_MSC_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VER_MSC not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808007D0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VER_MSC
value|(CVMX_ADD_IO_SEG(0x00011800808007D0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_VER_PP
value|CVMX_L2C_VER_PP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VER_PP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VER_PP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808007E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VER_PP
value|(CVMX_ADD_IO_SEG(0x00011800808007E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VIRTID_IOBX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VIRTID_IOBX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808C0200ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VIRTID_IOBX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800808C0200ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VIRTID_PPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|9
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VIRTID_PPX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800808C0000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VIRTID_PPX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800808C0000ull) + ((offset)& 31) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_VRT_CTL
value|CVMX_L2C_VRT_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VRT_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VRT_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VRT_CTL
value|(CVMX_ADD_IO_SEG(0x0001180080800010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_VRT_MEMX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1023
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_VRT_MEMX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080900000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1023
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_VRT_MEMX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080900000ull) + ((offset)& 1023) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_WPAR_IOBX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_WPAR_IOBX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080840200ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_WPAR_IOBX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080840200ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_WPAR_PPX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|5
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|9
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|31
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_WPAR_PPX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080840000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|31
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_WPAR_PPX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080840000ull) + ((offset)& 31) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_XMCX_PFC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_XMCX_PFC(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800400ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|64
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_XMCX_PFC
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080800400ull) + ((offset)& 3) * 64)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_L2C_XMC_CMD
value|CVMX_L2C_XMC_CMD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_XMC_CMD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_XMC_CMD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_XMC_CMD
value|(CVMX_ADD_IO_SEG(0x0001180080800028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_L2C_XMDX_PFC
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_L2C_XMDX_PFC(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180080800408ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|64
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_L2C_XMDX_PFC
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180080800408ull) + ((offset)& 3) * 64)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_l2c_big_ctl  *  * L2C_BIG_CTL = L2C Big memory control register  *  *  * Notes:  * (1) BIGRD interrupts can occur during normal operation as the PP's are allowed to prefetch to  *     non-existent memory locations.  Therefore, BIGRD is for informational purposes only.  *  * (2) When HOLEWR/BIGWR blocks a store L2C_VER_ID, L2C_VER_PP, L2C_VER_IOB, and L2C_VER_MSC will be  *     loaded just like a store which is blocked by VRTWR.  Additionally, L2C_ERR_XMC will be loaded.  */
end_comment

begin_union
union|union
name|cvmx_l2c_big_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_big_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|maxdram
range|:
literal|4
decl_stmt|;
comment|/**< Amount of configured DRAM                                                              0 = reserved                                                              1 = 512MB                                                              2 = 1GB                                                              3 = 2GB                                                              4 = 4GB                                                              5 = 8GB                                                              6 = 16GB                                                              7 = 32GB                                                              8 = 64GB     (**reserved in 63xx**)                                                              9 = 128GB    (**reserved in 63xx**)                                                              10-15 reserved                                                          Violations of this limit causes                                                          L2C to set L2C_INT_REG[BIGRD/BIGWR]. */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|disable
range|:
literal|1
decl_stmt|;
comment|/**< When set, disables the BIGWR/BIGRD logic completely                                                          and reverts HOLEWR to 63xx pass 1.x behavior.                                                          When clear, BIGWR and HOLEWR block stores in the same                                                          same manner as the VRT logic, and BIGRD is reported. */
else|#
directive|else
name|uint64_t
name|disable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|maxdram
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_big_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_big_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_big_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_big_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_big_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_big_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_big_ctl
name|cvmx_l2c_big_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst  *  * L2C_BST = L2C BIST Status  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dutfl
range|:
literal|32
decl_stmt|;
comment|/**< BIST failure status for PP0-3 DUT */
name|uint64_t
name|rbffl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for RBF0-3 */
name|uint64_t
name|xbffl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for XBF0-3 */
name|uint64_t
name|tdpfl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for TDP0-3 */
name|uint64_t
name|ioccmdfl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for IOCCMD */
name|uint64_t
name|iocdatfl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for IOCDAT */
name|uint64_t
name|dutresfl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for DUTRES */
name|uint64_t
name|vrtfl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for VRT0 */
name|uint64_t
name|tdffl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for TDF0 */
else|#
directive|else
name|uint64_t
name|tdffl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tdpfl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|xbffl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rbffl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_bst_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for PP0-3 DUT */
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for IOCCMD */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for IOCDAT */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for DUTRES */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for VRT0 */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tdffl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for TDF0 */
else|#
directive|else
name|uint64_t
name|tdffl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_l2c_bst_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|6
decl_stmt|;
comment|/**< BIST failure status for PP0-5 DUT */
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for IOCCMD */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for IOCDAT */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for DUTRES */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for VRT0 */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tdffl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for TDF0 */
else|#
directive|else
name|uint64_t
name|tdffl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_l2c_bst_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_bst_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|10
decl_stmt|;
comment|/**< BIST failure status for PP0-9 DUT */
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for IOCCMD */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for IOCDAT */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for DUTRES */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for VRT0 */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tdffl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for TDF0 */
else|#
directive|else
name|uint64_t
name|tdffl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|vrtfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dutresfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|iocdatfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ioccmdfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_31
range|:
literal|15
decl_stmt|;
name|uint64_t
name|dutfl
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_l2c_bst_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst
name|cvmx_l2c_bst_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst0  *  * L2C_BST0 = L2C BIST 0 CTL/STAT  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|dtbnk
range|:
literal|1
decl_stmt|;
comment|/**< DuTag Bank#                                                          When DT=1(BAD), this field provides additional information                                                          about which DuTag Bank (0/1) failed. */
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-MSK RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|dtcnt
range|:
literal|13
decl_stmt|;
comment|/**< DuTag BiST Counter (used to help isolate the failure)                                                          [12]:    i (0=FORWARD/1=REVERSE pass)                                                          [11:10]: j (Pattern# 1 of 4)                                                          [9:4]:   k (DT Index 1 of 64)                                                          [3:0]:   l (DT# 1 of 16 DTs) */
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DuTAG RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for STIN-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-DAT RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|13
decl_stmt|;
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dtbnk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_bst0_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-MSK RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|9
decl_stmt|;
comment|/**< DuTag BiST Counter (used to help isolate the failure)                                                          [8]:   i (0=FORWARD/1=REVERSE pass)                                                          [7:6]: j (Pattern# 1 of 4)                                                          [5:0]: k (DT Index 1 of 64) */
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DuTAG RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-DAT RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_15_18
range|:
literal|4
decl_stmt|;
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_bst0_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-MSK RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|10
decl_stmt|;
comment|/**< DuTag BiST Counter (used to help isolate the failure)                                                          [9]:   i (0=FORWARD/1=REVERSE pass)                                                          [8:7]: j (Pattern# 1 of 4)                                                          [6:1]: k (DT Index 1 of 64)                                                          [0]:   l (DT# 1 of 2 DTs) */
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DuTAG RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for STIN-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-DAT RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_l2c_bst0_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|13
decl_stmt|;
comment|/**< DuTag BiST Counter (used to help isolate the failure)                                                          [12]:    i (0=FORWARD/1=REVERSE pass)                                                          [11:10]: j (Pattern# 1 of 4)                                                          [9:4]:   k (DT Index 1 of 64)                                                          [3:0]:   l (DT# 1 of 16 DTs) */
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DuTAG RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for STIN-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-DAT RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_l2c_bst0_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2c_bst0_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|dtbnk
range|:
literal|1
decl_stmt|;
comment|/**< DuTag Bank#                                                          When DT=1(BAD), this field provides additional information                                                          about which DuTag Bank (0/1) failed. */
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-MSK RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|10
decl_stmt|;
comment|/**< DuTag BiST Counter (used to help isolate the failure)                                                          [9]:   i (0=FORWARD/1=REVERSE pass)                                                          [8:7]: j (Pattern# 1 of 4)                                                          [6:1]: k (DT Index 1 of 64)                                                          [0]:   l (DT# 1 of 2 DTs) */
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for DuTAG RAM(s)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for STIN-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for WLB-DAT RAM [DP0-3]                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|wlb_dat
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stin_msk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtcnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_16_18
range|:
literal|3
decl_stmt|;
name|uint64_t
name|wlb_msk
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dtbnk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_l2c_bst0_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst0_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst0
name|cvmx_l2c_bst0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst1  *  * L2C_BST1 = L2C BIST 1 CTL/STAT  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
comment|/**< Bist Results for L2T (USE+8SET RAMs)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_bst1_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|vwdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for VWDF RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|lrf
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for LRF RAMs (PLC+ILC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vab_vwcf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for VAB VWCF_MEM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_5_8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|l2t
range|:
literal|5
decl_stmt|;
comment|/**< Bist Results for L2T (USE+4SET RAMs)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_8
range|:
literal|4
decl_stmt|;
name|uint64_t
name|vab_vwcf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lrf
range|:
literal|2
decl_stmt|;
name|uint64_t
name|vwdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_l2c_bst1_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_l2c_bst1_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|vwdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for VWDF RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|lrf
range|:
literal|2
decl_stmt|;
comment|/**< Bist Results for LRF RAMs (PLC+ILC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vab_vwcf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for VAB VWCF_MEM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
comment|/**< Bist Results for L2T (USE+8SET RAMs)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vab_vwcf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lrf
range|:
literal|2
decl_stmt|;
name|uint64_t
name|vwdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_l2c_bst1_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_bst1_cn38xx
name|cn50xx
decl_stmt|;
struct|struct
name|cvmx_l2c_bst1_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|plc2
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for PLC2 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|plc1
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for PLC1 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|plc0
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for PLC0 RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vwdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for VWDF RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ilc
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for ILC RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vab_vwcf
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for VAB VWCF_MEM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
comment|/**< Bist Results for L2T (USE+8SET RAMs)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vab_vwcf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ilc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vwdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|plc0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|plc1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|plc2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_l2c_bst1_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_bst1_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|plc2
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for LRF RAMs (ILC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|plc1
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for LRF RAMs (ILC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|plc0
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for LRF RAMs (ILC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ilc
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for LRF RAMs (ILC)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vwdf1
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for VWDF1 RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vwdf0
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for VWDF0 RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|vab_vwcf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for VAB VWCF1_MEM */
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vab_vwcf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for VAB VWCF0_MEM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
comment|/**< Bist Results for L2T (USE+8SET RAMs)                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vab_vwcf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_10
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vab_vwcf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vwdf0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|vwdf1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ilc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|plc0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|plc1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|plc2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_l2c_bst1_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst1_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst1_cn38xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst1
name|cvmx_l2c_bst1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst2  *  * L2C_BST2 = L2C BIST 2 CTL/STAT  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for MRB RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_4_11
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB IPC RAM                                                          - 1: BAD */
name|uint64_t
name|picbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB PIC RAM                                                          - 1: BAD */
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-DAT RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|picbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_11
range|:
literal|8
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_bst2_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for MRB RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rmdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for RMDF RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB IPC RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-DAT RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rmdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_l2c_bst2_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_l2c_bst2_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for MRB RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rmdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for RMDF RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rhdf
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for RHDF RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB IPC RAM                                                          - 1: BAD */
name|uint64_t
name|picbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB PIC RAM                                                          - 1: BAD */
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-DAT RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|picbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rhdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rmdf
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_l2c_bst2_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_bst2_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst2_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst2_cn30xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_bst2_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for MRB RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rmdb
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for RMDB RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|rhdb
range|:
literal|4
decl_stmt|;
comment|/**< Bist Results for RHDB RAMs                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB IPC RAM                                                          - 1: BAD */
name|uint64_t
name|picbst
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB PIC RAM                                                          - 1: BAD */
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-MSK RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
comment|/**< Bist Results for RFB XRD-DAT RAM                                                          - 0: GOOD (or bist in progress/never run)                                                          - 1: BAD */
else|#
directive|else
name|uint64_t
name|xrddat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xrdmsk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|picbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ipcbst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rhdb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rmdb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mrb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_l2c_bst2_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst2_cn56xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst2_cn56xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst2
name|cvmx_l2c_bst2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst_mem#  *  * L2C_BST_MEM = L2C MEM BIST Status  *  *  * Notes:  * (1) CLEAR_BIST must be written to 1 before START_BIST is written to 1 using a separate CSR write.  *  * (2) CLEAR_BIST must not be changed after writing START_BIST to 1 until the BIST operation completes  *     (indicated by START_BIST returning to 0) or operation is undefined.  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst_memx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst_memx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
comment|/**< When written to 1, starts BIST.  Will read 1 until                                                          BIST is complete (see Note). */
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
comment|/**< When BIST is triggered, run clear BIST (see Note) */
name|uint64_t
name|reserved_5_61
range|:
literal|57
decl_stmt|;
name|uint64_t
name|rdffl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for RDF */
name|uint64_t
name|vbffl
range|:
literal|4
decl_stmt|;
comment|/**< BIST failure status for VBF0-3 */
else|#
directive|else
name|uint64_t
name|vbffl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rdffl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_61
range|:
literal|57
decl_stmt|;
name|uint64_t
name|clear_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|start_bist
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst_memx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst_memx
name|cvmx_l2c_bst_memx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst_tdt#  *  * L2C_BST_TDT = L2C TAD DaTa BIST Status  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst_tdtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst_tdtx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|fbfrspfl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 FBF RSP read port */
name|uint64_t
name|sbffl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 SBF */
name|uint64_t
name|fbffl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 FBF WRP read port */
name|uint64_t
name|l2dfl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 L2D */
else|#
directive|else
name|uint64_t
name|l2dfl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|fbffl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sbffl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|fbfrspfl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_bst_tdtx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_tdtx_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_l2c_bst_tdtx_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|sbffl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 SBF */
name|uint64_t
name|fbffl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 FBF */
name|uint64_t
name|l2dfl
range|:
literal|8
decl_stmt|;
comment|/**< BIST failure status for quad 0-7 L2D */
else|#
directive|else
name|uint64_t
name|l2dfl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|fbffl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sbffl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_l2c_bst_tdtx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_tdtx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_tdtx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst_tdtx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst_tdtx
name|cvmx_l2c_bst_tdtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_bst_ttg#  *  * L2C_BST_TTG = L2C TAD TaG BIST Status  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_bst_ttgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_bst_ttgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|lrufl
range|:
literal|1
decl_stmt|;
comment|/**< BIST failure status for tag LRU */
name|uint64_t
name|tagfl
range|:
literal|16
decl_stmt|;
comment|/**< BIST failure status for tag ways 0-15 */
else|#
directive|else
name|uint64_t
name|tagfl
range|:
literal|16
decl_stmt|;
name|uint64_t
name|lrufl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_bst_ttgx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_bst_ttgx
name|cvmx_l2c_bst_ttgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_cfg  *  * Specify the RSL base addresses for the block  *  *                  L2C_CFG = L2C Configuration  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|bstrun
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data Store Bist Running                                                          Indicates when the L2C HW Bist sequence(short or long) is                                                          running. [L2C ECC Bist FSM is not in the RESET/DONE state] */
name|uint64_t
name|lbist
range|:
literal|1
decl_stmt|;
comment|/**< L2C Data Store Long Bist Sequence                                                          When the previous state was '0' and SW writes a '1',                                                          the long bist sequence (enhanced 13N March) is performed.                                                          SW can then read the L2C_CFG[BSTRUN] which will indicate                                                          that the long bist sequence is running. When BSTRUN-=0,                                                          the state of the L2D_BST[0-3] registers contain information                                                          which reflects the status of the recent long bist sequence.                                                          NOTE: SW must never write LBIST=0 while Long Bist is running                                                          (ie: when BSTRUN=1 never write LBIST=0).                                                          NOTE: LBIST is disabled if the MIO_FUS_DAT2.BIST_DIS                                                          Fuse is blown. */
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
comment|/**< L2C XOR Bank Bit                                                          When both LMC's are enabled(DPRES1=1/DPRES0=1), this                                                          bit determines how addresses are assigned to                                                          LMC port(s).                                                             XOR_BANK|  LMC#                                                           ----------+---------------------------------                                                               0     |   byte address[7]                                                               1     |   byte address[7] XOR byte address[12]                                                          Example: If both LMC ports are enabled (DPRES1=1/DPRES0=1)                                                          and XOR_BANK=1, then addr[7] XOR addr[12] is used to determine                                                          which LMC Port# a reference is directed to. */
name|uint64_t
name|dpres1
range|:
literal|1
decl_stmt|;
comment|/**< DDR1 Present/LMC1 Enable                                                          When DPRES1 is set, LMC#1 is enabled(DDR1 pins at                                                          the BOTTOM of the chip are active).                                                          NOTE: When both LMC ports are enabled(DPRES1=1/DPRES0=1),                                                          see XOR_BANK bit to determine how a reference is                                                          assigned to a DDR/LMC port. (Also, in dual-LMC configuration,                                                          the address sent to the targeted LMC port is the                                                          address shifted right by one).                                                          NOTE: For power-savings, the DPRES1 is also used to                                                          disable DDR1/LMC1 clocks. */
name|uint64_t
name|dpres0
range|:
literal|1
decl_stmt|;
comment|/**< DDR0 Present/LMC0 Enable                                                          When DPRES0 is set, LMC#0 is enabled(DDR0 pins at                                                          the BOTTOM of the chip are active).                                                          NOTE: When both LMC ports are enabled(DPRES1=1/DPRES0=1),                                                          see XOR_BANK bit to determine how a reference is                                                          assigned to a DDR/LMC port. (Also, in dual-LMC configuration,                                                          the address sent to the targeted LMC port is the                                                          address shifted right by one).                                                          NOTE: For power-savings, the DPRES0 is also used to                                                          disable DDR0/LMC0 clocks. */
name|uint64_t
name|dfill_dis
range|:
literal|1
decl_stmt|;
comment|/**< L2C Dual Fill Disable                                                          When set, the L2C dual-fill performance feature is                                                          disabled.                                                          NOTE: This bit is only intended to evaluate the                                                          effectiveness of the dual-fill feature. For OPTIMAL                                                          performance, this bit should ALWAYS be zero. */
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Exponent                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When FPEN is enabled and the LFB is empty, the                                                          forward progress counter (FPCNT) is initialized to:                                                             FPCNT[24:0] = 2^(9+FPEXP)                                                          When the LFB is non-empty the FPCNT is decremented                                                          (every eclk interval). If the FPCNT reaches zero,                                                          the LFB no longer accepts new requests until either                                                             a) all of the current LFB entries have completed                                                                (to ensure forward progress).                                                             b) FPEMPTY=0 and another forward progress count                                                                interval timeout expires.                                                          EXAMPLE USE: If FPEXP=2, the FPCNT = 2048 eclks.                                                          (For eclk=500MHz(2ns), this would be ~4us). */
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Empty                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL all current LFB                                                          entries have completed.                                                          When clear, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL either                                                            a) all current LFB entries have completed.                                                            b) another forward progress interval expires                                                          NOTE: We may want to FREEZE/HANG the system when                                                          we encounter an LFB entry cannot complete, and there                                                          may be times when we want to allow further LFB-NQs                                                          to be permitted to help in further analyzing the                                                          source */
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Enable                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, enables the Forward Progress Counter to                                                          prevent new LFB entries from enqueueing until ALL                                                          current LFB entries have completed. */
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
comment|/**< L2C Index Alias Enable                                                          When set, the L2 Tag/Data Store will alias the 11-bit                                                          index with the low order 11-bits of the tag.                                                             index[17:7] =  (tag[28:18] ^ index[17:7])                                                          NOTE: This bit must only be modified at boot time,                                                          when it can be guaranteed that no blocks have been                                                          loaded into the L2 Cache.                                                          The index aliasing is a performance enhancement feature                                                          which reduces the L2 cache thrashing experienced for                                                          regular stride references.                                                          NOTE: The index alias is stored in the LFB and VAB, and                                                          its effects are reversed for memory references (Victims,                                                          STT-Misses and Read-Misses) */
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
comment|/**< MWF Credit Threshold: When the remaining MWF credits                                                          become less than or equal to the MWF_CRD, the L2C will                                                          assert l2c__lmi_mwd_hiwater_a to signal the LMC to give                                                          writes (victims) higher priority. */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RSP Arbitration Mode:                                                          - 0: Fixed Priority [HP=RFB, RMCF, RHCF, STRSP, LP=STRSC]                                                          - 1: Round Robin: [RFB(reflected I/O), RMCF(RdMiss),                                                              RHCF(RdHit), STRSP(ST RSP w/ invalidate),                                                              STRSC(ST RSP no invalidate)] */
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RFB Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB->PP requests are higher priority than                                                              PP->IOB requests                                                          - 1: Round Robin -                                                              I/O requests from PP and IOB are serviced in                                                              round robin */
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RF Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB memory requests are higher priority than PP                                                              memory requests.                                                          - 1: Round Robin -                                                              Memory requests from PP and IOB are serviced in                                                              round robin. */
else|#
directive|else
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dfill_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dpres0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dpres1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xor_bank
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bstrun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_cfg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Exponent                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When FPEN is enabled and the LFB is empty, the                                                          forward progress counter (FPCNT) is initialized to:                                                             FPCNT[24:0] = 2^(9+FPEXP)                                                          When the LFB is non-empty the FPCNT is decremented                                                          (every eclk interval). If the FPCNT reaches zero,                                                          the LFB no longer accepts new requests until either                                                             a) all of the current LFB entries have completed                                                                (to ensure forward progress).                                                             b) FPEMPTY=0 and another forward progress count                                                                interval timeout expires.                                                          EXAMPLE USE: If FPEXP=2, the FPCNT = 2048 eclks.                                                          (For eclk=500MHz(2ns), this would be ~4us). */
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Empty                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL all current LFB                                                          entries have completed.                                                          When clear, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL either                                                            a) all current LFB entries have completed.                                                            b) another forward progress interval expires                                                          NOTE: We may want to FREEZE/HANG the system when                                                          we encounter an LFB entry cannot complete, and there                                                          may be times when we want to allow further LFB-NQs                                                          to be permitted to help in further analyzing the                                                          source */
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Enable                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, enables the Forward Progress Counter to                                                          prevent new LFB entries from enqueueing until ALL                                                          current LFB entries have completed. */
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
comment|/**< L2C Index Alias Enable                                                          When set, the L2 Tag/Data Store will alias the 8-bit                                                          index with the low order 8-bits of the tag.                                                             index[14:7] =  (tag[22:15] ^ index[14:7])                                                          NOTE: This bit must only be modified at boot time,                                                          when it can be guaranteed that no blocks have been                                                          loaded into the L2 Cache.                                                          The index aliasing is a performance enhancement feature                                                          which reduces the L2 cache thrashing experienced for                                                          regular stride references.                                                          NOTE: The index alias is stored in the LFB and VAB, and                                                          its effects are reversed for memory references (Victims,                                                          STT-Misses and Read-Misses) */
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
comment|/**< MWF Credit Threshold: When the remaining MWF credits                                                          become less than or equal to the MWF_CRD, the L2C will                                                          assert l2c__lmi_mwd_hiwater_a to signal the LMC to give                                                          writes (victims) higher priority. */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RSP Arbitration Mode:                                                          - 0: Fixed Priority [HP=RFB, RMCF, RHCF, STRSP, LP=STRSC]                                                          - 1: Round Robin: [RFB(reflected I/O), RMCF(RdMiss),                                                              RHCF(RdHit), STRSP(ST RSP w/ invalidate),                                                              STRSC(ST RSP no invalidate)] */
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RFB Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB->PP requests are higher priority than                                                              PP->IOB requests                                                          - 1: Round Robin -                                                              I/O requests from PP and IOB are serviced in                                                              round robin */
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RF Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB memory requests are higher priority than PP                                                              memory requests.                                                          - 1: Round Robin -                                                              Memory requests from PP and IOB are serviced in                                                              round robin. */
else|#
directive|else
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_l2c_cfg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_cfg_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_cfg_cn30xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2c_cfg_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|bstrun
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data Store Bist Running                                                          Indicates when the L2C HW Bist sequence(short or long) is                                                          running. [L2C ECC Bist FSM is not in the RESET/DONE state] */
name|uint64_t
name|lbist
range|:
literal|1
decl_stmt|;
comment|/**< L2C Data Store Long Bist Sequence                                                          When the previous state was '0' and SW writes a '1',                                                          the long bist sequence (enhanced 13N March) is performed.                                                          SW can then read the L2C_CFG[BSTRUN] which will indicate                                                          that the long bist sequence is running. When BSTRUN-=0,                                                          the state of the L2D_BST[0-3] registers contain information                                                          which reflects the status of the recent long bist sequence.                                                          NOTE: SW must never write LBIST=0 while Long Bist is running                                                          (ie: when BSTRUN=1 never write LBIST=0). */
name|uint64_t
name|reserved_14_17
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Exponent                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When FPEN is enabled and the LFB is empty, the                                                          forward progress counter (FPCNT) is initialized to:                                                             FPCNT[24:0] = 2^(9+FPEXP)                                                          When the LFB is non-empty the FPCNT is decremented                                                          (every eclk interval). If the FPCNT reaches zero,                                                          the LFB no longer accepts new requests until either                                                             a) all of the current LFB entries have completed                                                                (to ensure forward progress).                                                             b) FPEMPTY=0 and another forward progress count                                                                interval timeout expires.                                                          EXAMPLE USE: If FPEXP=2, the FPCNT = 2048 eclks.                                                          (For eclk=500MHz(2ns), this would be ~4us). */
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Empty                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL all current LFB                                                          entries have completed.                                                          When clear, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL either                                                            a) all current LFB entries have completed.                                                            b) another forward progress interval expires                                                          NOTE: We may want to FREEZE/HANG the system when                                                          we encounter an LFB entry cannot complete, and there                                                          may be times when we want to allow further LFB-NQs                                                          to be permitted to help in further analyzing the                                                          source */
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Enable                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, enables the Forward Progress Counter to                                                          prevent new LFB entries from enqueueing until ALL                                                          current LFB entries have completed. */
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
comment|/**< L2C Index Alias Enable                                                          When set, the L2 Tag/Data Store will alias the 7-bit                                                          index with the low order 7-bits of the tag.                                                             index[13:7] =  (tag[20:14] ^ index[13:7])                                                          NOTE: This bit must only be modified at boot time,                                                          when it can be guaranteed that no blocks have been                                                          loaded into the L2 Cache.                                                          The index aliasing is a performance enhancement feature                                                          which reduces the L2 cache thrashing experienced for                                                          regular stride references.                                                          NOTE: The index alias is stored in the LFB and VAB, and                                                          its effects are reversed for memory references (Victims,                                                          STT-Misses and Read-Misses) */
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
comment|/**< MWF Credit Threshold: When the remaining MWF credits                                                          become less than or equal to the MWF_CRD, the L2C will                                                          assert l2c__lmi_mwd_hiwater_a to signal the LMC to give                                                          writes (victims) higher priority. */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RSP Arbitration Mode:                                                          - 0: Fixed Priority [HP=RFB, RMCF, RHCF, STRSP, LP=STRSC]                                                          - 1: Round Robin: [RFB(reflected I/O), RMCF(RdMiss),                                                              RHCF(RdHit), STRSP(ST RSP w/ invalidate),                                                              STRSC(ST RSP no invalidate)] */
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RFB Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB->PP requests are higher priority than                                                              PP->IOB requests                                                          - 1: Round Robin -                                                              I/O requests from PP and IOB are serviced in                                                              round robin */
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RF Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB memory requests are higher priority than PP                                                              memory requests.                                                          - 1: Round Robin -                                                              Memory requests from PP and IOB are serviced in                                                              round robin. */
else|#
directive|else
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_14_17
range|:
literal|4
decl_stmt|;
name|uint64_t
name|lbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bstrun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_l2c_cfg_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_cfg_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_cfg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_cfg_s
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_cfg_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|bstrun
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data Store Bist Running                                                          Indicates when the L2C HW Bist sequence(short or long) is                                                          running. [L2C ECC Bist FSM is not in the RESET/DONE state] */
name|uint64_t
name|lbist
range|:
literal|1
decl_stmt|;
comment|/**< L2C Data Store Long Bist Sequence                                                          When the previous state was '0' and SW writes a '1',                                                          the long bist sequence (enhanced 13N March) is performed.                                                          SW can then read the L2C_CFG[BSTRUN] which will indicate                                                          that the long bist sequence is running. When BSTRUN-=0,                                                          the state of the L2D_BST[0-3] registers contain information                                                          which reflects the status of the recent long bist sequence.                                                          NOTE: SW must never write LBIST=0 while Long Bist is running                                                          (ie: when BSTRUN=1 never write LBIST=0).                                                          NOTE: LBIST is disabled if the MIO_FUS_DAT2.BIST_DIS                                                          Fuse is blown. */
name|uint64_t
name|reserved_15_17
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dfill_dis
range|:
literal|1
decl_stmt|;
comment|/**< L2C Dual Fill Disable                                                          When set, the L2C dual-fill performance feature is                                                          disabled.                                                          NOTE: This bit is only intended to evaluate the                                                          effectiveness of the dual-fill feature. For OPTIMAL                                                          performance, this bit should ALWAYS be zero. */
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Exponent                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When FPEN is enabled and the LFB is empty, the                                                          forward progress counter (FPCNT) is initialized to:                                                             FPCNT[24:0] = 2^(9+FPEXP)                                                          When the LFB is non-empty the FPCNT is decremented                                                          (every eclk interval). If the FPCNT reaches zero,                                                          the LFB no longer accepts new requests until either                                                             a) all of the current LFB entries have completed                                                                (to ensure forward progress).                                                             b) FPEMPTY=0 and another forward progress count                                                                interval timeout expires.                                                          EXAMPLE USE: If FPEXP=2, the FPCNT = 2048 eclks.                                                          (For eclk=500MHz(2ns), this would be ~4us). */
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Empty                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL all current LFB                                                          entries have completed.                                                          When clear, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL either                                                            a) all current LFB entries have completed.                                                            b) another forward progress interval expires                                                          NOTE: We may want to FREEZE/HANG the system when                                                          we encounter an LFB entry cannot complete, and there                                                          may be times when we want to allow further LFB-NQs                                                          to be permitted to help in further analyzing the                                                          source */
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Enable                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, enables the Forward Progress Counter to                                                          prevent new LFB entries from enqueueing until ALL                                                          current LFB entries have completed. */
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
comment|/**< L2C Index Alias Enable                                                          When set, the L2 Tag/Data Store will alias the 11-bit                                                          index with the low order 11-bits of the tag.                                                             index[17:7] =  (tag[28:18] ^ index[17:7])                                                          NOTE: This bit must only be modified at boot time,                                                          when it can be guaranteed that no blocks have been                                                          loaded into the L2 Cache.                                                          The index aliasing is a performance enhancement feature                                                          which reduces the L2 cache thrashing experienced for                                                          regular stride references.                                                          NOTE: The index alias is stored in the LFB and VAB, and                                                          its effects are reversed for memory references (Victims,                                                          STT-Misses and Read-Misses) */
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
comment|/**< MWF Credit Threshold: When the remaining MWF credits                                                          become less than or equal to the MWF_CRD, the L2C will                                                          assert l2c__lmi_mwd_hiwater_a to signal the LMC to give                                                          writes (victims) higher priority. */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RSP Arbitration Mode:                                                          - 0: Fixed Priority [HP=RFB, RMCF, RHCF, STRSP, LP=STRSC]                                                          - 1: Round Robin: [RFB(reflected I/O), RMCF(RdMiss),                                                              RHCF(RdHit), STRSP(ST RSP w/ invalidate),                                                              STRSC(ST RSP no invalidate)] */
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RFB Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB->PP requests are higher priority than                                                              PP->IOB requests                                                          - 1: Round Robin -                                                              I/O requests from PP and IOB are serviced in                                                              round robin */
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RF Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB memory requests are higher priority than PP                                                              memory requests.                                                          - 1: Round Robin -                                                              Memory requests from PP and IOB are serviced in                                                              round robin. */
else|#
directive|else
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dfill_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_17
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lbist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bstrun
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
struct|struct
name|cvmx_l2c_cfg_cn58xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|dfill_dis
range|:
literal|1
decl_stmt|;
comment|/**< L2C Dual Fill Disable                                                          When set, the L2C dual-fill performance feature is                                                          disabled.                                                          NOTE: This bit is only intended to evaluate the                                                          effectiveness of the dual-fill feature. For OPTIMAL                                                          performance, this bit should ALWAYS be zero. */
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Exponent                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When FPEN is enabled and the LFB is empty, the                                                          forward progress counter (FPCNT) is initialized to:                                                             FPCNT[24:0] = 2^(9+FPEXP)                                                          When the LFB is non-empty the FPCNT is decremented                                                          (every eclk interval). If the FPCNT reaches zero,                                                          the LFB no longer accepts new requests until either                                                             a) all of the current LFB entries have completed                                                                (to ensure forward progress).                                                             b) FPEMPTY=0 and another forward progress count                                                                interval timeout expires.                                                          EXAMPLE USE: If FPEXP=2, the FPCNT = 2048 eclks.                                                          (For eclk=500MHz(2ns), this would be ~4us). */
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Empty                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL all current LFB                                                          entries have completed.                                                          When clear, if the forward progress counter expires,                                                          all new LFB-NQs are stopped UNTIL either                                                            a) all current LFB entries have completed.                                                            b) another forward progress interval expires                                                          NOTE: We may want to FREEZE/HANG the system when                                                          we encounter an LFB entry cannot complete, and there                                                          may be times when we want to allow further LFB-NQs                                                          to be permitted to help in further analyzing the                                                          source */
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
comment|/**< [CYA] Forward Progress Counter Enable                                                          NOTE: Should NOT be exposed to customer! [FOR DEBUG ONLY]                                                          When set, enables the Forward Progress Counter to                                                          prevent new LFB entries from enqueueing until ALL                                                          current LFB entries have completed. */
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
comment|/**< L2C Index Alias Enable                                                          When set, the L2 Tag/Data Store will alias the 11-bit                                                          index with the low order 11-bits of the tag.                                                             index[17:7] =  (tag[28:18] ^ index[17:7])                                                          NOTE: This bit must only be modified at boot time,                                                          when it can be guaranteed that no blocks have been                                                          loaded into the L2 Cache.                                                          The index aliasing is a performance enhancement feature                                                          which reduces the L2 cache thrashing experienced for                                                          regular stride references.                                                          NOTE: The index alias is stored in the LFB and VAB, and                                                          its effects are reversed for memory references (Victims,                                                          STT-Misses and Read-Misses) */
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
comment|/**< MWF Credit Threshold: When the remaining MWF credits                                                          become less than or equal to the MWF_CRD, the L2C will                                                          assert l2c__lmi_mwd_hiwater_a to signal the LMC to give                                                          writes (victims) higher priority. */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RSP Arbitration Mode:                                                          - 0: Fixed Priority [HP=RFB, RMCF, RHCF, STRSP, LP=STRSC]                                                          - 1: Round Robin: [RFB(reflected I/O), RMCF(RdMiss),                                                              RHCF(RdHit), STRSP(ST RSP w/ invalidate),                                                              STRSC(ST RSP no invalidate)] */
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RFB Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB->PP requests are higher priority than                                                              PP->IOB requests                                                          - 1: Round Robin -                                                              I/O requests from PP and IOB are serviced in                                                              round robin */
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< RF Arbitration Mode:                                                          - 0: Fixed Priority -                                                              IOB memory requests are higher priority than PP                                                              memory requests.                                                          - 1: Round Robin -                                                              Memory requests from PP and IOB are serviced in                                                              round robin. */
else|#
directive|else
name|uint64_t
name|lrf_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfb_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mwf_crd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|idxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpempty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fpexp
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dfill_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_cfg
name|cvmx_l2c_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_cop0_map#  *  * L2C_COP0_MAP = PP COP0 register memory mapped region  *  * Description: PP COP0 register mapped region.  *  * NOTE: for 63xx, if the PPID is outside the range of 0-3,63 the write will be ignored and reads  * will return 0x2bad2bad2bad2bad  *  * Notes:  * (1) There are 256 COP0 registers per PP.  Registers 0-255 map to PP0's COP0 registers, 256-511 are  *     mapped to PP1's, etc.  A special set X PP63 (registers 16128-16383) are for broadcast writes.  *     Any write done to these registers will take effect in ALL PPs.  Note the means the L2C_COP0_MAP  *     register to access can be gotten by:  *  *         REGNUM = [ PPID[5:0], rd[4:0], sel[2:0] ]  *  *     where rd and sel are as defined in the HRM description of Core Coprocessor 0 registers  *     and note 4 below.  *  * (2) if a COP0 register cannot be accessed by this mechanism the write be silently ignored and the  *     read data will be 0xBADDEED.  *  * (3) for 61xx, if the PPID is outside the range of 0-3,63 or if the PP in question is in reset a  *     write will be ignored and reads will timeout the RSL bus.  *  * (4) Referring to note (1) above, the following rd/sel values are supported:  *  *     NOTE: Put only the "Customer type" in HRM. do not put the "Real type" in HRM.  *  *                    Customer                                                    Real  *        rd     sel     type         Description                                 type  *     ======+=======+==========+==============================================+=========  *        4      2       RO          COP0 UserLocal                                RW  *        7      0       RO          COP0 HWREna                                   RW  *        9      0       RO          COP0 Count                                    RW  *        9      6       RO          COP0 CvmCount                                 RW  *        9      7       RO          COP0 CvmCtl                                   RW  *       11      0       RO          COP0 Compare                                  RW  *       11      6       RW          COP0 PowThrottle                              RW  *       12      0       RO          COP0 Status                                   RW  *       12      1       RO          COP0 IntCtl                                   RO  *       12      2       RO          COP0 SRSCtl                                   RO  *       13      0       RO          COP0 Cause                                    RW  *       14      0       RO          COP0 EPC                                      RW  *       15      0       RO          COP0 PrID                                     RO  *       15      1       RO          COP0 EBase                                    RW  *       16      0       RO          PC Issue Debug Info (see details below)       RO  *       16      1       RO          PC Fetch Debug Info (see details below)       RO  *       16      2       RO          PC Fill Debug Info (see details below)        RO  *       16      3       RO          PC Misc Debug Info (see details below)        RO  *       18      0       RO          COP0 WatchLo0                                 RW  *       19      0       RO          COP0 WatchHi0                                 RW  *       22      0       RO          COP0 MultiCoreDebug                           RW  *       22      1                   COP0 VoltageMonitor                           RW  *       23      0       RO          COP0 Debug                                    RW  *       23      6       RO          COP0 Debug2                                   RO  *       24      0       RO          COP0 DEPC                                     RW  *       25      0       RO          COP0 PerfCnt Control0                         RW  *       25      1       RO          COP0 PerfCnt Counter0                         RW  *       25      2       RO          COP0 PerfCnt Control1                         RW  *       25      3       RO          COP0 PerfCnt Counter1                         RW  *       27      0       RO          COP0 CacheErr (icache)                        RW  *       28      0       RO          COP0 TagLo (icache)                           RW  *       28      1       RO          COP0 DataLo (icache)                          RW  *       29      1       RO          COP0 DataHi (icache)                          RW  *       30      0       RO          COP0 ErrorEPC                                 RW  *       31      0       RO          COP0 DESAVE                                   RW  *       31      2       RO          COP0 Scratch                                  RW  *       31      3       RO          COP0 Scratch1                                 RW  *       31      4       RO          COP0 Scratch2                                 RW  *  *     - PC Issue Debug Info  *  *       - 63:2 pc0_5a<63:2> // often VA<63:2> of the next instruction to issue  *                           //    but can also be the VA of an instruction executing/replaying on pipe 0  *                           //    or can also be a VA being filled into the instruction cache  *                           //    or can also be unpredictable  *                           //<61:49> RAZ  *       1    illegal      // set when illegal VA  *       0    delayslot    // set when VA is delayslot (prior branch may be either taken or not taken)  *  *     - PC Fetch Debug Info  *  *       - 63:0 fetch_address_3a // VA being fetched from the instruction cache  *                               //<61:49>,<1:0> RAZ  *  *     - PC Fill Debug Info  *  *       - 63:0 fill_address_4a<63:2> // VA<63:2> being filled into instruction cache  *                                    // valid when waiting_for_ifill_4a is set (see PC Misc Debug Info below)  *                                    //<61:49> RAZ  *          1 illegal               // set when illegal VA  *          0 RAZ  *  *     - PC Misc Debug Info  *  *       - 63:3 RAZ  *          2 mem_stall_3a         // stall term from L1 memory system  *          1 waiting_for_pfill_4a // when waiting_for_ifill_4a is set, indicates whether instruction cache fill is due to a prefetch  *          0 waiting_for_ifill_4a // set when there is an outstanding instruction cache fill  */
end_comment

begin_union
union|union
name|cvmx_l2c_cop0_mapx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_cop0_mapx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Data to write to/read from designated PP's COP0                                                          register. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_cop0_mapx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_cop0_mapx
name|cvmx_l2c_cop0_mapx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ctl  *  * L2C_CTL = L2C Control  *  *  * Notes:  * (1) If MAXVAB is != 0, VAB_THRESH should be less than MAXVAB.  *  * (2) L2DFDBE and L2DFSBE allows software to generate L2DSBE, L2DDBE, VBFSBE, and VBFDBE errors for  *     the purposes of testing error handling code.  When one (or both) of these bits are set a PL2  *     which misses in the L2 will fill with the appropriate error in the first 2 OWs of the fill.  *     Software can determine which OW pair gets the error by choosing the desired fill order  *     (address<6:5>).  A PL2 which hits in the L2 will not inject any errors.  Therefore sending a  *     WBIL2 prior to the PL2 is recommended to make a miss likely (if multiple processors are involved  *     software must be careful to be sure no other processor or IO device can bring the block into the  *     L2).  *  *     To generate a VBFSBE or VBFDBE, software must first get the cache block into the cache with an  *     error using a PL2 which misses the L2.  Then a store partial to a portion of the cache block  *     without the error must change the block to dirty.  Then, a subsequent WBL2/WBIL2/victim will  *     trigger the VBFSBE/VBFDBE error.  */
end_comment

begin_union
union|union
name|cvmx_l2c_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|sepcmt
range|:
literal|1
decl_stmt|;
comment|/**< Sends all invals before the corresponding commit. */
name|uint64_t
name|rdf_fast
range|:
literal|1
decl_stmt|;
comment|/**< When 0, delay read data fifo from DCLK to RCLK by one                                                          cycle.  Needed when DCLK:RCLK ratio> 3:1.  Should be                                                          set before DDR traffic begins and only changed when                                                          memory traffic is idle. */
name|uint64_t
name|disstgl2i
range|:
literal|1
decl_stmt|;
comment|/**< Disable STGL2I's from changing the tags */
name|uint64_t
name|l2dfsbe
range|:
literal|1
decl_stmt|;
comment|/**< Force single bit ECC error on PL2 allocates (2) */
name|uint64_t
name|l2dfdbe
range|:
literal|1
decl_stmt|;
comment|/**< Force double bit ECC error on PL2 allocates (2) */
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
comment|/**< Disable conditional clocking in L2C PNR blocks */
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
comment|/**< Maximum VABs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
comment|/**< Maximum LFBs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for RSC/RSD bus                                                          == 0, round-robin                                                          == 1, static priority                                                              1. IOR data                                                              2. STIN/FILLs                                                              3. STDN/SCDN/SCFL */
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for XMC QOS queues                                                          == 0, fully determined through QOS                                                          == 1, QOS0 highest priority, QOS1-3 use normal mode */
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
comment|/**< LMC early fill enable */
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
comment|/**< LMC early fill count                                                          Specifies the number of cycles after the first LMC                                                          fill cycle to wait before requesting a fill on the                                                          RSC/RSD bus.                                                            // 7 dclks (we've received 1st out of 8                                                            // by the time we start counting)                                                            ef_cnt = ((LMCn_CONFIG[MODE32b] ? 14 : 7) *                                                                      dclk0_period) / rclk_period;                                                            // + 1 rclk if the dclk and rclk edges don't                                                            // stay in the same position                                                            if ((dclk0_gen.period % rclk_gen.period) != 0)                                                               ef_cnt = ef_cnt + 1;                                                            // + 2 rclk synchronization uncertainty                                                            ef_cnt = ef_cnt + 2;                                                            // - 3 rclks to recognize first write                                                            ef_cnt = ef_cnt - 3;                                                            // + 3 rclks to perform first write                                                            ef_cnt = ef_cnt + 3;                                                            // - 9 rclks minimum latency from counter expire                                                            // to final fbf read                                                            ef_cnt = ef_cnt - 9; */
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
comment|/**< VAB Threshold                                                          When the number of valid VABs exceeds this number the                                                          L2C increases the priority of all writes in the LMC. */
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
comment|/**< Tag and Data ECC Disable */
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
comment|/**< Index Alias Disable */
else|#
directive|else
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dfdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dfsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disstgl2i
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdf_fast
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sepcmt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_ctl_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|rdf_fast
range|:
literal|1
decl_stmt|;
comment|/**< When 0, delay read data fifo from DCLK to RCLK by one                                                          cycle.  Needed when DCLK:RCLK ratio> 3:1.  Should be                                                          set before DDR traffic begins and only changed when                                                          memory traffic is idle. */
name|uint64_t
name|disstgl2i
range|:
literal|1
decl_stmt|;
comment|/**< Disable STGL2I's from changing the tags */
name|uint64_t
name|l2dfsbe
range|:
literal|1
decl_stmt|;
comment|/**< Force single bit ECC error on PL2 allocates (2) */
name|uint64_t
name|l2dfdbe
range|:
literal|1
decl_stmt|;
comment|/**< Force double bit ECC error on PL2 allocates (2) */
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
comment|/**< Disable conditional clocking in L2C PNR blocks */
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
comment|/**< Maximum VABs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
comment|/**< Maximum LFBs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for RSC/RSD bus                                                          == 0, round-robin                                                          == 1, static priority                                                              1. IOR data                                                              2. STIN/FILLs                                                              3. STDN/SCDN/SCFL */
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for XMC QOS queues                                                          == 0, fully determined through QOS                                                          == 1, QOS0 highest priority, QOS1-3 use normal mode */
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
comment|/**< LMC early fill enable */
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
comment|/**< LMC early fill count                                                          Specifies the number of cycles after the first LMC                                                          fill cycle to wait before requesting a fill on the                                                          RSC/RSD bus.                                                            // 7 dclks (we've received 1st out of 8                                                            // by the time we start counting)                                                            ef_cnt = ((LMCn_CONFIG[MODE32b] ? 14 : 7) *                                                                      dclk0_period) / rclk_period;                                                            // + 1 rclk if the dclk and rclk edges don't                                                            // stay in the same position                                                            if ((dclk0_gen.period % rclk_gen.period) != 0)                                                               ef_cnt = ef_cnt + 1;                                                            // + 2 rclk synchronization uncertainty                                                            ef_cnt = ef_cnt + 2;                                                            // - 3 rclks to recognize first write                                                            ef_cnt = ef_cnt - 3;                                                            // + 3 rclks to perform first write                                                            ef_cnt = ef_cnt + 3;                                                            // - 9 rclks minimum latency from counter expire                                                            // to final fbf read                                                            ef_cnt = ef_cnt - 9; */
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
comment|/**< VAB Threshold                                                          When the number of valid VABs exceeds this number the                                                          L2C increases the priority of all writes in the LMC. */
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
comment|/**< Tag and Data ECC Disable */
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
comment|/**< Index Alias Disable */
else|#
directive|else
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dfdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dfsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disstgl2i
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdf_fast
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_l2c_ctl_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|disstgl2i
range|:
literal|1
decl_stmt|;
comment|/**< Disable STGL2I's from changing the tags */
name|uint64_t
name|l2dfsbe
range|:
literal|1
decl_stmt|;
comment|/**< Force single bit ECC error on PL2 allocates (2) */
name|uint64_t
name|l2dfdbe
range|:
literal|1
decl_stmt|;
comment|/**< Force double bit ECC error on PL2 allocates (2) */
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
comment|/**< Disable conditional clocking in L2C PNR blocks */
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
comment|/**< Maximum VABs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
comment|/**< Maximum LFBs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for RSC/RSD bus                                                          == 0, round-robin                                                          == 1, static priority                                                              1. IOR data                                                              2. STIN/FILLs                                                              3. STDN/SCDN/SCFL */
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for XMC QOS queues                                                          == 0, fully determined through QOS                                                          == 1, QOS0 highest priority, QOS1-3 use normal mode */
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
comment|/**< LMC early fill enable */
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
comment|/**< LMC early fill count                                                          Specifies the number of cycles after the first LMC                                                          fill cycle to wait before requesting a fill on the                                                          RSC/RSD bus.                                                            // 7 dclks (we've received 1st out of 8                                                            // by the time we start counting)                                                            ef_cnt = (7 * dclk0_period) / rclk_period;                                                            // + 1 rclk if the dclk and rclk edges don't                                                            // stay in the same position                                                            if ((dclk0_gen.period % rclk_gen.period) != 0)                                                               ef_cnt = ef_cnt + 1;                                                            // + 2 rclk synchronization uncertainty                                                            ef_cnt = ef_cnt + 2;                                                            // - 3 rclks to recognize first write                                                            ef_cnt = ef_cnt - 3;                                                            // + 3 rclks to perform first write                                                            ef_cnt = ef_cnt + 3;                                                            // - 9 rclks minimum latency from counter expire                                                            // to final fbf read                                                            ef_cnt = ef_cnt - 9; */
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
comment|/**< VAB Threshold                                                          When the number of valid VABs exceeds this number the                                                          L2C increases the priority of all writes in the LMC. */
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
comment|/**< Tag and Data ECC Disable */
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
comment|/**< Index Alias Disable */
else|#
directive|else
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dfdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dfsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disstgl2i
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_l2c_ctl_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
comment|/**< Disable conditional clocking in L2C PNR blocks */
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
comment|/**< Maximum VABs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
comment|/**< Maximum LFBs in use at once                                                          (0 means 16, 1-15 as expected) */
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for RSC/RSD bus                                                          == 0, round-robin                                                          == 1, static priority                                                              1. IOR data                                                              2. STIN/FILLs                                                              3. STDN/SCDN/SCFL */
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
comment|/**< Arbitration mode for XMC QOS queues                                                          == 0, fully determined through QOS                                                          == 1, QOS0 highest priority, QOS1-3 use normal mode */
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
comment|/**< LMC early fill enable */
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
comment|/**< LMC early fill count                                                          Specifies the number of cycles after the first LMC                                                          fill cycle to wait before requesting a fill on the                                                          RSC/RSD bus.                                                            // 7 dclks (we've received 1st out of 8                                                            // by the time we start counting)                                                            ef_cnt = (7 * dclk0_period) / rclk_period;                                                            // + 1 rclk if the dclk and rclk edges don't                                                            // stay in the same position                                                            if ((dclk0_gen.period % rclk_gen.period) != 0)                                                               ef_cnt = ef_cnt + 1;                                                            // + 2 rclk synchronization uncertainty                                                            ef_cnt = ef_cnt + 2;                                                            // - 3 rclks to recognize first write                                                            ef_cnt = ef_cnt - 3;                                                            // + 3 rclks to perform first write                                                            ef_cnt = ef_cnt + 3;                                                            // - 9 rclks minimum latency from counter expire                                                            // to final fbf read                                                            ef_cnt = ef_cnt - 9; */
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
comment|/**< VAB Threshold                                                          When the number of valid VABs exceeds this number the                                                          L2C increases the priority of all writes in the LMC. */
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
comment|/**< Tag and Data ECC Disable */
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
comment|/**< Index Alias Disable */
else|#
directive|else
name|uint64_t
name|disidxalias
range|:
literal|1
decl_stmt|;
name|uint64_t
name|disecc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vab_thresh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ef_cnt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ef_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|xmc_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_arb_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|maxlfb
range|:
literal|4
decl_stmt|;
name|uint64_t
name|maxvab
range|:
literal|4
decl_stmt|;
name|uint64_t
name|discclk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_l2c_ctl_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_ctl_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ctl_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_ctl
name|cvmx_l2c_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_dbg  *  * L2C_DBG = L2C DEBUG Register  *  * Description: L2C Tag/Data Store Debug Register  *  * Notes:  * (1) When using the L2T, L2D or FINV Debug probe feature, the LDD command WILL NOT update the DuTags.  * (2) L2T, L2D, FINV MUST BE mutually exclusive (only one set)  * (3) Force Invalidate is intended as a means for SW to invalidate the L2 Cache while also writing back  *     dirty data to memory to maintain coherency.  * (4) L2 Cache Lock Down feature MUST BE disabled (L2C_LCKBASE[LCK_ENA]=0) if ANY of the L2C debug  *     features (L2T, L2D, FINV) are enabled.  */
end_comment

begin_union
union|union
name|cvmx_l2c_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_dbg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|4
decl_stmt|;
comment|/**< Specifies the LFB Entry# which is to be captured. */
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Dump Enable: When written(=1), the contents of                                                          the LFB specified by LFB_ENUM[3:0] are captured                                                          into the L2C_LFB(0/1/2) registers.                                                          NOTE: Some fields of the LFB entry are unpredictable                                                          and dependent on usage. This is only intended to be                                                          used for HW debug. */
name|uint64_t
name|ppnum
range|:
literal|4
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines which one-of-16                                                          PPs is selected as the diagnostic PP. */
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines 1-of-n targeted                                                          sets to act upon.                                                          NOTE: L2C_DBG[SET] must never equal a crippled or                                                          unusable set (see UMSK* registers and Cripple mode                                                          fuses). */
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
comment|/**< Flush-Invalidate.                                                          When flush-invalidate is enable (FINV=1), all STF                                                          (L1 store-miss) commands generated from the diagnostic PP                                                          (L2C_DBG[PPNUM]) will invalidate the specified set                                                          (L2C_DBG[SET]) at the index specified in the STF                                                          address[17:7]. If a dirty block is detected (D=1), it is                                                          written back to memory. The contents of the invalid                                                          L2 Cache line is also 'scrubbed' with the STF write data.                                                          NOTE: If L2C_CFG[IDXALIAS]=1, the index specified in                                                          STF address[17:7] refers to the 'aliased' address.                                                          NOTE: An STF command with write data=ZEROES can be                                                          generated by SW using the Prefetch instruction with                                                          Hint=30d "prepare for Store", followed by a SYNCW.                                                          What is seen at the L2C as an STF w/wrdcnt=0 with all                                                          of its mask bits clear (indicates zero-fill data).                                                          A flush-invalidate will 'force-hit' the L2 cache at                                                          [index,set] and invalidate the entry (V=0/D=0/L=0/U=0).                                                          If the cache block is dirty, it is also written back                                                          to memory. The DuTag state is probed/updated as normal                                                          for an STF request.                                                          TYPICAL APPLICATIONS:                                                             1) L2 Tag/Data ECC SW Recovery                                                             2) Cache Unlocking                                                          NOTE: If the cacheline had been previously LOCKED(L=1),                                                          a flush-invalidate operation will explicitly UNLOCK                                                          (L=0) the set/index specified.                                                          NOTE: The diagnostic PP cores can generate STF                                                          commands to the L2 Cache whenever all 128 bytes in a                                                          block are written. SW must take this into consideration                                                          to avoid 'errant' Flush-Invalidates. */
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
comment|/**< When enabled (and L2C_DBG[L2T]=0), fill data is                                                          returned directly from the L2 Data Store                                                          (regardless of hit/miss) when an LDD(L1 load-miss) command                                                          is issued from a PP determined by the L2C_DBG[PPNUM]                                                          field. The selected set# is determined by the                                                          L2C_DBG[SET] field, and the index is determined                                                          from the address[17:7] associated with the LDD                                                          command.                                                          This 'force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state. */
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, L2 Tag information [V,D,L,U,phys_addr[33:18]]                                                          is returned on the data bus starting at +32(and +96) bytes                                                          offset from the beginning of cacheline when an LDD                                                          (L1 load-miss) command is issued from a PP determined by                                                          the L2C_DBG[PPNUM] field.                                                          The selected L2 set# is determined by the L2C_DBG[SET]                                                          field, and the L2 index is determined from the                                                          phys_addr[17:7] associated with the LDD command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state.                                                          NOTE: The diagnostic PP should issue a d-stream load                                                          to an aligned cacheline+0x20(+0x60) in order to have the                                                          return VDLUTAG information (in OW2/OW6) written directly                                                          into the proper PP register. The diagnostic PP should also                                                          flush it's local L1 cache after use(to ensure data                                                          coherency).                                                          NOTE: The position of the VDLUTAG data in the destination                                                          register is dependent on the endian mode(big/little).                                                          NOTE: N3K-Pass2 modification. (This bit's functionality                                                          has changed since Pass1-in the following way).                                                          NOTE: (For L2C BitMap testing of L2 Data Store OW ECC):                                                          If L2D_ERR[ECC_ENA]=0, the OW ECC from the selected                                                          half cacheline (see: L2D_ERR[BMHCLSEL] is also                                                          conditionally latched into the L2D_FSYN0/1 CSRs if an                                                          LDD command is detected from the diagnostic PP(L2C_DBG[PPNUM]). */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|4
decl_stmt|;
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_dbg_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|2
decl_stmt|;
comment|/**< Specifies the LFB Entry# which is to be captured. */
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Dump Enable: When written(=1), the contents of                                                          the LFB specified by LFB_ENUM are captured                                                          into the L2C_LFB(0/1/2) registers.                                                          NOTE: Some fields of the LFB entry are unpredictable                                                          and dependent on usage. This is only intended to be                                                          used for HW debug. */
name|uint64_t
name|reserved_7_9
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|1
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines which                                                          PP is selected as the diagnostic PP.                                                          NOTE: For CN30XX single core PPNUM=0 (MBZ) */
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines 1-of-n targeted                                                          sets to act upon.                                                          NOTE: L2C_DBG[SET] must never equal a crippled or                                                          unusable set (see UMSK* registers and Cripple mode                                                          fuses). */
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
comment|/**< Flush-Invalidate.                                                          When flush-invalidate is enable (FINV=1), all STF                                                          (L1 store-miss) commands generated from the PP will invalidate                                                          the specified set(L2C_DBG[SET]) at the index specified                                                          in the STF address[14:7]. If a dirty block is detected(D=1),                                                          it is written back to memory. The contents of the invalid                                                          L2 Cache line is also 'scrubbed' with the STF write data.                                                          NOTE: If L2C_CFG[IDXALIAS]=1, the index specified in                                                          STF address[14:7] refers to the 'aliased' address.                                                          NOTE: An STF command with write data=ZEROES can be                                                          generated by SW using the Prefetch instruction with                                                          Hint=30d "prepare for Store", followed by a SYNCW.                                                          What is seen at the L2C as an STF w/wrdcnt=0 with all                                                          of its mask bits clear (indicates zero-fill data).                                                          A flush-invalidate will 'force-hit' the L2 cache at                                                          [index,set] and invalidate the entry (V=0/D=0/L=0/U=0).                                                          If the cache block is dirty, it is also written back                                                          to memory. The DuTag state is probed/updated as normal                                                          for an STF request.                                                          TYPICAL APPLICATIONS:                                                             1) L2 Tag/Data ECC SW Recovery                                                             2) Cache Unlocking                                                          NOTE: If the cacheline had been previously LOCKED(L=1),                                                          a flush-invalidate operation will explicitly UNLOCK                                                          (L=0) the set/index specified.                                                          NOTE: The PP can generate STF(L1 store-miss)                                                          commands to the L2 Cache whenever all 128 bytes in a                                                          block are written. SW must take this into consideration                                                          to avoid 'errant' Flush-Invalidates. */
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
comment|/**< When enabled (and L2C_DBG[L2T]=0), fill data is                                                          returned directly from the L2 Data Store                                                          (regardless of hit/miss) when an LDD(L1 load-miss)                                                          command is issued from the PP.                                                          The selected set# is determined by the                                                          L2C_DBG[SET] field, and the index is determined                                                          from the address[14:7] associated with the LDD                                                          command.                                                          This 'force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state. */
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, L2 Tag information [V,D,L,U,phys_addr[33:15]]                                                          is returned on the data bus starting at +32(and +96) bytes                                                          offset from the beginning of cacheline when an LDD                                                          (L1 load-miss) command is issued from the PP.                                                          The selected L2 set# is determined by the L2C_DBG[SET]                                                          field, and the L2 index is determined from the                                                          phys_addr[14:7] associated with the LDD command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state.                                                          NOTE: The diagnostic PP should issue a d-stream load                                                          to an aligned cacheline+0x20(+0x60) in order to have the                                                          return VDLUTAG information (in OW2/OW6) written directly                                                          into the proper PP register. The diagnostic PP should also                                                          flush it's local L1 cache after use(to ensure data                                                          coherency).                                                          NOTE: The position of the VDLUTAG data in the destination                                                          register is dependent on the endian mode(big/little).                                                          NOTE: (For L2C BitMap testing of L2 Data Store OW ECC):                                                          If L2D_ERR[ECC_ENA]=0, the OW ECC from the selected                                                          half cacheline (see: L2D_ERR[BMHCLSEL] is also                                                          conditionally latched into the L2D_FSYN0/1 CSRs if an                                                          LDD(L1 load-miss) is detected. */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_9
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_dbg_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|3
decl_stmt|;
comment|/**< Specifies the LFB Entry# which is to be captured. */
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Dump Enable: When written(=1), the contents of                                                          the LFB specified by LFB_ENUM are captured                                                          into the L2C_LFB(0/1/2) registers.                                                          NOTE: Some fields of the LFB entry are unpredictable                                                          and dependent on usage. This is only intended to be                                                          used for HW debug. */
name|uint64_t
name|reserved_7_9
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|1
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines which                                                          PP is selected as the diagnostic PP. */
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines 1-of-n targeted                                                          sets to act upon.                                                          NOTE: L2C_DBG[SET] must never equal a crippled or                                                          unusable set (see UMSK* registers and Cripple mode                                                          fuses). */
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
comment|/**< Flush-Invalidate.                                                          When flush-invalidate is enable (FINV=1), all STF                                                          (L1 store-miss) commands generated from the diagnostic PP                                                          (L2C_DBG[PPNUM]) will invalidate the specified set                                                          (L2C_DBG[SET]) at the index specified in the STF                                                          address[15:7]. If a dirty block is detected (D=1), it is                                                          written back to memory. The contents of the invalid                                                          L2 Cache line is also 'scrubbed' with the STF write data.                                                          NOTE: If L2C_CFG[IDXALIAS]=1, the index specified in                                                          STF address[15:7] refers to the 'aliased' address.                                                          NOTE: An STF command with write data=ZEROES can be                                                          generated by SW using the Prefetch instruction with                                                          Hint=30d "prepare for Store", followed by a SYNCW.                                                          What is seen at the L2C as an STF w/wrdcnt=0 with all                                                          of its mask bits clear (indicates zero-fill data).                                                          A flush-invalidate will 'force-hit' the L2 cache at                                                          [index,set] and invalidate the entry (V=0/D=0/L=0/U=0).                                                          If the cache block is dirty, it is also written back                                                          to memory. The DuTag state is probed/updated as normal                                                          for an STF request.                                                          TYPICAL APPLICATIONS:                                                             1) L2 Tag/Data ECC SW Recovery                                                             2) Cache Unlocking                                                          NOTE: If the cacheline had been previously LOCKED(L=1),                                                          a flush-invalidate operation will explicitly UNLOCK                                                          (L=0) the set/index specified.                                                          NOTE: The diagnostic PP cores can generate STF(L1 store-miss)                                                          commands to the L2 Cache whenever all 128 bytes in a                                                          block are written. SW must take this into consideration                                                          to avoid 'errant' Flush-Invalidates. */
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
comment|/**< When enabled (and L2C_DBG[L2T]=0), fill data is                                                          returned directly from the L2 Data Store                                                          (regardless of hit/miss) when an LDD(L1 load-miss)                                                          command is issued from a PP determined by the                                                          L2C_DBG[PPNUM] field. The selected set# is determined                                                          by the L2C_DBG[SET] field, and the index is determined                                                          from the address[15:7] associated with the LDD command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state. */
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, L2 Tag information [V,D,L,U,phys_addr[33:16]]                                                          is returned on the data bus starting at +32(and +96) bytes                                                          offset from the beginning of cacheline when an LDD                                                          (L1 load-miss) command is issued from a PP determined by                                                          the L2C_DBG[PPNUM] field.                                                          The selected L2 set# is determined by the L2C_DBG[SET]                                                          field, and the L2 index is determined from the                                                          phys_addr[15:7] associated with the LDD command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state.                                                          NOTE: The diagnostic PP should issue a d-stream load                                                          to an aligned cacheline+0x20(+0x60) in order to have the                                                          return VDLUTAG information (in OW2/OW6) written directly                                                          into the proper PP register. The diagnostic PP should also                                                          flush it's local L1 cache after use(to ensure data                                                          coherency).                                                          NOTE: The position of the VDLUTAG data in the destination                                                          register is dependent on the endian mode(big/little).                                                          NOTE: (For L2C BitMap testing of L2 Data Store OW ECC):                                                          If L2D_ERR[ECC_ENA]=0, the OW ECC from the selected                                                          half cacheline (see: L2D_ERR[BMHCLSEL] is also                                                          conditionally latched into the L2D_FSYN0/1 CSRs if an                                                          LDD(L1 load-miss) is detected from the diagnostic PP                                                          (L2C_DBG[PPNUM]). */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_9
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_l2c_dbg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_dbg_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2c_dbg_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|3
decl_stmt|;
comment|/**< Specifies the LFB Entry# which is to be captured. */
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Dump Enable: When written(=1), the contents of                                                          the LFB specified by LFB_ENUM[2:0] are captured                                                          into the L2C_LFB(0/1/2) registers.                                                          NOTE: Some fields of the LFB entry are unpredictable                                                          and dependent on usage. This is only intended to be                                                          used for HW debug. */
name|uint64_t
name|reserved_7_9
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|1
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines which 1-of-2                                                          PPs is selected as the diagnostic PP. */
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines 1-of-n targeted                                                          sets to act upon.                                                          NOTE: L2C_DBG[SET] must never equal a crippled or                                                          unusable set (see UMSK* registers and Cripple mode                                                          fuses). */
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
comment|/**< Flush-Invalidate.                                                          When flush-invalidate is enable (FINV=1), all STF                                                          (L1 store-miss) commands generated from the diagnostic PP                                                          (L2C_DBG[PPNUM]) will invalidate the specified set                                                          (L2C_DBG[SET]) at the index specified in the STF                                                          address[13:7]. If a dirty block is detected (D=1), it is                                                          written back to memory. The contents of the invalid                                                          L2 Cache line is also 'scrubbed' with the STF write data.                                                          NOTE: If L2C_CFG[IDXALIAS]=1, the index specified in                                                          STF address[13:7] refers to the 'aliased' address.                                                          NOTE: An STF command with write data=ZEROES can be                                                          generated by SW using the Prefetch instruction with                                                          Hint=30d "prepare for Store", followed by a SYNCW.                                                          What is seen at the L2C as an STF w/wrdcnt=0 with all                                                          of its mask bits clear (indicates zero-fill data).                                                          A flush-invalidate will 'force-hit' the L2 cache at                                                          [index,set] and invalidate the entry (V=0/D=0/L=0/U=0).                                                          If the cache block is dirty, it is also written back                                                          to memory. The DuTag state is probed/updated as normal                                                          for an STF request.                                                          TYPICAL APPLICATIONS:                                                             1) L2 Tag/Data ECC SW Recovery                                                             2) Cache Unlocking                                                          NOTE: If the cacheline had been previously LOCKED(L=1),                                                          a flush-invalidate operation will explicitly UNLOCK                                                          (L=0) the set/index specified.                                                          NOTE: The diagnostic PP cores can generate STF                                                          commands to the L2 Cache whenever all 128 bytes in a                                                          block are written. SW must take this into consideration                                                          to avoid 'errant' Flush-Invalidates. */
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
comment|/**< When enabled (and L2C_DBG[L2T]=0), fill data is                                                          returned directly from the L2 Data Store                                                          (regardless of hit/miss) when an LDD(L1 load-miss) command                                                          is issued from a PP determined by the L2C_DBG[PPNUM]                                                          field. The selected set# is determined by the                                                          L2C_DBG[SET] field, and the index is determined                                                          from the address[13:7] associated with the LDD                                                          command.                                                          This 'force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state. */
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, L2 Tag information [V,D,L,U,phys_addr[33:14]]                                                          is returned on the data bus starting at +32(and +96) bytes                                                          offset from the beginning of cacheline when an LDD                                                          (L1 load-miss) command is issued from a PP determined by                                                          the L2C_DBG[PPNUM] field.                                                          The selected L2 set# is determined by the L2C_DBG[SET]                                                          field, and the L2 index is determined from the                                                          phys_addr[13:7] associated with the LDD command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state.                                                          NOTE: The diagnostic PP should issue a d-stream load                                                          to an aligned cacheline+0x20(+0x60) in order to have the                                                          return VDLUTAG information (in OW2/OW6) written directly                                                          into the proper PP register. The diagnostic PP should also                                                          flush it's local L1 cache after use(to ensure data                                                          coherency).                                                          NOTE: The position of the VDLUTAG data in the destination                                                          register is dependent on the endian mode(big/little).                                                          NOTE: (For L2C BitMap testing of L2 Data Store OW ECC):                                                          If L2D_ERR[ECC_ENA]=0, the OW ECC from the selected                                                          half cacheline (see: L2D_ERR[BMHCLSEL] is also                                                          conditionally latched into the L2D_FSYN0/1 CSRs if an                                                          LDD command is detected from the diagnostic PP(L2C_DBG[PPNUM]). */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_9
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2c_dbg_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|3
decl_stmt|;
comment|/**< Specifies the LFB Entry# which is to be captured. */
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Dump Enable: When written(=1), the contents of                                                          the LFB specified by LFB_ENUM[2:0] are captured                                                          into the L2C_LFB(0/1/2) registers.                                                          NOTE: Some fields of the LFB entry are unpredictable                                                          and dependent on usage. This is only intended to be                                                          used for HW debug. */
name|uint64_t
name|reserved_8_9
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|2
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines which 1-of-4                                                          PPs is selected as the diagnostic PP. */
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
comment|/**< When L2C_DBG[L2T] or L2C_DBG[L2D] or L2C_DBG[FINV]                                                          is enabled, this field determines 1-of-n targeted                                                          sets to act upon.                                                          NOTE: L2C_DBG[SET] must never equal a crippled or                                                          unusable set (see UMSK* registers and Cripple mode                                                          fuses). */
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
comment|/**< Flush-Invalidate.                                                          When flush-invalidate is enable (FINV=1), all STF                                                          (L1 store-miss) commands generated from the diagnostic PP                                                          (L2C_DBG[PPNUM]) will invalidate the specified set                                                          (L2C_DBG[SET]) at the index specified in the STF                                                          address[15:7]. If a dirty block is detected (D=1), it is                                                          written back to memory. The contents of the invalid                                                          L2 Cache line is also 'scrubbed' with the STF write data.                                                          NOTE: If L2C_CFG[IDXALIAS]=1, the index specified in                                                          STF address[15:7] refers to the 'aliased' address.                                                          NOTE: An STF command with write data=ZEROES can be                                                          generated by SW using the Prefetch instruction with                                                          Hint=30d "prepare for Store", followed by a SYNCW.                                                          What is seen at the L2C as an STF w/wrdcnt=0 with all                                                          of its mask bits clear (indicates zero-fill data).                                                          A flush-invalidate will 'force-hit' the L2 cache at                                                          [index,set] and invalidate the entry (V=0/D=0/L=0/U=0).                                                          If the cache block is dirty, it is also written back                                                          to memory. The DuTag state is probed/updated as normal                                                          for an STF request.                                                          TYPICAL APPLICATIONS:                                                             1) L2 Tag/Data ECC SW Recovery                                                             2) Cache Unlocking                                                          NOTE: If the cacheline had been previously LOCKED(L=1),                                                          a flush-invalidate operation will explicitly UNLOCK                                                          (L=0) the set/index specified.                                                          NOTE: The diagnostic PP cores can generate STF                                                          commands to the L2 Cache whenever all 128 bytes in a                                                          block are written. SW must take this into consideration                                                          to avoid 'errant' Flush-Invalidates. */
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
comment|/**< When enabled (and L2C_DBG[L2T]=0), fill data is                                                          returned directly from the L2 Data Store                                                          (regardless of hit/miss) when an LDD(L1 load-miss) command                                                          is issued from a PP determined by the L2C_DBG[PPNUM]                                                          field. The selected set# is determined by the                                                          L2C_DBG[SET] field, and the index is determined                                                          from the address[15:7] associated with the LDD                                                          command.                                                          This 'force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state. */
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
comment|/**< When enabled, L2 Tag information [V,D,L,U,phys_addr[33:16]]                                                          is returned on the data bus starting at +32(and +96) bytes                                                          offset from the beginning of cacheline when an LDD                                                          (L1 load-miss) command is issued from a PP determined by                                                          the L2C_DBG[PPNUM] field.                                                          The selected L2 set# is determined by the L2C_DBG[SET]                                                          field, and the L2 index is determined from the                                                          phys_addr[15:7] associated with the LDD command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state.                                                          NOTE: The diagnostic PP should issue a d-stream load                                                          to an aligned cacheline+0x20(+0x60) in order to have the                                                          return VDLUTAG information (in OW2/OW6) written directly                                                          into the proper PP register. The diagnostic PP should also                                                          flush it's local L1 cache after use(to ensure data                                                          coherency).                                                          NOTE: The position of the VDLUTAG data in the destination                                                          register is dependent on the endian mode(big/little).                                                          NOTE: (For L2C BitMap testing of L2 Data Store OW ECC):                                                          If L2D_ERR[ECC_ENA]=0, the OW ECC from the selected                                                          half cacheline (see: L2D_ERR[BMHCLSEL] is also                                                          conditionally latched into the L2D_FSYN0/1 CSRs if an                                                          LDD command is detected from the diagnostic PP(L2C_DBG[PPNUM]). */
else|#
directive|else
name|uint64_t
name|l2t
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2d
range|:
literal|1
decl_stmt|;
name|uint64_t
name|finv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ppnum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_9
range|:
literal|2
decl_stmt|;
name|uint64_t
name|lfb_dmp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lfb_enum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_l2c_dbg_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_dbg_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_dbg_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_dbg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_dbg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_dbg
name|cvmx_l2c_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_dut  *  * L2C_DUT = L2C DUTAG Register  *  * Description: L2C Duplicate Tag State Register  *  * Notes:  * (1) When using the L2T, L2D or FINV Debug probe feature, an LDD command issued by the diagnostic PP  *     WILL NOT update the DuTags.  * (2) L2T, L2D, FINV MUST BE mutually exclusive (only one enabled at a time).  * (3) Force Invalidate is intended as a means for SW to invalidate the L2 Cache while also writing back  *     dirty data to memory to maintain coherency. (A side effect of FINV is that an LDD L2 fill is  *     launched which fills data into the L2 DS).  */
end_comment

begin_union
union|union
name|cvmx_l2c_dut
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_dut_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|dtena
range|:
literal|1
decl_stmt|;
comment|/**< DuTag Diagnostic read enable.                                                          When L2C_DUT[DTENA]=1, all LDD(L1 load-miss)                                                          commands issued from the diagnostic PP                                                          (L2C_DBG[PPNUM]) will capture the DuTag state (V|L1TAG)                                                          of the PP#(specified in the LDD address[29:26] into                                                          the L2C_DUT CSR register. This allows the diagPP to                                                          read ALL DuTags (from any PP).                                                          The DuTag Set# to capture is extracted from the LDD                                                          address[25:20]. The diagnostic PP would issue the                                                          LDD then read the L2C_DUT register (one at a time).                                                          This LDD 'L2 force-hit' will NOT alter the current L2                                                          Tag State OR the DuTag state.                                                          NOTE: For CN58XX the DuTag SIZE has doubled (to 16KB)                                                          where each DuTag is organized as 2x 64-way entries.                                                          The LDD address[7] determines which 1(of-2) internal                                                          64-ways to select.                                                          The fill data is returned directly from the L2 Data                                                          Store(regardless of hit/miss) when an LDD command                                                          is issued from a PP determined by the L2C_DBG[PPNUM]                                                          field. The selected L2 Set# is determined by the                                                          L2C_DBG[SET] field, and the index is determined                                                          from the address[17:7] associated with the LDD                                                          command.                                                          This 'L2 force-hit' will NOT alter the current L2 Tag                                                          state OR the DuTag state.                                                          NOTE: In order for the DiagPP to generate an LDD command                                                          to the L2C, it must first force an L1 Dcache flush. */
name|uint64_t
name|reserved_30_30
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dt_vld
range|:
literal|1
decl_stmt|;
comment|/**< Duplicate L1 Tag Valid bit latched in for previous                                                          LDD(L1 load-miss) command sourced by diagnostic PP. */
name|uint64_t
name|dt_tag
range|:
literal|29
decl_stmt|;
comment|/**< Duplicate L1 Tag[35:7] latched in for previous                                                          LDD(L1 load-miss) command sourced by diagnostic PP. */
else|#
directive|else
name|uint64_t
name|dt_tag
range|:
literal|29
decl_stmt|;
name|uint64_t
name|dt_vld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_30
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dtena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_dut_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_dut
name|cvmx_l2c_dut_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_dut_map#  *  * L2C_DUT_MAP = L2C DUT memory map region  *  * Description: Address of the start of the region mapped to the duplicate tag.  Can be used to read  * and write the raw duplicate tag CAM.  Writes should be used only with great care as they can easily  * destroy the coherency of the memory system.  In any case this region is expected to only be used  * for debug.  *  * This base address should be combined with PP virtual ID, L1 way and L1 set to produce the final  * address as follows:  *     addr<63:13>      L2C_DUT_MAP<63:13>  *     addr<12:11>      PP VID  *     addr<10:6>       L1 way  *     addr<5:3>        L1 set  *     addr<2:0>        UNUSED  *  * Notes:  * (1) The tag is 37:10 from the 38-bit OCTEON physical address after hole removal. (The hole is between DR0  * and DR1. Remove the hole by subtracting 256MB from 38-bit OCTEON L2/DRAM physical addresses>= 512 MB.)  */
end_comment

begin_union
union|union
name|cvmx_l2c_dut_mapx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_dut_mapx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|28
decl_stmt|;
comment|/**< The tag value (see Note 1) */
name|uint64_t
name|reserved_1_9
range|:
literal|9
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/**< The valid bit */
else|#
directive|else
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_9
range|:
literal|9
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|28
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_dut_mapx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_dut_mapx
name|cvmx_l2c_dut_mapx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_err_tdt#  *  * L2C_ERR_TDT = L2C TAD DaTa Error Info  *  *  * Notes:  * (1) If the status bit corresponding to the value of the TYPE field is not set the WAYIDX/SYN fields  *     are not associated with the errors currently logged by the status bits and should be ignored.  *     This can occur, for example, because of a race between a write to clear a DBE and a new, lower  *     priority, SBE error occuring.  If the SBE arrives prior to the DBE clear the WAYIDX/SYN fields  *     will still be locked, but the new SBE error status bit will still be set.  *  * (2) The four types of errors have differing priorities.  Priority (from lowest to highest) is SBE,  *     VSBE, DBE, VDBE.  A error will lock the WAYIDX, and SYN fields for other errors of equal or  *     lower priority until cleared by software.  This means that the error information is always  *     (assuming the TYPE field matches) for the highest priority error logged in the status bits.  *  * (3) If VSBE or VDBE are set (and the TYPE field matches), the WAYIDX fields are valid and the  *     syndrome can be found in L2C_ERR_VBF.  *  * (4) The syndrome is recorded for DBE errors, though the utility of the value is not clear.  */
end_comment

begin_union
union|union
name|cvmx_l2c_err_tdtx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_err_tdtx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double-Bit error has occurred */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single-Bit error has occurred */
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit error has occurred */
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit error has occurred */
name|uint64_t
name|syn
range|:
literal|10
decl_stmt|;
comment|/**< L2D syndrome (valid only for SBE/DBE, not VSBE/VDBE) */
name|uint64_t
name|reserved_22_49
range|:
literal|28
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|18
decl_stmt|;
comment|/**< Way, index, OW of the L2 block containing the error */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the WAYIDX,SYN were latched for.                                                          0 - VSBE                                                          1 - VDBE                                                          2 - SBE                                                          3 - DBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_22_49
range|:
literal|28
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|10
decl_stmt|;
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_err_tdtx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double-Bit error has occurred */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single-Bit error has occurred */
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit error has occurred */
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit error has occurred */
name|uint64_t
name|syn
range|:
literal|10
decl_stmt|;
comment|/**< L2D syndrome (valid only for SBE/DBE, not VSBE/VDBE) */
name|uint64_t
name|reserved_20_49
range|:
literal|30
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|16
decl_stmt|;
comment|/**< Way, index, OW of the L2 block containing the error */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the WAYIDX,SYN were latched for.                                                          0 - VSBE                                                          1 - VDBE                                                          2 - SBE                                                          3 - DBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_20_49
range|:
literal|30
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|10
decl_stmt|;
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_l2c_err_tdtx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double-Bit error has occurred */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single-Bit error has occurred */
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit error has occurred */
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit error has occurred */
name|uint64_t
name|syn
range|:
literal|10
decl_stmt|;
comment|/**< L2D syndrome (valid only for SBE/DBE, not VSBE/VDBE) */
name|uint64_t
name|reserved_21_49
range|:
literal|29
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|17
decl_stmt|;
comment|/**< Way, index, OW of the L2 block containing the error */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the WAYIDX,SYN were latched for.                                                          0 - VSBE                                                          1 - VDBE                                                          2 - SBE                                                          3 - DBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_21_49
range|:
literal|29
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|10
decl_stmt|;
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_l2c_err_tdtx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_tdtx_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_tdtx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_tdtx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_tdtx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_err_tdtx
name|cvmx_l2c_err_tdtx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_err_ttg#  *  * L2C_ERR_TTG = L2C TAD TaG Error Info  *  *  * Notes:  * (1) The priority of errors (highest to lowest) is DBE, SBE, NOWAY.  An error will lock the SYN, and  *     WAYIDX fields for equal or lower priority errors until cleared by software.  *  * (2) The syndrome is recorded for DBE errors, though the utility of the value is not clear.  *  * (3) A NOWAY error does not change the value of the SYN field, and leaves WAYIDX[20:17]  *     unpredictable.  WAYIDX[16:7] is the L2 block index associated with the command which had no way  *     to allocate.  *  * (4) If the status bit corresponding to the value of the TYPE field is not set the WAYIDX/SYN fields  *     are not associated with the errors currently logged by the status bits and should be ignored.  *     This can occur, for example, because of a race between a write to clear a DBE and a new, lower  *     priority, SBE error occuring.  If the SBE arrives prior to the DBE clear the WAYIDX/SYN fields  *     will still be locked, but the new SBE error status bit will still be set.  */
end_comment

begin_union
union|union
name|cvmx_l2c_err_ttgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_err_ttgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< Double-Bit ECC error */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< Single-Bit ECC error */
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
comment|/**< No way was available for allocation.                                                          L2C sets NOWAY during its processing of a                                                          transaction whenever it needed/wanted to allocate                                                          a WAY in the L2 cache, but was unable to. NOWAY==1                                                          is (generally) not an indication that L2C failed to                                                          complete transactions. Rather, it is a hint of                                                          possible performance degradation. (For example, L2C                                                          must read-modify-write DRAM for every transaction                                                          that updates some, but not all, of the bytes in a                                                          cache block, misses in the L2 cache, and cannot                                                          allocate a WAY.) There is one "failure" case where                                                          L2C will set NOWAY: when it cannot leave a block                                                          locked in the L2 cache as part of a LCKL2                                                          transaction. */
name|uint64_t
name|reserved_56_60
range|:
literal|5
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|6
decl_stmt|;
comment|/**< Syndrome for the single-bit error */
name|uint64_t
name|reserved_22_49
range|:
literal|28
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|15
decl_stmt|;
comment|/**< Way and index of the L2 block containing the error */
name|uint64_t
name|reserved_2_6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the WAYIDX,SYN were latched for.                                                          0 - not valid                                                          1 - NOWAY                                                          2 - SBE                                                          3 - DBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|15
decl_stmt|;
name|uint64_t
name|reserved_22_49
range|:
literal|28
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_56_60
range|:
literal|5
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_err_ttgx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< Double-Bit ECC error */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< Single-Bit ECC error */
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
comment|/**< No way was available for allocation.                                                          L2C sets NOWAY during its processing of a                                                          transaction whenever it needed/wanted to allocate                                                          a WAY in the L2 cache, but was unable to. NOWAY==1                                                          is (generally) not an indication that L2C failed to                                                          complete transactions. Rather, it is a hint of                                                          possible performance degradation. (For example, L2C                                                          must read-modify-write DRAM for every transaction                                                          that updates some, but not all, of the bytes in a                                                          cache block, misses in the L2 cache, and cannot                                                          allocate a WAY.) There is one "failure" case where                                                          L2C will set NOWAY: when it cannot leave a block                                                          locked in the L2 cache as part of a LCKL2                                                          transaction. */
name|uint64_t
name|reserved_56_60
range|:
literal|5
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|6
decl_stmt|;
comment|/**< Syndrome for the single-bit error */
name|uint64_t
name|reserved_20_49
range|:
literal|30
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|13
decl_stmt|;
comment|/**< Way and index of the L2 block containing the error */
name|uint64_t
name|reserved_2_6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the WAYIDX,SYN were latched for.                                                          0 - not valid                                                          1 - NOWAY                                                          2 - SBE                                                          3 - DBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|13
decl_stmt|;
name|uint64_t
name|reserved_20_49
range|:
literal|30
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_56_60
range|:
literal|5
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_l2c_err_ttgx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
comment|/**< Double-Bit ECC error */
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
comment|/**< Single-Bit ECC error */
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
comment|/**< No way was available for allocation.                                                          L2C sets NOWAY during its processing of a                                                          transaction whenever it needed/wanted to allocate                                                          a WAY in the L2 cache, but was unable to. NOWAY==1                                                          is (generally) not an indication that L2C failed to                                                          complete transactions. Rather, it is a hint of                                                          possible performance degradation. (For example, L2C                                                          must read-modify-write DRAM for every transaction                                                          that updates some, but not all, of the bytes in a                                                          cache block, misses in the L2 cache, and cannot                                                          allocate a WAY.) There is one "failure" case where                                                          L2C will set NOWAY: when it cannot leave a block                                                          locked in the L2 cache as part of a LCKL2                                                          transaction. */
name|uint64_t
name|reserved_56_60
range|:
literal|5
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|6
decl_stmt|;
comment|/**< Syndrome for the single-bit error */
name|uint64_t
name|reserved_21_49
range|:
literal|29
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|14
decl_stmt|;
comment|/**< Way and index of the L2 block containing the error */
name|uint64_t
name|reserved_2_6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the WAYIDX,SYN were latched for.                                                          0 - not valid                                                          1 - NOWAY                                                          2 - SBE                                                          3 - DBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_6
range|:
literal|5
decl_stmt|;
name|uint64_t
name|wayidx
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_21_49
range|:
literal|29
decl_stmt|;
name|uint64_t
name|syn
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_56_60
range|:
literal|5
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbe
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_l2c_err_ttgx_cn63xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_ttgx_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_ttgx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_ttgx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_ttgx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_err_ttgx
name|cvmx_l2c_err_ttgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_err_vbf#  *  * L2C_ERR_VBF = L2C VBF Error Info  *  *  * Notes:  * (1) The way/index information is stored in L2C_ERR_TDT, assuming no later interrupt occurred to  *     overwrite the information.  See the notes associated with L2C_ERR_TDT for full details.  *  * (2) The first VSBE will lock the register for other VSBE's.  A VDBE, however, will overwrite a  *     previously logged VSBE.  Once a VDBE has been logged all later errors will not be logged.  This  *     means that if VDBE is set the information in the register is for the VDBE, if VDBE is clear and  *     VSBE is set the register contains information about the VSBE.  *  * (3) The syndrome is recorded for VDBE errors, though the utility of the value is not clear.  *  * (4) If the status bit corresponding to the value of the TYPE field is not set the SYN field is not  *     associated with the errors currently logged by the status bits and should be ignored.  This can  *     occur, for example, because of a race between a write to clear a VDBE and a new, lower priority,  *     VSBE error occuring.  If the VSBE arrives prior to the VDBE clear the SYN field will still be  *     locked, but the new VSBE error status bit will still be set.  */
end_comment

begin_union
union|union
name|cvmx_l2c_err_vbfx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_err_vbfx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit error has occurred */
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit error has occurred */
name|uint64_t
name|vsyn
range|:
literal|10
decl_stmt|;
comment|/**< VBF syndrome (valid only if VSBE/VDBE is set) */
name|uint64_t
name|reserved_2_49
range|:
literal|48
decl_stmt|;
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
comment|/**< The type of error the SYN were latched for.                                                          0 - VSBE                                                          1 - VDBE */
else|#
directive|else
name|uint64_t
name|type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_49
range|:
literal|48
decl_stmt|;
name|uint64_t
name|vsyn
range|:
literal|10
decl_stmt|;
name|uint64_t
name|vsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_vbfx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_err_vbfx
name|cvmx_l2c_err_vbfx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_err_xmc  *  * L2C_ERR_XMC = L2C XMC request error  *  * Description: records error information for HOLE*, BIG* and VRT* interrupts.  *  * Notes:  * (1) The first BIGWR/HOLEWR/VRT* interrupt will lock the register until L2C_INT_REG[6:1] are  *     cleared.  *  * (2) ADDR<15:0> will always be zero for VRT* interrupts.  *  * (3) ADDR is the 38-bit OCTEON physical address after hole removal. (The hole is between DR0  *     and DR1. Remove the hole by subtracting 256MB from all 38-bit OCTEON L2/DRAM physical addresses  *>= 512 MB.)  *  * (4) For 63xx pass 2.0 and all 68xx ADDR<15:0> will ALWAYS be zero.  */
end_comment

begin_union
union|union
name|cvmx_l2c_err_xmc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_err_xmc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
comment|/**< XMC command or request causing error */
name|uint64_t
name|reserved_54_57
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|6
decl_stmt|;
comment|/**< XMC sid of request causing error */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
comment|/**< XMC address causing the error (see Notes 2 and 3) */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_57
range|:
literal|4
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_err_xmc_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
comment|/**< XMC command or request causing error */
name|uint64_t
name|reserved_52_57
range|:
literal|6
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|4
decl_stmt|;
comment|/**< XMC sid of request causing error */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
comment|/**< XMC address causing the error (see Notes 2 and 3) */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_52_57
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_l2c_err_xmc_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_xmc_cn61xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_err_xmc_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
comment|/**< XMC command or request causing error */
name|uint64_t
name|reserved_53_57
range|:
literal|5
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|5
decl_stmt|;
comment|/**< XMC sid of request causing error */
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
comment|/**< XMC address causing the error (see Notes 2 and 3) */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_47
range|:
literal|10
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_53_57
range|:
literal|5
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_l2c_err_xmc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_err_xmc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_err_xmc_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_err_xmc
name|cvmx_l2c_err_xmc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_grpwrr0  *  * L2C_GRPWRR0 = L2C PP Weighted Round \#0 Register  *  * Description: Defines Weighted rounds(32) for Group PLC0,PLC1  *  * Notes:  * - Starvation of a group 'could' occur, unless SW takes the precaution to ensure that each GROUP  * participates in at least 1(of 32) rounds (ie: At least 1 bit(of 32) should be clear).  */
end_comment

begin_union
union|union
name|cvmx_l2c_grpwrr0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_grpwrr0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|plc1rmsk
range|:
literal|32
decl_stmt|;
comment|/**< PLC1 Group#1 Weighted Round Mask                                                          Each bit represents 1 of 32 rounds                                                          for Group \#1's participation. When a 'round' bit is                                                          set, Group#1 is 'masked' and DOES NOT participate.                                                          When a 'round' bit is clear, Group#1 WILL                                                          participate in the arbitration for this round. */
name|uint64_t
name|plc0rmsk
range|:
literal|32
decl_stmt|;
comment|/**< PLC Group#0 Weighted Round Mask                                                          Each bit represents 1 of 32 rounds                                                          for Group \#0's participation. When a 'round' bit is                                                          set, Group#0 is 'masked' and DOES NOT participate.                                                          When a 'round' bit is clear, Group#0 WILL                                                          participate in the arbitration for this round. */
else|#
directive|else
name|uint64_t
name|plc0rmsk
range|:
literal|32
decl_stmt|;
name|uint64_t
name|plc1rmsk
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_grpwrr0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_grpwrr0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_grpwrr0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_grpwrr0_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_grpwrr0
name|cvmx_l2c_grpwrr0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_grpwrr1  *  * L2C_GRPWRR1 = L2C PP Weighted Round \#1 Register  *  * Description: Defines Weighted Rounds(32) for Group PLC2,ILC  *  * Notes:  * - Starvation of a group 'could' occur, unless SW takes the precaution to ensure that each GROUP  * participates in at least 1(of 32) rounds (ie: At least 1 bit(of 32) should be clear).  */
end_comment

begin_union
union|union
name|cvmx_l2c_grpwrr1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_grpwrr1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|ilcrmsk
range|:
literal|32
decl_stmt|;
comment|/**< ILC (IOB) Weighted Round Mask                                                          Each bit represents 1 of 32 rounds                                                          for IOB participation. When a 'round' bit is                                                          set, IOB is 'masked' and DOES NOT participate.                                                          When a 'round' bit is clear, IOB WILL                                                          participate in the arbitration for this round. */
name|uint64_t
name|plc2rmsk
range|:
literal|32
decl_stmt|;
comment|/**< PLC Group#2 Weighted Round Mask                                                          Each bit represents 1 of 32 rounds                                                          for Group \#2's participation. When a 'round' bit is                                                          set, Group#2 is 'masked' and DOES NOT participate.                                                          When a 'round' bit is clear, Group#2 WILL                                                          participate in the arbitration for this round. */
else|#
directive|else
name|uint64_t
name|plc2rmsk
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ilcrmsk
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_grpwrr1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_grpwrr1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_grpwrr1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_grpwrr1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_grpwrr1
name|cvmx_l2c_grpwrr1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_int_en  *  * L2C_INT_EN = L2C Global Interrupt Enable Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|lck2ena
range|:
literal|1
decl_stmt|;
comment|/**< L2 Tag Lock Error2 Interrupt Enable bit                                                          NOTE: This is the 'same' bit as L2T_ERR[LCK_INTENA2] */
name|uint64_t
name|lckena
range|:
literal|1
decl_stmt|;
comment|/**< L2 Tag Lock Error Interrupt Enable bit                                                          NOTE: This is the 'same' bit as L2T_ERR[LCK_INTENA] */
name|uint64_t
name|l2ddeden
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data ECC Double Error Detect(DED) Interrupt Enable bit                                                          When set, allows interrupts to be reported on double bit                                                          (uncorrectable) errors from the L2 Data Arrays.                                                          NOTE: This is the 'same' bit as L2D_ERR[DED_INTENA] */
name|uint64_t
name|l2dsecen
range|:
literal|1
decl_stmt|;
comment|/**< L2 Data ECC Single Error Correct(SEC) Interrupt Enable bit                                                          When set, allows interrupts to be reported on single bit                                                          (correctable) errors from the L2 Data Arrays.                                                          NOTE: This is the 'same' bit as L2D_ERR[SEC_INTENA] */
name|uint64_t
name|l2tdeden
range|:
literal|1
decl_stmt|;
comment|/**< L2 Tag ECC Double Error Detect(DED) Interrupt                                                          NOTE: This is the 'same' bit as L2T_ERR[DED_INTENA] */
name|uint64_t
name|l2tsecen
range|:
literal|1
decl_stmt|;
comment|/**< L2 Tag ECC Single Error Correct(SEC) Interrupt                                                          Enable bit. When set, allows interrupts to be                                                          reported on single bit (correctable) errors from                                                          the L2 Tag Arrays.                                                          NOTE: This is the 'same' bit as L2T_ERR[SEC_INTENA] */
name|uint64_t
name|oob3en
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Interrupt Enable Range#3 */
name|uint64_t
name|oob2en
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Interrupt Enable Range#2 */
name|uint64_t
name|oob1en
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Interrupt Enable Range#1 */
else|#
directive|else
name|uint64_t
name|oob1en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oob2en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oob3en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2tsecen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2tdeden
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dsecen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2ddeden
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lckena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lck2ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_int_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_int_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_en_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_int_en
name|cvmx_l2c_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_int_ena  *  * L2C_INT_ENA = L2C Interrupt Enable  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_int_ena
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_int_ena_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|bigrd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference past MAXDRAM enable */
name|uint64_t
name|bigwr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference past MAXDRAM enable */
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization memory parity error */
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
comment|/**< Address outside of virtualization range enable */
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID out of range enable */
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID prevented a write enable */
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference to 256MB hole enable */
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference to 256MB hole enable */
else|#
directive|else
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bigwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bigrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_int_ena_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_ena_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_l2c_int_ena_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization memory parity error */
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
comment|/**< Address outside of virtualization range enable */
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID out of range enable */
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID prevented a write enable */
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference to 256MB hole enable */
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference to 256MB hole enable */
else|#
directive|else
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_l2c_int_ena_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_ena_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_ena_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_int_ena_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_int_ena
name|cvmx_l2c_int_ena_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_int_reg  *  * L2C_INT_REG = L2C Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_int_reg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
name|uint64_t
name|tad3
range|:
literal|1
decl_stmt|;
comment|/**< When set, the enabled interrupt is in                                                          the L2C_TAD3_INT CSR */
name|uint64_t
name|tad2
range|:
literal|1
decl_stmt|;
comment|/**< When set, the enabled interrupt is in                                                          the L2C_TAD2_INT CSR */
name|uint64_t
name|tad1
range|:
literal|1
decl_stmt|;
comment|/**< When set, the enabled interrupt is in                                                          the L2C_TAD1_INT CSR */
name|uint64_t
name|tad0
range|:
literal|1
decl_stmt|;
comment|/**< When set, the enabled interrupt is in                                                          the L2C_TAD0_INT CSR */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bigrd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference past L2C_BIG_CTL[MAXDRAM] occurred */
name|uint64_t
name|bigwr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference past L2C_BIG_CTL[MAXDRAM] occurred */
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
comment|/**< L2C_VRT_MEM read found a parity error                                                          Whenever an L2C_VRT_MEM read finds a parity error,                                                          that L2C_VRT_MEM cannot cause stores to be blocked.                                                          Software should correct the error. */
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
comment|/**< Address outside of virtualization range                                                          Set when a L2C_VRT_CTL[MEMSZ] violation blocked a                                                          store.                                                          L2C_VRT_CTL[OOBERR] must be set for L2C to set this. */
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID out of range                                                          Set when a L2C_VRT_CTL[NUMID] violation blocked a                                                          store. */
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID prevented a write                                                          Set when L2C_VRT_MEM blocked a store. */
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference to 256MB hole occurred */
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference to 256MB hole occurred */
else|#
directive|else
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bigwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bigrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tad0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tad1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tad2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tad3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_20_63
range|:
literal|44
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_int_reg_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|tad0
range|:
literal|1
decl_stmt|;
comment|/**< When set, the enabled interrupt is in                                                          the L2C_TAD0_INT CSR */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bigrd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference past L2C_BIG_CTL[MAXDRAM] occurred */
name|uint64_t
name|bigwr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference past L2C_BIG_CTL[MAXDRAM] occurred */
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
comment|/**< L2C_VRT_MEM read found a parity error                                                          Whenever an L2C_VRT_MEM read finds a parity error,                                                          that L2C_VRT_MEM cannot cause stores to be blocked.                                                          Software should correct the error. */
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
comment|/**< Address outside of virtualization range                                                          Set when a L2C_VRT_CTL[MEMSZ] violation blocked a                                                          store.                                                          L2C_VRT_CTL[OOBERR] must be set for L2C to set this. */
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID out of range                                                          Set when a L2C_VRT_CTL[NUMID] violation blocked a                                                          store. */
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID prevented a write                                                          Set when L2C_VRT_MEM blocked a store. */
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference to 256MB hole occurred */
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference to 256MB hole occurred */
else|#
directive|else
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bigwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bigrd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tad0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_l2c_int_reg_cn61xx
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_l2c_int_reg_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|tad0
range|:
literal|1
decl_stmt|;
comment|/**< When set, the enabled interrupt is in either                                                          the L2C_ERR_TDT0 or L2C_ERR_TTG0 CSR */
name|uint64_t
name|reserved_6_15
range|:
literal|10
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
comment|/**< L2C_VRT_MEM read found a parity error                                                          Whenever an L2C_VRT_MEM read finds a parity error,                                                          that L2C_VRT_MEM cannot cause stores to be blocked.                                                          Software should correct the error. */
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
comment|/**< Address outside of virtualization range                                                          Set when a L2C_VRT_CTL[MEMSZ] violation blocked a                                                          store.                                                          L2C_VRT_CTL[OOBERR] must be set for L2C to set this. */
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID out of range                                                          Set when a L2C_VRT_CTL[NUMID] violation blocked a                                                          store. */
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
comment|/**< Virtualization ID prevented a write                                                          Set when L2C_VRT_MEM blocked a store. */
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
comment|/**< Write reference to 256MB hole occurred */
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
comment|/**< Read reference to 256MB hole occurred */
else|#
directive|else
name|uint64_t
name|holerd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|holewr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtwr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtidrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtadrng
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vrtpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_15
range|:
literal|10
decl_stmt|;
name|uint64_t
name|tad0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_l2c_int_reg_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_reg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_reg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_int_reg_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_int_reg
name|cvmx_l2c_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_int_stat  *  * L2C_INT_STAT = L2C Global Interrupt Status Register  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_int_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_int_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|lck2
range|:
literal|1
decl_stmt|;
comment|/**< HW detected a case where a Rd/Wr Miss from PP#n                                                          could not find an available/unlocked set (for                                                          replacement).                                                          Most likely, this is a result of SW mixing SET                                                          PARTITIONING with ADDRESS LOCKING. If SW allows                                                          another PP to LOCKDOWN all SETs available to PP#n,                                                          then a Rd/Wr Miss from PP#n will be unable                                                          to determine a 'valid' replacement set (since LOCKED                                                          addresses should NEVER be replaced).                                                          If such an event occurs, the HW will select the smallest                                                          available SET(specified by UMSK'x)' as the replacement                                                          set, and the address is unlocked.                                                          NOTE: This is the 'same' bit as L2T_ERR[LCKERR2] */
name|uint64_t
name|lck
range|:
literal|1
decl_stmt|;
comment|/**< SW attempted to LOCK DOWN the last available set of                                                          the INDEX (which is ignored by HW - but reported to SW).                                                          The LDD(L1 load-miss) for the LOCK operation is completed                                                          successfully, however the address is NOT locked.                                                          NOTE: 'Available' sets takes the L2C_SPAR*[UMSK*]                                                          into account. For example, if diagnostic PPx has                                                          UMSKx defined to only use SETs [1:0], and SET1 had                                                          been previously LOCKED, then an attempt to LOCK the                                                          last available SET0 would result in a LCKERR. (This                                                          is to ensure that at least 1 SET at each INDEX is                                                          not LOCKED for general use by other PPs).                                                          NOTE: This is the 'same' bit as L2T_ERR[LCKERR] */
name|uint64_t
name|l2dded
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double Error detected (DED)                                                          NOTE: This is the 'same' bit as L2D_ERR[DED_ERR] */
name|uint64_t
name|l2dsec
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single Error corrected (SEC)                                                          NOTE: This is the 'same' bit as L2D_ERR[SEC_ERR] */
name|uint64_t
name|l2tded
range|:
literal|1
decl_stmt|;
comment|/**< L2T Double Bit Error detected (DED)                                                          During every L2 Tag Probe, all 8 sets Tag's (at a                                                          given index) are checked for double bit errors(DBEs).                                                          This bit is set if ANY of the 8 sets contains a DBE.                                                          DBEs also generated an interrupt(if enabled).                                                          NOTE: This is the 'same' bit as L2T_ERR[DED_ERR] */
name|uint64_t
name|l2tsec
range|:
literal|1
decl_stmt|;
comment|/**< L2T Single Bit Error corrected (SEC) status                                                          During every L2 Tag Probe, all 8 sets Tag's (at a                                                          given index) are checked for single bit errors(SBEs).                                                          This bit is set if ANY of the 8 sets contains an SBE.                                                          SBEs are auto corrected in HW and generate an                                                          interrupt(if enabled).                                                          NOTE: This is the 'same' bit as L2T_ERR[SEC_ERR] */
name|uint64_t
name|oob3
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Interrupt Status Range#3 */
name|uint64_t
name|oob2
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Interrupt Status Range#2 */
name|uint64_t
name|oob1
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Interrupt Status Range#1 */
else|#
directive|else
name|uint64_t
name|oob1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oob2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oob3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2tsec
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2tded
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dsec
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2dded
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lck2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_int_stat_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_stat_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_int_stat_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_int_stat_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_int_stat
name|cvmx_l2c_int_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ioc#_pfc  *  * L2C_IOC_PFC = L2C IOC Performance Counter(s)  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_iocx_pfc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_iocx_pfc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_iocx_pfc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_iocx_pfc
name|cvmx_l2c_iocx_pfc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ior#_pfc  *  * L2C_IOR_PFC = L2C IOR Performance Counter(s)  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_iorx_pfc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_iorx_pfc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_iorx_pfc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_iorx_pfc
name|cvmx_l2c_iorx_pfc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_lckbase  *  * L2C_LCKBASE = L2C LockDown Base Register  *  * Description: L2C LockDown Base Register  *  * Notes:  * (1) SW RESTRICTION \#1: SW must manage the L2 Data Store lockdown space such that at least 1  *     set per cache line remains in the 'unlocked' (normal) state to allow general caching operations.  *     If SW violates this restriction, a status bit is set (LCK_ERR) and an interrupt is posted.  *     [this limits the total lockdown space to 7/8ths of the total L2 data store = 896KB]  * (2) IOB initiated LDI commands are ignored (only PP initiated LDI/LDD commands are considered  *     for lockdown).  * (3) To 'unlock' a locked cache line, SW can use the FLUSH-INVAL CSR mechanism (see L2C_DBG[FINV]).  * (4) LCK_ENA MUST only be activated when debug modes are disabled (L2C_DBG[L2T], L2C_DBG[L2D], L2C_DBG[FINV]).  */
end_comment

begin_union
union|union
name|cvmx_l2c_lckbase
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_lckbase_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|lck_base
range|:
literal|27
decl_stmt|;
comment|/**< Base Memory block address[33:7]. Specifies the                                                          starting address of the lockdown region. */
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lck_ena
range|:
literal|1
decl_stmt|;
comment|/**< L2 Cache Lock Enable                                                          When the LCK_ENA=1, all LDI(I-stream Load) or                                                          LDD(L1 load-miss) commands issued from the                                                          diagnostic PP (specified by the L2C_DBG[PPNUM]),                                                          which fall within a predefined lockdown address                                                          range (specified by: [lck_base:lck_base+lck_offset])                                                          are LOCKED in the L2 cache. The LOCKED state is                                                          denoted using an explicit L2 Tag bit (L=1).                                                          If the LOCK request L2-Hits (on ANY SET), then data is                                                          returned from the L2 and the hit set is updated to the                                                          LOCKED state. NOTE: If the Hit Set# is outside the                                                          available sets for a given PP (see UMSK'x'), the                                                          the LOCK bit is still SET. If the programmer's intent                                                          is to explicitly LOCK addresses into 'available' sets,                                                          care must be taken to flush-invalidate the cache first                                                          (to avoid such situations). Not following this procedure                                                          can lead to LCKERR2 interrupts.                                                          If the LOCK request L2-Misses, a replacment set is                                                          chosen(from the available sets (UMSK'x').                                                          If the replacement set contains a dirty-victim it is                                                          written back to memory. Memory read data is then written                                                          into the replacement set, and the replacment SET is                                                          updated to the LOCKED state(L=1).                                                          NOTE: SETs that contain LOCKED addresses are                                                          excluded from the replacement set selection algorithm.                                                          NOTE: The LDD command will allocate the DuTag as normal.                                                          NOTE: If L2C_CFG[IDXALIAS]=1, the address is 'aliased' first                                                          before being checked against the lockdown address                                                          range. To ensure an 'aliased' address is properly locked,                                                          it is recommmended that SW preload the 'aliased' locked adddress                                                          into the L2C_LCKBASE[LCK_BASE] register (while keeping                                                          L2C_LCKOFF[LCK_OFFSET]=0).                                                          NOTE: The OCTEON(N3) implementation only supports 16GB(MAX) of                                                          physical memory. Therefore, only byte address[33:0] are used                                                          (ie: address[35:34] are ignored). */
else|#
directive|else
name|uint64_t
name|lck_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_3
range|:
literal|3
decl_stmt|;
name|uint64_t
name|lck_base
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckbase_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_lckbase
name|cvmx_l2c_lckbase_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_lckoff  *  * L2C_LCKOFF = L2C LockDown OFFSET Register  *  * Description: L2C LockDown OFFSET Register  *  * Notes:  * (1) The generation of the end lockdown block address will 'wrap'.  * (2) The minimum granularity for lockdown is 1 cache line (= 128B block)  */
end_comment

begin_union
union|union
name|cvmx_l2c_lckoff
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_lckoff_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|lck_offset
range|:
literal|10
decl_stmt|;
comment|/**< LockDown block Offset. Used in determining                                                          the ending block address of the lockdown                                                          region:                                                          End Lockdown block Address[33:7] =                                                          LCK_BASE[33:7]+LCK_OFFSET[9:0] */
else|#
directive|else
name|uint64_t
name|lck_offset
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_lckoff_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_lckoff
name|cvmx_l2c_lckoff_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_lfb0  *  * L2C_LFB0 = L2C LFB DEBUG 0 Register  *  * Description: L2C LFB Contents (Status Bits)  */
end_comment

begin_union
union|union
name|cvmx_l2c_lfb0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC Pending Status */
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Pending Status */
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Invalidate Status */
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC=FAIL Status */
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
comment|/**< Valid Full Address Match Status */
name|uint64_t
name|inxt
range|:
literal|4
decl_stmt|;
comment|/**< Next LFB Pointer(invalid if ITL=1) */
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
comment|/**< LFB Tail of List Indicator */
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
comment|/**< LFB Head of List Indicator */
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
comment|/**< SET# used for DS-OP (hit=hset/miss=rset) */
name|uint64_t
name|vabnum
range|:
literal|4
decl_stmt|;
comment|/**< VAB# used for LMC Miss Launch(valid only if VAM=1) */
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
comment|/**< LFB Source ID */
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
comment|/**< LFB Command */
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
comment|/**< LFB Valid */
else|#
directive|else
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|4
decl_stmt|;
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_lfb0_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC Pending Status */
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Pending Status */
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Invalidate Status */
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC=FAIL Status */
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
comment|/**< Valid Full Address Match Status */
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|2
decl_stmt|;
comment|/**< Next LFB Pointer(invalid if ITL=1) */
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
comment|/**< LFB Tail of List Indicator */
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
comment|/**< LFB Head of List Indicator */
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
comment|/**< SET# used for DS-OP (hit=hset/miss=rset) */
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|2
decl_stmt|;
comment|/**< VAB# used for LMC Miss Launch(valid only if VAM=1) */
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
comment|/**< LFB Source ID */
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
comment|/**< LFB Command */
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
comment|/**< LFB Valid */
else|#
directive|else
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_16_17
range|:
literal|2
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_25_26
range|:
literal|2
decl_stmt|;
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_lfb0_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC Pending Status */
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Pending Status */
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Invalidate Status */
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC=FAIL Status */
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
comment|/**< Valid Full Address Match Status */
name|uint64_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|3
decl_stmt|;
comment|/**< Next LFB Pointer(invalid if ITL=1) */
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
comment|/**< LFB Tail of List Indicator */
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
comment|/**< LFB Head of List Indicator */
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
comment|/**< SET# used for DS-OP (hit=hset/miss=rset) */
name|uint64_t
name|reserved_17_17
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|3
decl_stmt|;
comment|/**< VAB# used for LMC Miss Launch(valid only if VAM=1) */
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
comment|/**< LFB Source ID */
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
comment|/**< LFB Command */
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
comment|/**< LFB Valid */
else|#
directive|else
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_17_17
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_20_20
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_l2c_lfb0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb0_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb0_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC Pending Status */
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Pending Status */
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
comment|/**< LFB ST* Invalidate Status */
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
comment|/**< LFB STC=FAIL Status */
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
comment|/**< Valid Full Address Match Status */
name|uint64_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|3
decl_stmt|;
comment|/**< Next LFB Pointer(invalid if ITL=1) */
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
comment|/**< LFB Tail of List Indicator */
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
comment|/**< LFB Head of List Indicator */
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
comment|/**< SET# used for DS-OP (hit=hset/miss=rset) */
name|uint64_t
name|reserved_17_17
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|3
decl_stmt|;
comment|/**< VAB# used for LMC Miss Launch(valid only if VAM=1) */
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
comment|/**< LFB Source ID */
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
comment|/**< LFB Command */
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
comment|/**< LFB Valid */
else|#
directive|else
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sid
range|:
literal|9
decl_stmt|;
name|uint64_t
name|vabnum
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_17_17
range|:
literal|1
decl_stmt|;
name|uint64_t
name|set
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ihd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|itl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inxt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_26_26
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stinv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stcpnd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_l2c_lfb0_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb0_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_lfb0
name|cvmx_l2c_lfb0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_lfb1  *  * L2C_LFB1 = L2C LFB DEBUG 1 Register  *  * Description: L2C LFB Contents (Wait Bits)  */
end_comment

begin_union
union|union
name|cvmx_l2c_lfb1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
name|uint64_t
name|dsgoing
range|:
literal|1
decl_stmt|;
comment|/**< LFB DS Going (in flight) */
name|uint64_t
name|bid
range|:
literal|2
decl_stmt|;
comment|/**< LFB DS Bid# */
name|uint64_t
name|wtrsp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for RSC Response [FILL,STRSP] completion */
name|uint64_t
name|wtdw
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for DS-WR completion */
name|uint64_t
name|wtdq
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for LFB-DQ */
name|uint64_t
name|wtwhp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Write-Hit Partial L2 DS-WR completion */
name|uint64_t
name|wtwhf
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Write-Hit Full L2 DS-WR completion */
name|uint64_t
name|wtwrm
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Write-Miss L2 DS-WR completion */
name|uint64_t
name|wtstm
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Write-Miss L2 DS-WR completion */
name|uint64_t
name|wtrda
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Read-Miss L2 DS-WR completion */
name|uint64_t
name|wtstdt
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for all ST write Data to arrive on XMD bus */
name|uint64_t
name|wtstrsp
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for ST RSC/RSD to be issued on RSP                                                          (with invalidates) */
name|uint64_t
name|wtstrsc
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for ST RSC-Only to be issued on RSP                                                          (no-invalidates) */
name|uint64_t
name|wtvtm
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Victim Read L2 DS-RD completion */
name|uint64_t
name|wtmfl
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Memory Fill completion to MRB */
name|uint64_t
name|prbrty
range|:
literal|1
decl_stmt|;
comment|/**< Probe-Retry Detected - waiting for probe completion */
name|uint64_t
name|wtprb
range|:
literal|1
decl_stmt|;
comment|/**< LFB Waiting for Probe */
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
comment|/**< LFB Valid */
else|#
directive|else
name|uint64_t
name|vld
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtprb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prbrty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtmfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtvtm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtstrsc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtstrsp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtstdt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtrda
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtstm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtwrm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtwhf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtwhp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtdq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtdw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wtrsp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bid
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dsgoing
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_63
range|:
literal|45
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_lfb1
name|cvmx_l2c_lfb1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_lfb2  *  * L2C_LFB2 = L2C LFB DEBUG 2 Register  *  * Description: L2C LFB Contents Tag/Index  */
end_comment

begin_union
union|union
name|cvmx_l2c_lfb2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_lfb2_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|19
decl_stmt|;
comment|/**< LFB TAG[33:15] */
name|uint64_t
name|lfb_idx
range|:
literal|8
decl_stmt|;
comment|/**< LFB IDX[14:7] */
else|#
directive|else
name|uint64_t
name|lfb_idx
range|:
literal|8
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|19
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_lfb2_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|17
decl_stmt|;
comment|/**< LFB TAG[33:16] */
name|uint64_t
name|lfb_idx
range|:
literal|10
decl_stmt|;
comment|/**< LFB IDX[15:7] */
else|#
directive|else
name|uint64_t
name|lfb_idx
range|:
literal|10
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_l2c_lfb2_cn31xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb2_cn31xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb2_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|20
decl_stmt|;
comment|/**< LFB TAG[33:14] */
name|uint64_t
name|lfb_idx
range|:
literal|7
decl_stmt|;
comment|/**< LFB IDX[13:7] */
else|#
directive|else
name|uint64_t
name|lfb_idx
range|:
literal|7
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|20
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_l2c_lfb2_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|18
decl_stmt|;
comment|/**< LFB TAG[33:16] */
name|uint64_t
name|lfb_idx
range|:
literal|9
decl_stmt|;
comment|/**< LFB IDX[15:7] */
else|#
directive|else
name|uint64_t
name|lfb_idx
range|:
literal|9
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_l2c_lfb2_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb2_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|16
decl_stmt|;
comment|/**< LFB TAG[33:18] */
name|uint64_t
name|lfb_idx
range|:
literal|11
decl_stmt|;
comment|/**< LFB IDX[17:7] */
else|#
directive|else
name|uint64_t
name|lfb_idx
range|:
literal|11
decl_stmt|;
name|uint64_t
name|lfb_tag
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_l2c_lfb2_cn56xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb2_cn56xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb2_cn56xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_lfb2
name|cvmx_l2c_lfb2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_lfb3  *  * L2C_LFB3 = L2C LFB DEBUG 3 Register  *  * Description: LFB High Water Mark Register  */
end_comment

begin_union
union|union
name|cvmx_l2c_lfb3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_lfb3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|stpartdis
range|:
literal|1
decl_stmt|;
comment|/**< STP/C Performance Enhancement Disable                                                          When clear, all STP/C(store partials) will take 2 cycles                                                          to complete (power-on default).                                                          When set, all STP/C(store partials) will take 4 cycles                                                          to complete.                                                          NOTE: It is recommended to keep this bit ALWAYS ZERO. */
name|uint64_t
name|lfb_hwm
range|:
literal|4
decl_stmt|;
comment|/**< LFB High Water Mark                                                          Determines \#of LFB Entries in use before backpressure                                                          is asserted.                                                             HWM=0:   1 LFB Entry available                                                                        - ...                                                             HWM=15: 16 LFB Entries available */
else|#
directive|else
name|uint64_t
name|lfb_hwm
range|:
literal|4
decl_stmt|;
name|uint64_t
name|stpartdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_lfb3_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|stpartdis
range|:
literal|1
decl_stmt|;
comment|/**< STP/C Performance Enhancement Disable                                                          When clear, all STP/C(store partials) will take 2 cycles                                                          to complete (power-on default).                                                          When set, all STP/C(store partials) will take 4 cycles                                                          to complete.                                                          NOTE: It is recommended to keep this bit ALWAYS ZERO. */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|lfb_hwm
range|:
literal|2
decl_stmt|;
comment|/**< LFB High Water Mark                                                          Determines \#of LFB Entries in use before backpressure                                                          is asserted.                                                             HWM=0:   1 LFB Entry available                                                                        - ...                                                             HWM=3:   4 LFB Entries available */
else|#
directive|else
name|uint64_t
name|lfb_hwm
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stpartdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_lfb3_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|stpartdis
range|:
literal|1
decl_stmt|;
comment|/**< STP/C Performance Enhancement Disable                                                          When clear, all STP/C(store partials) will take 2 cycles                                                          to complete (power-on default).                                                          When set, all STP/C(store partials) will take 4 cycles                                                          to complete.                                                          NOTE: It is recommended to keep this bit ALWAYS ZERO. */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lfb_hwm
range|:
literal|3
decl_stmt|;
comment|/**< LFB High Water Mark                                                          Determines \#of LFB Entries in use before backpressure                                                          is asserted.                                                             HWM=0:   1 LFB Entry available                                                                        - ...                                                             HWM=7:   8 LFB Entries available */
else|#
directive|else
name|uint64_t
name|lfb_hwm
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stpartdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_l2c_lfb3_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_cn31xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_cn31xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_cn31xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_lfb3_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_lfb3
name|cvmx_l2c_lfb3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_oob  *  * L2C_OOB = L2C Out of Bounds Global Enables  *  * Description: Defines DMA "Out of Bounds" global enables.  */
end_comment

begin_union
union|union
name|cvmx_l2c_oob
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_oob_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dwbena
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Range Checker for DMA DWB                                                          commands (Don't WriteBack).                                                          When enabled, any DMA DWB commands which hit 1-of-3                                                          out of bounds regions will be logged into                                                          L2C_INT_STAT[OOB*] CSRs and the DMA store WILL                                                          NOT occur. If the corresponding L2C_INT_EN[OOB*]                                                          is enabled, an interrupt will also be reported. */
name|uint64_t
name|stena
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Range Checker for DMA store                                                          commands (STF/P/T).                                                          When enabled, any DMA store commands (STF/P/T) which                                                          hit 1-of-3 out of bounds regions will be logged into                                                          L2C_INT_STAT[OOB*] CSRs and the DMA store WILL                                                          NOT occur. If the corresponding L2C_INT_EN[OOB*]                                                          is enabled, an interrupt will also be reported. */
else|#
directive|else
name|uint64_t
name|stena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dwbena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_oob_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_oob_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_oob
name|cvmx_l2c_oob_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_oob1  *  * L2C_OOB1 = L2C Out of Bounds Range Checker  *  * Description: Defines DMA "Out of Bounds" region \#1. If a DMA initiated write transaction generates an address  * within the specified region, the write is 'ignored' and an interrupt is generated to alert software.  */
end_comment

begin_union
union|union
name|cvmx_l2c_oob1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_oob1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|fadr
range|:
literal|27
decl_stmt|;
comment|/**< DMA initated Memory Range Checker Failing Address                                                          When L2C_INT_STAT[OOB1]=1, this field indicates the                                                          DMA cacheline address.                                                          (addr[33:7] = full cacheline address captured)                                                          NOTE: FADR is locked down until L2C_INT_STAT[OOB1]                                                          is cleared. */
name|uint64_t
name|fsrc
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Failing Source Command                                                          When L2C_INT_STAT[OOB1]=1, this field indicates the                                                          type of DMA command.                                                           - 0: ST* (STF/P/T)                                                           - 1: DWB (Don't WriteBack)                                                          NOTE: FSRC is locked down until L2C_INT_STAT[OOB1]                                                          is cleared. */
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sadr
range|:
literal|14
decl_stmt|;
comment|/**< DMA initated Memory Range Checker Starting Address                                                          (1MB granularity) */
name|uint64_t
name|reserved_14_19
range|:
literal|6
decl_stmt|;
name|uint64_t
name|size
range|:
literal|14
decl_stmt|;
comment|/**< DMA Out of Bounds Range Checker Size                                                          (1MB granularity)                                                          Example: 0: 0MB / 1: 1MB                                                          The range check is for:                                                              (SADR<<20)<= addr[33:0]< (((SADR+SIZE)& 0x3FFF)<<20)                                                          SW NOTE: SADR+SIZE could be setup to potentially wrap                                                          the 34bit ending bounds address. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_14_19
range|:
literal|6
decl_stmt|;
name|uint64_t
name|sadr
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fsrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_oob1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_oob1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob1_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_oob1
name|cvmx_l2c_oob1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_oob2  *  * L2C_OOB2 = L2C Out of Bounds Range Checker  *  * Description: Defines DMA "Out of Bounds" region \#2. If a DMA initiated write transaction generates an address  * within the specified region, the write is 'ignored' and an interrupt is generated to alert software.  */
end_comment

begin_union
union|union
name|cvmx_l2c_oob2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_oob2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|fadr
range|:
literal|27
decl_stmt|;
comment|/**< DMA initated Memory Range Checker Failing Address                                                          When L2C_INT_STAT[OOB2]=1, this field indicates the                                                          DMA cacheline address.                                                          (addr[33:7] = full cacheline address captured)                                                          NOTE: FADR is locked down until L2C_INT_STAT[OOB2]                                                          is cleared. */
name|uint64_t
name|fsrc
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Failing Source Command                                                          When L2C_INT_STAT[OOB2]=1, this field indicates the                                                          type of DMA command.                                                           - 0: ST* (STF/P/T)                                                           - 1: DWB (Don't WriteBack)                                                          NOTE: FSRC is locked down until L2C_INT_STAT[OOB2]                                                          is cleared. */
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sadr
range|:
literal|14
decl_stmt|;
comment|/**< DMA initated Memory Range Checker Starting Address                                                          (1MB granularity) */
name|uint64_t
name|reserved_14_19
range|:
literal|6
decl_stmt|;
name|uint64_t
name|size
range|:
literal|14
decl_stmt|;
comment|/**< DMA Out of Bounds Range Checker Size                                                          (1MB granularity)                                                          Example: 0: 0MB / 1: 1MB                                                          The range check is for:                                                              (SADR<<20)<= addr[33:0]< (((SADR+SIZE)& 0x3FFF)<<20)                                                          SW NOTE: SADR+SIZE could be setup to potentially wrap                                                          the 34bit ending bounds address. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_14_19
range|:
literal|6
decl_stmt|;
name|uint64_t
name|sadr
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fsrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_oob2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_oob2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_oob2
name|cvmx_l2c_oob2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_oob3  *  * L2C_OOB3 = L2C Out of Bounds Range Checker  *  * Description: Defines DMA "Out of Bounds" region \#3. If a DMA initiated write transaction generates an address  * within the specified region, the write is 'ignored' and an interrupt is generated to alert software.  */
end_comment

begin_union
union|union
name|cvmx_l2c_oob3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_oob3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|fadr
range|:
literal|27
decl_stmt|;
comment|/**< DMA initated Memory Range Checker Failing Address                                                          When L2C_INT_STAT[OOB3]=1, this field indicates the                                                          DMA cacheline address.                                                          (addr[33:7] = full cacheline address captured)                                                          NOTE: FADR is locked down until L2C_INT_STAT[00B3]                                                          is cleared. */
name|uint64_t
name|fsrc
range|:
literal|1
decl_stmt|;
comment|/**< DMA Out of Bounds Failing Source Command                                                          When L2C_INT_STAT[OOB3]=1, this field indicates the                                                          type of DMA command.                                                           - 0: ST* (STF/P/T)                                                           - 1: DWB (Don't WriteBack)                                                          NOTE: FSRC is locked down until L2C_INT_STAT[00B3]                                                          is cleared. */
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sadr
range|:
literal|14
decl_stmt|;
comment|/**< DMA initated Memory Range Checker Starting Address                                                          (1MB granularity) */
name|uint64_t
name|reserved_14_19
range|:
literal|6
decl_stmt|;
name|uint64_t
name|size
range|:
literal|14
decl_stmt|;
comment|/**< DMA Out of Bounds Range Checker Size                                                          (1MB granularity)                                                          Example: 0: 0MB / 1: 1MB                                                          The range check is for:                                                              (SADR<<20)<= addr[33:0]< (((SADR+SIZE)& 0x3FFF)<<20)                                                          SW NOTE: SADR+SIZE could be setup to potentially wrap                                                          the 34bit ending bounds address. */
else|#
directive|else
name|uint64_t
name|size
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_14_19
range|:
literal|6
decl_stmt|;
name|uint64_t
name|sadr
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fsrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fadr
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_oob3_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob3_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_oob3_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_oob3_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_oob3
name|cvmx_l2c_oob3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_pfc#  *  * L2C_PFC0 = L2 Performance Counter \#0  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_pfcx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_pfcx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|pfcnt0
range|:
literal|36
decl_stmt|;
comment|/**< Performance Counter \#0 */
else|#
directive|else
name|uint64_t
name|pfcnt0
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfcx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_pfcx
name|cvmx_l2c_pfcx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_pfctl  *  * L2C_PFCTL = L2 Performance Counter Control Register  *  * Description: Controls the actions of the 4 Performance Counters  *  * Notes:  * - There are four 36b performance counter registers which can simultaneously count events.  * Each Counter's event is programmably selected via the corresponding CNTxSEL field:  *       CNTxSEL[5:0]    Event  *    -----------------+-----------------------  *             0       | Cycles  *             1       | L2 LDI Command Miss (NOTE: Both PP and IOB are cabable of generating LDI)  *             2       | L2 LDI Command Hit  (NOTE: Both PP and IOB are cabable of generating LDI)  *             3       | L2 non-LDI Command Miss  *             4       | L2 non-LDI Command Hit  *             5       | L2 Miss (total)  *             6       | L2 Hit (total)  *             7       | L2 Victim Buffer Hit (Retry Probe)  *             8       | LFB-NQ Index Conflict  *             9       | L2 Tag Probe (issued - could be VB-Retried)  *            10       | L2 Tag Update (completed - note: some CMD types do not update)  *            11       | L2 Tag Probe Completed (beyond VB-RTY window)  *            12       | L2 Tag Dirty Victim  *            13       | L2 Data Store NOP  *            14       | L2 Data Store READ  *            15       | L2 Data Store WRITE  *            16       | Memory Fill Data valid (1 strobe/32B)  *            17       | Memory Write Request  *            18       | Memory Read Request  *            19       | Memory Write Data valid (1 strobe/32B)  *            20       | XMC NOP (XMC Bus Idle)  *            21       | XMC LDT (Load-Through Request)  *            22       | XMC LDI (L2 Load I-Stream Request)  *            23       | XMC LDD (L2 Load D-stream Request)  *            24       | XMC STF (L2 Store Full cacheline Request)  *            25       | XMC STT (L2 Store Through Request)  *            26       | XMC STP (L2 Store Partial Request)  *            27       | XMC STC (L2 Store Conditional Request)  *            28       | XMC DWB (L2 Don't WriteBack Request)  *            29       | XMC PL2 (L2 Prefetch Request)  *            30       | XMC PSL1 (L1 Prefetch Request)  *            31       | XMC IOBLD  *            32       | XMC IOBST  *            33       | XMC IOBDMA  *            34       | XMC IOBRSP  *            35       | XMD Bus valid (all)  *            36       | XMD Bus valid (DST=L2C) Memory Data  *            37       | XMD Bus valid (DST=IOB) REFL Data  *            38       | XMD Bus valid (DST=PP) IOBRSP Data  *            39       | RSC NOP  *            40       | RSC STDN  *            41       | RSC FILL  *            42       | RSC REFL  *            43       | RSC STIN  *            44       | RSC SCIN  *            45       | RSC SCFL  *            46       | RSC SCDN  *            47       | RSD Data Valid  *            48       | RSD Data Valid (FILL)  *            49       | RSD Data Valid (STRSP)  *            50       | RSD Data Valid (REFL)  *            51       | LRF-REQ (LFB-NQ)  *            52       | DT RD-ALLOC (LDD/PSL1 Commands)  *            53       | DT WR-INVAL (ST* Commands)  */
end_comment

begin_union
union|union
name|cvmx_l2c_pfctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_pfctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|cnt3rdclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 3 Read Clear                                                          When set, all CSR reads of the L2C_PFC3                                                          register will auto-clear the counter. This allows                                                          SW to maintain 'cumulative' counters in SW.                                                          NOTE: If the CSR read occurs in the same cycle as                                                          the 'event' to be counted, the counter will                                                          properly reflect the event. */
name|uint64_t
name|cnt2rdclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 2 Read Clear                                                          When set, all CSR reads of the L2C_PFC2                                                          register will auto-clear the counter. This allows                                                          SW to maintain 'cumulative' counters in SW.                                                          NOTE: If the CSR read occurs in the same cycle as                                                          the 'event' to be counted, the counter will                                                          properly reflect the event. */
name|uint64_t
name|cnt1rdclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 1 Read Clear                                                          When set, all CSR reads of the L2C_PFC1                                                          register will auto-clear the counter. This allows                                                          SW to maintain 'cumulative' counters in SW.                                                          NOTE: If the CSR read occurs in the same cycle as                                                          the 'event' to be counted, the counter will                                                          properly reflect the event. */
name|uint64_t
name|cnt0rdclr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 0 Read Clear                                                          When set, all CSR reads of the L2C_PFC0                                                          register will 'auto-clear' the counter. This allows                                                          SW to maintain accurate 'cumulative' counters.                                                          NOTE: If the CSR read occurs in the same cycle as                                                          the 'event' to be counted, the counter will                                                          properly reflect the event. */
name|uint64_t
name|cnt3ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 3 Enable                                                          When this bit is set, the performance counter                                                          is enabled. */
name|uint64_t
name|cnt3clr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 3 Clear                                                          When the CSR write occurs, if this bit is set,                                                          the performance counter is cleared. Otherwise,                                                          it will resume counting from its current value. */
name|uint64_t
name|cnt3sel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter 3 Event Selector                                                          (see list of selectable events to count in NOTES) */
name|uint64_t
name|cnt2ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 2 Enable                                                          When this bit is set, the performance counter                                                          is enabled. */
name|uint64_t
name|cnt2clr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 2 Clear                                                          When the CSR write occurs, if this bit is set,                                                          the performance counter is cleared. Otherwise,                                                          it will resume counting from its current value. */
name|uint64_t
name|cnt2sel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter 2 Event Selector                                                          (see list of selectable events to count in NOTES) */
name|uint64_t
name|cnt1ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 1 Enable                                                          When this bit is set, the performance counter                                                          is enabled. */
name|uint64_t
name|cnt1clr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 1 Clear                                                          When the CSR write occurs, if this bit is set,                                                          the performance counter is cleared. Otherwise,                                                          it will resume counting from its current value. */
name|uint64_t
name|cnt1sel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter 1 Event Selector                                                          (see list of selectable events to count in NOTES) */
name|uint64_t
name|cnt0ena
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 0 Enable                                                          When this bit is set, the performance counter                                                          is enabled. */
name|uint64_t
name|cnt0clr
range|:
literal|1
decl_stmt|;
comment|/**< Performance Counter 0 Clear                                                          When the CSR write occurs, if this bit is set,                                                          the performance counter is cleared. Otherwise,                                                          it will resume counting from its current value. */
name|uint64_t
name|cnt0sel
range|:
literal|6
decl_stmt|;
comment|/**< Performance Counter 0 Event Selector                                                          (see list of selectable events to count in NOTES) */
else|#
directive|else
name|uint64_t
name|cnt0sel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cnt0clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt0ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt1sel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cnt1clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt1ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt2sel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cnt2clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt2ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt3sel
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cnt3clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt3ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt0rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt1rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt2rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cnt3rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_pfctl_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_pfctl
name|cvmx_l2c_pfctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ppgrp  *  * L2C_PPGRP = L2C PP Group Number  *  * Description: Defines the PP(Packet Processor) PLC Group \# (0,1,2)  */
end_comment

begin_union
union|union
name|cvmx_l2c_ppgrp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_ppgrp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|pp11grp
range|:
literal|2
decl_stmt|;
comment|/**< PP11 PLC Group# (0,1,2) */
name|uint64_t
name|pp10grp
range|:
literal|2
decl_stmt|;
comment|/**< PP10 PLC Group# (0,1,2) */
name|uint64_t
name|pp9grp
range|:
literal|2
decl_stmt|;
comment|/**< PP9 PLC Group# (0,1,2) */
name|uint64_t
name|pp8grp
range|:
literal|2
decl_stmt|;
comment|/**< PP8 PLC Group# (0,1,2) */
name|uint64_t
name|pp7grp
range|:
literal|2
decl_stmt|;
comment|/**< PP7 PLC Group# (0,1,2) */
name|uint64_t
name|pp6grp
range|:
literal|2
decl_stmt|;
comment|/**< PP6 PLC Group# (0,1,2) */
name|uint64_t
name|pp5grp
range|:
literal|2
decl_stmt|;
comment|/**< PP5 PLC Group# (0,1,2) */
name|uint64_t
name|pp4grp
range|:
literal|2
decl_stmt|;
comment|/**< PP4 PLC Group# (0,1,2) */
name|uint64_t
name|pp3grp
range|:
literal|2
decl_stmt|;
comment|/**< PP3 PLC Group# (0,1,2) */
name|uint64_t
name|pp2grp
range|:
literal|2
decl_stmt|;
comment|/**< PP2 PLC Group# (0,1,2) */
name|uint64_t
name|pp1grp
range|:
literal|2
decl_stmt|;
comment|/**< PP1 PLC Group# (0,1,2) */
name|uint64_t
name|pp0grp
range|:
literal|2
decl_stmt|;
comment|/**< PP0 PLC Group# (0,1,2) */
else|#
directive|else
name|uint64_t
name|pp0grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp1grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp2grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp3grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp4grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp5grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp6grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp7grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp8grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp9grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp10grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp11grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_ppgrp_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pp3grp
range|:
literal|2
decl_stmt|;
comment|/**< PP3 PLC Group# (0,1,2) */
name|uint64_t
name|pp2grp
range|:
literal|2
decl_stmt|;
comment|/**< PP2 PLC Group# (0,1,2) */
name|uint64_t
name|pp1grp
range|:
literal|2
decl_stmt|;
comment|/**< PP1 PLC Group# (0,1,2) */
name|uint64_t
name|pp0grp
range|:
literal|2
decl_stmt|;
comment|/**< PP0 PLC Group# (0,1,2) */
else|#
directive|else
name|uint64_t
name|pp0grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp1grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp2grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pp3grp
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_l2c_ppgrp_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ppgrp_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_ppgrp_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_ppgrp
name|cvmx_l2c_ppgrp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_qos_iob#  *  * L2C_QOS_IOB = L2C IOB QOS level  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_qos_iobx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_qos_iobx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|dwblvl
range|:
literal|3
decl_stmt|;
comment|/**< QOS level for DWB commands. */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lvl
range|:
literal|3
decl_stmt|;
comment|/**< QOS level for non-DWB commands. */
else|#
directive|else
name|uint64_t
name|lvl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dwblvl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_qos_iobx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|dwblvl
range|:
literal|2
decl_stmt|;
comment|/**< QOS level for DWB commands. */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|lvl
range|:
literal|2
decl_stmt|;
comment|/**< QOS level for non-DWB commands. */
else|#
directive|else
name|uint64_t
name|lvl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dwblvl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_l2c_qos_iobx_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_iobx_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_qos_iobx_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_iobx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_iobx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_qos_iobx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_qos_iobx
name|cvmx_l2c_qos_iobx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_qos_pp#  *  * L2C_QOS_PP = L2C PP QOS level  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_qos_ppx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_qos_ppx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|lvl
range|:
literal|3
decl_stmt|;
comment|/**< QOS level to use for this PP. */
else|#
directive|else
name|uint64_t
name|lvl
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_qos_ppx_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|lvl
range|:
literal|2
decl_stmt|;
comment|/**< QOS level to use for this PP. */
else|#
directive|else
name|uint64_t
name|lvl
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_l2c_qos_ppx_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_ppx_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_qos_ppx_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_ppx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_ppx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_qos_ppx_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_qos_ppx
name|cvmx_l2c_qos_ppx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_qos_wgt  *  * L2C_QOS_WGT = L2C QOS weights  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_qos_wgt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_qos_wgt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|wgt7
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 7 */
name|uint64_t
name|wgt6
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 6 */
name|uint64_t
name|wgt5
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 5 */
name|uint64_t
name|wgt4
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 4 */
name|uint64_t
name|wgt3
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 3 */
name|uint64_t
name|wgt2
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 2 */
name|uint64_t
name|wgt1
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 1 */
name|uint64_t
name|wgt0
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 0 */
else|#
directive|else
name|uint64_t
name|wgt0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt3
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt4
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt5
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt6
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt7
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_qos_wgt_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|wgt3
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 3 */
name|uint64_t
name|wgt2
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 2 */
name|uint64_t
name|wgt1
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 1 */
name|uint64_t
name|wgt0
range|:
literal|8
decl_stmt|;
comment|/**< Weight for QOS level 0 */
else|#
directive|else
name|uint64_t
name|wgt0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|wgt3
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_l2c_qos_wgt_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_wgt_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_qos_wgt_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_wgt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_qos_wgt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_qos_wgt_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_qos_wgt
name|cvmx_l2c_qos_wgt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_rsc#_pfc  *  * L2C_RSC_PFC = L2C RSC Performance Counter(s)  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_rscx_pfc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_rscx_pfc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_rscx_pfc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_rscx_pfc
name|cvmx_l2c_rscx_pfc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_rsd#_pfc  *  * L2C_RSD_PFC = L2C RSD Performance Counter(s)  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_rsdx_pfc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_rsdx_pfc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_rsdx_pfc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_rsdx_pfc
name|cvmx_l2c_rsdx_pfc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_spar0  *  * L2C_SPAR0 = L2 Set Partitioning Register (PP0-3)  *  * Description: L2 Set Partitioning Register  *  * Notes:  * - When a bit is set in the UMSK'x' register, a memory command issued from PP='x' will NOT select that  *   set for replacement.  * - There MUST ALWAYS BE at least 1 bit clear in each UMSK'x' register for proper L2 cache operation  * - NOTES: When L2C FUSE[136] is blown(CRIP_256K), then SETS#7-4 are SET in all UMSK'x' registers  *          When L2C FUSE[137] is blown(CRIP_128K), then SETS#7-2 are SET in all UMSK'x' registers  */
end_comment

begin_union
union|union
name|cvmx_l2c_spar0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_spar0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|umsk3
range|:
literal|8
decl_stmt|;
comment|/**< PP[3] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk2
range|:
literal|8
decl_stmt|;
comment|/**< PP[2] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk1
range|:
literal|8
decl_stmt|;
comment|/**< PP[1] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk0
range|:
literal|8
decl_stmt|;
comment|/**< PP[0] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk2
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk3
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_spar0_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|umsk0
range|:
literal|4
decl_stmt|;
comment|/**< PP[0] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_l2c_spar0_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|umsk1
range|:
literal|4
decl_stmt|;
comment|/**< PP[1] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|umsk0
range|:
literal|4
decl_stmt|;
comment|/**< PP[0] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk0
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|umsk1
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
name|struct
name|cvmx_l2c_spar0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar0_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_l2c_spar0_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|umsk1
range|:
literal|8
decl_stmt|;
comment|/**< PP[1] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk0
range|:
literal|8
decl_stmt|;
comment|/**< PP[0] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk1
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_l2c_spar0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_spar0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_spar0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar0_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_spar0
name|cvmx_l2c_spar0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_spar1  *  * L2C_SPAR1 = L2 Set Partitioning Register (PP4-7)  *  * Description: L2 Set Partitioning Register  *  * Notes:  * - When a bit is set in the UMSK'x' register, a memory command issued from PP='x' will NOT select that  *   set for replacement.  * - There should ALWAYS BE at least 1 bit clear in each UMSK'x' register for proper L2 cache operation  * - NOTES: When L2C FUSE[136] is blown(CRIP_1024K), then SETS#7-4 are SET in all UMSK'x' registers  *          When L2C FUSE[137] is blown(CRIP_512K), then SETS#7-2 are SET in all UMSK'x' registers  */
end_comment

begin_union
union|union
name|cvmx_l2c_spar1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_spar1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|umsk7
range|:
literal|8
decl_stmt|;
comment|/**< PP[7] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk6
range|:
literal|8
decl_stmt|;
comment|/**< PP[6] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk5
range|:
literal|8
decl_stmt|;
comment|/**< PP[5] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk4
range|:
literal|8
decl_stmt|;
comment|/**< PP[4] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk4
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk5
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk6
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_spar1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_spar1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_spar1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar1_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_spar1
name|cvmx_l2c_spar1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_spar2  *  * L2C_SPAR2 = L2 Set Partitioning Register (PP8-11)  *  * Description: L2 Set Partitioning Register  *  * Notes:  * - When a bit is set in the UMSK'x' register, a memory command issued from PP='x' will NOT select that  *   set for replacement.  * - There should ALWAYS BE at least 1 bit clear in each UMSK'x' register for proper L2 cache operation  * - NOTES: When L2C FUSE[136] is blown(CRIP_1024K), then SETS#7-4 are SET in all UMSK'x' registers  *          When L2C FUSE[137] is blown(CRIP_512K), then SETS#7-2 are SET in all UMSK'x' registers  */
end_comment

begin_union
union|union
name|cvmx_l2c_spar2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_spar2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|umsk11
range|:
literal|8
decl_stmt|;
comment|/**< PP[11] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk10
range|:
literal|8
decl_stmt|;
comment|/**< PP[10] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk9
range|:
literal|8
decl_stmt|;
comment|/**< PP[9] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk8
range|:
literal|8
decl_stmt|;
comment|/**< PP[8] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk8
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk9
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk10
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk11
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_spar2_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar2_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_spar2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar2_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_spar2_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar2_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_spar2
name|cvmx_l2c_spar2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_spar3  *  * L2C_SPAR3 = L2 Set Partitioning Register (PP12-15)  *  * Description: L2 Set Partitioning Register  *  * Notes:  * - When a bit is set in the UMSK'x' register, a memory command issued from PP='x' will NOT select that  *   set for replacement.  * - There should ALWAYS BE at least 1 bit clear in each UMSK'x' register for proper L2 cache operation  * - NOTES: When L2C FUSE[136] is blown(CRIP_1024K), then SETS#7-4 are SET in all UMSK'x' registers  *          When L2C FUSE[137] is blown(CRIP_512K), then SETS#7-2 are SET in all UMSK'x' registers  */
end_comment

begin_union
union|union
name|cvmx_l2c_spar3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_spar3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|umsk15
range|:
literal|8
decl_stmt|;
comment|/**< PP[15] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk14
range|:
literal|8
decl_stmt|;
comment|/**< PP[14] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk13
range|:
literal|8
decl_stmt|;
comment|/**< PP[13] L2 'DO NOT USE' set partition mask */
name|uint64_t
name|umsk12
range|:
literal|8
decl_stmt|;
comment|/**< PP[12] L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umsk12
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk13
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk14
range|:
literal|8
decl_stmt|;
name|uint64_t
name|umsk15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_spar3_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar3_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_spar3_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar3_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_spar3
name|cvmx_l2c_spar3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_spar4  *  * L2C_SPAR4 = L2 Set Partitioning Register (IOB)  *  * Description: L2 Set Partitioning Register  *  * Notes:  * - When a bit is set in the UMSK'x' register, a memory command issued from PP='x' will NOT select that  *   set for replacement.  * - There should ALWAYS BE at least 1 bit clear in each UMSK'x' register for proper L2 cache operation  * - NOTES: When L2C FUSE[136] is blown(CRIP_256K), then SETS#7-4 are SET in all UMSK'x' registers  *          When L2C FUSE[137] is blown(CRIP_128K), then SETS#7-2 are SET in all UMSK'x' registers  */
end_comment

begin_union
union|union
name|cvmx_l2c_spar4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_spar4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|umskiob
range|:
literal|8
decl_stmt|;
comment|/**< IOB L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umskiob
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_spar4_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|umskiob
range|:
literal|4
decl_stmt|;
comment|/**< IOB L2 'DO NOT USE' set partition mask */
else|#
directive|else
name|uint64_t
name|umskiob
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_l2c_spar4_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_l2c_spar4_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_spar4
name|cvmx_l2c_spar4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_ecc0  *  * L2C_TAD_ECC0 = L2C ECC logging  *  * Description: holds the syndromes for a L2D read generated from L2C_XMC_CMD  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_ecc0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_ecc0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow3ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW3 of cache block */
name|uint64_t
name|reserved_42_47
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow2ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW2 of cache block */
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow1ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW1 of cache block */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow0ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW0 of cache block */
else|#
directive|else
name|uint64_t
name|ow0ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow1ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow2ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_42_47
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow3ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_ecc0
name|cvmx_l2c_tadx_ecc0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_ecc1  *  * L2C_TAD_ECC1 = L2C ECC logging  *  * Description: holds the syndromes for a L2D read generated from L2C_XMC_CMD  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_ecc1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_ecc1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow7ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW7 of cache block */
name|uint64_t
name|reserved_42_47
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow6ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW6 of cache block */
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow5ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW5 of cache block */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow4ecc
range|:
literal|10
decl_stmt|;
comment|/**< ECC for OW4 of cache block */
else|#
directive|else
name|uint64_t
name|ow4ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow5ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_26_31
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow6ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_42_47
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ow7ecc
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ecc1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_ecc1
name|cvmx_l2c_tadx_ecc1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_ien  *  * L2C_TAD_IEN = L2C TAD Interrupt Enable  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_ien
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_ien_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|wrdislmc
range|:
literal|1
decl_stmt|;
comment|/**< Illegal Write to Disabled LMC Error enable                                                          Enables L2C_TADX_INT[WRDISLMC] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|rddislmc
range|:
literal|1
decl_stmt|;
comment|/**< Illegal Read  to Disabled LMC Error enable                                                          Enables L2C_TADX_INT[RDDISLMC] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
comment|/**< No way available interrupt enable                                                          Enables L2C_ERR_TTGX[NOWAY]/L2C_TADX_INT[NOWAY] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|vbfdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit Error enable                                                          Enables L2C_ERR_TDTX[VDBE]/L2C_TADX_INT[VBFSBE] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|vbfsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit Error enable                                                          Enables L2C_ERR_TDTX[VSBE]/L2C_TADX_INT[VBFSBE] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|tagdbe
range|:
literal|1
decl_stmt|;
comment|/**< TAG Double-Bit Error enable                                                          Enables L2C_ERR_TTGX[DBE]/L2C_TADX_INT[TAGDBE] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|tagsbe
range|:
literal|1
decl_stmt|;
comment|/**< TAG Single-Bit Error enable                                                          Enables L2C_ERR_TTGX[SBE]/L2C_TADX_INT[TAGSBE] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|l2ddbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double-Bit Error enable                                                          Enables L2C_ERR_TDTX[DBE]/L2C_TADX_INT[L2DDBE] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|l2dsbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single-Bit Error enable                                                          Enables L2C_ERR_TDTX[SBE]/L2C_TADX_INT[L2DSBE] to                                                          assert L2C_INT_REG[TADX] (and cause an interrupt) */
else|#
directive|else
name|uint64_t
name|l2dsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2ddbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tagsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tagdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbfsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbfdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rddislmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wrdislmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_ien_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ien_s
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_ien_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
comment|/**< No way available interrupt enable                                                          Enables L2C_ERR_TTGX[NOWAY] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|vbfdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit Error enable                                                          Enables L2C_ERR_TDTX[VSBE] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|vbfsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit Error enable                                                          Enables L2C_ERR_TDTX[VSBE] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|tagdbe
range|:
literal|1
decl_stmt|;
comment|/**< TAG Double-Bit Error enable                                                          Enables L2C_ERR_TTGX[DBE] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|tagsbe
range|:
literal|1
decl_stmt|;
comment|/**< TAG Single-Bit Error enable                                                          Enables L2C_ERR_TTGX[SBE] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|l2ddbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double-Bit Error enable                                                          Enables L2C_ERR_TDTX[DBE] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
name|uint64_t
name|l2dsbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single-Bit Error enable                                                          Enables L2C_ERR_TDTX[SBE] to assert                                                          L2C_INT_REG[TADX] (and cause an interrupt) */
else|#
directive|else
name|uint64_t
name|l2dsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2ddbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tagsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tagdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbfsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbfdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_l2c_tadx_ien_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ien_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ien_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_ien_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_ien
name|cvmx_l2c_tadx_ien_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_int  *  * L2C_TAD_INT = L2C TAD Interrupt Register (not present in pass 1 O63)  *  *  * Notes:  * L2C_TAD_IEN is the interrupt enable register corresponding to this register.  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|wrdislmc
range|:
literal|1
decl_stmt|;
comment|/**< Illegal Write to Disabled LMC Error                                                          A DRAM write arrived before the LMC(s) were enabled */
name|uint64_t
name|rddislmc
range|:
literal|1
decl_stmt|;
comment|/**< Illegal Read  to Disabled LMC Error                                                          A DRAM read  arrived before the LMC(s) were enabled */
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
comment|/**< No way available interrupt                                                          Shadow copy of L2C_ERR_TTGX[NOWAY]                                                          Writes of 1 also clear L2C_ERR_TTGX[NOWAY] */
name|uint64_t
name|vbfdbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Double-Bit Error                                                          Shadow copy of L2C_ERR_TDTX[VDBE]                                                          Writes of 1 also clear L2C_ERR_TDTX[VDBE] */
name|uint64_t
name|vbfsbe
range|:
literal|1
decl_stmt|;
comment|/**< VBF Single-Bit Error                                                          Shadow copy of L2C_ERR_TDTX[VSBE]                                                          Writes of 1 also clear L2C_ERR_TDTX[VSBE] */
name|uint64_t
name|tagdbe
range|:
literal|1
decl_stmt|;
comment|/**< TAG Double-Bit Error                                                          Shadow copy of L2C_ERR_TTGX[DBE]                                                          Writes of 1 also clear L2C_ERR_TTGX[DBE] */
name|uint64_t
name|tagsbe
range|:
literal|1
decl_stmt|;
comment|/**< TAG Single-Bit Error                                                          Shadow copy of L2C_ERR_TTGX[SBE]                                                          Writes of 1 also clear L2C_ERR_TTGX[SBE] */
name|uint64_t
name|l2ddbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Double-Bit Error                                                          Shadow copy of L2C_ERR_TDTX[DBE]                                                          Writes of 1 also clear L2C_ERR_TDTX[DBE] */
name|uint64_t
name|l2dsbe
range|:
literal|1
decl_stmt|;
comment|/**< L2D Single-Bit Error                                                          Shadow copy of L2C_ERR_TDTX[SBE]                                                          Writes of 1 also clear L2C_ERR_TDTX[SBE] */
else|#
directive|else
name|uint64_t
name|l2dsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2ddbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tagsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tagdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbfsbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vbfdbe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|noway
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rddislmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wrdislmc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_int_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_int
name|cvmx_l2c_tadx_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_pfc0  *  * L2C_TAD_PFC0 = L2C TAD Performance Counter 0  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_pfc0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_pfc0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_pfc0
name|cvmx_l2c_tadx_pfc0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_pfc1  *  * L2C_TAD_PFC1 = L2C TAD Performance Counter 1  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_pfc1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_pfc1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_pfc1
name|cvmx_l2c_tadx_pfc1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_pfc2  *  * L2C_TAD_PFC2 = L2C TAD Performance Counter 2  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_pfc2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_pfc2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_pfc2
name|cvmx_l2c_tadx_pfc2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_pfc3  *  * L2C_TAD_PFC3 = L2C TAD Performance Counter 3  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_pfc3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_pfc3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_pfc3_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_pfc3
name|cvmx_l2c_tadx_pfc3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_prf  *  * L2C_TAD_PRF = L2C TAD Performance Counter Control  *  *  * Notes:  * (1) All four counters are equivalent and can use any of the defined selects.  *  * (2) the CNTnSEL legal values are:  *         0x00 -- Nothing (disabled)  *         0x01 -- L2 Tag Hit  *         0x02 -- L2 Tag Miss  *         0x03 -- L2 Tag NoAlloc (forced no-allocate)  *         0x04 -- L2 Victim  *         0x05 -- SC Fail  *         0x06 -- SC Pass  *         0x07 -- LFB Occupancy (each cycle adds \# of LFBs valid)  *         0x08 -- LFB Wait LFB (each cycle adds \# LFBs waiting for other LFBs)  *         0x09 -- LFB Wait VAB (each cycle adds \# LFBs waiting for VAB)  *         0x80 -- Quad 0 index bus inuse  *         0x81 -- Quad 0 read data bus inuse  *         0x82 -- Quad 0 \# banks inuse (0-4/cycle)  *         0x83 -- Quad 0 wdat flops inuse (0-4/cycle)  *         0x90 -- Quad 1 index bus inuse  *         0x91 -- Quad 1 read data bus inuse  *         0x92 -- Quad 1 \# banks inuse (0-4/cycle)  *         0x93 -- Quad 1 wdat flops inuse (0-4/cycle)  *         0xA0 -- Quad 2 index bus inuse  *         0xA1 -- Quad 2 read data bus inuse  *         0xA2 -- Quad 2 \# banks inuse (0-4/cycle)  *         0xA3 -- Quad 2 wdat flops inuse (0-4/cycle)  *         0xB0 -- Quad 3 index bus inuse  *         0xB1 -- Quad 3 read data bus inuse  *         0xB2 -- Quad 3 \# banks inuse (0-4/cycle)  *         0xB3 -- Quad 3 wdat flops inuse (0-4/cycle)  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_prf
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_prf_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cnt3sel
range|:
literal|8
decl_stmt|;
comment|/**< Selects event to count for L2C_TAD_PFC3 */
name|uint64_t
name|cnt2sel
range|:
literal|8
decl_stmt|;
comment|/**< Selects event to count for L2C_TAD_PFC2 */
name|uint64_t
name|cnt1sel
range|:
literal|8
decl_stmt|;
comment|/**< Selects event to count for L2C_TAD_PFC1 */
name|uint64_t
name|cnt0sel
range|:
literal|8
decl_stmt|;
comment|/**< Selects event to count for L2C_TAD_PFC0 */
else|#
directive|else
name|uint64_t
name|cnt0sel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cnt1sel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cnt2sel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cnt3sel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_prf_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_prf
name|cvmx_l2c_tadx_prf_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_tad#_tag  *  * L2C_TAD_TAG = L2C tag data  *  * Description: holds the tag information for LTGL2I and STGL2I commands  *  * Notes:  * (1) For 63xx TAG[35] must be written zero for STGL2I's or operation is undefined.  During normal  *     operation, TAG[35] will also read 0.  *  * (2) If setting the LOCK bit, the USE bit should also be set or operation is undefined.  *  * (3) The tag is the corresponding bits from the L2C+LMC internal L2/DRAM byte address.  */
end_comment

begin_union
union|union
name|cvmx_l2c_tadx_tag
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_tadx_tag_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
name|uint64_t
name|ecc
range|:
literal|6
decl_stmt|;
comment|/**< The tag ECC */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|19
decl_stmt|;
comment|/**< The tag (see notes 1 and 3) */
name|uint64_t
name|reserved_4_16
range|:
literal|13
decl_stmt|;
name|uint64_t
name|use
range|:
literal|1
decl_stmt|;
comment|/**< The LRU use bit */
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
comment|/**< The valid bit */
name|uint64_t
name|dirty
range|:
literal|1
decl_stmt|;
comment|/**< The dirty bit */
name|uint64_t
name|lock
range|:
literal|1
decl_stmt|;
comment|/**< The lock bit */
else|#
directive|else
name|uint64_t
name|lock
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dirty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|use
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_16
range|:
literal|13
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|19
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ecc
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_46_63
range|:
literal|18
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_tadx_tag_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_tadx_tag
name|cvmx_l2c_tadx_tag_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ver_id  *  * L2C_VER_ID = L2C Virtualization ID Error Register  *  * Description: records virtualization IDs associated with HOLEWR/BIGWR/VRTWR/VRTIDRNG/VRTADRNG interrupts.  */
end_comment

begin_union
union|union
name|cvmx_l2c_ver_id
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_ver_id_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
comment|/**< Mask of virtualization IDs which had a                                                          HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_ver_id_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_id_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_id_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ver_id_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_id_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_id_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ver_id_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_ver_id
name|cvmx_l2c_ver_id_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ver_iob  *  * L2C_VER_IOB = L2C Virtualization ID IOB Error Register  *  * Description: records IOBs associated with HOLEWR/BIGWR/VRTWR/VRTIDRNG/VRTADRNG interrupts.  */
end_comment

begin_union
union|union
name|cvmx_l2c_ver_iob
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_ver_iob_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|2
decl_stmt|;
comment|/**< Mask of IOBs which had a HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_ver_iob_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|1
decl_stmt|;
comment|/**< Mask of IOBs which had a HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_l2c_ver_iob_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_iob_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ver_iob_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_iob_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_iob_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ver_iob_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_ver_iob
name|cvmx_l2c_ver_iob_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ver_msc  *  * L2C_VER_MSC = L2C Virtualization Miscellaneous Error Register (not in 63xx pass 1.x)  *  * Description: records type of command associated with HOLEWR/BIGWR/VRTWR/VRTIDRNG/VRTADRNG interrupts  */
end_comment

begin_union
union|union
name|cvmx_l2c_ver_msc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_ver_msc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|invl2
range|:
literal|1
decl_stmt|;
comment|/**< If set, a INVL2 caused HOLEWR/BIGWR/VRT* to set */
name|uint64_t
name|dwb
range|:
literal|1
decl_stmt|;
comment|/**< If set, a DWB caused HOLEWR/BIGWR/VRT* to set */
else|#
directive|else
name|uint64_t
name|dwb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|invl2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_ver_msc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_msc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_msc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_msc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_msc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ver_msc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_ver_msc
name|cvmx_l2c_ver_msc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_ver_pp  *  * L2C_VER_PP = L2C Virtualization ID PP Error Register  *  * Description: records PPs associated with HOLEWR/BIGWR/VRTWR/VRTIDRNG/VRTADRNG interrupts.  */
end_comment

begin_union
union|union
name|cvmx_l2c_ver_pp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_ver_pp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|32
decl_stmt|;
comment|/**< Mask of PPs which had a HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_l2c_ver_pp_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|4
decl_stmt|;
comment|/**< Mask of PPs which had a HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_l2c_ver_pp_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|6
decl_stmt|;
comment|/**< Mask of PPs which had a HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_l2c_ver_pp_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_l2c_ver_pp_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|10
decl_stmt|;
comment|/**< Mask of PPs which had a HOLEWR/BIGWR/VRTWR error */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_l2c_ver_pp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_ver_pp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_ver_pp_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_ver_pp
name|cvmx_l2c_ver_pp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_virtid_iob#  *  * L2C_VIRTID_IOB = L2C IOB virtualization ID  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_virtid_iobx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_virtid_iobx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|dwbid
range|:
literal|6
decl_stmt|;
comment|/**< Virtualization ID to use for DWB commands */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|id
range|:
literal|6
decl_stmt|;
comment|/**< Virtualization ID to use for non-DWB commands */
else|#
directive|else
name|uint64_t
name|id
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dwbid
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_iobx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_virtid_iobx
name|cvmx_l2c_virtid_iobx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_virtid_pp#  *  * L2C_VIRTID_PP = L2C PP virtualization ID  *  * Description:  */
end_comment

begin_union
union|union
name|cvmx_l2c_virtid_ppx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_virtid_ppx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|id
range|:
literal|6
decl_stmt|;
comment|/**< Virtualization ID to use for this PP. */
else|#
directive|else
name|uint64_t
name|id
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_virtid_ppx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_virtid_ppx
name|cvmx_l2c_virtid_ppx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_vrt_ctl  *  * L2C_VRT_CTL = L2C Virtualization control register  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_vrt_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_vrt_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|ooberr
range|:
literal|1
decl_stmt|;
comment|/**< Whether out of bounds writes are an error                                                          Determines virtualization hardware behavior for                                                          a store to an L2/DRAM address larger than                                                          indicated by MEMSZ. If OOBERR is set, all these                                                          stores (from any virtualization ID) are blocked. If                                                          OOBERR is clear, none of these stores are blocked. */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|memsz
range|:
literal|3
decl_stmt|;
comment|/**< Memory space coverage of L2C_VRT_MEM (encoded)                                                          0 = 1GB                                                          1 = 2GB                                                          2 = 4GB                                                          3 = 8GB                                                          4 = 16GB                                                          5 = 32GB                                                          6 = 64GB (**reserved in 63xx**)                                                          7 = 128GB (**reserved in 63xx**) */
name|uint64_t
name|numid
range|:
literal|3
decl_stmt|;
comment|/**< Number of allowed virtualization IDs (encoded)                                                              0 = 2                                                              1 = 4                                                              2 = 8                                                              3 = 16                                                              4 = 32                                                              5 = 64                                                              6,7 illegal                                                          Violations of this limit causes                                                          L2C to set L2C_INT_REG[VRTIDRNG]. */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Global virtualization enable                                                          When ENABLE is clear, stores are never blocked by                                                          the L2C virtualization hardware and none of NUMID,                                                          MEMSZ, OOBERR are used. */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|numid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|memsz
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ooberr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_ctl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_vrt_ctl
name|cvmx_l2c_vrt_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_vrt_mem#  *  * L2C_VRT_MEM = L2C Virtualization Memory  *  * Description: Virtualization memory mapped region.  There are 1024 32b  * byte-parity protected entries.  *  * Notes:  * When a DATA bit is set in L2C_VRT_MEM when L2C virtualization is enabled, L2C  * prevents the selected virtual machine from storing to the selected L2/DRAM region.  * L2C uses L2C_VRT_MEM to block stores when:  *  - L2C_VRT_CTL[ENABLE] is set, and  *  - the address of the store exists in L2C+LMC internal L2/DRAM Address space  *    and is within the L2C_VRT_CTL[MEMSZ] bounds, and  *  - the virtID of the store is within the L2C_VRT_CTL[NUMID] bounds  *  * L2C_VRT_MEM is never used for these L2C transactions which are always allowed:  *   - L2C CMI L2/DRAM transactions that cannot modify L2/DRAM, and  *   - any L2/DRAM transaction originated from L2C_XMC_CMD  *  * L2C_VRT_MEM contains one DATA bit per L2C+LMC internal L2/DRAM region and virtID indicating whether the store  * to the region is allowed. The granularity of the checking is the region size, which is:  *       2 ^^ (L2C_VRT_CTL[NUMID]+L2C_VRT_CTL[MEMSZ]+16)  * which ranges from a minimum of 64KB to a maximum of 256MB, depending on the size  * of L2/DRAM that is protected and the number of virtual machines.  *  * The L2C_VRT_MEM DATA bit that L2C uses is:  *  *   l2c_vrt_mem_bit_index = address>> (L2C_VRT_CTL[MEMSZ]+L2C_VRT_CTL[NUMID]+16); // address is a byte address  *   l2c_vrt_mem_bit_index = l2c_vrt_mem_bit_index | (virtID<< (14-L2C_VRT_CTL[NUMID]));  *  *   L2C_VRT_MEM(l2c_vrt_mem_bit_index>> 5)[DATA<l2c_vrt_mem_bit_index& 0x1F>] is used  *  * A specific example:  *  *   L2C_VRT_CTL[NUMID]=2 (i.e. 8 virtual machine ID's used)  *   L2C_VRT_CTL[MEMSZ]=4 (i.e. L2C_VRT_MEM covers 16 GB)  *  *   L2/DRAM region size (granularity) is 4MB  *  *   l2c_vrt_mem_bit_index<14:12> = virtID<2:0>  *   l2c_vrt_mem_bit_index<11:0> = address<33:22>  *  *   For L2/DRAM physical address 0x51000000 with virtID=5:  *      L2C_VRT_MEM648[DATA<4>] determines when the store is allowed (648 is decimal, not hex)  */
end_comment

begin_union
union|union
name|cvmx_l2c_vrt_memx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_vrt_memx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|parity
range|:
literal|4
decl_stmt|;
comment|/**< Parity to write into (or read from) the                                                          virtualization memory.                                                          PARITY<i> is the even parity of DATA<(i*8)+7:i*8> */
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
comment|/**< Data to write into (or read from) the                                                          virtualization memory. */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
name|uint64_t
name|parity
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_vrt_memx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_vrt_memx
name|cvmx_l2c_vrt_memx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_wpar_iob#  *  * L2C_WPAR_IOB = L2C IOB way partitioning  *  *  * Notes:  * (1) The read value of MASK will include bits set because of the L2C cripple fuses.  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_wpar_iobx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_wpar_iobx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Way partitioning mask. (1 means do not use) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_iobx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_wpar_iobx
name|cvmx_l2c_wpar_iobx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_wpar_pp#  *  * L2C_WPAR_PP = L2C PP way partitioning  *  *  * Notes:  * (1) The read value of MASK will include bits set because of the L2C cripple fuses.  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_wpar_ppx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_wpar_ppx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
comment|/**< Way partitioning mask. (1 means do not use) */
else|#
directive|else
name|uint64_t
name|mask
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_wpar_ppx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_wpar_ppx
name|cvmx_l2c_wpar_ppx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_xmc#_pfc  *  * L2C_XMC_PFC = L2C XMC Performance Counter(s)  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_xmcx_pfc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_xmcx_pfc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_xmcx_pfc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_xmcx_pfc
name|cvmx_l2c_xmcx_pfc_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_xmc_cmd  *  * L2C_XMC_CMD = L2C XMC command register  *  *  * Notes:  * (1) the XMC command chosen MUST NOT be a IOB destined command or operation is UNDEFINED.  *  * (2) the XMC command will have sid forced to IOB, did forced to L2C, no virtualization checks  *     performed (always pass), and xmdmsk forced to 0.  Note that this implies that commands which  *     REQUIRE an XMD cycle (STP,STC,SAA,FAA,FAS) should not be used or the results are unpredictable.  *     The sid=IOB means that the way partitioning used for the command is L2C_WPAR_IOB.  *     None of L2C_QOS_IOB, L2C_QOS_PP, L2C_VIRTID_IOB, L2C_VIRTID_PP are used for these commands.  *  * (3) any responses generated by the XMC command will be forced to PP7 (a non-existant PP) effectively  *     causing them to be ignored.  Generated STINs, however, will correctly invalidate the required  *     PPs.  *  * (4) any L2D read generated by the XMC command will record the syndrome information in  *     L2C_TAD_ECC0/1.  If ECC is disabled prior to the CSR write this provides the ability to read the  *     ECC bits directly.  If ECC is not disabled this should log 0's (assuming no ECC errors were  *     found in the block).  *  * (5) A write which arrives while the INUSE bit is set will block until the INUSE bit clears.  This  *     gives software 2 options when needing to issue a stream of writes to L2C_XMC_CMD: polling on the  *     INUSE bit, or allowing HW to handle the interlock -- at the expense of locking up the RSL bus  *     for potentially tens of cycles at a time while waiting for an available LFB/VAB entry.  *  * (6) The address written to L2C_XMC_CMD is a 38-bit OCTEON physical address.  L2C performs hole removal and  *     index aliasing (if enabled) on the written address and uses that for the command. This hole  *     removed/index aliased 38-bit address is what is returned on a read of the L2C_XMC_CMD register.  */
end_comment

begin_union
union|union
name|cvmx_l2c_xmc_cmd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_xmc_cmd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|inuse
range|:
literal|1
decl_stmt|;
comment|/**< Set to 1 by HW upon receiving a write, cleared when                                                          command has issued (not necessarily completed, but                                                          ordered relative to other traffic) and HW can accept                                                          another command. */
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
comment|/**< Command to use for simulated XMC request                                                          a new request can be accepted */
name|uint64_t
name|reserved_38_56
range|:
literal|19
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
comment|/**< Address to use for simulated XMC request (see Note 6) */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
name|uint64_t
name|reserved_38_56
range|:
literal|19
decl_stmt|;
name|uint64_t
name|cmd
range|:
literal|6
decl_stmt|;
name|uint64_t
name|inuse
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_xmc_cmd_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_xmc_cmd
name|cvmx_l2c_xmc_cmd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_l2c_xmd#_pfc  *  * L2C_XMD_PFC = L2C XMD Performance Counter(s)  *  */
end_comment

begin_union
union|union
name|cvmx_l2c_xmdx_pfc
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_l2c_xmdx_pfc_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
comment|/**< Current counter value */
else|#
directive|else
name|uint64_t
name|count
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_l2c_xmdx_pfc_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_l2c_xmdx_pfc
name|cvmx_l2c_xmdx_pfc_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

