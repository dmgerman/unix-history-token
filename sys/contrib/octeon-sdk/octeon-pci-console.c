begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_define
define|#
directive|define
name|CVMX_USE_1_TO_1_TLB_MAPPINGS
value|0
end_define

begin_include
include|#
directive|include
file|"cvmx-platform.h"
end_include

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)<(b))?(a):(b))
end_define

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"octeon-pci-console.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OCTEON_TARGET
argument_list|)
end_if

begin_include
include|#
directive|include
file|"octeon-pci.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following code is only used in standalone CVMX applications. It does     not apply for kernel or Linux programming */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_TARGET
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|int
name|cvmx_pci_console_num
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|per_core_pci_consoles
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|pci_console_desc_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function for simple executive internal use only - do not use in any application */
end_comment

begin_function
name|int
name|__cvmx_pci_console_write
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|int
name|console_num
decl_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0x10000000
condition|)
block|{
name|console_num
operator|=
name|fd
operator|&
literal|0xFFFF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|per_core_pci_consoles
condition|)
block|{
name|console_num
operator|=
name|cvmx_get_core_num
argument_list|()
expr_stmt|;
block|}
else|else
name|console_num
operator|=
name|cvmx_pci_console_num
expr_stmt|;
if|if
condition|(
operator|!
name|pci_console_desc_addr
condition|)
block|{
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|block_desc
init|=
name|cvmx_bootmem_find_named_block
argument_list|(
name|OCTEON_PCI_CONSOLE_BLOCK_NAME
argument_list|)
decl_stmt|;
name|pci_console_desc_addr
operator|=
name|block_desc
operator|->
name|base_addr
expr_stmt|;
block|}
return|return
name|octeon_pci_console_write
argument_list|(
name|pci_console_desc_addr
argument_list|,
name|console_num
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|CFG_PCI_CONSOLE
argument_list|)
operator|)
end_if

begin_function
name|int
name|octeon_pci_console_buffer_free_bytes
parameter_list|(
name|uint32_t
name|buffer_size
parameter_list|,
name|uint32_t
name|wr_idx
parameter_list|,
name|uint32_t
name|rd_idx
parameter_list|)
block|{
if|if
condition|(
name|rd_idx
operator|>=
name|buffer_size
operator|||
name|wr_idx
operator|>=
name|buffer_size
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
operator|(
operator|(
name|buffer_size
operator|-
literal|1
operator|)
operator|-
operator|(
name|wr_idx
operator|-
name|rd_idx
operator|)
operator|)
operator|%
name|buffer_size
operator|)
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_buffer_avail_bytes
parameter_list|(
name|uint32_t
name|buffer_size
parameter_list|,
name|uint32_t
name|wr_idx
parameter_list|,
name|uint32_t
name|rd_idx
parameter_list|)
block|{
if|if
condition|(
name|rd_idx
operator|>=
name|buffer_size
operator|||
name|wr_idx
operator|>=
name|buffer_size
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|buffer_size
operator|-
literal|1
operator|-
name|octeon_pci_console_buffer_free_bytes
argument_list|(
name|buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following code is only used under Linux userspace when you are using     CVMX */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|OCTEON_TARGET
argument_list|)
end_if

begin_function
name|int
name|octeon_pci_console_host_write
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|write_reqest_size
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|console_desc_addr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get global pci console information and look up specific console structure. */
name|uint32_t
name|num_consoles
init|=
name|octeon_read_mem32
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|num_consoles
argument_list|)
argument_list|)
decl_stmt|;
comment|//    printf("Num consoles: %d, buf size: %d\n", num_consoles, console_buffer_size);
if|if
condition|(
name|console_num
operator|>=
name|num_consoles
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: attempting to read non-existant console: %d\n"
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uint64_t
name|console_addr
init|=
name|octeon_read_mem64
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|console_addr_array
argument_list|)
operator|+
name|console_num
operator|*
literal|8
argument_list|)
decl_stmt|;
comment|//    printf("Console %d is at 0x%llx\n", console_num, (long long)console_addr);
name|uint32_t
name|console_buffer_size
init|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|buf_size
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check to see if any data is available */
name|uint32_t
name|rd_idx
decl_stmt|,
name|wr_idx
decl_stmt|;
name|uint64_t
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|octeon_read_mem64
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rd_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_read_index
argument_list|)
argument_list|)
expr_stmt|;
name|wr_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_write_index
argument_list|)
argument_list|)
expr_stmt|;
comment|//    printf("Input base: 0x%llx, rd: %d(0x%x), wr: %d(0x%x)\n", (long long)base_addr, rd_idx, rd_idx, wr_idx, wr_idx);
name|int
name|bytes_to_write
init|=
name|octeon_pci_console_buffer_free_bytes
argument_list|(
name|console_buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes_to_write
operator|<=
literal|0
condition|)
return|return
name|bytes_to_write
return|;
name|bytes_to_write
operator|=
name|MIN
argument_list|(
name|bytes_to_write
argument_list|,
name|write_reqest_size
argument_list|)
expr_stmt|;
comment|/* Check to see if what we want to write is not contiguous, and limit ourselves to the contiguous block*/
if|if
condition|(
name|wr_idx
operator|+
name|bytes_to_write
operator|>=
name|console_buffer_size
condition|)
name|bytes_to_write
operator|=
name|console_buffer_size
operator|-
name|wr_idx
expr_stmt|;
comment|//    printf("Attempting to write %d bytes, (buf size: %d)\n", bytes_to_write, write_reqest_size);
name|octeon_pci_write_mem
argument_list|(
name|base_addr
operator|+
name|wr_idx
argument_list|,
name|buffer
argument_list|,
name|bytes_to_write
argument_list|,
name|OCTEON_PCI_ENDIAN_64BIT_SWAP
argument_list|)
expr_stmt|;
name|octeon_write_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_write_index
argument_list|)
argument_list|,
operator|(
name|wr_idx
operator|+
name|bytes_to_write
operator|)
operator|%
name|console_buffer_size
argument_list|)
expr_stmt|;
return|return
name|bytes_to_write
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_host_read
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buf_size
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
name|console_desc_addr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get global pci console information and look up specific console structure. */
name|uint32_t
name|num_consoles
init|=
name|octeon_read_mem32
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|num_consoles
argument_list|)
argument_list|)
decl_stmt|;
comment|//    printf("Num consoles: %d, buf size: %d\n", num_consoles, console_buffer_size);
if|if
condition|(
name|console_num
operator|>=
name|num_consoles
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: attempting to read non-existant console: %d\n"
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uint64_t
name|console_addr
init|=
name|octeon_read_mem64
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|console_addr_array
argument_list|)
operator|+
name|console_num
operator|*
literal|8
argument_list|)
decl_stmt|;
name|uint32_t
name|console_buffer_size
init|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|buf_size
argument_list|)
argument_list|)
decl_stmt|;
comment|//    printf("Console %d is at 0x%llx\n", console_num, (long long)console_addr);
comment|/* Check to see if any data is available */
name|uint32_t
name|rd_idx
decl_stmt|,
name|wr_idx
decl_stmt|;
name|uint64_t
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|octeon_read_mem64
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rd_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_read_index
argument_list|)
argument_list|)
expr_stmt|;
name|wr_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_write_index
argument_list|)
argument_list|)
expr_stmt|;
comment|//    printf("Read buffer base: 0x%llx, rd: %d(0x%x), wr: %d(0x%x)\n", (long long)base_addr, rd_idx, rd_idx, wr_idx, wr_idx);
name|int
name|bytes_to_read
init|=
name|octeon_pci_console_buffer_avail_bytes
argument_list|(
name|console_buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes_to_read
operator|<=
literal|0
condition|)
return|return
name|bytes_to_read
return|;
name|bytes_to_read
operator|=
name|MIN
argument_list|(
name|bytes_to_read
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
comment|/* Check to see if what we want to read is not contiguous, and limit ourselves to the contiguous block*/
if|if
condition|(
name|rd_idx
operator|+
name|bytes_to_read
operator|>=
name|console_buffer_size
condition|)
name|bytes_to_read
operator|=
name|console_buffer_size
operator|-
name|rd_idx
expr_stmt|;
name|octeon_pci_read_mem
argument_list|(
name|buffer
argument_list|,
name|base_addr
operator|+
name|rd_idx
argument_list|,
name|bytes_to_read
argument_list|,
name|OCTEON_PCI_ENDIAN_64BIT_SWAP
argument_list|)
expr_stmt|;
name|octeon_write_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_read_index
argument_list|)
argument_list|,
operator|(
name|rd_idx
operator|+
name|bytes_to_read
operator|)
operator|%
name|console_buffer_size
argument_list|)
expr_stmt|;
return|return
name|bytes_to_read
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_host_write_avail
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|)
block|{
if|if
condition|(
operator|!
name|console_desc_addr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get global pci console information and look up specific console structure. */
name|uint32_t
name|num_consoles
init|=
name|octeon_read_mem32
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|num_consoles
argument_list|)
argument_list|)
decl_stmt|;
comment|//    printf("Num consoles: %d, buf size: %d\n", num_consoles, console_buffer_size);
if|if
condition|(
name|console_num
operator|>=
name|num_consoles
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: attempting to read non-existant console: %d\n"
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|uint64_t
name|console_addr
init|=
name|octeon_read_mem64
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|console_addr_array
argument_list|)
operator|+
name|console_num
operator|*
literal|8
argument_list|)
decl_stmt|;
comment|//    printf("Console %d is at 0x%llx\n", console_num, (long long)console_addr);
name|uint32_t
name|console_buffer_size
init|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|buf_size
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Check to see if any data is available */
name|uint32_t
name|rd_idx
decl_stmt|,
name|wr_idx
decl_stmt|;
name|uint64_t
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|octeon_read_mem64
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rd_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_read_index
argument_list|)
argument_list|)
expr_stmt|;
name|wr_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|input_write_index
argument_list|)
argument_list|)
expr_stmt|;
comment|//    printf("Input base: 0x%llx, rd: %d(0x%x), wr: %d(0x%x)\n", (long long)base_addr, rd_idx, rd_idx, wr_idx, wr_idx);
return|return
name|octeon_pci_console_buffer_free_bytes
argument_list|(
name|console_buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_host_read_avail
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|)
block|{
if|if
condition|(
operator|!
name|console_desc_addr
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Get global pci console information and look up specific console structure. */
name|uint32_t
name|num_consoles
init|=
name|octeon_read_mem32
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|num_consoles
argument_list|)
argument_list|)
decl_stmt|;
comment|//    printf("Num consoles: %d, buf size: %d\n", num_consoles, console_buffer_size);
if|if
condition|(
name|console_num
operator|>=
name|num_consoles
condition|)
block|{
name|printf
argument_list|(
literal|"ERROR: attempting to read non-existant console: %d\n"
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uint64_t
name|console_addr
init|=
name|octeon_read_mem64
argument_list|(
name|console_desc_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|,
name|console_addr_array
argument_list|)
operator|+
name|console_num
operator|*
literal|8
argument_list|)
decl_stmt|;
name|uint32_t
name|console_buffer_size
init|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|buf_size
argument_list|)
argument_list|)
decl_stmt|;
comment|//    printf("Console %d is at 0x%llx\n", console_num, (long long)console_addr);
comment|/* Check to see if any data is available */
name|uint32_t
name|rd_idx
decl_stmt|,
name|wr_idx
decl_stmt|;
name|uint64_t
name|base_addr
decl_stmt|;
name|base_addr
operator|=
name|octeon_read_mem64
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_base_addr
argument_list|)
argument_list|)
expr_stmt|;
name|rd_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_read_index
argument_list|)
argument_list|)
expr_stmt|;
name|wr_idx
operator|=
name|octeon_read_mem32
argument_list|(
name|console_addr
operator|+
name|offsetof
argument_list|(
name|octeon_pci_console_t
argument_list|,
name|output_write_index
argument_list|)
argument_list|)
expr_stmt|;
comment|//    printf("Read buffer base: 0x%llx, rd: %d(0x%x), wr: %d(0x%x)\n", (long long)base_addr, rd_idx, rd_idx, wr_idx, wr_idx);
return|return
name|octeon_pci_console_buffer_avail_bytes
argument_list|(
name|console_buffer_size
argument_list|,
name|wr_idx
argument_list|,
name|rd_idx
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TARGET_HOST */
end_comment

begin_comment
comment|/* This code is only available in a kernel or CVMX standalone. It can't be used     from userspace */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|||
name|defined
argument_list|(
name|__KERNEL__
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|CFG_PCI_CONSOLE
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|octeon_pci_console_t
modifier|*
name|octeon_pci_console_get_ptr
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|)
block|{
name|octeon_pci_console_desc_t
modifier|*
name|cons_desc_ptr
decl_stmt|;
if|if
condition|(
operator|!
name|console_desc_addr
condition|)
return|return
name|NULL
return|;
name|cons_desc_ptr
operator|=
operator|(
name|octeon_pci_console_desc_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|console_desc_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|console_num
operator|>=
name|cons_desc_ptr
operator|->
name|num_consoles
condition|)
return|return
name|NULL
return|;
return|return
operator|(
name|octeon_pci_console_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|cons_desc_ptr
operator|->
name|console_addr_array
index|[
name|console_num
index|]
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_write
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|bytes_to_write
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|octeon_pci_console_t
modifier|*
name|cons_ptr
decl_stmt|;
name|cvmx_spinlock_t
modifier|*
name|lock
decl_stmt|;
name|int
name|bytes_available
decl_stmt|;
name|char
modifier|*
name|buf_ptr
decl_stmt|;
name|int
name|bytes_written
decl_stmt|;
name|cons_ptr
operator|=
name|octeon_pci_console_get_ptr
argument_list|(
name|console_desc_addr
argument_list|,
name|console_num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cons_ptr
condition|)
return|return
operator|-
literal|1
return|;
name|lock
operator|=
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
name|cons_ptr
operator|->
name|lock
expr_stmt|;
name|buf_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|cons_ptr
operator|->
name|output_base_addr
argument_list|)
expr_stmt|;
name|bytes_written
operator|=
literal|0
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|bytes_to_write
operator|>
literal|0
condition|)
block|{
name|bytes_available
operator|=
name|octeon_pci_console_buffer_free_bytes
argument_list|(
name|cons_ptr
operator|->
name|buf_size
argument_list|,
name|cons_ptr
operator|->
name|output_write_index
argument_list|,
name|cons_ptr
operator|->
name|output_read_index
argument_list|)
expr_stmt|;
comment|//        printf("Console %d has %d bytes available for writes\n", console_num, bytes_available);
if|if
condition|(
name|bytes_available
operator|>
literal|0
condition|)
block|{
name|int
name|write_size
init|=
name|MIN
argument_list|(
name|bytes_available
argument_list|,
name|bytes_to_write
argument_list|)
decl_stmt|;
comment|/* Limit ourselves to what we can output in a contiguous block */
if|if
condition|(
name|cons_ptr
operator|->
name|output_write_index
operator|+
name|write_size
operator|>=
name|cons_ptr
operator|->
name|buf_size
condition|)
name|write_size
operator|=
name|cons_ptr
operator|->
name|buf_size
operator|-
name|cons_ptr
operator|->
name|output_write_index
expr_stmt|;
name|memcpy
argument_list|(
name|buf_ptr
operator|+
name|cons_ptr
operator|->
name|output_write_index
argument_list|,
name|buffer
operator|+
name|bytes_written
argument_list|,
name|write_size
argument_list|)
expr_stmt|;
name|CVMX_SYNCW
expr_stmt|;
comment|/* Make sure data is visible before changing write index */
name|cons_ptr
operator|->
name|output_write_index
operator|=
operator|(
name|cons_ptr
operator|->
name|output_write_index
operator|+
name|write_size
operator|)
operator|%
name|cons_ptr
operator|->
name|buf_size
expr_stmt|;
name|bytes_to_write
operator|-=
name|write_size
expr_stmt|;
name|bytes_written
operator|+=
name|write_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bytes_available
operator|==
literal|0
condition|)
block|{
comment|/* Check to see if we should wait for room, or return after a partial write */
if|if
condition|(
name|flags
operator|&
name|OCT_PCI_CON_FLAG_NONBLOCK
condition|)
goto|goto
name|done
goto|;
name|cvmx_wait
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
comment|/* Delay if we are spinning */
block|}
else|else
block|{
name|bytes_written
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
name|done
label|:
name|cvmx_spinlock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytes_written
operator|)
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_read
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buffer_size
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int
name|bytes_available
decl_stmt|;
name|char
modifier|*
name|buf_ptr
decl_stmt|;
name|cvmx_spinlock_t
modifier|*
name|lock
decl_stmt|;
name|int
name|bytes_read
decl_stmt|;
name|int
name|read_size
decl_stmt|;
name|octeon_pci_console_t
modifier|*
name|cons_ptr
init|=
name|octeon_pci_console_get_ptr
argument_list|(
name|console_desc_addr
argument_list|,
name|console_num
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cons_ptr
condition|)
return|return
operator|-
literal|1
return|;
name|buf_ptr
operator|=
operator|(
name|char
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|cons_ptr
operator|->
name|input_base_addr
argument_list|)
expr_stmt|;
name|bytes_available
operator|=
name|octeon_pci_console_buffer_avail_bytes
argument_list|(
name|cons_ptr
operator|->
name|buf_size
argument_list|,
name|cons_ptr
operator|->
name|input_write_index
argument_list|,
name|cons_ptr
operator|->
name|input_read_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_available
operator|<
literal|0
condition|)
return|return
name|bytes_available
return|;
name|lock
operator|=
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
name|cons_ptr
operator|->
name|lock
expr_stmt|;
name|cvmx_spinlock_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|OCT_PCI_CON_FLAG_NONBLOCK
operator|)
condition|)
block|{
comment|/* Wait for some data to be available */
while|while
condition|(
literal|0
operator|==
operator|(
name|bytes_available
operator|=
name|octeon_pci_console_buffer_avail_bytes
argument_list|(
name|cons_ptr
operator|->
name|buf_size
argument_list|,
name|cons_ptr
operator|->
name|input_write_index
argument_list|,
name|cons_ptr
operator|->
name|input_read_index
argument_list|)
operator|)
condition|)
name|cvmx_wait
argument_list|(
literal|1000000
argument_list|)
expr_stmt|;
block|}
name|bytes_read
operator|=
literal|0
expr_stmt|;
comment|//        printf("Console %d has %d bytes available for writes\n", console_num, bytes_available);
comment|/* Don't overflow the buffer passed to us */
name|read_size
operator|=
name|MIN
argument_list|(
name|bytes_available
argument_list|,
name|buffer_size
argument_list|)
expr_stmt|;
comment|/* Limit ourselves to what we can input in a contiguous block */
if|if
condition|(
name|cons_ptr
operator|->
name|input_read_index
operator|+
name|read_size
operator|>=
name|cons_ptr
operator|->
name|buf_size
condition|)
name|read_size
operator|=
name|cons_ptr
operator|->
name|buf_size
operator|-
name|cons_ptr
operator|->
name|input_read_index
expr_stmt|;
name|memcpy
argument_list|(
name|buffer
argument_list|,
name|buf_ptr
operator|+
name|cons_ptr
operator|->
name|input_read_index
argument_list|,
name|read_size
argument_list|)
expr_stmt|;
name|cons_ptr
operator|->
name|input_read_index
operator|=
operator|(
name|cons_ptr
operator|->
name|input_read_index
operator|+
name|read_size
operator|)
operator|%
name|cons_ptr
operator|->
name|buf_size
expr_stmt|;
name|bytes_read
operator|+=
name|read_size
expr_stmt|;
name|cvmx_spinlock_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|bytes_read
operator|)
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_write_avail
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|)
block|{
name|int
name|bytes_available
decl_stmt|;
name|octeon_pci_console_t
modifier|*
name|cons_ptr
init|=
name|octeon_pci_console_get_ptr
argument_list|(
name|console_desc_addr
argument_list|,
name|console_num
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cons_ptr
condition|)
return|return
operator|-
literal|1
return|;
name|bytes_available
operator|=
name|octeon_pci_console_buffer_free_bytes
argument_list|(
name|cons_ptr
operator|->
name|buf_size
argument_list|,
name|cons_ptr
operator|->
name|input_write_index
argument_list|,
name|cons_ptr
operator|->
name|input_read_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_available
operator|>=
literal|0
condition|)
return|return
operator|(
name|bytes_available
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|octeon_pci_console_read_avail
parameter_list|(
name|uint64_t
name|console_desc_addr
parameter_list|,
name|unsigned
name|int
name|console_num
parameter_list|)
block|{
name|int
name|bytes_available
decl_stmt|;
name|octeon_pci_console_t
modifier|*
name|cons_ptr
init|=
name|octeon_pci_console_get_ptr
argument_list|(
name|console_desc_addr
argument_list|,
name|console_num
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|cons_ptr
condition|)
return|return
operator|-
literal|1
return|;
name|bytes_available
operator|=
name|octeon_pci_console_buffer_avail_bytes
argument_list|(
name|cons_ptr
operator|->
name|buf_size
argument_list|,
name|cons_ptr
operator|->
name|input_write_index
argument_list|,
name|cons_ptr
operator|->
name|input_read_index
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_available
operator|>=
literal|0
condition|)
return|return
operator|(
name|bytes_available
operator|)
return|;
else|else
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This code can only be used in the bootloader */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
operator|&&
name|defined
argument_list|(
name|CFG_PCI_CONSOLE
argument_list|)
end_if

begin_define
define|#
directive|define
name|DDR0_TOP
value|0x10000000
end_define

begin_define
define|#
directive|define
name|DDR2_BASE
value|0x20000000
end_define

begin_function
name|uint64_t
name|octeon_pci_console_init
parameter_list|(
name|int
name|num_consoles
parameter_list|,
name|int
name|buffer_size
parameter_list|)
block|{
name|octeon_pci_console_desc_t
modifier|*
name|cons_desc_ptr
decl_stmt|;
name|octeon_pci_console_t
modifier|*
name|cons_ptr
decl_stmt|;
comment|/* Compute size required for pci console structure */
name|int
name|alloc_size
init|=
name|num_consoles
operator|*
operator|(
name|buffer_size
operator|*
literal|2
operator|+
sizeof|sizeof
argument_list|(
name|octeon_pci_console_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|)
decl_stmt|;
comment|/* Allocate memory for the consoles.  This must be in the range addresssible by the bootloader.     ** Try to do so in a manner which minimizes fragmentation.  We try to put it at the top of DDR0 or bottom of     ** DDR2 first, and only do generic allocation if those fail */
name|int64_t
name|console_block_addr
init|=
name|cvmx_bootmem_phy_named_block_alloc
argument_list|(
name|alloc_size
argument_list|,
name|DDR0_TOP
operator|-
name|alloc_size
operator|-
literal|128
argument_list|,
name|DDR0_TOP
argument_list|,
literal|128
argument_list|,
name|OCTEON_PCI_CONSOLE_BLOCK_NAME
argument_list|,
name|CVMX_BOOTMEM_FLAG_END_ALLOC
argument_list|)
decl_stmt|;
if|if
condition|(
name|console_block_addr
operator|<
literal|0
condition|)
name|console_block_addr
operator|=
name|cvmx_bootmem_phy_named_block_alloc
argument_list|(
name|alloc_size
argument_list|,
name|DDR2_BASE
operator|+
literal|1
argument_list|,
name|DDR2_BASE
operator|+
name|alloc_size
operator|+
literal|128
argument_list|,
literal|128
argument_list|,
name|OCTEON_PCI_CONSOLE_BLOCK_NAME
argument_list|,
name|CVMX_BOOTMEM_FLAG_END_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|console_block_addr
operator|<
literal|0
condition|)
name|console_block_addr
operator|=
name|cvmx_bootmem_phy_named_block_alloc
argument_list|(
name|alloc_size
argument_list|,
literal|0
argument_list|,
literal|0x7fffffff
argument_list|,
literal|128
argument_list|,
name|OCTEON_PCI_CONSOLE_BLOCK_NAME
argument_list|,
name|CVMX_BOOTMEM_FLAG_END_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|console_block_addr
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|cons_desc_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uint32_t
operator|)
name|console_block_addr
expr_stmt|;
name|memset
argument_list|(
name|cons_desc_ptr
argument_list|,
literal|0
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
comment|/* Clear entire alloc'ed memory */
name|cons_desc_ptr
operator|->
name|lock
operator|=
literal|1
expr_stmt|;
comment|/* initialize as locked until we are done */
name|CVMX_SYNCW
expr_stmt|;
name|cons_desc_ptr
operator|->
name|num_consoles
operator|=
name|num_consoles
expr_stmt|;
name|cons_desc_ptr
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|cons_desc_ptr
operator|->
name|major_version
operator|=
name|OCTEON_PCI_CONSOLE_MAJOR_VERSION
expr_stmt|;
name|cons_desc_ptr
operator|->
name|minor_version
operator|=
name|OCTEON_PCI_CONSOLE_MINOR_VERSION
expr_stmt|;
name|int
name|i
decl_stmt|;
name|uint64_t
name|avail_addr
init|=
name|console_block_addr
operator|+
sizeof|sizeof
argument_list|(
name|octeon_pci_console_desc_t
argument_list|)
operator|+
name|num_consoles
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_consoles
condition|;
name|i
operator|++
control|)
block|{
name|cons_desc_ptr
operator|->
name|console_addr_array
index|[
name|i
index|]
operator|=
name|avail_addr
expr_stmt|;
name|cons_ptr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|uint32_t
operator|)
name|cons_desc_ptr
operator|->
name|console_addr_array
index|[
name|i
index|]
expr_stmt|;
name|avail_addr
operator|+=
sizeof|sizeof
argument_list|(
name|octeon_pci_console_t
argument_list|)
expr_stmt|;
name|cons_ptr
operator|->
name|input_base_addr
operator|=
name|avail_addr
expr_stmt|;
name|avail_addr
operator|+=
name|buffer_size
expr_stmt|;
name|cons_ptr
operator|->
name|output_base_addr
operator|=
name|avail_addr
expr_stmt|;
name|avail_addr
operator|+=
name|buffer_size
expr_stmt|;
name|cons_ptr
operator|->
name|buf_size
operator|=
name|buffer_size
expr_stmt|;
block|}
name|CVMX_SYNCW
expr_stmt|;
name|cons_desc_ptr
operator|->
name|lock
operator|=
literal|0
expr_stmt|;
return|return
name|console_block_addr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

