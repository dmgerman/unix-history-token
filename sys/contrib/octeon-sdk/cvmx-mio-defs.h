begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-mio-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon mio.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_MIO_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_MIO_DEFS_H__
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_BIST_STAT
value|(CVMX_ADD_IO_SEG(0x00011800000000F8ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_COMP
value|CVMX_MIO_BOOT_COMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_COMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_COMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800000000B8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_COMP
value|(CVMX_ADD_IO_SEG(0x00011800000000B8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_DMA_CFGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_DMA_CFGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000100ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_DMA_CFGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000100ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_DMA_INTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_DMA_INTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000138ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_DMA_INTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000138ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_DMA_INT_ENX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_DMA_INT_ENX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000150ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_DMA_INT_ENX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000150ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_DMA_TIMX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_DMA_TIMX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000120ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_DMA_TIMX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000120ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_ERR
value|(CVMX_ADD_IO_SEG(0x00011800000000A0ull))
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_INT
value|(CVMX_ADD_IO_SEG(0x00011800000000A8ull))
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_LOC_ADR
value|(CVMX_ADD_IO_SEG(0x0001180000000090ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_LOC_CFGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_LOC_CFGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_LOC_CFGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000080ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_LOC_DAT
value|(CVMX_ADD_IO_SEG(0x0001180000000098ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_PIN_DEFS
value|CVMX_MIO_BOOT_PIN_DEFS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_PIN_DEFS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_PIN_DEFS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800000000C0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_PIN_DEFS
value|(CVMX_ADD_IO_SEG(0x00011800000000C0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_REG_CFGX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_REG_CFGX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_REG_CFGX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000000ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_BOOT_REG_TIMX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_BOOT_REG_TIMX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_REG_TIMX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000040ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_BOOT_THR
value|(CVMX_ADD_IO_SEG(0x00011800000000B0ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_BUF_DAT
value|CVMX_MIO_EMM_BUF_DAT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_BUF_DAT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_BUF_DAT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800000020E8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_BUF_DAT
value|(CVMX_ADD_IO_SEG(0x00011800000020E8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_BUF_IDX
value|CVMX_MIO_EMM_BUF_IDX_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_BUF_IDX_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_BUF_IDX not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800000020E0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_BUF_IDX
value|(CVMX_ADD_IO_SEG(0x00011800000020E0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_CFG
value|CVMX_MIO_EMM_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_CFG
value|(CVMX_ADD_IO_SEG(0x0001180000002000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_CMD
value|CVMX_MIO_EMM_CMD_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_CMD_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_CMD not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002058ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_CMD
value|(CVMX_ADD_IO_SEG(0x0001180000002058ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_DMA
value|CVMX_MIO_EMM_DMA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_DMA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_DMA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002050ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_DMA
value|(CVMX_ADD_IO_SEG(0x0001180000002050ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_INT
value|CVMX_MIO_EMM_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002078ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_INT
value|(CVMX_ADD_IO_SEG(0x0001180000002078ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_INT_EN
value|CVMX_MIO_EMM_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002080ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001180000002080ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_MODEX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_MODEX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_MODEX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000002008ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RCA
value|CVMX_MIO_EMM_RCA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_RCA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_RCA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800000020A0ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RCA
value|(CVMX_ADD_IO_SEG(0x00011800000020A0ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RSP_HI
value|CVMX_MIO_EMM_RSP_HI_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_RSP_HI_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_RSP_HI not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002070ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RSP_HI
value|(CVMX_ADD_IO_SEG(0x0001180000002070ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RSP_LO
value|CVMX_MIO_EMM_RSP_LO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_RSP_LO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_RSP_LO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002068ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RSP_LO
value|(CVMX_ADD_IO_SEG(0x0001180000002068ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RSP_STS
value|CVMX_MIO_EMM_RSP_STS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_RSP_STS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_RSP_STS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002060ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_RSP_STS
value|(CVMX_ADD_IO_SEG(0x0001180000002060ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_SAMPLE
value|CVMX_MIO_EMM_SAMPLE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_SAMPLE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_SAMPLE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002090ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_SAMPLE
value|(CVMX_ADD_IO_SEG(0x0001180000002090ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_STS_MASK
value|CVMX_MIO_EMM_STS_MASK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_STS_MASK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_STS_MASK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002098ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_STS_MASK
value|(CVMX_ADD_IO_SEG(0x0001180000002098ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_SWITCH
value|CVMX_MIO_EMM_SWITCH_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_SWITCH_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_SWITCH not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002048ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_SWITCH
value|(CVMX_ADD_IO_SEG(0x0001180000002048ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_WDOG
value|CVMX_MIO_EMM_WDOG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_EMM_WDOG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_EMM_WDOG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000002088ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_EMM_WDOG
value|(CVMX_ADD_IO_SEG(0x0001180000002088ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_BNK_DATX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_BNK_DATX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001520ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_BNK_DATX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001520ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_DAT0
value|(CVMX_ADD_IO_SEG(0x0001180000001400ull))
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_DAT1
value|(CVMX_ADD_IO_SEG(0x0001180000001408ull))
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_DAT2
value|(CVMX_ADD_IO_SEG(0x0001180000001410ull))
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_DAT3
value|(CVMX_ADD_IO_SEG(0x0001180000001418ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_EMA
value|CVMX_MIO_FUS_EMA_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_EMA_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_EMA not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001550ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_EMA
value|(CVMX_ADD_IO_SEG(0x0001180000001550ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PDF
value|CVMX_MIO_FUS_PDF_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_PDF_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_PDF not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001420ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PDF
value|(CVMX_ADD_IO_SEG(0x0001180000001420ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PLL
value|CVMX_MIO_FUS_PLL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_PLL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_PLL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001580ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PLL
value|(CVMX_ADD_IO_SEG(0x0001180000001580ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PROG
value|(CVMX_ADD_IO_SEG(0x0001180000001510ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PROG_TIMES
value|CVMX_MIO_FUS_PROG_TIMES_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_PROG_TIMES_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN5XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_PROG_TIMES not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001518ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_PROG_TIMES
value|(CVMX_ADD_IO_SEG(0x0001180000001518ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_RCMD
value|(CVMX_ADD_IO_SEG(0x0001180000001500ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_READ_TIMES
value|CVMX_MIO_FUS_READ_TIMES_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_READ_TIMES_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_READ_TIMES not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001570ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_READ_TIMES
value|(CVMX_ADD_IO_SEG(0x0001180000001570ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_REPAIR_RES0
value|CVMX_MIO_FUS_REPAIR_RES0_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_REPAIR_RES0_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_REPAIR_RES0 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001558ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_REPAIR_RES0
value|(CVMX_ADD_IO_SEG(0x0001180000001558ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_REPAIR_RES1
value|CVMX_MIO_FUS_REPAIR_RES1_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_REPAIR_RES1_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_REPAIR_RES1 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001560ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_REPAIR_RES1
value|(CVMX_ADD_IO_SEG(0x0001180000001560ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_REPAIR_RES2
value|CVMX_MIO_FUS_REPAIR_RES2_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_REPAIR_RES2_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_REPAIR_RES2 not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001568ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_REPAIR_RES2
value|(CVMX_ADD_IO_SEG(0x0001180000001568ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_SPR_REPAIR_RES
value|(CVMX_ADD_IO_SEG(0x0001180000001548ull))
end_define

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_SPR_REPAIR_SUM
value|(CVMX_ADD_IO_SEG(0x0001180000001540ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_TGG
value|CVMX_MIO_FUS_TGG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_TGG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_TGG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001428ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_TGG
value|(CVMX_ADD_IO_SEG(0x0001180000001428ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_UNLOCK
value|CVMX_MIO_FUS_UNLOCK_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_FUS_UNLOCK_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_FUS_UNLOCK not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001578ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_UNLOCK
value|(CVMX_ADD_IO_SEG(0x0001180000001578ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_MIO_FUS_WADR
value|(CVMX_ADD_IO_SEG(0x0001180000001508ull))
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_GPIO_COMP
value|CVMX_MIO_GPIO_COMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_GPIO_COMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_GPIO_COMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800000000C8ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_GPIO_COMP
value|(CVMX_ADD_IO_SEG(0x00011800000000C8ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_NDF_DMA_CFG
value|CVMX_MIO_NDF_DMA_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_NDF_DMA_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_NDF_DMA_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000168ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_NDF_DMA_CFG
value|(CVMX_ADD_IO_SEG(0x0001180000000168ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_NDF_DMA_INT
value|CVMX_MIO_NDF_DMA_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_NDF_DMA_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_NDF_DMA_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000170ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_NDF_DMA_INT
value|(CVMX_ADD_IO_SEG(0x0001180000000170ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_NDF_DMA_INT_EN
value|CVMX_MIO_NDF_DMA_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_NDF_DMA_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_NDF_DMA_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000178ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_NDF_DMA_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001180000000178ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PLL_CTL
value|CVMX_MIO_PLL_CTL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PLL_CTL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PLL_CTL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001448ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PLL_CTL
value|(CVMX_ADD_IO_SEG(0x0001180000001448ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PLL_SETTING
value|CVMX_MIO_PLL_SETTING_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PLL_SETTING_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PLL_SETTING not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001440ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PLL_SETTING
value|(CVMX_ADD_IO_SEG(0x0001180000001440ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_HI_INCR
value|CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CKOUT_HI_INCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CKOUT_HI_INCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F40ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_HI_INCR
value|(CVMX_ADD_IO_SEG(0x0001070000000F40ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_LO_INCR
value|CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CKOUT_LO_INCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CKOUT_LO_INCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F48ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_LO_INCR
value|(CVMX_ADD_IO_SEG(0x0001070000000F48ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_THRESH_HI
value|CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CKOUT_THRESH_HI_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CKOUT_THRESH_HI not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F38ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_THRESH_HI
value|(CVMX_ADD_IO_SEG(0x0001070000000F38ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_THRESH_LO
value|CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CKOUT_THRESH_LO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CKOUT_THRESH_LO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F30ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CKOUT_THRESH_LO
value|(CVMX_ADD_IO_SEG(0x0001070000000F30ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_CFG
value|CVMX_MIO_PTP_CLOCK_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CLOCK_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CLOCK_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F00ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_CFG
value|(CVMX_ADD_IO_SEG(0x0001070000000F00ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_COMP
value|CVMX_MIO_PTP_CLOCK_COMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CLOCK_COMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CLOCK_COMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F18ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_COMP
value|(CVMX_ADD_IO_SEG(0x0001070000000F18ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_HI
value|CVMX_MIO_PTP_CLOCK_HI_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CLOCK_HI_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CLOCK_HI not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F10ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_HI
value|(CVMX_ADD_IO_SEG(0x0001070000000F10ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_LO
value|CVMX_MIO_PTP_CLOCK_LO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_CLOCK_LO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_CLOCK_LO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F08ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_CLOCK_LO
value|(CVMX_ADD_IO_SEG(0x0001070000000F08ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_EVT_CNT
value|CVMX_MIO_PTP_EVT_CNT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_EVT_CNT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_EVT_CNT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F28ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_EVT_CNT
value|(CVMX_ADD_IO_SEG(0x0001070000000F28ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PHY_1PPS_IN
value|CVMX_MIO_PTP_PHY_1PPS_IN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_PHY_1PPS_IN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_PHY_1PPS_IN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F70ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PHY_1PPS_IN
value|(CVMX_ADD_IO_SEG(0x0001070000000F70ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_HI_INCR
value|CVMX_MIO_PTP_PPS_HI_INCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_PPS_HI_INCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_PPS_HI_INCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F60ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_HI_INCR
value|(CVMX_ADD_IO_SEG(0x0001070000000F60ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_LO_INCR
value|CVMX_MIO_PTP_PPS_LO_INCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_PPS_LO_INCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_PPS_LO_INCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F68ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_LO_INCR
value|(CVMX_ADD_IO_SEG(0x0001070000000F68ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_THRESH_HI
value|CVMX_MIO_PTP_PPS_THRESH_HI_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_PPS_THRESH_HI_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_PPS_THRESH_HI not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F58ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_THRESH_HI
value|(CVMX_ADD_IO_SEG(0x0001070000000F58ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_THRESH_LO
value|CVMX_MIO_PTP_PPS_THRESH_LO_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_PPS_THRESH_LO_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_PPS_THRESH_LO not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F50ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_PPS_THRESH_LO
value|(CVMX_ADD_IO_SEG(0x0001070000000F50ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_TIMESTAMP
value|CVMX_MIO_PTP_TIMESTAMP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_PTP_TIMESTAMP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_PTP_TIMESTAMP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001070000000F20ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_PTP_TIMESTAMP
value|(CVMX_ADD_IO_SEG(0x0001070000000F20ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_QLMX_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|4
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_QLMX_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001590ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_QLMX_CFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001590ull) + ((offset)& 7) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_RST_BOOT
value|CVMX_MIO_RST_BOOT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_BOOT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_BOOT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001600ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_BOOT
value|(CVMX_ADD_IO_SEG(0x0001180000001600ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_RST_CFG
value|CVMX_MIO_RST_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001610ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_CFG
value|(CVMX_ADD_IO_SEG(0x0001180000001610ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_RST_CKILL
value|CVMX_MIO_RST_CKILL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_CKILL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_CKILL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001638ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_CKILL
value|(CVMX_ADD_IO_SEG(0x0001180000001638ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_CNTLX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_CNTLX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001648ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_CNTLX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001648ull) + ((offset)& 3) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_CTLX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_CTLX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001618ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_CTLX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001618ull) + ((offset)& 1) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_RST_DELAY
value|CVMX_MIO_RST_DELAY_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_DELAY_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_DELAY not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001608ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_DELAY
value|(CVMX_ADD_IO_SEG(0x0001180000001608ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_RST_INT
value|CVMX_MIO_RST_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001628ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_INT
value|(CVMX_ADD_IO_SEG(0x0001180000001628ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_RST_INT_EN
value|CVMX_MIO_RST_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_RST_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_RST_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001630ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_RST_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001180000001630ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_TWSX_INT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_TWSX_INT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|512
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_TWSX_INT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001010ull) + ((offset)& 1) * 512)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_TWSX_SW_TWSI
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_TWSX_SW_TWSI(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|512
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_TWSX_SW_TWSI
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001000ull) + ((offset)& 1) * 512)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_TWSX_SW_TWSI_EXT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_TWSX_SW_TWSI_EXT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|512
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_TWSX_SW_TWSI_EXT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001018ull) + ((offset)& 1) * 512)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_TWSX_TWSI_SW
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_TWSX_TWSI_SW(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000001008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|512
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_TWSX_TWSI_SW
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000001008ull) + ((offset)& 1) * 512)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_DLH
value|CVMX_MIO_UART2_DLH_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_DLH_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_DLH not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000488ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_DLH
value|(CVMX_ADD_IO_SEG(0x0001180000000488ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_DLL
value|CVMX_MIO_UART2_DLL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_DLL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_DLL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000480ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_DLL
value|(CVMX_ADD_IO_SEG(0x0001180000000480ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_FAR
value|CVMX_MIO_UART2_FAR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_FAR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_FAR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000520ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_FAR
value|(CVMX_ADD_IO_SEG(0x0001180000000520ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_FCR
value|CVMX_MIO_UART2_FCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_FCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_FCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000450ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_FCR
value|(CVMX_ADD_IO_SEG(0x0001180000000450ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_HTX
value|CVMX_MIO_UART2_HTX_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_HTX_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_HTX not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000708ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_HTX
value|(CVMX_ADD_IO_SEG(0x0001180000000708ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_IER
value|CVMX_MIO_UART2_IER_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_IER_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_IER not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000408ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_IER
value|(CVMX_ADD_IO_SEG(0x0001180000000408ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_IIR
value|CVMX_MIO_UART2_IIR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_IIR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_IIR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000410ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_IIR
value|(CVMX_ADD_IO_SEG(0x0001180000000410ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_LCR
value|CVMX_MIO_UART2_LCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_LCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_LCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000418ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_LCR
value|(CVMX_ADD_IO_SEG(0x0001180000000418ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_LSR
value|CVMX_MIO_UART2_LSR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_LSR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_LSR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000428ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_LSR
value|(CVMX_ADD_IO_SEG(0x0001180000000428ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_MCR
value|CVMX_MIO_UART2_MCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_MCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_MCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000420ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_MCR
value|(CVMX_ADD_IO_SEG(0x0001180000000420ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_MSR
value|CVMX_MIO_UART2_MSR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_MSR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_MSR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000430ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_MSR
value|(CVMX_ADD_IO_SEG(0x0001180000000430ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_RBR
value|CVMX_MIO_UART2_RBR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_RBR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_RBR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000400ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_RBR
value|(CVMX_ADD_IO_SEG(0x0001180000000400ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_RFL
value|CVMX_MIO_UART2_RFL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_RFL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_RFL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000608ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_RFL
value|(CVMX_ADD_IO_SEG(0x0001180000000608ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_RFW
value|CVMX_MIO_UART2_RFW_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_RFW_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_RFW not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000530ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_RFW
value|(CVMX_ADD_IO_SEG(0x0001180000000530ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SBCR
value|CVMX_MIO_UART2_SBCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_SBCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_SBCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000620ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SBCR
value|(CVMX_ADD_IO_SEG(0x0001180000000620ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SCR
value|CVMX_MIO_UART2_SCR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_SCR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_SCR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000438ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SCR
value|(CVMX_ADD_IO_SEG(0x0001180000000438ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SFE
value|CVMX_MIO_UART2_SFE_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_SFE_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_SFE not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000630ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SFE
value|(CVMX_ADD_IO_SEG(0x0001180000000630ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SRR
value|CVMX_MIO_UART2_SRR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_SRR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_SRR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000610ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SRR
value|(CVMX_ADD_IO_SEG(0x0001180000000610ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SRT
value|CVMX_MIO_UART2_SRT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_SRT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_SRT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000638ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SRT
value|(CVMX_ADD_IO_SEG(0x0001180000000638ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SRTS
value|CVMX_MIO_UART2_SRTS_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_SRTS_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_SRTS not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000618ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_SRTS
value|(CVMX_ADD_IO_SEG(0x0001180000000618ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_STT
value|CVMX_MIO_UART2_STT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_STT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_STT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000700ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_STT
value|(CVMX_ADD_IO_SEG(0x0001180000000700ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_TFL
value|CVMX_MIO_UART2_TFL_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_TFL_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_TFL not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000600ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_TFL
value|(CVMX_ADD_IO_SEG(0x0001180000000600ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_TFR
value|CVMX_MIO_UART2_TFR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_TFR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_TFR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000528ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_TFR
value|(CVMX_ADD_IO_SEG(0x0001180000000528ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_THR
value|CVMX_MIO_UART2_THR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_THR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_THR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000440ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_THR
value|(CVMX_ADD_IO_SEG(0x0001180000000440ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_USR
value|CVMX_MIO_UART2_USR_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UART2_USR_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UART2_USR not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000538ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UART2_USR
value|(CVMX_ADD_IO_SEG(0x0001180000000538ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_DLH
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_DLH(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000888ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_DLH
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000888ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_DLL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_DLL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000880ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_DLL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000880ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_FAR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_FAR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000920ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_FAR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000920ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_FCR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_FCR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000850ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_FCR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000850ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_HTX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_HTX(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000B08ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_HTX
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000B08ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_IER
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_IER(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000808ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_IER
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000808ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_IIR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_IIR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000810ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_IIR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000810ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_LCR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_LCR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000818ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_LCR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000818ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_LSR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_LSR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000828ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_LSR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000828ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_MCR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_MCR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000820ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_MCR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000820ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_MSR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_MSR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000830ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_MSR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000830ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_RBR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_RBR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000800ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_RBR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000800ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_RFL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_RFL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A08ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_RFL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A08ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_RFW
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_RFW(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000930ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_RFW
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000930ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_SBCR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_SBCR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A20ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_SBCR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A20ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_SCR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_SCR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000838ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_SCR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000838ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_SFE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_SFE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A30ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_SFE
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A30ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_SRR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_SRR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A10ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_SRR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A10ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_SRT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_SRT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A38ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_SRT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A38ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_SRTS
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_SRTS(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A18ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_SRTS
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A18ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_STT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_STT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000B00ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_STT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000B00ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_TFL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_TFL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000A00ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_TFL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000A00ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_TFR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_TFR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000928ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_TFR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000928ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_THR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_THR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000840ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_THR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000840ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_MIO_UARTX_USR
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN61XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF71XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_MIO_UARTX_USR(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180000000938ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_MIO_UARTX_USR
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180000000938ull) + ((offset)& 1) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_mio_boot_bist_stat  *  * MIO_BOOT_BIST_STAT = MIO Boot BIST Status Register  *  * Contains the BIST status for the MIO boot memories.  '0' = pass, '1' = fail.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_bist_stat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_bist_stat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|ncbo_1
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO 1 BIST status */
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO 0 BIST status */
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
comment|/**< Local memory BIST status */
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
comment|/**< NCB input FIFO BIST status */
else|#
directive|else
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_mio_boot_bist_stat_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO BIST status */
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
comment|/**< Local memory BIST status */
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
comment|/**< NCB input FIFO BIST status */
else|#
directive|else
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_mio_boot_bist_stat_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|pcm_1
range|:
literal|1
decl_stmt|;
comment|/**< PCM memory 1 BIST status */
name|uint64_t
name|pcm_0
range|:
literal|1
decl_stmt|;
comment|/**< PCM memory 0 BIST status */
name|uint64_t
name|ncbo_1
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO 1 BIST status */
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO 0 BIST status */
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
comment|/**< Local memory region BIST status */
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
comment|/**< NCB input FIFO BIST status */
else|#
directive|else
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcm_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pcm_1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|ndf
range|:
literal|2
decl_stmt|;
comment|/**< NAND flash BIST status */
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO BIST status */
name|uint64_t
name|dma
range|:
literal|1
decl_stmt|;
comment|/**< DMA memory BIST status */
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
comment|/**< Local memory BIST status */
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
comment|/**< NCB input FIFO BIST status */
else|#
directive|else
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ndf
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn52xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
comment|/**< NCB output FIFO BIST status */
name|uint64_t
name|dma
range|:
literal|1
decl_stmt|;
comment|/**< DMA memory BIST status */
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
comment|/**< Local memory region BIST status */
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
comment|/**< NCB input FIFO BIST status */
else|#
directive|else
name|uint64_t
name|ncbi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ncbo_0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_mio_boot_bist_stat_cn52xxp1
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_bist_stat_cn52xxp1
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_bist_stat_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_bist_stat_cn38xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|stat
range|:
literal|12
decl_stmt|;
comment|/**< BIST status */
else|#
directive|else
name|uint64_t
name|stat
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|stat
range|:
literal|9
decl_stmt|;
comment|/**< BIST status */
else|#
directive|else
name|uint64_t
name|stat
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_mio_boot_bist_stat_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_boot_bist_stat_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|stat
range|:
literal|10
decl_stmt|;
comment|/**< BIST status */
else|#
directive|else
name|uint64_t
name|stat
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_mio_boot_bist_stat_cn66xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_bist_stat_cn66xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_bist_stat_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_bist_stat
name|cvmx_mio_boot_bist_stat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_comp  *  * MIO_BOOT_COMP = MIO Boot Compensation Register  *  * Reset value is as follows:  *  * no pullups,               PCTL=38, NCTL=30 (25 ohm termination)  * pullup on boot_ad[9],     PCTL=19, NCTL=15 (50 ohm termination)  * pullup on boot_ad[10],    PCTL=15, NCTL=12 (65 ohm termination)  * pullups on boot_ad[10:9], PCTL=15, NCTL=12 (65 ohm termination)  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_comp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_comp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_boot_comp_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< Boot bus PCTL */
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< Boot bus NCTL */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_mio_boot_comp_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn50xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_boot_comp_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|6
decl_stmt|;
comment|/**< Boot bus PCTL */
name|uint64_t
name|nctl
range|:
literal|6
decl_stmt|;
comment|/**< Boot bus NCTL */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_boot_comp_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_comp_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_comp
name|cvmx_mio_boot_comp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_dma_cfg#  *  * MIO_BOOT_DMA_CFG = MIO Boot DMA Config Register (1 per engine * 2 engines)  *  * SIZE is specified in number of bus transfers, where one transfer is equal to the following number  * of bytes dependent on MIO_BOOT_DMA_TIMn[WIDTH] and MIO_BOOT_DMA_TIMn[DDR]:  *  * WIDTH     DDR      Transfer Size (bytes)  * ----------------------------------------  *   0        0               2  *   0        1               4  *   1        0               4  *   1        1               8  *  * Note: ADR must be aligned to the bus width (i.e. 16 bit aligned if WIDTH=0, 32 bit aligned if WIDTH=1).  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_dma_cfgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_dma_cfgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X enable */
name|uint64_t
name|rw
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X R/W bit (0 = read, 1 = write) */
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X clear EN on device terminated burst */
name|uint64_t
name|reserved_60_60
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap32
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X 32 bit swap */
name|uint64_t
name|swap16
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X 16 bit swap */
name|uint64_t
name|swap8
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X 8 bit swap */
name|uint64_t
name|endian
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X NCB endian mode (0 = big, 1 = little) */
name|uint64_t
name|size
range|:
literal|20
decl_stmt|;
comment|/**< DMA Engine X size */
name|uint64_t
name|adr
range|:
literal|36
decl_stmt|;
comment|/**< DMA Engine X address */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|size
range|:
literal|20
decl_stmt|;
name|uint64_t
name|endian
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap32
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_60_60
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_cfgx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_dma_cfgx
name|cvmx_mio_boot_dma_cfgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_dma_int#  *  * MIO_BOOT_DMA_INT = MIO Boot DMA Interrupt Register (1 per engine * 2 engines)  *  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_dma_intx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_dma_intx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dmarq
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X DMARQ asserted interrupt */
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X request completion interrupt */
else|#
directive|else
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmarq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_intx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_dma_intx
name|cvmx_mio_boot_dma_intx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_dma_int_en#  *  * MIO_BOOT_DMA_INT_EN = MIO Boot DMA Interrupt Enable Register (1 per engine * 2 engines)  *  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_dma_int_enx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_dma_int_enx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|dmarq
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X DMARQ asserted interrupt enable */
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X request completion interrupt enable */
else|#
directive|else
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmarq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_int_enx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_dma_int_enx
name|cvmx_mio_boot_dma_int_enx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_dma_tim#  *  * MIO_BOOT_DMA_TIM = MIO Boot DMA Timing Register (1 per engine * 2 engines)  *  * DMACK_PI inverts the assertion level of boot_dmack[n].  The default polarity of boot_dmack[1:0] is  * selected on the first de-assertion of reset by the values on boot_ad[12:11], where 0 is active high  * and 1 is active low (see MIO_BOOT_PIN_DEFS for a read-only copy of the default polarity).  * boot_ad[12:11] have internal pulldowns, so place a pullup on boot_ad[n+11] for active low default  * polarity on engine n.  To interface with CF cards in True IDE Mode, either a pullup should be placed  * on boot_ad[n+11] OR the corresponding DMACK_PI[n] should be set.  *  * DMARQ_PI inverts the assertion level of boot_dmarq[n].  The default polarity of boot_dmarq[1:0] is  * active high, thus setting the polarity inversion bits changes the polarity to active low.  To  * interface with CF cards in True IDE Mode, the corresponding DMARQ_PI[n] should be clear.  *  * TIM_MULT specifies the timing multiplier for an engine.  The timing multiplier applies to all timing  * parameters, except for DMARQ and RD_DLY, which simply count eclks.  TIM_MULT is encoded as follows:  * 0 = 4x, 1 = 1x, 2 = 2x, 3 = 8x.  *  * RD_DLY specifies the read sample delay in eclk cycles for an engine.  For reads, the data bus is  * normally sampled on the same eclk edge that drives boot_oe_n high (and also low in DDR mode).  * This parameter can delay that sampling edge by up to 7 eclks.  Note: the number of eclk cycles  * counted by the OE_A and DMACK_H + PAUSE timing parameters must be greater than RD_DLY.  *  * If DDR is set, then WE_N must be less than WE_A.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_dma_timx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_dma_timx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dmack_pi
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X DMA ack polarity inversion */
name|uint64_t
name|dmarq_pi
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X DMA request polarity inversion */
name|uint64_t
name|tim_mult
range|:
literal|2
decl_stmt|;
comment|/**< DMA Engine X timing multiplier */
name|uint64_t
name|rd_dly
range|:
literal|3
decl_stmt|;
comment|/**< DMA Engine X read sample delay */
name|uint64_t
name|ddr
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X DDR mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine X bus width (0 = 16 bits, 1 = 32 bits) */
name|uint64_t
name|reserved_48_54
range|:
literal|7
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X pause count */
name|uint64_t
name|dmack_h
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X DMA ack hold count */
name|uint64_t
name|we_n
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X write enable negated count */
name|uint64_t
name|we_a
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X write enable asserted count */
name|uint64_t
name|oe_n
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X output enable negated count */
name|uint64_t
name|oe_a
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X output enable asserted count */
name|uint64_t
name|dmack_s
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X DMA ack setup count */
name|uint64_t
name|dmarq
range|:
literal|6
decl_stmt|;
comment|/**< DMA Engine X DMA request count (must be non-zero) */
else|#
directive|else
name|uint64_t
name|dmarq
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dmack_s
range|:
literal|6
decl_stmt|;
name|uint64_t
name|oe_a
range|:
literal|6
decl_stmt|;
name|uint64_t
name|oe_n
range|:
literal|6
decl_stmt|;
name|uint64_t
name|we_a
range|:
literal|6
decl_stmt|;
name|uint64_t
name|we_n
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dmack_h
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_48_54
range|:
literal|7
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_dly
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tim_mult
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dmarq_pi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_pi
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_dma_timx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_dma_timx
name|cvmx_mio_boot_dma_timx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_err  *  * MIO_BOOT_ERR = MIO Boot Error Register  *  * Contains the address decode error and wait mode error bits.  Address decode error is set when a  * boot bus access does not hit in any of the 8 remote regions or 2 local memory regions.  Wait mode error is  * set when wait mode is enabled and the external wait signal is not de-asserted after 32k eclk cycles.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_err
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_err_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|wait_err
range|:
literal|1
decl_stmt|;
comment|/**< Wait mode error */
name|uint64_t
name|adr_err
range|:
literal|1
decl_stmt|;
comment|/**< Address decode error */
else|#
directive|else
name|uint64_t
name|adr_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wait_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_err_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_err_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_err
name|cvmx_mio_boot_err_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_int  *  * MIO_BOOT_INT = MIO Boot Interrupt Register  *  * Contains the interrupt enable bits for address decode error and wait mode error.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|wait_int
range|:
literal|1
decl_stmt|;
comment|/**< Wait mode error interrupt enable */
name|uint64_t
name|adr_int
range|:
literal|1
decl_stmt|;
comment|/**< Address decode error interrupt enable */
else|#
directive|else
name|uint64_t
name|adr_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|wait_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_int_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_int
name|cvmx_mio_boot_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_loc_adr  *  * MIO_BOOT_LOC_ADR = MIO Boot Local Memory Region Address Register  *  * Specifies the address for reading or writing the local memory region.  This address will post-increment  * following an access to the MIO Boot Local Memory Region Data Register (MIO_BOOT_LOC_DAT).  *  * Local memory region 0 exists from addresses 0x00 - 0x78.  * Local memory region 1 exists from addresses 0x80 - 0xf8.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_loc_adr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_loc_adr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|adr
range|:
literal|5
decl_stmt|;
comment|/**< Local memory region address */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|adr
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_adr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_loc_adr
name|cvmx_mio_boot_loc_adr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_loc_cfg#  *  * MIO_BOOT_LOC_CFG = MIO Boot Local Memory Region Config Register (1 per region * 2 regions)  *  * Contains local memory region enable and local memory region base address parameters.  Each local memory region is 128  * bytes organized as 16 entries x 8 bytes.  *  * Base address specifies address bits [31:7] of the region.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_loc_cfgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_loc_cfgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Local memory region X enable */
name|uint64_t
name|reserved_28_30
range|:
literal|3
decl_stmt|;
name|uint64_t
name|base
range|:
literal|25
decl_stmt|;
comment|/**< Local memory region X base address */
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|base
range|:
literal|25
decl_stmt|;
name|uint64_t
name|reserved_28_30
range|:
literal|3
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_cfgx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_loc_cfgx
name|cvmx_mio_boot_loc_cfgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_loc_dat  *  * MIO_BOOT_LOC_DAT = MIO Boot Local Memory Region Data Register  *  * This is a pseudo-register that will read/write the local memory region at the address specified by the MIO  * Boot Local Memory Region Address Register (MIO_BOOT_LOC_ADR) when accessed.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_loc_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_loc_dat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
comment|/**< Local memory region data */
else|#
directive|else
name|uint64_t
name|data
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_loc_dat_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_loc_dat
name|cvmx_mio_boot_loc_dat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_pin_defs  *  * MIO_BOOT_PIN_DEFS = MIO Boot Pin Defaults Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_pin_defs
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_pin_defs_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|user1
range|:
literal|16
decl_stmt|;
comment|/**< BOOT_AD [31:16] latched during power up */
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default bus width */
name|uint64_t
name|dmack_p2
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[2] default polarity */
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[1] default polarity */
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[0] default polarity */
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
comment|/**< Selects default driver termination */
name|uint64_t
name|nand
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 is NAND flash */
name|uint64_t
name|user0
range|:
literal|8
decl_stmt|;
comment|/**< BOOT_AD [7:0] latched during power up */
else|#
directive|else
name|uint64_t
name|user0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nand
range|:
literal|1
decl_stmt|;
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|user1
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_boot_pin_defs_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default bus width */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[1] default polarity */
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[0] default polarity */
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
comment|/**< Selects default driver termination */
name|uint64_t
name|nand
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 is NAND flash */
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_7
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nand
range|:
literal|1
decl_stmt|;
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
struct|struct
name|cvmx_mio_boot_pin_defs_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default bus width */
name|uint64_t
name|dmack_p2
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[2] default polarity */
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[1] default polarity */
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[0] default polarity */
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
comment|/**< Selects default driver termination */
name|uint64_t
name|reserved_0_8
range|:
literal|9
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_8
range|:
literal|9
decl_stmt|;
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
struct|struct
name|cvmx_mio_boot_pin_defs_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|user1
range|:
literal|16
decl_stmt|;
comment|/**< BOOT_AD [31:16] latched during power up */
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 default bus width */
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[1] default polarity */
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
comment|/**< boot_dmack[0] default polarity */
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
comment|/**< Selects default driver termination */
name|uint64_t
name|nand
range|:
literal|1
decl_stmt|;
comment|/**< Region 0 is NAND flash */
name|uint64_t
name|user0
range|:
literal|8
decl_stmt|;
comment|/**< BOOT_AD [7:0] latched during power up */
else|#
directive|else
name|uint64_t
name|user0
range|:
literal|8
decl_stmt|;
name|uint64_t
name|nand
range|:
literal|1
decl_stmt|;
name|uint64_t
name|term
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dmack_p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dmack_p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_13
range|:
literal|1
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|user1
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_boot_pin_defs_cn52xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_pin_defs_cn52xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_pin_defs_cn52xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_pin_defs_cn52xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_pin_defs_cn52xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_pin_defs_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_pin_defs
name|cvmx_mio_boot_pin_defs_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_reg_cfg#  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_reg_cfgx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_reg_cfgx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|dmack
range|:
literal|2
decl_stmt|;
comment|/**< Region X DMACK */
name|uint64_t
name|tim_mult
range|:
literal|2
decl_stmt|;
comment|/**< Region X timing multiplier */
name|uint64_t
name|rd_dly
range|:
literal|3
decl_stmt|;
comment|/**< Region X read sample delay */
name|uint64_t
name|sam
range|:
literal|1
decl_stmt|;
comment|/**< Region X SAM mode */
name|uint64_t
name|we_ext
range|:
literal|2
decl_stmt|;
comment|/**< Region X write enable count extension */
name|uint64_t
name|oe_ext
range|:
literal|2
decl_stmt|;
comment|/**< Region X output enable count extension */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Region X enable */
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
comment|/**< Region X or bit */
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region X ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region X bus width */
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
comment|/**< Region X size */
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
comment|/**< Region X base address */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oe_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|we_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_dly
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tim_mult
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dmack
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_boot_reg_cfgx_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|sam
range|:
literal|1
decl_stmt|;
comment|/**< Region X SAM mode */
name|uint64_t
name|we_ext
range|:
literal|2
decl_stmt|;
comment|/**< Region X write enable count extension */
name|uint64_t
name|oe_ext
range|:
literal|2
decl_stmt|;
comment|/**< Region X output enable count extension */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Region X enable */
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
comment|/**< Region X or bit */
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region X ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region X bus width */
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
comment|/**< Region X size */
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
comment|/**< Region X base address */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oe_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|we_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_mio_boot_reg_cfgx_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_mio_boot_reg_cfgx_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Region X enable */
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
comment|/**< Region X or bit */
name|uint64_t
name|reserved_28_29
range|:
literal|2
decl_stmt|;
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
comment|/**< Region X size */
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
comment|/**< Region X base address */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_28_29
range|:
literal|2
decl_stmt|;
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_mio_boot_reg_cfgx_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_mio_boot_reg_cfgx_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|tim_mult
range|:
literal|2
decl_stmt|;
comment|/**< Region X timing multiplier */
name|uint64_t
name|rd_dly
range|:
literal|3
decl_stmt|;
comment|/**< Region X read sample delay */
name|uint64_t
name|sam
range|:
literal|1
decl_stmt|;
comment|/**< Region X SAM mode */
name|uint64_t
name|we_ext
range|:
literal|2
decl_stmt|;
comment|/**< Region X write enable count extension */
name|uint64_t
name|oe_ext
range|:
literal|2
decl_stmt|;
comment|/**< Region X output enable count extension */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< Region X enable */
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
comment|/**< Region X or bit */
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
comment|/**< Region X ALE mode */
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
comment|/**< Region X bus width */
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
comment|/**< Region X size */
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
comment|/**< Region X base address */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|16
decl_stmt|;
name|uint64_t
name|size
range|:
literal|12
decl_stmt|;
name|uint64_t
name|width
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|1
decl_stmt|;
name|uint64_t
name|orbit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oe_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|we_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|sam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rd_dly
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tim_mult
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_cfgx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_reg_cfgx
name|cvmx_mio_boot_reg_cfgx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_reg_tim#  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_reg_timx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_reg_timx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pagem
range|:
literal|1
decl_stmt|;
comment|/**< Region X page mode */
name|uint64_t
name|waitm
range|:
literal|1
decl_stmt|;
comment|/**< Region X wait mode */
name|uint64_t
name|pages
range|:
literal|2
decl_stmt|;
comment|/**< Region X page size */
name|uint64_t
name|ale
range|:
literal|6
decl_stmt|;
comment|/**< Region X ALE count */
name|uint64_t
name|page
range|:
literal|6
decl_stmt|;
comment|/**< Region X page count */
name|uint64_t
name|wait
range|:
literal|6
decl_stmt|;
comment|/**< Region X wait count */
name|uint64_t
name|pause
range|:
literal|6
decl_stmt|;
comment|/**< Region X pause count */
name|uint64_t
name|wr_hld
range|:
literal|6
decl_stmt|;
comment|/**< Region X write hold count */
name|uint64_t
name|rd_hld
range|:
literal|6
decl_stmt|;
comment|/**< Region X read hold count */
name|uint64_t
name|we
range|:
literal|6
decl_stmt|;
comment|/**< Region X write enable count */
name|uint64_t
name|oe
range|:
literal|6
decl_stmt|;
comment|/**< Region X output enable count */
name|uint64_t
name|ce
range|:
literal|6
decl_stmt|;
comment|/**< Region X chip enable count */
name|uint64_t
name|adr
range|:
literal|6
decl_stmt|;
comment|/**< Region X address count */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ce
range|:
literal|6
decl_stmt|;
name|uint64_t
name|oe
range|:
literal|6
decl_stmt|;
name|uint64_t
name|we
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rd_hld
range|:
literal|6
decl_stmt|;
name|uint64_t
name|wr_hld
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|6
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|6
decl_stmt|;
name|uint64_t
name|page
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ale
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pages
range|:
literal|2
decl_stmt|;
name|uint64_t
name|waitm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pagem
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_mio_boot_reg_timx_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pagem
range|:
literal|1
decl_stmt|;
comment|/**< Region X page mode */
name|uint64_t
name|waitm
range|:
literal|1
decl_stmt|;
comment|/**< Region X wait mode */
name|uint64_t
name|pages
range|:
literal|2
decl_stmt|;
comment|/**< Region X page size (NOT IN PASS 1) */
name|uint64_t
name|reserved_54_59
range|:
literal|6
decl_stmt|;
name|uint64_t
name|page
range|:
literal|6
decl_stmt|;
comment|/**< Region X page count */
name|uint64_t
name|wait
range|:
literal|6
decl_stmt|;
comment|/**< Region X wait count */
name|uint64_t
name|pause
range|:
literal|6
decl_stmt|;
comment|/**< Region X pause count */
name|uint64_t
name|wr_hld
range|:
literal|6
decl_stmt|;
comment|/**< Region X write hold count */
name|uint64_t
name|rd_hld
range|:
literal|6
decl_stmt|;
comment|/**< Region X read hold count */
name|uint64_t
name|we
range|:
literal|6
decl_stmt|;
comment|/**< Region X write enable count */
name|uint64_t
name|oe
range|:
literal|6
decl_stmt|;
comment|/**< Region X output enable count */
name|uint64_t
name|ce
range|:
literal|6
decl_stmt|;
comment|/**< Region X chip enable count */
name|uint64_t
name|adr
range|:
literal|6
decl_stmt|;
comment|/**< Region X address count */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ce
range|:
literal|6
decl_stmt|;
name|uint64_t
name|oe
range|:
literal|6
decl_stmt|;
name|uint64_t
name|we
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rd_hld
range|:
literal|6
decl_stmt|;
name|uint64_t
name|wr_hld
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pause
range|:
literal|6
decl_stmt|;
name|uint64_t
name|wait
range|:
literal|6
decl_stmt|;
name|uint64_t
name|page
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_54_59
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pages
range|:
literal|2
decl_stmt|;
name|uint64_t
name|waitm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pagem
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_mio_boot_reg_timx_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_reg_timx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_reg_timx
name|cvmx_mio_boot_reg_timx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_boot_thr  *  * MIO_BOOT_THR = MIO Boot Threshold Register  *  * Contains MIO Boot threshold values:  *  * FIF_THR = Assert ncb__busy when the Boot NCB input FIFO reaches this level (not typically for  *           customer use).  *  * DMA_THR = When non-DMA accesses are pending, perform a DMA access after this value of non-DMA  *           accesses have completed.  If set to zero, only perform a DMA access when non-DMA  *           accesses are not pending.  */
end_comment

begin_union
union|union
name|cvmx_mio_boot_thr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_boot_thr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
name|uint64_t
name|dma_thr
range|:
literal|6
decl_stmt|;
comment|/**< DMA threshold */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fif_cnt
range|:
literal|6
decl_stmt|;
comment|/**< Current NCB FIFO count */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fif_thr
range|:
literal|6
decl_stmt|;
comment|/**< NCB busy threshold */
else|#
directive|else
name|uint64_t
name|fif_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fif_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|dma_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_22_63
range|:
literal|42
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_boot_thr_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|fif_cnt
range|:
literal|6
decl_stmt|;
comment|/**< Current NCB FIFO count */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fif_thr
range|:
literal|6
decl_stmt|;
comment|/**< NCB busy threshold */
else|#
directive|else
name|uint64_t
name|fif_thr
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fif_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_mio_boot_thr_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_boot_thr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_boot_thr
name|cvmx_mio_boot_thr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_buf_dat  *  * MIO_EMM_BUF_DAT = MIO EMMC Data buffer access Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_buf_dat
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_buf_dat_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
comment|/**< Direct access to the 1KB data buffer memory.    Address                                                          specified by MIO_EMM_BUF_IDX */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_buf_dat_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_buf_dat_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_buf_dat
name|cvmx_mio_emm_buf_dat_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_buf_idx  *  * MIO_EMM_BUF_IDX = MIO EMMC Data buffer address Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_buf_idx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_buf_idx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|1
decl_stmt|;
comment|/**< Automatically advance BUF_SEL/OFFSET after each access to                                                          MIO_EMM_BUF_DAT.   Wraps after last offset of last data buffer. */
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|buf_num
range|:
literal|1
decl_stmt|;
comment|/**< Specify the data buffer for the next access to MIO_EMM_BUF_DAT */
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
comment|/**< Specify the 8B data buffer offset for the next access to                                                          MIO_EMM_BUF_DAT */
else|#
directive|else
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
name|uint64_t
name|buf_num
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_buf_idx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_buf_idx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_buf_idx
name|cvmx_mio_emm_buf_idx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_cfg  *  * MIO_EMM_CFG = MIO EMMC Configuration Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|boot_fail
range|:
literal|1
decl_stmt|;
comment|/**< SW should set BOOT_FAIL when an unrecoverable error occurs                                                          while attempt to boot from eMMC or NOR Flash.   When set, the                                                          following pattern will be output:                                                            BOOT_AD[7:0] pulled up to 1                                                            BOOT_CE_N[7:0] driven to 1                                                            BOOT_ALE driven to 0                                                            BOOT_OE_L driven to 1                                                            BOOT_WE_L driven to 1 */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|bus_ena
range|:
literal|4
decl_stmt|;
comment|/**< eMMC bus enable mask.                                                           Setting bit0 of BUS_ENA causes BOOT_CE[1] to become dedicated                                                          eMMC bus 0 command (ie. disabling any NOR use)                                                           Setting bit1 of BUS_ENA causes BOOT_CE[2] to become dedicated                                                          eMMC bus 1 command (ie. disabling any NOR use).                                                           Setting bit2 of BUS_ENA causes BOOT_CE[3] to become dedicated                                                          eMMC bus 2 command (ie. disabling any NOR use).                                                           Setting bit3 of BUS_ENA causes BOOT_CE[4] to become dedicated                                                          eMMC bus 3 command (ie. disabling any NOR use).                                                           Setting any bit of BUS_ENA causes BOOT_CE[5] to become the eMMC                                                          clock for both bus0 and bus1. */
else|#
directive|else
name|uint64_t
name|bus_ena
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|boot_fail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_cfg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_cfg
name|cvmx_mio_emm_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_cmd  *  * MIO_EMM_CMD = MIO EMMC Command Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_cmd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_cmd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
comment|/**< Specify the eMMC bus */
name|uint64_t
name|cmd_val
range|:
literal|1
decl_stmt|;
comment|/**< Request valid.  SW writes this bit to a 1.   HW clears it when                                                          the operation completes. */
name|uint64_t
name|reserved_56_58
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dbuf
range|:
literal|1
decl_stmt|;
comment|/**< Specify the data buffer to be used for a block transfer. */
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
comment|/**< Debug only.  Specify the number of 8 byte transfers in the                                                          used in the command.  Value is 64-OFFSET.  The block transfer                                                          will still start at the first btye in the 512B data buffer.                                                          SW must ensure CMD16 has updated the card block length. */
name|uint64_t
name|reserved_43_48
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ctype_xor
range|:
literal|2
decl_stmt|;
comment|/**< Reserved. Must be zero */
name|uint64_t
name|rtype_xor
range|:
literal|3
decl_stmt|;
comment|/**< Reserved. Must be zero */
name|uint64_t
name|cmd_idx
range|:
literal|6
decl_stmt|;
comment|/**< eMMC command */
name|uint64_t
name|arg
range|:
literal|32
decl_stmt|;
comment|/**< eMMC command argument */
else|#
directive|else
name|uint64_t
name|arg
range|:
literal|32
decl_stmt|;
name|uint64_t
name|cmd_idx
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rtype_xor
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ctype_xor
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_43_48
range|:
literal|6
decl_stmt|;
name|uint64_t
name|offset
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_56_58
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cmd_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_cmd_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_cmd_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_cmd
name|cvmx_mio_emm_cmd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_dma  *  * MIO_EMM_DMA = MIO EMMC DMA config Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_dma
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_dma_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
comment|/**< Specify the eMMC bus */
name|uint64_t
name|dma_val
range|:
literal|1
decl_stmt|;
comment|/**< SW writes this bit to a 1 to indicate that HW should perform                                                          the DMA transfer.   HW clears when DMA operation completes or                                                          is terminated. */
name|uint64_t
name|sector
range|:
literal|1
decl_stmt|;
comment|/**< Specify CARD_ADDR and eMMC are using sector (512B) addressing. */
name|uint64_t
name|dat_null
range|:
literal|1
decl_stmt|;
comment|/**< Do not perform any eMMC commands.   A DMA read will return all                                                          0s.  A DMA write tosses the data.  In the case of a failure,                                                          this can be used to unwind the DMA engine. */
name|uint64_t
name|thres
range|:
literal|6
decl_stmt|;
comment|/**< Number of 8B blocks of data that must exist in the DBUF before                                                          the starting the 512B block transfer.  0 indicates to wait for                                                          the entire block. */
name|uint64_t
name|rel_wr
range|:
literal|1
decl_stmt|;
comment|/**< Set the reliable write parameter when performing CMD23                                                          (SET_BLOCK_COUNT) for a multiple block */
name|uint64_t
name|rw
range|:
literal|1
decl_stmt|;
comment|/**< R/W bit (0 = read, 1 = write) */
name|uint64_t
name|multi
range|:
literal|1
decl_stmt|;
comment|/**< Perform operation using a multiple block command instead of a                                                          series of single block commands. */
name|uint64_t
name|block_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of blocks to read/write.  Hardware decrements the block                                                          count after each successful block transfer. */
name|uint64_t
name|card_addr
range|:
literal|32
decl_stmt|;
comment|/**< Data address for media =<2GB is a 32bit byte address and data                                                          address for media> 2GB is a 32bit sector (512B) address.                                                          Hardware advances the card address after each successful block                                                          transfer by 512 for byte addressing and by 1 for sector                                                          addressing. */
else|#
directive|else
name|uint64_t
name|card_addr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|block_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|multi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rel_wr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|thres
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dat_null
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sector
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_dma_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_dma_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_dma
name|cvmx_mio_emm_dma_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_int  *  * MIO_EMM_INT = MIO EMMC Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|switch_err
range|:
literal|1
decl_stmt|;
comment|/**< Switch operation encountered an error. */
name|uint64_t
name|switch_done
range|:
literal|1
decl_stmt|;
comment|/**< Switch operation completed successfully */
name|uint64_t
name|dma_err
range|:
literal|1
decl_stmt|;
comment|/**< DMA transfer encountered an error.   See MIO_EMM_RSP. */
name|uint64_t
name|cmd_err
range|:
literal|1
decl_stmt|;
comment|/**< Operation specified by MIO_EMM_CMD encountered an error.  See                                                          MIO_EMM_RSP. */
name|uint64_t
name|dma_done
range|:
literal|1
decl_stmt|;
comment|/**< DMA transfer completed successfully */
name|uint64_t
name|cmd_done
range|:
literal|1
decl_stmt|;
comment|/**< Operation specified by MIO_EMM_CMD completed successfully */
name|uint64_t
name|buf_done
range|:
literal|1
decl_stmt|;
comment|/**< The next 512B block transfer of a multi-block transfer has                                                          completed. */
else|#
directive|else
name|uint64_t
name|buf_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_int
name|cvmx_mio_emm_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_int_en  *  * MIO_EMM_INT_EN = MIO EMMC Interrupt enable Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|switch_err
range|:
literal|1
decl_stmt|;
comment|/**< Switch operation encountered an error. */
name|uint64_t
name|switch_done
range|:
literal|1
decl_stmt|;
comment|/**< Switch operation completed. */
name|uint64_t
name|dma_err
range|:
literal|1
decl_stmt|;
comment|/**< DMA transfer encountered an error.   See MIO_EMM_RSP. */
name|uint64_t
name|cmd_err
range|:
literal|1
decl_stmt|;
comment|/**< Operation specified by MIO_EMM_CMD encountered an error.  See                                                          MIO_EMM_RSP. */
name|uint64_t
name|dma_done
range|:
literal|1
decl_stmt|;
comment|/**< DMA transfer completed */
name|uint64_t
name|cmd_done
range|:
literal|1
decl_stmt|;
comment|/**< Operation specified by MIO_EMM_CMD completed */
name|uint64_t
name|buf_done
range|:
literal|1
decl_stmt|;
comment|/**< The next 512B block transfer of a multi-block transfer has                                                          completed. */
else|#
directive|else
name|uint64_t
name|buf_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_int_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_int_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_int_en
name|cvmx_mio_emm_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_mode#  *  * MIO_EMM_MODE = MIO EMMC Operating mode Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_modex
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_modex_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
name|uint64_t
name|hs_timing
range|:
literal|1
decl_stmt|;
comment|/**< Current high speed timing mode.   Required when CLK frequency                                                          higher than 20MHz. */
name|uint64_t
name|reserved_43_47
range|:
literal|5
decl_stmt|;
name|uint64_t
name|bus_width
range|:
literal|3
decl_stmt|;
comment|/**< Current card bus mode.  Out of reset, the card is in 1 bit data                                                          bus mode.   Select bus width.                                                           0 - 1 bit data bus (power on)                                                          1 - 4 bit data bus                                                          2 - 8 bit data bus                                                          5 - 4 bit data bus (dual data rate)                                                          6 - 8 bit data bus (dual data rate) */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|power_class
range|:
literal|4
decl_stmt|;
comment|/**< Out of reset, the card power class is 0, which is the minimum                                                          current consumption class for the card.  EXT_CSD bytes                                                          [203:200] and [239:238] contain the power class for different                                                          BUS_WITDH and CLK frequencies.  Software should write this                                                          field with the  4-bit field from the EXT_CSD bytes                                                          corresponding to the selected operating mode. */
name|uint64_t
name|clk_hi
range|:
literal|16
decl_stmt|;
comment|/**< Current number of sclk cycles to hold the eMMC CLK pin high */
name|uint64_t
name|clk_lo
range|:
literal|16
decl_stmt|;
comment|/**< Current number of sclk cycles to hold the eMMC CLK pin low. */
else|#
directive|else
name|uint64_t
name|clk_lo
range|:
literal|16
decl_stmt|;
name|uint64_t
name|clk_hi
range|:
literal|16
decl_stmt|;
name|uint64_t
name|power_class
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bus_width
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_43_47
range|:
literal|5
decl_stmt|;
name|uint64_t
name|hs_timing
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_63
range|:
literal|15
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_modex_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_modex_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_modex
name|cvmx_mio_emm_modex_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_rca  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_rca
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_rca_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|card_rca
range|:
literal|16
decl_stmt|;
comment|/**< Whenever SW performs CMD7, HW will update CARD_RCA with the                                                          relative card address from the MIO_EMM_CMD[ARG] unless the                                                          operations encounters an error. */
else|#
directive|else
name|uint64_t
name|card_rca
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_rca_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_rca_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_rca
name|cvmx_mio_emm_rca_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_rsp_hi  *  * MIO_EMM_RSP_HI = MIO EMMC Response data high Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_rsp_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_rsp_hi_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
comment|/**< Command response (as per JEDEC eMMC spec)                                                           RSP_TYPE=1 - DAT[63:0] - 0x0                                                          RSP_TYPE=2 - DAT[63:0] - CID[127:64] or CSD[127:64]                                                          RSP_TYPE=3 - DAT[63:0] - 0x0                                                          RSP_TYPE=4 - DAT[63:0] - 0x0                                                          RSP_TYPE=5 - DAT[63:0] - 0x0 */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_rsp_hi_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_rsp_hi_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_rsp_hi
name|cvmx_mio_emm_rsp_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_rsp_lo  *  * MIO_EMM_RSP_LO = MIO EMMC Response data low Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_rsp_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_rsp_lo_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
comment|/**< Command response (as per JEDEC eMMC spec)                                                           RSP_TYPE = 1                                                                  DAT[63:46] - 0x0                                                                  DAT[45:40] - Command index                                                                  DAT[39: 8] - Card status                                                                  DAT[ 7: 1] - CRC7                                                                  DAT[    0] - End bit                                                           RSP_TYPE = 2                                                                  DAT[63: 1] - CID[63:1] or CSD[63:1] including CRC                                                                  DAT[    0] - End bit                                                           RSP_TYPE = 3                                                                  DAT[63:46] - 0x0                                                                  DAT[45:40] - Check bits (0x3f)                                                                  DAT[39: 8] - OCR register                                                                  DAT[ 7: 1] - Check bits (0x7f)                                                                  DAT[    0] - End bit                                                           RSP_TYPE = 4                                                                  DAT[63:46] - 0x0                                                                  DAT[45:40] - CMD39 ('10111')                                                                  DAT[39:24] - RCA[31:16]                                                                  DAT[   23] - Status                                                                  DAT[22:16] - Register address                                                                  DAT[15: 8] - Register contents                                                                  DAT[ 7: 1] - CRC7                                                                  DAT[    0] - End bit                                                           RSP_TYPE = 5                                                                  DAT[63:46] - 0x0                                                                  DAT[45:40] - CMD40 ('10100')                                                                  DAT[39:24] - RCA[31:16]                                                                  DAT[   23] - Status                                                                  DAT[22:16] - Register address                                                                  DAT[15: 8] - Not defined.  May be used for IRQ data                                                                  DAT[ 7: 1] - CRC7                                                                  DAT[    0] - End bit */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_rsp_lo_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_rsp_lo_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_rsp_lo
name|cvmx_mio_emm_rsp_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_rsp_sts  *  * MIO_EMM_RSP_STS = MIO EMMC Response status Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_rsp_sts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_rsp_sts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
comment|/**< eMMC bus id to which the response status corresponds. */
name|uint64_t
name|cmd_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only copy of MIO_EMM_CMD[CMD_VAL].  CMD_VAL=1 indicates a                                                          direct operation is in progress. */
name|uint64_t
name|switch_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only copy of MIO_EMM_SWITCH[SWITCH_EXE].   SWITCH_VAL=1                                                          indicates a switch operation is in progress. */
name|uint64_t
name|dma_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only copy of MIO_EMM_DMA[DMA_VAL].   DMA_VAL=1 indicates a                                                          DMA operation is in progress. */
name|uint64_t
name|dma_pend
range|:
literal|1
decl_stmt|;
comment|/**< The DMA engine has a pending transfer resulting from an error.                                                          SW can resume the transfer by writing MIO_EMM_DMA[DMA_VAL]=1.                                                          SW can terminate the transfer by writing MIO_EMM_DMA[DMA_VAL]=1                                                          and MIO_EMM_DMA[NULL]=1.   HW will clear DMA_PEND and perform                                                          the DMA operation */
name|uint64_t
name|reserved_29_55
range|:
literal|27
decl_stmt|;
name|uint64_t
name|dbuf_err
range|:
literal|1
decl_stmt|;
comment|/**< For CMD_TYPE=1, indicates a DMA read data arrived from card                                                          without a free DBUF.                                                           For CMD_TYPE=2, indicates a DBUF underflow occurred during a                                                          DMA write.    See MIO_EMM_DMA[THRES]. */
name|uint64_t
name|reserved_24_27
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dbuf
range|:
literal|1
decl_stmt|;
comment|/**< DBUF corresponding to the most recently attempted block                                                          transfer. */
name|uint64_t
name|blk_timeout
range|:
literal|1
decl_stmt|;
comment|/**< Timeout waiting for read data or 3bit CRC token */
name|uint64_t
name|blk_crc_err
range|:
literal|1
decl_stmt|;
comment|/**< For CMD_TYPE=1, indicates a card read data CRC mismatch.                                                          MIO_EMM_RSP_STS[DBUF] indicates the failing data buffer.                                                           For CMD_TYPE=2, indicates card returned 3-bit CRC status token                                                          indicating the card encountered a write data CRC check                                                          mismatch.  MIO_EMM_RSP_STS[DBUF] indicates the failing data                                                          buffer. */
name|uint64_t
name|rsp_busybit
range|:
literal|1
decl_stmt|;
comment|/**< Debug only.  eMMC protocol utilizes DAT0 as a busy signal                                                          during block writes and R1b responses. */
name|uint64_t
name|stp_timeout
range|:
literal|1
decl_stmt|;
comment|/**< Stop transmission response timeout. */
name|uint64_t
name|stp_crc_err
range|:
literal|1
decl_stmt|;
comment|/**< Stop transmission response had a CRC error */
name|uint64_t
name|stp_bad_sts
range|:
literal|1
decl_stmt|;
comment|/**< Stop transmission response had bad status. */
name|uint64_t
name|stp_val
range|:
literal|1
decl_stmt|;
comment|/**< Stop transmission response valid. */
name|uint64_t
name|rsp_timeout
range|:
literal|1
decl_stmt|;
comment|/**< Response timeout */
name|uint64_t
name|rsp_crc_err
range|:
literal|1
decl_stmt|;
comment|/**< Response CRC error */
name|uint64_t
name|rsp_bad_sts
range|:
literal|1
decl_stmt|;
comment|/**< Response bad status */
name|uint64_t
name|rsp_val
range|:
literal|1
decl_stmt|;
comment|/**< Response id.   See MIO_EMM_RSP_HI/LO */
name|uint64_t
name|rsp_type
range|:
literal|3
decl_stmt|;
comment|/**< Indicates the response type. See MIO_EMM_RSP_HI/LO */
name|uint64_t
name|cmd_type
range|:
literal|2
decl_stmt|;
comment|/**< eMMC command type (0=no data, 1=read, 2=write) */
name|uint64_t
name|cmd_idx
range|:
literal|6
decl_stmt|;
comment|/**< eMMC command index most recently attempted */
name|uint64_t
name|cmd_done
range|:
literal|1
decl_stmt|;
comment|/**< eMMC command completed.   Once the command has complete, the                                                          status is final and can be examined by SW. */
else|#
directive|else
name|uint64_t
name|cmd_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_idx
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmd_type
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rsp_type
range|:
literal|3
decl_stmt|;
name|uint64_t
name|rsp_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_bad_sts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_crc_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_timeout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stp_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stp_bad_sts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stp_crc_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stp_timeout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsp_busybit
range|:
literal|1
decl_stmt|;
name|uint64_t
name|blk_crc_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|blk_timeout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbuf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_24_27
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dbuf_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_55
range|:
literal|27
decl_stmt|;
name|uint64_t
name|dma_pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dma_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cmd_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_rsp_sts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_rsp_sts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_rsp_sts
name|cvmx_mio_emm_rsp_sts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_sample  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_sample
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_sample_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|cmd_cnt
range|:
literal|10
decl_stmt|;
comment|/**< Number of SCLK cycles before the eMMC clock edge to sample the                                                          command pin. */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|dat_cnt
range|:
literal|10
decl_stmt|;
comment|/**< Number of SCLK cycles before the eMMC clock rising edge to                                                          sample the data pin. */
else|#
directive|else
name|uint64_t
name|dat_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|cmd_cnt
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_sample_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_sample_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_sample
name|cvmx_mio_emm_sample_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_sts_mask  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_sts_mask
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_sts_mask_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|sts_msk
range|:
literal|32
decl_stmt|;
comment|/**< Any bit set in STS_MSK causes the corresponding bit in the card                                                          status to be considered when computing response bad status. */
else|#
directive|else
name|uint64_t
name|sts_msk
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_sts_mask_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_sts_mask_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_sts_mask
name|cvmx_mio_emm_sts_mask_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_switch  *  * MIO_EMM_SWITCH = MIO EMMC Operating mode switch Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_switch
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_switch_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
comment|/**< Specify the eMMC bus */
name|uint64_t
name|switch_exe
range|:
literal|1
decl_stmt|;
comment|/**< When SWITCH_EXE is 0, the operating modes will be update                                                          directly without performing any SWITCH operations.   This                                                          allows SW to perform the SWITCH operations manually, then                                                          update the HW.                                                           SW writes this bit to a 1 to indicate that HW should perform                                                          the necessary SWITCH operations.   First, the POWER_CLASS                                                          switch will be performed.   If it fails, SWITCH_ERR0 will be                                                          and the remaining SWITCH operations will not be performed.   If                                                          is succeeds, the POWER_CLASS field will be updated and the                                                          HS_TIMING switch will be performed.   If it fails, SWITCH_ERR1                                                          will be set and the remaining SWITCH operations will not be                                                          performed.   If is succeeds, the HS_TIMING field will be                                                          updated and the BUS_WITDH switch operation will be performed.                                                          If it fails, SWITCH_ERR2 will be set.  If it succeeds, the                                                          BUS_WITDH will be updated.                                                           Changes to CLK_HI and CLK_LO are discarded if any switch error                                                          occurs. */
name|uint64_t
name|switch_err0
range|:
literal|1
decl_stmt|;
comment|/**< Error encounter while performing POWER_CLASS switch .   See                                                          MIO_EMM_RSP_STS */
name|uint64_t
name|switch_err1
range|:
literal|1
decl_stmt|;
comment|/**< Error encounter while performing HS_TIMING switch .   See                                                          MIO_EMM_RSP_STS */
name|uint64_t
name|switch_err2
range|:
literal|1
decl_stmt|;
comment|/**< Error encounter while performing BUS_WIDTH switch .   See                                                          MIO_EMM_RSP_STS */
name|uint64_t
name|reserved_49_55
range|:
literal|7
decl_stmt|;
name|uint64_t
name|hs_timing
range|:
literal|1
decl_stmt|;
comment|/**< Requested update to HS_TIMING */
name|uint64_t
name|reserved_43_47
range|:
literal|5
decl_stmt|;
name|uint64_t
name|bus_width
range|:
literal|3
decl_stmt|;
comment|/**< Requested update to BUS_WIDTH */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|power_class
range|:
literal|4
decl_stmt|;
comment|/**< Requested update to POWER_CLASS */
name|uint64_t
name|clk_hi
range|:
literal|16
decl_stmt|;
comment|/**< Requested update to CLK_HI */
name|uint64_t
name|clk_lo
range|:
literal|16
decl_stmt|;
comment|/**< Requested update to CLK_LO */
else|#
directive|else
name|uint64_t
name|clk_lo
range|:
literal|16
decl_stmt|;
name|uint64_t
name|clk_hi
range|:
literal|16
decl_stmt|;
name|uint64_t
name|power_class
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bus_width
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_43_47
range|:
literal|5
decl_stmt|;
name|uint64_t
name|hs_timing
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_55
range|:
literal|7
decl_stmt|;
name|uint64_t
name|switch_err2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_err1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_err0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|switch_exe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bus_id
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_switch_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_switch_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_switch
name|cvmx_mio_emm_switch_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_emm_wdog  *  * MIO_EMM_WDOG = MIO EMMC Watchdog Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_emm_wdog
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_emm_wdog_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|clk_cnt
range|:
literal|26
decl_stmt|;
comment|/**< Number of CLK_CNT cycles to wait for the card to return a                                                          response, read data, or the 3-bit CRC status token. */
else|#
directive|else
name|uint64_t
name|clk_cnt
range|:
literal|26
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_emm_wdog_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_emm_wdog_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_emm_wdog
name|cvmx_mio_emm_wdog_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_bnk_dat#  *  * Notes:  * The intial state of MIO_FUS_BNK_DAT* is as if bank6 was just read i.e. DAT* = fus[895:768]  *  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_bnk_datx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_bnk_datx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
comment|/**< Efuse bank store                                                          For reads, the DAT gets the fus bank last read                                                          For write, the DAT determines which fuses to blow */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_bnk_datx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_bnk_datx
name|cvmx_mio_fus_bnk_datx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_dat0  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_dat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|man_info
range|:
literal|32
decl_stmt|;
comment|/**< Fuse information - manufacturing info [31:0] */
else|#
directive|else
name|uint64_t
name|man_info
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_dat0
name|cvmx_mio_fus_dat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_dat1  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_dat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|man_info
range|:
literal|32
decl_stmt|;
comment|/**< Fuse information - manufacturing info [63:32] */
else|#
directive|else
name|uint64_t
name|man_info
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_dat1
name|cvmx_mio_fus_dat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_dat2  *  * Notes:  * CHIP_ID is consumed in several places within Octeon.  *  *    * Core COP0 ProcessorIdentification[Revision]  *    * Core EJTAG DeviceIdentification[Version]  *    * PCI_CFG02[RID]  *    * JTAG controller  *  * Note: The JTAG controller gets CHIP_ID[3:0] solely from the laser fuses.  * Modification to the efuses will not change what the JTAG controller reports  * for CHIP_ID.  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_dat2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|fus118
range|:
literal|1
decl_stmt|;
comment|/**< Ignore Authentik disable */
name|uint64_t
name|rom_info
range|:
literal|10
decl_stmt|;
comment|/**< Fuse information - ROM info */
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Power limit */
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - See NOCRYPTO */
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Disable Kasumi */
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DORM_CRYPTO and NOCRYPTO                                                          together to select 1 of 4 mutually-exclusive                                                          modes:                                                           DORM_CRYPT=0,NOCRYPTO=0 AES/DES/HASH enabled                                                          DORM_CRYPT=0,NOCRYPTO=1 AES/DES/HASH disable                                                          DORM_CRYPT=1,NOCRYPTO=0 Dormant Encryption enable                                                          DORM_CRYPT=1,NOCRYPTO=1 Authenik mode */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rom_info
range|:
literal|10
decl_stmt|;
name|uint64_t
name|fus118
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_fus_dat2_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|pll_off
range|:
literal|4
decl_stmt|;
comment|/**< Fuse information - core pll offset                                                          Used to compute the base offset for the core pll.                                                          the offset will be (PLL_OFF ^ 8)                                                          Note, these fuses can only be set from laser fuse */
name|uint64_t
name|reserved_1_11
range|:
literal|11
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_11
range|:
literal|11
decl_stmt|;
name|uint64_t
name|pll_off
range|:
literal|4
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_mio_fus_dat2_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|pll_off
range|:
literal|4
decl_stmt|;
comment|/**< Fuse information - core pll offset                                                          Used to compute the base offset for the core pll.                                                          the offset will be (PLL_OFF ^ 8)                                                          Note, these fuses can only be set from laser fuse */
name|uint64_t
name|reserved_2_11
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_11
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pll_off
range|:
literal|4
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_mio_fus_dat2_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2)                                                          (PASS2 Only) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable                                                          (PASS2 Only) */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable                                                          (PASS2 Only) */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|pp_dis
range|:
literal|16
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|16
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_mio_fus_dat2_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat2_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - a copy of fuse318 */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled                                                          (5020 does not have RAID co-processor) */
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Disable Kasumi */
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2)                                                          (5020 does not have DFA co-processor) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_15
range|:
literal|14
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_mio_fus_dat2_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - a copy of fuse318 */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Disable Kasumi */
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|4
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mio_fus_dat2_cn52xx
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat2_cn56xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - a copy of fuse318 */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Disable Kasumi */
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|12
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_12_15
range|:
literal|4
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_31
range|:
literal|2
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_34_63
range|:
literal|30
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_mio_fus_dat2_cn56xx
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat2_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Disable Kasumi */
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - When set, use short reset count */
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BIST Disable */
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|pp_dis
range|:
literal|16
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|16
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|bist_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_sht
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nokasu
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_30_63
range|:
literal|34
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_mio_fus_dat2_cn58xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat2_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|fus118
range|:
literal|1
decl_stmt|;
comment|/**< Ignore Authentik disable */
name|uint64_t
name|rom_info
range|:
literal|10
decl_stmt|;
comment|/**< Fuse information - ROM info */
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Power limit */
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - See NOCRYPTO */
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DORM_CRYPTO and NOCRYPTO                                                          together to select 1 of 4 mutually-exclusive                                                          modes:                                                           DORM_CRYPT=0,NOCRYPTO=0 AES/DES/HASH enabled                                                          DORM_CRYPT=0,NOCRYPTO=1 AES/DES/HASH disable                                                          DORM_CRYPT=1,NOCRYPTO=0 Dormant Encryption enable                                                          DORM_CRYPT=1,NOCRYPTO=1 Authenik mode */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|4
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_15
range|:
literal|12
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rom_info
range|:
literal|10
decl_stmt|;
name|uint64_t
name|fus118
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_mio_fus_dat2_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Dormant Encryption enable */
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_6_15
range|:
literal|10
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|6
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_15
range|:
literal|10
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_mio_fus_dat2_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat2_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|fus118
range|:
literal|1
decl_stmt|;
comment|/**< Ignore Authentik disable */
name|uint64_t
name|rom_info
range|:
literal|10
decl_stmt|;
comment|/**< Fuse information - ROM info */
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Power limit */
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - See NOCRYPTO */
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DORM_CRYPTO and NOCRYPTO                                                          together to select 1 of 4 mutually-exclusive                                                          modes:                                                           DORM_CRYPT=0,NOCRYPTO=0 AES/DES/HASH enabled                                                          DORM_CRYPT=0,NOCRYPTO=1 AES/DES/HASH disable                                                          DORM_CRYPT=1,NOCRYPTO=0 Dormant Encryption enable                                                          DORM_CRYPT=1,NOCRYPTO=1 Authenik mode */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pp_dis
range|:
literal|10
decl_stmt|;
comment|/**< Fuse information - PP_DISABLES */
else|#
directive|else
name|uint64_t
name|pp_dis
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_15
range|:
literal|6
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rom_info
range|:
literal|10
decl_stmt|;
name|uint64_t
name|fus118
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
struct|struct
name|cvmx_mio_fus_dat2_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Power limit */
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - Dormant Encryption enable */
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RAID enabled */
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (CP2) */
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - VMUL disable */
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - AES/DES/HASH disable */
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
comment|/**< Fuse information - CHIP_ID */
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_15
range|:
literal|16
decl_stmt|;
name|uint64_t
name|chip_id
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_25
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nocrypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nomul
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nodfa_cp2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_31
range|:
literal|3
decl_stmt|;
name|uint64_t
name|raid_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fus318
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dorm_crypto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|power_limit
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_37_63
range|:
literal|27
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_mio_fus_dat2_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat2_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_dat2
name|cvmx_mio_fus_dat2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_dat3  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_dat3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pll_ctl
range|:
literal|10
decl_stmt|;
comment|/**< Fuse information - PLL control */
name|uint64_t
name|dfa_info_dte
range|:
literal|3
decl_stmt|;
comment|/**< Fuse information - DFA information (DTE) */
name|uint64_t
name|dfa_info_clm
range|:
literal|4
decl_stmt|;
comment|/**< Fuse information - DFA information (Cluster mask) */
name|uint64_t
name|reserved_40_40
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - EMA */
name|uint64_t
name|efus_lck_rsv
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|efus_lck_man
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|pll_half_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RCLK PLL control */
name|uint64_t
name|l2c_crip
range|:
literal|3
decl_stmt|;
comment|/**< Fuse information - L2C Cripple (1/8, 1/4, 1/2) */
name|uint64_t
name|pll_div4
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - PLL DIV4 mode                                                          (laser fuse only) */
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BAR2 Present (when blown '1') */
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse ignore */
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - ZIP disable */
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (DTE) */
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
comment|/**< Fuse information - ICACHE Hard Repair Data */
else|#
directive|else
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pll_div4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_crip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pll_half_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck_man
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck_rsv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_40_40
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa_info_clm
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dfa_info_dte
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pll_ctl
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_fus_dat3_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pll_div4
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - PLL DIV4 mode                                                          (laser fuse only) */
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BAR2 Enable (when blown '1') */
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse ignore                                                          This bit only has side effects when blown in                                                          the laser fuses.  It is ignore if only set in                                                          efuse store. */
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - ZIP disable */
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (DTE) */
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
comment|/**< Fuse information - ICACHE Hard Repair Data */
else|#
directive|else
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_30
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pll_div4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
struct|struct
name|cvmx_mio_fus_dat3_cn31xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pll_div4
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - PLL DIV4 mode                                                          (laser fuse only) */
name|uint64_t
name|zip_crip
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Zip Cripple                                                          (O2P Only) */
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BAR2 Enable (when blown '1') */
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse ignore                                                          This bit only has side effects when blown in                                                          the laser fuses.  It is ignore if only set in                                                          efuse store. */
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - ZIP disable */
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (DTE) */
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
comment|/**< Fuse information - ICACHE Hard Repair Data */
else|#
directive|else
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip_crip
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pll_div4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn31xx
struct|;
struct|struct
name|cvmx_mio_fus_dat3_cn38xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|zip_crip
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Zip Cripple                                                          (PASS3 Only) */
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BAR2 Enable (when blown '1')                                                          (PASS2 Only) */
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown                                                          (PASS2 Only) */
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse ignore                                                          This bit only has side effects when blown in                                                          the laser fuses.  It is ignore if only set in                                                          efuse store.                                                          (PASS2 Only) */
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - ZIP disable                                                          (PASS2 Only) */
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (DTE)                                                          (PASS2 Only) */
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
comment|/**< Fuse information - ICACHE Hard Repair Data */
else|#
directive|else
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip_crip
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
struct|struct
name|cvmx_mio_fus_dat3_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BAR2 Enable (when blown '1')                                                          (PASS2 Only) */
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown                                                          (PASS2 Only) */
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse ignore                                                          This bit only has side effects when blown in                                                          the laser fuses.  It is ignore if only set in                                                          efuse store.                                                          (PASS2 Only) */
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - ZIP disable                                                          (PASS2 Only) */
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (DTE)                                                          (PASS2 Only) */
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
comment|/**< Fuse information - ICACHE Hard Repair Data */
else|#
directive|else
name|uint64_t
name|icache
range|:
literal|24
decl_stmt|;
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_29_63
range|:
literal|35
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn38xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_dat3_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pll_ctl
range|:
literal|10
decl_stmt|;
comment|/**< Fuse information - PLL control */
name|uint64_t
name|dfa_info_dte
range|:
literal|3
decl_stmt|;
comment|/**< Fuse information - DFA information (DTE) */
name|uint64_t
name|dfa_info_clm
range|:
literal|4
decl_stmt|;
comment|/**< Fuse information - DFA information (Cluster mask) */
name|uint64_t
name|reserved_40_40
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - EMA */
name|uint64_t
name|efus_lck_rsv
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|efus_lck_man
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|pll_half_dis
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - RCLK PLL control */
name|uint64_t
name|l2c_crip
range|:
literal|3
decl_stmt|;
comment|/**< Fuse information - L2C Cripple (1/8, 1/4, 1/2) */
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip_info
range|:
literal|2
decl_stmt|;
comment|/**< Fuse information - Zip information */
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - BAR2 Present (when blown '1') */
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse lockdown */
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - efuse ignore */
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - ZIP disable */
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
comment|/**< Fuse information - DFA Disable (DTE) */
name|uint64_t
name|reserved_0_23
range|:
literal|24
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_23
range|:
literal|24
decl_stmt|;
name|uint64_t
name|nodfa_dte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nozip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bar2_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|zip_info
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_31_31
range|:
literal|1
decl_stmt|;
name|uint64_t
name|l2c_crip
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pll_half_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck_man
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efus_lck_rsv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_40_40
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfa_info_clm
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dfa_info_dte
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pll_ctl
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_fus_dat3_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_dat3_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_dat3
name|cvmx_mio_fus_dat3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_ema  *  * DON'T PUT IN HRM*  *  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_ema
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_ema_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|eff_ema
range|:
literal|3
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ema
range|:
literal|3
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|ema
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|eff_ema
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn56xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_ema_cn58xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|ema
range|:
literal|2
decl_stmt|;
comment|/**< EMA Settings */
else|#
directive|else
name|uint64_t
name|ema
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_mio_fus_ema_cn58xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_ema_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_ema
name|cvmx_mio_fus_ema_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_pdf  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_pdf
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_pdf_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|pdf
range|:
literal|64
decl_stmt|;
comment|/**< Fuse information - Product Definition Field */
else|#
directive|else
name|uint64_t
name|pdf
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pdf_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_pdf
name|cvmx_mio_fus_pdf_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_pll  *  * Notes:  * The core clkout postscaler should be placed in reset at least 10 ref clocks prior to changing  * the core clkout select.  The core clkout postscaler should remain under reset for at least 10  * ref clocks after the core clkout select changes.  *  * The pnr clkout postscaler should be placed in reset at least 10 ref clocks prior to changing  * the pnr clkout select.  The pnr clkout postscaler should remain under reset for at least 10  * ref clocks after the pnr clkout select changes.  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_pll
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_pll_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rclk_align_r
range|:
literal|8
decl_stmt|;
comment|/**< RCLK right alignment settings */
name|uint64_t
name|rclk_align_l
range|:
literal|8
decl_stmt|;
comment|/**< RCLK left alignment settings */
name|uint64_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
name|uint64_t
name|c_cout_rst
range|:
literal|1
decl_stmt|;
comment|/**< Core clkout postscaler reset */
name|uint64_t
name|c_cout_sel
range|:
literal|2
decl_stmt|;
comment|/**< Core clkout select                                                          0=RCLK,1=PS output,2=PLL output,3=undivided RCLK |   $PR                                                          (***Pass 1.x: 3=GND) */
name|uint64_t
name|pnr_cout_rst
range|:
literal|1
decl_stmt|;
comment|/**< PNR  clkout postscaler reset */
name|uint64_t
name|pnr_cout_sel
range|:
literal|2
decl_stmt|;
comment|/**< PNR  clkout select                                                          0=SCLK,1=PS output,2=PLL output,3=undivided RCLK |   $PR                                                          (***Pass 1.x: 3=GND) */
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnr_cout_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pnr_cout_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_cout_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|c_cout_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_31
range|:
literal|24
decl_stmt|;
name|uint64_t
name|rclk_align_l
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rclk_align_r
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_fus_pll_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
comment|/**< PLL reference clock slip */
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
comment|/**< PLL feedback clock slip */
else|#
directive|else
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_mio_fus_pll_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn50xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_pll_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|c_cout_rst
range|:
literal|1
decl_stmt|;
comment|/**< Core clkout postscaler reset */
name|uint64_t
name|c_cout_sel
range|:
literal|2
decl_stmt|;
comment|/**< Core clkout select                                                          0=RCLK,1=PS output,2=PLL output,3=undivided RCLK |   $PR                                                          (***Pass 1.x: 3=GND) */
name|uint64_t
name|pnr_cout_rst
range|:
literal|1
decl_stmt|;
comment|/**< PNR  clkout postscaler reset */
name|uint64_t
name|pnr_cout_sel
range|:
literal|2
decl_stmt|;
comment|/**< PNR  clkout select                                                          0=SCLK,1=PS output,2=PLL output,3=undivided RCLK |   $PR                                                          (***Pass 1.x: 3=GND) */
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
comment|/**< Reserved */
else|#
directive|else
name|uint64_t
name|fbslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfslip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pnr_cout_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pnr_cout_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|c_cout_sel
range|:
literal|2
decl_stmt|;
name|uint64_t
name|c_cout_rst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_fus_pll_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_pll_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_pll
name|cvmx_mio_fus_pll_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_prog  *  * DON'T PUT IN HRM*  *  *  * Notes:  * This CSR is not present in the HRM.  *  * To write a bank of fuses, SW must set MIO_FUS_WADR[ADDR] to the bank to be  * programmed and then set each bit within MIO_FUS_BNK_DATX to indicate which  * fuses to blow.  Once ADDR, and DAT are setup, SW can write to  * MIO_FUS_PROG[PROG] to start the bank write and poll on PROG.  Once PROG is  * clear, the bank write is complete.  *  * A soft blow is still subject to lockdown fuses.  After a soft/warm reset, the  * chip will behave as though the fuses were actually blown.  A cold reset restores  * the actual fuse valuse.  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_prog
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_prog_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|soft
range|:
literal|1
decl_stmt|;
comment|/**< When set with PROG, causes only the local storeage                                                          to change.  Will not really blow any fuses.  HW                                                          will clear when the program operation is complete */
name|uint64_t
name|prog
range|:
literal|1
decl_stmt|;
comment|/**< Blow the fuse bank                                                          SW will set PROG, and then the HW will clear                                                          when the program operation is complete */
else|#
directive|else
name|uint64_t
name|prog
range|:
literal|1
decl_stmt|;
name|uint64_t
name|soft
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_fus_prog_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|prog
range|:
literal|1
decl_stmt|;
comment|/**< Blow the fuse                                                          SW will set PROG, hold it for 10us, then clear it */
else|#
directive|else
name|uint64_t
name|prog
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_prog
name|cvmx_mio_fus_prog_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_prog_times  *  * DON'T PUT IN HRM*  *  *  * Notes:  * This CSR is not present in the HRM.  *  * All values must be> 0 for correct electrical operation.  *  * IFB fuses are 0..1791  * L6G fuses are 1792 to 2047  *  * The reset values are for IFB fuses for ref_clk of 100MHZ  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_prog_times
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_prog_times_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|vgate_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse vgate pin (L6G) */
name|uint64_t
name|fsrc_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse fsource pin (L6G) */
name|uint64_t
name|prog_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse program pin (IFB) */
name|uint64_t
name|reserved_6_31
range|:
literal|26
decl_stmt|;
name|uint64_t
name|setup
range|:
literal|6
decl_stmt|;
comment|/**< efuse timing param                                                           SETUP = (tWRS/refclk period)-1                                                           For IFB: tWRS =  20ns                                                          For L6G: tWRS =  20ns */
else|#
directive|else
name|uint64_t
name|setup
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_31
range|:
literal|26
decl_stmt|;
name|uint64_t
name|prog_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsrc_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vgate_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_fus_prog_times_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|prog_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse program pin */
name|uint64_t
name|out
range|:
literal|8
decl_stmt|;
comment|/**< efuse timing param (ref_clks to delay 10ns) */
name|uint64_t
name|sclk_lo
range|:
literal|4
decl_stmt|;
comment|/**< efuse timing param (ref_clks to delay 5ns) */
name|uint64_t
name|sclk_hi
range|:
literal|12
decl_stmt|;
comment|/**< efuse timing param (ref_clks to delay 1000ns) */
name|uint64_t
name|setup
range|:
literal|8
decl_stmt|;
comment|/**< efuse timing param (ref_clks to delay 10ns) */
else|#
directive|else
name|uint64_t
name|setup
range|:
literal|8
decl_stmt|;
name|uint64_t
name|sclk_hi
range|:
literal|12
decl_stmt|;
name|uint64_t
name|sclk_lo
range|:
literal|4
decl_stmt|;
name|uint64_t
name|out
range|:
literal|8
decl_stmt|;
name|uint64_t
name|prog_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
name|struct
name|cvmx_mio_fus_prog_times_cn50xx
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn50xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn50xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn50xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn50xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_prog_times_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
name|uint64_t
name|vgate_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse vgate pin (L6G) */
name|uint64_t
name|fsrc_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse fsource pin (L6G) */
name|uint64_t
name|prog_pin
range|:
literal|1
decl_stmt|;
comment|/**< efuse program pin (IFB) */
name|uint64_t
name|out
range|:
literal|7
decl_stmt|;
comment|/**< efuse timing param                                                           OUT = (tOUT/refclk period)-1                                                           For IFB: tOUT =  20ns                                                          For L6G: tOUT =  20ns */
name|uint64_t
name|sclk_lo
range|:
literal|4
decl_stmt|;
comment|/**< efuse timing param                                                           SCLK_LO=(tSLO/refclk period)-1                                                           For IFB: tSLO =  20ns                                                          For L6G: tSLO =  20ns */
name|uint64_t
name|sclk_hi
range|:
literal|15
decl_stmt|;
comment|/**< efuse timing param                                                          ***NOTE: Pass 1.x reset value is 20000                                                           SCLK_HI=(tSHI/refclk period)-1                                                           For IFB: tSHI =  200us                                                          For L6G: tSHI =  25us */
name|uint64_t
name|setup
range|:
literal|6
decl_stmt|;
comment|/**< efuse timing param                                                           SETUP = (tWRS/refclk period)-1                                                           For IFB: tWRS =  20ns                                                          For L6G: tWRS =  20ns */
else|#
directive|else
name|uint64_t
name|setup
range|:
literal|6
decl_stmt|;
name|uint64_t
name|sclk_hi
range|:
literal|15
decl_stmt|;
name|uint64_t
name|sclk_lo
range|:
literal|4
decl_stmt|;
name|uint64_t
name|out
range|:
literal|7
decl_stmt|;
name|uint64_t
name|prog_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fsrc_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|vgate_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_35_63
range|:
literal|29
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_fus_prog_times_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_prog_times_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_prog_times
name|cvmx_mio_fus_prog_times_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_rcmd  *  * Notes:  * To read an efuse, SW writes MIO_FUS_RCMD[ADDR,PEND] with the byte address of  * the fuse in question, then SW can poll MIO_FUS_RCMD[PEND].  When PEND is  * clear, then MIO_FUS_RCMD[DAT] is valid.  In addition, if the efuse read went  * to the efuse banks (eg. ((ADDR/16) not [0,1,7]) || EFUSE) SW can read  * MIO_FUS_BNK_DATX which contains all 128 fuses in the bank associated in  * ADDR.  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_rcmd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_rcmd_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|8
decl_stmt|;
comment|/**< 8bits of fuse data */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< SW sets this bit on a write to start FUSE read                                                          operation.  HW clears when read is complete and                                                          the DAT is valid */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|efuse
range|:
literal|1
decl_stmt|;
comment|/**< When set, return data from the efuse storage                                                          rather than the local storage */
name|uint64_t
name|addr
range|:
literal|8
decl_stmt|;
comment|/**< The byte address of the fuse to read */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|efuse
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_fus_rcmd_cn30xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|8
decl_stmt|;
comment|/**< 8bits of fuse data */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
comment|/**< SW sets this bit on a write to start FUSE read                                                          operation.  HW clears when read is complete and                                                          the DAT is valid */
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|efuse
range|:
literal|1
decl_stmt|;
comment|/**< When set, return data from the efuse storage                                                          rather than the local storage for the 320 HW fuses */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|7
decl_stmt|;
comment|/**< The byte address of the fuse to read */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|efuse
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_11
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pend
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dat
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_mio_fus_rcmd_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_cn30xx
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_cn30xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_cn30xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_cn30xx
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_rcmd_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_rcmd
name|cvmx_mio_fus_rcmd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_read_times  *  * Notes:  * IFB fuses are 0..1791  * L6G fuses are 1792 to 2047  *  * The reset values are for IFB fuses for refclk up to 100MHZ when core PLL is enagaged  *  * If any of the formulas above result in a value less than zero, the corresponding  * timing parameter should be set to zero.  *  * Prior to issuing a read to the fuse banks (via. MIO_FUS_RCMD), this register  * should be written with the timing parameters which correspond to the fuse bank type (IFB vs L6G)  * that will be read.  *  * This register should not be written while MIO_FUS_RCMD[PEND]=1.  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_read_times
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_read_times_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
name|uint64_t
name|sch
range|:
literal|4
decl_stmt|;
comment|/**< Hold CS for (SCH+1) refclks after FSET desserts                                                           SCH = (tSCH/refclk period)-1                                                           For IFB: tSCH = 160ns                                                          For L6G: tSCH =  10ns */
name|uint64_t
name|fsh
range|:
literal|4
decl_stmt|;
comment|/**< Hold FSET for (FSH+1) refclks after PRCHG deasserts                                                           FSH = (tFSH/refclk period)-1                                                           For IFB: tFSH = 160ns                                                          For L6G: tFSH =  10ns */
name|uint64_t
name|prh
range|:
literal|4
decl_stmt|;
comment|/**< Assert PRCHG (PRH+1) refclks after SIGDEV deasserts                                                           PRH = (tPRH/refclk period)-1                                                           For IFB: tPRH =  70ns                                                          For L6G: tPRH =  10ns */
name|uint64_t
name|sdh
range|:
literal|4
decl_stmt|;
comment|/**< Hold SIGDEV for (SDH+1) refclks after FSET asserts                                                           SDH = (tSDH/refclk period)-1                                                           For IFB: tPRH =  10ns                                                          For L6G: tPRH =  10ns */
name|uint64_t
name|setup
range|:
literal|10
decl_stmt|;
comment|/**< Assert CS for (SETUP+1) refclks before asserting                                                          SIGDEV, FSET, or PRCHG                                                           SETUP=(tRDS/refclk period)-1                                                           For IFB: tRDS = 10000ns                                                          For L6G: tRDS = max(tSCS,tSDS,tPRS)                                                            where tSCS   = 10ns                                                                  tSDS   = 10ns                                                                  tPRS   = 10ns */
else|#
directive|else
name|uint64_t
name|setup
range|:
literal|10
decl_stmt|;
name|uint64_t
name|sdh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|prh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|fsh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|sch
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_26_63
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_read_times_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_read_times
name|cvmx_mio_fus_read_times_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_repair_res0  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_repair_res0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_repair_res0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
name|uint64_t
name|too_many
range|:
literal|1
decl_stmt|;
comment|/**< Too many defects */
name|uint64_t
name|repair2
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
name|uint64_t
name|repair1
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
name|uint64_t
name|repair0
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
else|#
directive|else
name|uint64_t
name|repair0
range|:
literal|18
decl_stmt|;
name|uint64_t
name|repair1
range|:
literal|18
decl_stmt|;
name|uint64_t
name|repair2
range|:
literal|18
decl_stmt|;
name|uint64_t
name|too_many
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_55_63
range|:
literal|9
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res0_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_repair_res0
name|cvmx_mio_fus_repair_res0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_repair_res1  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_repair_res1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_repair_res1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
name|uint64_t
name|repair5
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
name|uint64_t
name|repair4
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
name|uint64_t
name|repair3
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
else|#
directive|else
name|uint64_t
name|repair3
range|:
literal|18
decl_stmt|;
name|uint64_t
name|repair4
range|:
literal|18
decl_stmt|;
name|uint64_t
name|repair5
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_54_63
range|:
literal|10
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res1_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_repair_res1
name|cvmx_mio_fus_repair_res1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_repair_res2  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_repair_res2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_repair_res2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|repair6
range|:
literal|18
decl_stmt|;
comment|/**< BISR Results */
else|#
directive|else
name|uint64_t
name|repair6
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_repair_res2_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_repair_res2
name|cvmx_mio_fus_repair_res2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_spr_repair_res  *  * DON'T PUT IN HRM*  *  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_spr_repair_res
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_spr_repair_res_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|repair2
range|:
literal|14
decl_stmt|;
comment|/**< Reserved (see  MIO_FUS_REPAIR_RES*) */
name|uint64_t
name|repair1
range|:
literal|14
decl_stmt|;
comment|/**< Reserved (see  MIO_FUS_REPAIR_RES*) */
name|uint64_t
name|repair0
range|:
literal|14
decl_stmt|;
comment|/**< Reserved (see  MIO_FUS_REPAIR_RES*) */
else|#
directive|else
name|uint64_t
name|repair0
range|:
literal|14
decl_stmt|;
name|uint64_t
name|repair1
range|:
literal|14
decl_stmt|;
name|uint64_t
name|repair2
range|:
literal|14
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_res_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_spr_repair_res
name|cvmx_mio_fus_spr_repair_res_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_spr_repair_sum  *  * DON'T PUT IN HRM*  *  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_spr_repair_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_spr_repair_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|too_many
range|:
literal|1
decl_stmt|;
comment|/**< Reserved (see  MIO_FUS_REPAIR_RES*) */
else|#
directive|else
name|uint64_t
name|too_many
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_spr_repair_sum_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_spr_repair_sum
name|cvmx_mio_fus_spr_repair_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_tgg  *  * Notes:  * The TGG fuses are fuses[831:768].  The valid bit (TGG[63]) is fuse[831].  *  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_tgg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_tgg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
comment|/**< Out of reset, VAL will return the TGG[63] fuse.                                                          Software may write this CSR bit to zero (to hide                                                          the value of the TGG fuses).  Software cannot write                                                          the valid bit to a one, so it is not possible to                                                          read  the value of the TGG fuses after the valid                                                          bit is clear.                                                           It is never possible to read the value of the TGG                                                          fuses directly (ie. the only way to read the value                                                          of the TGG fuses is via the MIO_FUS_TGG CSR.)                                                           Whenever the fuse corresponding to the valid bit                                                          (ie. TGG[63]) is blown, it is not possible to blow                                                          the other 63 TGG fuses.  (ie. only when the TGG[63]                                                          fuse is not blown, the other 63 TGG fuses can be                                                          blown.  The TGG[63] fuse is the one and only fuse                                                          lockdown bit for the other 63 fuses TGG fuses.  No                                                          other fuse lockdown bits can prevent blowing the 63                                                          fuses. */
name|uint64_t
name|dat
range|:
literal|63
decl_stmt|;
comment|/**< Whenever VAL is clear, DAT will always read as                                                          zero, regardless of the value of the TGG[62:0]                                                          fuses.                                                           Whenever VAL is set, DAT will match the value of                                                          other 63 TGG fuses (ie. TGG[62:0]) */
else|#
directive|else
name|uint64_t
name|dat
range|:
literal|63
decl_stmt|;
name|uint64_t
name|val
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_tgg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_tgg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_tgg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_tgg
name|cvmx_mio_fus_tgg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_unlock  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_unlock
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_unlock_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|key
range|:
literal|24
decl_stmt|;
comment|/**< When set to the typical value, allows SW to                                                          program the efuses */
else|#
directive|else
name|uint64_t
name|key
range|:
literal|24
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_unlock_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_unlock_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_unlock
name|cvmx_mio_fus_unlock_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_fus_wadr  */
end_comment

begin_union
union|union
name|cvmx_mio_fus_wadr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_fus_wadr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|10
decl_stmt|;
comment|/**< Which of the banks of 128 fuses to blow */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|10
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_fus_wadr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_s
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_mio_fus_wadr_cn50xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|2
decl_stmt|;
comment|/**< Which of the four banks of 256 fuses to blow */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_mio_fus_wadr_cn52xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|3
decl_stmt|;
comment|/**< Which of the four banks of 256 fuses to blow */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
name|struct
name|cvmx_mio_fus_wadr_cn52xx
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn52xx
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn50xx
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn50xx
name|cn58xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_fus_wadr_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|4
decl_stmt|;
comment|/**< Which of the banks of 128 fuses to blow */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_fus_wadr_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn61xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_fus_wadr_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_fus_wadr
name|cvmx_mio_fus_wadr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_gpio_comp  *  * MIO_GPIO_COMP = MIO GPIO Compensation Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_gpio_comp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_gpio_comp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|6
decl_stmt|;
comment|/**< GPIO bus PCTL */
name|uint64_t
name|nctl
range|:
literal|6
decl_stmt|;
comment|/**< GPIO bus NCTL */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_gpio_comp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_gpio_comp
name|cvmx_mio_gpio_comp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ndf_dma_cfg  *  * MIO_NDF_DMA_CFG = MIO NAND Flash DMA Config Register  *  * SIZE is specified in number of 64 bit transfers (encoded in -1 notation).  *  * ADR must be 64 bit aligned.  */
end_comment

begin_union
union|union
name|cvmx_mio_ndf_dma_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ndf_dma_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine enable */
name|uint64_t
name|rw
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine R/W bit (0 = read, 1 = write) */
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine clear EN on device terminated burst */
name|uint64_t
name|reserved_60_60
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap32
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine 32 bit swap */
name|uint64_t
name|swap16
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine 16 bit swap */
name|uint64_t
name|swap8
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine 8 bit swap */
name|uint64_t
name|endian
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine NCB endian mode (0 = big, 1 = little) */
name|uint64_t
name|size
range|:
literal|20
decl_stmt|;
comment|/**< DMA Engine size */
name|uint64_t
name|adr
range|:
literal|36
decl_stmt|;
comment|/**< DMA Engine address */
else|#
directive|else
name|uint64_t
name|adr
range|:
literal|36
decl_stmt|;
name|uint64_t
name|size
range|:
literal|20
decl_stmt|;
name|uint64_t
name|endian
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap8
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap16
range|:
literal|1
decl_stmt|;
name|uint64_t
name|swap32
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_60_60
range|:
literal|1
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rw
range|:
literal|1
decl_stmt|;
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ndf_dma_cfg
name|cvmx_mio_ndf_dma_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ndf_dma_int  *  * MIO_NDF_DMA_INT = MIO NAND Flash DMA Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ndf_dma_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ndf_dma_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine request completion interrupt */
else|#
directive|else
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ndf_dma_int
name|cvmx_mio_ndf_dma_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ndf_dma_int_en  *  * MIO_NDF_DMA_INT_EN = MIO NAND Flash DMA Interrupt Enable Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ndf_dma_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ndf_dma_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
comment|/**< DMA Engine request completion interrupt enable */
else|#
directive|else
name|uint64_t
name|done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ndf_dma_int_en_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ndf_dma_int_en
name|cvmx_mio_ndf_dma_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_pll_ctl  */
end_comment

begin_union
union|union
name|cvmx_mio_pll_ctl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_pll_ctl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|bw_ctl
range|:
literal|5
decl_stmt|;
comment|/**< Core PLL bandwidth control */
else|#
directive|else
name|uint64_t
name|bw_ctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_pll_ctl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_pll_ctl_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_pll_ctl
name|cvmx_mio_pll_ctl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_pll_setting  */
end_comment

begin_union
union|union
name|cvmx_mio_pll_setting
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_pll_setting_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|17
decl_stmt|;
comment|/**< Core PLL setting */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|17
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_pll_setting_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_pll_setting_s
name|cn31xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_pll_setting
name|cvmx_mio_pll_setting_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_ckout_hi_incr  *  * MIO_PTP_CKOUT_HI_INCR = PTP Clock Out Hi Increment  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_ckout_hi_incr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_ckout_hi_incr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
comment|/**< Nanoseconds */
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_ckout_hi_incr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_hi_incr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_hi_incr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_hi_incr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_ckout_hi_incr
name|cvmx_mio_ptp_ckout_hi_incr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_ckout_lo_incr  *  * MIO_PTP_CKOUT_LO_INCR = PTP Clock Out Lo Increment  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_ckout_lo_incr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_ckout_lo_incr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
comment|/**< Nanoseconds */
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_ckout_lo_incr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_lo_incr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_lo_incr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_lo_incr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_ckout_lo_incr
name|cvmx_mio_ptp_ckout_lo_incr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_ckout_thresh_hi  *  * MIO_PTP_CKOUT_THRESH_HI = Hi bytes of PTP Clock Out  *  * Writes to MIO_PTP_CKOUT_THRESH_HI also clear MIO_PTP_CKOUT_THRESH_LO. To update all 96 bits, write MIO_PTP_CKOUT_THRESH_HI followed  * by MIO_PTP_CKOUT_THRESH_LO  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_ckout_thresh_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_ckout_thresh_hi_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
comment|/**< Nanoseconds */
else|#
directive|else
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_hi_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_hi_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_hi_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_hi_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_ckout_thresh_hi
name|cvmx_mio_ptp_ckout_thresh_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_ckout_thresh_lo  *  * MIO_PTP_CKOUT_THRESH_LO = Lo bytes of PTP Clock Out  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_ckout_thresh_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_ckout_thresh_lo_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_lo_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_lo_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_lo_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_ckout_thresh_lo_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_ckout_thresh_lo
name|cvmx_mio_ptp_ckout_thresh_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_clock_cfg  *  * MIO_PTP_CLOCK_CFG = Configuration  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_clock_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_clock_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
name|uint64_t
name|pps
range|:
literal|1
decl_stmt|;
comment|/**< PTP PPS Output                                                          reflects ptp__pps after PPS_INV inverter */
name|uint64_t
name|ckout
range|:
literal|1
decl_stmt|;
comment|/**< PTP Clock Output                                                          reflects ptp__ckout after CKOUT_INV inverter */
name|uint64_t
name|ext_clk_edge
range|:
literal|2
decl_stmt|;
comment|/**< External Clock input edge                                                          00 = rising edge                                                          01 = falling edge                                                          10 = both rising& falling edge                                                          11 = reserved */
name|uint64_t
name|ckout_out4
range|:
literal|1
decl_stmt|;
comment|/**< Destination for PTP Clock Out output                                                          See CKOUT_OUT */
name|uint64_t
name|pps_out
range|:
literal|5
decl_stmt|;
comment|/**< Destination for PTP PPS output to GPIO                                                          0-19 : GPIO[PPS_OUT[4:0]]                                                          - 20:30: Reserved                                                          31   : Disabled                                                          This should be different from CKOUT_OUT */
name|uint64_t
name|pps_inv
range|:
literal|1
decl_stmt|;
comment|/**< Invert PTP PPS                                                          0 = don't invert                                                          1 = invert */
name|uint64_t
name|pps_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP PPS */
name|uint64_t
name|ckout_out
range|:
literal|4
decl_stmt|;
comment|/**< Destination for PTP Clock Out output to GPIO                                                          0-19 : GPIO[[CKOUT_OUT4,CKOUT_OUT[3:0]]]                                                          - 20:30: Reserved                                                          31   : Disabled                                                          This should be different from PPS_OUT */
name|uint64_t
name|ckout_inv
range|:
literal|1
decl_stmt|;
comment|/**< Invert PTP Clock Out                                                          0 = don't invert                                                          1 = invert */
name|uint64_t
name|ckout_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP Clock Out */
name|uint64_t
name|evcnt_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for event counter input                                                          0x00-0x0f : GPIO[EVCNT_IN[3:0]]                                                          0x20      : GPIO[16]                                                          0x21      : GPIO[17]                                                          0x22      : GPIO[18]                                                          0x23      : GPIO[19]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x18      : RF_MCLK (PHY pin)                                                          0x12-0x17 : Reserved                                                          0x19-0x1f : Reserved                                                          0x24-0x3f : Reserved */
name|uint64_t
name|evcnt_edge
range|:
literal|1
decl_stmt|;
comment|/**< Event counter input edge                                                          0 = falling edge                                                          1 = rising edge */
name|uint64_t
name|evcnt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable event counter */
name|uint64_t
name|tstmp_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for timestamp input                                                          0x00-0x0f : GPIO[TSTMP_IN[3:0]]                                                          0x20      : GPIO[16]                                                          0x21      : GPIO[17]                                                          0x22      : GPIO[18]                                                          0x23      : GPIO[19]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x18      : RF_MCLK (PHY pin)                                                          0x12-0x17 : Reserved                                                          0x19-0x1f : Reserved                                                          0x24-0x3f : Reserved */
name|uint64_t
name|tstmp_edge
range|:
literal|1
decl_stmt|;
comment|/**< External timestamp input edge                                                          0 = falling edge                                                          1 = rising edge */
name|uint64_t
name|tstmp_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable external timestamp */
name|uint64_t
name|ext_clk_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for external clock                                                          0x00-0x0f : GPIO[EXT_CLK_IN[3:0]]                                                          0x20      : GPIO[16]                                                          0x21      : GPIO[17]                                                          0x22      : GPIO[18]                                                          0x23      : GPIO[19]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x18      : RF_MCLK (PHY pin)                                                          0x12-0x17 : Reserved                                                          0x19-0x1f : Reserved                                                          0x24-0x3f : Reserved */
name|uint64_t
name|ext_clk_en
range|:
literal|1
decl_stmt|;
comment|/**< Use external clock */
name|uint64_t
name|ptp_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP Module */
else|#
directive|else
name|uint64_t
name|ptp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|tstmp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tstmp_edge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tstmp_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|evcnt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|evcnt_edge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|evcnt_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ckout_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ckout_inv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ckout_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pps_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pps_inv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pps_out
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ckout_out4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_edge
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ckout
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pps
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_42_63
range|:
literal|22
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_clock_cfg_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_clock_cfg_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|evcnt_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for event counter input                                                          0x00-0x0f : GPIO[EVCNT_IN[3:0]]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x12      : QLM2_REF_CLK                                                          0x13-0x3f : Reserved */
name|uint64_t
name|evcnt_edge
range|:
literal|1
decl_stmt|;
comment|/**< Event counter input edge                                                          0 = falling edge                                                          1 = rising edge */
name|uint64_t
name|evcnt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable event counter */
name|uint64_t
name|tstmp_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for timestamp input                                                          0x00-0x0f : GPIO[TSTMP_IN[3:0]]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x12      : QLM2_REF_CLK                                                          0x13-0x3f : Reserved */
name|uint64_t
name|tstmp_edge
range|:
literal|1
decl_stmt|;
comment|/**< External timestamp input edge                                                          0 = falling edge                                                          1 = rising edge */
name|uint64_t
name|tstmp_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable external timestamp */
name|uint64_t
name|ext_clk_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for external clock                                                          0x00-0x0f : GPIO[EXT_CLK_IN[3:0]]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x12      : QLM2_REF_CLK                                                          0x13-0x3f : Reserved */
name|uint64_t
name|ext_clk_en
range|:
literal|1
decl_stmt|;
comment|/**< Use positive edge of external clock */
name|uint64_t
name|ptp_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP Module */
else|#
directive|else
name|uint64_t
name|ptp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|tstmp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tstmp_edge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tstmp_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|evcnt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|evcnt_edge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|evcnt_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_mio_ptp_clock_cfg_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_clock_cfg_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ext_clk_edge
range|:
literal|2
decl_stmt|;
comment|/**< External Clock input edge                                                          00 = rising edge                                                          01 = falling edge                                                          10 = both rising& falling edge                                                          11 = reserved */
name|uint64_t
name|ckout_out4
range|:
literal|1
decl_stmt|;
comment|/**< Destination for PTP Clock Out output                                                          0-19 : GPIO[[CKOUT_OUT4,CKOUT_OUT[3:0]]]                                                          This should be different from PPS_OUT */
name|uint64_t
name|pps_out
range|:
literal|5
decl_stmt|;
comment|/**< Destination for PTP PPS output                                                          0-19 : GPIO[PPS_OUT[4:0]]                                                          This should be different from CKOUT_OUT */
name|uint64_t
name|pps_inv
range|:
literal|1
decl_stmt|;
comment|/**< Invert PTP PPS                                                          0 = don't invert                                                          1 = invert */
name|uint64_t
name|pps_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP PPS */
name|uint64_t
name|ckout_out
range|:
literal|4
decl_stmt|;
comment|/**< Destination for PTP Clock Out output                                                          0-19 : GPIO[[CKOUT_OUT4,CKOUT_OUT[3:0]]]                                                          This should be different from PPS_OUT */
name|uint64_t
name|ckout_inv
range|:
literal|1
decl_stmt|;
comment|/**< Invert PTP Clock Out                                                          0 = don't invert                                                          1 = invert */
name|uint64_t
name|ckout_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP Clock Out */
name|uint64_t
name|evcnt_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for event counter input                                                          0x00-0x0f : GPIO[EVCNT_IN[3:0]]                                                          0x20      : GPIO[16]                                                          0x21      : GPIO[17]                                                          0x22      : GPIO[18]                                                          0x23      : GPIO[19]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x12      : QLM2_REF_CLK                                                          0x13-0x1f : Reserved                                                          0x24-0x3f : Reserved */
name|uint64_t
name|evcnt_edge
range|:
literal|1
decl_stmt|;
comment|/**< Event counter input edge                                                          0 = falling edge                                                          1 = rising edge */
name|uint64_t
name|evcnt_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable event counter */
name|uint64_t
name|tstmp_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for timestamp input                                                          0x00-0x0f : GPIO[TSTMP_IN[3:0]]                                                          0x20      : GPIO[16]                                                          0x21      : GPIO[17]                                                          0x22      : GPIO[18]                                                          0x23      : GPIO[19]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x12      : QLM2_REF_CLK                                                          0x13-0x1f : Reserved                                                          0x24-0x3f : Reserved */
name|uint64_t
name|tstmp_edge
range|:
literal|1
decl_stmt|;
comment|/**< External timestamp input edge                                                          0 = falling edge                                                          1 = rising edge */
name|uint64_t
name|tstmp_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable external timestamp */
name|uint64_t
name|ext_clk_in
range|:
literal|6
decl_stmt|;
comment|/**< Source for external clock                                                          0x00-0x0f : GPIO[EXT_CLK_IN[3:0]]                                                          0x20      : GPIO[16]                                                          0x21      : GPIO[17]                                                          0x22      : GPIO[18]                                                          0x23      : GPIO[19]                                                          0x10      : QLM0_REF_CLK                                                          0x11      : QLM1_REF_CLK                                                          0x12      : QLM2_REF_CLK                                                          0x13-0x1f : Reserved                                                          0x24-0x3f : Reserved */
name|uint64_t
name|ext_clk_en
range|:
literal|1
decl_stmt|;
comment|/**< Use external clock */
name|uint64_t
name|ptp_en
range|:
literal|1
decl_stmt|;
comment|/**< Enable PTP Module */
else|#
directive|else
name|uint64_t
name|ptp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|tstmp_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tstmp_edge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tstmp_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|evcnt_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|evcnt_edge
range|:
literal|1
decl_stmt|;
name|uint64_t
name|evcnt_in
range|:
literal|6
decl_stmt|;
name|uint64_t
name|ckout_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ckout_inv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ckout_out
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pps_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pps_inv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pps_out
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ckout_out4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_clk_edge
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_mio_ptp_clock_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_cfg_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_cfg_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_clock_cfg
name|cvmx_mio_ptp_clock_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_clock_comp  *  * MIO_PTP_CLOCK_COMP = Compensator  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_clock_comp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_clock_comp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
comment|/**< Nanoseconds */
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_comp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_clock_comp
name|cvmx_mio_ptp_clock_comp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_clock_hi  *  * MIO_PTP_CLOCK_HI = Hi bytes of CLOCK  *  * Writes to MIO_PTP_CLOCK_HI also clear MIO_PTP_CLOCK_LO. To update all 96 bits, write MIO_PTP_CLOCK_HI followed  * by MIO_PTP_CLOCK_LO  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_clock_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_clock_hi_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
comment|/**< Nanoseconds */
else|#
directive|else
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_hi_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_clock_hi
name|cvmx_mio_ptp_clock_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_clock_lo  *  * MIO_PTP_CLOCK_LO = Lo bytes of CLOCK  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_clock_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_clock_lo_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_clock_lo_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_clock_lo
name|cvmx_mio_ptp_clock_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_evt_cnt  *  * MIO_PTP_EVT_CNT = Event Counter  *  * Writes to MIO_PTP_EVT_CNT increment this register by the written data. The register counts down by  * 1 for every MIO_PTP_CLOCK_CFG[EVCNT_EDGE] edge of MIO_PTP_CLOCK_CFG[EVCNT_IN]. When register equals  * 0, an interrupt gets gerated  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_evt_cnt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_evt_cnt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|cntr
range|:
literal|64
decl_stmt|;
comment|/**< Nanoseconds */
else|#
directive|else
name|uint64_t
name|cntr
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_evt_cnt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_evt_cnt
name|cvmx_mio_ptp_evt_cnt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_phy_1pps_in  *  * MIO_PTP_PHY_1PPS_IN = PHY 1PPS input mux selection  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_phy_1pps_in
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_phy_1pps_in_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|sel
range|:
literal|5
decl_stmt|;
comment|/**< Source for PHY 1pps input signal                                                          0-19 : GPIO[SEL[4:0]], for AGPS_1PPS                                                          24   : PPS_OUT (Enabled by PPS_EN and PPS_INV,                                                                 reflects ptp_pps after PPS_INV inverter)                                                          - 20-23: Reserved                                                          - 25-30: Reserved                                                          31   : Disabled */
else|#
directive|else
name|uint64_t
name|sel
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_phy_1pps_in_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_phy_1pps_in
name|cvmx_mio_ptp_phy_1pps_in_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_pps_hi_incr  *  * MIO_PTP_PPS_HI_INCR = PTP PPS Hi Increment  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_pps_hi_incr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_pps_hi_incr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
comment|/**< Nanoseconds */
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_pps_hi_incr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_hi_incr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_hi_incr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_hi_incr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_pps_hi_incr
name|cvmx_mio_ptp_pps_hi_incr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_pps_lo_incr  *  * MIO_PTP_PPS_LO_INCR = PTP PPS Lo Increment  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_pps_lo_incr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_pps_lo_incr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
comment|/**< Nanoseconds */
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|nanosec
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_pps_lo_incr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_lo_incr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_lo_incr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_lo_incr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_pps_lo_incr
name|cvmx_mio_ptp_pps_lo_incr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_pps_thresh_hi  *  * MIO_PTP_PPS_THRESH_HI = Hi bytes of PTP PPS  *  * Writes to MIO_PTP_PPS_THRESH_HI also clear MIO_PTP_PPS_THRESH_LO. To update all 96 bits, write MIO_PTP_PPS_THRESH_HI followed  * by MIO_PTP_PPS_THRESH_LO  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_pps_thresh_hi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_pps_thresh_hi_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
comment|/**< Nanoseconds */
else|#
directive|else
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_pps_thresh_hi_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_thresh_hi_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_thresh_hi_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_thresh_hi_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_pps_thresh_hi
name|cvmx_mio_ptp_pps_thresh_hi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_pps_thresh_lo  *  * MIO_PTP_PPS_THRESH_LO = Lo bytes of PTP PPS  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_pps_thresh_lo
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_pps_thresh_lo_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
comment|/**< Fractions of Nanoseconds */
else|#
directive|else
name|uint64_t
name|frnanosec
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_pps_thresh_lo_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_thresh_lo_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_thresh_lo_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_pps_thresh_lo_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_pps_thresh_lo
name|cvmx_mio_ptp_pps_thresh_lo_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_ptp_timestamp  *  * MIO_PTP_TIMESTAMP = Timestamp latched on MIO_PTP_CLOCK_CFG[TSTMP_EDGE] edge of MIO_PTP_CLOCK_CFG[TSTMP_IN]  *  */
end_comment

begin_union
union|union
name|cvmx_mio_ptp_timestamp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_ptp_timestamp_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
comment|/**< Nanoseconds */
else|#
directive|else
name|uint64_t
name|nanosec
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_ptp_timestamp_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_ptp_timestamp
name|cvmx_mio_ptp_timestamp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_qlm#_cfg  *  * Notes:  * Certain QLM_SPD is valid only for certain QLM_CFG configuration, refer to HRM for valid  * combinations.  These csrs are reset only on COLD_RESET.  The Reset values for QLM_SPD and QLM_CFG  * are as follows:               MIO_QLM0_CFG  SPD=F, CFG=2 SGMII (AGX0)  *                               MIO_QLM1_CFG  SPD=0, CFG=1 PCIE 2x1 (PEM0/PEM1)  */
end_comment

begin_union
union|union
name|cvmx_mio_qlmx_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_qlmx_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|1
decl_stmt|;
comment|/**< Port Mode, value of MIO_RST_CNTLX.PRTMODE[0]                                                          0 = port is EP mode                                                          1 = port is RC mode */
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0 speed for SGMii                                                             0   = 5     Gbaud   100.00 MHz Ref                                                             1   = 2.5   Gbaud   100.00 MHz Ref                                                             2   = 2.5   Gbaud   100.00 MHz Ref                                                             3   = 1.25  Gbaud   100.00 MHz Ref                                                             4   = 1.25  Gbaud   156.25 MHz Ref                                                             5   = 6.25  Gbaud   125.00 MHz Ref                                                             6   = 5     Gbaud   125.00 MHz Ref                                                             7   = 2.5   Gbaud   156.25 MHz Ref                                                             8   = 3.125 Gbaud   125.00 MHz Ref                                                             9   = 2.5   Gbaud   125.00 MHz Ref                                                             10  = 1.25  Gbaud   125.00 MHz Ref                                                             11  = 5     Gbaud   156.25 MHz Ref                                                             12  = 6.25  Gbaud   156.25 MHz Ref                                                             13  = 3.75  Gbaud   156.25 MHz Ref                                                             14  = 3.125 Gbaud   156.25 MHz Ref                                                             15  = QLM Disabled                                                           QLM1 speed PEM0   PEM1                                                             0   =  2.5/5  2.5/5 Gbaud  100.00 MHz Ref                                                             1   =  2.5    2.5/5 Gbaud  100.00 MHz Ref                                                             2   =  2.5/5  2.5   Gbaud  100.00 MHz Ref                                                             3   =  2.5    2.5   Gbaud  100.00 MHz Ref                                                             4   =  2.5/5  2.5/5 Gbaud  125.00 MHz Ref                                                             6   =  2.5/5  2.5   Gbaud  125.00 MHz Ref                                                             7   =  2.5    2.5   Gbaud  125.00 MHz Ref                                                             9   =  2.5    2.5/5 Gbaud  125.00 MHz Ref                                                             15  =  QLM Disabled                                                             5,8,10-14 are reserved */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|4
decl_stmt|;
comment|/**< QLM configuration mode                                                          For Interface 0:                                                             00 Reserved                                                             01 Reserved                                                             10 SGMII (AGX0)                                                             11 Reserved                                                          For Interface 1:                                                             00 PCIE 1x2 (PEM1)                                                             01 PCIE 2x1 (PEM0/PEM1)                                                             1x Reserved */
else|#
directive|else
name|uint64_t
name|qlm_cfg
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_qlmx_cfg_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|1
decl_stmt|;
comment|/**< Port Mode, value of MIO_RST_CNTLX.PRTMODE[0]                                                             0 = port is EP mode                                                             1 = port is RC mode                                                          For QLM2, HOST_MODE is always '0' because PCIe                                                          is not supported. */
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM speed for SGMii/XAUI                                                             0   = 5     Gbaud   100.00 MHz Ref                                                             1   = 2.5   Gbaud   100.00 MHz Ref                                                             2   = 2.5   Gbaud   100.00 MHz Ref                                                             3   = 1.25  Gbaud   100.00 MHz Ref                                                             4   = 1.25  Gbaud   156.25 MHz Ref                                                             5   = 6.25  Gbaud   125.00 MHz Ref                                                             6   = 5     Gbaud   125.00 MHz Ref                                                             7   = 2.5   Gbaud   156.25 MHz Ref                                                             8   = 3.125 Gbaud   125.00 MHz Ref                                                             9   = 2.5   Gbaud   125.00 MHz Ref                                                             10  = 1.25  Gbaud   125.00 MHz Ref                                                             11  = 5     Gbaud   156.25 MHz Ref                                                             12  = 6.25  Gbaud   156.25 MHz Ref                                                             13  = 3.75  Gbaud   156.25 MHz Ref                                                             14  = 3.125 Gbaud   156.25 MHz Ref                                                             15  = QLM Disabled                                                           QLM speed PEM0   PEM1                                                             0   =  2.5/5  2.5/5 Gbaud  100.00 MHz Ref                                                             1   =  2.5    2.5/5 Gbaud  100.00 MHz Ref                                                             2   =  2.5/5  2.5   Gbaud  100.00 MHz Ref                                                             3   =  2.5    2.5   Gbaud  100.00 MHz Ref                                                             4   =  2.5/5  2.5/5 Gbaud  125.00 MHz Ref                                                             6   =  2.5/5  2.5   Gbaud  125.00 MHz Ref                                                             7   =  2.5    2.5   Gbaud  125.00 MHz Ref                                                             9   =  2.5    2.5/5 Gbaud  125.00 MHz Ref                                                             15  =  QLM Disabled                                                             5,8,10-14 are reserved */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|2
decl_stmt|;
comment|/**< QLM configuration mode                                                          For Interface 0:                                                             00 PCIE 1x4 (PEM0)                                                             01 Reserved                                                             10 SGMII (AGX1)                                                             11 XAUI (AGX1)                                                          For Interface 1:                                                             00 PCIE 1x2 (PEM1)                                                             01 PCIE 2x1 (PEM0/PEM1)                                                             10 Reserved                                                             11 Reserved                                                          For Interface 2:                                                             00 Reserved                                                             01 Reserved                                                             10 SGMII (AGX0)                                                             11 XAUI (AGX0) */
else|#
directive|else
name|uint64_t
name|qlm_cfg
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_13
range|:
literal|2
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_63
range|:
literal|49
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_mio_qlmx_cfg_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM speed                                                          0   = 5     Gbaud                                                          1   = 2.5   Gbaud                                                          2   = 2.5   Gbaud                                                          3   = 1.25  Gbaud                                                          4   = 1.25  Gbaud                                                          5   = 6.25  Gbaud                                                          6   = 5     Gbaud                                                          7   = 2.5   Gbaud                                                          8   = 3.125 Gbaud                                                          9   = 2.5   Gbaud                                                          10  = 1.25  Gbaud                                                          11  = 5     Gbaud                                                          12  = 6.25  Gbaud                                                          13  = 3.75  Gbaud                                                          14  = 3.125 Gbaud                                                          15  = QLM Disabled */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|4
decl_stmt|;
comment|/**< QLM configuration mode                                                             0000 PCIE gen2                                                             0001 SRIO 1x4 short                                                             0010 PCIE gen1 only                                                             0011 SRIO 1x4 long                                                             0100 SRIO 2x2 short                                                             0101 SRIO 4x1 short                                                             0110 SRIO 2x2 long                                                             0111 SRIO 4x1 long                                                             1000 PCIE gen2 (alias)                                                             1001 SGMII                                                             1010 PCIE gen1 only (alias)                                                             1011 XAUI                                                             1100 RESERVED                                                             1101 RESERVED                                                             1110 RESERVED                                                             1111 RESERVED                                                          NOTE: Internal encodings differ from QLM_MODE                                                                pins encodings */
else|#
directive|else
name|uint64_t
name|qlm_cfg
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
struct|struct
name|cvmx_mio_qlmx_cfg_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM speed                                                          0   = 5     Gbaud   100.00 MHz Ref                                                          1   = 2.5   Gbaud   100.00 MHz Ref                                                          2   = 2.5   Gbaud   100.00 MHz Ref                                                          3   = 1.25  Gbaud   100.00 MHz Ref                                                          4   = 1.25  Gbaud   156.25 MHz Ref                                                          5   = 6.25  Gbaud   125.00 MHz Ref                                                          6   = 5     Gbaud   125.00 MHz Ref                                                          7   = 2.5   Gbaud   156.25 MHz Ref                                                          8   = 3.125 Gbaud   125.00 MHz Ref                                                          9   = 2.5   Gbaud   125.00 MHz Ref                                                          10  = 1.25  Gbaud   125.00 MHz Ref                                                          11  = 5     Gbaud   156.25 MHz Ref                                                          12  = 6.25  Gbaud   156.25 MHz Ref                                                          13  = 3.75  Gbaud   156.25 MHz Ref                                                          14  = 3.125 Gbaud   156.25 MHz Ref                                                          15  = QLM Disabled */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|3
decl_stmt|;
comment|/**< QLM configuration mode                                                             000 = PCIE                                                             001 = ILK                                                             010 = SGMII                                                             011 = XAUI                                                             100 = RESERVED                                                             101 = RESERVED                                                             110 = RESERVED                                                             111 = RXAUI                                                          NOTE: Internal encodings differ from QLM_MODE                                                                pins encodings */
else|#
directive|else
name|uint64_t
name|qlm_cfg
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|qlm_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_mio_qlmx_cfg_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_qlmx_cfg_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_qlmx_cfg
name|cvmx_mio_qlmx_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_boot  *  * Notes:  * JTCSRDIS, EJTAGDIS, ROMEN reset to 1 in authentik mode; in all other modes they reset to 0.  *  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_boot
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_boot_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|chipkill
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition of CHIPKILL starts the CHIPKILL                                                          timer.  When CHIPKILL=1 and the timer expires,                                                          internal chip reset is asserted forever until the                                                          next chip reset.  The CHIPKILL timer can be                                                          stopped only by a chip (cold, warm, soft) reset.                                                          The length of the CHIPKILL timer is specified by                                                          MIO_RST_CKILL[TIMER]. */
name|uint64_t
name|jtcsrdis
range|:
literal|1
decl_stmt|;
comment|/**< If JTCSRDIS=1, internal CSR access via JTAG TAP                                                          controller is disabled */
name|uint64_t
name|ejtagdis
range|:
literal|1
decl_stmt|;
comment|/**< If EJTAGDIS=1, external EJTAG access is disabled */
name|uint64_t
name|romen
range|:
literal|1
decl_stmt|;
comment|/**< If ROMEN=1, Authentik/eMMC boot ROM is visible                                                          in the boot bus address space. */
name|uint64_t
name|ckill_ppdis
range|:
literal|1
decl_stmt|;
comment|/**< If CK_PPDIS=1, PPs other than 0 are disabled                                                          during a CHIPKILL.  Writes have no effect when                                                          MIO_RST_BOOT[CHIPKILL]=1. */
name|uint64_t
name|jt_tstmode
range|:
literal|1
decl_stmt|;
comment|/**< JTAG test mode */
name|uint64_t
name|reserved_50_57
range|:
literal|8
decl_stmt|;
name|uint64_t
name|lboot_ext
range|:
literal|2
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|reserved_44_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm4_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM4_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm3_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM3_SPD pins sampled at DCOK assertion */
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
comment|/**< Core clock multiplier:                                                            C_MUL = (core clk speed) / (ref clock speed)                                                          "ref clock speed" should always be 50MHz.                                                          If PLL_QLM_REF_CLK_EN=0, "ref clock" comes                                                               from PLL_REF_CLK pin.                                                          If PLL_QLM_REF_CLK_EN=1, "ref clock" is                                                               1/2 speed of QLMC_REF_CLK_* pins. */
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
comment|/**< Coprocessor clock multiplier:                                                            PNR_MUL = (coprocessor clk speed) /                                                                            (ref clock speed)                                                          See C_MUL comments about ref clock. */
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM2_SPD, report MIO_QLM2_CFG[SPD] */
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM1_SPD, report MIO_QLM1_CFG[SPD] */
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0_SPD, report MIO_QLM0_CFG[SPD] */
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
comment|/**< Last boot cause mask, resets only with dcok.                                                           bit9 - Soft reset due to watchdog                                                          bit8 - Soft reset due to CIU_SOFT_RST write                                                          bit7 - Warm reset due to cntl0 link-down or                                                                 hot-reset                                                          bit6 - Warm reset due to cntl1 link-down or                                                                 hot-reset                                                          bit5 - Cntl1 reset due to PERST1_L pin                                                          bit4 - Cntl0 reset due to PERST0_L pin                                                          bit3 - Warm reset due to PERST1_L pin                                                          bit2 - Warm reset due to PERST0_L pin                                                          bit1 - Warm reset due to CHIP_RESET_L pin                                                          bit0 - Cold reset due to DCOK pin */
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
comment|/**< Determines whether core 0 remains in reset after                                                          after chip cold/warm/soft reset. */
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to REMOTE_BOOT pin */
else|#
directive|else
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qlm3_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm4_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_44_47
range|:
literal|4
decl_stmt|;
name|uint64_t
name|lboot_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_50_57
range|:
literal|8
decl_stmt|;
name|uint64_t
name|jt_tstmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ckill_ppdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|romen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ejtagdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jtcsrdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chipkill
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_rst_boot_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|chipkill
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition of CHIPKILL starts the CHIPKILL                                                          timer.  When CHIPKILL=1 and the timer expires,                                                          internal chip reset is asserted forever until the                                                          next chip reset.  The CHIPKILL timer can be                                                          stopped only by a chip (cold, warm, soft) reset.                                                          The length of the CHIPKILL timer is specified by                                                          MIO_RST_CKILL[TIMER]. */
name|uint64_t
name|jtcsrdis
range|:
literal|1
decl_stmt|;
comment|/**< If JTCSRDIS=1, internal CSR access via JTAG TAP                                                          controller is disabled */
name|uint64_t
name|ejtagdis
range|:
literal|1
decl_stmt|;
comment|/**< If EJTAGDIS=1, external EJTAG access is disabled */
name|uint64_t
name|romen
range|:
literal|1
decl_stmt|;
comment|/**< If ROMEN=1, Authentik/eMMC boot ROM is visible                                                          in the boot bus address space. */
name|uint64_t
name|ckill_ppdis
range|:
literal|1
decl_stmt|;
comment|/**< If CK_PPDIS=1, PPs other than 0 are disabled                                                          during a CHIPKILL.  Writes have no effect when                                                          MIO_RST_BOOT[CHIPKILL]=1. */
name|uint64_t
name|jt_tstmode
range|:
literal|1
decl_stmt|;
comment|/**< JTAG test mode */
name|uint64_t
name|reserved_50_57
range|:
literal|8
decl_stmt|;
name|uint64_t
name|lboot_ext
range|:
literal|2
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|reserved_36_47
range|:
literal|12
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
comment|/**< Core clock multiplier:                                                            C_MUL = (core clk speed) / (ref clock speed)                                                          "ref clock speed" should always be 50MHz.                                                          If PLL_QLM_REF_CLK_EN=0, "ref clock" comes                                                               from PLL_REF_CLK pin.                                                          If PLL_QLM_REF_CLK_EN=1, "ref clock" is                                                               1/2 speed of QLMC_REF_CLK_* pins. */
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
comment|/**< Coprocessor clock multiplier:                                                            PNR_MUL = (coprocessor clk speed) /                                                                            (ref clock speed)                                                          See C_MUL comments about ref clock. */
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM2_SPD, report MIO_QLM2_CFG[SPD] */
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM1_SPD, report MIO_QLM1_CFG[SPD] */
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0_SPD, report MIO_QLM0_CFG[SPD] */
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
comment|/**< Last boot cause mask, resets only with dcok.                                                           bit9 - Soft reset due to watchdog                                                          bit8 - Soft reset due to CIU_SOFT_RST write                                                          bit7 - Warm reset due to cntl0 link-down or                                                                 hot-reset                                                          bit6 - Warm reset due to cntl1 link-down or                                                                 hot-reset                                                          bit5 - Cntl1 reset due to PERST1_L pin                                                          bit4 - Cntl0 reset due to PERST0_L pin                                                          bit3 - Warm reset due to PERST1_L pin                                                          bit2 - Warm reset due to PERST0_L pin                                                          bit1 - Warm reset due to CHIP_RESET_L pin                                                          bit0 - Cold reset due to DCOK pin */
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
comment|/**< Determines whether core 0 remains in reset after                                                          after chip cold/warm/soft reset. */
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to REMOTE_BOOT pin */
else|#
directive|else
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_36_47
range|:
literal|12
decl_stmt|;
name|uint64_t
name|lboot_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_50_57
range|:
literal|8
decl_stmt|;
name|uint64_t
name|jt_tstmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ckill_ppdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|romen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ejtagdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jtcsrdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chipkill
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
struct|struct
name|cvmx_mio_rst_boot_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
comment|/**< Core clock multiplier:                                                            C_MUL = (core clk speed) / (ref clock speed)                                                          "ref clock speed" should always be 50MHz.                                                          If PLL_QLM_REF_CLK_EN=0, "ref clock" comes                                                               from PLL_REF_CLK pin.                                                          If PLL_QLM_REF_CLK_EN=1, "ref clock" is                                                               1/2 speed of QLMC_REF_CLK_* pins. */
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
comment|/**< Coprocessor clock multiplier:                                                            PNR_MUL = (coprocessor clk speed) /                                                                            (ref clock speed)                                                          See C_MUL comments about ref clock. */
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM2_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM1_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0_SPD pins sampled at DCOK assertion */
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
comment|/**< Last boot cause mask, resets only with dock.                                                           bit9 - Soft reset due to watchdog                                                          bit8 - Soft reset due to CIU_SOFT_RST write                                                          bit7 - Warm reset due to cntl0 link-down or                                                                 hot-reset                                                          bit6 - Warm reset due to cntl1 link-down or                                                                 hot-reset                                                          bit5 - Cntl1 reset due to PERST1_L pin                                                          bit4 - Cntl0 reset due to PERST0_L pin                                                          bit3 - Warm reset due to PERST1_L pin                                                          bit2 - Warm reset due to PERST0_L pin                                                          bit1 - Warm reset due to CHIP_RESET_L pin                                                          bit0 - Cold reset due to DCOK pin */
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
comment|/**< Determines whether core 0 remains in reset after                                                          after chip cold/warm/soft reset. */
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to REMOTE_BOOT pin */
else|#
directive|else
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
name|struct
name|cvmx_mio_rst_boot_cn63xx
name|cn63xxp1
decl_stmt|;
struct|struct
name|cvmx_mio_rst_boot_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|chipkill
range|:
literal|1
decl_stmt|;
comment|/**< A 0->1 transition of CHIPKILL starts the CHIPKILL                                                          timer.  When CHIPKILL=1 and the timer expires,                                                          internal chip reset is asserted forever until the                                                          next chip reset.  The CHIPKILL timer can be                                                          stopped only by a chip (cold, warm, soft) reset.                                                          The length of the CHIPKILL timer is specified by                                                          MIO_RST_CKILL[TIMER]. */
name|uint64_t
name|jtcsrdis
range|:
literal|1
decl_stmt|;
comment|/**< If JTCSRDIS=1, internal CSR access via JTAG TAP                                                          controller is disabled */
name|uint64_t
name|ejtagdis
range|:
literal|1
decl_stmt|;
comment|/**< If EJTAGDIS=1, external EJTAG access is disabled */
name|uint64_t
name|romen
range|:
literal|1
decl_stmt|;
comment|/**< If ROMEN=1, Authentik ROM is visible in the boot                                                          bus address space. */
name|uint64_t
name|ckill_ppdis
range|:
literal|1
decl_stmt|;
comment|/**< If CK_PPDIS=1, PPs other than 0 are disabled                                                          during a CHIPKILL.  Writes have no effect when                                                          MIO_RST_BOOT[CHIPKILL]=1. */
name|uint64_t
name|reserved_50_58
range|:
literal|9
decl_stmt|;
name|uint64_t
name|lboot_ext
range|:
literal|2
decl_stmt|;
comment|/**< Extended Last boot cause mask, resets only with                                                          dock.                                                             bit1 - Warm reset due to cntl3 link-down or                                                                   hot-reset                                                            bit0 - Warm reset due to cntl2 link-down or                                                                   hot-reset */
name|uint64_t
name|reserved_36_47
range|:
literal|12
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
comment|/**< Core clock multiplier:                                                            C_MUL = (core clk speed) / (ref clock speed)                                                          "ref clock speed" should always be 50MHz.                                                          If PLL_QLM_REF_CLK_EN=0, "ref clock" comes                                                               from PLL_REF_CLK pin.                                                          If PLL_QLM_REF_CLK_EN=1, "ref clock" is                                                               1/2 speed of QLMC_REF_CLK_* pins. */
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
comment|/**< Coprocessor clock multiplier:                                                            PNR_MUL = (coprocessor clk speed) /                                                                            (ref clock speed)                                                          See C_MUL comments about ref clock. */
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM2_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM1_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0_SPD pins sampled at DCOK assertion */
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
comment|/**< Last boot cause mask, resets only with dock.                                                           bit9 - Soft reset due to watchdog                                                          bit8 - Soft reset due to CIU_SOFT_RST write                                                          bit7 - Warm reset due to cntl0 link-down or                                                                 hot-reset                                                          bit6 - Warm reset due to cntl1 link-down or                                                                 hot-reset                                                          bit5 - Cntl1 reset due to PERST1_L pin                                                          bit4 - Cntl0 reset due to PERST0_L pin                                                          bit3 - Warm reset due to PERST1_L pin                                                          bit2 - Warm reset due to PERST0_L pin                                                          bit1 - Warm reset due to CHIP_RESET_L pin                                                          bit0 - Cold reset due to DCOK pin */
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
comment|/**< Determines whether core 0 remains in reset after                                                          after chip cold/warm/soft reset. */
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to REMOTE_BOOT pin */
else|#
directive|else
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_36_47
range|:
literal|12
decl_stmt|;
name|uint64_t
name|lboot_ext
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_50_58
range|:
literal|9
decl_stmt|;
name|uint64_t
name|ckill_ppdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|romen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ejtagdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|jtcsrdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|chipkill
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
struct|struct
name|cvmx_mio_rst_boot_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|jt_tstmode
range|:
literal|1
decl_stmt|;
comment|/**< JTAG test mode */
name|uint64_t
name|reserved_44_57
range|:
literal|14
decl_stmt|;
name|uint64_t
name|qlm4_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM4_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm3_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM3_SPD pins sampled at DCOK assertion */
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
comment|/**< Core clock multiplier:                                                            C_MUL = (core clk speed) / (ref clock speed)                                                          "ref clock" is PLL_REF_CLK pin, which should                                                          always be 50 MHz. */
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
comment|/**< Coprocessor clock multiplier:                                                            PNR_MUL = (coprocessor clk speed)                                                                          (ref clock speed)                                                          See C_MUL comments about ref clock. */
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM2_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM1_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0_SPD pins sampled at DCOK assertion */
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
comment|/**< Last boot cause mask, resets only with dock.                                                           bit9 - Soft reset due to watchdog                                                          bit8 - Soft reset due to CIU_SOFT_RST write                                                          bit7 - Warm reset due to cntl0 link-down or                                                                 hot-reset                                                          bit6 - Warm reset due to cntl1 link-down or                                                                 hot-reset                                                          bit5 - Cntl1 reset due to PERST1_L pin                                                          bit4 - Cntl0 reset due to PERST0_L pin                                                          bit3 - Warm reset due to PERST1_L pin                                                          bit2 - Warm reset due to PERST0_L pin                                                          bit1 - Warm reset due to CHIP_RESET_L pin                                                          bit0 - Cold reset due to DCOK pin */
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
comment|/**< Determines whether core 0 remains in reset after                                                          after chip cold/warm/soft reset. */
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to REMOTE_BOOT pin */
else|#
directive|else
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qlm3_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm4_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_44_57
range|:
literal|14
decl_stmt|;
name|uint64_t
name|jt_tstmode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
struct|struct
name|cvmx_mio_rst_boot_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
name|uint64_t
name|qlm4_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM4_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm3_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM3_SPD pins sampled at DCOK assertion */
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
comment|/**< Core clock multiplier:                                                            C_MUL = (core clk speed) / (ref clock speed)                                                          "ref clock" is PLL_REF_CLK pin, which should                                                          always be 50 MHz. */
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
comment|/**< Coprocessor clock multiplier:                                                            PNR_MUL = (coprocessor clk speed)                                                                          (ref clock speed)                                                          See C_MUL comments about ref clock. */
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM2_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM1_SPD pins sampled at DCOK assertion */
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
comment|/**< QLM0_SPD pins sampled at DCOK assertion */
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
comment|/**< Last boot cause mask, resets only with dock.                                                           bit9 - Soft reset due to watchdog                                                          bit8 - Soft reset due to CIU_SOFT_RST write                                                          bit7 - Warm reset due to cntl0 link-down or                                                                 hot-reset                                                          bit6 - Warm reset due to cntl1 link-down or                                                                 hot-reset                                                          bit5 - Cntl1 reset due to PERST1_L pin                                                          bit4 - Cntl0 reset due to PERST0_L pin                                                          bit3 - Warm reset due to PERST1_L pin                                                          bit2 - Warm reset due to PERST0_L pin                                                          bit1 - Warm reset due to CHIP_RESET_L pin                                                          bit0 - Cold reset due to DCOK pin */
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
comment|/**< Determines whether core 0 remains in reset after                                                          after chip cold/warm/soft reset. */
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to REMOTE_BOOT pin */
else|#
directive|else
name|uint64_t
name|rboot_pin
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rboot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lboot
range|:
literal|10
decl_stmt|;
name|uint64_t
name|qlm0_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm1_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm2_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pnr_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|c_mul
range|:
literal|6
decl_stmt|;
name|uint64_t
name|qlm3_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|qlm4_spd
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_44_63
range|:
literal|20
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
name|struct
name|cvmx_mio_rst_boot_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_boot
name|cvmx_mio_rst_boot_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_cfg  *  * Notes:  * Cold reset will always performs a full bist.  *  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|cntl_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during cntl only reset,                                                          instead of a full bist. A warm/soft reset will                                                          not change this field. */
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during warm reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during soft reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
else|#
directive|else
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cntl_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_rst_cfg_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|bist_delay
range|:
literal|58
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|reserved_3_5
range|:
literal|3
decl_stmt|;
name|uint64_t
name|cntl_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during cntl only reset,                                                          instead of a full bist. A warm/soft reset will                                                          not change this field. */
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during warm reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during soft reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
else|#
directive|else
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cntl_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_5
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bist_delay
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_rst_cfg_cn61xx
name|cn63xx
decl_stmt|;
struct|struct
name|cvmx_mio_rst_cfg_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|bist_delay
range|:
literal|58
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|reserved_2_5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during warm reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during soft reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
else|#
directive|else
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_5
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bist_delay
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_mio_rst_cfg_cn61xx
name|cn66xx
decl_stmt|;
struct|struct
name|cvmx_mio_rst_cfg_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|bist_delay
range|:
literal|56
decl_stmt|;
comment|/**< Reserved */
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|cntl_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during cntl only reset,                                                          instead of a full bist. A warm/soft reset will                                                          not change this field. */
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during warm reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
comment|/**< Peform clear bist during soft reset, instead                                                          of a full bist. A warm/soft reset will not                                                          change this field. */
else|#
directive|else
name|uint64_t
name|soft_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|warm_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cntl_clr_bist
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_7
range|:
literal|5
decl_stmt|;
name|uint64_t
name|bist_delay
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
name|struct
name|cvmx_mio_rst_cfg_cn68xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_cfg_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_cfg
name|cvmx_mio_rst_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_ckill  *  * MIO_RST_CKILL = MIO Chipkill Timer Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_ckill
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_ckill_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
name|uint64_t
name|timer
range|:
literal|47
decl_stmt|;
comment|/**< CHIPKILL timer measured in SCLKs.  Reads return                                                          the current CHIPKILL timer.   Writes have no                                                          effect when MIO_RST_BOOT[CHIPKILL]=1. */
else|#
directive|else
name|uint64_t
name|timer
range|:
literal|47
decl_stmt|;
name|uint64_t
name|reserved_47_63
range|:
literal|17
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_rst_ckill_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_ckill_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_ckill_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_ckill
name|cvmx_mio_rst_ckill_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_cntl#  *  * Notes:  * GEN1_Only mode is enabled for PEM0 when QLM1_SPD[0] is set or when sclk< 550Mhz.  * GEN1_Only mode is enabled for PEM1 when QLM1_SPD[1] is set or when sclk< 550Mhz.  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_cntlx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_cntlx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|in_rev_ln
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding pin PCIE*_REV_LANES                                                          which is used for initial value for REV_LANES                                                          For INT0/CNTL0: pin PCIE0_REV_LANES                                                          For INT1/CNTL1: always zero as no PCIE1 pin */
name|uint64_t
name|rev_lanes
range|:
literal|1
decl_stmt|;
comment|/**< Reverse the lanes for INT*.                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to                                                          IN_REVLANE value.                                                          When QLM1_CFG=1, INT0(PEM0) REV_LANES internal                                                          setting will be always forced to '0', INT1(PEM1)                                                          will be forced to '1' regardless CSR value. */
name|uint64_t
name|gen1_only
range|:
literal|1
decl_stmt|;
comment|/**< Disable PCIE GEN2 Capability.  This bit is                                                          always unpredictable whenever the controller                                                          is not attached to any SerDes lanes, and is                                                          otherwise always set when SCLK is slower than                                                          550Mhz.                                                          The MIO_RST_CNTL*[GEN1_ONLY] value is based on                                                          the MIO_QLM1_CFG[QLM_SPD] value. */
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes the assertion of                                                          CIU_SOFT_PRST*[SOFT_PRST]                                                           A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0 */
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to controller reset status                                                           RESET_DONE is always zero (i.e. the controller                                                          is held in reset) when:                                                            - CIU_SOFT_PRST*[SOFT_PRST]=1, or                                                            - RST_RCV==1 and PERST*_L pin is asserted */
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes a warm chip reset                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding HOST_MODE=1                                                             1 = when corresponding HOST_MODE=0                                                           Note that a link-down or hot-reset event can                                                          never cause a warm chip reset when the                                                          controller is in reset (i.e. can never cause a                                                          warm reset when RST_DONE==0). */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding strap PCIE*_HOST_MODE                                                          For CNTL1/INT1, HOST_MODE is always '1' because                                                          there is no PCIE1_HOST_MODE pin. */
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
comment|/**< Port mode                                                             0 = port is EP mode                                                             1 = port is RC mode                                                             2,3 = Reserved                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized as                                                          HOST_MODE (corresponding strap PCIE*_HOST_MODE) */
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is driven by the OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding HOST_MODE=0                                                           1 = when corresponding HOST_MODE=1                                                           When set, OCTEON drives the corresponding                                                          PERST*_L pin. Otherwise, OCTEON does not drive                                                          the corresponding PERST*_L pin. */
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is recieved by OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding HOST_MODE=1                                                           1 = when corresponding HOST_MODE=0                                                           When RST_RCV==1, the PERST*_L value is                                                          received and may be used to reset the                                                          controller and (optionally, based on RST_CHIP)                                                          warm reset the chip.                                                           When RST_RCV==1 (and RST_CHIP=0),                                                          MIO_RST_INT[PERST*] gets set when the PERST*_L                                                          pin asserts. (This interrupt can alert SW                                                          whenever the external reset pin initiates a                                                          controller reset sequence.)                                                           RST_VAL gives the PERST*_L pin value when                                                          RST_RCV==1.                                                           When RST_RCV==0, the PERST*_L pin value is                                                          ignored. */
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip                                                          pin causes a chip warm reset like CHIP_RESET_L.                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0.                                                           RST_CHIP is not used when RST_RCV==0.                                                           When RST_RCV==0, RST_CHIP is ignored.                                                           When RST_RCV==1, RST_CHIP==1, and PERST*_L                                                          asserts, a chip warm reset will be generated. */
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to corresponding PERST*_L pin                                                          Unpredictable when RST_RCV==0. Reads as 1 when                                                          RST_RCV==1 and the PERST*_L pin is asserted.                                                          Reads as 0 when RST_RCV==1 and the PERST*_L                                                          pin is not asserted. */
else|#
directive|else
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gen1_only
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rev_lanes
range|:
literal|1
decl_stmt|;
name|uint64_t
name|in_rev_ln
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_rst_cntlx_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_mio_rst_cntlx_cn66xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes the assertion of                                                          CIU_SOFT_PRST*[SOFT_PRST]                                                           A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0 */
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to controller reset status                                                           RESET_DONE is always zero (i.e. the controller                                                          is held in reset) when:                                                            - CIU_SOFT_PRST*[SOFT_PRST]=1, or                                                            - RST_RCV==1 and PERST*_L pin is asserted */
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes a warm chip reset                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=1                                                             1 = when corresponding strap QLM*_HOST_MODE=0                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is initialized to 1 on cold reset.                                                           Note that a link-down or hot-reset event can                                                          never cause a warm chip reset when the                                                          controller is in reset (i.e. can never cause a                                                          warm reset when RST_DONE==0). */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding strap QLM*_HOST_MODE                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is reserved/RAZ.                                                           QLM0_HOST_MODE corresponds to PCIe0/sRIO0                                                          QLM1_HOST_MODE corresponds to PCIe1/sRIO1 */
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
comment|/**< Port mode                                                             0 = port is EP mode                                                             1 = port is RC mode                                                             2,3 = Reserved                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=0                                                             1 = when corresponding strap QLM*_HOST_MODE=1                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is initialized to 0 on cold reset. */
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                            is driven by the OCTEON.  A warm/soft reset                                                            will not change this field.  On cold reset,                                                            this field is initialized as follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=0                                                             1 = when corresponding strap QLM*_HOST_MODE=1                                                             When set, OCTEON drives the corresponding                                                            PERST*_L pin. Otherwise, OCTEON does not drive                                                            the corresponding PERST*_L pin.                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is reserved/RAZ. */
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                            is recieved by OCTEON.  A warm/soft reset                                                            will not change this field.  On cold reset,                                                            this field is initialized as follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=1                                                             1 = when corresponding strap QLM*_HOST_MODE=0                                                             When RST_RCV==1, the PERST*_L value is                                                            received and may be used to reset the                                                            controller and (optionally, based on RST_CHIP)                                                            warm reset the chip.                                                             When RST_RCV==1 (and RST_CHIP=0),                                                            MIO_RST_INT[PERST*] gets set when the PERST*_L                                                            pin asserts. (This interrupt can alert SW                                                            whenever the external reset pin initiates a                                                            controller reset sequence.)                                                             RST_VAL gives the PERST*_L pin value when                                                            RST_RCV==1.                                                             When RST_RCV==0, the PERST*_L pin value is                                                            ignored.                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is reserved/RAZ. */
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip                                                            pin causes a chip warm reset like CHIP_RESET_L.                                                            A warm/soft reset will not change this field.                                                            On cold reset, this field is initialized to 0.                                                             RST_CHIP is not used when RST_RCV==0.                                                             When RST_RCV==0, RST_CHIP is ignored.                                                             When RST_RCV==1, RST_CHIP==1, and PERST*_L                                                            asserts, a chip warm reset will be generated.                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is reserved/RAZ. */
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to corresponding PERST*_L pin                                                            Unpredictable when RST_RCV==0. Reads as 1 when                                                            RST_RCV==1 and the PERST*_L pin is asserted.                                                            Reads as 0 when RST_RCV==1 and the PERST*_L                                                            pin is not asserted.                                                           For MIO_RST_CNTL2 and MIO_RST_CNTL3, this field                                                          is reserved/RAZ. */
else|#
directive|else
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn66xx
struct|;
name|struct
name|cvmx_mio_rst_cntlx_cn66xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_cntlx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_cntlx
name|cvmx_mio_rst_cntlx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_ctl#  *  * Notes:  * GEN1_Only mode is enabled for PEM0 when QLM1_SPD[0] is set or when sclk< 550Mhz.  * GEN1_Only mode is enabled for PEM1 when QLM1_SPD[1] is set or when sclk< 550Mhz.  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_ctlx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_ctlx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|in_rev_ln
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding pin PCIE*_REV_LANES                                                          which is used for initial value for REV_LANES                                                          For INT0/CNTL0: pin PCIE0_REV_LANES                                                          For INT1/CNTL1: always zero as no PCIE1 pin */
name|uint64_t
name|rev_lanes
range|:
literal|1
decl_stmt|;
comment|/**< Reverse the lanes for INT*.                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to                                                          IN_REVLANE value.                                                          When QLM1_CFG=1, INT0(PEM0) REV_LANES internal                                                          setting will be always forced to '0', INT1(PEM1)                                                          will be forced to '1' regardless CSR value. */
name|uint64_t
name|gen1_only
range|:
literal|1
decl_stmt|;
comment|/**< Disable PCIE GEN2 Capability.  This bit is                                                          always unpredictable whenever the controller                                                          is not attached to any SerDes lanes, and is                                                          otherwise always set when SCLK is slower than                                                          550Mhz.                                                          The MIO_RST_CNTL*[GEN1_ONLY] value is based on                                                          the MIO_QLM1_CFG[QLM_SPD] value. */
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes the assertion of                                                          CIU_SOFT_PRST*[SOFT_PRST]                                                           A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0 */
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to controller reset status                                                           RESET_DONE is always zero (i.e. the controller                                                          is held in reset) when:                                                            - CIU_SOFT_PRST*[SOFT_PRST]=1, or                                                            - RST_RCV==1 and PERST*_L pin is asserted */
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes a warm chip reset                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding HOST_MODE=1                                                             1 = when corresponding HOST_MODE=0                                                           Note that a link-down or hot-reset event can                                                          never cause a warm chip reset when the                                                          controller is in reset (i.e. can never cause a                                                          warm reset when RST_DONE==0). */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding strap PCIE*_HOST_MODE                                                          For CNTL1/INT1, HOST_MODE is always '1' because                                                          there is no PCIE1_HOST_MODE pin. */
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
comment|/**< Port mode                                                             0 = port is EP mode                                                             1 = port is RC mode                                                             2,3 = Reserved                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized as                                                          HOST_MODE (corresponding strap PCIE*_HOST_MODE) */
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is driven by the OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding HOST_MODE=0                                                           1 = when corresponding HOST_MODE=1                                                           When set, OCTEON drives the corresponding                                                          PERST*_L pin. Otherwise, OCTEON does not drive                                                          the corresponding PERST*_L pin. */
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is recieved by OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding HOST_MODE=1                                                           1 = when corresponding HOST_MODE=0                                                           When RST_RCV==1, the PERST*_L value is                                                          received and may be used to reset the                                                          controller and (optionally, based on RST_CHIP)                                                          warm reset the chip.                                                           When RST_RCV==1 (and RST_CHIP=0),                                                          MIO_RST_INT[PERST*] gets set when the PERST*_L                                                          pin asserts. (This interrupt can alert SW                                                          whenever the external reset pin initiates a                                                          controller reset sequence.)                                                           RST_VAL gives the PERST*_L pin value when                                                          RST_RCV==1.                                                           When RST_RCV==0, the PERST*_L pin value is                                                          ignored. */
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip                                                          pin causes a chip warm reset like CHIP_RESET_L.                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0.                                                           RST_CHIP is not used when RST_RCV==0.                                                           When RST_RCV==0, RST_CHIP is ignored.                                                           When RST_RCV==1, RST_CHIP==1, and PERST*_L                                                          asserts, a chip warm reset will be generated. */
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to corresponding PERST*_L pin                                                          Unpredictable when RST_RCV==0. Reads as 1 when                                                          RST_RCV==1 and the PERST*_L pin is asserted.                                                          Reads as 0 when RST_RCV==1 and the PERST*_L                                                          pin is not asserted. */
else|#
directive|else
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|gen1_only
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rev_lanes
range|:
literal|1
decl_stmt|;
name|uint64_t
name|in_rev_ln
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_rst_ctlx_s
name|cn61xx
decl_stmt|;
struct|struct
name|cvmx_mio_rst_ctlx_cn63xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes the assertion of                                                          CIU_SOFT_PRST*[SOFT_PRST]                                                           A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to controller reset status                                                           RESET_DONE is always zero (i.e. the controller                                                          is held in reset) when:                                                            - CIU_SOFT_PRST*[SOFT_PRST]=1, or                                                            - RST_RCV==1 and PERST*_L pin is asserted */
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes a warm chip reset                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=1                                                             1 = when corresponding strap QLM*_HOST_MODE=0                                                           Note that a link-down or hot-reset event can                                                          never cause a warm chip reset when the                                                          controller is in reset (i.e. can never cause a                                                          warm reset when RST_DONE==0). */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding strap QLM*_HOST_MODE */
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
comment|/**< Port mode                                                             0 = port is EP mode                                                             1 = port is RC mode                                                             2,3 = Reserved                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=0                                                             1 = when corresponding strap QLM*_HOST_MODE=1 */
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is driven by the OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding strap QLM*_HOST_MODE=0                                                           1 = when corresponding strap QLM*_HOST_MODE=1                                                           When set, OCTEON drives the corresponding                                                          PERST*_L pin. Otherwise, OCTEON does not drive                                                          the corresponding PERST*_L pin. */
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is recieved by OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding strap QLM*_HOST_MODE=1                                                           1 = when corresponding strap QLM*_HOST_MODE=0                                                           When RST_RCV==1, the PERST*_L value is                                                          received and may be used to reset the                                                          controller and (optionally, based on RST_CHIP)                                                          warm reset the chip.                                                           When RST_RCV==1 (and RST_CHIP=0),                                                          MIO_RST_INT[PERST*] gets set when the PERST*_L                                                          pin asserts. (This interrupt can alert SW                                                          whenever the external reset pin initiates a                                                          controller reset sequence.)                                                           RST_VAL gives the PERST*_L pin value when                                                          RST_RCV==1.                                                           When RST_RCV==0, the PERST*_L pin value is                                                          ignored. */
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip                                                          pin causes a chip warm reset like CHIP_RESET_L.                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0.                                                           RST_CHIP is not used when RST_RCV==0.                                                           When RST_RCV==0, RST_CHIP is ignored.                                                           When RST_RCV==1, RST_CHIP==1, and PERST*_L                                                          asserts, a chip warm reset will be generated. */
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to corresponding PERST*_L pin                                                          Unpredictable when RST_RCV==0. Reads as 1 when                                                          RST_RCV==1 and the PERST*_L pin is asserted.                                                          Reads as 0 when RST_RCV==1 and the PERST*_L                                                          pin is not asserted. */
else|#
directive|else
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xx
struct|;
struct|struct
name|cvmx_mio_rst_ctlx_cn63xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to controller reset status                                                           RESET_DONE is always zero (i.e. the controller                                                          is held in reset) when:                                                            - CIU_SOFT_PRST*[SOFT_PRST]=1, or                                                            - RST_RCV==1 and PERST*_L pin is asserted */
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding controller                                                          link-down or hot-reset causes a warm chip reset                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=1                                                             1 = when corresponding strap QLM*_HOST_MODE=0                                                           Note that a link-down or hot-reset event can                                                          never cause a warm chip reset when the                                                          controller is in reset (i.e. can never cause a                                                          warm reset when RST_DONE==0). */
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
comment|/**< RO access to corresponding strap QLM*_HOST_MODE */
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
comment|/**< Port mode                                                             0 = port is EP mode                                                             1 = port is RC mode                                                             2,3 = Reserved                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized as                                                          follows:                                                             0 = when corresponding strap QLM*_HOST_MODE=0                                                             1 = when corresponding strap QLM*_HOST_MODE=1 */
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is driven by the OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding strap QLM*_HOST_MODE=0                                                           1 = when corresponding strap QLM*_HOST_MODE=1                                                           When set, OCTEON drives the corresponding                                                          PERST*_L pin. Otherwise, OCTEON does not drive                                                          the corresponding PERST*_L pin. */
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip pin                                                          is recieved by OCTEON.  A warm/soft reset                                                          will not change this field.  On cold reset,                                                          this field is initialized as follows:                                                           0 = when corresponding strap QLM*_HOST_MODE=1                                                           1 = when corresponding strap QLM*_HOST_MODE=0                                                           When RST_RCV==1, the PERST*_L value is                                                          received and may be used to reset the                                                          controller and (optionally, based on RST_CHIP)                                                          warm reset the chip.                                                           When RST_RCV==1 (and RST_CHIP=0),                                                          MIO_RST_INT[PERST*] gets set when the PERST*_L                                                          pin asserts. (This interrupt can alert SW                                                          whenever the external reset pin initiates a                                                          controller reset sequence.)                                                           RST_VAL gives the PERST*_L pin value when                                                          RST_RCV==1.                                                           When RST_RCV==0, the PERST*_L pin value is                                                          ignored. */
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
comment|/**< Controls whether corresponding PERST*_L chip                                                          pin causes a chip warm reset like CHIP_RESET_L.                                                          A warm/soft reset will not change this field.                                                          On cold reset, this field is initialized to 0.                                                           RST_CHIP is not used when RST_RCV==0.                                                           When RST_RCV==0, RST_CHIP is ignored.                                                           When RST_RCV==1, RST_CHIP==1, and PERST*_L                                                          asserts, a chip warm reset will be generated. */
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
comment|/**< Read-only access to corresponding PERST*_L pin                                                          Unpredictable when RST_RCV==0. Reads as 1 when                                                          RST_RCV==1 and the PERST*_L pin is asserted.                                                          Reads as 0 when RST_RCV==1 and the PERST*_L                                                          pin is not asserted. */
else|#
directive|else
name|uint64_t
name|rst_val
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_chip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_rcv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_drv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|prtmode
range|:
literal|2
decl_stmt|;
name|uint64_t
name|host_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn63xxp1
struct|;
name|struct
name|cvmx_mio_rst_ctlx_cn63xx
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_ctlx_cn63xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_ctlx_cn63xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_ctlx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_ctlx
name|cvmx_mio_rst_ctlx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_delay  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_delay
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_delay_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|warm_rst_dly
range|:
literal|16
decl_stmt|;
comment|/**< A warm reset immediately causes an early warm                                                          reset notification.  However, the assertion of                                                          warm reset will be delayed this many sclks.                                                          A warm/soft reset will not change this field.                                                          NOTE: This must be at least 500 dclks */
name|uint64_t
name|soft_rst_dly
range|:
literal|16
decl_stmt|;
comment|/**< A soft reset immediately causes an early soft                                                          reset notification.  However, the assertion of                                                          soft reset will be delayed this many sclks.                                                          A warm/soft reset will not change this field.                                                          NOTE: This must be at least 500 dclks */
else|#
directive|else
name|uint64_t
name|soft_rst_dly
range|:
literal|16
decl_stmt|;
name|uint64_t
name|warm_rst_dly
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_rst_delay_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_delay_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_delay_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_delay_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_delay_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_delay_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_delay_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_delay
name|cvmx_mio_rst_delay_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_int  *  * MIO_RST_INT = MIO Reset Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
comment|/**< PERST1_L asserted while MIO_RST_CTL1[RST_RCV]=1                                                          and MIO_RST_CTL1[RST_CHIP]=0 */
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
comment|/**< PERST0_L asserted while MIO_RST_CTL0[RST_RCV]=1                                                          and MIO_RST_CTL0[RST_CHIP]=0 */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rst_link3
range|:
literal|1
decl_stmt|;
comment|/**< A controller3 link-down/hot-reset occurred while                                                          MIO_RST_CNTL3[RST_LINK]=0.  Software must assert                                                          then de-assert CIU_SOFT_PRST3[SOFT_PRST] */
name|uint64_t
name|rst_link2
range|:
literal|1
decl_stmt|;
comment|/**< A controller2 link-down/hot-reset occurred while                                                          MIO_RST_CNTL2[RST_LINK]=0.  Software must assert                                                          then de-assert CIU_SOFT_PRST2[SOFT_PRST] */
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
comment|/**< A controller1 link-down/hot-reset occurred while                                                          MIO_RST_CTL1[RST_LINK]=0.  Software must assert                                                          then de-assert CIU_SOFT_PRST1[SOFT_PRST] */
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
comment|/**< A controller0 link-down/hot-reset occurred while                                                          MIO_RST_CTL0[RST_LINK]=0.  Software must assert                                                          then de-assert CIU_SOFT_PRST[SOFT_PRST] */
else|#
directive|else
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_rst_int_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
comment|/**< PERST1_L asserted while MIO_RST_CTL1[RST_RCV]=1                                                          and MIO_RST_CTL1[RST_CHIP]=0 */
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
comment|/**< PERST0_L asserted while MIO_RST_CTL0[RST_RCV]=1                                                          and MIO_RST_CTL0[RST_CHIP]=0 */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
comment|/**< A controller1 link-down/hot-reset occurred while                                                          MIO_RST_CTL1[RST_LINK]=0.  Software must assert                                                          then de-assert CIU_SOFT_PRST1[SOFT_PRST] */
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
comment|/**< A controller0 link-down/hot-reset occurred while                                                          MIO_RST_CTL0[RST_LINK]=0.  Software must assert                                                          then de-assert CIU_SOFT_PRST[SOFT_PRST] */
else|#
directive|else
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_rst_int_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_int
name|cvmx_mio_rst_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_rst_int_en  *  * MIO_RST_INT_EN = MIO Reset Interrupt Enable Register  *  */
end_comment

begin_union
union|union
name|cvmx_mio_rst_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_rst_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
comment|/**< Controller1 PERST reset interrupt enable */
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
comment|/**< Controller0 PERST reset interrupt enable */
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|rst_link3
range|:
literal|1
decl_stmt|;
comment|/**< Controller3 link-down/hot reset interrupt enable */
name|uint64_t
name|rst_link2
range|:
literal|1
decl_stmt|;
comment|/**< Controller2 link-down/hot reset interrupt enable */
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
comment|/**< Controller1 link-down/hot reset interrupt enable */
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
comment|/**< Controller0 link-down/hot reset interrupt enable */
else|#
directive|else
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_7
range|:
literal|4
decl_stmt|;
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_mio_rst_int_en_cn61xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
comment|/**< Controller1 PERST reset interrupt enable */
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
comment|/**< Controller0 PERST reset interrupt enable */
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
comment|/**< Controller1 link-down/hot reset interrupt enable */
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
comment|/**< Controller0 link-down/hot reset interrupt enable */
else|#
directive|else
name|uint64_t
name|rst_link0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rst_link1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|perst0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|perst1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|cn61xx
struct|;
name|struct
name|cvmx_mio_rst_int_en_cn61xx
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_en_cn61xx
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_en_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_en_cn61xx
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_en_cn61xx
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_rst_int_en_cn61xx
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_rst_int_en
name|cvmx_mio_rst_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_tws#_int  *  * MIO_TWSX_INT = TWSX Interrupt Register  *  * This register contains the TWSI interrupt enable mask and the interrupt source bits.  Note: the  * interrupt source bit for the TWSI core interrupt (CORE_INT) is read-only, the appropriate sequence  * must be written to the TWSI core to clear this interrupt.  The other interrupt source bits are write-  * one-to-clear.  TS_INT is set on the update of the MIO_TWS_TWSI_SW register (i.e. when it is written  * by a TWSI device).  ST_INT is set whenever the valid bit of the MIO_TWS_SW_TWSI is cleared (see above  * for reasons).  *  * Note: When using the high-level controller, CORE_EN should be clear and CORE_INT should be ignored.  * Conversely, when the high-level controller is disabled, ST_EN / TS_EN should be clear and ST_INT /  * TS_INT should be ignored.  *  * This register also contains a read-only copy of the TWSI bus (SCL and SDA) as well as control bits to  * override the current state of the TWSI bus (SCL_OVR and SDA_OVR).  Setting an override bit high will  * result in the open drain driver being activated, thus driving the corresponding signal low.  */
end_comment

begin_union
union|union
name|cvmx_mio_twsx_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_twsx_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|scl
range|:
literal|1
decl_stmt|;
comment|/**< SCL */
name|uint64_t
name|sda
range|:
literal|1
decl_stmt|;
comment|/**< SDA */
name|uint64_t
name|scl_ovr
range|:
literal|1
decl_stmt|;
comment|/**< SCL override */
name|uint64_t
name|sda_ovr
range|:
literal|1
decl_stmt|;
comment|/**< SDA override */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_en
range|:
literal|1
decl_stmt|;
comment|/**< TWSI core interrupt enable */
name|uint64_t
name|ts_en
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_TWSI_SW register update interrupt enable */
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_SW_TWSI register update interrupt enable */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_int
range|:
literal|1
decl_stmt|;
comment|/**< TWSI core interrupt */
name|uint64_t
name|ts_int
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_TWSI_SW register update interrupt */
name|uint64_t
name|st_int
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_SW_TWSI register update interrupt */
else|#
directive|else
name|uint64_t
name|st_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ts_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ts_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sda_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|scl_ovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|sda
range|:
literal|1
decl_stmt|;
name|uint64_t
name|scl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn38xx
decl_stmt|;
struct|struct
name|cvmx_mio_twsx_int_cn38xxp2
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|core_en
range|:
literal|1
decl_stmt|;
comment|/**< TWSI core interrupt enable */
name|uint64_t
name|ts_en
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_TWSI_SW register update interrupt enable */
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_SW_TWSI register update interrupt enable */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_int
range|:
literal|1
decl_stmt|;
comment|/**< TWSI core interrupt */
name|uint64_t
name|ts_int
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_TWSI_SW register update interrupt */
name|uint64_t
name|st_int
range|:
literal|1
decl_stmt|;
comment|/**< MIO_TWS_SW_TWSI register update interrupt */
else|#
directive|else
name|uint64_t
name|st_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ts_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|st_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ts_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|core_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xxp2
struct|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_int_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_twsx_int
name|cvmx_mio_twsx_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_tws#_sw_twsi  *  * MIO_TWSX_SW_TWSI = TWSX Software to TWSI Register  *  * This register allows software to  *    - initiate TWSI interface master-mode operations with a write and read the result with a read  *    - load four bytes for later retrieval (slave mode) with a write and check validity with a read  *    - launch a TWSI controller configuration read/write with a write and read the result with a read  *  * This register should be read or written by software, and read by the TWSI device. The TWSI device can  * use either two-byte or five-byte reads to reference this register.  *  * The TWSI device considers this register valid when V==1 and SLONLY==1.  */
end_comment

begin_union
union|union
name|cvmx_mio_twsx_sw_twsi
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_twsx_sw_twsi_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|v
range|:
literal|1
decl_stmt|;
comment|/**< Valid bit                                                          - Set on a write (should always be written with                                                            a 1)                                                          - Cleared when a TWSI master mode op completes                                                          - Cleared when a TWSI configuration register                                                            access completes                                                          - Cleared when the TWSI device reads the                                                            register if SLONLY==1 */
name|uint64_t
name|slonly
range|:
literal|1
decl_stmt|;
comment|/**< Slave Only Mode                                                          - No operation is initiated with a write when                                                            this bit is set - only D field is updated in                                                            this case                                                          - When clear, a write initiates either a TWSI                                                            master-mode operation or a TWSI configuration                                                            register access */
name|uint64_t
name|eia
range|:
literal|1
decl_stmt|;
comment|/**< Extended Internal Address - send additional                                                          internal address byte (MSB of IA is from IA field                                                          of MIO_TWS_SW_TWSI_EXT) */
name|uint64_t
name|op
range|:
literal|4
decl_stmt|;
comment|/**< Opcode field - When the register is written with                                                          SLONLY==0, initiate a read or write:                                                            0000 => 7-bit Byte Master Mode TWSI Op                                                            0001 => 7-bit Byte Combined Read Master Mode Op                                                                    7-bit Byte Write w/ IA Master Mode Op                                                            0010 => 10-bit Byte Master Mode TWSI Op                                                            0011 => 10-bit Byte Combined Read Master Mode Op                                                                    10-bit Byte Write w/ IA Master Mode Op                                                            0100 => TWSI Master Clock Register                                                            0110 => See EOP field                                                            1000 => 7-bit 4-byte Master Mode TWSI Op                                                            1001 => 7-bit 4-byte Comb. Read Master Mode Op                                                                    7-bit 4-byte Write w/ IA Master Mode Op                                                            1010 => 10-bit 4-byte Master Mode TWSI Op                                                            1011 => 10-bit 4-byte Comb. Read Master Mode Op                                                                    10-bit 4-byte Write w/ IA Master Mode Op */
name|uint64_t
name|r
range|:
literal|1
decl_stmt|;
comment|/**< Read bit or result                                                          - If set on a write when SLONLY==0, the                                                            operation is a read                                                          - On a read, this bit returns the result                                                            indication for the most recent master mode                                                            operation (1 = success, 0 = fail) */
name|uint64_t
name|sovr
range|:
literal|1
decl_stmt|;
comment|/**< Size Override - if set, use the SIZE field to                                                          determine Master Mode Op size rather than what                                                          the Opcode field specifies.  For operations                                                          greater than 4 bytes, the additional data will be                                                          contained in the D field of MIO_TWS_SW_TWSI_EXT */
name|uint64_t
name|size
range|:
literal|3
decl_stmt|;
comment|/**< Size in bytes of Master Mode Op if the Size                                                          Override bit is set.  Specified in -1 notation                                                          (i.e. 0 = 1 byte, 1 = 2 bytes ... 7 = 8 bytes) */
name|uint64_t
name|scr
range|:
literal|2
decl_stmt|;
comment|/**< Scratch - unused, but retain state */
name|uint64_t
name|a
range|:
literal|10
decl_stmt|;
comment|/**< Address field                                                           - the address of the remote device for a master                                                             mode operation                                                           - A<9:7> are only used for 10-bit addressing                                                          Note that when mastering a 7-bit OP, A<6:0> should                                                          not take any of the values 0x78, 0x79, 0x7A nor                                                          0x7B (these 7-bit addresses are reserved to                                                          extend to 10-bit addressing). */
name|uint64_t
name|ia
range|:
literal|5
decl_stmt|;
comment|/**< Internal Address - Used when launching a master                                                          mode combined read / write with internal address                                                          (lower 3 bits are contained in the EOP_IA field) */
name|uint64_t
name|eop_ia
range|:
literal|3
decl_stmt|;
comment|/**< Extra opcode (when OP<3:0> == 0110 and SLONLY==0):                                                            000 => TWSI Slave Address Register                                                            001 => TWSI Data Register                                                            010 => TWSI Control Register                                                            011 => TWSI Clock Control Register (when R == 0)                                                            011 => TWSI Status Register (when R == 1)                                                            100 => TWSI Extended Slave Register                                                            111 => TWSI Soft Reset Register                                                          Also the lower 3 bits of Internal Address when                                                            launching a master mode combined read / write                                                            with internal address */
name|uint64_t
name|d
range|:
literal|32
decl_stmt|;
comment|/**< Data Field                                                          Used on a write when                                                            - initiating a master-mode write (SLONLY==0)                                                            - writing a TWSI config register (SLONLY==0)                                                            - a slave mode write (SLONLY==1)                                                          The read value is updated by                                                            - a write to this register                                                            - master mode completion (contains result or                                                              error code)                                                            - TWSI config register read (contains result) */
else|#
directive|else
name|uint64_t
name|d
range|:
literal|32
decl_stmt|;
name|uint64_t
name|eop_ia
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ia
range|:
literal|5
decl_stmt|;
name|uint64_t
name|a
range|:
literal|10
decl_stmt|;
name|uint64_t
name|scr
range|:
literal|2
decl_stmt|;
name|uint64_t
name|size
range|:
literal|3
decl_stmt|;
name|uint64_t
name|sovr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|r
range|:
literal|1
decl_stmt|;
name|uint64_t
name|op
range|:
literal|4
decl_stmt|;
name|uint64_t
name|eia
range|:
literal|1
decl_stmt|;
name|uint64_t
name|slonly
range|:
literal|1
decl_stmt|;
name|uint64_t
name|v
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_twsx_sw_twsi
name|cvmx_mio_twsx_sw_twsi_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_tws#_sw_twsi_ext  *  * MIO_TWSX_SW_TWSI_EXT = TWSX Software to TWSI Extension Register  *  * This register contains an additional byte of internal address and 4 additional bytes of data to be  * used with TWSI master mode operations.  IA will be sent as the first byte of internal address when  * performing master mode combined read / write with internal address operations and the EIA bit of  * MIO_TWS_SW_TWSI is set.  D extends the data field of MIO_TWS_SW_TWSI for a total of 8 bytes (SOVR  * must be set to perform operations greater than 4 bytes).  */
end_comment

begin_union
union|union
name|cvmx_mio_twsx_sw_twsi_ext
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
name|uint64_t
name|ia
range|:
literal|8
decl_stmt|;
comment|/**< Extended Internal Address */
name|uint64_t
name|d
range|:
literal|32
decl_stmt|;
comment|/**< Extended Data Field */
else|#
directive|else
name|uint64_t
name|d
range|:
literal|32
decl_stmt|;
name|uint64_t
name|ia
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_40_63
range|:
literal|24
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_sw_twsi_ext_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_twsx_sw_twsi_ext
name|cvmx_mio_twsx_sw_twsi_ext_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_tws#_twsi_sw  *  * MIO_TWSX_TWSI_SW = TWSX TWSI to Software Register  *  * This register allows the TWSI device to transfer data to software and later check that software has  * received the information.  *  * This register should be read or written by the TWSI device, and read by software. The TWSI device can  * use one-byte or four-byte payload writes, and two-byte payload reads.  *  * The TWSI device considers this register valid when V==1.  */
end_comment

begin_union
union|union
name|cvmx_mio_twsx_twsi_sw
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_twsx_twsi_sw_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|v
range|:
literal|2
decl_stmt|;
comment|/**< Valid Bits                                                          - Not directly writable                                                          - Set to 1 on any write by the TWSI device                                                          - Cleared on any read by software */
name|uint64_t
name|reserved_32_61
range|:
literal|30
decl_stmt|;
name|uint64_t
name|d
range|:
literal|32
decl_stmt|;
comment|/**< Data Field - updated on a write by the TWSI device */
else|#
directive|else
name|uint64_t
name|d
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_61
range|:
literal|30
decl_stmt|;
name|uint64_t
name|v
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_twsx_twsi_sw_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_twsx_twsi_sw
name|cvmx_mio_twsx_twsi_sw_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_dlh  *  * MIO_UARTX_DLH = MIO UARTX Divisor Latch High Register  *  * The DLH (Divisor Latch High) register in conjunction with DLL (Divisor Latch Low) register form a  * 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. It is  * accessed by first setting the DLAB bit (bit 7) in the Line Control Register (LCR). The output baud  * rate is equal to eclk frequency divided by sixteen times the value of the baud rate divisor, as  * follows: baud rate = eclk / (16 * divisor).  *  * Note that the BUSY bit (bit 0) of the UART Status Register (USR) must be clear before writing this  * register. BUSY bit is always clear in PASS3.  *  * Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled  * and no serial communications will occur. Also, once the DLL or DLH is set, at least 8 clock cycles  * of eclk should be allowed to pass before transmitting or receiving data.  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * IER and DLH registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_dlh
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_dlh_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dlh
range|:
literal|8
decl_stmt|;
comment|/**< Divisor Latch High Register */
else|#
directive|else
name|uint64_t
name|dlh
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dlh_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_dlh
name|cvmx_mio_uartx_dlh_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_dlh_t
name|cvmx_uart_dlh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_dll  *  * MIO_UARTX_DLL = MIO UARTX Divisor Latch Low Register  *  * The DLH (Divisor Latch High) register in conjunction with DLL (Divisor Latch Low) register form a  * 16-bit, read/write, Divisor Latch register that contains the baud rate divisor for the UART. It is  * accessed by first setting the DLAB bit (bit 7) in the Line Control Register (LCR). The output baud  * rate is equal to eclk frequency divided by sixteen times the value of the baud rate divisor, as  * follows: baud rate = eclk / (16 * divisor).  *  * Note that the BUSY bit (bit 0) of the UART Status Register (USR) must be clear before writing this  * register. BUSY bit is always clear in PASS3.  *  * Note that with the Divisor Latch Registers (DLL and DLH) set to zero, the baud clock is disabled  * and no serial communications will occur. Also, once the DLL or DLH is set, at least 8 clock cycles  * of eclk should be allowed to pass before transmitting or receiving data.  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * RBR, THR, and DLL registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_dll
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_dll_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dll
range|:
literal|8
decl_stmt|;
comment|/**< Divisor Latch Low Register */
else|#
directive|else
name|uint64_t
name|dll
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_dll_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_dll
name|cvmx_mio_uartx_dll_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_dll_t
name|cvmx_uart_dll_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_far  *  * MIO_UARTX_FAR = MIO UARTX FIFO Access Register  *  * The FIFO Access Register (FAR) is used to enable a FIFO access mode for testing, so that the receive  * FIFO can be written by software and the transmit FIFO can be read by software when the FIFOs are  * enabled. When FIFOs are not enabled it allows the RBR to be written by software and the THR to be read  * by software. Note, that when the FIFO access mode is enabled/disabled, the control portion of the  * receive FIFO and transmit FIFO is reset and the FIFOs are treated as empty.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_far
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_far_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|far
range|:
literal|1
decl_stmt|;
comment|/**< FIFO Access Register */
else|#
directive|else
name|uint64_t
name|far
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_far_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_far
name|cvmx_mio_uartx_far_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_far_t
name|cvmx_uart_far_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_fcr  *  * MIO_UARTX_FCR = MIO UARTX FIFO Control Register  *  * The FIFO Control Register (FCR) is a write-only register that controls the read and write data FIFO  * operation. When FIFOs and Programmable THRE Interrupt mode are enabled, this register also controls  * the THRE Interrupt empty threshold level.  *  * Setting bit 0 of the FCR enables the transmit and receive FIFOs. Whenever the value of this bit is  * changed both the TX and RX FIFOs will be reset.  *  * Writing a '1' to bit 1 of the FCR resets and flushes data in the receive FIFO. Note that this bit is  * self-clearing and it is not necessary to clear this bit.  *  * Writing a '1' to bit 2 of the FCR resets and flushes data in the transmit FIFO. Note that this bit is  * self-clearing and it is not necessary to clear this bit.  *  * If the FIFOs and Programmable THRE Interrupt mode are enabled, bits 4 and 5 control the empty  * threshold level at which THRE Interrupts are generated when the mode is active.  See the following  * table for encodings:  *  * TX Trigger  * ----------  * 00 = empty FIFO  * 01 = 2 chars in FIFO  * 10 = FIFO 1/4 full  * 11 = FIFO 1/2 full  *  * If the FIFO mode is enabled (bit 0 of the FCR is set to '1') bits 6 and 7 are active. Bit 6 and bit 7  * set the trigger level in the receiver FIFO for the Enable Received Data Available Interrupt (ERBFI).  * In auto flow control mode the trigger is used to determine when the rts_n signal will be deasserted.  * See the following table for encodings:  *  * RX Trigger  * ----------  * 00 = 1 char in FIFO  * 01 = FIFO 1/4 full  * 10 = FIFO 1/2 full  * 11 = FIFO 2 chars less than full  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * IIR and FCR registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_fcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_fcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rxtrig
range|:
literal|2
decl_stmt|;
comment|/**< RX Trigger */
name|uint64_t
name|txtrig
range|:
literal|2
decl_stmt|;
comment|/**< TX Trigger */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfr
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO reset */
name|uint64_t
name|rxfr
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO reset */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< FIFO enable */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txtrig
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rxtrig
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_fcr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_fcr
name|cvmx_mio_uartx_fcr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_fcr_t
name|cvmx_uart_fcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_htx  *  * MIO_UARTX_HTX = MIO UARTX Halt TX Register  *  * The Halt TX Register (HTX) is used to halt transmissions for testing, so that the transmit FIFO can be  * filled by software when FIFOs are enabled. If FIFOs are not enabled, setting the HTX register will  * have no effect.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_htx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_htx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|htx
range|:
literal|1
decl_stmt|;
comment|/**< Halt TX */
else|#
directive|else
name|uint64_t
name|htx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_htx_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_htx
name|cvmx_mio_uartx_htx_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_htx_t
name|cvmx_uart_htx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_ier  *  * MIO_UARTX_IER = MIO UARTX Interrupt Enable Register  *  * Interrupt Enable Register (IER) is a read/write register that contains four bits that enable  * the generation of interrupts. These four bits are the Enable Received Data Available Interrupt  * (ERBFI), the Enable Transmitter Holding Register Empty Interrupt (ETBEI), the Enable Receiver Line  * Status Interrupt (ELSI), and the Enable Modem Status Interrupt (EDSSI).  *  * The IER also contains an enable bit (PTIME) for the Programmable THRE Interrupt mode.  *  * Note: The Divisor Latch Address Bit (DLAB) of the Line Control Register (LCR) must be clear to access  * this register.  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * IER and DLH registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_ier
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_ier_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Programmable THRE Interrupt mode enable */
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|edssi
range|:
literal|1
decl_stmt|;
comment|/**< Enable Modem Status Interrupt */
name|uint64_t
name|elsi
range|:
literal|1
decl_stmt|;
comment|/**< Enable Receiver Line Status Interrupt */
name|uint64_t
name|etbei
range|:
literal|1
decl_stmt|;
comment|/**< Enable Transmitter Holding Register Empty Interrupt */
name|uint64_t
name|erbfi
range|:
literal|1
decl_stmt|;
comment|/**< Enable Received Data Available Interrupt */
else|#
directive|else
name|uint64_t
name|erbfi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|etbei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|elsi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|edssi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_ier_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_ier
name|cvmx_mio_uartx_ier_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_ier_t
name|cvmx_uart_ier_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_iir  *  * MIO_UARTX_IIR = MIO UARTX Interrupt Identity Register  *  * The Interrupt Identity Register (IIR) is a read-only register that identifies the source of an  * interrupt. The upper two bits of the register are FIFO-enabled bits. These bits are '00' if the FIFOs  * are disabled, and '11' if they are enabled. The lower four bits identify the highest priority pending  * interrupt. The following table defines interrupt source decoding, interrupt priority, and interrupt  * reset control:  *  * Interrupt   Priority   Interrupt         Interrupt                                       Interrupt  * ID          Level      Type              Source                                          Reset By  * ---------------------------------------------------------------------------------------------------------------------------------  * 0001        -          None              None                                            -  *  * 0110        Highest    Receiver Line     Overrun, parity, or framing errors or break     Reading the Line Status Register  *                        Status            interrupt  *  * 0100        Second     Received Data     Receiver data available (FIFOs disabled) or     Reading the Receiver Buffer Register  *                        Available         RX FIFO trigger level reached (FIFOs            (FIFOs disabled) or the FIFO drops below  *                                          enabled)                                        the trigger level (FIFOs enabled)  *  * 1100        Second     Character         No characters in or out of the RX FIFO          Reading the Receiver Buffer Register  *                        Timeout           during the last 4 character times and there  *                        Indication        is at least 1 character in it during this  *                                          time  *  * 0010        Third      Transmitter       Transmitter Holding Register Empty              Reading the Interrupt Identity Register  *                        Holding           (Programmable THRE Mode disabled) or TX         (if source of interrupt) or writing into  *                        Register          FIFO at or below threshold (Programmable        THR (FIFOs or THRE Mode disabled) or TX  *                        Empty             THRE Mode enabled)                              FIFO above threshold (FIFOs and THRE  *                                                                                          Mode enabled)  *  * 0000        Fourth     Modem Status      Clear To Send (CTS) or Data Set Ready (DSR)     Reading the Modem Status Register  *                        Changed           or Ring Indicator (RI) or Data Carrier  *                                          Detect (DCD) changed (note: if auto flow  *                                          control mode is enabled, a change in CTS  *                                          will not cause an interrupt)  *  * 0111        Fifth      Busy Detect       Software has tried to write to the Line         Reading the UART Status Register  *                        Indication        Control Register while the BUSY bit of the  *                                          UART Status Register was set  *  * Note: The Busy Detect Indication interrupt has been removed from PASS3 and will never assert.  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * IIR and FCR registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_iir
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_iir_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|fen
range|:
literal|2
decl_stmt|;
comment|/**< FIFO-enabled bits */
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|cvmx_uart_iid_t
name|iid
range|:
literal|4
decl_stmt|;
comment|/**< Interrupt ID */
else|#
directive|else
name|cvmx_uart_iid_t
name|iid
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fen
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_iir_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_iir
name|cvmx_mio_uartx_iir_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_iir_t
name|cvmx_uart_iir_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_lcr  *  * MIO_UARTX_LCR = MIO UARTX Line Control Register  *  * The Line Control Register (LCR) controls the format of the data that is transmitted and received by  * the UART.  *  * LCR bits 0 and 1 are the Character Length Select field. This field is used to select the number of  * data bits per character that are transmitted and received. See the following table for encodings:  *  * CLS  * ---  * 00 = 5 bits (bits 0-4 sent)  * 01 = 6 bits (bits 0-5 sent)  * 10 = 7 bits (bits 0-6 sent)  * 11 = 8 bits (all bits sent)  *  * LCR bit 2 controls the number of stop bits transmitted. If bit 2 is a '0', one stop bit is transmitted  * in the serial data. If bit 2 is a '1' and the data bits are set to '00', one and a half stop bits are  * generated. Otherwise, two stop bits are generated and transmitted in the serial data out. Note that  * regardless of the number of stop bits selected the receiver will only check the first stop bit.  *  * LCR bit 3 is the Parity Enable bit. This bit is used to enable and disable parity generation and  * detection in transmitted and received serial character respectively.  *  * LCR bit 4 is the Even Parity Select bit. If parity is enabled, bit 4 selects between even and odd  * parity. If bit 4 is a '1', an even number of ones is transmitted or checked. If bit 4 is a '0', an odd  * number of ones is transmitted or checked.  *  * LCR bit 6 is the Break Control bit. Setting the Break bit sends a break signal by holding the sout  * line low (when not in Loopback mode, as determined by Modem Control Register bit 4). When in Loopback  * mode, the break condition is internally looped back to the receiver.  *  * LCR bit 7 is the Divisor Latch Address bit. Setting this bit enables reading and writing of the  * Divisor Latch register (DLL and DLH) to set the baud rate of the UART. This bit must be cleared after  * initial baud rate setup in order to access other registers.  *  * Note: The LCR is writeable only when the UART is not busy (when the BUSY bit (bit 0) of the UART  * Status Register (USR) is clear). The LCR is always readable. In PASS3, the LCR is always writable  * because the BUSY bit is always clear.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_lcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_lcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dlab
range|:
literal|1
decl_stmt|;
comment|/**< Divisor Latch Address bit */
name|uint64_t
name|brk
range|:
literal|1
decl_stmt|;
comment|/**< Break Control bit */
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|eps
range|:
literal|1
decl_stmt|;
comment|/**< Even Parity Select bit */
name|uint64_t
name|pen
range|:
literal|1
decl_stmt|;
comment|/**< Parity Enable bit */
name|uint64_t
name|stop
range|:
literal|1
decl_stmt|;
comment|/**< Stop Control bit */
name|cvmx_uart_bits_t
name|cls
range|:
literal|2
decl_stmt|;
comment|/**< Character Length Select */
else|#
directive|else
name|cvmx_uart_bits_t
name|cls
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|eps
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlab
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lcr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_lcr
name|cvmx_mio_uartx_lcr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_lcr_t
name|cvmx_uart_lcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_lsr  *  * MIO_UARTX_LSR = MIO UARTX Line Status Register  *  * The Line Status Register (LSR) contains status of the receiver and transmitter data transfers. This  * status can be read by the user at anytime.  *  * LSR bit 0 is the Data Ready (DR) bit. When set, this bit indicates the receiver contains at least one  * character in the RBR or the receiver FIFO. This bit is cleared when the RBR is read in the non-FIFO  * mode, or when the receiver FIFO is empty, in FIFO mode.  *  * LSR bit 1 is the Overrun Error (OE) bit. When set, this bit indicates an overrun error has occurred  * because a new data character was received before the previous data was read. In the non-FIFO mode, the  * OE bit is set when a new character arrives in the receiver before the previous character was read from  * the RBR. When this happens, the data in the RBR is overwritten. In the FIFO mode, an overrun error  * occurs when the FIFO is full and a new character arrives at the receiver. The data in the FIFO is  * retained and the data in the receive shift register is lost.  *  * LSR bit 2 is the Parity Error (PE) bit. This bit is set whenever there is a parity error in the  * receiver if the Parity Enable (PEN) bit in the LCR is set. In the FIFO mode, since the parity error is  * associated with a character received, it is revealed when the character with the parity error arrives  * at the top of the FIFO. It should be noted that the Parity Error (PE) bit will be set if a break  * interrupt has occurred, as indicated by the Break Interrupt (BI) bit.  *  * LSR bit 3 is the Framing Error (FE) bit. This bit is set whenever there is a framing error in the  * receiver. A framing error occurs when the receiver does not detect a valid STOP bit in the received  * data. In the FIFO mode, since the framing error is associated with a character received, it is  * revealed when the character with the framing error is at the top of the FIFO. When a framing error  * occurs the UART will try resynchronize. It does this by assuming that the error was due to the start  * bit of the next character and then continues receiving the other bits (i.e. data and/or parity and  * stop). It should be noted that the Framing Error (FE) bit will be set if a break interrupt has  * occurred, as indicated by the Break Interrupt (BI) bit.  *  * Note: The OE, PE, and FE bits are reset when a read of the LSR is performed.  *  * LSR bit 4 is the Break Interrupt (BI) bit. This bit is set whenever the serial input (sin) is held in  * a 0 state for longer than the sum of start time + data bits + parity + stop bits. A break condition on  * sin causes one and only one character, consisting of all zeros, to be received by the UART. In the  * FIFO mode, the character associated with the break condition is carried through the FIFO and is  * revealed when the character is at the top of the FIFO. Reading the LSR clears the BI bit. In the non-  * FIFO mode, the BI indication occurs immediately and persists until the LSR is read.  *  * LSR bit 5 is the Transmitter Holding Register Empty (THRE) bit. When Programmable THRE Interrupt mode  * is disabled, this bit indicates that the UART can accept a new character for transmission. This bit is  * set whenever data is transferred from the THR (or TX FIFO) to the transmitter shift register and no  * new data has been written to the THR (or TX FIFO). This also causes a THRE Interrupt to occur, if the  * THRE Interrupt is enabled. When FIFOs and Programmable THRE Interrupt mode are enabled, LSR bit 5  * functionality is switched to indicate the transmitter FIFO is full, and no longer controls THRE  * Interrupts, which are then controlled by the FCR[5:4] threshold setting.  *  * LSR bit 6 is the Transmitter Empty (TEMT) bit. In the FIFO mode, this bit is set whenever the  * Transmitter Shift Register and the FIFO are both empty. In the non-FIFO mode, this bit is set whenever  * the Transmitter Holding Register and the Transmitter Shift Register are both empty. This bit is  * typically used to make sure it is safe to change control registers. Changing control registers while  * the transmitter is busy can result in corrupt data being transmitted.  *  * LSR bit 7 is the Error in Receiver FIFO (FERR) bit. This bit is active only when FIFOs are enabled. It  * is set when there is at least one parity error, framing error, or break indication in the FIFO. This  * bit is cleared when the LSR is read and the character with the error is at the top of the receiver  * FIFO and there are no subsequent errors in the FIFO.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_lsr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_lsr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ferr
range|:
literal|1
decl_stmt|;
comment|/**< Error in Receiver FIFO bit */
name|uint64_t
name|temt
range|:
literal|1
decl_stmt|;
comment|/**< Transmitter Empty bit */
name|uint64_t
name|thre
range|:
literal|1
decl_stmt|;
comment|/**< Transmitter Holding Register Empty bit */
name|uint64_t
name|bi
range|:
literal|1
decl_stmt|;
comment|/**< Break Interrupt bit */
name|uint64_t
name|fe
range|:
literal|1
decl_stmt|;
comment|/**< Framing Error bit */
name|uint64_t
name|pe
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error bit */
name|uint64_t
name|oe
range|:
literal|1
decl_stmt|;
comment|/**< Overrun Error bit */
name|uint64_t
name|dr
range|:
literal|1
decl_stmt|;
comment|/**< Data Ready bit */
else|#
directive|else
name|uint64_t
name|dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|thre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|temt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ferr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_lsr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_lsr
name|cvmx_mio_uartx_lsr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_lsr_t
name|cvmx_uart_lsr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_mcr  *  * MIO_UARTX_MCR = MIO UARTX Modem Control Register  *  * The lower four bits of the Modem Control Register (MCR) directly manipulate the outputs of the UART.  * The DTR (bit 0), RTS (bit 1), OUT1 (bit 2), and OUT2 (bit 3) bits are inverted and then drive the  * corresponding UART outputs, dtr_n, rts_n, out1_n, and out2_n.  In loopback mode, these outputs are  * driven inactive high while the values in these locations are internally looped back to the inputs.  *  * Note: When Auto RTS is enabled, the rts_n output is controlled in the same way, but is also gated  * with the receiver FIFO threshold trigger (rts_n is inactive high when above the threshold). The  * rts_n output will be de-asserted whenever RTS (bit 1) is set low.  *  * Note: The UART0 out1_n and out2_n outputs are not present on the pins of the chip, but the UART0 OUT1  * and OUT2 bits still function in Loopback mode.  The UART1 dtr_n, out1_n, and out2_n outputs are not  * present on the pins of the chip, but the UART1 DTR, OUT1, and OUT2 bits still function in Loopback  * mode.  *  * MCR bit 4 is the Loopback bit. When set, data on the sout line is held high, while serial data output  * is looped back to the sin line, internally. In this mode all the interrupts are fully functional. This  * feature is used for diagnostic purposes. Also, in loopback mode, the modem control inputs (dsr_n,  * cts_n, ri_n, dcd_n) are disconnected and the four modem control outputs (dtr_n, rts_n, out1_n, out1_n)  * are looped back to the inputs, internally.  *  * MCR bit 5 is the Auto Flow Control Enable (AFCE) bit. When FIFOs are enabled and this bit is set,  * 16750-compatible Auto RTS and Auto CTS serial data flow control features are enabled.  *  * Auto RTS becomes active when the following occurs:  * 1. MCR bit 1 is set  * 2. FIFOs are enabled by setting FIFO Control Register (FCR) bit 0  * 3. MCR bit 5 is set (must be set after FCR bit 0)  *  * When active, the rts_n output is forced inactive-high when the receiver FIFO level reaches the  * threshold set by FCR[7:6]. When rts_n is connected to the cts_n input of another UART device, the  * other UART stops sending serial data until the receiver FIFO has available space.  *  * The selectable receiver FIFO threshold values are: 1, 1/4, 1/2, and 2 less than full. Since one  * additional character may be transmitted to the UART after rts_n has become inactive (due to data  * already having entered the transmitter block in the other UART), setting the threshold to 2 less  * than full allows maximum use of the FIFO with a safety zone of one character.  *  * Once the receiver FIFO becomes completely empty by reading the Receiver Buffer Register (RBR), rts_n  * again becomes active-low, signalling the other UART to continue sending data. It is important to note  * that, even if everything else is set to Enabled and the correct MCR bits are set, if the FIFOs are  * disabled through FCR[0], Auto Flow Control is also disabled. When Auto RTS is disabled or inactive,  * rts_n is controlled solely by MCR[1].  *  * Auto CTS becomes active when the following occurs:  * 1. FIFOs are enabled by setting FIFO Control Register (FCR) bit 0  * 2. MCR bit 5 is set (must be set after FCR bit 0)  *  * When active, the UART transmitter is disabled whenever the cts_n input becomes inactive-high. This  * prevents overflowing the FIFO of the receiving UART.  *  * Note that, if the cts_n input is not inactivated before the middle of the last stop bit, another  * character is transmitted before the transmitter is disabled. While the transmitter is disabled, the  * transmitter FIFO can still be written to, and even overflowed. Therefore, when using this mode, either  * the true FIFO depth (64 characters) must be known to software, or the Programmable THRE Interrupt mode  * must be enabled to access the FIFO full status through the Line Status Register. When using the FIFO  * full status, software can poll this before each write to the Transmitter FIFO.  *  * Note: FIFO full status is also available in the UART Status Register (USR) or the actual level of the  * FIFO may be read through the Transmit FIFO Level (TFL) register.  *  * When the cts_n input becomes active-low again, transmission resumes. It is important to note that,  * even if everything else is set to Enabled, Auto Flow Control is also disabled if the FIFOs are  * disabled through FCR[0]. When Auto CTS is disabled or inactive, the transmitter is unaffected by  * cts_n.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_mcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_mcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|afce
range|:
literal|1
decl_stmt|;
comment|/**< Auto Flow Control Enable bit */
name|uint64_t
name|loop
range|:
literal|1
decl_stmt|;
comment|/**< Loopback bit */
name|uint64_t
name|out2
range|:
literal|1
decl_stmt|;
comment|/**< OUT2 output bit */
name|uint64_t
name|out1
range|:
literal|1
decl_stmt|;
comment|/**< OUT1 output bit */
name|uint64_t
name|rts
range|:
literal|1
decl_stmt|;
comment|/**< Request To Send output bit */
name|uint64_t
name|dtr
range|:
literal|1
decl_stmt|;
comment|/**< Data Terminal Ready output bit */
else|#
directive|else
name|uint64_t
name|dtr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|afce
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_mcr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_mcr
name|cvmx_mio_uartx_mcr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_mcr_t
name|cvmx_uart_mcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_msr  *  * MIO_UARTX_MSR = MIO UARTX Modem Status Register  *  * The Modem Status Register (MSR) contains the current status of the modem control input lines and if  * they changed.  *  * DCTS (bit 0), DDSR (bit 1), and DDCD (bit 3) bits record whether the modem control lines (cts_n,  * dsr_n, and dcd_n) have changed since the last time the user read the MSR. TERI (bit 2) indicates ri_n  * has changed from an active-low, to an inactive-high state since the last time the MSR was read. In  * Loopback mode, DCTS reflects changes on MCR bit 1 (RTS), DDSR reflects changes on MCR bit 0 (DTR), and  * DDCD reflects changes on MCR bit 3 (Out2), while TERI reflects when MCR bit 2 (Out1) has changed state  * from a high to a low.  *  * Note: if the DCTS bit is not set and the cts_n signal is asserted (low) and a reset occurs (software  * or otherwise), then the DCTS bit will get set when the reset is removed if the cts_n signal remains  * asserted.  *  * The CTS, DSR, RI, and DCD Modem Status bits contain information on the current state of the modem  * control lines. CTS (bit 4) is the compliment of cts_n, DSR (bit 5) is the compliment of dsr_n, RI  * (bit 6) is the compliment of ri_n, and DCD (bit 7) is the compliment of dcd_n. In Loopback mode, CTS  * is the same as MCR bit 1 (RTS), DSR is the same as MCR bit 0 (DTR), RI is the same as MCR bit 2  * (Out1), and DCD is the same as MCR bit 3 (Out2).  *  * Note: The UART0 dsr_n and ri_n inputs are internally tied to power and not present on the pins of chip.  * Thus the UART0 DSR and RI bits will be '0' when not in Loopback mode.  The UART1 dsr_n, ri_n, and dcd_n  * inputs are internally tied to power and not present on the pins of chip. Thus the UART1 DSR, RI, and  * DCD bits will be '0' when not in Loopback mode.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_msr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_msr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dcd
range|:
literal|1
decl_stmt|;
comment|/**< Data Carrier Detect input bit */
name|uint64_t
name|ri
range|:
literal|1
decl_stmt|;
comment|/**< Ring Indicator input bit */
name|uint64_t
name|dsr
range|:
literal|1
decl_stmt|;
comment|/**< Data Set Ready input bit */
name|uint64_t
name|cts
range|:
literal|1
decl_stmt|;
comment|/**< Clear To Send input bit */
name|uint64_t
name|ddcd
range|:
literal|1
decl_stmt|;
comment|/**< Delta Data Carrier Detect bit */
name|uint64_t
name|teri
range|:
literal|1
decl_stmt|;
comment|/**< Trailing Edge of Ring Indicator bit */
name|uint64_t
name|ddsr
range|:
literal|1
decl_stmt|;
comment|/**< Delta Data Set Ready bit */
name|uint64_t
name|dcts
range|:
literal|1
decl_stmt|;
comment|/**< Delta Clear To Send bit */
else|#
directive|else
name|uint64_t
name|dcts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|teri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddcd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_msr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_msr
name|cvmx_mio_uartx_msr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_msr_t
name|cvmx_uart_msr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_rbr  *  * MIO_UARTX_RBR = MIO UARTX Receive Buffer Register  *  * The Receive Buffer Register (RBR) is a read-only register that contains the data byte received on the  * serial input port (sin). The data in this register is valid only if the Data Ready (DR) bit in the  * Line status Register (LSR) is set. When the FIFOs are programmed OFF, the data in the RBR must be  * read before the next data arrives, otherwise it is overwritten, resulting in an overrun error. When  * the FIFOs are programmed ON, this register accesses the head of the receive FIFO. If the receive FIFO  * is full (64 characters) and this register is not read before the next data character arrives, then the  * data already in the FIFO is preserved, but any incoming data is lost. An overrun error also occurs.  *  * Note: The Divisor Latch Address Bit (DLAB) of the Line Control Register (LCR) must be clear to access  * this register.  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * RBR, THR, and DLL registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_rbr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_rbr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rbr
range|:
literal|8
decl_stmt|;
comment|/**< Receive Buffer Register */
else|#
directive|else
name|uint64_t
name|rbr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rbr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_rbr
name|cvmx_mio_uartx_rbr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_rbr_t
name|cvmx_uart_rbr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_rfl  *  * MIO_UARTX_RFL = MIO UARTX Receive FIFO Level Register  *  * The Receive FIFO Level Register (RFL) indicates the number of data entries in the receive FIFO.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_rfl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_rfl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|rfl
range|:
literal|7
decl_stmt|;
comment|/**< Receive FIFO Level Register */
else|#
directive|else
name|uint64_t
name|rfl
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_rfl
name|cvmx_mio_uartx_rfl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_rfl_t
name|cvmx_uart_rfl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_rfw  *  * MIO_UARTX_RFW = MIO UARTX Receive FIFO Write Register  *  * The Receive FIFO Write Register (RFW) is only valid when FIFO access mode is enabled (FAR bit 0 is  * set). When FIFOs are enabled, this register is used to write data to the receive FIFO. Each  * consecutive write pushes the new data to the next write location in the receive FIFO. When FIFOs are  * not enabled, this register is used to write data to the RBR.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_rfw
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_rfw_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|rffe
range|:
literal|1
decl_stmt|;
comment|/**< Receive FIFO Framing Error */
name|uint64_t
name|rfpe
range|:
literal|1
decl_stmt|;
comment|/**< Receive FIFO Parity Error */
name|uint64_t
name|rfwd
range|:
literal|8
decl_stmt|;
comment|/**< Receive FIFO Write Data */
else|#
directive|else
name|uint64_t
name|rfwd
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rfpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rffe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_rfw_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_rfw
name|cvmx_mio_uartx_rfw_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_rfw_t
name|cvmx_uart_rfw_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_sbcr  *  * MIO_UARTX_SBCR = MIO UARTX Shadow Break Control Register  *  * The Shadow Break Control Register (SBCR) is a shadow register for the BREAK bit (LCR bit 6) that can  * be used to remove the burden of having to perform a read-modify-write on the LCR.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_sbcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_sbcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|sbcr
range|:
literal|1
decl_stmt|;
comment|/**< Shadow Break Control */
else|#
directive|else
name|uint64_t
name|sbcr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sbcr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_sbcr
name|cvmx_mio_uartx_sbcr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_sbcr_t
name|cvmx_uart_sbcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_scr  *  * MIO_UARTX_SCR = MIO UARTX Scratchpad Register  *  * The Scratchpad Register (SCR) is an 8-bit read/write register for programmers to use as a temporary  * storage space.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_scr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_scr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|scr
range|:
literal|8
decl_stmt|;
comment|/**< Scratchpad Register */
else|#
directive|else
name|uint64_t
name|scr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_scr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_scr
name|cvmx_mio_uartx_scr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_scr_t
name|cvmx_uart_scr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_sfe  *  * MIO_UARTX_SFE = MIO UARTX Shadow FIFO Enable Register  *  * The Shadow FIFO Enable Register (SFE) is a shadow register for the FIFO enable bit (FCR bit 0) that  * can be used to remove the burden of having to store the previously written value to the FCR in memory  * and having to mask this value so that only the FIFO enable bit gets updated.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_sfe
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_sfe_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|sfe
range|:
literal|1
decl_stmt|;
comment|/**< Shadow FIFO Enable */
else|#
directive|else
name|uint64_t
name|sfe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_sfe_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_sfe
name|cvmx_mio_uartx_sfe_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_sfe_t
name|cvmx_uart_sfe_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_srr  *  * MIO_UARTX_SRR = MIO UARTX Software Reset Register  *  * The Software Reset Register (SRR) is a write-only register that resets the UART and/or the receive  * FIFO and/or the transmit FIFO.  *  * Bit 0 of the SRR is the UART Soft Reset (USR) bit.  Setting this bit resets the UART.  *  * Bit 1 of the SRR is a shadow copy of the RX FIFO Reset bit (FCR bit 1). This can be used to remove  * the burden on software having to store previously written FCR values (which are pretty static) just  * to reset the receive FIFO.  *  * Bit 2 of the SRR is a shadow copy of the TX FIFO Reset bit (FCR bit 2). This can be used to remove  * the burden on software having to store previously written FCR values (which are pretty static) just  * to reset the transmit FIFO.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_srr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_srr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|stfr
range|:
literal|1
decl_stmt|;
comment|/**< Shadow TX FIFO Reset */
name|uint64_t
name|srfr
range|:
literal|1
decl_stmt|;
comment|/**< Shadow RX FIFO Reset */
name|uint64_t
name|usr
range|:
literal|1
decl_stmt|;
comment|/**< UART Soft Reset */
else|#
directive|else
name|uint64_t
name|usr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_srr
name|cvmx_mio_uartx_srr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_srr_t
name|cvmx_uart_srr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_srt  *  * MIO_UARTX_SRT = MIO UARTX Shadow RX Trigger Register  *  * The Shadow RX Trigger Register (SRT) is a shadow register for the RX Trigger bits (FCR bits 7:6) that  * can be used to remove the burden of having to store the previously written value to the FCR in memory  * and having to mask this value so that only the RX Trigger bits get updated.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_srt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_srt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|srt
range|:
literal|2
decl_stmt|;
comment|/**< Shadow RX Trigger */
else|#
directive|else
name|uint64_t
name|srt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_srt
name|cvmx_mio_uartx_srt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_srt_t
name|cvmx_uart_srt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_srts  *  * MIO_UARTX_SRTS = MIO UARTX Shadow Request To Send Register  *  * The Shadow Request To Send Register (SRTS) is a shadow register for the RTS bit (MCR bit 1) that can  * be used to remove the burden of having to perform a read-modify-write on the MCR.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_srts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_srts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|srts
range|:
literal|1
decl_stmt|;
comment|/**< Shadow Request To Send */
else|#
directive|else
name|uint64_t
name|srts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_srts_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_srts
name|cvmx_mio_uartx_srts_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_srts_t
name|cvmx_uart_srts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_stt  *  * MIO_UARTX_STT = MIO UARTX Shadow TX Trigger Register  *  * The Shadow TX Trigger Register (STT) is a shadow register for the TX Trigger bits (FCR bits 5:4) that  * can be used to remove the burden of having to store the previously written value to the FCR in memory  * and having to mask this value so that only the TX Trigger bits get updated.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_stt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_stt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|stt
range|:
literal|2
decl_stmt|;
comment|/**< Shadow TX Trigger */
else|#
directive|else
name|uint64_t
name|stt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_stt_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_stt
name|cvmx_mio_uartx_stt_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_stt_t
name|cvmx_uart_stt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_tfl  *  * MIO_UARTX_TFL = MIO UARTX Transmit FIFO Level Register  *  * The Transmit FIFO Level Register (TFL) indicates the number of data entries in the transmit FIFO.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_tfl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_tfl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|tfl
range|:
literal|7
decl_stmt|;
comment|/**< Transmit FIFO Level Register */
else|#
directive|else
name|uint64_t
name|tfl
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfl_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_tfl
name|cvmx_mio_uartx_tfl_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_tfl_t
name|cvmx_uart_tfl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_tfr  *  * MIO_UARTX_TFR = MIO UARTX Transmit FIFO Read Register  *  * The Transmit FIFO Read Register (TFR) is only valid when FIFO access mode is enabled (FAR bit 0 is  * set). When FIFOs are enabled, reading this register gives the data at the top of the transmit FIFO.  * Each consecutive read pops the transmit FIFO and gives the next data value that is currently at the  * top of the FIFO. When FIFOs are not enabled, reading this register gives the data in the THR.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_tfr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_tfr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|tfr
range|:
literal|8
decl_stmt|;
comment|/**< Transmit FIFO Read Register */
else|#
directive|else
name|uint64_t
name|tfr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_tfr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_tfr
name|cvmx_mio_uartx_tfr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_tfr_t
name|cvmx_uart_tfr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_thr  *  * MIO_UARTX_THR = MIO UARTX Transmit Holding Register  *  * Transmit Holding Register (THR) is a write-only register that contains data to be transmitted on the  * serial output port (sout). Data can be written to the THR any time that the THR Empty (THRE) bit of  * the Line Status Register (LSR) is set.  *  * If FIFOs are not enabled and THRE is set, writing a single character to the THR clears the THRE. Any  * additional writes to the THR before the THRE is set again causes the THR data to be overwritten.  *  * If FIFOs are enabled and THRE is set (and Programmable THRE mode disabled), 64 characters of data may  * be written to the THR before the FIFO is full. Any attempt to write data when the FIFO is full results  * in the write data being lost.  *  * Note: The Divisor Latch Address Bit (DLAB) of the Line Control Register (LCR) must be clear to access  * this register.  *  * Note: The address below is an alias to simplify these CSR descriptions. It should be known that the  * RBR, THR, and DLL registers are the same.  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_thr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_thr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|thr
range|:
literal|8
decl_stmt|;
comment|/**< Transmit Holding Register */
else|#
directive|else
name|uint64_t
name|thr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_thr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_thr
name|cvmx_mio_uartx_thr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_thr_t
name|cvmx_uart_thr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart#_usr  *  * MIO_UARTX_USR = MIO UARTX UART Status Register  *  * The UART Status Register (USR) contains UART status information.  *  * USR bit 0 is the BUSY bit.  When set this bit indicates that a serial transfer is in progress, when  * clear it indicates that the UART is idle or inactive.  *  * Note: In PASS3, the BUSY bit will always be clear.  *  * USR bits 1-4 indicate the following FIFO status: TX FIFO Not Full (TFNF), TX FIFO Empty (TFE), RX  * FIFO Not Empty (RFNE), and RX FIFO Full (RFF).  */
end_comment

begin_union
union|union
name|cvmx_mio_uartx_usr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uartx_usr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|rff
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO Full */
name|uint64_t
name|rfne
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO Not Empty */
name|uint64_t
name|tfe
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO Empty */
name|uint64_t
name|tfnf
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO Not Full */
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< Busy bit (always 0 in PASS3) */
else|#
directive|else
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tfnf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tfe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfne
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn56xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn58xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn61xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn63xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn63xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn66xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cn68xxp1
decl_stmt|;
name|struct
name|cvmx_mio_uartx_usr_s
name|cnf71xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uartx_usr
name|cvmx_mio_uartx_usr_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|cvmx_mio_uartx_usr_t
name|cvmx_uart_usr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_dlh  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_dlh
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_dlh_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dlh
range|:
literal|8
decl_stmt|;
comment|/**< Divisor Latch High Register */
else|#
directive|else
name|uint64_t
name|dlh
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_dlh_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_dlh_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_dlh
name|cvmx_mio_uart2_dlh_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_dll  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_dll
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_dll_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dll
range|:
literal|8
decl_stmt|;
comment|/**< Divisor Latch Low Register */
else|#
directive|else
name|uint64_t
name|dll
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_dll_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_dll_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_dll
name|cvmx_mio_uart2_dll_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_far  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_far
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_far_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|far
range|:
literal|1
decl_stmt|;
comment|/**< FIFO Access Register */
else|#
directive|else
name|uint64_t
name|far
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_far_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_far_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_far
name|cvmx_mio_uart2_far_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_fcr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_fcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_fcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rxtrig
range|:
literal|2
decl_stmt|;
comment|/**< RX Trigger */
name|uint64_t
name|txtrig
range|:
literal|2
decl_stmt|;
comment|/**< TX Trigger */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfr
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO reset */
name|uint64_t
name|rxfr
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO reset */
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
comment|/**< FIFO enable */
else|#
directive|else
name|uint64_t
name|en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txtrig
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rxtrig
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_fcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_fcr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_fcr
name|cvmx_mio_uart2_fcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_htx  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_htx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_htx_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|htx
range|:
literal|1
decl_stmt|;
comment|/**< Halt TX */
else|#
directive|else
name|uint64_t
name|htx
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_htx_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_htx_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_htx
name|cvmx_mio_uart2_htx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_ier  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_ier
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_ier_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
comment|/**< Programmable THRE Interrupt mode enable */
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|edssi
range|:
literal|1
decl_stmt|;
comment|/**< Enable Modem Status Interrupt */
name|uint64_t
name|elsi
range|:
literal|1
decl_stmt|;
comment|/**< Enable Receiver Line Status Interrupt */
name|uint64_t
name|etbei
range|:
literal|1
decl_stmt|;
comment|/**< Enable Transmitter Holding Register Empty Interrupt */
name|uint64_t
name|erbfi
range|:
literal|1
decl_stmt|;
comment|/**< Enable Received Data Available Interrupt */
else|#
directive|else
name|uint64_t
name|erbfi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|etbei
range|:
literal|1
decl_stmt|;
name|uint64_t
name|elsi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|edssi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_6
range|:
literal|3
decl_stmt|;
name|uint64_t
name|ptime
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_ier_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_ier_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_ier
name|cvmx_mio_uart2_ier_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_iir  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_iir
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_iir_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|fen
range|:
literal|2
decl_stmt|;
comment|/**< FIFO-enabled bits */
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|iid
range|:
literal|4
decl_stmt|;
comment|/**< Interrupt ID */
else|#
directive|else
name|uint64_t
name|iid
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|fen
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_iir_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_iir_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_iir
name|cvmx_mio_uart2_iir_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_lcr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_lcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_lcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dlab
range|:
literal|1
decl_stmt|;
comment|/**< Divisor Latch Address bit */
name|uint64_t
name|brk
range|:
literal|1
decl_stmt|;
comment|/**< Break Control bit */
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|eps
range|:
literal|1
decl_stmt|;
comment|/**< Even Parity Select bit */
name|uint64_t
name|pen
range|:
literal|1
decl_stmt|;
comment|/**< Parity Enable bit */
name|uint64_t
name|stop
range|:
literal|1
decl_stmt|;
comment|/**< Stop Control bit */
name|uint64_t
name|cls
range|:
literal|2
decl_stmt|;
comment|/**< Character Length Select */
else|#
directive|else
name|uint64_t
name|cls
range|:
literal|2
decl_stmt|;
name|uint64_t
name|stop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pen
range|:
literal|1
decl_stmt|;
name|uint64_t
name|eps
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dlab
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_lcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_lcr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_lcr
name|cvmx_mio_uart2_lcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_lsr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_lsr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_lsr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ferr
range|:
literal|1
decl_stmt|;
comment|/**< Error in Receiver FIFO bit */
name|uint64_t
name|temt
range|:
literal|1
decl_stmt|;
comment|/**< Transmitter Empty bit */
name|uint64_t
name|thre
range|:
literal|1
decl_stmt|;
comment|/**< Transmitter Holding Register Empty bit */
name|uint64_t
name|bi
range|:
literal|1
decl_stmt|;
comment|/**< Break Interrupt bit */
name|uint64_t
name|fe
range|:
literal|1
decl_stmt|;
comment|/**< Framing Error bit */
name|uint64_t
name|pe
range|:
literal|1
decl_stmt|;
comment|/**< Parity Error bit */
name|uint64_t
name|oe
range|:
literal|1
decl_stmt|;
comment|/**< Overrun Error bit */
name|uint64_t
name|dr
range|:
literal|1
decl_stmt|;
comment|/**< Data Ready bit */
else|#
directive|else
name|uint64_t
name|dr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|oe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bi
range|:
literal|1
decl_stmt|;
name|uint64_t
name|thre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|temt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ferr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_lsr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_lsr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_lsr
name|cvmx_mio_uart2_lsr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_mcr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_mcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_mcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|afce
range|:
literal|1
decl_stmt|;
comment|/**< Auto Flow Control Enable bit */
name|uint64_t
name|loop
range|:
literal|1
decl_stmt|;
comment|/**< Loopback bit */
name|uint64_t
name|out2
range|:
literal|1
decl_stmt|;
comment|/**< OUT2 output bit */
name|uint64_t
name|out1
range|:
literal|1
decl_stmt|;
comment|/**< OUT1 output bit */
name|uint64_t
name|rts
range|:
literal|1
decl_stmt|;
comment|/**< Request To Send output bit */
name|uint64_t
name|dtr
range|:
literal|1
decl_stmt|;
comment|/**< Data Terminal Ready output bit */
else|#
directive|else
name|uint64_t
name|dtr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|out2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|loop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|afce
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_mcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_mcr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_mcr
name|cvmx_mio_uart2_mcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_msr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_msr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_msr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|dcd
range|:
literal|1
decl_stmt|;
comment|/**< Data Carrier Detect input bit */
name|uint64_t
name|ri
range|:
literal|1
decl_stmt|;
comment|/**< Ring Indicator input bit */
name|uint64_t
name|dsr
range|:
literal|1
decl_stmt|;
comment|/**< Data Set Ready input bit */
name|uint64_t
name|cts
range|:
literal|1
decl_stmt|;
comment|/**< Clear To Send input bit */
name|uint64_t
name|ddcd
range|:
literal|1
decl_stmt|;
comment|/**< Delta Data Carrier Detect bit */
name|uint64_t
name|teri
range|:
literal|1
decl_stmt|;
comment|/**< Trailing Edge of Ring Indicator bit */
name|uint64_t
name|ddsr
range|:
literal|1
decl_stmt|;
comment|/**< Delta Data Set Ready bit */
name|uint64_t
name|dcts
range|:
literal|1
decl_stmt|;
comment|/**< Delta Clear To Send bit */
else|#
directive|else
name|uint64_t
name|dcts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|teri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ddcd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dsr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ri
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dcd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_msr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_msr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_msr
name|cvmx_mio_uart2_msr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_rbr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_rbr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_rbr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|rbr
range|:
literal|8
decl_stmt|;
comment|/**< Receive Buffer Register */
else|#
directive|else
name|uint64_t
name|rbr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_rbr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_rbr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_rbr
name|cvmx_mio_uart2_rbr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_rfl  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_rfl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_rfl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|rfl
range|:
literal|7
decl_stmt|;
comment|/**< Receive FIFO Level Register */
else|#
directive|else
name|uint64_t
name|rfl
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_rfl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_rfl_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_rfl
name|cvmx_mio_uart2_rfl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_rfw  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_rfw
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_rfw_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
name|uint64_t
name|rffe
range|:
literal|1
decl_stmt|;
comment|/**< Receive FIFO Framing Error */
name|uint64_t
name|rfpe
range|:
literal|1
decl_stmt|;
comment|/**< Receive FIFO Parity Error */
name|uint64_t
name|rfwd
range|:
literal|8
decl_stmt|;
comment|/**< Receive FIFO Write Data */
else|#
directive|else
name|uint64_t
name|rfwd
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rfpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rffe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_10_63
range|:
literal|54
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_rfw_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_rfw_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_rfw
name|cvmx_mio_uart2_rfw_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_sbcr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_sbcr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_sbcr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|sbcr
range|:
literal|1
decl_stmt|;
comment|/**< Shadow Break Control */
else|#
directive|else
name|uint64_t
name|sbcr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_sbcr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_sbcr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_sbcr
name|cvmx_mio_uart2_sbcr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_scr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_scr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_scr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|scr
range|:
literal|8
decl_stmt|;
comment|/**< Scratchpad Register */
else|#
directive|else
name|uint64_t
name|scr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_scr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_scr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_scr
name|cvmx_mio_uart2_scr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_sfe  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_sfe
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_sfe_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|sfe
range|:
literal|1
decl_stmt|;
comment|/**< Shadow FIFO Enable */
else|#
directive|else
name|uint64_t
name|sfe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_sfe_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_sfe_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_sfe
name|cvmx_mio_uart2_sfe_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_srr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_srr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_srr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|stfr
range|:
literal|1
decl_stmt|;
comment|/**< Shadow TX FIFO Reset */
name|uint64_t
name|srfr
range|:
literal|1
decl_stmt|;
comment|/**< Shadow RX FIFO Reset */
name|uint64_t
name|usr
range|:
literal|1
decl_stmt|;
comment|/**< UART Soft Reset */
else|#
directive|else
name|uint64_t
name|usr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|srfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stfr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_srr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_srr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_srr
name|cvmx_mio_uart2_srr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_srt  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_srt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_srt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|srt
range|:
literal|2
decl_stmt|;
comment|/**< Shadow RX Trigger */
else|#
directive|else
name|uint64_t
name|srt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_srt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_srt_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_srt
name|cvmx_mio_uart2_srt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_srts  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_srts
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_srts_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|srts
range|:
literal|1
decl_stmt|;
comment|/**< Shadow Request To Send */
else|#
directive|else
name|uint64_t
name|srts
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_srts_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_srts_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_srts
name|cvmx_mio_uart2_srts_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_stt  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_stt
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_stt_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|stt
range|:
literal|2
decl_stmt|;
comment|/**< Shadow TX Trigger */
else|#
directive|else
name|uint64_t
name|stt
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_stt_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_stt_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_stt
name|cvmx_mio_uart2_stt_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_tfl  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_tfl
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_tfl_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|tfl
range|:
literal|7
decl_stmt|;
comment|/**< Transmit FIFO Level Register */
else|#
directive|else
name|uint64_t
name|tfl
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_tfl_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_tfl_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_tfl
name|cvmx_mio_uart2_tfl_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_tfr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_tfr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_tfr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|tfr
range|:
literal|8
decl_stmt|;
comment|/**< Transmit FIFO Read Register */
else|#
directive|else
name|uint64_t
name|tfr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_tfr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_tfr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_tfr
name|cvmx_mio_uart2_tfr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_thr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_thr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_thr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|thr
range|:
literal|8
decl_stmt|;
comment|/**< Transmit Holding Register */
else|#
directive|else
name|uint64_t
name|thr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_thr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_thr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_thr
name|cvmx_mio_uart2_thr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_mio_uart2_usr  */
end_comment

begin_union
union|union
name|cvmx_mio_uart2_usr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_mio_uart2_usr_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|rff
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO Full */
name|uint64_t
name|rfne
range|:
literal|1
decl_stmt|;
comment|/**< RX FIFO Not Empty */
name|uint64_t
name|tfe
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO Empty */
name|uint64_t
name|tfnf
range|:
literal|1
decl_stmt|;
comment|/**< TX FIFO Not Full */
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
comment|/**< Busy bit (always 0 in PASS3) */
else|#
directive|else
name|uint64_t
name|busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tfnf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tfe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfne
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_mio_uart2_usr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_mio_uart2_usr_s
name|cn52xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_mio_uart2_usr
name|cvmx_mio_uart2_usr_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

