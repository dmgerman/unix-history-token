begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to PCIe as a host(RC) or target(EP)  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-csr-db.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pcie.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-wqe.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-errata.h"
end_include

begin_comment
comment|/**  * Return the Core virtual base address for PCIe IO access. IOs are  * read/written as an offset from this address.  *  * @param pcie_port PCIe port the IO is for  *  * @return 64bit Octeon IO base address for read/write  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_io_base_address
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|cvmx_pcie_address_t
name|pcie_addr
decl_stmt|;
name|pcie_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|upper
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|subdid
operator|=
literal|2
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|es
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|io
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
return|return
name|pcie_addr
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Size of the IO address region returned at address  * cvmx_pcie_get_io_base_address()  *  * @param pcie_port PCIe port the IO is for  *  * @return Size of the IO window  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_io_size
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
return|return
literal|1ull
operator|<<
literal|32
return|;
block|}
end_function

begin_comment
comment|/**  * Return the Core virtual base address for PCIe MEM access. Memory is  * read/written as an offset from this address.  *  * @param pcie_port PCIe port the IO is for  *  * @return 64bit Octeon IO base address for read/write  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_mem_base_address
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|cvmx_pcie_address_t
name|pcie_addr
decl_stmt|;
name|pcie_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|upper
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|pcie_addr
operator|.
name|mem
operator|.
name|subdid
operator|=
literal|3
operator|+
name|pcie_port
expr_stmt|;
return|return
name|pcie_addr
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Size of the Mem address region returned at address  * cvmx_pcie_get_mem_base_address()  *  * @param pcie_port PCIe port the IO is for  *  * @return Size of the Mem window  */
end_comment

begin_function
name|uint64_t
name|cvmx_pcie_get_mem_size
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
return|return
literal|1ull
operator|<<
literal|36
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize the RC config space CSRs  *  * @param pcie_port PCIe port to initialize  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_pcie_rc_initialize_config_space
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
comment|/* Max Payload Size (PCIE*_CFG030[MPS]) */
comment|/* Max Read Request Size (PCIE*_CFG030[MRRS]) */
comment|/* Relaxed-order, no-snoop enables (PCIE*_CFG030[RO_EN,NS_EN] */
comment|/* Error Message Enables (PCIE*_CFG030[CE_EN,NFE_EN,FE_EN,UR_EN]) */
block|{
name|cvmx_pciercx_cfg030_t
name|pciercx_cfg030
decl_stmt|;
name|pciercx_cfg030
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mps
operator|=
literal|0
expr_stmt|;
comment|/* Max payload size = 128 bytes for best Octeon DMA performance */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|0
expr_stmt|;
comment|/* Max read request size = 128 bytes for best Octeon DMA performance */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ro_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable relaxed order processing. This will allow devices to affect read response ordering */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ns_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable no snoop processing. Not used by Octeon */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ce_en
operator|=
literal|1
expr_stmt|;
comment|/* Correctable error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|nfe_en
operator|=
literal|1
expr_stmt|;
comment|/* Non-fatal error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|fe_en
operator|=
literal|1
expr_stmt|;
comment|/* Fatal error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ur_en
operator|=
literal|1
expr_stmt|;
comment|/* Unsupported request reporting enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg030
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Max Payload Size (NPEI_CTL_STATUS2[MPS]) must match PCIE*_CFG030[MPS] */
comment|/* Max Read Request Size (NPEI_CTL_STATUS2[MRRS]) must not exceed PCIE*_CFG030[MRRS] */
block|{
name|cvmx_npei_ctl_status2_t
name|npei_ctl_status2
decl_stmt|;
name|npei_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|)
expr_stmt|;
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mps
operator|=
literal|0
expr_stmt|;
comment|/* Max payload size = 128 bytes for best Octeon DMA performance */
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|0
expr_stmt|;
comment|/* Max read request size = 128 bytes for best Octeon DMA performance */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|,
name|npei_ctl_status2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* ECRC Generation (PCIE*_CFG070[GE,CE]) */
block|{
name|cvmx_pciercx_cfg070_t
name|pciercx_cfg070
decl_stmt|;
name|pciercx_cfg070
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG070
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg070
operator|.
name|s
operator|.
name|ge
operator|=
literal|1
expr_stmt|;
comment|/* ECRC generation enable. */
name|pciercx_cfg070
operator|.
name|s
operator|.
name|ce
operator|=
literal|1
expr_stmt|;
comment|/* ECRC check enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG070
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg070
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Access Enables (PCIE*_CFG001[MSAE,ME]) */
comment|/* ME and MSAE should always be set. */
comment|/* Interrupt Disable (PCIE*_CFG001[I_DIS]) */
comment|/* System Error Message Enable (PCIE*_CFG001[SEE]) */
block|{
name|cvmx_pciercx_cfg001_t
name|pciercx_cfg001
decl_stmt|;
name|pciercx_cfg001
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG001
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg001
operator|.
name|s
operator|.
name|msae
operator|=
literal|1
expr_stmt|;
comment|/* Memory space enable. */
name|pciercx_cfg001
operator|.
name|s
operator|.
name|me
operator|=
literal|1
expr_stmt|;
comment|/* Bus master enable. */
name|pciercx_cfg001
operator|.
name|s
operator|.
name|i_dis
operator|=
literal|1
expr_stmt|;
comment|/* INTx assertion disable. */
name|pciercx_cfg001
operator|.
name|s
operator|.
name|see
operator|=
literal|1
expr_stmt|;
comment|/* SERR# enable */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG001
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg001
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Advanced Error Recovery Message Enables */
comment|/* (PCIE*_CFG066,PCIE*_CFG067,PCIE*_CFG069) */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG066
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Use CVMX_PCIERCX_CFG067 hardware default */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG069
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Active State Power Management (PCIE*_CFG032[ASLPC]) */
block|{
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg032
operator|.
name|s
operator|.
name|aslpc
operator|=
literal|0
expr_stmt|;
comment|/* Active state Link PM control. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg032
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Entrance Latencies (PCIE*_CFG451[L0EL,L1EL]) */
comment|// FIXME: Anything needed here?
comment|/* Link Width Mode (PCIERCn_CFG452[LME]) - Set during cvmx_pcie_rc_initialize_link() */
comment|/* Primary Bus Number (PCIERCn_CFG006[PBNUM]) */
block|{
comment|/* We set the primary bus number to 1 so IDT bridges are happy. They don't like zero */
name|cvmx_pciercx_cfg006_t
name|pciercx_cfg006
decl_stmt|;
name|pciercx_cfg006
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|pciercx_cfg006
operator|.
name|s
operator|.
name|pbnum
operator|=
literal|1
expr_stmt|;
name|pciercx_cfg006
operator|.
name|s
operator|.
name|sbnum
operator|=
literal|1
expr_stmt|;
name|pciercx_cfg006
operator|.
name|s
operator|.
name|subbnum
operator|=
literal|1
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG006
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg006
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Memory-mapped I/O BAR (PCIERCn_CFG008) */
comment|/* Most applications should disable the memory-mapped I/O BAR by */
comment|/* setting PCIERCn_CFG008[ML_ADDR]< PCIERCn_CFG008[MB_ADDR] */
block|{
name|cvmx_pciercx_cfg008_t
name|pciercx_cfg008
decl_stmt|;
name|pciercx_cfg008
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|pciercx_cfg008
operator|.
name|s
operator|.
name|mb_addr
operator|=
literal|0x100
expr_stmt|;
name|pciercx_cfg008
operator|.
name|s
operator|.
name|ml_addr
operator|=
literal|0
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG008
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg008
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Prefetchable BAR (PCIERCn_CFG009,PCIERCn_CFG010,PCIERCn_CFG011) */
comment|/* Most applications should disable the prefetchable BAR by setting */
comment|/* PCIERCn_CFG011[UMEM_LIMIT],PCIERCn_CFG009[LMEM_LIMIT]< */
comment|/* PCIERCn_CFG010[UMEM_BASE],PCIERCn_CFG009[LMEM_BASE] */
block|{
name|cvmx_pciercx_cfg009_t
name|pciercx_cfg009
decl_stmt|;
name|cvmx_pciercx_cfg010_t
name|pciercx_cfg010
decl_stmt|;
name|cvmx_pciercx_cfg011_t
name|pciercx_cfg011
decl_stmt|;
name|pciercx_cfg009
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG009
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg010
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG010
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg011
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG011
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg009
operator|.
name|s
operator|.
name|lmem_base
operator|=
literal|0x100
expr_stmt|;
name|pciercx_cfg009
operator|.
name|s
operator|.
name|lmem_limit
operator|=
literal|0
expr_stmt|;
name|pciercx_cfg010
operator|.
name|s
operator|.
name|umem_base
operator|=
literal|0x100
expr_stmt|;
name|pciercx_cfg011
operator|.
name|s
operator|.
name|umem_limit
operator|=
literal|0
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG009
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg009
operator|.
name|u32
argument_list|)
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG010
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg010
operator|.
name|u32
argument_list|)
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG011
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg011
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* System Error Interrupt Enables (PCIERCn_CFG035[SECEE,SEFEE,SENFEE]) */
comment|/* PME Interrupt Enables (PCIERCn_CFG035[PMEIE]) */
block|{
name|cvmx_pciercx_cfg035_t
name|pciercx_cfg035
decl_stmt|;
name|pciercx_cfg035
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG035
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg035
operator|.
name|s
operator|.
name|secee
operator|=
literal|1
expr_stmt|;
comment|/* System error on correctable error enable. */
name|pciercx_cfg035
operator|.
name|s
operator|.
name|sefee
operator|=
literal|1
expr_stmt|;
comment|/* System error on fatal error enable. */
name|pciercx_cfg035
operator|.
name|s
operator|.
name|senfee
operator|=
literal|1
expr_stmt|;
comment|/* System error on non-fatal error enable. */
name|pciercx_cfg035
operator|.
name|s
operator|.
name|pmeie
operator|=
literal|1
expr_stmt|;
comment|/* PME interrupt enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG035
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg035
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Advanced Error Recovery Interrupt Enables */
comment|/* (PCIERCn_CFG075[CERE,NFERE,FERE]) */
block|{
name|cvmx_pciercx_cfg075_t
name|pciercx_cfg075
decl_stmt|;
name|pciercx_cfg075
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG075
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg075
operator|.
name|s
operator|.
name|cere
operator|=
literal|1
expr_stmt|;
comment|/* Correctable error reporting enable. */
name|pciercx_cfg075
operator|.
name|s
operator|.
name|nfere
operator|=
literal|1
expr_stmt|;
comment|/* Non-fatal error reporting enable. */
name|pciercx_cfg075
operator|.
name|s
operator|.
name|fere
operator|=
literal|1
expr_stmt|;
comment|/* Fatal error reporting enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG075
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg075
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* HP Interrupt Enables (PCIERCn_CFG034[HPINT_EN], */
comment|/* PCIERCn_CFG034[DLLS_EN,CCINT_EN]) */
block|{
name|cvmx_pciercx_cfg034_t
name|pciercx_cfg034
decl_stmt|;
name|pciercx_cfg034
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG034
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg034
operator|.
name|s
operator|.
name|hpint_en
operator|=
literal|1
expr_stmt|;
comment|/* Hot-plug interrupt enable. */
name|pciercx_cfg034
operator|.
name|s
operator|.
name|dlls_en
operator|=
literal|1
expr_stmt|;
comment|/* Data Link Layer state changed enable */
name|pciercx_cfg034
operator|.
name|s
operator|.
name|ccint_en
operator|=
literal|1
expr_stmt|;
comment|/* Command completed interrupt enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG034
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg034
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Initialize a host mode PCIe link. This function takes a PCIe  * port from reset to a link up state. Software can then begin  * configuring the rest of the link.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_pcie_rc_initialize_link
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|uint64_t
name|start_cycle
decl_stmt|;
name|cvmx_pescx_ctl_status_t
name|pescx_ctl_status
decl_stmt|;
name|cvmx_pciercx_cfg452_t
name|pciercx_cfg452
decl_stmt|;
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|cvmx_pciercx_cfg448_t
name|pciercx_cfg448
decl_stmt|;
comment|/* Set the lane width */
name|pciercx_cfg452
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG452
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pescx_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_ctl_status
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|0
condition|)
block|{
comment|/* We're in 8 lane (56XX) or 4 lane (54XX) mode */
name|pciercx_cfg452
operator|.
name|s
operator|.
name|lme
operator|=
literal|0xf
expr_stmt|;
block|}
else|else
block|{
comment|/* We're in 4 lane (56XX) or 2 lane (52XX) mode */
name|pciercx_cfg452
operator|.
name|s
operator|.
name|lme
operator|=
literal|0x7
expr_stmt|;
block|}
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG452
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg452
operator|.
name|u32
argument_list|)
expr_stmt|;
comment|/* CN52XX pass 1.x has an errata where length mismatches on UR responses can         cause bus errors on 64bit memory reads. Turning off length error         checking fixes this */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_pciercx_cfg455_t
name|pciercx_cfg455
decl_stmt|;
name|pciercx_cfg455
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG455
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg455
operator|.
name|s
operator|.
name|m_cpl_len_err
operator|=
literal|1
expr_stmt|;
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG455
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg455
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Lane swap needs to be manually enabled for CN52XX */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
name|pcie_port
operator|==
literal|1
operator|)
condition|)
block|{
name|pescx_ctl_status
operator|.
name|s
operator|.
name|lane_swp
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Bring up the link */
name|pescx_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pescx_ctl_status
operator|.
name|s
operator|.
name|lnk_enb
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* CN52XX pass 1.0: Due to a bug in 2nd order CDR, it needs to be disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_0
argument_list|)
condition|)
name|__cvmx_helper_errata_qlm_disable_2nd_order_cdr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Wait for the link to come up */
name|start_cycle
operator|=
name|cvmx_get_cycle
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|cvmx_get_cycle
argument_list|()
operator|-
name|start_cycle
operator|>
literal|2
operator|*
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|cpu_clock_hz
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d link timeout\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|dlla
operator|==
literal|0
condition|)
do|;
comment|/* Update the Replay Time Limit. Empirically, some PCIe devices take a         little longer to respond than expected under load. As a workaround for         this we configure the Replay Time Limit to the value expected for a 512         byte MPS instead of our actual 256 byte MPS. The numbers below are         directly from the PCIe spec table 3-4 */
name|pciercx_cfg448
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG448
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pciercx_cfg032
operator|.
name|s
operator|.
name|nlw
condition|)
block|{
case|case
literal|1
case|:
comment|/* 1 lane */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|1677
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 2 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|867
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* 4 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|462
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* 8 lanes */
name|pciercx_cfg448
operator|.
name|s
operator|.
name|rtl
operator|=
literal|258
expr_stmt|;
break|break;
block|}
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG448
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg448
operator|.
name|u32
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a PCIe port for use in host(RC) mode. It doesn't enumerate the bus.  *  * @param pcie_port PCIe port to initialize  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_pcie_rc_initialize
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|cvmx_pescx_bist_status_t
name|pescx_bist_status
decl_stmt|;
name|cvmx_pescx_bist_status2_t
name|pescx_bist_status2
decl_stmt|;
name|cvmx_npei_ctl_status_t
name|npei_ctl_status
decl_stmt|;
name|cvmx_npei_mem_access_ctl_t
name|npei_mem_access_ctl
decl_stmt|;
name|cvmx_npei_mem_access_subidx_t
name|mem_access_subid
decl_stmt|;
name|cvmx_npei_dbg_data_t
name|npei_dbg_data
decl_stmt|;
name|cvmx_pescx_ctl_status2_t
name|pescx_ctl_status2
decl_stmt|;
name|cvmx_pciercx_cfg032_t
name|pciercx_cfg032
decl_stmt|;
name|retry
label|:
comment|/* Make sure we aren't trying to setup a target mode interface in host mode */
name|npei_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcie_port
operator|==
literal|0
operator|)
operator|&&
operator|!
name|npei_ctl_status
operator|.
name|s
operator|.
name|host_mode
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: ERROR: cvmx_pcie_rc_initialize() called on port0, but port0 is not in host mode\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make sure a CN52XX isn't trying to bring up port 1 when it is disabled */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
condition|)
block|{
name|npei_dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcie_port
operator|==
literal|1
operator|)
operator|&&
name|npei_dbg_data
operator|.
name|cn52xx
operator|.
name|qlm0_link_width
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: ERROR: cvmx_pcie_rc_initialize() called on port1, but port1 is disabled\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* PCIe switch arbitration mode. '0' == fixed priority NPEI, PCIe0, then PCIe1. '1' == round robin. */
name|npei_ctl_status
operator|.
name|s
operator|.
name|arb
operator|=
literal|1
expr_stmt|;
comment|/* Allow up to 0x20 config retries */
name|npei_ctl_status
operator|.
name|s
operator|.
name|cfg_rtry
operator|=
literal|0x20
expr_stmt|;
comment|/* CN52XX pass1.x has an errata where P0_NTAGS and P1_NTAGS don't reset */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
name|npei_ctl_status
operator|.
name|s
operator|.
name|p0_ntags
operator|=
literal|0x20
expr_stmt|;
name|npei_ctl_status
operator|.
name|s
operator|.
name|p1_ntags
operator|=
literal|0x20
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS
argument_list|,
name|npei_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Bring the PCIe out of reset */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH5200
condition|)
block|{
comment|/* The EBH5200 board swapped the PCIe reset lines on the board. As a             workaround for this bug, we bring both PCIe ports out of reset at             the same time instead of on separate calls. So for port 0, we bring             both out of reset and do nothing on port 1 */
if|if
condition|(
name|pcie_port
operator|==
literal|0
condition|)
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
comment|/* After a chip reset the PCIe will also be in reset. If it isn't,                 most likely someone is trying to init it again without a proper                 PCIe reset */
if|if
condition|(
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|==
literal|0
condition|)
block|{
comment|/* Reset the ports */
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait until pcie resets the ports. */
name|cvmx_wait_usec
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The normal case: The PCIe ports are completely separate and can be             brought out of reset independently */
if|if
condition|(
name|pcie_port
condition|)
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
else|else
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
comment|/* After a chip reset the PCIe will also be in reset. If it isn't,             most likely someone is trying to init it again without a proper             PCIe reset */
if|if
condition|(
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|==
literal|0
condition|)
block|{
comment|/* Reset the port */
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pcie_port
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
else|else
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait until pcie resets the ports. */
name|cvmx_wait_usec
argument_list|(
literal|2000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pcie_port
condition|)
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Wait for PCIe reset to complete. Due to errata PCIE-700, we don't poll        PESCX_CTL_STATUS2[PCIERST], but simply wait a fixed number of cycles */
name|cvmx_wait
argument_list|(
literal|400000
argument_list|)
expr_stmt|;
comment|/* PESCX_BIST_STATUS2[PCLK_RUN] was missing on pass 1 of CN56XX and         CN52XX, so we only probe it on newer chips */
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
operator|&&
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
comment|/* Clear PCLK_RUN so we can check if the clock is running */
name|pescx_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pescx_ctl_status2
operator|.
name|s
operator|.
name|pclk_run
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_ctl_status2
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Now that we cleared PCLK_RUN, wait for it to be set again telling             us the clock is running */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|cvmx_pescx_ctl_status2_t
argument_list|,
name|pclk_run
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|10000
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d isn't clocked, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Check and make sure PCIe came out of reset. If it doesn't the board         probably hasn't wired the clocks up and the interface should be         skipped */
name|pescx_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CTL_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_ctl_status2
operator|.
name|s
operator|.
name|pcierst
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d stuck in reset, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check BIST2 status. If any bits are set skip this interface. This         is an attempt to catch PCIE-813 on pass 1 parts */
name|pescx_bist_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_BIST_STATUS2
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_bist_status2
operator|.
name|u64
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d BIST2 failed. Most likely this port isn't hooked up, skipping.\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Check BIST status */
name|pescx_bist_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_BIST_STATUS
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pescx_bist_status
operator|.
name|u64
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: BIST FAILED for port %d (0x%016llx)\n"
argument_list|,
name|pcie_port
argument_list|,
name|CAST64
argument_list|(
name|pescx_bist_status
operator|.
name|u64
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the config space CSRs */
name|__cvmx_pcie_rc_initialize_config_space
argument_list|(
name|pcie_port
argument_list|)
expr_stmt|;
comment|/* Bring the link up */
if|if
condition|(
name|__cvmx_pcie_rc_initialize_link
argument_list|(
name|pcie_port
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: ERROR: cvmx_pcie_rc_initialize_link() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Store merge control (NPEI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
name|npei_mem_access_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_CTL
argument_list|)
expr_stmt|;
name|npei_mem_access_ctl
operator|.
name|s
operator|.
name|max_word
operator|=
literal|0
expr_stmt|;
comment|/* Allow 16 words to combine */
name|npei_mem_access_ctl
operator|.
name|s
operator|.
name|timer
operator|=
literal|127
expr_stmt|;
comment|/* Wait up to 127 cycles for more data */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_CTL
argument_list|,
name|npei_mem_access_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup Mem access SubDIDs */
name|mem_access_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
comment|/* Port the request is sent to. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|1
expr_stmt|;
comment|/* Due to an errata on pass 1 chips, no merging is allowed. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esr
operator|=
literal|1
expr_stmt|;
comment|/* Endian-swap for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esw
operator|=
literal|1
expr_stmt|;
comment|/* Endian-swap for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsr
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snooping for Reads. Octeon doesn't care, but devices might want this more conservative setting */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsw
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snoop for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ror
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|row
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
comment|/* PCIe Adddress Bits<63:34>. */
comment|/* Setup mem access 12-15 for port 0, 16-19 for port 1, supplying 36 bits of address space */
for|for
control|(
name|i
operator|=
literal|12
operator|+
name|pcie_port
operator|*
literal|4
init|;
name|i
operator|<
literal|16
operator|+
name|pcie_port
operator|*
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_SUBIDX
argument_list|(
name|i
argument_list|)
argument_list|,
name|mem_access_subid
operator|.
name|u64
argument_list|)
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|ba
operator|+=
literal|1
expr_stmt|;
comment|/* Set each SUBID to extend the addressable range */
block|}
comment|/* Disable the peer to peer forwarding register. This must be setup         by the OS after it enumerates the bus and assigns addresses to the         PCIe busses */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2P_BARX_START
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2P_BARX_END
argument_list|(
name|i
argument_list|,
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Set Octeon's BAR0 to decode 0-16KB. It overlaps with Bar2 */
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2N_BAR0_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Disable Octeon's BAR1. It isn't needed in RC mode since BAR2         maps all of memory. BAR2 also maps 256MB-512MB into the 2nd         256MB of memory */
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2N_BAR1_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* Set Octeon's BAR2 to decode 0-2^39. Bar0 and Bar1 take precedence         where they overlap. It also overlaps with the device addresses, so         make sure the peer to peer forwarding is set right */
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_P2N_BAR2_START
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Setup BAR2 attributes */
comment|/* Relaxed Ordering (NPEI_CTL_PORTn[PTLP_RO,CTLP_RO, WAIT_COM]) */
comment|/* ­ PTLP_RO,CTLP_RO should normally be set (except for debug). */
comment|/* ­ WAIT_COM=0 will likely work for all applications. */
comment|/* Load completion relaxed ordering (NPEI_CTL_PORTn[WAITL_COM]) */
if|if
condition|(
name|pcie_port
condition|)
block|{
name|cvmx_npei_ctl_port1_t
name|npei_ctl_port
decl_stmt|;
name|npei_ctl_port
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT1
argument_list|)
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_enb
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_esx
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_cax
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ptlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ctlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|wait_com
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|waitl_com
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT1
argument_list|,
name|npei_ctl_port
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_npei_ctl_port0_t
name|npei_ctl_port
decl_stmt|;
name|npei_ctl_port
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT0
argument_list|)
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_enb
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_esx
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|bar2_cax
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ptlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|ctlp_ro
operator|=
literal|1
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|wait_com
operator|=
literal|0
expr_stmt|;
name|npei_ctl_port
operator|.
name|s
operator|.
name|waitl_com
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_PORT0
argument_list|,
name|npei_ctl_port
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Both pass 1 and pass 2 of CN52XX and CN56XX have an errata that causes         TLP ordering to not be preserved after multiple PCIe port resets. This         code detects this fault and corrects it by aligning the TLP counters         properly. Another link reset is then performed. See PCIE-13340 */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS2_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS2_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_npei_dbg_data_t
name|dbg_data
decl_stmt|;
name|int
name|old_in_fif_p_count
decl_stmt|;
name|int
name|in_fif_p_count
decl_stmt|;
name|int
name|out_p_count
decl_stmt|;
name|int
name|in_p_offset
init|=
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX_PASS1_X
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX_PASS1_X
argument_list|)
operator|)
condition|?
literal|4
else|:
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Choose a write address of 1MB. It should be harmless as all bars             haven't been setup */
name|uint64_t
name|write_address
init|=
operator|(
name|cvmx_pcie_get_mem_base_address
argument_list|(
name|pcie_port
argument_list|)
operator|+
literal|0x100000
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
decl_stmt|;
comment|/* Make sure at least in_p_offset have been executed before we try and             read in_fif_p_count */
name|i
operator|=
name|in_p_offset
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|write_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
block|}
comment|/* Read the IN_FIF_P_COUNT from the debug select. IN_FIF_P_COUNT can be             unstable sometimes so read it twice with a write between the reads.             This way we can tell the value is good as it will increment by one             due to the write */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|,
operator|(
name|pcie_port
operator|)
condition|?
literal|0xd7fc
else|:
literal|0xcffc
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|)
expr_stmt|;
do|do
block|{
name|dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
name|old_in_fif_p_count
operator|=
name|dbg_data
operator|.
name|s
operator|.
name|data
operator|&
literal|0xff
expr_stmt|;
name|cvmx_write64_uint32
argument_list|(
name|write_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
name|in_fif_p_count
operator|=
name|dbg_data
operator|.
name|s
operator|.
name|data
operator|&
literal|0xff
expr_stmt|;
block|}
do|while
condition|(
name|in_fif_p_count
operator|!=
operator|(
operator|(
name|old_in_fif_p_count
operator|+
literal|1
operator|)
operator|&
literal|0xff
operator|)
condition|)
do|;
comment|/* Update in_fif_p_count for it's offset with respect to out_p_count */
name|in_fif_p_count
operator|=
operator|(
name|in_fif_p_count
operator|+
name|in_p_offset
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Read the OUT_P_COUNT from the debug select */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|,
operator|(
name|pcie_port
operator|)
condition|?
literal|0xd00f
else|:
literal|0xc80f
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_SELECT
argument_list|)
expr_stmt|;
name|dbg_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DBG_DATA
argument_list|)
expr_stmt|;
name|out_p_count
operator|=
operator|(
name|dbg_data
operator|.
name|s
operator|.
name|data
operator|>>
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* Check that the two counters are aligned */
if|if
condition|(
name|out_p_count
operator|!=
name|in_fif_p_count
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d aligning TLP counters as workaround to maintain ordering\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
while|while
condition|(
name|in_fif_p_count
operator|!=
literal|0
condition|)
block|{
name|cvmx_write64_uint32
argument_list|(
name|write_address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
name|in_fif_p_count
operator|=
operator|(
name|in_fif_p_count
operator|+
literal|1
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
comment|/* The EBH5200 board swapped the PCIe reset lines on the board. This                 means we must bring both links down and up, which will cause the                 PCIe0 to need alignment again. Lots of messages will be displayed,                 but everything should work */
if|if
condition|(
operator|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_EBH5200
operator|)
operator|&&
operator|(
name|pcie_port
operator|==
literal|1
operator|)
condition|)
name|cvmx_pcie_rc_initialize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Rety bringing this port up */
goto|goto
name|retry
goto|;
block|}
block|}
comment|/* Display the link status */
name|pciercx_cfg032
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG032
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d link active, %d lanes\n"
argument_list|,
name|pcie_port
argument_list|,
name|pciercx_cfg032
operator|.
name|s
operator|.
name|nlw
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Shutdown a PCIe port and put it in reset  *  * @param pcie_port PCIe port to shutdown  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_pcie_rc_shutdown
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
comment|/* Wait for all pending operations to complete */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_PESCX_CPL_LUT_VALID
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|cvmx_pescx_cpl_lut_valid_t
argument_list|,
name|tag
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
literal|2000
argument_list|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"PCIe: Port %d shutdown timeout\n"
argument_list|,
name|pcie_port
argument_list|)
expr_stmt|;
comment|/* Force reset */
if|if
condition|(
name|pcie_port
condition|)
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_soft_prst_t
name|ciu_soft_prst
decl_stmt|;
name|ciu_soft_prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
name|ciu_soft_prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|ciu_soft_prst
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Build a PCIe config space request address for a device  *  * @param pcie_port PCIe port to access  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return 64bit Octeon IO address  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|__cvmx_pcie_build_config_addr
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|cvmx_pcie_address_t
name|pcie_addr
decl_stmt|;
name|cvmx_pciercx_cfg006_t
name|pciercx_cfg006
decl_stmt|;
name|pciercx_cfg006
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG006
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bus
operator|<=
name|pciercx_cfg006
operator|.
name|s
operator|.
name|pbnum
operator|)
operator|&&
operator|(
name|dev
operator|!=
literal|0
operator|)
condition|)
return|return
literal|0
return|;
name|pcie_addr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|upper
operator|=
literal|2
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|subdid
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|es
operator|=
literal|1
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|ty
operator|=
operator|(
name|bus
operator|>
name|pciercx_cfg006
operator|.
name|s
operator|.
name|pbnum
operator|)
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|bus
operator|=
name|bus
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|dev
operator|=
name|dev
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|func
operator|=
name|fn
expr_stmt|;
name|pcie_addr
operator|.
name|config
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
return|return
name|pcie_addr
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Read 8bits from a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return Result of the read  */
end_comment

begin_function
name|uint8_t
name|cvmx_pcie_config_read8
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
return|return
name|cvmx_read64_uint8
argument_list|(
name|address
argument_list|)
return|;
else|else
return|return
literal|0xff
return|;
block|}
end_function

begin_comment
comment|/**  * Read 16bits from a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return Result of the read  */
end_comment

begin_function
name|uint16_t
name|cvmx_pcie_config_read16
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
return|return
name|cvmx_le16_to_cpu
argument_list|(
name|cvmx_read64_uint16
argument_list|(
name|address
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0xffff
return|;
block|}
end_function

begin_comment
comment|/**  * Read 32bits from a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  *  * @return Result of the read  */
end_comment

begin_function
name|uint32_t
name|cvmx_pcie_config_read32
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
return|return
name|cvmx_le32_to_cpu
argument_list|(
name|cvmx_read64_uint32
argument_list|(
name|address
argument_list|)
argument_list|)
return|;
else|else
return|return
literal|0xffffffff
return|;
block|}
end_function

begin_comment
comment|/**  * Write 8bits to a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  * @param val       Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_config_write8
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint8_t
name|val
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
name|cvmx_write64_uint8
argument_list|(
name|address
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Write 16bits to a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  * @param val       Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_config_write16
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint16_t
name|val
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
name|cvmx_write64_uint16
argument_list|(
name|address
argument_list|,
name|cvmx_cpu_to_le16
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Write 32bits to a Device's config space  *  * @param pcie_port PCIe port the device is on  * @param bus       Sub bus  * @param dev       Device ID  * @param fn        Device sub function  * @param reg       Register to access  * @param val       Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_config_write32
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|int
name|bus
parameter_list|,
name|int
name|dev
parameter_list|,
name|int
name|fn
parameter_list|,
name|int
name|reg
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|uint64_t
name|address
init|=
name|__cvmx_pcie_build_config_addr
argument_list|(
name|pcie_port
argument_list|,
name|bus
argument_list|,
name|dev
argument_list|,
name|fn
argument_list|,
name|reg
argument_list|)
decl_stmt|;
if|if
condition|(
name|address
condition|)
name|cvmx_write64_uint32
argument_list|(
name|address
argument_list|,
name|cvmx_cpu_to_le32
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read a PCIe config space register indirectly. This is used for  * registers of the form PCIEEP_CFG??? and PCIERC?_CFG???.  *  * @param pcie_port  PCIe port to read from  * @param cfg_offset Address to read  *  * @return Value read  */
end_comment

begin_function
name|uint32_t
name|cvmx_pcie_cfgx_read
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|uint32_t
name|cfg_offset
parameter_list|)
block|{
name|cvmx_pescx_cfg_rd_t
name|pescx_cfg_rd
decl_stmt|;
name|pescx_cfg_rd
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pescx_cfg_rd
operator|.
name|s
operator|.
name|addr
operator|=
name|cfg_offset
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CFG_RD
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_cfg_rd
operator|.
name|u64
argument_list|)
expr_stmt|;
name|pescx_cfg_rd
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PESCX_CFG_RD
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pescx_cfg_rd
operator|.
name|s
operator|.
name|data
return|;
block|}
end_function

begin_comment
comment|/**  * Write a PCIe config space register indirectly. This is used for  * registers of the form PCIEEP_CFG??? and PCIERC?_CFG???.  *  * @param pcie_port  PCIe port to write to  * @param cfg_offset Address to write  * @param val        Value to write  */
end_comment

begin_function
name|void
name|cvmx_pcie_cfgx_write
parameter_list|(
name|int
name|pcie_port
parameter_list|,
name|uint32_t
name|cfg_offset
parameter_list|,
name|uint32_t
name|val
parameter_list|)
block|{
name|cvmx_pescx_cfg_wr_t
name|pescx_cfg_wr
decl_stmt|;
name|pescx_cfg_wr
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|pescx_cfg_wr
operator|.
name|s
operator|.
name|addr
operator|=
name|cfg_offset
expr_stmt|;
name|pescx_cfg_wr
operator|.
name|s
operator|.
name|data
operator|=
name|val
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PESCX_CFG_WR
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pescx_cfg_wr
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize a PCIe port for use in target(EP) mode.  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_pcie_ep_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|pcie_port
init|=
literal|0
decl_stmt|;
name|cvmx_npei_ctl_status_t
name|npei_ctl_status
decl_stmt|;
name|npei_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS
argument_list|)
expr_stmt|;
if|if
condition|(
name|npei_ctl_status
operator|.
name|s
operator|.
name|host_mode
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Enable bus master and memory */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIEEP_CFG001
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
comment|/* Max Payload Size (PCIE*_CFG030[MPS]) */
comment|/* Max Read Request Size (PCIE*_CFG030[MRRS]) */
comment|/* Relaxed-order, no-snoop enables (PCIE*_CFG030[RO_EN,NS_EN] */
comment|/* Error Message Enables (PCIE*_CFG030[CE_EN,NFE_EN,FE_EN,UR_EN]) */
block|{
name|cvmx_pciercx_cfg030_t
name|pciercx_cfg030
decl_stmt|;
name|pciercx_cfg030
operator|.
name|u32
operator|=
name|cvmx_pcie_cfgx_read
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|)
expr_stmt|;
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mps
operator|=
literal|0
expr_stmt|;
comment|/* Max payload size = 128 bytes (Limit of most PCs) */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|0
expr_stmt|;
comment|/* Max read request size = 128 bytes for best Octeon DMA performance */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ro_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable relaxed ordering. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ns_en
operator|=
literal|1
expr_stmt|;
comment|/* Enable no snoop. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ce_en
operator|=
literal|1
expr_stmt|;
comment|/* Correctable error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|nfe_en
operator|=
literal|1
expr_stmt|;
comment|/* Non-fatal error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|fe_en
operator|=
literal|1
expr_stmt|;
comment|/* Fatal error reporting enable. */
name|pciercx_cfg030
operator|.
name|s
operator|.
name|ur_en
operator|=
literal|1
expr_stmt|;
comment|/* Unsupported request reporting enable. */
name|cvmx_pcie_cfgx_write
argument_list|(
name|pcie_port
argument_list|,
name|CVMX_PCIERCX_CFG030
argument_list|(
name|pcie_port
argument_list|)
argument_list|,
name|pciercx_cfg030
operator|.
name|u32
argument_list|)
expr_stmt|;
block|}
comment|/* Max Payload Size (NPEI_CTL_STATUS2[MPS]) must match PCIE*_CFG030[MPS] */
comment|/* Max Read Request Size (NPEI_CTL_STATUS2[MRRS]) must not exceed PCIE*_CFG030[MRRS] */
block|{
name|cvmx_npei_ctl_status2_t
name|npei_ctl_status2
decl_stmt|;
name|npei_ctl_status2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|)
expr_stmt|;
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mps
operator|=
literal|0
expr_stmt|;
comment|/* Max payload size = 128 bytes (Limit of most PCs) */
name|npei_ctl_status2
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|0
expr_stmt|;
comment|/* Max read request size = 128 bytes for best Octeon DMA performance */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_CTL_STATUS2
argument_list|,
name|npei_ctl_status2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Setup Mem access SubDID 12 to access Host memory */
block|{
name|cvmx_npei_mem_access_subidx_t
name|mem_access_subid
decl_stmt|;
name|mem_access_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|mem_access_subid
operator|.
name|s
operator|.
name|port
operator|=
name|pcie_port
expr_stmt|;
comment|/* Port the request is sent to. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|1
expr_stmt|;
comment|/* Merging is allowed in this window. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esr
operator|=
literal|0
expr_stmt|;
comment|/* Endian-swap for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|esw
operator|=
literal|0
expr_stmt|;
comment|/* Endian-swap for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsr
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snooping for Reads. Octeon doesn't care, but devices might want this more conservative setting */
name|mem_access_subid
operator|.
name|s
operator|.
name|nsw
operator|=
literal|0
expr_stmt|;
comment|/* Enable Snoop for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ror
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Reads. */
name|mem_access_subid
operator|.
name|s
operator|.
name|row
operator|=
literal|0
expr_stmt|;
comment|/* Disable Relaxed Ordering for Writes. */
name|mem_access_subid
operator|.
name|s
operator|.
name|ba
operator|=
literal|0
expr_stmt|;
comment|/* PCIe Adddress Bits<63:34>. */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_NPEI_MEM_ACCESS_SUBIDX
argument_list|(
literal|12
argument_list|)
argument_list|,
name|mem_access_subid
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Wait for posted PCIe read/writes to reach the other side of  * the internal PCIe switch. This will insure that core  * read/writes are posted before anything after this function  * is called. This may be necessary when writing to memory that  * will later be read using the DMA/PKT engines.  *  * @param pcie_port PCIe port to wait for  */
end_comment

begin_function
name|void
name|cvmx_pcie_wait_for_pending
parameter_list|(
name|int
name|pcie_port
parameter_list|)
block|{
name|cvmx_npei_data_out_cnt_t
name|npei_data_out_cnt
decl_stmt|;
name|int
name|a
decl_stmt|;
name|int
name|b
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* See section 9.8, PCIe Core-initiated Requests, in the manual for a         description of how this code works */
name|npei_data_out_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DATA_OUT_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|pcie_port
condition|)
block|{
if|if
condition|(
operator|!
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_fcnt
condition|)
return|return;
name|a
operator|=
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_ucnt
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|+
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_fcnt
operator|-
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_fcnt
condition|)
return|return;
name|a
operator|=
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_ucnt
expr_stmt|;
name|b
operator|=
operator|(
name|a
operator|+
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_fcnt
operator|-
literal|1
operator|)
operator|&
literal|0xffff
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
name|npei_data_out_cnt
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_NPEI_DATA_OUT_CNT
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|pcie_port
operator|)
condition|?
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p1_ucnt
else|:
name|npei_data_out_cnt
operator|.
name|s
operator|.
name|p0_ucnt
expr_stmt|;
if|if
condition|(
name|a
operator|<=
name|b
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|<
name|a
operator|)
operator|||
operator|(
name|c
operator|>
name|b
operator|)
condition|)
return|return;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|c
operator|>
name|b
operator|)
operator|&&
operator|(
name|c
operator|<
name|a
operator|)
condition|)
return|return;
block|}
block|}
block|}
end_function

end_unit

