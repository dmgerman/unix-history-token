begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-asxx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon asxx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_ASXX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_ASXX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_GMII_RX_CLK_SET
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_GMII_RX_CLK_SET(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000180ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_GMII_RX_CLK_SET
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000180ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_GMII_RX_DAT_SET
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_GMII_RX_DAT_SET(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000188ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_GMII_RX_DAT_SET
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000188ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_INT_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_INT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_INT_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000018ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_INT_REG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_INT_REG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000010ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_INT_REG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000010ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_MII_RX_DAT_SET
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_MII_RX_DAT_SET(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000190ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_MII_RX_DAT_SET
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000190ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_PRT_LOOP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_PRT_LOOP(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000040ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_PRT_LOOP
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000040ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_BYPASS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_BYPASS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000248ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_BYPASS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000248ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_BYPASS_SETTING
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_BYPASS_SETTING(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000250ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_BYPASS_SETTING
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000250ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_COMP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_COMP(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000220ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_COMP
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000220ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_DATA_DRV
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_DATA_DRV(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000218ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_DATA_DRV
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000218ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_FCRAM_MODE
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_FCRAM_MODE(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000210ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_FCRAM_MODE
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000210ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_NCTL_STRONG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_NCTL_STRONG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000230ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_NCTL_STRONG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000230ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_NCTL_WEAK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_NCTL_WEAK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000240ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_NCTL_WEAK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000240ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_PCTL_STRONG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_PCTL_STRONG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000228ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_PCTL_STRONG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000228ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_PCTL_WEAK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_PCTL_WEAK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000238ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_PCTL_WEAK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000238ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RLD_SETTING
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RLD_SETTING(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000258ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RLD_SETTING
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000258ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RX_CLK_SETX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RX_CLK_SETX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000020ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RX_CLK_SETX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000020ull) + (((offset)& 3) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RX_PRT_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RX_PRT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RX_PRT_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000000ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RX_WOL
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RX_WOL(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000100ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RX_WOL
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000100ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RX_WOL_MSK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RX_WOL_MSK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000108ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RX_WOL_MSK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000108ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RX_WOL_POWOK
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RX_WOL_POWOK(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000118ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RX_WOL_POWOK
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000118ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_RX_WOL_SIG
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_RX_WOL_SIG(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000110ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_RX_WOL_SIG
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000110ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_TX_CLK_SETX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_TX_CLK_SETX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_TX_CLK_SETX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000048ull) + (((offset)& 3) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_TX_COMP_BYP
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_TX_COMP_BYP(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000068ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_TX_COMP_BYP
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000068ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_TX_HI_WATERX
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|2
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_TX_HI_WATERX(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000080ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x1000000ull
operator|)
operator|*
literal|8
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_TX_HI_WATERX
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000080ull) + (((offset)& 3) + ((block_id)& 1) * 0x1000000ull) * 8)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ASXX_TX_PRT_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN30XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN31XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN38XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|==
literal|0
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ASXX_TX_PRT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800B0000008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ASXX_TX_PRT_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800B0000008ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_asx#_gmii_rx_clk_set  *  * ASX_GMII_RX_CLK_SET = GMII Clock delay setting  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_gmii_rx_clk_set
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_gmii_rx_clk_set_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< Setting to place on the RXCLK (GMII receive clk)                                                          delay line.  The intrinsic delay can range from                                                          50ps to 80ps per tap. */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_gmii_rx_clk_set_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_asxx_gmii_rx_clk_set_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_gmii_rx_clk_set_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_gmii_rx_clk_set
name|cvmx_asxx_gmii_rx_clk_set_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_gmii_rx_dat_set  *  * ASX_GMII_RX_DAT_SET = GMII Clock delay setting  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_gmii_rx_dat_set
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_gmii_rx_dat_set_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< Setting to place on the RXD (GMII receive data)                                                          delay lines.  The intrinsic delay can range from                                                          50ps to 80ps per tap. */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_gmii_rx_dat_set_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_asxx_gmii_rx_dat_set_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_gmii_rx_dat_set_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_gmii_rx_dat_set
name|cvmx_asxx_gmii_rx_dat_set_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_int_en  *  * ASX_INT_EN = Interrupt Enable  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_int_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|4
decl_stmt|;
comment|/**< TX FIFO overflow on RMGII port */
name|uint64_t
name|txpop
range|:
literal|4
decl_stmt|;
comment|/**< TX FIFO underflow on RMGII port */
name|uint64_t
name|ovrflw
range|:
literal|4
decl_stmt|;
comment|/**< RX FIFO overflow on RMGII port */
else|#
directive|else
name|uint64_t
name|ovrflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_int_en_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|3
decl_stmt|;
comment|/**< TX FIFO overflow on RMGII port */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|3
decl_stmt|;
comment|/**< TX FIFO underflow on RMGII port */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrflw
range|:
literal|3
decl_stmt|;
comment|/**< RX FIFO overflow on RMGII port */
else|#
directive|else
name|uint64_t
name|ovrflw
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_int_en_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_int_en_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_en_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_int_en
name|cvmx_asxx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_int_reg  *  * ASX_INT_REG = Interrupt Register  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_int_reg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_int_reg_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|4
decl_stmt|;
comment|/**< TX FIFO overflow on RMGII port */
name|uint64_t
name|txpop
range|:
literal|4
decl_stmt|;
comment|/**< TX FIFO underflow on RMGII port */
name|uint64_t
name|ovrflw
range|:
literal|4
decl_stmt|;
comment|/**< RX FIFO overflow on RMGII port */
else|#
directive|else
name|uint64_t
name|ovrflw
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_int_reg_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|3
decl_stmt|;
comment|/**< TX FIFO overflow on RMGII port */
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|3
decl_stmt|;
comment|/**< TX FIFO underflow on RMGII port */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ovrflw
range|:
literal|3
decl_stmt|;
comment|/**< RX FIFO overflow on RMGII port */
else|#
directive|else
name|uint64_t
name|ovrflw
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpop
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_7
range|:
literal|1
decl_stmt|;
name|uint64_t
name|txpsh
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_11_63
range|:
literal|53
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_int_reg_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_reg_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_reg_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_int_reg_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_reg_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_int_reg_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_int_reg
name|cvmx_asxx_int_reg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_mii_rx_dat_set  *  * ASX_MII_RX_DAT_SET = GMII Clock delay setting  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_mii_rx_dat_set
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_mii_rx_dat_set_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< Setting to place on the RXD (MII receive data)                                                          delay lines.  The intrinsic delay can range from                                                          50ps to 80ps per tap. */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_mii_rx_dat_set_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_asxx_mii_rx_dat_set_s
name|cn50xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_mii_rx_dat_set
name|cvmx_asxx_mii_rx_dat_set_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_prt_loop  *  * ASX_PRT_LOOP = Internal Loopback mode - TX FIFO output goes into RX FIFO (and maybe pins)  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_prt_loop
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_prt_loop_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|ext_loop
range|:
literal|4
decl_stmt|;
comment|/**< External Loopback Enable                                                          0 = No Loopback (TX FIFO is filled by RMGII)                                                          1 = RX FIFO drives the TX FIFO                                                              - GMX_PRT_CFG[DUPLEX] must be 1 (FullDuplex)                                                              - GMX_PRT_CFG[SPEED] must be 1  (GigE speed)                                                              - core clock> 250MHZ                                                              - rxc must not deviate from the +-50ppm                                                              - if txc>rxc, idle cycle may drop over time */
name|uint64_t
name|int_loop
range|:
literal|4
decl_stmt|;
comment|/**< Internal Loopback Enable                                                          0 = No Loopback (RX FIFO is filled by RMGII pins)                                                          1 = TX FIFO drives the RX FIFO                                                          Note, in internal loop-back mode, the RGMII link                                                          status is not used (since there is no real PHY).                                                          Software cannot use the inband status. */
else|#
directive|else
name|uint64_t
name|int_loop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ext_loop
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_prt_loop_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
name|uint64_t
name|ext_loop
range|:
literal|3
decl_stmt|;
comment|/**< External Loopback Enable                                                          0 = No Loopback (TX FIFO is filled by RMGII)                                                          1 = RX FIFO drives the TX FIFO                                                              - GMX_PRT_CFG[DUPLEX] must be 1 (FullDuplex)                                                              - GMX_PRT_CFG[SPEED] must be 1  (GigE speed)                                                              - core clock> 250MHZ                                                              - rxc must not deviate from the +-50ppm                                                              - if txc>rxc, idle cycle may drop over time */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|int_loop
range|:
literal|3
decl_stmt|;
comment|/**< Internal Loopback Enable                                                          0 = No Loopback (RX FIFO is filled by RMGII pins)                                                          1 = TX FIFO drives the RX FIFO                                                              - GMX_PRT_CFG[DUPLEX] must be 1 (FullDuplex)                                                              - GMX_PRT_CFG[SPEED] must be 1  (GigE speed)                                                              - GMX_TX_CLK[CLK_CNT] must be 1                                                          Note, in internal loop-back mode, the RGMII link                                                          status is not used (since there is no real PHY).                                                          Software cannot use the inband status. */
else|#
directive|else
name|uint64_t
name|int_loop
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_loop
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_7_63
range|:
literal|57
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_prt_loop_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_prt_loop_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_prt_loop_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_prt_loop_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_prt_loop_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_prt_loop_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_prt_loop
name|cvmx_asxx_prt_loop_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_bypass  *  * ASX_RLD_BYPASS  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_bypass
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_bypass_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
comment|/**< When set, the rld_dll setting is bypassed with                                                          ASX_RLD_BYPASS_SETTING */
else|#
directive|else
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_bypass_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_bypass_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_bypass_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_bypass_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_bypass
name|cvmx_asxx_rld_bypass_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_bypass_setting  *  * ASX_RLD_BYPASS_SETTING  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_bypass_setting
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_bypass_setting_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< The rld_dll setting bypass value */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_bypass_setting_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_bypass_setting_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_bypass_setting_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_bypass_setting_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_bypass_setting
name|cvmx_asxx_rld_bypass_setting_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_comp  *  * ASX_RLD_COMP  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_comp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_comp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< PCTL Compensation Value                                                          These bits reflect the computed compensation                                                           values from the built-in compensation circuit. */
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< These bits reflect the computed compensation                                                          values from the built-in compensation circuit. */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_rld_comp_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
comment|/**< These bits reflect the computed compensation                                                          values from the built-in compensation circuit. */
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< These bits reflect the computed compensation                                                          values from the built-in compensation circuit. */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_asxx_rld_comp_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_comp_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_comp_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_comp
name|cvmx_asxx_rld_comp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_data_drv  *  * ASX_RLD_DATA_DRV  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_data_drv
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_data_drv_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
comment|/**< These bits specify a driving strength (positive                                                          integer) for the RLD I/Os when the built-in                                                          compensation circuit is bypassed. */
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< These bits specify a driving strength (positive                                                          integer) for the RLD I/Os when the built-in                                                          compensation circuit is bypassed. */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_data_drv_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_data_drv_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_data_drv_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_data_drv_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_data_drv
name|cvmx_asxx_rld_data_drv_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_fcram_mode  *  * ASX_RLD_FCRAM_MODE  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_fcram_mode
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_fcram_mode_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
comment|/**< Memory Mode                                                          - 0: RLDRAM                                                          - 1: FCRAM */
else|#
directive|else
name|uint64_t
name|mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_fcram_mode_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_fcram_mode_s
name|cn38xxp2
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_fcram_mode
name|cvmx_asxx_rld_fcram_mode_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_nctl_strong  *  * ASX_RLD_NCTL_STRONG  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_nctl_strong
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_nctl_strong_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< Duke's drive control */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_nctl_strong_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_nctl_strong_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_nctl_strong_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_nctl_strong_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_nctl_strong
name|cvmx_asxx_rld_nctl_strong_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_nctl_weak  *  * ASX_RLD_NCTL_WEAK  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_nctl_weak
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_nctl_weak_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< UNUSED (not needed for CN58XX) */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_nctl_weak_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_nctl_weak_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_nctl_weak_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_nctl_weak_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_nctl_weak
name|cvmx_asxx_rld_nctl_weak_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_pctl_strong  *  * ASX_RLD_PCTL_STRONG  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_pctl_strong
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_pctl_strong_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< Duke's drive control */
else|#
directive|else
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_pctl_strong_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_pctl_strong_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_pctl_strong_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_pctl_strong_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_pctl_strong
name|cvmx_asxx_rld_pctl_strong_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_pctl_weak  *  * ASX_RLD_PCTL_WEAK  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_pctl_weak
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_pctl_weak_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< UNUSED (not needed for CN58XX) */
else|#
directive|else
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rld_pctl_weak_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_pctl_weak_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_pctl_weak_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_pctl_weak_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_pctl_weak
name|cvmx_asxx_rld_pctl_weak_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rld_setting  *  * ASX_RLD_SETTING  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rld_setting
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rld_setting_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|dfaset
range|:
literal|5
decl_stmt|;
comment|/**< RLD ClkGen DLL Setting(debug) */
name|uint64_t
name|dfalag
range|:
literal|1
decl_stmt|;
comment|/**< RLD ClkGen DLL Lag Error(debug) */
name|uint64_t
name|dfalead
range|:
literal|1
decl_stmt|;
comment|/**< RLD ClkGen DLL Lead Error(debug) */
name|uint64_t
name|dfalock
range|:
literal|1
decl_stmt|;
comment|/**< RLD ClkGen DLL Lock acquisition(debug) */
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< RLDCK90 DLL Setting(debug) */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dfalock
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfalead
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfalag
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dfaset
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_rld_setting_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< This is the read-only true rld dll_setting. */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_asxx_rld_setting_cn38xx
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rld_setting_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rld_setting_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rld_setting
name|cvmx_asxx_rld_setting_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rx_clk_set#  *  * ASX_RX_CLK_SET = RGMII Clock delay setting  *  *  * Notes:  * Setting to place on the open-loop RXC (RGMII receive clk)  * delay line, which can delay the recieved clock. This  * can be used if the board and/or transmitting device  * has not otherwise delayed the clock.  *  * A value of SETTING=0 disables the delay line. The delay  * line should be disabled unless the transmitter or board  * does not delay the clock.  *  * Note that this delay line provides only a coarse control  * over the delay. Generally, it can only reliably provide  * a delay in the range 1.25-2.5ns, which may not be adequate  * for some system applications.  *  * The open loop delay line selects  * from among a series of tap positions. Each incremental  * tap position adds a delay of 50ps to 135ps per tap, depending  * on the chip, its temperature, and the voltage.  * To achieve from 1.25-2.5ns of delay on the recieved  * clock, a fixed value of SETTING=24 may work.  * For more precision, we recommend the following settings  * based on the chip voltage:  *  *    VDD           SETTING  *  -----------------------------  *    1.0             18  *    1.05            19  *    1.1             21  *    1.15            22  *    1.2             23  *    1.25            24  *    1.3             25  */
end_comment

begin_union
union|union
name|cvmx_asxx_rx_clk_setx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rx_clk_setx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< Setting to place on the open-loop RXC delay line */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_clk_setx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rx_clk_setx
name|cvmx_asxx_rx_clk_setx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rx_prt_en  *  * ASX_RX_PRT_EN = RGMII Port Enable  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rx_prt_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rx_prt_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|prt_en
range|:
literal|4
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to receive                                                          RMGII traffic.  When this bit clear on a given                                                          port, then the all RGMII cycles will appear as                                                          inter-frame cycles. */
else|#
directive|else
name|uint64_t
name|prt_en
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_rx_prt_en_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|prt_en
range|:
literal|3
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to receive                                                          RMGII traffic.  When this bit clear on a given                                                          port, then the all RGMII cycles will appear as                                                          inter-frame cycles. */
else|#
directive|else
name|uint64_t
name|prt_en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_rx_prt_en_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_prt_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_prt_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_rx_prt_en_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_prt_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_prt_en_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rx_prt_en
name|cvmx_asxx_rx_prt_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rx_wol  *  * ASX_RX_WOL = RGMII RX Wake on LAN status register  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rx_wol
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rx_wol_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
comment|/**< Copy of PMCSR[15] - PME_status */
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
comment|/**< Copy of PMCSR[8]  - PME_enable */
else|#
directive|else
name|uint64_t
name|enable
range|:
literal|1
decl_stmt|;
name|uint64_t
name|status
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rx_wol_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_wol_s
name|cn38xxp2
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rx_wol
name|cvmx_asxx_rx_wol_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rx_wol_msk  *  * ASX_RX_WOL_MSK = RGMII RX Wake on LAN byte mask  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rx_wol_msk
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rx_wol_msk_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|msk
range|:
literal|64
decl_stmt|;
comment|/**< Bytes to include in the CRC signature */
else|#
directive|else
name|uint64_t
name|msk
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rx_wol_msk_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_wol_msk_s
name|cn38xxp2
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rx_wol_msk
name|cvmx_asxx_rx_wol_msk_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rx_wol_powok  *  * ASX_RX_WOL_POWOK = RGMII RX Wake on LAN Power OK  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rx_wol_powok
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rx_wol_powok_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|powerok
range|:
literal|1
decl_stmt|;
comment|/**< Power OK */
else|#
directive|else
name|uint64_t
name|powerok
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rx_wol_powok_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_wol_powok_s
name|cn38xxp2
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rx_wol_powok
name|cvmx_asxx_rx_wol_powok_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_rx_wol_sig  *  * ASX_RX_WOL_SIG = RGMII RX Wake on LAN CRC signature  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_rx_wol_sig
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_rx_wol_sig_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|sig
range|:
literal|32
decl_stmt|;
comment|/**< CRC signature */
else|#
directive|else
name|uint64_t
name|sig
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_rx_wol_sig_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_rx_wol_sig_s
name|cn38xxp2
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_rx_wol_sig
name|cvmx_asxx_rx_wol_sig_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_tx_clk_set#  *  * ASX_TX_CLK_SET = RGMII Clock delay setting  *  *  * Notes:  * Setting to place on the open-loop TXC (RGMII transmit clk)  * delay line, which can delay the transmited clock. This  * can be used if the board and/or transmitting device  * has not otherwise delayed the clock.  *  * A value of SETTING=0 disables the delay line. The delay  * line should be disabled unless the transmitter or board  * does not delay the clock.  *  * Note that this delay line provides only a coarse control  * over the delay. Generally, it can only reliably provide  * a delay in the range 1.25-2.5ns, which may not be adequate  * for some system applications.  *  * The open loop delay line selects  * from among a series of tap positions. Each incremental  * tap position adds a delay of 50ps to 135ps per tap, depending  * on the chip, its temperature, and the voltage.  * To achieve from 1.25-2.5ns of delay on the recieved  * clock, a fixed value of SETTING=24 may work.  * For more precision, we recommend the following settings  * based on the chip voltage:  *  *    VDD           SETTING  *  -----------------------------  *    1.0             18  *    1.05            19  *    1.1             21  *    1.15            22  *    1.2             23  *    1.25            24  *    1.3             25  */
end_comment

begin_union
union|union
name|cvmx_asxx_tx_clk_setx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_tx_clk_setx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
comment|/**< Setting to place on the open-loop TXC delay line */
else|#
directive|else
name|uint64_t
name|setting
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn30xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_clk_setx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_tx_clk_setx
name|cvmx_asxx_tx_clk_setx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_tx_comp_byp  *  * ASX_TX_COMP_BYP = RGMII Clock delay setting  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_tx_comp_byp
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_tx_comp_byp_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_tx_comp_byp_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
comment|/**< Compensation bypass */
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
comment|/**< PCTL Compensation Value (see Duke) */
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< NCTL Compensation Value (see Duke) */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_tx_comp_byp_cn30xx
name|cn31xx
decl_stmt|;
struct|struct
name|cvmx_asxx_tx_comp_byp_cn38xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
comment|/**< PCTL Compensation Value (see Duke) */
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
comment|/**< NCTL Compensation Value (see Duke) */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn38xx
struct|;
name|struct
name|cvmx_asxx_tx_comp_byp_cn38xx
name|cn38xxp2
decl_stmt|;
struct|struct
name|cvmx_asxx_tx_comp_byp_cn50xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
comment|/**< Compensation bypass */
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< PCTL Compensation Value (see Duke) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< NCTL Compensation Value (see Duke) */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_15
range|:
literal|3
decl_stmt|;
name|uint64_t
name|bypass
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|cn50xx
struct|;
struct|struct
name|cvmx_asxx_tx_comp_byp_cn58xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
comment|/**< PCTL Compensation Value (see Duke) */
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
comment|/**< NCTL Compensation Value (see Duke) */
else|#
directive|else
name|uint64_t
name|nctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_5_7
range|:
literal|3
decl_stmt|;
name|uint64_t
name|pctl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|cn58xx
struct|;
name|struct
name|cvmx_asxx_tx_comp_byp_cn58xx
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_tx_comp_byp
name|cvmx_asxx_tx_comp_byp_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_tx_hi_water#  *  * ASX_TX_HI_WATER = RGMII TX FIFO Hi WaterMark  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_tx_hi_waterx
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_tx_hi_waterx_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|4
decl_stmt|;
comment|/**< TX FIFO HiWatermark to stall GMX                                                          Value of 0 maps to 16                                                          Reset value changed from 10 in pass1                                                          Pass1 settings (assuming 125 tclk)                                                          - 325-375: 12                                                          - 375-437: 11                                                          - 437-550: 10                                                          - 550-687:  9 */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_tx_hi_waterx_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|mark
range|:
literal|3
decl_stmt|;
comment|/**< TX FIFO HiWatermark to stall GMX                                                          Value 0 maps to 8. */
else|#
directive|else
name|uint64_t
name|mark
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_tx_hi_waterx_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_hi_waterx_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_hi_waterx_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_tx_hi_waterx_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_hi_waterx_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_hi_waterx_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_tx_hi_waterx
name|cvmx_asxx_tx_hi_waterx_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_asx#_tx_prt_en  *  * ASX_TX_PRT_EN = RGMII Port Enable  *  */
end_comment

begin_union
union|union
name|cvmx_asxx_tx_prt_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_asxx_tx_prt_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|prt_en
range|:
literal|4
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to send                                                          RMGII traffic.   When this bit clear on a given                                                          port, then all RGMII cycles will appear as                                                          inter-frame cycles. */
else|#
directive|else
name|uint64_t
name|prt_en
range|:
literal|4
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_asxx_tx_prt_en_cn30xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|prt_en
range|:
literal|3
decl_stmt|;
comment|/**< Port enable.  Must be set for Octane to send                                                          RMGII traffic.   When this bit clear on a given                                                          port, then all RGMII cycles will appear as                                                          inter-frame cycles. */
else|#
directive|else
name|uint64_t
name|prt_en
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|cn30xx
struct|;
name|struct
name|cvmx_asxx_tx_prt_en_cn30xx
name|cn31xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_prt_en_s
name|cn38xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_prt_en_s
name|cn38xxp2
decl_stmt|;
name|struct
name|cvmx_asxx_tx_prt_en_cn30xx
name|cn50xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_prt_en_s
name|cn58xx
decl_stmt|;
name|struct
name|cvmx_asxx_tx_prt_en_s
name|cn58xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_asxx_tx_prt_en
name|cvmx_asxx_tx_prt_en_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

