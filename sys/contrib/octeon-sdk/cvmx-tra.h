begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the Trace buffer hardware.  *  * WRITING THE TRACE BUFFER  *  * When the trace is enabled, commands are traced continuously (wrapping) or until the buffer is filled once  * (no wrapping).  Additionally and independent of wrapping, tracing can be temporarily enabled and disabled  * by the tracing triggers.  All XMC commands can be traced except for IDLE and IOBRSP.  The subset of XMC  * commands that are traced is determined by the filter and the two triggers, each of which is comprised of  * masks for command, sid, did, and address).  If triggers are disabled, then only those commands matching  * the filter are traced.  If triggers are enabled, then only those commands matching the filter, the start  * trigger, or the stop trigger are traced during the time between a start trigger and a stop trigger.  *  * For a given command, its XMC data is written immediately to the buffer.  If the command has XMD data,  * then that data comes in-order at some later time.  The XMD data is accumulated across all valid  * XMD cycles and written to the buffer or to a shallow fifo.  Data from the fifo is written to the buffer  * as soon as it gets access to write the buffer (i.e. the buffer is not currently being written with XMC  * data).  If the fifo overflows, it simply overwrites itself and the previous XMD data is lost.  *  *  * READING THE TRACE BUFFER  *  * Each entry of the trace buffer is read by a CSR read command.  The trace buffer services each read in order,  * as soon as it has access to the (single-ported) trace buffer.  *  *  * OVERFLOW, UNDERFLOW AND THRESHOLD EVENTS  *  * The trace buffer maintains a write pointer and a read pointer and detects both the overflow and underflow  * conditions.  Each time a new trace is enabled, both pointers are reset to entry 0.  Normally, each write  * (traced event) increments the write pointer and each read increments the read pointer.  During the overflow  * condition, writing (tracing) is disabled.  Tracing will continue as soon as the overflow condition is  * resolved.  The first entry that is written immediately following the overflow condition may be marked to  * indicate that a tracing discontinuity has occurred before this entry.  During the underflow condition,  * reading does not increment the read pointer and the read data is marked to indicate that no read data is  * available.  *  * The full threshold events are defined to signal an interrupt a certain levels of "fullness" (1/2, 3/4, 4/4).  * "fullness" is defined as the relative distance between the write and read pointers (i.e. not defined as the  * absolute distance between the write pointer and entry 0).  When enabled, the full threshold event occurs  * every time the desired level of "fullness" is achieved.  *  *  * Trace buffer entry format  * @verbatim  *       6                   5                   4                   3                   2                   1                   0  * 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | DWB   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | PL2   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | PSL1  | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | LDD   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | LDI   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | LDT   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STC   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STF   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STP   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STT   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:0]                                |    0    | src id| dest id |IOBLD8 | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:1]                              |     0     | src id| dest id |IOBLD16| diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:2]                            |      0      | src id| dest id |IOBLD32| diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id| dest id |IOBLD64| diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id| dest id |IOBST  | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                     * or address[35:3]                          | * or length   | src id| dest id |IOBDMA | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  *  * notes:  * - Fields marked as '*' are first filled with '0' at XMC time and may be filled with real data later at XMD time.  Note that the  * XMD write may be dropped if the shallow FIFO overflows which leaves the '*' fields as '0'.  * - 2 bits (sta) are used not to trace, but to return global state information with each read, encoded as follows:  * 0x0-0x1=not valid  * 0x2=valid, no discontinuity  * 0x3=valid,    discontinuity  * - commands are encoded as follows:  * 0x0=DWB  * 0x1=PL2  * 0x2=PSL1  * 0x3=LDD  * 0x4=LDI  * 0x5=LDT  * 0x6=STC  * 0x7=STF  * 0x8=STP  * 0x9=STT  * 0xa=IOBLD8  * 0xb=IOBLD16  * 0xc=IOBLD32  * 0xd=IOBLD64  * 0xe=IOBST  * 0xf=IOBDMA  * - For non IOB* commands  * - source id is encoded as follows:  * 0x00-0x0f=PP[n]  * 0x10=IOB(Packet)  * 0x11=IOB(PKO)  * 0x12=IOB(ReqLoad, ReqStore)  * 0x13=IOB(DWB)  * 0x14-0x1e=illegal  * 0x1f=IOB(generic)  * - dest   id is unused (can only be L2c)  * - For IOB* commands  * - source id is encoded as follows:  * 0x00-0x0f = PP[n]  * - dest   id is encoded as follows:  * 0x00-0x0f=PP[n]  * 0x10=IOB(Packet)  * 0x11=IOB(PKO)  * 0x12=IOB(ReqLoad, ReqStore)  * 0x13=IOB(DWB)  * 0x14-0x1e=illegal  * 0x1f=IOB(generic)  *  * Source of data for each command  * command source id    dest id      address                 length/mask  * -------+------------+------------+-----------------------+----------------------------------------------  * LDI     xmc_sid[8:3] x            xmc_adr[35:3]           x  * LDT     xmc_sid[8:3] x            xmc_adr[35:3]           x  * STF     xmc_sid[8:3] x            xmc_adr[35:3]           16B mask(xmd_[wrval,eow,adr[6:4],wrmsk[15:0]])  * STC     xmc_sid[8:3] x            xmc_adr[35:3]           16B mask(xmd_[wrval,eow,adr[6:4],wrmsk[15:0]])  * STP     xmc_sid[8:3] x            xmc_adr[35:3]           16B mask(xmd_[wrval,eow,adr[6:4],wrmsk[15:0]])  * STT     xmc_sid[8:3] x            xmc_adr[35:3]           16B mask(xmd_[wrval,eow,adr[6:4],wrmsk[15:0]])  * DWB     xmc_sid[8:3] x            xmc_adr[35:3]           x  * PL2     xmc_sid[8:3] x            xmc_adr[35:3]           x  * PSL1    xmc_sid[8:3] x            xmc_adr[35:3]           x  * IOBLD8  xmc_sid[8:3] xmc_did[8:3] xmc_adr[35:0]           x  * IOBLD16 xmc_sid[8:3] xmc_did[8:3] xmc_adr[35:1]           x  * IOBLD32 xmc_sid[8:3] xmc_did[8:3] xmc_adr[35:2]           x  * IOBLD64 xmc_sid[8:3] xmc_did[8:3] xmc_adr[35:3]           x  * IOBST   xmc_sid[8:3] xmc_did[8:3] xmc_adr[35:3]           16B mask(xmd_[wrval,eow,adr[6:4],wrmsk[15:0]])  * IOBDMA  xmc_sid[8:3] xmc_did[8:3] (xmd_[wrval,eow,dat[]]) length(xmd_[wrval,eow,dat[]])  * IOBRSP  not traced, but monitored to keep XMC and XMD data in sync.  * @endverbatim  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_TRA_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_TRA_H__
end_define

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* CSR typedefs have been moved to cvmx-csr-*.h */
comment|/**  * Enumeration of the data types stored in cvmx_tra_data_t  */
typedef|typedef
enum|enum
block|{
name|CVMX_TRA_DATA_DWB
init|=
literal|0x0
block|,
name|CVMX_TRA_DATA_PL2
init|=
literal|0x1
block|,
name|CVMX_TRA_DATA_PSL1
init|=
literal|0x2
block|,
name|CVMX_TRA_DATA_LDD
init|=
literal|0x3
block|,
name|CVMX_TRA_DATA_LDI
init|=
literal|0x4
block|,
name|CVMX_TRA_DATA_LDT
init|=
literal|0x5
block|,
name|CVMX_TRA_DATA_STC
init|=
literal|0x6
block|,
name|CVMX_TRA_DATA_STF
init|=
literal|0x7
block|,
name|CVMX_TRA_DATA_STP
init|=
literal|0x8
block|,
name|CVMX_TRA_DATA_STT
init|=
literal|0x9
block|,
name|CVMX_TRA_DATA_IOBLD8
init|=
literal|0xa
block|,
name|CVMX_TRA_DATA_IOBLD16
init|=
literal|0xb
block|,
name|CVMX_TRA_DATA_IOBLD32
init|=
literal|0xc
block|,
name|CVMX_TRA_DATA_IOBLD64
init|=
literal|0xd
block|,
name|CVMX_TRA_DATA_IOBST
init|=
literal|0xe
block|,
name|CVMX_TRA_DATA_IOBDMA
init|=
literal|0xf
block|,
name|CVMX_TRA_DATA_SAA
init|=
literal|0x10
block|, }
name|cvmx_tra_data_type_t
typedef|;
comment|/**  * TRA data format definition. Use the type field to  * determine which union element to use.  */
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|cvmx_tra_data_type_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|cvmx_tra_data_type_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|5
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cmn
struct|;
comment|/**< for DWB, PL2, PSL1, LDD, LDI, LDT */
struct|struct
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|cvmx_tra_data_type_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|cvmx_tra_data_type_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|store
struct|;
comment|/**< STC, STF, STP, STT */
struct|struct
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|subid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|subid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|iobld
struct|;
comment|/**< for IOBLD8, IOBLD16, IOBLD32, IOBLD64, IOBST, SAA */
struct|struct
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|iob
struct|;
comment|/**< for IOBDMA */
block|}
name|cvmx_tra_data_t
typedef|;
comment|/**  * Setup the TRA buffer for use  *  * @param control TRA control setup  * @param filter  Which events to log  * @param source_filter  *                Source match  * @param dest_filter  *                Destination match  * @param address Address compare  * @param address_mask  *                Address mask  */
specifier|extern
name|void
name|cvmx_tra_setup
parameter_list|(
name|cvmx_tra_ctl_t
name|control
parameter_list|,
name|cvmx_tra_filt_cmd_t
name|filter
parameter_list|,
name|cvmx_tra_filt_sid_t
name|source_filter
parameter_list|,
name|cvmx_tra_filt_did_t
name|dest_filter
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|address_mask
parameter_list|)
function_decl|;
comment|/**  * Setup a TRA trigger. How the triggers are used should be  * setup using cvmx_tra_setup.  *  * @param trigger Trigger to setup (0 or 1)  * @param filter  Which types of events to trigger on  * @param source_filter  *                Source trigger match  * @param dest_filter  *                Destination trigger match  * @param address Trigger address compare  * @param address_mask  *                Trigger address mask  */
specifier|extern
name|void
name|cvmx_tra_trig_setup
parameter_list|(
name|uint64_t
name|trigger
parameter_list|,
name|cvmx_tra_filt_cmd_t
name|filter
parameter_list|,
name|cvmx_tra_filt_sid_t
name|source_filter
parameter_list|,
name|cvmx_tra_trig0_did_t
name|dest_filter
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|address_mask
parameter_list|)
function_decl|;
comment|/**  * Read an entry from the TRA buffer  *  * @return Value return. High bit will be zero if there wasn't any data  */
specifier|extern
name|cvmx_tra_data_t
name|cvmx_tra_read
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Decode a TRA entry into human readable output  *  * @param tra_ctl Trace control setup  * @param data    Data to decode  */
specifier|extern
name|void
name|cvmx_tra_decode_text
parameter_list|(
name|cvmx_tra_ctl_t
name|tra_ctl
parameter_list|,
name|cvmx_tra_data_t
name|data
parameter_list|)
function_decl|;
comment|/**  * Display the entire trace buffer. It is advised that you  * disable the trace buffer before calling this routine  * otherwise it could infinitely loop displaying trace data  * that it created.  */
specifier|extern
name|void
name|cvmx_tra_display
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Enable or disable the TRA hardware  *  * @param enable 1=enable, 0=disable  */
specifier|static
specifier|inline
name|void
name|cvmx_tra_enable
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|cvmx_tra_ctl_t
name|control
decl_stmt|;
name|control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TRA_CTL
argument_list|)
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|ena
operator|=
name|enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TRA_CTL
argument_list|,
name|control
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_TRA_CTL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

