begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to the Trace buffer hardware.  *  * WRITING THE TRACE BUFFER  *  * When the trace is enabled, commands are traced continuously (wrapping) or until the buffer is filled once  * (no wrapping).  Additionally and independent of wrapping, tracing can be temporarily enabled and disabled  * by the tracing triggers.  All XMC commands can be traced except for IDLE and IOBRSP.  The subset of XMC  * commands that are traced is determined by the filter and the two triggers, each of which is comprised of  * masks for command, sid, did, and address).  If triggers are disabled, then only those commands matching  * the filter are traced.  If triggers are enabled, then only those commands matching the filter, the start  * trigger, or the stop trigger are traced during the time between a start trigger and a stop trigger.  *  * For a given command, its XMC data is written immediately to the buffer.  If the command has XMD data,  * then that data comes in-order at some later time.  The XMD data is accumulated across all valid  * XMD cycles and written to the buffer or to a shallow fifo.  Data from the fifo is written to the buffer  * as soon as it gets access to write the buffer (i.e. the buffer is not currently being written with XMC  * data).  If the fifo overflows, it simply overwrites itself and the previous XMD data is lost.  *  *  * READING THE TRACE BUFFER  *  * Each entry of the trace buffer is read by a CSR read command.  The trace buffer services each read in order,  * as soon as it has access to the (single-ported) trace buffer.  *  * On Octeon2, each entry of the trace buffer is read by two CSR memory read operations.  The first read accesses  * bits 63:0 of the buffer entry, and the second read accesses bits 68:64 of the buffer entry. The trace buffer  * services each read in order, as soon as it has access to the (single-ported) trace buffer.  Buffer's read pointer  * increments after two CSR memory read operations.  *  *  * OVERFLOW, UNDERFLOW AND THRESHOLD EVENTS  *  * The trace buffer maintains a write pointer and a read pointer and detects both the overflow and underflow  * conditions.  Each time a new trace is enabled, both pointers are reset to entry 0.  Normally, each write  * (traced event) increments the write pointer and each read increments the read pointer.  During the overflow  * condition, writing (tracing) is disabled.  Tracing will continue as soon as the overflow condition is  * resolved.  The first entry that is written immediately following the overflow condition may be marked to  * indicate that a tracing discontinuity has occurred before this entry.  During the underflow condition,  * reading does not increment the read pointer and the read data is marked to indicate that no read data is  * available.  *  * The full threshold events are defined to signal an interrupt a certain levels of "fullness" (1/2, 3/4, 4/4).  * "fullness" is defined as the relative distance between the write and read pointers (i.e. not defined as the  * absolute distance between the write pointer and entry 0).  When enabled, the full threshold event occurs  * every time the desired level of "fullness" is achieved.  *  *  * Trace buffer entry format  * @verbatim  *       6                   5                   4                   3                   2                   1                   0  * 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | DWB   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | PL2   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | PSL1  | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | LDD   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | LDI   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id  |   0   | LDT   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STC   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STF   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STP   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id  |   0   | STT   | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:0]                                |    0    | src id| dest id |IOBLD8 | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:1]                              |     0     | src id| dest id |IOBLD16| diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:2]                            |      0      | src id| dest id |IOBLD32| diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          |       0       | src id| dest id |IOBLD64| diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[35:3]                          | * or 16B mask | src id| dest id |IOBST  | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                     * or address[35:3]                          | * or length   | src id| dest id |IOBDMA | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  *  *  * Trace buffer entry format in Octeon2 is different  *  *                 6                   5                   4                   3                   2                   1                   0  * 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[37:0]                                  |       0           |  src id |  Group 1    | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[37:0]                                  | 0 |  xmd mask     |  src id |  Group 2    | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                          address[37:0]                                  | 0 |s-did| dest id |  src id |  Group 3    | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  * |sta|                         *address[37:3]                            | *Length       | dest id |  src id |  Group 4    | diff timestamp|  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+  *  * notes:  * - diff timestamp is the difference in time from the previous trace event to this event - 1.  the granularity of the timestamp is programmable  * - Fields marked as '*' are first filled with '0' at XMC time and may be filled with real data later at XMD time.  Note that the  * XMD write may be dropped if the shallow FIFO overflows which leaves the '*' fields as '0'.  * - 2 bits (sta) are used not to trace, but to return global state information with each read, encoded as follows:  * 0x0=not valid  * 0x1=valid, no discontinuity  * 0x2=not valid, discontinuity  * 0x3=valid, discontinuity  * - commands are encoded as follows:  * 0x0=DWB  * 0x1=PL2  * 0x2=PSL1  * 0x3=LDD  * 0x4=LDI  * 0x5=LDT  * 0x6=STF  * 0x7=STC  * 0x8=STP  * 0x9=STT  * 0xa=IOBLD8  * 0xb=IOBLD16  * 0xc=IOBLD32  * 0xd=IOBLD64  * 0xe=IOBST  * 0xf=IOBDMA  * - In Octeon2 the commands are grouped as follows:  * Group1:  *   XMC_LDT, XMC_LDI, XMC_PL2, XMC_RPL2, XMC_DWB, XMC_WBL2,  *   XMC_SET8, XMC_SET16, XMC_SET32, XMC_SET64,  *   XMC_CLR8, XMC_CLR16, XMC_CLR32, XMC_CLR64,  *   XMC_INCR8, XMC_INCR16, XMC_INCR32, XMC_INCR64,  *   XMC_DECR8, XMC_DECR16, XMC_DECR32, XMC_DECR64  * Group2:  *   XMC_STF, XMC_STT, XMC_STP, XMC_STC,  *   XMC_LDD, XMC_PSL1  *   XMC_SAA32, XMC_SAA64,  *   XMC_FAA32, XMC_FAA64,  *   XMC_FAS32, XMC_FAS64  * Group3:  *   XMC_IOBLD8, XMC_IOBLD16, XMC_IOBLD32, XMC_IOBLD64,  *   XMC_IOBST8, XMC_IOBST16, XMC_IOBST32, XMC_IOBST64  * Group4:  *   XMC_IOBDMA  * - For non IOB* commands  * - source id is encoded as follows:  * 0x00-0x0f=PP[n]  * 0x10=IOB(Packet)  * 0x11=IOB(PKO)  * 0x12=IOB(ReqLoad, ReqStore)  * 0x13=IOB(DWB)  * 0x14-0x1e=illegal  * 0x1f=IOB(generic)  * - dest id is unused (can only be L2c)  * - For IOB* commands  * - source id is encoded as follows:  * 0x00-0x0f = PP[n]  * - dest   id is encoded as follows:  * 0   = CIU/GPIO (for CSRs)  * 1-2 = illegal  * 3   = PCIe (access to RSL-type CSRs)  * 4   = KEY (read/write operations)  * 5   = FPA (free pool allocate/free operations)  * 6   = DFA  * 7   = ZIP (doorbell operations)  * 8   = RNG (load/IOBDMA operations)  * 10  = PKO (doorbell operations)  * 11  = illegal  * 12  = POW (get work, add work, status/memory/index loads, NULLrd load operations, CSR operations)  * 13-31 = illegal  * @endverbatim  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_TRA_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_TRA_H__
end_define

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-l2c.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|"cvmx-tra-defs.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* CSR typedefs have been moved to cvmx-tra-defs.h */
comment|/* The 'saa' filter command is renamed as 'saa64' */
define|#
directive|define
name|CVMX_TRA_FILT_SAA
value|CVMX_TRA_FILT_SAA64
comment|/* The 'iobst' filter command is renamed as 'iobst64' */
define|#
directive|define
name|CVMX_TRA_FILT_IOBST
value|CVMX_TRA_FILT_IOBST64
comment|/**  * Enumeration of the bitmask of all the filter commands. The bit positions  * correspond to Octeon2 model.  */
typedef|typedef
enum|enum
block|{
name|CVMX_TRA_FILT_NOP
init|=
literal|1ull
operator|<<
literal|0
block|,
comment|/**< none */
name|CVMX_TRA_FILT_LDT
init|=
literal|1ull
operator|<<
literal|1
block|,
comment|/**< don't allocate L2 or L1 */
name|CVMX_TRA_FILT_LDI
init|=
literal|1ull
operator|<<
literal|2
block|,
comment|/**< don't allocate L1 */
name|CVMX_TRA_FILT_PL2
init|=
literal|1ull
operator|<<
literal|3
block|,
comment|/**< pref L2 */
name|CVMX_TRA_FILT_RPL2
init|=
literal|1ull
operator|<<
literal|4
block|,
comment|/**< mark for replacement in L2 */
name|CVMX_TRA_FILT_DWB
init|=
literal|1ull
operator|<<
literal|5
block|,
comment|/**< clear L2 dirty bit (no writeback) + RPL2 */
name|CVMX_TRA_FILT_LDD
init|=
literal|1ull
operator|<<
literal|8
block|,
comment|/**< normal load */
name|CVMX_TRA_FILT_PSL1
init|=
literal|1ull
operator|<<
literal|9
block|,
comment|/**< pref L1, bypass L2 */
name|CVMX_TRA_FILT_IOBDMA
init|=
literal|1ull
operator|<<
literal|15
block|,
comment|/**< store reflection by IOB for prior load */
name|CVMX_TRA_FILT_STF
init|=
literal|1ull
operator|<<
literal|16
block|,
comment|/**< full block store to L2, fill 0's */
name|CVMX_TRA_FILT_STT
init|=
literal|1ull
operator|<<
literal|17
block|,
comment|/**< full block store bypass-L2, fill 0's */
name|CVMX_TRA_FILT_STP
init|=
literal|1ull
operator|<<
literal|18
block|,
comment|/**< partial store to L2 */
name|CVMX_TRA_FILT_STC
init|=
literal|1ull
operator|<<
literal|19
block|,
comment|/**< partial store to L2, if duptag valid */
name|CVMX_TRA_FILT_STFIL1
init|=
literal|1ull
operator|<<
literal|20
block|,
comment|/**< full block store to L2, fill 0's, invalidate L1 */
name|CVMX_TRA_FILT_STTIL1
init|=
literal|1ull
operator|<<
literal|21
block|,
comment|/**< full block store bypass-L2, fill 0's, invalidate L1 */
name|CVMX_TRA_FILT_FAS32
init|=
literal|1ull
operator|<<
literal|22
block|,
comment|/**< to load from and write a word of memory atomically */
name|CVMX_TRA_FILT_FAS64
init|=
literal|1ull
operator|<<
literal|23
block|,
comment|/**< to load from and write a doubleword of memory atomically */
name|CVMX_TRA_FILT_WBIL2I
init|=
literal|1ull
operator|<<
literal|24
block|,
comment|/**< writeback if dirty, invalidate, clear use bit, by index/way */
name|CVMX_TRA_FILT_LTGL2I
init|=
literal|1ull
operator|<<
literal|25
block|,
comment|/**< read tag @ index/way into CSR */
name|CVMX_TRA_FILT_STGL2I
init|=
literal|1ull
operator|<<
literal|26
block|,
comment|/**< write tag @ index/way from CSR */
name|CVMX_TRA_FILT_INVL2
init|=
literal|1ull
operator|<<
literal|28
block|,
comment|/**< invalidate, clear use bit, by address (dirty data is LOST) */
name|CVMX_TRA_FILT_WBIL2
init|=
literal|1ull
operator|<<
literal|29
block|,
comment|/**< writeback if dirty, invalidate, clear use bit, by address */
name|CVMX_TRA_FILT_WBL2
init|=
literal|1ull
operator|<<
literal|30
block|,
comment|/**< writeback if dirty, make clean, clear use bit, by address */
name|CVMX_TRA_FILT_LCKL2
init|=
literal|1ull
operator|<<
literal|31
block|,
comment|/**< allocate (if miss), set lock bit, set use bit, by address */
name|CVMX_TRA_FILT_IOBLD8
init|=
literal|1ull
operator|<<
literal|32
block|,
comment|/**< load reflection 8bit */
name|CVMX_TRA_FILT_IOBLD16
init|=
literal|1ull
operator|<<
literal|33
block|,
comment|/**< load reflection 16bit */
name|CVMX_TRA_FILT_IOBLD32
init|=
literal|1ull
operator|<<
literal|34
block|,
comment|/**< load reflection 32bit */
name|CVMX_TRA_FILT_IOBLD64
init|=
literal|1ull
operator|<<
literal|35
block|,
comment|/**< load reflection 64bit */
name|CVMX_TRA_FILT_IOBST8
init|=
literal|1ull
operator|<<
literal|36
block|,
comment|/**< store reflection 8bit */
name|CVMX_TRA_FILT_IOBST16
init|=
literal|1ull
operator|<<
literal|37
block|,
comment|/**< store reflection 16bit */
name|CVMX_TRA_FILT_IOBST32
init|=
literal|1ull
operator|<<
literal|38
block|,
comment|/**< store reflection 32bit */
name|CVMX_TRA_FILT_IOBST64
init|=
literal|1ull
operator|<<
literal|39
block|,
comment|/**< store reflection 64bit */
name|CVMX_TRA_FILT_SET8
init|=
literal|1ull
operator|<<
literal|40
block|,
comment|/**< to load from and write 1's to 8bit of memory atomically */
name|CVMX_TRA_FILT_SET16
init|=
literal|1ull
operator|<<
literal|41
block|,
comment|/**< to load from and write 1's to 16bit of memory atomically */
name|CVMX_TRA_FILT_SET32
init|=
literal|1ull
operator|<<
literal|42
block|,
comment|/**< to load from and write 1's to 32bit of memory atomically */
name|CVMX_TRA_FILT_SET64
init|=
literal|1ull
operator|<<
literal|43
block|,
comment|/**< to load from and write 1's to 64bit of memory atomically */
name|CVMX_TRA_FILT_CLR8
init|=
literal|1ull
operator|<<
literal|44
block|,
comment|/**< to load from and write 0's to 8bit of memory atomically */
name|CVMX_TRA_FILT_CLR16
init|=
literal|1ull
operator|<<
literal|45
block|,
comment|/**< to load from and write 0's to 16bit of memory atomically */
name|CVMX_TRA_FILT_CLR32
init|=
literal|1ull
operator|<<
literal|46
block|,
comment|/**< to load from and write 0's to 32bit of memory atomically */
name|CVMX_TRA_FILT_CLR64
init|=
literal|1ull
operator|<<
literal|47
block|,
comment|/**< to load from and write 0's to 64bit of memory atomically */
name|CVMX_TRA_FILT_INCR8
init|=
literal|1ull
operator|<<
literal|48
block|,
comment|/**< to load and increment 8bit of memory atomically */
name|CVMX_TRA_FILT_INCR16
init|=
literal|1ull
operator|<<
literal|49
block|,
comment|/**< to load and increment 16bit of memory atomically */
name|CVMX_TRA_FILT_INCR32
init|=
literal|1ull
operator|<<
literal|50
block|,
comment|/**< to load and increment 32bit of memory atomically */
name|CVMX_TRA_FILT_INCR64
init|=
literal|1ull
operator|<<
literal|51
block|,
comment|/**< to load and increment 64bit of memory atomically */
name|CVMX_TRA_FILT_DECR8
init|=
literal|1ull
operator|<<
literal|52
block|,
comment|/**< to load and decrement 8bit of memory atomically */
name|CVMX_TRA_FILT_DECR16
init|=
literal|1ull
operator|<<
literal|53
block|,
comment|/**< to load and decrement 16bit of memory atomically */
name|CVMX_TRA_FILT_DECR32
init|=
literal|1ull
operator|<<
literal|54
block|,
comment|/**< to load and decrement 32bit of memory atomically */
name|CVMX_TRA_FILT_DECR64
init|=
literal|1ull
operator|<<
literal|55
block|,
comment|/**< to load and decrement 64bit of memory atomically */
name|CVMX_TRA_FILT_FAA32
init|=
literal|1ull
operator|<<
literal|58
block|,
comment|/**< to load from and add to a word of memory atomically */
name|CVMX_TRA_FILT_FAA64
init|=
literal|1ull
operator|<<
literal|59
block|,
comment|/**< to load from and add to a doubleword of memory atomically  */
name|CVMX_TRA_FILT_SAA32
init|=
literal|1ull
operator|<<
literal|62
block|,
comment|/**< to atomically add a word to a memory location */
name|CVMX_TRA_FILT_SAA64
init|=
literal|1ull
operator|<<
literal|63
block|,
comment|/**< to atomically add a doubleword to a memory location */
name|CVMX_TRA_FILT_ALL
init|=
operator|-
literal|1ull
comment|/**< all the above filter commands */
block|}
name|cvmx_tra_filt_t
typedef|;
comment|/*  * Enumeration of the bitmask of all source commands.  */
typedef|typedef
enum|enum
block|{
name|CVMX_TRA_SID_PP0
init|=
literal|1ull
operator|<<
literal|0
block|,
comment|/**< Enable tracing from PP0 with matching sourceID */
name|CVMX_TRA_SID_PP1
init|=
literal|1ull
operator|<<
literal|1
block|,
comment|/**< Enable tracing from PP1 with matching sourceID */
name|CVMX_TRA_SID_PP2
init|=
literal|1ull
operator|<<
literal|2
block|,
comment|/**< Enable tracing from PP2 with matching sourceID */
name|CVMX_TRA_SID_PP3
init|=
literal|1ull
operator|<<
literal|3
block|,
comment|/**< Enable tracing from PP3 with matching sourceID */
name|CVMX_TRA_SID_PP4
init|=
literal|1ull
operator|<<
literal|4
block|,
comment|/**< Enable tracing from PP4 with matching sourceID */
name|CVMX_TRA_SID_PP5
init|=
literal|1ull
operator|<<
literal|5
block|,
comment|/**< Enable tracing from PP5 with matching sourceID */
name|CVMX_TRA_SID_PP6
init|=
literal|1ull
operator|<<
literal|6
block|,
comment|/**< Enable tracing from PP6 with matching sourceID */
name|CVMX_TRA_SID_PP7
init|=
literal|1ull
operator|<<
literal|7
block|,
comment|/**< Enable tracing from PP7 with matching sourceID */
name|CVMX_TRA_SID_PP8
init|=
literal|1ull
operator|<<
literal|8
block|,
comment|/**< Enable tracing from PP8 with matching sourceID */
name|CVMX_TRA_SID_PP9
init|=
literal|1ull
operator|<<
literal|9
block|,
comment|/**< Enable tracing from PP9 with matching sourceID */
name|CVMX_TRA_SID_PP10
init|=
literal|1ull
operator|<<
literal|10
block|,
comment|/**< Enable tracing from PP10 with matching sourceID */
name|CVMX_TRA_SID_PP11
init|=
literal|1ull
operator|<<
literal|11
block|,
comment|/**< Enable tracing from PP11 with matching sourceID */
name|CVMX_TRA_SID_PP12
init|=
literal|1ull
operator|<<
literal|12
block|,
comment|/**< Enable tracing from PP12 with matching sourceID */
name|CVMX_TRA_SID_PP13
init|=
literal|1ull
operator|<<
literal|13
block|,
comment|/**< Enable tracing from PP13 with matching sourceID */
name|CVMX_TRA_SID_PP14
init|=
literal|1ull
operator|<<
literal|14
block|,
comment|/**< Enable tracing from PP14 with matching sourceID */
name|CVMX_TRA_SID_PP15
init|=
literal|1ull
operator|<<
literal|15
block|,
comment|/**< Enable tracing from PP15 with matching sourceID */
name|CVMX_TRA_SID_PKI
init|=
literal|1ull
operator|<<
literal|16
block|,
comment|/**< Enable tracing of write requests from PIP/IPD */
name|CVMX_TRA_SID_PKO
init|=
literal|1ull
operator|<<
literal|17
block|,
comment|/**< Enable tracing of write requests from PKO */
name|CVMX_TRA_SID_IOBREQ
init|=
literal|1ull
operator|<<
literal|18
block|,
comment|/**< Enable tracing of write requests from FPA,TIM,DFA,PCI,ZIP,POW, and PKO (writes) */
name|CVMX_TRA_SID_DWB
init|=
literal|1ull
operator|<<
literal|19
block|,
comment|/**< Enable tracing of write requests from IOB DWB engine */
name|CVMX_TRA_SID_ALL
init|=
operator|-
literal|1ull
comment|/**< Enable tracing all the above source commands */
block|}
name|cvmx_tra_sid_t
typedef|;
define|#
directive|define
name|CVMX_TRA_DID_SLI
value|CVMX_TRA_DID_PCI
comment|/**< Enable tracing of requests to SLI and RSL-type CSRs. */
comment|/*  * Enumeration of the bitmask of all destination commands.  */
typedef|typedef
enum|enum
block|{
name|CVMX_TRA_DID_MIO
init|=
literal|1ull
operator|<<
literal|0
block|,
comment|/**< Enable tracing of CIU and GPIO CSR's */
name|CVMX_TRA_DID_PCI
init|=
literal|1ull
operator|<<
literal|3
block|,
comment|/**< Enable tracing of requests to PCI and RSL type CSR's */
name|CVMX_TRA_DID_KEY
init|=
literal|1ull
operator|<<
literal|4
block|,
comment|/**< Enable tracing of requests to KEY memory */
name|CVMX_TRA_DID_FPA
init|=
literal|1ull
operator|<<
literal|5
block|,
comment|/**< Enable tracing of requests to FPA */
name|CVMX_TRA_DID_DFA
init|=
literal|1ull
operator|<<
literal|6
block|,
comment|/**< Enable tracing of requests to DFA */
name|CVMX_TRA_DID_ZIP
init|=
literal|1ull
operator|<<
literal|7
block|,
comment|/**< Enable tracing of requests to ZIP */
name|CVMX_TRA_DID_RNG
init|=
literal|1ull
operator|<<
literal|8
block|,
comment|/**< Enable tracing of requests to RNG */
name|CVMX_TRA_DID_IPD
init|=
literal|1ull
operator|<<
literal|9
block|,
comment|/**< Enable tracing of IPD CSR accesses */
name|CVMX_TRA_DID_PKO
init|=
literal|1ull
operator|<<
literal|10
block|,
comment|/**< Enable tracing of PKO accesses (doorbells) */
name|CVMX_TRA_DID_POW
init|=
literal|1ull
operator|<<
literal|12
block|,
comment|/**< Enable tracing of requests to RNG */
name|CVMX_TRA_DID_USB0
init|=
literal|1ull
operator|<<
literal|13
block|,
comment|/**< Enable tracing of USB0 accesses (UAHC0 EHCI and OHCI NCB CSRs) */
name|CVMX_TRA_DID_RAD
init|=
literal|1ull
operator|<<
literal|14
block|,
comment|/**< Enable tracing of RAD accesses (doorbells) */
name|CVMX_TRA_DID_DPI
init|=
literal|1ull
operator|<<
literal|27
block|,
comment|/**< Enable tracing of DPI accesses (DPI NCD CSRs) */
name|CVMX_TRA_DID_FAU
init|=
literal|1ull
operator|<<
literal|30
block|,
comment|/**< Enable tracing FAU accesses */
name|CVMX_TRA_DID_ALL
init|=
operator|-
literal|1ull
comment|/**< Enable tracing all the above destination commands */
block|}
name|cvmx_tra_did_t
typedef|;
comment|/**  * TRA data format definition. Use the type field to  * determine which union element to use.  *  * In Octeon 2, the trace buffer is 69 bits,  * the first read accesses bits 63:0 of the trace buffer entry, and  * the second read accesses bits 68:64 of the trace buffer entry.  */
typedef|typedef
union|union
block|{
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|datahi
decl_stmt|;
name|uint64_t
name|data
decl_stmt|;
else|#
directive|else
name|uint64_t
name|data
decl_stmt|;
name|uint64_t
name|datahi
decl_stmt|;
endif|#
directive|endif
block|}
name|u128
struct|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|5
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|cmn
struct|;
comment|/**< for DWB, PL2, PSL1, LDD, LDI, LDT */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved2
range|:
literal|3
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|store
struct|;
comment|/**< STC, STF, STP, STT */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|subid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|subid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|address
range|:
literal|36
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|iobld
struct|;
comment|/**< for IOBLD8, IOBLD16, IOBLD32, IOBLD64, IOBST, SAA */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|4
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|4
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|address
range|:
literal|33
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved3
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|iob
struct|;
comment|/**< for IOBDMA */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
comment|/* Split the address to fit in upper 64 bits  */
name|uint64_t
name|addresslo
range|:
literal|35
decl_stmt|;
comment|/* and lower 64-bits. */
name|uint64_t
name|reserved
range|:
literal|10
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|10
decl_stmt|;
name|uint64_t
name|addresslo
range|:
literal|35
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cmn2
struct|;
comment|/**< for LDT, LDI, PL2, RPL2, DWB, WBL2, WBIL2i, LTGL2i, STGL2i, INVL2, WBIL2, LCKL2, SET*, CLR*, INCR*, DECR* */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
comment|/* Split the address to fit in upper 64 bits  */
name|uint64_t
name|addresslo
range|:
literal|35
decl_stmt|;
comment|/* and lower 64-bits */
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|addresslo
range|:
literal|35
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|store2
struct|;
comment|/**< for STC, STF, STP, STT, LDD, PSL1, SAA32, SAA64, FAA32, FAA64, FAS32, FAS64, STTIL1, STFIL1 */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
comment|/* Split the address to fit in upper 64 bits  */
name|uint64_t
name|addresslo
range|:
literal|35
decl_stmt|;
comment|/* and lower 64-bits */
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|subid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|subid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|reserved
range|:
literal|2
decl_stmt|;
name|uint64_t
name|addresslo
range|:
literal|35
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|iobld2
struct|;
comment|/**< for IOBLD8, IOBLD16, IOBLD32, IOBLD64, IOBST64, IOBST32, IOBST16, IOBST8 */
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
comment|/* Split the address to fit in upper 64 bits  */
name|uint64_t
name|addresslo
range|:
literal|32
decl_stmt|;
comment|/* and lower 64-bits */
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
else|#
directive|else
name|uint64_t
name|timestamp
range|:
literal|8
decl_stmt|;
name|uint64_t
name|type
range|:
literal|6
decl_stmt|;
name|uint64_t
name|source
range|:
literal|5
decl_stmt|;
name|uint64_t
name|dest
range|:
literal|5
decl_stmt|;
name|uint64_t
name|mask
range|:
literal|8
decl_stmt|;
name|uint64_t
name|addresslo
range|:
literal|32
decl_stmt|;
name|uint64_t
name|addresshi
range|:
literal|3
decl_stmt|;
name|uint64_t
name|valid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|discontinuity
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved1
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|iob2
struct|;
comment|/**< for IOBDMA */
block|}
name|cvmx_tra_data_t
typedef|;
comment|/* The trace buffer number to use. */
specifier|extern
name|int
name|_cvmx_tra_unit
decl_stmt|;
comment|/**  * Setup the TRA buffer for use  *  * @param control TRA control setup  * @param filter  Which events to log  * @param source_filter  *                Source match  * @param dest_filter  *                Destination match  * @param address Address compare  * @param address_mask  *                Address mask  */
specifier|extern
name|void
name|cvmx_tra_setup
parameter_list|(
name|cvmx_tra_ctl_t
name|control
parameter_list|,
name|cvmx_tra_filt_t
name|filter
parameter_list|,
name|cvmx_tra_sid_t
name|source_filter
parameter_list|,
name|cvmx_tra_did_t
name|dest_filter
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|address_mask
parameter_list|)
function_decl|;
comment|/**  * Setup each TRA buffer for use  *  * @param tra     Which TRA buffer to use (0-3)  * @param control TRA control setup  * @param filter  Which events to log  * @param source_filter  *                Source match  * @param dest_filter  *                Destination match  * @param address Address compare  * @param address_mask  *                Address mask  */
specifier|extern
name|void
name|cvmx_tra_setup_v2
parameter_list|(
name|int
name|tra
parameter_list|,
name|cvmx_tra_ctl_t
name|control
parameter_list|,
name|cvmx_tra_filt_t
name|filter
parameter_list|,
name|cvmx_tra_sid_t
name|source_filter
parameter_list|,
name|cvmx_tra_did_t
name|dest_filter
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|address_mask
parameter_list|)
function_decl|;
comment|/**  * Setup a TRA trigger. How the triggers are used should be  * setup using cvmx_tra_setup.  *  * @param trigger Trigger to setup (0 or 1)  * @param filter  Which types of events to trigger on  * @param source_filter  *                Source trigger match  * @param dest_filter  *                Destination trigger match  * @param address Trigger address compare  * @param address_mask  *                Trigger address mask  */
specifier|extern
name|void
name|cvmx_tra_trig_setup
parameter_list|(
name|uint64_t
name|trigger
parameter_list|,
name|cvmx_tra_filt_t
name|filter
parameter_list|,
name|cvmx_tra_sid_t
name|source_filter
parameter_list|,
name|cvmx_tra_did_t
name|dest_filter
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|address_mask
parameter_list|)
function_decl|;
comment|/**  * Setup each TRA trigger. How the triggers are used should be  * setup using cvmx_tra_setup.  *  * @param tra     Which TRA buffer to use (0-3)  * @param trigger Trigger to setup (0 or 1)  * @param filter  Which types of events to trigger on  * @param source_filter  *                Source trigger match  * @param dest_filter  *                Destination trigger match  * @param address Trigger address compare  * @param address_mask  *                Trigger address mask  */
specifier|extern
name|void
name|cvmx_tra_trig_setup_v2
parameter_list|(
name|int
name|tra
parameter_list|,
name|uint64_t
name|trigger
parameter_list|,
name|cvmx_tra_filt_t
name|filter
parameter_list|,
name|cvmx_tra_sid_t
name|source_filter
parameter_list|,
name|cvmx_tra_did_t
name|dest_filter
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|address_mask
parameter_list|)
function_decl|;
comment|/**  * Read an entry from the TRA buffer. The trace buffer format is  * different in Octeon2, need to read twice from TRA_READ_DAT.  *  * @return Value return. High bit will be zero if there wasn't any data  */
specifier|extern
name|cvmx_tra_data_t
name|cvmx_tra_read
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Read an entry from the TRA buffer from a given TRA unit.  *  * @param tra_unit  Trace buffer unit to read  *  * @return Value return. High bit will be zero if there wasn't any data  */
name|cvmx_tra_data_t
name|cvmx_tra_read_v2
parameter_list|(
name|int
name|tra_unit
parameter_list|)
function_decl|;
comment|/**  * Decode a TRA entry into human readable output  *  * @param tra_ctl Trace control setup  * @param data    Data to decode  */
specifier|extern
name|void
name|cvmx_tra_decode_text
parameter_list|(
name|cvmx_tra_ctl_t
name|tra_ctl
parameter_list|,
name|cvmx_tra_data_t
name|data
parameter_list|)
function_decl|;
comment|/**  * Display the entire trace buffer. It is advised that you  * disable the trace buffer before calling this routine  * otherwise it could infinitely loop displaying trace data  * that it created.  */
specifier|extern
name|void
name|cvmx_tra_display
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/**  * Display the entire trace buffer. It is advised that you  * disable the trace buffer before calling this routine  * otherwise it could infinitely loop displaying trace data  * that it created.  *  * @param tra_unit   Which TRA buffer to use.  */
specifier|extern
name|void
name|cvmx_tra_display_v2
parameter_list|(
name|int
name|tra_unit
parameter_list|)
function_decl|;
comment|/**  * Enable or disable the TRA hardware, by default enables all TRAs.  *  * @param enable 1=enable, 0=disable  */
specifier|static
specifier|inline
name|void
name|cvmx_tra_enable
parameter_list|(
name|int
name|enable
parameter_list|)
block|{
name|cvmx_tra_ctl_t
name|control
decl_stmt|;
name|int
name|tad
decl_stmt|;
for|for
control|(
name|tad
operator|=
literal|0
init|;
name|tad
operator|<
name|CVMX_L2C_TADS
condition|;
name|tad
operator|++
control|)
block|{
name|control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TRAX_CTL
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|ena
operator|=
name|enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TRAX_CTL
argument_list|(
name|tad
argument_list|)
argument_list|,
name|control
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_TRAX_CTL
argument_list|(
name|tad
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/**  * Enable or disable a particular TRA hardware  *  * @param enable  1=enable, 0=disable  * @param tra     which TRA to enable, CN68XX has 4.  */
specifier|static
specifier|inline
name|void
name|cvmx_tra_enable_v2
parameter_list|(
name|int
name|enable
parameter_list|,
name|int
name|tra
parameter_list|)
block|{
name|cvmx_tra_ctl_t
name|control
decl_stmt|;
if|if
condition|(
operator|(
name|tra
operator|+
literal|1
operator|)
operator|>
name|CVMX_L2C_TADS
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"cvmx_tra_enable: Invalid TRA(%d), max allowed are %d\n"
argument_list|,
name|tra
argument_list|,
name|CVMX_L2C_TADS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|tra
operator|=
literal|0
expr_stmt|;
block|}
name|control
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_TRAX_CTL
argument_list|(
name|tra
argument_list|)
argument_list|)
expr_stmt|;
name|control
operator|.
name|s
operator|.
name|ena
operator|=
name|enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_TRAX_CTL
argument_list|(
name|tra
argument_list|)
argument_list|,
name|control
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_TRAX_CTL
argument_list|(
name|tra
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

