begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-pescx-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon pescx.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_PESCX_TYPEDEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_PESCX_TYPEDEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_BIST_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_BIST_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000018ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_BIST_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000018ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_BIST_STATUS2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_BIST_STATUS2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000418ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_BIST_STATUS2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000418ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_CFG_RD
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_CFG_RD(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000030ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_CFG_RD
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000030ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_CFG_WR
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_CFG_WR(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000028ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_CFG_WR
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000028ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_CPL_LUT_VALID
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_CPL_LUT_VALID(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000098ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_CPL_LUT_VALID
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000098ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_CTL_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_CTL_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000000ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_CTL_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000000ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_CTL_STATUS2
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_CTL_STATUS2(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000400ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_CTL_STATUS2
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000400ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_DBG_INFO
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_DBG_INFO(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000008ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_DBG_INFO
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000008ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_DBG_INFO_EN
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_DBG_INFO_EN(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C80000A0ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_DBG_INFO_EN
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C80000A0ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_DIAG_STATUS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_DIAG_STATUS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000020ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_DIAG_STATUS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000020ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_P2N_BAR0_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_P2N_BAR0_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000080ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_P2N_BAR0_START
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000080ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_P2N_BAR1_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_P2N_BAR1_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000088ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_P2N_BAR1_START
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000088ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_P2N_BAR2_START
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_P2N_BAR2_START(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000090ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_P2N_BAR2_START
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000090ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_P2P_BARX_END
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_P2P_BARX_END(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000048ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x800000ull
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_P2P_BARX_END
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000048ull) + (((offset)& 3) + ((block_id)& 1) * 0x800000ull) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_P2P_BARX_START
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|,
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
operator|(
name|offset
operator|<=
literal|3
operator|)
operator|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_P2P_BARX_START(%lu,%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000040ull
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|offset
operator|)
operator|&
literal|3
operator|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x800000ull
operator|)
operator|*
literal|16
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_P2P_BARX_START
parameter_list|(
name|offset
parameter_list|,
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000040ull) + (((offset)& 3) + ((block_id)& 1) * 0x800000ull) * 16)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_PESCX_TLP_CREDITS
parameter_list|(
name|unsigned
name|long
name|block_id
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN52XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN56XX
argument_list|)
operator|&&
operator|(
operator|(
name|block_id
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_PESCX_TLP_CREDITS(%lu) is invalid on this chip\n"
argument_list|,
name|block_id
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800C8000038ull
argument_list|)
operator|+
operator|(
operator|(
name|block_id
operator|)
operator|&
literal|1
operator|)
operator|*
literal|0x8000000ull
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_PESCX_TLP_CREDITS
parameter_list|(
name|block_id
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800C8000038ull) + ((block_id)& 1) * 0x8000000ull)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_pesc#_bist_status  *  * PESC_BIST_STATUS = PESC Bist Status  *  * Contains the diffrent interrupt summary bits of the PESC.  */
end_comment

begin_union
union|union
name|cvmx_pescx_bist_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_bist_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|rqdata5
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory5. */
name|uint64_t
name|ctlp_or
range|:
literal|1
decl_stmt|;
comment|/**< C-TLP Order Fifo. */
name|uint64_t
name|ntlp_or
range|:
literal|1
decl_stmt|;
comment|/**< N-TLP Order Fifo. */
name|uint64_t
name|ptlp_or
range|:
literal|1
decl_stmt|;
comment|/**< P-TLP Order Fifo. */
name|uint64_t
name|retry
range|:
literal|1
decl_stmt|;
comment|/**< Retry Buffer. */
name|uint64_t
name|rqdata0
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory0. */
name|uint64_t
name|rqdata1
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory1. */
name|uint64_t
name|rqdata2
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory2. */
name|uint64_t
name|rqdata3
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory3. */
name|uint64_t
name|rqdata4
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory4. */
name|uint64_t
name|rqhdr1
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Header1. */
name|uint64_t
name|rqhdr0
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Header0. */
name|uint64_t
name|sot
range|:
literal|1
decl_stmt|;
comment|/**< SOT Buffer. */
else|#
directive|else
name|uint64_t
name|sot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqhdr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqhdr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|retry
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_or
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ntlp_or
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctlp_or
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_bist_status_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_pescx_bist_status_cn52xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
name|uint64_t
name|ctlp_or
range|:
literal|1
decl_stmt|;
comment|/**< C-TLP Order Fifo. */
name|uint64_t
name|ntlp_or
range|:
literal|1
decl_stmt|;
comment|/**< N-TLP Order Fifo. */
name|uint64_t
name|ptlp_or
range|:
literal|1
decl_stmt|;
comment|/**< P-TLP Order Fifo. */
name|uint64_t
name|retry
range|:
literal|1
decl_stmt|;
comment|/**< Retry Buffer. */
name|uint64_t
name|rqdata0
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory0. */
name|uint64_t
name|rqdata1
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory1. */
name|uint64_t
name|rqdata2
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory2. */
name|uint64_t
name|rqdata3
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory3. */
name|uint64_t
name|rqdata4
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Data Memory4. */
name|uint64_t
name|rqhdr1
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Header1. */
name|uint64_t
name|rqhdr0
range|:
literal|1
decl_stmt|;
comment|/**< Rx Queue Header0. */
name|uint64_t
name|sot
range|:
literal|1
decl_stmt|;
comment|/**< SOT Buffer. */
else|#
directive|else
name|uint64_t
name|sot
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqhdr0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqhdr1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata4
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqdata0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|retry
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptlp_or
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ntlp_or
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ctlp_or
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_63
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_pescx_bist_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_bist_status_cn52xxp1
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_bist_status
name|cvmx_pescx_bist_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_bist_status2  *  * PESC(0..1)_BIST_STATUS2 = PESC BIST Status Register  *  * Results from BIST runs of PESC's memories.  */
end_comment

begin_union
union|union
name|cvmx_pescx_bist_status2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_bist_status2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|cto_p2e
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the cto_p2e_fifo */
name|uint64_t
name|e2p_cpl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_cpl_fifo */
name|uint64_t
name|e2p_n
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_n_fifo */
name|uint64_t
name|e2p_p
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_p_fifo */
name|uint64_t
name|e2p_rsl
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the e2p_rsl__fifo */
name|uint64_t
name|dbg_p2e
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the dbg_p2e_fifo */
name|uint64_t
name|peai_p2e
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the peai__pesc_fifo */
name|uint64_t
name|rsl_p2e
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the rsl_p2e_fifo */
name|uint64_t
name|pef_tpf1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_p_fifo1 */
name|uint64_t
name|pef_tpf0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_p_fifo0 */
name|uint64_t
name|pef_tnf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_n_fifo */
name|uint64_t
name|pef_tcf1
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_cpl_fifo1 */
name|uint64_t
name|pef_tc0
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the pef_tlp_cpl_fifo0 */
name|uint64_t
name|ppf
range|:
literal|1
decl_stmt|;
comment|/**< BIST Status for the ppf_fifo */
else|#
directive|else
name|uint64_t
name|ppf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tc0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tcf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tnf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tpf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pef_tpf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rsl_p2e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|peai_p2e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dbg_p2e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_rsl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_p
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_n
range|:
literal|1
decl_stmt|;
name|uint64_t
name|e2p_cpl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cto_p2e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_bist_status2_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_bist_status2_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_bist_status2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_bist_status2_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_bist_status2
name|cvmx_pescx_bist_status2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_cfg_rd  *  * PESC_CFG_RD = PESC Configuration Read  *  * Allows read access to the configuration in the PCIe Core.  */
end_comment

begin_union
union|union
name|cvmx_pescx_cfg_rd
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_cfg_rd_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
comment|/**< Data. */
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
comment|/**< Address to read. A write to this register                                                          starts a read operation. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_cfg_rd_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_cfg_rd_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_cfg_rd_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_cfg_rd_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_cfg_rd
name|cvmx_pescx_cfg_rd_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_cfg_wr  *  * PESC_CFG_WR = PESC Configuration Write  *  * Allows write access to the configuration in the PCIe Core.  */
end_comment

begin_union
union|union
name|cvmx_pescx_cfg_wr
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_cfg_wr_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
comment|/**< Data to write. A write to this register starts                                                          a write operation. */
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
comment|/**< Address to write. A write to this register starts                                                          a write operation. */
else|#
directive|else
name|uint64_t
name|addr
range|:
literal|32
decl_stmt|;
name|uint64_t
name|data
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_cfg_wr_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_cfg_wr_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_cfg_wr_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_cfg_wr_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_cfg_wr
name|cvmx_pescx_cfg_wr_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_cpl_lut_valid  *  * PESC_CPL_LUT_VALID = PESC Cmpletion Lookup Table Valid  *  * Bit set for outstanding tag read.  */
end_comment

begin_union
union|union
name|cvmx_pescx_cpl_lut_valid
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_cpl_lut_valid_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
comment|/**< Bit vector set cooresponds to an outstanding tag                                                          expecting a completion. */
else|#
directive|else
name|uint64_t
name|tag
range|:
literal|32
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_cpl_lut_valid_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_cpl_lut_valid_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_cpl_lut_valid_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_cpl_lut_valid_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_cpl_lut_valid
name|cvmx_pescx_cpl_lut_valid_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_ctl_status  *  * PESC_CTL_STATUS = PESC Control Status  *  * General control and status of the PESC.  */
end_comment

begin_union
union|union
name|cvmx_pescx_ctl_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_ctl_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|dnum
range|:
literal|5
decl_stmt|;
comment|/**< Primary bus device number. */
name|uint64_t
name|pbus
range|:
literal|8
decl_stmt|;
comment|/**< Primary bus number. */
name|uint64_t
name|qlm_cfg
range|:
literal|2
decl_stmt|;
comment|/**< The QLM configuration pad bits. */
name|uint64_t
name|lane_swp
range|:
literal|1
decl_stmt|;
comment|/**< Lane Swap. For PEDC1, when 0 NO LANE SWAP when '1'                                                          enables LANE SWAP. THis bit has no effect on PEDC0.                                                          This bit should be set before enabling PEDC1. */
name|uint64_t
name|pm_xtoff
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core pm_xmt_turnoff port. RC mode. */
name|uint64_t
name|pm_xpme
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core pm_xmt_pme port. EP mode. */
name|uint64_t
name|ob_p_cmd
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core outband_pwrup_cmd port. EP mode. */
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nf_ecrc
range|:
literal|1
decl_stmt|;
comment|/**< Do not forward peer-to-peer ECRC TLPs. */
name|uint64_t
name|dly_one
range|:
literal|1
decl_stmt|;
comment|/**< When set the output client state machines will                                                          wait one cycle before starting a new TLP out. */
name|uint64_t
name|lnk_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the link is enabled when '0' the                                                          link is disabled. This bit only is active when in                                                          RC mode. */
name|uint64_t
name|ro_ctlp
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' C-TLPs that have the RO bit set will                                                          not wait for P-TLPs that normaly would be sent                                                          first. */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_ecrc
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the LSB of the ECRC to be inverted. */
name|uint64_t
name|inv_lcrc
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the LSB of the LCRC to be inverted. */
else|#
directive|else
name|uint64_t
name|inv_lcrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_ecrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ro_ctlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dly_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nf_ecrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ob_p_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xpme
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xtoff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_swp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbus
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_ctl_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_ctl_status_s
name|cn52xxp1
decl_stmt|;
struct|struct
name|cvmx_pescx_ctl_status_cn56xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|dnum
range|:
literal|5
decl_stmt|;
comment|/**< Primary bus device number. */
name|uint64_t
name|pbus
range|:
literal|8
decl_stmt|;
comment|/**< Primary bus number. */
name|uint64_t
name|qlm_cfg
range|:
literal|2
decl_stmt|;
comment|/**< The QLM configuration pad bits. */
name|uint64_t
name|reserved_12_12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xtoff
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core pm_xmt_turnoff port. RC mode. */
name|uint64_t
name|pm_xpme
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core pm_xmt_pme port. EP mode. */
name|uint64_t
name|ob_p_cmd
range|:
literal|1
decl_stmt|;
comment|/**< When WRITTEN with a '1' a single cycle pulse is                                                          to the PCIe core outband_pwrup_cmd port. EP mode. */
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|nf_ecrc
range|:
literal|1
decl_stmt|;
comment|/**< Do not forward peer-to-peer ECRC TLPs. */
name|uint64_t
name|dly_one
range|:
literal|1
decl_stmt|;
comment|/**< When set the output client state machines will                                                          wait one cycle before starting a new TLP out. */
name|uint64_t
name|lnk_enb
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' the link is enabled when '0' the                                                          link is disabled. This bit only is active when in                                                          RC mode. */
name|uint64_t
name|ro_ctlp
range|:
literal|1
decl_stmt|;
comment|/**< When set '1' C-TLPs that have the RO bit set will                                                          not wait for P-TLPs that normaly would be sent                                                          first. */
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_ecrc
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the LSB of the ECRC to be inverted. */
name|uint64_t
name|inv_lcrc
range|:
literal|1
decl_stmt|;
comment|/**< When '1' causes the LSB of the LCRC to be inverted. */
else|#
directive|else
name|uint64_t
name|inv_lcrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|inv_ecrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ro_ctlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_enb
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dly_one
range|:
literal|1
decl_stmt|;
name|uint64_t
name|nf_ecrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_7_8
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ob_p_cmd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xpme
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_xtoff
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_12
range|:
literal|1
decl_stmt|;
name|uint64_t
name|qlm_cfg
range|:
literal|2
decl_stmt|;
name|uint64_t
name|pbus
range|:
literal|8
decl_stmt|;
name|uint64_t
name|dnum
range|:
literal|5
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|cn56xx
struct|;
name|struct
name|cvmx_pescx_ctl_status_cn56xx
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_ctl_status
name|cvmx_pescx_ctl_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_ctl_status2  *  * Below are in PESC  *  *                  PESC(0..1)_BIST_STATUS2 = PESC BIST Status Register  *  * Results from BIST runs of PESC's memories.  */
end_comment

begin_union
union|union
name|cvmx_pescx_ctl_status2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_ctl_status2_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|pclk_run
range|:
literal|1
decl_stmt|;
comment|/**< When the pce_clk is running this bit will be '1'.                                                          Writing a '1' to this location will cause the                                                          bit to be cleared, but if the pce_clk is running                                                          this bit will be re-set. */
name|uint64_t
name|pcierst
range|:
literal|1
decl_stmt|;
comment|/**< Set to '1' when PCIe is in reset. */
else|#
directive|else
name|uint64_t
name|pcierst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pclk_run
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_ctl_status2_s
name|cn52xx
decl_stmt|;
struct|struct
name|cvmx_pescx_ctl_status2_cn52xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
name|uint64_t
name|pcierst
range|:
literal|1
decl_stmt|;
comment|/**< Set to '1' when PCIe is in reset. */
else|#
directive|else
name|uint64_t
name|pcierst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_1_63
range|:
literal|63
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_pescx_ctl_status2_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_ctl_status2_cn52xxp1
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_ctl_status2
name|cvmx_pescx_ctl_status2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_dbg_info  *  * PESC(0..1)_DBG_INFO = PESC Debug Information  *  * General debug info.  */
end_comment

begin_union
union|union
name|cvmx_pescx_dbg_info
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_dbg_info_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
comment|/**< Received a ECRC error.                                                          radm_ecrc_err */
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
comment|/**< Received a write with poisoned payload                                                          radm_rcvd_wreq_poisoned */
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
comment|/**< Received a completion with poisoned payload                                                          radm_rcvd_cpl_poisoned */
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
comment|/**< Received a malformed TLP                                                          radm_mlf_tlp_err */
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
comment|/**< Recieved a request which device does not support                                                          radm_rcvd_ur_req */
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
comment|/**< Completer aborted a request                                                          radm_rcvd_ca_req                                                          This bit will never be set because Octeon does                                                          not generate Completer Aborts. */
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
comment|/**< Received a completion with CA status                                                          radm_rcvd_cpl_ca */
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
comment|/**< Received a completion with UR status                                                          radm_rcvd_cpl_ur */
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
comment|/**< Received an unexpected completion                                                          radm_unexp_cpl_err */
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
comment|/**< Receive queue overflow. Normally happens only when                                                          flow control advertisements are ignored                                                          radm_qoverflow */
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Update Violation (opt. checks)                                                          int_xadm_fc_prot_err */
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
comment|/**< When the PHY reports 8B/10B decode error                                                          (RxStatus = 3b100) or disparity error                                                          (RxStatus = 3b111), the signal rmlh_rcvd_err will                                                          be asserted.                                                          rmlh_rcvd_err */
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
comment|/**< Flow Control Protocol Violation (Watchdog Timer)                                                          rtlh_fc_prot_err */
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
comment|/**< DLLP protocol error (out of sequence DLLP)                                                          rdlh_prot_err */
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP with DataLink Layer Error                                                          rdlh_bad_tlp_err */
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
comment|/**< Received DLLP with DataLink Layer Error                                                          rdlh_bad_dllp_err */
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
comment|/**< Max Retries Exceeded                                                          xdlh_replay_num_rlover_err */
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
comment|/**< Replay Timer Expired                                                          xdlh_replay_timeout_err                                                          This bit is set when the REPLAY_TIMER expires in                                                          the PCIE core. The probability of this bit being                                                          set will increase with the traffic load. */
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
comment|/**< A Completion Timeout Occured                                                          pedc_radm_cpl_timeout */
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
comment|/**< Received Vendor-Defined Message                                                          pedc_radm_vendor_msg */
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
comment|/**< Received Unlock Message (EP Mode Only)                                                          pedc_radm_msg_unlock */
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
comment|/**< Received PME Turnoff Acknowledge Message                                                          (RC Mode only)                                                          pedc_radm_pm_to_ack */
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
comment|/**< Received PME Message (RC Mode only)                                                          pedc_radm_pm_pme */
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Received Fatal Error Message (RC Mode only)                                                          pedc_radm_fatal_err                                                          Bit set when a message with ERR_FATAL is set. */
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Received Non-Fatal Error Message (RC Mode only)                                                          pedc_radm_nonfatal_err */
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
comment|/**< Received Correctable Error Message (RC Mode only)                                                          pedc_radm_correctable_err */
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
comment|/**< Received Poisoned TLP                                                          pedc__radm_trgt1_poisoned& pedc__radm_trgt1_hv */
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
comment|/**< Received ECRC Error                                                          pedc_radm_trgt1_ecrc_err& pedc__radm_trgt1_eot */
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP has link layer error                                                          pedc_radm_trgt1_dllp_abort& pedc__radm_trgt1_eot */
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
comment|/**< Received TLP is malformed or a message.                                                          pedc_radm_trgt1_tlp_abort& pedc__radm_trgt1_eot                                                          If the core receives a MSG (or Vendor Message)                                                          this bit will be set. */
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
comment|/**< Poisoned TLP sent                                                          peai__client0_tlp_ep& peai__client0_tlp_hv */
else|#
directive|else
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_dbg_info_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_dbg_info_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_dbg_info_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_dbg_info_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_dbg_info
name|cvmx_pescx_dbg_info_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_dbg_info_en  *  * PESC(0..1)_DBG_INFO_EN = PESC Debug Information Enable  *  * Allows PESC_DBG_INFO to generate interrupts when cooresponding enable bit is set.  */
end_comment

begin_union
union|union
name|cvmx_pescx_dbg_info_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_dbg_info_en_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[30] to generate an interrupt. */
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[29] to generate an interrupt. */
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[28] to generate an interrupt. */
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[27] to generate an interrupt. */
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[26] to generate an interrupt. */
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[25] to generate an interrupt. */
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[24] to generate an interrupt. */
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[23] to generate an interrupt. */
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[22] to generate an interrupt. */
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[21] to generate an interrupt. */
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[20] to generate an interrupt. */
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[19] to generate an interrupt. */
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[18] to generate an interrupt. */
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[17] to generate an interrupt. */
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[16] to generate an interrupt. */
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[15] to generate an interrupt. */
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[14] to generate an interrupt. */
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[13] to generate an interrupt. */
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[12] to generate an interrupt. */
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[11] to generate an interrupt. */
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[10] to generate an interrupt. */
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[9] to generate an interrupt. */
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[8] to generate an interrupt. */
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[7] to generate an interrupt. */
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[6] to generate an interrupt. */
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[5] to generate an interrupt. */
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[4] to generate an interrupt. */
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[3] to generate an interrupt. */
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[2] to generate an interrupt. */
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[1] to generate an interrupt. */
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
comment|/**< Allows PESC_DBG_INFO[0] to generate an interrupt. */
else|#
directive|else
name|uint64_t
name|spoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlpmal
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtlplle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|recrce
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpoison
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rcemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rnfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rfemrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpmerc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rptamrc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rumep
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rvdm
range|:
literal|1
decl_stmt|;
name|uint64_t
name|acto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rte
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mre
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rdwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rtwdle
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dpeoosd
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcpvwt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rpe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|fcuv
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rqo
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rauc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racur
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racca
range|:
literal|1
decl_stmt|;
name|uint64_t
name|caar
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rarwdns
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ramtlp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|racpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rawwpp
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ecrc_e
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_31_63
range|:
literal|33
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_dbg_info_en_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_dbg_info_en_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_dbg_info_en_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_dbg_info_en_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_dbg_info_en
name|cvmx_pescx_dbg_info_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_diag_status  *  * PESC_DIAG_STATUS = PESC Diagnostic Status  *  * Selection control for the cores diagnostic bus.  */
end_comment

begin_union
union|union
name|cvmx_pescx_diag_status
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_diag_status_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|pm_dst
range|:
literal|1
decl_stmt|;
comment|/**< Current power management DSTATE. */
name|uint64_t
name|pm_stat
range|:
literal|1
decl_stmt|;
comment|/**< Power Management Status. */
name|uint64_t
name|pm_en
range|:
literal|1
decl_stmt|;
comment|/**< Power Management Event Enable. */
name|uint64_t
name|aux_en
range|:
literal|1
decl_stmt|;
comment|/**< Auxilary Power Enable. */
else|#
directive|else
name|uint64_t
name|aux_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_en
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pm_dst
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_diag_status_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_diag_status_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_diag_status_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_diag_status_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_diag_status
name|cvmx_pescx_diag_status_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_p2n_bar0_start  *  * PESC_P2N_BAR0_START = PESC PCIe to Npei BAR0 Start  *  * The starting address for addresses to forwarded to the NPEI in RC Mode.  */
end_comment

begin_union
union|union
name|cvmx_pescx_p2n_bar0_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_p2n_bar0_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|50
decl_stmt|;
comment|/**< The starting address of the 16KB address space that                                                          is the BAR0 address space. */
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_13
range|:
literal|14
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_p2n_bar0_start_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar0_start_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar0_start_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar0_start_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_p2n_bar0_start
name|cvmx_pescx_p2n_bar0_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_p2n_bar1_start  *  * PESC_P2N_BAR1_START = PESC PCIe to Npei BAR1 Start  *  * The starting address for addresses to forwarded to the NPEI in RC Mode.  */
end_comment

begin_union
union|union
name|cvmx_pescx_p2n_bar1_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_p2n_bar1_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
comment|/**< The starting address of the 64KB address space                                                          that is the BAR1 address space. */
name|uint64_t
name|reserved_0_25
range|:
literal|26
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_25
range|:
literal|26
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|38
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_p2n_bar1_start_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar1_start_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar1_start_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar1_start_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_p2n_bar1_start
name|cvmx_pescx_p2n_bar1_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_p2n_bar2_start  *  * PESC_P2N_BAR2_START = PESC PCIe to Npei BAR2 Start  *  * The starting address for addresses to forwarded to the NPEI in RC Mode.  */
end_comment

begin_union
union|union
name|cvmx_pescx_p2n_bar2_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_p2n_bar2_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|25
decl_stmt|;
comment|/**< The starting address of the 2^39 address space                                                          that is the BAR2 address space. */
name|uint64_t
name|reserved_0_38
range|:
literal|39
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_38
range|:
literal|39
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|25
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_p2n_bar2_start_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar2_start_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar2_start_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2n_bar2_start_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_p2n_bar2_start
name|cvmx_pescx_p2n_bar2_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_p2p_bar#_end  *  * PESC_P2P_BAR#_END = PESC Peer-To-Peer BAR0 End  *  * The ending address for addresses to forwarded to the PCIe peer port.  */
end_comment

begin_union
union|union
name|cvmx_pescx_p2p_barx_end
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_p2p_barx_end_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
comment|/**< The ending address of the address window created                                                          this field and the PESC_P2P_BAR0_START[63:12]                                                          field. The full 64-bits of address are created by:                                                          [ADDR[63:12], 12'b0]. */
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_p2p_barx_end_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2p_barx_end_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_p2p_barx_end_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2p_barx_end_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_p2p_barx_end
name|cvmx_pescx_p2p_barx_end_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_p2p_bar#_start  *  * PESC_P2P_BAR#_START = PESC Peer-To-Peer BAR0 Start  *  * The starting address and enable for addresses to forwarded to the PCIe peer port.  */
end_comment

begin_union
union|union
name|cvmx_pescx_p2p_barx_start
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_p2p_barx_start_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
comment|/**< The starting address of the address window created                                                          this field and the PESC_P2P_BAR0_END[63:12] field.                                                          The full 64-bits of address are created by:                                                          [ADDR[63:12], 12'b0]. */
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_11
range|:
literal|12
decl_stmt|;
name|uint64_t
name|addr
range|:
literal|52
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_pescx_p2p_barx_start_s
name|cn52xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2p_barx_start_s
name|cn52xxp1
decl_stmt|;
name|struct
name|cvmx_pescx_p2p_barx_start_s
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_p2p_barx_start_s
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_p2p_barx_start
name|cvmx_pescx_p2p_barx_start_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_pesc#_tlp_credits  *  * PESC_TLP_CREDITS = PESC TLP Credits  *  * Specifies the number of credits the PESC for use in moving TLPs. When this register is written the credit values are  * reset to the register value. A write to this register should take place BEFORE traffic flow starts.  */
end_comment

begin_union
union|union
name|cvmx_pescx_tlp_credits
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_pescx_tlp_credits_s
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_pescx_tlp_credits_cn52xx
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|peai_ppf
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the Peer.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|pesc_cpl
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the Peer.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|pesc_np
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Non-Posted TLPs in the Peer.                                                          Legal values are 0x4 to 0x10. */
name|uint64_t
name|pesc_p
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Posted TLPs in the Peer.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|npei_cpl
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the NPEI.                                                          Legal values are 0x24 to 0x80. */
name|uint64_t
name|npei_np
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Non-Posted TLPs in the NPEI.                                                          Legal values are 0x4 to 0x10. */
name|uint64_t
name|npei_p
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits for Posted TLPs in the NPEI.                                                          Legal values are 0x24 to 0x80. */
else|#
directive|else
name|uint64_t
name|npei_p
range|:
literal|8
decl_stmt|;
name|uint64_t
name|npei_np
range|:
literal|8
decl_stmt|;
name|uint64_t
name|npei_cpl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pesc_p
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pesc_np
range|:
literal|8
decl_stmt|;
name|uint64_t
name|pesc_cpl
range|:
literal|8
decl_stmt|;
name|uint64_t
name|peai_ppf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xx
struct|;
struct|struct
name|cvmx_pescx_tlp_credits_cn52xxp1
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
name|uint64_t
name|peai_ppf
range|:
literal|8
decl_stmt|;
comment|/**< TLP credits in core clk pre-buffer that holds TLPs                                                          being sent from PCIe Core to NPEI or PEER. */
name|uint64_t
name|pesc_cpl
range|:
literal|5
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the Peer. */
name|uint64_t
name|pesc_np
range|:
literal|5
decl_stmt|;
comment|/**< TLP credits for Non-Posted TLPs in the Peer. */
name|uint64_t
name|pesc_p
range|:
literal|5
decl_stmt|;
comment|/**< TLP credits for Posted TLPs in the Peer. */
name|uint64_t
name|npei_cpl
range|:
literal|5
decl_stmt|;
comment|/**< TLP credits for Completion TLPs in the NPEI. */
name|uint64_t
name|npei_np
range|:
literal|5
decl_stmt|;
comment|/**< TLP credits for Non-Posted TLPs in the NPEI. */
name|uint64_t
name|npei_p
range|:
literal|5
decl_stmt|;
comment|/**< TLP credits for Posted TLPs in the NPEI. */
else|#
directive|else
name|uint64_t
name|npei_p
range|:
literal|5
decl_stmt|;
name|uint64_t
name|npei_np
range|:
literal|5
decl_stmt|;
name|uint64_t
name|npei_cpl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pesc_p
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pesc_np
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pesc_cpl
range|:
literal|5
decl_stmt|;
name|uint64_t
name|peai_ppf
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_38_63
range|:
literal|26
decl_stmt|;
endif|#
directive|endif
block|}
name|cn52xxp1
struct|;
name|struct
name|cvmx_pescx_tlp_credits_cn52xx
name|cn56xx
decl_stmt|;
name|struct
name|cvmx_pescx_tlp_credits_cn52xxp1
name|cn56xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_pescx_tlp_credits
name|cvmx_pescx_tlp_credits_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

