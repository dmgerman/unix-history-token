begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to SRIO  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-srio.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-atomic.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CAVIUM_DECODE_RSL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sriox-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sriomaintx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sli-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dpi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-qlm.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-srio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_include
include|#
directive|include
file|"cvmx-atomic.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-helper-errata.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-qlm.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_SRIO_CONFIG_TIMEOUT
value|10000
end_define

begin_comment
comment|/* 10ms */
end_comment

begin_define
define|#
directive|define
name|CVMX_SRIO_DOORBELL_TIMEOUT
value|10000
end_define

begin_comment
comment|/* 10ms */
end_comment

begin_define
define|#
directive|define
name|CVMX_SRIO_CONFIG_PRIORITY
value|0
end_define

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
comment|/* Normally 2 for XKPHYS */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
comment|/* 1 for IO space access */
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
comment|/* DID = 3 */
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
comment|/* SubDID = 3-6 */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
comment|/* SubDID extender */
name|uint64_t
name|reserved_32_33
range|:
literal|2
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|hopcount
range|:
literal|8
decl_stmt|;
comment|/* Hopcount */
name|uint64_t
name|address
range|:
literal|24
decl_stmt|;
comment|/* Mem address */
else|#
directive|else
name|uint64_t
name|address
range|:
literal|24
decl_stmt|;
name|uint64_t
name|hopcount
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_33
range|:
literal|2
decl_stmt|;
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|config
struct|;
struct|struct
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
comment|/* Normally 2 for XKPHYS */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
comment|/* 1 for IO space access */
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
comment|/* DID = 3 */
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
comment|/* SubDID = 3-6 */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
comment|/* SubDID extender */
name|uint64_t
name|address
range|:
literal|34
decl_stmt|;
comment|/* Mem address */
else|#
directive|else
name|uint64_t
name|address
range|:
literal|34
decl_stmt|;
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|mem
struct|;
block|}
name|cvmx_sli_address_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|cvmx_srio_initialize_flags_t
name|flags
decl_stmt|;
name|int32_t
name|subidx_ref_count
index|[
literal|16
index|]
decl_stmt|;
comment|/* Reference count for SLI_MEM_ACCESS_SUBID[12-27]. Index=X-12 */
name|int32_t
name|s2m_ref_count
index|[
literal|16
index|]
decl_stmt|;
comment|/* Reference count for SRIOX_S2M_TYPE[0-15]. */
block|}
name|__cvmx_srio_state_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|__cvmx_srio_state_t
name|__cvmx_srio_state
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Allocate a SRIOX_S2M_TYPEX register for mapping a remote SRIO  * device's address range into Octeons SLI address space. Reference  * counting is used to allow sharing of duplicate setups. The current  * implementation treats reads and writes as paired, but this could be  * changed if we have trouble running out of indexes.  *  * @param srio_port SRIO port device is on  * @param s2m       SRIOX_S2M_TYPEX setup required  *  * @return Index of CSR, or negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_alloc_s2m
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_sriox_s2m_typex_t
name|s2m
parameter_list|)
block|{
name|int
name|s2m_index
decl_stmt|;
comment|/* Search through the S2M_TYPE registers looking for an unsed one or one         setup the way we need it */
for|for
control|(
name|s2m_index
operator|=
literal|0
init|;
name|s2m_index
operator|<
literal|16
condition|;
name|s2m_index
operator|++
control|)
block|{
comment|/* Increment ref count by 2 since we count read and write             independently. We might need a more complicated search in the             future */
name|int
name|ref_count
init|=
name|cvmx_atomic_fetch_and_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|s2m_ref_count
index|[
name|s2m_index
index|]
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_count
operator|==
literal|0
condition|)
block|{
comment|/* Unused location. Write our value */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|s2m_index
argument_list|,
name|srio_port
argument_list|)
argument_list|,
name|s2m
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Read back to make sure the update is complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|s2m_index
argument_list|,
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|s2m_index
return|;
block|}
else|else
block|{
comment|/* In use, see if we can use it */
if|if
condition|(
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|s2m_index
argument_list|,
name|srio_port
argument_list|)
argument_list|)
operator|==
name|s2m
operator|.
name|u64
condition|)
return|return
name|s2m_index
return|;
else|else
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|s2m_ref_count
index|[
name|s2m_index
index|]
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Unable to find free SRIOX_S2M_TYPEX\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Free a handle allocated by __cvmx_srio_alloc_s2m  *  * @param srio_port SRIO port  * @param index     Index to free  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_srio_free_s2m
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|/* Read to force pending transactions to complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|index
argument_list|,
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|s2m_ref_count
index|[
name|index
index|]
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Allocate a SLI SubID to map a region of memory. Reference  * counting is used to allow sharing of duplicate setups.  *  * @param subid  SLI_MEM_ACCESS_SUBIDX we need an index for  *  * @return Index of CSR, or negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_alloc_subid
parameter_list|(
name|cvmx_sli_mem_access_subidx_t
name|subid
parameter_list|)
block|{
name|int
name|mem_index
decl_stmt|;
comment|/* Search through the mem access subid registers looking for an unsed one         or one setup the way we need it. PCIe uses the low indexes, so search         backwards */
for|for
control|(
name|mem_index
operator|=
literal|27
init|;
name|mem_index
operator|>=
literal|12
condition|;
name|mem_index
operator|--
control|)
block|{
name|int
name|ref_count
init|=
name|cvmx_atomic_fetch_and_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
literal|0
index|]
operator|.
name|subidx_ref_count
index|[
name|mem_index
operator|-
literal|12
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_count
operator|==
literal|0
condition|)
block|{
comment|/* Unused location. Write our value */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|,
name|subid
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Read back the value to make sure the update is complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|mem_index
return|;
block|}
else|else
block|{
comment|/* In use, see if we can use it */
if|if
condition|(
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|)
operator|==
name|subid
operator|.
name|u64
condition|)
return|return
name|mem_index
return|;
else|else
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
literal|0
index|]
operator|.
name|subidx_ref_count
index|[
name|mem_index
operator|-
literal|12
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_dprintf
argument_list|(
literal|"SRIO: Unable to find free SLI_MEM_ACCESS_SUBIDX\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Free a handle allocated by __cvmx_srio_alloc_subid  *  * @param index  Index to free  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_srio_free_subid
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|/* Read to force pending transactions to complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
literal|0
index|]
operator|.
name|subidx_ref_count
index|[
name|index
operator|-
literal|12
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Read 32bits from a local port  *  * @param srio_port SRIO port the device is on  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param result    Result of the read. This will be unmodified on failure.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_local_read32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
name|cvmx_sriox_maint_op_t
name|maint_op
decl_stmt|;
name|cvmx_sriox_maint_rd_data_t
name|maint_rd_data
decl_stmt|;
name|maint_op
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|maint_op
operator|.
name|s
operator|.
name|op
operator|=
literal|0
expr_stmt|;
comment|/* Read */
name|maint_op
operator|.
name|s
operator|.
name|addr
operator|=
name|offset
expr_stmt|;
comment|/* Make sure SRIO isn't already busy */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Pending bit stuck before config read\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Issue the read to the hardware */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|maint_op
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for the hardware to complete the operation */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config read timeout\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Display and error and return if the operation failed to issue */
name|maint_op
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maint_op
operator|.
name|s
operator|.
name|fail
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config read addressing error (offset=0x%x)\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Wait for the read data to become valid */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_RD_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_rd_data_t
argument_list|,
name|valid
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config read data timeout\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the read data */
name|maint_rd_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_MAINT_RD_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|maint_rd_data
operator|.
name|s
operator|.
name|rd_data
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write 32bits to a local port  * @param srio_port SRIO port the device is on  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param data      Data to write.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_local_write32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|cvmx_sriox_maint_op_t
name|maint_op
decl_stmt|;
name|maint_op
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|maint_op
operator|.
name|s
operator|.
name|wr_data
operator|=
name|data
expr_stmt|;
name|maint_op
operator|.
name|s
operator|.
name|op
operator|=
literal|1
expr_stmt|;
comment|/* Write */
name|maint_op
operator|.
name|s
operator|.
name|addr
operator|=
name|offset
expr_stmt|;
comment|/* Make sure SRIO isn't already busy */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Pending bit stuck before config write\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Issue the write to the hardware */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|maint_op
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for the hardware to complete the operation */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config write timeout\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Display and error and return if the operation failed to issue */
name|maint_op
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maint_op
operator|.
name|s
operator|.
name|fail
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config write addressing error (offset=0x%x)\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Reset SRIO to link partner  *  * @param srio_port  SRIO port to initialize  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_srio_link_rst
parameter_list|(
name|int
name|srio_port
parameter_list|)
block|{
name|cvmx_sriomaintx_port_0_link_resp_t
name|link_resp
decl_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Generate a symbol reset to the link partner by writing 0x3. */
if|if
condition|(
name|cvmx_srio_config_write32
argument_list|(
name|srio_port
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_LINK_REQ
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|3
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cvmx_srio_config_read32
argument_list|(
name|srio_port
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_LINK_RESP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|link_resp
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Poll until link partner has received the reset. */
while|while
condition|(
name|link_resp
operator|.
name|s
operator|.
name|valid
operator|==
literal|0
condition|)
block|{
comment|//cvmx_dprintf("Waiting for Link Response\n");
if|if
condition|(
name|cvmx_srio_config_read32
argument_list|(
name|srio_port
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_LINK_RESP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|link_resp
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Valid response, Asserting MAC reset */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
literal|0x1
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|10
argument_list|)
expr_stmt|;
comment|/* De-asserting MAC Reset */
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a SRIO port for use.  *  * @param srio_port SRIO port to initialize  * @param flags     Optional flags  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_srio_initialize
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_srio_initialize_flags_t
name|flags
parameter_list|)
block|{
name|cvmx_sriomaintx_port_lt_ctl_t
name|port_lt_ctl
decl_stmt|;
name|cvmx_sriomaintx_port_rt_ctl_t
name|port_rt_ctl
decl_stmt|;
name|cvmx_sriomaintx_port_0_ctl_t
name|port_0_ctl
decl_stmt|;
name|cvmx_sriomaintx_core_enables_t
name|core_enables
decl_stmt|;
name|cvmx_sriomaintx_port_gen_ctl_t
name|port_gen_ctl
decl_stmt|;
name|cvmx_sriox_status_reg_t
name|sriox_status_reg
decl_stmt|;
name|cvmx_mio_rst_ctlx_t
name|mio_rst_ctl
decl_stmt|;
name|cvmx_sriox_imsg_vport_thr_t
name|sriox_imsg_vport_thr
decl_stmt|;
name|cvmx_dpi_sli_prtx_cfg_t
name|prt_cfg
decl_stmt|;
name|cvmx_sli_s2m_portx_ctl_t
name|sli_s2m_portx_ctl
decl_stmt|;
name|cvmx_sli_mem_access_ctl_t
name|sli_mem_access_ctl
decl_stmt|;
name|cvmx_sriomaintx_port_0_ctl2_t
name|port_0_ctl2
decl_stmt|;
name|sriox_status_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_STATUS_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
block|{
comment|/* All SRIO ports are connected to QLM0 */
name|int
name|status
init|=
name|cvmx_qlm_get_status
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|<
literal|4
operator|||
name|status
operator|>
literal|6
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Initialization called on a port not in SRIO mode\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|sriox_status_reg
operator|.
name|s
operator|.
name|srio
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Initialization called on a port not in SRIO mode\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be         programmed */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_0
argument_list|)
condition|)
block|{
if|if
condition|(
name|srio_port
condition|)
block|{
name|cvmx_ciu_qlm1_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_qlm0_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Don't receive or drive reset signals for the SRIO QLM */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
block|{
comment|/* The reset signals are available only for srio_port == 0. */
if|if
condition|(
name|srio_port
operator|==
literal|0
operator|||
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX_PASS1_2
argument_list|)
operator|&&
name|srio_port
operator|==
literal|1
operator|)
condition|)
block|{
name|cvmx_mio_rst_cntlx_t
name|mio_rst_cntl
decl_stmt|;
name|mio_rst_cntl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CNTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|mio_rst_cntl
operator|.
name|s
operator|.
name|rst_drv
operator|=
literal|0
expr_stmt|;
name|mio_rst_cntl
operator|.
name|s
operator|.
name|rst_rcv
operator|=
literal|0
expr_stmt|;
name|mio_rst_cntl
operator|.
name|s
operator|.
name|rst_chip
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_RST_CNTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|mio_rst_cntl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* MIO_RST_CNTL2<prtmode> is initialized to 0 on cold reset */
name|mio_rst_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CNTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mio_rst_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|mio_rst_ctl
operator|.
name|s
operator|.
name|rst_drv
operator|=
literal|0
expr_stmt|;
name|mio_rst_ctl
operator|.
name|s
operator|.
name|rst_rcv
operator|=
literal|0
expr_stmt|;
name|mio_rst_ctl
operator|.
name|s
operator|.
name|rst_chip
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|mio_rst_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
name|mio_rst_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Port in %s mode\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|mio_rst_ctl
operator|.
name|s
operator|.
name|prtmode
operator|)
condition|?
literal|"host"
else|:
literal|"endpoint"
argument_list|)
expr_stmt|;
comment|/* Bring the port out of reset if necessary */
switch|switch
condition|(
name|srio_port
condition|)
block|{
case|case
literal|0
case|:
block|{
name|cvmx_ciu_soft_prst_t
name|prst
decl_stmt|;
name|prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
name|prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait up to 250ms for the port to come out of reset */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_STATUS_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_status_reg_t
argument_list|,
name|access
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|250000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
case|case
literal|1
case|:
block|{
name|cvmx_ciu_soft_prst1_t
name|prst
decl_stmt|;
name|prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
name|prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait up to 250ms for the port to come out of reset */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_STATUS_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_status_reg_t
argument_list|,
name|access
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|250000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
case|case
literal|2
case|:
block|{
name|cvmx_ciu_soft_prst2_t
name|prst
decl_stmt|;
name|prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST2
argument_list|)
expr_stmt|;
if|if
condition|(
name|prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
name|prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST2
argument_list|,
name|prst
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait up to 250ms for the port to come out of reset */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_STATUS_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_status_reg_t
argument_list|,
name|access
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
literal|250000
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
break|break;
block|}
block|}
comment|/* Disable the link while we make changes */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_0_ctl
operator|.
name|s
operator|.
name|o_enable
operator|=
literal|0
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|i_enable
operator|=
literal|0
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|prt_lock
operator|=
literal|1
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|disable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* CN63XX Pass 2.0 and 2.1 errata G-15273 requires the QLM De-emphasis be         programmed when using a 156.25Mhz ref clock */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_0
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_1
argument_list|)
condition|)
block|{
name|cvmx_mio_rst_boot_t
name|mio_rst_boot
decl_stmt|;
name|cvmx_sriomaintx_lane_x_status_0_t
name|lane_x_status
decl_stmt|;
comment|/* Read the QLM config and speed pins */
name|mio_rst_boot
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_BOOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_LANE_X_STATUS_0
argument_list|(
literal|0
argument_list|,
name|srio_port
argument_list|)
argument_list|,
operator|&
name|lane_x_status
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|srio_port
condition|)
block|{
name|cvmx_ciu_qlm1_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mio_rst_boot
operator|.
name|cn63xx
operator|.
name|qlm1_spd
condition|)
block|{
case|case
literal|0x4
case|:
comment|/* 1.25 Gbaud, 156.25MHz */
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|0x0
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
operator|(
name|lane_x_status
operator|.
name|s
operator|.
name|rx_type
operator|==
literal|0
operator|)
condition|?
literal|0x11
else|:
literal|0x1c
expr_stmt|;
comment|/* short or med/long */
break|break;
case|case
literal|0xb
case|:
comment|/* 5.0 Gbaud, 156.25MHz */
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
operator|(
name|lane_x_status
operator|.
name|s
operator|.
name|rx_type
operator|==
literal|0
operator|)
condition|?
literal|0xa
else|:
literal|0xf
expr_stmt|;
comment|/* short or med/long */
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
operator|(
name|lane_x_status
operator|.
name|s
operator|.
name|rx_type
operator|==
literal|0
operator|)
condition|?
literal|0xf
else|:
literal|0x1a
expr_stmt|;
comment|/* short or med/long */
break|break;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_qlm0_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mio_rst_boot
operator|.
name|cn63xx
operator|.
name|qlm0_spd
condition|)
block|{
case|case
literal|0x4
case|:
comment|/* 1.25 Gbaud, 156.25MHz */
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|0x0
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
operator|(
name|lane_x_status
operator|.
name|s
operator|.
name|rx_type
operator|==
literal|0
operator|)
condition|?
literal|0x11
else|:
literal|0x1c
expr_stmt|;
comment|/* short or med/long */
break|break;
case|case
literal|0xb
case|:
comment|/* 5.0 Gbaud, 156.25MHz */
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
operator|(
name|lane_x_status
operator|.
name|s
operator|.
name|rx_type
operator|==
literal|0
operator|)
condition|?
literal|0xa
else|:
literal|0xf
expr_stmt|;
comment|/* short or med/long */
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
operator|(
name|lane_x_status
operator|.
name|s
operator|.
name|rx_type
operator|==
literal|0
operator|)
condition|?
literal|0xf
else|:
literal|0x1a
expr_stmt|;
comment|/* short or med/long */
break|break;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Errata SRIO-14485: Link speed is reported incorrectly in CN63XX         pass 1.x */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_sriomaintx_port_0_ctl2_t
name|port_0_ctl2
decl_stmt|;
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl2
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_500g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_625g
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_312g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_500g
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_250g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_312g
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_125g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_250g
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_125g
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl2
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Errata SRIO-15351: Turn off SRIOMAINTX_MAC_CTRL[TYPE_MRG] as it may         cause packet ACCEPT to be lost */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_0
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS2_1
argument_list|)
condition|)
block|{
name|cvmx_sriomaintx_mac_ctrl_t
name|mac_ctrl
decl_stmt|;
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_MAC_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|mac_ctrl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|mac_ctrl
operator|.
name|s
operator|.
name|type_mrg
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_MAC_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|mac_ctrl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Set the link layer timeout to 1ms. The default is too high and causes         core bus errors */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_LT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_lt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_lt_ctl
operator|.
name|s
operator|.
name|timeout
operator|=
literal|1000000
operator|/
literal|200
expr_stmt|;
comment|/* 1ms = 1000000ns / 200ns */
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_LT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_lt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set the logical layer timeout to 100ms. The default is too high and causes         core bus errors */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_RT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_rt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_rt_ctl
operator|.
name|s
operator|.
name|timeout
operator|=
literal|100000000
operator|/
literal|200
expr_stmt|;
comment|/* 100ms = 100000000ns / 200ns */
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_RT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_rt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Allow memory and doorbells. Messaging is enabled later */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_CORE_ENABLES
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|core_enables
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|core_enables
operator|.
name|s
operator|.
name|doorbell
operator|=
literal|1
expr_stmt|;
name|core_enables
operator|.
name|s
operator|.
name|memory
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_CORE_ENABLES
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|core_enables
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Allow us to master transactions */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_GEN_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_gen_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_gen_ctl
operator|.
name|s
operator|.
name|menable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_GEN_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_gen_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set the MRRS and MPS for optimal SRIO performance */
name|prt_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mps
operator|=
literal|1
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|1
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|molr
operator|=
literal|32
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
name|prt_cfg
operator|.
name|s
operator|.
name|molr
operator|=
operator|(
operator|(
name|prt_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|1
operator|||
name|prt_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|3
operator|)
condition|?
literal|8
else|:
operator|(
name|prt_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|4
operator|||
name|prt_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|6
operator|)
condition|?
literal|16
else|:
literal|32
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|prt_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sli_s2m_portx_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup RX messaging thresholds */
name|sriox_imsg_vport_thr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_IMSG_VPORT_THR
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_tot
operator|=
operator|(
operator|(
name|prt_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|1
operator|||
name|prt_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|==
literal|3
operator|)
condition|?
literal|44
else|:
literal|46
operator|)
expr_stmt|;
else|else
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_tot
operator|=
literal|48
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_s1
operator|=
literal|24
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_s0
operator|=
literal|24
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|sp_vport
operator|=
literal|1
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|buf_thr
operator|=
literal|4
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_p1
operator|=
literal|12
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_p0
operator|=
literal|12
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_IMSG_VPORT_THR
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sriox_imsg_vport_thr
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup RX messaging thresholds for other virtual ports. */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX
argument_list|)
condition|)
block|{
name|cvmx_sriox_imsg_vport_thr2_t
name|sriox_imsg_vport_thr2
decl_stmt|;
name|sriox_imsg_vport_thr2
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_IMSG_VPORT_THR2
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sriox_imsg_vport_thr2
operator|.
name|s
operator|.
name|max_s2
operator|=
literal|24
expr_stmt|;
name|sriox_imsg_vport_thr2
operator|.
name|s
operator|.
name|max_s3
operator|=
literal|24
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_IMSG_VPORT_THR2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sriox_imsg_vport_thr2
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Errata SRIO-X: SRIO error behavior may not be optimal in CN63XX pass 1.x */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_sriox_tx_ctrl_t
name|sriox_tx_ctrl
decl_stmt|;
name|sriox_tx_ctrl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sriox_tx_ctrl
operator|.
name|s
operator|.
name|tag_th2
operator|=
literal|2
expr_stmt|;
name|sriox_tx_ctrl
operator|.
name|s
operator|.
name|tag_th1
operator|=
literal|3
expr_stmt|;
name|sriox_tx_ctrl
operator|.
name|s
operator|.
name|tag_th0
operator|=
literal|4
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sriox_tx_ctrl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Errata SLI-15954: SLI relaxed order issues */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN66XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_sli_ctl_portx_t
name|sli_ctl_portx
decl_stmt|;
name|sli_ctl_portx
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_CTL_PORTX
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sli_ctl_portx
operator|.
name|s
operator|.
name|ptlp_ro
operator|=
literal|1
expr_stmt|;
comment|/* Set to same value for all MACs. */
name|sli_ctl_portx
operator|.
name|s
operator|.
name|ctlp_ro
operator|=
literal|1
expr_stmt|;
comment|/* Set to same value for all MACs. */
name|sli_ctl_portx
operator|.
name|s
operator|.
name|wait_com
operator|=
literal|0
expr_stmt|;
comment|/* So that no inbound stores wait for a commit */
name|sli_ctl_portx
operator|.
name|s
operator|.
name|waitl_com
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_CTL_PORTX
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sli_ctl_portx
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
comment|/* Clear the ACK state */
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Bring the link down, then up, by writing to the SRIO port's        PORT_0_CTL2 CSR. */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl2
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl2
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Clear any pending interrupts */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable error reporting */
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_FREEBSD_KERNEL
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|CONFIG_CAVIUM_DECODE_RSL
argument_list|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_SRIO
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Finally enable the link */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_0_ctl
operator|.
name|s
operator|.
name|o_enable
operator|=
literal|1
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|i_enable
operator|=
literal|1
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|disable
operator|=
literal|0
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|prt_lock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Store merge control (SLI_MEM_ACCESS_CTL[TIMER,MAX_WORD]) */
name|sli_mem_access_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_CTL
argument_list|)
expr_stmt|;
name|sli_mem_access_ctl
operator|.
name|s
operator|.
name|max_word
operator|=
literal|0
expr_stmt|;
comment|/* Allow 16 words to combine */
name|sli_mem_access_ctl
operator|.
name|s
operator|.
name|timer
operator|=
literal|127
expr_stmt|;
comment|/* Wait up to 127 cycles for more data */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_CTL
argument_list|,
name|sli_mem_access_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* FIXME: Disable sending a link request when the SRIO link is         brought up. For unknown reasons this code causes issues with some SRIO         devices. As we currently don't support hotplug in software, this code         should never be needed.  Without link down/up events, the ACKs should         start off and stay synchronized */
if|#
directive|if
literal|0
comment|/* Ask for a link and align our ACK state. CN63XXp1 didn't support this */
block|if (!OCTEON_IS_MODEL(OCTEON_CN63XX_PASS1_X))     {         uint64_t stop_cycle;         cvmx_sriomaintx_port_0_err_stat_t sriomaintx_port_0_err_stat;
comment|/* Clear the SLI_CTL_PORTX[DIS_PORT[ bit to re-enable traffic-flow            to the SRIO MACs. */
block|cvmx_write_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port), cvmx_read_csr(CVMX_PEXP_SLI_CTL_PORTX(srio_port)));
comment|/* Wait a little to see if the link comes up */
block|stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/4 + cvmx_clock_get_count(CVMX_CLOCK_CORE);         do         {
comment|/* Read the port link status */
block|if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_ERR_STAT(srio_port),&sriomaintx_port_0_err_stat.u32))                 return -1;         } while (!sriomaintx_port_0_err_stat.s.pt_ok&& (cvmx_clock_get_count(CVMX_CLOCK_CORE)< stop_cycle));
comment|/* Send link request if link is up */
block|if (sriomaintx_port_0_err_stat.s.pt_ok)         {             cvmx_sriomaintx_port_0_link_req_t link_req;             cvmx_sriomaintx_port_0_link_resp_t link_resp;             link_req.u32 = 0;             link_req.s.cmd = 4;
comment|/* Send the request */
block|if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_LINK_REQ(srio_port), link_req.u32))                 return -1;
comment|/* Wait for the response */
block|stop_cycle = cvmx_clock_get_rate(CVMX_CLOCK_CORE)/8 + cvmx_clock_get_count(CVMX_CLOCK_CORE);             do             {                 if (__cvmx_srio_local_read32(srio_port, CVMX_SRIOMAINTX_PORT_0_LINK_RESP(srio_port),&link_resp.u32))                     return -1;             } while (!link_resp.s.valid&& (cvmx_clock_get_count(CVMX_CLOCK_CORE)< stop_cycle));
comment|/* Set our ACK state if we got a response */
block|if (link_resp.s.valid)             {                 cvmx_sriomaintx_port_0_local_ackid_t local_ackid;                 local_ackid.u32 = 0;                 local_ackid.s.i_ackid = 0;                 local_ackid.s.e_ackid = link_resp.s.ackid;                 local_ackid.s.o_ackid = link_resp.s.ackid;                 if (__cvmx_srio_local_write32(srio_port, CVMX_SRIOMAINTX_PORT_0_LOCAL_ACKID(srio_port), local_ackid.u32))                     return -1;             }             else                  return -1;         }     }
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Read 32bits from a Device's config space  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID, or -1 for the local Octeon.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param result    Result of the read. This will be unmodified on failure.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_config_read32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint8_t
name|hopcount
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
name|destid
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|status
init|=
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|offset
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|&&
operator|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Local read [0x%06x]<= 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
else|else
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|int
name|return_code
decl_stmt|;
name|uint32_t
name|pkt
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sourceid
decl_stmt|;
name|uint64_t
name|stop_cycle
decl_stmt|;
name|char
name|rx_buffer
index|[
literal|64
index|]
decl_stmt|;
comment|/* Tell the user */
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x]<= "
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Read the proper source ID */
if|if
condition|(
name|srcid_index
condition|)
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_SEC_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
else|else
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PRI_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/* Use the 16bit source ID */
name|sourceid
operator|&=
literal|0xffff
expr_stmt|;
comment|/* MAINT Reads are 11 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|11
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|1
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|8
expr_stmt|;
comment|/* destID   [23:8] */
name|pkt
operator||=
name|sourceid
operator|>>
literal|8
expr_stmt|;
comment|/* sourceID [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|sourceid
operator|<<
literal|24
expr_stmt|;
comment|/* sourceID [31:24] */
name|pkt
operator||=
literal|0
operator|<<
literal|20
expr_stmt|;
comment|/* transaction [23:20] */
name|pkt
operator||=
literal|8
operator|<<
literal|16
expr_stmt|;
comment|/* rdsize [19:16] */
name|pkt
operator||=
literal|0xc0
operator|<<
literal|8
expr_stmt|;
comment|/* srcTID [15:8] */
name|pkt
operator||=
name|hopcount
expr_stmt|;
comment|/* hopcount [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|8
expr_stmt|;
comment|/* offset [31:11, wdptr[10], reserved[9:8] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the 8bit source ID */
name|sourceid
operator|=
operator|(
name|sourceid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* MAINT Reads are 9 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|9
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|0
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|16
expr_stmt|;
comment|/* destID   [23:16] */
name|pkt
operator||=
name|sourceid
operator|<<
literal|8
expr_stmt|;
comment|/* sourceID [15:8] */
name|pkt
operator||=
literal|0
operator|<<
literal|4
expr_stmt|;
comment|/* transaction [7:4] */
name|pkt
operator||=
literal|8
operator|<<
literal|0
expr_stmt|;
comment|/* rdsize [3:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
literal|0xc0
operator|<<
literal|24
expr_stmt|;
comment|/* srcTID [31:24] */
name|pkt
operator||=
name|hopcount
operator|<<
literal|16
expr_stmt|;
comment|/* hopcount [23:16] */
name|pkt
operator||=
name|offset
operator|>>
literal|8
expr_stmt|;
comment|/* offset [15:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|24
expr_stmt|;
comment|/* offset [31:27, wdptr[26], reserved[25:24] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
name|stop_cycle
operator|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|10
operator|+
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
expr_stmt|;
do|do
block|{
name|return_code
operator|=
name|cvmx_srio_receive_spf
argument_list|(
name|srio_port
argument_list|,
name|rx_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|return_code
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|>
name|stop_cycle
operator|)
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"timeout\n"
argument_list|)
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|return_code
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|return_code
operator|==
operator|(
operator|(
name|is16bit
operator|)
condition|?
literal|23
else|:
literal|19
operator|)
condition|)
block|{
if|if
condition|(
name|is16bit
condition|)
block|{
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|15
operator|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|11
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|13
operator|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|9
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result
operator|=
literal|0xffffffff
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|return_code
return|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
name|uint64_t
name|physical
decl_stmt|;
name|physical
operator|=
name|cvmx_srio_physical_map
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIO_WRITE_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|CVMX_SRIO_READ_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|srcid_index
argument_list|,
name|destid
argument_list|,
name|is16bit
argument_list|,
name|offset
operator|+
operator|(
name|hopcount
operator|<<
literal|24
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|physical
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x]<= "
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Finally do the maintenance read to complete the config request */
operator|*
name|result
operator|=
name|cvmx_read64_uint32
argument_list|(
name|CVMX_ADD_IO_SEG
argument_list|(
name|physical
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_srio_physical_unmap
argument_list|(
name|physical
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_srio_config_read32
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Write 32bits to a Device's config space  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID, or -1 for the local Octeon.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param data      Data to write.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_config_write32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint8_t
name|hopcount
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|destid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Local write[0x%06x] => 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|int
name|return_code
decl_stmt|;
name|uint32_t
name|pkt
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sourceid
decl_stmt|;
name|uint64_t
name|stop_cycle
decl_stmt|;
name|char
name|rx_buffer
index|[
literal|64
index|]
decl_stmt|;
comment|/* Tell the user */
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* Read the proper source ID */
if|if
condition|(
name|srcid_index
condition|)
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_SEC_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
else|else
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PRI_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/* Use the 16bit source ID */
name|sourceid
operator|&=
literal|0xffff
expr_stmt|;
comment|/* MAINT Writes are 19 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|19
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|1
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|8
expr_stmt|;
comment|/* destID   [23:8] */
name|pkt
operator||=
name|sourceid
operator|>>
literal|8
expr_stmt|;
comment|/* sourceID [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|sourceid
operator|<<
literal|24
expr_stmt|;
comment|/* sourceID [31:24] */
name|pkt
operator||=
literal|1
operator|<<
literal|20
expr_stmt|;
comment|/* transaction [23:20] */
name|pkt
operator||=
literal|8
operator|<<
literal|16
expr_stmt|;
comment|/* wrsize [19:16] */
name|pkt
operator||=
literal|0xc0
operator|<<
literal|8
expr_stmt|;
comment|/* srcTID [15:8] */
name|pkt
operator||=
name|hopcount
expr_stmt|;
comment|/* hopcount [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|8
expr_stmt|;
comment|/* offset [31:11, wdptr[10], reserved[9:8] */
if|if
condition|(
operator|(
name|offset
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
name|pkt
operator||=
literal|0xff
operator|&
operator|(
name|data
operator|>>
literal|24
operator|)
expr_stmt|;
comment|/* data [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
block|{
name|pkt
operator|=
literal|0xff
operator|&
operator|(
name|data
operator|>>
literal|24
operator|)
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|<<
literal|8
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkt
operator|=
name|data
operator|<<
literal|8
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use the 8bit source ID */
name|sourceid
operator|=
operator|(
name|sourceid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* MAINT Writes are 17 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|17
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|0
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|16
expr_stmt|;
comment|/* destID   [23:16] */
name|pkt
operator||=
name|sourceid
operator|<<
literal|8
expr_stmt|;
comment|/* sourceID [15:8] */
name|pkt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
comment|/* transaction [7:4] */
name|pkt
operator||=
literal|8
operator|<<
literal|0
expr_stmt|;
comment|/* wrsize [3:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
literal|0xc0
operator|<<
literal|24
expr_stmt|;
comment|/* srcTID [31:24] */
name|pkt
operator||=
name|hopcount
operator|<<
literal|16
expr_stmt|;
comment|/* hopcount [23:16] */
name|pkt
operator||=
name|offset
operator|>>
literal|8
expr_stmt|;
comment|/* offset [15:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|24
expr_stmt|;
comment|/* offset [31:27, wdptr[26], reserved[25:24] */
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
block|{
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|>>
literal|8
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|<<
literal|24
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkt
operator||=
name|data
operator|>>
literal|8
expr_stmt|;
comment|/* data [23:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|<<
literal|24
expr_stmt|;
comment|/* data [31:24] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_cycle
operator|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|10
operator|+
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
expr_stmt|;
do|do
block|{
name|return_code
operator|=
name|cvmx_srio_receive_spf
argument_list|(
name|srio_port
argument_list|,
name|rx_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|return_code
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|>
name|stop_cycle
operator|)
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"timeout\n"
argument_list|)
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|return_code
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|return_code
operator|==
operator|(
operator|(
name|is16bit
operator|)
condition|?
literal|15
else|:
literal|11
operator|)
condition|)
name|return_code
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote write failed\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|return_code
return|;
block|}
else|else
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
name|uint64_t
name|physical
init|=
name|cvmx_srio_physical_map
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIO_WRITE_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|CVMX_SRIO_READ_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|srcid_index
argument_list|,
name|destid
argument_list|,
name|is16bit
argument_list|,
name|offset
operator|+
operator|(
name|hopcount
operator|<<
literal|24
operator|)
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|physical
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* Finally do the maintenance write to complete the config request */
name|cvmx_write64_uint32
argument_list|(
name|CVMX_ADD_IO_SEG
argument_list|(
name|physical
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|cvmx_srio_physical_unmap
argument_list|(
name|physical
argument_list|,
literal|4
argument_list|)
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/**  * Send a RapidIO doorbell to a remote device  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param priority  Doorbell priority (0-3)  * @param data      Data for doorbell.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_send_doorbell
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|int
name|priority
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|cvmx_sriox_tx_bell_t
name|tx_bell
decl_stmt|;
name|tx_bell
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|dest_id
operator|=
name|destid
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|src_id
operator|=
name|srcid_index
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|id16
operator|=
operator|!
operator|!
name|is16bit
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
comment|/* Make sure the previous doorbell has completed */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_TX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_tx_bell_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_DOORBELL_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Pending bit stuck before doorbell\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Send doorbell destid=0x%x, priority=%d, data=0x%x\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|priority
argument_list|,
literal|0xffff
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* Send the doorbell. We don't wait for it to complete. The next doorbell         may delay on the pending bit, but this gives the caller the ability to         do other stuff while the doorbell processes */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_TX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|tx_bell
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_srio_send_doorbell
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Get the status of the last doorbell sent. If the dooorbell  * hardware is done, then the status is cleared to get ready for  * the next doorbell (or retry).  *  * @param srio_port SRIO port to check doorbell on  *  * @return Doorbell status  */
end_comment

begin_function
name|cvmx_srio_doorbell_status_t
name|cvmx_srio_send_doorbell_status
parameter_list|(
name|int
name|srio_port
parameter_list|)
block|{
name|cvmx_sriox_tx_bell_t
name|tx_bell
decl_stmt|;
name|cvmx_sriox_tx_bell_info_t
name|tx_bell_info
decl_stmt|;
name|cvmx_sriox_int_reg_t
name|int_reg
decl_stmt|;
name|cvmx_sriox_int_reg_t
name|int_reg_clear
decl_stmt|;
comment|/* Return busy if the doorbell is still processing */
name|tx_bell
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_TX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bell
operator|.
name|s
operator|.
name|pending
condition|)
return|return
name|CVMX_SRIO_DOORBELL_BUSY
return|;
comment|/* Read and clear the TX doorbell interrupts */
name|int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|int_reg_clear
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|int_reg_clear
operator|.
name|s
operator|.
name|bell_err
operator|=
name|int_reg
operator|.
name|s
operator|.
name|bell_err
expr_stmt|;
name|int_reg_clear
operator|.
name|s
operator|.
name|txbell
operator|=
name|int_reg
operator|.
name|s
operator|.
name|txbell
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|int_reg_clear
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Check for errors */
if|if
condition|(
name|int_reg
operator|.
name|s
operator|.
name|bell_err
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Send doorbell failed\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
name|tx_bell_info
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_TX_BELL_INFO
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bell_info
operator|.
name|s
operator|.
name|timeout
condition|)
return|return
name|CVMX_SRIO_DOORBELL_TMOUT
return|;
if|if
condition|(
name|tx_bell_info
operator|.
name|s
operator|.
name|error
condition|)
return|return
name|CVMX_SRIO_DOORBELL_ERROR
return|;
if|if
condition|(
name|tx_bell_info
operator|.
name|s
operator|.
name|retry
condition|)
return|return
name|CVMX_SRIO_DOORBELL_RETRY
return|;
block|}
comment|/* Check if we're done */
if|if
condition|(
name|int_reg
operator|.
name|s
operator|.
name|txbell
condition|)
return|return
name|CVMX_SRIO_DOORBELL_DONE
return|;
comment|/* No doorbell found */
return|return
name|CVMX_SRIO_DOORBELL_NONE
return|;
block|}
end_function

begin_comment
comment|/**  * Read a received doorbell and report data about it.  *  * @param srio_port SRIO port to check for the received doorbell  * @param destid_index  *                  Which Octeon destination ID was the doorbell for  * @param sequence_num  *                  Sequence number of doorbell (32bits)  * @param srcid     RapidIO source ID of the doorbell sender  * @param priority  Priority of the doorbell (0-3)  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param data      Data in the doorbell (16 bits)  *  * @return Doorbell status. Either DONE, NONE, or ERROR.  */
end_comment

begin_function
name|cvmx_srio_doorbell_status_t
name|cvmx_srio_receive_doorbell
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
modifier|*
name|destid_index
parameter_list|,
name|uint32_t
modifier|*
name|sequence_num
parameter_list|,
name|int
modifier|*
name|srcid
parameter_list|,
name|int
modifier|*
name|priority
parameter_list|,
name|int
modifier|*
name|is16bit
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|cvmx_sriox_rx_bell_seq_t
name|rx_bell_seq
decl_stmt|;
name|cvmx_sriox_rx_bell_t
name|rx_bell
decl_stmt|;
comment|/* Check if there are any pending doorbells */
name|rx_bell_seq
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_RX_BELL_SEQ
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_bell_seq
operator|.
name|s
operator|.
name|count
condition|)
return|return
name|CVMX_SRIO_DOORBELL_NONE
return|;
comment|/* Read the doorbell and write our return parameters */
name|rx_bell
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_RX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sequence_num
operator|=
name|rx_bell_seq
operator|.
name|s
operator|.
name|seq
expr_stmt|;
operator|*
name|srcid
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|src_id
expr_stmt|;
operator|*
name|priority
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|priority
expr_stmt|;
operator|*
name|is16bit
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|id16
expr_stmt|;
operator|*
name|data
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|data
expr_stmt|;
operator|*
name|destid_index
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|dest_id
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Receive doorbell sequence=0x%x, srcid=0x%x, priority=%d, data=0x%x\n"
argument_list|,
name|srio_port
argument_list|,
name|rx_bell_seq
operator|.
name|s
operator|.
name|seq
argument_list|,
name|rx_bell
operator|.
name|s
operator|.
name|src_id
argument_list|,
name|rx_bell
operator|.
name|s
operator|.
name|priority
argument_list|,
name|rx_bell
operator|.
name|s
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|CVMX_SRIO_DOORBELL_DONE
return|;
block|}
end_function

begin_comment
comment|/**  * Receive a packet from the Soft Packet FIFO (SPF).  *  * @param srio_port SRIO port to read the packet from.  * @param buffer    Buffer to receive the packet.  * @param buffer_length  *                  Length of the buffer in bytes.  *  * @return Returns the length of the packet read. Negative on failure.  *         Zero if no packets are available.  */
end_comment

begin_function
name|int
name|cvmx_srio_receive_spf
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ptr
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
decl_stmt|;
name|cvmx_sriomaintx_ir_sp_rx_stat_t
name|sriomaintx_ir_sp_rx_stat
decl_stmt|;
comment|/* Read the SFP status */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_RX_STAT
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sriomaintx_ir_sp_rx_stat
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Return zero if there isn't a packet available */
if|if
condition|(
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|buffers
operator|<
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Soft packet FIFO received %d bytes"
argument_list|,
name|srio_port
argument_list|,
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
argument_list|)
expr_stmt|;
comment|/* Return error if the packet is larger than our buffer */
if|if
condition|(
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
operator|>
name|buffer_length
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Read out the packet four bytes at a time */
name|buffer_length
operator|=
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
expr_stmt|;
while|while
condition|(
name|buffer_length
operator|>
literal|0
condition|)
block|{
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_RX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|" %08x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|buffer_length
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Return the number of bytes in the buffer */
return|return
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * Map a remote device's memory region into Octeon's physical  * address area. The caller can then map this into a core using  * the TLB or XKPHYS.  *  * @param srio_port SRIO port to map the device on  * @param write_op  Type of operation to perform on a write to the device.  *                  Normally should be CVMX_SRIO_WRITE_MODE_AUTO.  * @param write_priority  *                  SRIO priority of writes (0-3)  * @param read_op   Type of operation to perform on reads to the device.  *                  Normally should be CVMX_SRIO_READ_MODE_NORMAL.  * @param read_priority  *                  SRIO priority of reads (0-3)  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param base      Device base address to start the mapping  * @param size      Size of the mapping in bytes  *  * @return Octeon 64bit physical address that accesses the remote device,  *         or zero on failure.  */
end_comment

begin_function
name|uint64_t
name|cvmx_srio_physical_map
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_srio_write_mode_t
name|write_op
parameter_list|,
name|int
name|write_priority
parameter_list|,
name|cvmx_srio_read_mode_t
name|read_op
parameter_list|,
name|int
name|read_priority
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|cvmx_sriox_s2m_typex_t
name|needed_s2m_type
decl_stmt|;
name|cvmx_sli_mem_access_subidx_t
name|needed_subid
decl_stmt|;
name|int
name|s2m_index
decl_stmt|;
name|int
name|subdid
decl_stmt|;
name|cvmx_sli_address_t
name|sli_address
decl_stmt|;
comment|/* We currently don't support mapping regions that span a 34 bit boundary.         Keeping track of multiple regions to span 34 bits is hard and not         likely to be needed */
if|if
condition|(
operator|(
operator|(
name|base
operator|+
name|size
operator|-
literal|1
operator|)
operator|>>
literal|34
operator|)
operator|!=
operator|(
name|base
operator|>>
literal|34
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Failed to map range 0x%llx-0x%llx spanning a 34bit boundary\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|ULL
operator|)
name|base
argument_list|,
operator|(
name|ULL
operator|)
name|base
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Build the S2M_TYPE we are going to need */
name|needed_s2m_type
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|wr_op
operator|=
name|write_op
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|rd_op
operator|=
name|read_op
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|wr_prior
operator|=
name|write_priority
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|rd_prior
operator|=
name|read_priority
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|src_id
operator|=
name|srcid_index
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|id16
operator|=
operator|!
operator|!
name|is16bit
expr_stmt|;
comment|/* Build the needed SubID config */
name|needed_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|port
operator|=
name|srio_port
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|0
expr_stmt|;
comment|/* FIXME: We might want to use the device ID swapping modes so the device         ID is part of the lower address bits. This would allow many more         devices to share S2M_TYPE indexes. This would require "base+size-1"         to fit in bits [17:0] or bits[25:0] for 8 bits of device ID */
if|if
condition|(
name|base
operator|<
operator|(
literal|1ull
operator|<<
literal|34
operator|)
condition|)
block|{
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator|=
name|destid
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|iaow_sel
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<
operator|(
literal|1ull
operator|<<
literal|42
operator|)
condition|)
block|{
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator|=
operator|(
name|base
operator|>>
literal|34
operator|)
operator|&
literal|0xff
expr_stmt|;
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|destid
operator|&
literal|0xff
operator|)
operator|<<
operator|(
literal|42
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|destid
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|<<
operator|(
literal|51
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|iaow_sel
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|destid
operator|>>
literal|8
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Attempt to map 16bit device ID 0x%x using 66bit addressing\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
operator|>>
literal|50
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Attempt to map address 0x%llx using 66bit addressing\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|ULL
operator|)
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator|=
operator|(
name|base
operator|>>
literal|34
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|destid
operator|&
literal|0xff
operator|)
operator|<<
operator|(
literal|51
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|iaow_sel
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Find a S2M_TYPE index to use. If this fails return 0 */
name|s2m_index
operator|=
name|__cvmx_srio_alloc_s2m
argument_list|(
name|srio_port
argument_list|,
name|needed_s2m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2m_index
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Attach the SubID to the S2M_TYPE index */
name|needed_subid
operator|.
name|s
operator|.
name|rtype
operator|=
name|s2m_index
operator|&
literal|3
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|wtype
operator|=
name|s2m_index
operator|&
literal|3
expr_stmt|;
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|s2m_index
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|<<
operator|(
literal|50
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_subid
operator|.
name|cn63xx
operator|.
name|ba
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|s2m_index
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
operator|<<
operator|(
literal|59
operator|-
literal|34
operator|)
expr_stmt|;
comment|/* Allocate a SubID for use */
name|subdid
operator|=
name|__cvmx_srio_alloc_subid
argument_list|(
name|needed_subid
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Free the s2m_index as we aren't using it */
name|__cvmx_srio_free_s2m
argument_list|(
name|srio_port
argument_list|,
name|s2m_index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Build the final core physical address */
name|sli_address
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|subdid
operator|=
name|subdid
operator|>>
literal|2
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|se
operator|=
name|subdid
operator|&
literal|3
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|address
operator|=
name|base
expr_stmt|;
comment|/* Bits[33:0] of full address */
return|return
name|sli_address
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Unmap a physical address window created by cvmx_srio_phys_map().  *  * @param physical_address  *               Physical address returned by cvmx_srio_phys_map().  * @param size   Size used on original call.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_physical_unmap
parameter_list|(
name|uint64_t
name|physical_address
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|cvmx_sli_mem_access_subidx_t
name|subid
decl_stmt|;
name|int
name|subdid
init|=
operator|(
name|physical_address
operator|>>
literal|40
operator|)
operator|&
literal|7
decl_stmt|;
name|int
name|extender
init|=
operator|(
name|physical_address
operator|>>
literal|34
operator|)
operator|&
literal|3
decl_stmt|;
name|int
name|mem_index
init|=
name|subdid
operator|*
literal|4
operator|+
name|extender
decl_stmt|;
name|int
name|read_s2m_type
decl_stmt|;
comment|/* Get the subid setup so we can figure out where this mapping was for */
name|subid
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type[0] is mapped to the Relaxed Ordering        Type[1] is mapped to the No Snoop        Type[2] is mapped directly to bit 50 of the SLI address        Type[3] is mapped directly to bit 59 of the SLI address */
name|read_s2m_type
operator|=
operator|(
operator|(
name|subid
operator|.
name|cn63xx
operator|.
name|ba
operator|>>
operator|(
literal|50
operator|-
literal|34
operator|)
operator|)
operator|&
literal|1
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|subid
operator|.
name|cn63xx
operator|.
name|ba
operator|>>
operator|(
literal|59
operator|-
literal|34
operator|)
operator|)
operator|&
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
name|read_s2m_type
operator||=
name|subid
operator|.
name|s
operator|.
name|rtype
expr_stmt|;
name|__cvmx_srio_free_subid
argument_list|(
name|mem_index
argument_list|)
expr_stmt|;
name|__cvmx_srio_free_s2m
argument_list|(
name|subid
operator|.
name|s
operator|.
name|port
argument_list|,
name|read_s2m_type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
end_ifdef

begin_comment
comment|/**  * fill out outbound message descriptor  *  * @param port        pip/ipd port number  * @param buf_ptr     pointer to a buffer pointer. the buffer pointer points  *                    to a chain of buffers that hold an outbound srio packet.  *                    the packet can take the format of (1) a pip/ipd inbound  *                    message or (2) an application-generated outbound message  * @param desc_ptr    pointer to an outbound message descriptor. should be null  *                    if *buf_ptr is in the format (1)  *  * @return           0 on success; negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_omsg_desc
parameter_list|(
name|uint64_t
name|port
parameter_list|,
name|cvmx_buf_ptr_t
modifier|*
name|buf_ptr
parameter_list|,
name|cvmx_srio_tx_message_header_t
modifier|*
name|desc_ptr
parameter_list|)
block|{
name|int
name|ret_val
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|intf_num
decl_stmt|;
name|cvmx_helper_interface_mode_t
name|imode
decl_stmt|;
name|uint64_t
modifier|*
name|desc_addr
decl_stmt|,
modifier|*
name|hdr_addr
decl_stmt|;
name|cvmx_srio_rx_message_header_t
name|rx_msg_hdr
decl_stmt|;
name|cvmx_srio_tx_message_header_t
modifier|*
name|tx_msg_hdr_ptr
decl_stmt|;
if|if
condition|(
name|buf_ptr
operator|==
name|NULL
condition|)
return|return
name|ret_val
return|;
comment|/* check if port is an srio port */
name|intf_num
operator|=
name|cvmx_helper_get_interface_num
argument_list|(
name|port
argument_list|)
expr_stmt|;
name|imode
operator|=
name|cvmx_helper_interface_get_mode
argument_list|(
name|intf_num
argument_list|)
expr_stmt|;
if|if
condition|(
name|imode
operator|!=
name|CVMX_HELPER_INTERFACE_MODE_SRIO
condition|)
return|return
name|ret_val
return|;
comment|/* app-generated outbound message. descriptor space pre-allocated */
if|if
condition|(
name|desc_ptr
operator|!=
name|NULL
condition|)
block|{
name|desc_addr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|addr
argument_list|)
expr_stmt|;
operator|*
name|desc_addr
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|desc_ptr
expr_stmt|;
name|ret_val
operator|=
literal|0
expr_stmt|;
return|return
name|ret_val
return|;
block|}
comment|/* pip/ipd inbound message. 16-byte srio message header is present */
name|hdr_addr
operator|=
operator|(
name|uint64_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|addr
argument_list|)
expr_stmt|;
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|u64
operator|=
operator|*
name|hdr_addr
expr_stmt|;
comment|/* adjust buffer pointer to get rid of srio message header word 0 */
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|addr
operator|+=
literal|8
expr_stmt|;
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|size
operator|-=
literal|8
expr_stmt|;
comment|/* last buffer or not */
if|if
condition|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|addr
operator|>>
literal|7
operator|>
operator|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|addr
operator|-
literal|8
operator|)
operator|>>
literal|7
condition|)
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|back
operator|++
expr_stmt|;
name|tx_msg_hdr_ptr
operator|=
operator|(
name|cvmx_srio_tx_message_header_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
operator|(
operator|*
name|buf_ptr
operator|)
operator|.
name|s
operator|.
name|addr
argument_list|)
expr_stmt|;
comment|/* transfer values from rx to tx */
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|prio
operator|=
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|s
operator|.
name|prio
expr_stmt|;
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|tt
operator|=
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|s
operator|.
name|tt
expr_stmt|;
comment|/* called id in hrm */
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|sis
operator|=
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|s
operator|.
name|dis
expr_stmt|;
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|ssize
operator|=
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|s
operator|.
name|ssize
expr_stmt|;
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|did
operator|=
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|s
operator|.
name|sid
expr_stmt|;
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|mbox
operator|=
name|rx_msg_hdr
operator|.
name|word0
operator|.
name|s
operator|.
name|mbox
expr_stmt|;
comment|/* other values we have to decide */
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|xmbox
operator|=
literal|0
expr_stmt|;
comment|/* multi-segement in general */
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|letter
operator|=
literal|0
expr_stmt|;
comment|/* fake like traffic gen */
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|lns
operator|=
literal|0
expr_stmt|;
comment|/* not use sriox_omsg_ctrly[] */
name|tx_msg_hdr_ptr
operator|->
name|s
operator|.
name|intr
operator|=
literal|1
expr_stmt|;
comment|/* get status */
name|ret_val
operator|=
literal|0
expr_stmt|;
return|return
name|ret_val
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

