begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Interface to SRIO  *  *<hr>$Revision: 41586 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-srio.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-clock.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-atomic.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CONFIG_CAVIUM_DECODE_RSL
end_ifdef

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-error.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sriox-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sriomaintx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sli-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-dpi-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pexp-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-srio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-clock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_include
include|#
directive|include
file|"cvmx-atomic.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-error.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-errata.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|CVMX_SRIO_USE_FIFO_FOR_MAINT
value|1
end_define

begin_define
define|#
directive|define
name|CVMX_SRIO_CONFIG_TIMEOUT
value|10000
end_define

begin_comment
comment|/* 10ms */
end_comment

begin_define
define|#
directive|define
name|CVMX_SRIO_DOORBELL_TIMEOUT
value|10000
end_define

begin_comment
comment|/* 10ms */
end_comment

begin_define
define|#
directive|define
name|CVMX_SRIO_CONFIG_PRIORITY
value|0
end_define

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_typedef
typedef|typedef
union|union
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
comment|/* Normally 2 for XKPHYS */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
comment|/* 1 for IO space access */
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
comment|/* DID = 3 */
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
comment|/* SubDID = 3-6 */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
comment|/* SubDID extender */
name|uint64_t
name|reserved_32_33
range|:
literal|2
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|hopcount
range|:
literal|8
decl_stmt|;
comment|/* Hopcount */
name|uint64_t
name|address
range|:
literal|24
decl_stmt|;
comment|/* Mem address */
else|#
directive|else
name|uint64_t
name|address
range|:
literal|24
decl_stmt|;
name|uint64_t
name|hopcount
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_33
range|:
literal|2
decl_stmt|;
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|config
struct|;
struct|struct
block|{
if|#
directive|if
name|__BYTE_ORDER
operator|==
name|__BIG_ENDIAN
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
comment|/* Normally 2 for XKPHYS */
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
comment|/* 1 for IO space access */
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
comment|/* DID = 3 */
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
comment|/* SubDID = 3-6 */
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
comment|/* Must be zero */
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
comment|/* SubDID extender */
name|uint64_t
name|address
range|:
literal|34
decl_stmt|;
comment|/* Mem address */
else|#
directive|else
name|uint64_t
name|address
range|:
literal|34
decl_stmt|;
name|uint64_t
name|se
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_39
range|:
literal|4
decl_stmt|;
name|uint64_t
name|subdid
range|:
literal|3
decl_stmt|;
name|uint64_t
name|did
range|:
literal|5
decl_stmt|;
name|uint64_t
name|io
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_49_61
range|:
literal|13
decl_stmt|;
name|uint64_t
name|upper
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|mem
struct|;
block|}
name|cvmx_sli_address_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|cvmx_srio_initialize_flags_t
name|flags
decl_stmt|;
name|int32_t
name|subidx_ref_count
index|[
literal|16
index|]
decl_stmt|;
comment|/* Reference count for SLI_MEM_ACCESS_SUBID[12-27]. Index=X-12 */
name|int32_t
name|s2m_ref_count
index|[
literal|16
index|]
decl_stmt|;
comment|/* Reference count for SRIOX_S2M_TYPE[0-15]. */
block|}
name|__cvmx_srio_state_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|__cvmx_srio_state_t
name|__cvmx_srio_state
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * @INTERNAL  * Allocate a SRIOX_S2M_TYPEX register for mapping a remote SRIO  * device's address range into Octeons SLI address space. Reference  * counting is used to allow sharing of duplicate setups. The current  * implementation treats reads and writes as paired, but this could be  * changed if we have trouble running out of indexes.  *  * @param srio_port SRIO port device is on  * @param s2m       SRIOX_S2M_TYPEX setup required  *  * @return Index of CSR, or negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_alloc_s2m
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_sriox_s2m_typex_t
name|s2m
parameter_list|)
block|{
name|int
name|s2m_index
decl_stmt|;
comment|/* Search through the S2M_TYPE registers looking for an unsed one or one         setup the way we need it */
for|for
control|(
name|s2m_index
operator|=
literal|0
init|;
name|s2m_index
operator|<
literal|16
condition|;
name|s2m_index
operator|++
control|)
block|{
comment|/* Increment ref count by 2 since we count read and write             independently. We might need a more complicated search in the             future */
name|int
name|ref_count
init|=
name|cvmx_atomic_fetch_and_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|s2m_ref_count
index|[
name|s2m_index
index|]
argument_list|,
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_count
operator|==
literal|0
condition|)
block|{
comment|/* Unused location. Write our value */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|s2m_index
argument_list|,
name|srio_port
argument_list|)
argument_list|,
name|s2m
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
name|s2m_index
return|;
block|}
else|else
block|{
comment|/* In use, see if we can use it */
if|if
condition|(
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|s2m_index
argument_list|,
name|srio_port
argument_list|)
argument_list|)
operator|==
name|s2m
operator|.
name|u64
condition|)
return|return
name|s2m_index
return|;
else|else
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|s2m_ref_count
index|[
name|s2m_index
index|]
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Unable to find free SRIOX_S2M_TYPEX\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Free a handle allocated by __cvmx_srio_alloc_s2m  *  * @param srio_port SRIO port  * @param index     Index to free  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_srio_free_s2m
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|index
parameter_list|)
block|{
comment|/* Read to force pending transactions to complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_S2M_TYPEX
argument_list|(
name|index
argument_list|,
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|s2m_ref_count
index|[
name|index
index|]
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Allocate a SLI SubID to map a region of memory. Reference  * counting is used to allow sharing of duplicate setups.  *  * @param subid  SLI_MEM_ACCESS_SUBIDX we need an index for  *  * @return Index of CSR, or negative on failure  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_alloc_subid
parameter_list|(
name|cvmx_sli_mem_access_subidx_t
name|subid
parameter_list|)
block|{
name|int
name|mem_index
decl_stmt|;
comment|/* Search through the mem access subid registers looking for an unsed one         or one setup the way we need it. PCIe uses the low indexes, so search         backwards */
for|for
control|(
name|mem_index
operator|=
literal|27
init|;
name|mem_index
operator|>=
literal|12
condition|;
name|mem_index
operator|--
control|)
block|{
name|int
name|ref_count
init|=
name|cvmx_atomic_fetch_and_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
literal|0
index|]
operator|.
name|subidx_ref_count
index|[
name|mem_index
operator|-
literal|12
index|]
argument_list|,
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|ref_count
operator|==
literal|0
condition|)
block|{
comment|/* Unused location. Write our value */
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|,
name|subid
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
name|mem_index
return|;
block|}
else|else
block|{
comment|/* In use, see if we can use it */
if|if
condition|(
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|)
operator|==
name|subid
operator|.
name|u64
condition|)
return|return
name|mem_index
return|;
else|else
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
literal|0
index|]
operator|.
name|subidx_ref_count
index|[
name|mem_index
operator|-
literal|12
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|cvmx_dprintf
argument_list|(
literal|"SRIO: Unable to find free SLI_MEM_ACCESS_SUBIDX\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Free a handle allocated by __cvmx_srio_alloc_subid  *  * @param index  Index to free  */
end_comment

begin_function
specifier|static
name|void
name|__cvmx_srio_free_subid
parameter_list|(
name|int
name|index
parameter_list|)
block|{
comment|/* Read to force pending transactions to complete */
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|index
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_atomic_add32
argument_list|(
operator|&
name|__cvmx_srio_state
index|[
literal|0
index|]
operator|.
name|subidx_ref_count
index|[
name|index
operator|-
literal|12
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Read 32bits from a local port  *  * @param srio_port SRIO port the device is on  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param result    Result of the read. This will be unmodified on failure.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_local_read32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
name|cvmx_sriox_maint_op_t
name|maint_op
decl_stmt|;
name|cvmx_sriox_maint_rd_data_t
name|maint_rd_data
decl_stmt|;
name|maint_op
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|maint_op
operator|.
name|s
operator|.
name|op
operator|=
literal|0
expr_stmt|;
comment|/* Read */
name|maint_op
operator|.
name|s
operator|.
name|addr
operator|=
name|offset
expr_stmt|;
comment|/* Make sure SRIO isn't already busy */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Pending bit stuck before config read\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Issue the read to the hardware */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|maint_op
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for the hardware to complete the operation */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config read timeout\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Display and error and return if the operation failed to issue */
name|maint_op
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maint_op
operator|.
name|s
operator|.
name|fail
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config read addressing error (offset=0x%x)\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Wait for the read data to become valid */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_RD_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_rd_data_t
argument_list|,
name|valid
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config read data timeout\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Get the read data */
name|maint_rd_data
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_MAINT_RD_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|maint_rd_data
operator|.
name|s
operator|.
name|rd_data
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Write 32bits to a local port  * @param srio_port SRIO port the device is on  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param data      Data to write.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_srio_local_write32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
name|cvmx_sriox_maint_op_t
name|maint_op
decl_stmt|;
name|maint_op
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|maint_op
operator|.
name|s
operator|.
name|wr_data
operator|=
name|data
expr_stmt|;
name|maint_op
operator|.
name|s
operator|.
name|op
operator|=
literal|1
expr_stmt|;
comment|/* Write */
name|maint_op
operator|.
name|s
operator|.
name|addr
operator|=
name|offset
expr_stmt|;
comment|/* Make sure SRIO isn't already busy */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Pending bit stuck before config write\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Issue the write to the hardware */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|maint_op
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Wait for the hardware to complete the operation */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_maint_op_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_CONFIG_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config write timeout\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Display and error and return if the operation failed to issue */
name|maint_op
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_MAINT_OP
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maint_op
operator|.
name|s
operator|.
name|fail
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Config write addressing error (offset=0x%x)\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Initialize a SRIO port for use.  *  * @param srio_port SRIO port to initialize  * @param flags     Optional flags  *  * @return Zero on success  */
end_comment

begin_function
name|int
name|cvmx_srio_initialize
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_srio_initialize_flags_t
name|flags
parameter_list|)
block|{
name|cvmx_sriomaintx_port_lt_ctl_t
name|port_lt_ctl
decl_stmt|;
name|cvmx_sriomaintx_port_rt_ctl_t
name|port_rt_ctl
decl_stmt|;
name|cvmx_sriomaintx_port_0_ctl_t
name|port_0_ctl
decl_stmt|;
name|cvmx_sriomaintx_core_enables_t
name|core_enables
decl_stmt|;
name|cvmx_sriomaintx_port_gen_ctl_t
name|port_gen_ctl
decl_stmt|;
name|cvmx_sriox_status_reg_t
name|sriox_status_reg
decl_stmt|;
name|cvmx_mio_rst_ctlx_t
name|mio_rst_ctl
decl_stmt|;
name|cvmx_sriox_imsg_vport_thr_t
name|sriox_imsg_vport_thr
decl_stmt|;
name|cvmx_dpi_sli_prtx_cfg_t
name|prt_cfg
decl_stmt|;
name|cvmx_sli_s2m_portx_ctl_t
name|sli_s2m_portx_ctl
decl_stmt|;
name|sriox_status_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_STATUS_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sriox_status_reg
operator|.
name|s
operator|.
name|srio
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Initialization called on a port not in SRIO mode\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|=
name|flags
expr_stmt|;
comment|/* CN63XX Pass 1.0 errata G-14395 requires the QLM De-emphasis be         programmed */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_0
argument_list|)
condition|)
block|{
if|if
condition|(
name|srio_port
condition|)
block|{
name|cvmx_ciu_qlm1_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM1
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_ciu_qlm0_t
name|ciu_qlm
decl_stmt|;
name|ciu_qlm
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|)
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txbypass
operator|=
literal|1
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txdeemph
operator|=
literal|5
expr_stmt|;
name|ciu_qlm
operator|.
name|s
operator|.
name|txmargin
operator|=
literal|0x17
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_QLM0
argument_list|,
name|ciu_qlm
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
name|mio_rst_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_RST_CTLX
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Port in %s mode\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|mio_rst_ctl
operator|.
name|s
operator|.
name|prtmode
operator|)
condition|?
literal|"host"
else|:
literal|"endpoint"
argument_list|)
expr_stmt|;
comment|/* Bring the port out of reset if necessary */
if|if
condition|(
name|srio_port
condition|)
block|{
name|cvmx_ciu_soft_prst1_t
name|prst
decl_stmt|;
name|prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
name|prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST1
argument_list|,
name|prst
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* 10ms for new link to stabalize */
block|}
block|}
else|else
block|{
name|cvmx_ciu_soft_prst_t
name|prst
decl_stmt|;
name|prst
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|)
expr_stmt|;
if|if
condition|(
name|prst
operator|.
name|s
operator|.
name|soft_prst
condition|)
block|{
name|prst
operator|.
name|s
operator|.
name|soft_prst
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_CIU_SOFT_PRST
argument_list|,
name|prst
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|10000
argument_list|)
expr_stmt|;
comment|/* 10ms for new link to stabalize */
block|}
block|}
comment|/* Disable the link while we make changes */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_0_ctl
operator|.
name|s
operator|.
name|disable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Errata SRIO-14485: Link speed is reported incorrectly in CN63XX         pass 1.x */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_sriomaintx_port_0_ctl2_t
name|port_0_ctl2
decl_stmt|;
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl2
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_500g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_625g
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_312g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_500g
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_250g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_312g
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_125g
condition|)
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_250g
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|port_0_ctl2
operator|.
name|u32
operator|=
literal|0
expr_stmt|;
name|port_0_ctl2
operator|.
name|s
operator|.
name|enb_125g
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL2
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl2
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
block|}
comment|/* Set the link layer timeout to 10us. The default is too high and causes         core bus errors */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_LT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_lt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_lt_ctl
operator|.
name|s
operator|.
name|timeout
operator|=
literal|10000
operator|/
literal|200
expr_stmt|;
comment|/* 10us = 10000ns / 200ns */
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_LT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_lt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set the logical layer timeout to 10ms. The default is too high and causes         core bus errors */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_RT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_rt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_rt_ctl
operator|.
name|s
operator|.
name|timeout
operator|=
literal|10000000
operator|/
literal|200
expr_stmt|;
comment|/* 10ms = 10000000ns / 200ns */
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_RT_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_rt_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Allow memory and doorbells. Messaging is enabled later */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_CORE_ENABLES
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|core_enables
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|core_enables
operator|.
name|s
operator|.
name|doorbell
operator|=
literal|1
expr_stmt|;
name|core_enables
operator|.
name|s
operator|.
name|memory
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_CORE_ENABLES
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|core_enables
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Allow us to master transactions */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_GEN_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_gen_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_gen_ctl
operator|.
name|s
operator|.
name|menable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_GEN_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_gen_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Set the MRRS and MPS for optimal SRIO performance */
name|prt_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mps
operator|=
literal|1
expr_stmt|;
name|prt_cfg
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_DPI_SLI_PRTX_CFG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|prt_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sli_s2m_portx_ctl
operator|.
name|s
operator|.
name|mrrs
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_PEXP_SLI_S2M_PORTX_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sli_s2m_portx_ctl
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Setup RX messaging thresholds */
name|sriox_imsg_vport_thr
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_IMSG_VPORT_THR
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_tot
operator|=
literal|48
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_s1
operator|=
literal|24
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_s0
operator|=
literal|24
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|sp_vport
operator|=
literal|1
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|buf_thr
operator|=
literal|4
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_p1
operator|=
literal|12
expr_stmt|;
name|sriox_imsg_vport_thr
operator|.
name|s
operator|.
name|max_p0
operator|=
literal|12
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_IMSG_VPORT_THR
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sriox_imsg_vport_thr
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Errata SRIO-X: SRIO error behavior may not be optimal in CN63XX pass 1.x */
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN63XX_PASS1_X
argument_list|)
condition|)
block|{
name|cvmx_sriox_tx_ctrl_t
name|sriox_tx_ctrl
decl_stmt|;
name|sriox_tx_ctrl
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|sriox_tx_ctrl
operator|.
name|s
operator|.
name|tag_th2
operator|=
literal|2
expr_stmt|;
name|sriox_tx_ctrl
operator|.
name|s
operator|.
name|tag_th1
operator|=
literal|3
expr_stmt|;
name|sriox_tx_ctrl
operator|.
name|s
operator|.
name|tag_th0
operator|=
literal|4
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|sriox_tx_ctrl
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* Clear any pending interrupts */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable error reporting */
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|)
operator|||
name|defined
argument_list|(
name|CONFIG_CAVIUM_DECODE_RSL
argument_list|)
name|cvmx_error_enable_group
argument_list|(
name|CVMX_ERROR_GROUP_SRIO
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Finally enable the link */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|port_0_ctl
operator|.
name|s
operator|.
name|o_enable
operator|=
literal|1
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|i_enable
operator|=
literal|1
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|disable
operator|=
literal|0
expr_stmt|;
name|port_0_ctl
operator|.
name|s
operator|.
name|prt_lock
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PORT_0_CTL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|port_0_ctl
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Read 32bits from a Device's config space  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID, or -1 for the local Octeon.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param result    Result of the read. This will be unmodified on failure.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_config_read32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint8_t
name|hopcount
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
modifier|*
name|result
parameter_list|)
block|{
if|if
condition|(
name|destid
operator|==
operator|-
literal|1
condition|)
block|{
name|int
name|status
init|=
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|offset
argument_list|,
name|result
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|status
operator|==
literal|0
operator|)
operator|&&
operator|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
operator|)
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Local read [0x%06x]<= 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
else|else
block|{
if|#
directive|if
name|CVMX_SRIO_USE_FIFO_FOR_MAINT
name|int
name|return_code
decl_stmt|;
name|uint32_t
name|pkt
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sourceid
decl_stmt|;
name|uint64_t
name|stop_cycle
decl_stmt|;
name|char
name|rx_buffer
index|[
literal|64
index|]
decl_stmt|;
comment|/* Tell the user */
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x]<= "
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|)
expr_stmt|;
comment|/* Read the proper source ID */
if|if
condition|(
name|srcid_index
condition|)
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_SEC_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
else|else
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PRI_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/* Use the 16bit source ID */
name|sourceid
operator|&=
literal|0xffff
expr_stmt|;
comment|/* MAINT Reads are 11 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|11
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|1
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|8
expr_stmt|;
comment|/* destID   [23:8] */
name|pkt
operator||=
name|sourceid
operator|>>
literal|8
expr_stmt|;
comment|/* sourceID [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|sourceid
operator|<<
literal|24
expr_stmt|;
comment|/* sourceID [31:24] */
name|pkt
operator||=
literal|0
operator|<<
literal|20
expr_stmt|;
comment|/* transaction [23:20] */
name|pkt
operator||=
literal|8
operator|<<
literal|16
expr_stmt|;
comment|/* rdsize [19:16] */
name|pkt
operator||=
literal|0xc0
operator|<<
literal|8
expr_stmt|;
comment|/* srcTID [15:8] */
name|pkt
operator||=
name|hopcount
expr_stmt|;
comment|/* hopcount [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|8
expr_stmt|;
comment|/* offset [31:11, wdptr[10], reserved[9:8] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the 8bit source ID */
name|sourceid
operator|=
operator|(
name|sourceid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* MAINT Reads are 9 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|9
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|0
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|16
expr_stmt|;
comment|/* destID   [23:16] */
name|pkt
operator||=
name|sourceid
operator|<<
literal|8
expr_stmt|;
comment|/* sourceID [15:8] */
name|pkt
operator||=
literal|0
operator|<<
literal|4
expr_stmt|;
comment|/* transaction [7:4] */
name|pkt
operator||=
literal|8
operator|<<
literal|0
expr_stmt|;
comment|/* rdsize [3:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
literal|0xc0
operator|<<
literal|24
expr_stmt|;
comment|/* srcTID [31:24] */
name|pkt
operator||=
name|hopcount
operator|<<
literal|16
expr_stmt|;
comment|/* hopcount [23:16] */
name|pkt
operator||=
name|offset
operator|>>
literal|8
expr_stmt|;
comment|/* offset [15:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|24
expr_stmt|;
comment|/* offset [31:27, wdptr[26], reserved[25:24] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
name|stop_cycle
operator|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|10
operator|+
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
expr_stmt|;
do|do
block|{
name|return_code
operator|=
name|cvmx_srio_receive_spf
argument_list|(
name|srio_port
argument_list|,
name|rx_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|return_code
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|>
name|stop_cycle
operator|)
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"timeout\n"
argument_list|)
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|return_code
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|return_code
operator|==
operator|(
operator|(
name|is16bit
operator|)
condition|?
literal|23
else|:
literal|19
operator|)
condition|)
block|{
if|if
condition|(
name|is16bit
condition|)
block|{
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|15
operator|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|11
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|13
operator|)
expr_stmt|;
else|else
operator|*
name|result
operator|=
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|(
name|rx_buffer
operator|+
literal|9
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"0x%08x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|result
argument_list|)
expr_stmt|;
name|return_code
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|*
name|result
operator|=
literal|0xffffffff
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|return_code
return|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
name|uint64_t
name|physical
decl_stmt|;
name|physical
operator|=
name|cvmx_srio_physical_map
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIO_WRITE_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|CVMX_SRIO_READ_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|srcid_index
argument_list|,
name|destid
argument_list|,
name|is16bit
argument_list|,
name|offset
operator|+
operator|(
name|hopcount
operator|<<
literal|24
operator|)
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|physical
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote read [id=0x%04x hop=%3d offset=0x%06x]<= "
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
name|offset
argument_list|)
expr_stmt|;
comment|/* Finally do the maintenance read to complete the config request */
operator|*
name|result
operator|=
name|cvmx_read64_uint32
argument_list|(
name|CVMX_ADD_IO_SEG
argument_list|(
name|physical
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_srio_physical_unmap
argument_list|(
name|physical
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"0x%08x\n"
argument_list|,
operator|*
name|result
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/**  * Write 32bits to a Device's config space  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID, or -1 for the local Octeon.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param hopcount  Number of hops to the remote device. Use 0 for the local Octeon.  * @param offset    Offset in config space. This must be a multiple of 32 bits.  * @param data      Data to write.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_config_write32
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint8_t
name|hopcount
parameter_list|,
name|uint32_t
name|offset
parameter_list|,
name|uint32_t
name|data
parameter_list|)
block|{
if|if
condition|(
name|destid
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Local write[0x%06x] => 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|data
argument_list|)
expr_stmt|;
return|return
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
return|;
block|}
else|else
block|{
if|#
directive|if
name|CVMX_SRIO_USE_FIFO_FOR_MAINT
name|int
name|return_code
decl_stmt|;
name|uint32_t
name|pkt
init|=
literal|0
decl_stmt|;
name|uint32_t
name|sourceid
decl_stmt|;
name|uint64_t
name|stop_cycle
decl_stmt|;
name|char
name|rx_buffer
index|[
literal|64
index|]
decl_stmt|;
comment|/* Tell the user */
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|offset
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|data
argument_list|)
expr_stmt|;
comment|/* Read the proper source ID */
if|if
condition|(
name|srcid_index
condition|)
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_SEC_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
else|else
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_PRI_DEV_ID
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sourceid
argument_list|)
expr_stmt|;
if|if
condition|(
name|is16bit
condition|)
block|{
comment|/* Use the 16bit source ID */
name|sourceid
operator|&=
literal|0xffff
expr_stmt|;
comment|/* MAINT Writes are 19 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|19
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|1
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|8
expr_stmt|;
comment|/* destID   [23:8] */
name|pkt
operator||=
name|sourceid
operator|>>
literal|8
expr_stmt|;
comment|/* sourceID [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|sourceid
operator|<<
literal|24
expr_stmt|;
comment|/* sourceID [31:24] */
name|pkt
operator||=
literal|1
operator|<<
literal|20
expr_stmt|;
comment|/* transaction [23:20] */
name|pkt
operator||=
literal|8
operator|<<
literal|16
expr_stmt|;
comment|/* wrsize [19:16] */
name|pkt
operator||=
literal|0xc0
operator|<<
literal|8
expr_stmt|;
comment|/* srcTID [15:8] */
name|pkt
operator||=
name|hopcount
expr_stmt|;
comment|/* hopcount [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|8
expr_stmt|;
comment|/* offset [31:11, wdptr[10], reserved[9:8] */
if|if
condition|(
operator|(
name|offset
operator|&
literal|4
operator|)
operator|==
literal|0
condition|)
name|pkt
operator||=
literal|0xff
operator|&
operator|(
name|data
operator|>>
literal|24
operator|)
expr_stmt|;
comment|/* data [7:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
block|{
name|pkt
operator|=
literal|0xff
operator|&
operator|(
name|data
operator|>>
literal|24
operator|)
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|<<
literal|8
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkt
operator|=
name|data
operator|<<
literal|8
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use the 8bit source ID */
name|sourceid
operator|=
operator|(
name|sourceid
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* MAINT Writes are 17 bytes */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_CTRL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|17
operator|<<
literal|16
argument_list|)
expr_stmt|;
name|pkt
operator||=
name|CVMX_SRIO_CONFIG_PRIORITY
operator|<<
literal|30
expr_stmt|;
comment|/* priority [31:30] */
name|pkt
operator||=
literal|0
operator|<<
literal|28
expr_stmt|;
comment|/* tt       [29:28] */
name|pkt
operator||=
literal|0x8
operator|<<
literal|24
expr_stmt|;
comment|/* ftype    [27:24] */
name|pkt
operator||=
name|destid
operator|<<
literal|16
expr_stmt|;
comment|/* destID   [23:16] */
name|pkt
operator||=
name|sourceid
operator|<<
literal|8
expr_stmt|;
comment|/* sourceID [15:8] */
name|pkt
operator||=
literal|1
operator|<<
literal|4
expr_stmt|;
comment|/* transaction [7:4] */
name|pkt
operator||=
literal|8
operator|<<
literal|0
expr_stmt|;
comment|/* wrsize [3:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
literal|0xc0
operator|<<
literal|24
expr_stmt|;
comment|/* srcTID [31:24] */
name|pkt
operator||=
name|hopcount
operator|<<
literal|16
expr_stmt|;
comment|/* hopcount [23:16] */
name|pkt
operator||=
name|offset
operator|>>
literal|8
expr_stmt|;
comment|/* offset [15:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
literal|0
expr_stmt|;
name|pkt
operator||=
name|offset
operator|<<
literal|24
expr_stmt|;
comment|/* offset [31:27, wdptr[26], reserved[25:24] */
if|if
condition|(
name|offset
operator|&
literal|4
condition|)
block|{
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|>>
literal|8
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|<<
literal|24
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pkt
operator||=
name|data
operator|>>
literal|8
expr_stmt|;
comment|/* data [23:0] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|pkt
operator|=
name|data
operator|<<
literal|24
expr_stmt|;
comment|/* data [31:24] */
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|pkt
argument_list|)
expr_stmt|;
name|__cvmx_srio_local_write32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_TX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|stop_cycle
operator|=
name|cvmx_clock_get_rate
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|/
literal|10
operator|+
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
expr_stmt|;
do|do
block|{
name|return_code
operator|=
name|cvmx_srio_receive_spf
argument_list|(
name|srio_port
argument_list|,
name|rx_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|rx_buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|return_code
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cvmx_clock_get_count
argument_list|(
name|CVMX_CLOCK_CORE
argument_list|)
operator|>
name|stop_cycle
operator|)
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"timeout\n"
argument_list|)
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
do|while
condition|(
name|return_code
operator|==
literal|0
condition|)
do|;
if|if
condition|(
name|return_code
operator|==
operator|(
operator|(
name|is16bit
operator|)
condition|?
literal|15
else|:
literal|11
operator|)
condition|)
name|return_code
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote write failed\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
name|return_code
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|return_code
return|;
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_HOST
argument_list|)
name|uint64_t
name|physical
init|=
name|cvmx_srio_physical_map
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIO_WRITE_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|CVMX_SRIO_READ_MODE_MAINTENANCE
argument_list|,
name|CVMX_SRIO_CONFIG_PRIORITY
argument_list|,
name|srcid_index
argument_list|,
name|destid
argument_list|,
name|is16bit
argument_list|,
name|offset
operator|+
operator|(
name|hopcount
operator|<<
literal|24
operator|)
argument_list|,
literal|4
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|physical
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Remote write[id=0x%04x hop=%3d offset=0x%06x] => 0x%08x\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|hopcount
argument_list|,
name|offset
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Finally do the maintenance write to complete the config request */
name|cvmx_write64_uint32
argument_list|(
name|CVMX_ADD_IO_SEG
argument_list|(
name|physical
argument_list|)
argument_list|,
name|data
argument_list|)
expr_stmt|;
return|return
name|cvmx_srio_physical_unmap
argument_list|(
name|physical
argument_list|,
literal|4
argument_list|)
return|;
else|#
directive|else
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/**  * Send a RapidIO doorbell to a remote device  *  * @param srio_port SRIO port the device is on  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param priority  Doorbell priority (0-3)  * @param data      Data for doorbell.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_send_doorbell
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|int
name|priority
parameter_list|,
name|uint16_t
name|data
parameter_list|)
block|{
name|cvmx_sriox_tx_bell_t
name|tx_bell
decl_stmt|;
name|tx_bell
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|dest_id
operator|=
name|destid
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|src_id
operator|=
name|srcid_index
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|id16
operator|=
operator|!
operator|!
name|is16bit
expr_stmt|;
name|tx_bell
operator|.
name|s
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
comment|/* Make sure the previous doorbell has completed */
if|if
condition|(
name|CVMX_WAIT_FOR_FIELD64
argument_list|(
name|CVMX_SRIOX_TX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|cvmx_sriox_tx_bell_t
argument_list|,
name|pending
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|,
name|CVMX_SRIO_DOORBELL_TIMEOUT
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Pending bit stuck before doorbell\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Send doorbell destid=0x%x, priority=%d, data=0x%x\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|,
name|priority
argument_list|,
literal|0xffff
operator|&
name|data
argument_list|)
expr_stmt|;
comment|/* Send the doorbell. We don't wait for it to complete. The next doorbell         may delay on the pending bit, but this gives the caller the ability to         do other stuff while the doorbell processes */
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_TX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|tx_bell
operator|.
name|u64
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get the status of the last doorbell sent. If the dooorbell  * hardware is done, then the status is cleared to get ready for  * the next doorbell (or retry).  *  * @param srio_port SRIO port to check doorbell on  *  * @return Doorbell status  */
end_comment

begin_function
name|cvmx_srio_doorbell_status_t
name|cvmx_srio_send_doorbell_status
parameter_list|(
name|int
name|srio_port
parameter_list|)
block|{
name|cvmx_sriox_tx_bell_t
name|tx_bell
decl_stmt|;
name|cvmx_sriox_tx_bell_info_t
name|tx_bell_info
decl_stmt|;
name|cvmx_sriox_int_reg_t
name|int_reg
decl_stmt|;
name|cvmx_sriox_int_reg_t
name|int_reg_clear
decl_stmt|;
comment|/* Return busy if the doorbell is still processing */
name|tx_bell
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_TX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bell
operator|.
name|s
operator|.
name|pending
condition|)
return|return
name|CVMX_SRIO_DOORBELL_BUSY
return|;
comment|/* Read and clear the TX doorbell interrupts */
name|int_reg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
name|int_reg_clear
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|int_reg_clear
operator|.
name|s
operator|.
name|bell_err
operator|=
name|int_reg
operator|.
name|s
operator|.
name|bell_err
expr_stmt|;
name|int_reg_clear
operator|.
name|s
operator|.
name|txbell
operator|=
name|int_reg
operator|.
name|s
operator|.
name|txbell
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_SRIOX_INT_REG
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|int_reg_clear
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* Check for errors */
if|if
condition|(
name|int_reg
operator|.
name|s
operator|.
name|bell_err
condition|)
block|{
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Send doorbell failed\n"
argument_list|,
name|srio_port
argument_list|)
expr_stmt|;
name|tx_bell_info
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_TX_BELL_INFO
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx_bell_info
operator|.
name|s
operator|.
name|timeout
operator|||
name|tx_bell_info
operator|.
name|s
operator|.
name|error
condition|)
return|return
name|CVMX_SRIO_DOORBELL_ERROR
return|;
if|if
condition|(
name|tx_bell_info
operator|.
name|s
operator|.
name|retry
condition|)
return|return
name|CVMX_SRIO_DOORBELL_RETRY
return|;
block|}
comment|/* Check if we're done */
if|if
condition|(
name|int_reg
operator|.
name|s
operator|.
name|txbell
condition|)
return|return
name|CVMX_SRIO_DOORBELL_DONE
return|;
comment|/* No doorbell found */
return|return
name|CVMX_SRIO_DOORBELL_NONE
return|;
block|}
end_function

begin_comment
comment|/**  * Read a received doorbell and report data about it.  *  * @param srio_port SRIO port to check for the received doorbell  * @param destid_index  *                  Which Octeon destination ID was the doorbell for  * @param sequence_num  *                  Sequence number of doorbell (32bits)  * @param srcid     RapidIO source ID of the doorbell sender  * @param priority  Priority of the doorbell (0-3)  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param data      Data in the doorbell (16 bits)  *  * @return Doorbell status. Either DONE, NONE, or ERROR.  */
end_comment

begin_function
name|cvmx_srio_doorbell_status_t
name|cvmx_srio_receive_doorbell
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|int
modifier|*
name|destid_index
parameter_list|,
name|uint32_t
modifier|*
name|sequence_num
parameter_list|,
name|int
modifier|*
name|srcid
parameter_list|,
name|int
modifier|*
name|priority
parameter_list|,
name|int
modifier|*
name|is16bit
parameter_list|,
name|uint16_t
modifier|*
name|data
parameter_list|)
block|{
name|cvmx_sriox_rx_bell_seq_t
name|rx_bell_seq
decl_stmt|;
name|cvmx_sriox_rx_bell_t
name|rx_bell
decl_stmt|;
comment|/* Check if there are any pending doorbells */
name|rx_bell_seq
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_RX_BELL_SEQ
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rx_bell_seq
operator|.
name|s
operator|.
name|count
condition|)
return|return
name|CVMX_SRIO_DOORBELL_NONE
return|;
comment|/* Read the doorbell and write our return parameters */
name|rx_bell
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_SRIOX_RX_BELL
argument_list|(
name|srio_port
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|sequence_num
operator|=
name|rx_bell_seq
operator|.
name|s
operator|.
name|seq
expr_stmt|;
operator|*
name|srcid
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|src_id
expr_stmt|;
operator|*
name|priority
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|priority
expr_stmt|;
operator|*
name|is16bit
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|id16
expr_stmt|;
operator|*
name|data
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|data
expr_stmt|;
operator|*
name|destid_index
operator|=
name|rx_bell
operator|.
name|s
operator|.
name|dest_id
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Receive doorbell sequence=0x%x, srcid=0x%x, priority=%d, data=0x%x\n"
argument_list|,
name|srio_port
argument_list|,
name|rx_bell_seq
operator|.
name|s
operator|.
name|seq
argument_list|,
name|rx_bell
operator|.
name|s
operator|.
name|src_id
argument_list|,
name|rx_bell
operator|.
name|s
operator|.
name|priority
argument_list|,
name|rx_bell
operator|.
name|s
operator|.
name|data
argument_list|)
expr_stmt|;
return|return
name|CVMX_SRIO_DOORBELL_DONE
return|;
block|}
end_function

begin_comment
comment|/**  * Receive a packet from the Soft Packet FIFO (SPF).  *  * @param srio_port SRIO port to read the packet from.  * @param buffer    Buffer to receive the packet.  * @param buffer_length  *                  Length of the buffer in bytes.  *  * @return Returns the length of the packet read. Negative on failure.  *         Zero if no packets are available.  */
end_comment

begin_function
name|int
name|cvmx_srio_receive_spf
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|int
name|buffer_length
parameter_list|)
block|{
name|uint32_t
modifier|*
name|ptr
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|buffer
decl_stmt|;
name|cvmx_sriomaintx_ir_sp_rx_stat_t
name|sriomaintx_ir_sp_rx_stat
decl_stmt|;
comment|/* Read the SFP status */
if|if
condition|(
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_RX_STAT
argument_list|(
name|srio_port
argument_list|)
argument_list|,
operator|&
name|sriomaintx_ir_sp_rx_stat
operator|.
name|u32
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Return zero if there isn't a packet available */
if|if
condition|(
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|buffers
operator|<
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Soft packet FIFO received %d bytes"
argument_list|,
name|srio_port
argument_list|,
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
argument_list|)
expr_stmt|;
comment|/* Return error if the packet is larger than our buffer */
if|if
condition|(
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
operator|>
name|buffer_length
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Read out the packet four bytes at a time */
name|buffer_length
operator|=
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
expr_stmt|;
while|while
condition|(
name|buffer_length
operator|>
literal|0
condition|)
block|{
name|__cvmx_srio_local_read32
argument_list|(
name|srio_port
argument_list|,
name|CVMX_SRIOMAINTX_IR_SP_RX_DATA
argument_list|(
name|srio_port
argument_list|)
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|" %08x"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|ptr
operator|++
expr_stmt|;
name|buffer_length
operator|-=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|__cvmx_srio_state
index|[
name|srio_port
index|]
operator|.
name|flags
operator|&
name|CVMX_SRIO_INITIALIZE_DEBUG
condition|)
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Return the number of bytes in the buffer */
return|return
name|sriomaintx_ir_sp_rx_stat
operator|.
name|s
operator|.
name|octets
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/**  * Map a remote device's memory region into Octeon's physical  * address area. The caller can then map this into a core using  * the TLB or XKPHYS.  *  * @param srio_port SRIO port to map the device on  * @param write_op  Type of operation to perform on a write to the device.  *                  Normally should be CVMX_SRIO_WRITE_MODE_AUTO.  * @param write_priority  *                  SRIO priority of writes (0-3)  * @param read_op   Type of operation to perform on reads to the device.  *                  Normally should be CVMX_SRIO_READ_MODE_NORMAL.  * @param read_priority  *                  SRIO priority of reads (0-3)  * @param srcid_index  *                  Which SRIO source ID to use. 0 = Primary, 1 = Secondary  * @param destid    RapidIO device ID.  * @param is16bit   Non zero if the transactions should use 16bit device IDs. Zero  *                  if transactions should use 8bit device IDs.  * @param base      Device base address to start the mapping  * @param size      Size of the mapping in bytes  *  * @return Octeon 64bit physical address that accesses the remote device,  *         or zero on failure.  */
end_comment

begin_function
name|uint64_t
name|cvmx_srio_physical_map
parameter_list|(
name|int
name|srio_port
parameter_list|,
name|cvmx_srio_write_mode_t
name|write_op
parameter_list|,
name|int
name|write_priority
parameter_list|,
name|cvmx_srio_read_mode_t
name|read_op
parameter_list|,
name|int
name|read_priority
parameter_list|,
name|int
name|srcid_index
parameter_list|,
name|int
name|destid
parameter_list|,
name|int
name|is16bit
parameter_list|,
name|uint64_t
name|base
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|cvmx_sriox_s2m_typex_t
name|needed_s2m_type
decl_stmt|;
name|cvmx_sli_mem_access_subidx_t
name|needed_subid
decl_stmt|;
name|int
name|s2m_index
decl_stmt|;
name|int
name|subdid
decl_stmt|;
name|cvmx_sli_address_t
name|sli_address
decl_stmt|;
comment|/* We currently don't support mapping regions that span a 34 bit boundary.         Keeping track of multiple regions to span 34 bits is hard and not         likely to be needed */
if|if
condition|(
operator|(
operator|(
name|base
operator|+
name|size
operator|-
literal|1
operator|)
operator|>>
literal|34
operator|)
operator|!=
operator|(
name|base
operator|>>
literal|34
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Failed to map range 0x%llx-0x%llx spanning a 34bit boundary\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|ULL
operator|)
name|base
argument_list|,
operator|(
name|ULL
operator|)
name|base
operator|+
name|size
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Build the S2M_TYPE we are going to need */
name|needed_s2m_type
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|wr_op
operator|=
name|write_op
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|rd_op
operator|=
name|read_op
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|wr_prior
operator|=
name|write_priority
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|rd_prior
operator|=
name|read_priority
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|src_id
operator|=
name|srcid_index
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|id16
operator|=
operator|!
operator|!
name|is16bit
expr_stmt|;
comment|/* Build the needed SubID config */
name|needed_subid
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|port
operator|=
name|srio_port
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|nmerge
operator|=
literal|1
expr_stmt|;
comment|/* FIXME: We might want to use the device ID swapping modes so the device         ID is part of the lower address bits. This would allow many more         devices to share S2M_TYPE indexes. This would require "base+size-1"         to fit in bits [17:0] or bits[25:0] for 8 bits of device ID */
if|if
condition|(
name|base
operator|<
operator|(
literal|1ull
operator|<<
literal|34
operator|)
condition|)
block|{
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator|=
name|destid
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|iaow_sel
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|base
operator|<
operator|(
literal|1ull
operator|<<
literal|42
operator|)
condition|)
block|{
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator|=
operator|(
name|base
operator|>>
literal|34
operator|)
operator|&
literal|0xff
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|destid
operator|&
literal|0xff
operator|)
operator|<<
operator|(
literal|42
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|destid
operator|>>
literal|8
operator|)
operator|&
literal|0xff
operator|)
operator|<<
operator|(
literal|51
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|iaow_sel
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|destid
operator|>>
literal|8
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Attempt to map 16bit device ID 0x%x using 66bit addressing\n"
argument_list|,
name|srio_port
argument_list|,
name|destid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|base
operator|>>
literal|50
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"SRIO%d: Attempt to map address 0x%llx using 66bit addressing\n"
argument_list|,
name|srio_port
argument_list|,
operator|(
name|ULL
operator|)
name|base
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator|=
operator|(
name|base
operator|>>
literal|34
operator|)
operator|&
literal|0xffff
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|destid
operator|&
literal|0xff
operator|)
operator|<<
operator|(
literal|51
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_s2m_type
operator|.
name|s
operator|.
name|iaow_sel
operator|=
literal|2
expr_stmt|;
block|}
comment|/* Find a S2M_TYPE index to use. If this fails return 0 */
name|s2m_index
operator|=
name|__cvmx_srio_alloc_s2m
argument_list|(
name|srio_port
argument_list|,
name|needed_s2m_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|s2m_index
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Attach the SubID to the S2M_TYPE index */
name|needed_subid
operator|.
name|s
operator|.
name|rtype
operator|=
name|s2m_index
operator|&
literal|3
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|wtype
operator|=
name|s2m_index
operator|&
literal|3
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|s2m_index
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|<<
operator|(
literal|50
operator|-
literal|34
operator|)
expr_stmt|;
name|needed_subid
operator|.
name|s
operator|.
name|ba
operator||=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|s2m_index
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
operator|<<
operator|(
literal|59
operator|-
literal|34
operator|)
expr_stmt|;
comment|/* Allocate a SubID for use */
name|subdid
operator|=
name|__cvmx_srio_alloc_subid
argument_list|(
name|needed_subid
argument_list|)
expr_stmt|;
if|if
condition|(
name|subdid
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Free the s2m_index as we aren't using it */
name|__cvmx_srio_free_s2m
argument_list|(
name|srio_port
argument_list|,
name|s2m_index
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Build the final core physical address */
name|sli_address
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|io
operator|=
literal|1
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|did
operator|=
literal|3
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|subdid
operator|=
name|subdid
operator|>>
literal|2
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|se
operator|=
name|subdid
operator|&
literal|3
expr_stmt|;
name|sli_address
operator|.
name|mem
operator|.
name|address
operator|=
name|base
expr_stmt|;
comment|/* Bits[33:0] of full address */
return|return
name|sli_address
operator|.
name|u64
return|;
block|}
end_function

begin_comment
comment|/**  * Unmap a physical address window created by cvmx_srio_phys_map().  *  * @param physical_address  *               Physical address returned by cvmx_srio_phys_map().  * @param size   Size used on original call.  *  * @return Zero on success, negative on failure.  */
end_comment

begin_function
name|int
name|cvmx_srio_physical_unmap
parameter_list|(
name|uint64_t
name|physical_address
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|cvmx_sli_mem_access_subidx_t
name|subid
decl_stmt|;
name|int
name|subdid
init|=
operator|(
name|physical_address
operator|>>
literal|40
operator|)
operator|&
literal|7
decl_stmt|;
name|int
name|extender
init|=
operator|(
name|physical_address
operator|>>
literal|34
operator|)
operator|&
literal|3
decl_stmt|;
name|int
name|mem_index
init|=
name|subdid
operator|*
literal|4
operator|+
name|extender
decl_stmt|;
name|int
name|read_s2m_type
decl_stmt|;
comment|/* Get the subid setup so we can figure out where this mapping was for */
name|subid
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_PEXP_SLI_MEM_ACCESS_SUBIDX
argument_list|(
name|mem_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Type[0] is mapped to the Relaxed Ordering        Type[1] is mapped to the No Snoop        Type[2] is mapped directly to bit 50 of the SLI address        Type[3] is mapped directly to bit 59 of the SLI address */
name|read_s2m_type
operator|=
operator|(
operator|(
name|subid
operator|.
name|s
operator|.
name|ba
operator|>>
operator|(
literal|50
operator|-
literal|34
operator|)
operator|)
operator|&
literal|1
operator|<<
literal|2
operator|)
operator||
operator|(
operator|(
name|subid
operator|.
name|s
operator|.
name|ba
operator|>>
operator|(
literal|59
operator|-
literal|34
operator|)
operator|)
operator|&
literal|1
operator|<<
literal|3
operator|)
expr_stmt|;
name|read_s2m_type
operator||=
name|subid
operator|.
name|s
operator|.
name|rtype
expr_stmt|;
name|__cvmx_srio_free_subid
argument_list|(
name|mem_index
argument_list|)
expr_stmt|;
name|__cvmx_srio_free_s2m
argument_list|(
name|subid
operator|.
name|s
operator|.
name|port
argument_list|,
name|read_s2m_type
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

