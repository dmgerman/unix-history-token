begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2012  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * cvmx-ilk-defs.h  *  * Configuration and status register (CSR) type definitions for  * Octeon ilk.  *  * This file is auto generated. Do not edit.  *  *<hr>$Revision$<hr>  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__CVMX_ILK_DEFS_H__
end_ifndef

begin_define
define|#
directive|define
name|__CVMX_ILK_DEFS_H__
end_define

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_BIST_SUM
value|CVMX_ILK_BIST_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_BIST_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_BIST_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000038ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_BIST_SUM
value|(CVMX_ADD_IO_SEG(0x0001180014000038ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_GBL_CFG
value|CVMX_ILK_GBL_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_GBL_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_GBL_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_GBL_CFG
value|(CVMX_ADD_IO_SEG(0x0001180014000000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_GBL_INT
value|CVMX_ILK_GBL_INT_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_GBL_INT_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_GBL_INT not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_GBL_INT
value|(CVMX_ADD_IO_SEG(0x0001180014000008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_GBL_INT_EN
value|CVMX_ILK_GBL_INT_EN_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_GBL_INT_EN_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_GBL_INT_EN not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000010ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_GBL_INT_EN
value|(CVMX_ADD_IO_SEG(0x0001180014000010ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_INT_SUM
value|CVMX_ILK_INT_SUM_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_INT_SUM_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_INT_SUM not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000030ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_INT_SUM
value|(CVMX_ADD_IO_SEG(0x0001180014000030ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_LNE_DBG
value|CVMX_ILK_LNE_DBG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_LNE_DBG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_LNE_DBG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014030008ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_LNE_DBG
value|(CVMX_ADD_IO_SEG(0x0001180014030008ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_LNE_STS_MSG
value|CVMX_ILK_LNE_STS_MSG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_LNE_STS_MSG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_LNE_STS_MSG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014030000ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_LNE_STS_MSG
value|(CVMX_ADD_IO_SEG(0x0001180014030000ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_RXF_IDX_PMAP
value|CVMX_ILK_RXF_IDX_PMAP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXF_IDX_PMAP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXF_IDX_PMAP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000020ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXF_IDX_PMAP
value|(CVMX_ADD_IO_SEG(0x0001180014000020ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_RXF_MEM_PMAP
value|CVMX_ILK_RXF_MEM_PMAP_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXF_MEM_PMAP_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXF_MEM_PMAP not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000028ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXF_MEM_PMAP
value|(CVMX_ADD_IO_SEG(0x0001180014000028ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_CFG0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_CFG0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_CFG0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020000ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_CFG1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_CFG1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_CFG1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020008ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_FLOW_CTL0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_FLOW_CTL0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020090ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_FLOW_CTL0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020090ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_FLOW_CTL1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_FLOW_CTL1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020098ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_FLOW_CTL1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020098ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_IDX_CAL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_IDX_CAL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800140200A0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_IDX_CAL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800140200A0ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_IDX_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_IDX_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020070ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_IDX_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020070ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_IDX_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_IDX_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020078ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_IDX_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020078ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_INT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_INT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_INT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020010ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_INT_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_INT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_INT_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020018ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_JABBER
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_JABBER(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800140200B8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_JABBER
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800140200B8ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_MEM_CAL0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_MEM_CAL0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800140200A8ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_MEM_CAL0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800140200A8ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_MEM_CAL1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_MEM_CAL1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800140200B0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_MEM_CAL1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800140200B0ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_MEM_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_MEM_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_MEM_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020080ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_MEM_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_MEM_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020088ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_MEM_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020088ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_RID
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_RID(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x00011800140200C0ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_RID
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x00011800140200C0ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020020ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020028ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020030ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020038ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT4(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT4
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020040ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT5(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT5
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020048ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT6
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT6(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT6
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020050ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT7
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT7(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020058ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT7
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020058ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT8
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT8(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT8
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020060ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RXX_STAT9
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RXX_STAT9(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014020068ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RXX_STAT9
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014020068ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_CFG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_CFG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_CFG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038000ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_INT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_INT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_INT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038008ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_INT_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_INT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_INT_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038010ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038018ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038020ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT2
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT2(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT2
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038028ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT3
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT3(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT3
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038030ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT4
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT4(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT4
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038038ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT5
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT5(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT5
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038040ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT6
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT6(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT6
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038048ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT7
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT7(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT7
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038050ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT8
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT8(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038058ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT8
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038058ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_RX_LNEX_STAT9
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|7
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_RX_LNEX_STAT9(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014038060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|7
operator|)
operator|*
literal|1024
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_RX_LNEX_STAT9
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014038060ull) + ((offset)& 7) * 1024)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_define
define|#
directive|define
name|CVMX_ILK_SER_CFG
value|CVMX_ILK_SER_CFG_FUNC()
end_define

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_SER_CFG_FUNC
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_SER_CFG not supported on this chip\n"
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014000018ull
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_SER_CFG
value|(CVMX_ADD_IO_SEG(0x0001180014000018ull))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_CFG0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_CFG0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010000ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_CFG0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010000ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_CFG1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_CFG1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010008ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_CFG1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010008ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_DBG
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_DBG(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010070ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_DBG
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010070ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_FLOW_CTL0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_FLOW_CTL0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010048ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_FLOW_CTL0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010048ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_FLOW_CTL1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_FLOW_CTL1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010050ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_FLOW_CTL1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010050ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_IDX_CAL
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_IDX_CAL(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010058ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_IDX_CAL
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010058ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_IDX_PMAP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_IDX_PMAP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010010ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_IDX_PMAP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010010ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_IDX_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_IDX_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010020ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_IDX_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010020ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_IDX_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_IDX_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010028ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_IDX_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010028ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_INT
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_INT(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010078ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_INT
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010078ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_INT_EN
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_INT_EN(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010080ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_INT_EN
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010080ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_MEM_CAL0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_MEM_CAL0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010060ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_MEM_CAL0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010060ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_MEM_CAL1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_MEM_CAL1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010068ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_MEM_CAL1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010068ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_MEM_PMAP
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_MEM_PMAP(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010018ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_MEM_PMAP
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010018ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_MEM_STAT0
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_MEM_STAT0(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010030ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_MEM_STAT0
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010030ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_MEM_STAT1
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_MEM_STAT1(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010038ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_MEM_STAT1
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010038ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_PIPE
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_PIPE(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010088ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_PIPE
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010088ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|CVMX_ENABLE_CSR_ADDRESS_CHECKING
end_if

begin_function
specifier|static
specifier|inline
name|uint64_t
name|CVMX_ILK_TXX_RMATCH
parameter_list|(
name|unsigned
name|long
name|offset
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|&&
operator|(
operator|(
name|offset
operator|<=
literal|1
operator|)
operator|)
operator|)
operator|)
condition|)
name|cvmx_warn
argument_list|(
literal|"CVMX_ILK_TXX_RMATCH(%lu) is invalid on this chip\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
return|return
name|CVMX_ADD_IO_SEG
argument_list|(
literal|0x0001180014010040ull
argument_list|)
operator|+
operator|(
operator|(
name|offset
operator|)
operator|&
literal|1
operator|)
operator|*
literal|16384
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CVMX_ILK_TXX_RMATCH
parameter_list|(
name|offset
parameter_list|)
value|(CVMX_ADD_IO_SEG(0x0001180014010040ull) + ((offset)& 1) * 16384)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_ilk_bist_sum  */
end_comment

begin_union
union|union
name|cvmx_ilk_bist_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_bist_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rxf_x2p1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.x2p_fif_mem1 */
name|uint64_t
name|rxf_x2p0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.x2p_fif_mem0 */
name|uint64_t
name|rxf_pmap
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_map_mem */
name|uint64_t
name|rxf_mem2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem2 */
name|uint64_t
name|rxf_mem1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem1 */
name|uint64_t
name|rxf_mem0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem0 */
name|uint64_t
name|reserved_36_51
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rle7_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle7.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle7_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle7.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle6_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle6.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle6_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle6.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle5_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle5.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle5_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle5.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle4_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle4.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle4_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle4.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle3_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle3.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle3_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle3.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle2_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle2.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle2_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle2.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle1_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle1.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle1_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle1.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle0_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle0.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle0_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle0.dsk.dsk_fif_mem0 */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.csr.stat_mem1    ***NOTE: Added in pass 2.0 */
name|uint64_t
name|rlk1_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.fwc.cal_chan_ram */
name|uint64_t
name|rlk1_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.csr.stat_mem */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.csr.stat_mem1    ***NOTE: Added in pass 2.0 */
name|uint64_t
name|rlk0_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.fwc.cal_chan_ram */
name|uint64_t
name|rlk0_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.csr.stat_mem */
name|uint64_t
name|tlk1_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.csr.stat_mem1 */
name|uint64_t
name|tlk1_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.fwc.cal_chan_ram */
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_map_mem */
name|uint64_t
name|tlk1_txf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_fif_mem1 */
name|uint64_t
name|tlk1_txf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_fif_mem0 */
name|uint64_t
name|tlk0_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.csr.stat_mem1 */
name|uint64_t
name|tlk0_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.fwc.cal_chan_ram */
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_map_mem */
name|uint64_t
name|tlk0_txf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_fif_mem1 */
name|uint64_t
name|tlk0_txf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_fif_mem0 */
else|#
directive|else
name|uint64_t
name|tlk0_txf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_3
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_9
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle0_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle0_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_51
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rxf_mem0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_mem1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_mem2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_pmap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_x2p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_x2p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
struct|struct
name|cvmx_ilk_bist_sum_cn68xx
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rxf_x2p1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.x2p_fif_mem1 */
name|uint64_t
name|rxf_x2p0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.x2p_fif_mem0 */
name|uint64_t
name|rxf_pmap
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_map_mem */
name|uint64_t
name|rxf_mem2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem2 */
name|uint64_t
name|rxf_mem1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem1 */
name|uint64_t
name|rxf_mem0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem0 */
name|uint64_t
name|reserved_36_51
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rle7_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle7.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle7_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle7.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle6_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle6.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle6_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle6.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle5_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle5.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle5_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle5.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle4_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle4.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle4_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle4.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle3_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle3.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle3_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle3.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle2_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle2.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle2_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle2.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle1_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle1.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle1_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle1.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle0_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle0.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle0_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle0.dsk.dsk_fif_mem0 */
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.csr.stat_mem1    ***NOTE: Added in pass 2.0 */
name|uint64_t
name|rlk1_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.fwc.cal_chan_ram */
name|uint64_t
name|rlk1_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.csr.stat_mem0 */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.csr.stat_mem1    ***NOTE: Added in pass 2.0 */
name|uint64_t
name|rlk0_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.fwc.cal_chan_ram */
name|uint64_t
name|rlk0_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.csr.stat_mem0 */
name|uint64_t
name|tlk1_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.csr.stat_mem1 */
name|uint64_t
name|tlk1_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.fwc.cal_chan_ram */
name|uint64_t
name|tlk1_stat0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.csr.stat_mem0 */
name|uint64_t
name|tlk1_txf2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_map_mem */
name|uint64_t
name|tlk1_txf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_fif_mem1 */
name|uint64_t
name|tlk1_txf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_fif_mem0 */
name|uint64_t
name|tlk0_stat1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.csr.stat_mem1 */
name|uint64_t
name|tlk0_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.fwc.cal_chan_ram */
name|uint64_t
name|tlk0_stat0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.csr.stat_mem0 */
name|uint64_t
name|tlk0_txf2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_map_mem */
name|uint64_t
name|tlk0_txf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_fif_mem1 */
name|uint64_t
name|tlk0_txf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_fif_mem0 */
else|#
directive|else
name|uint64_t
name|tlk0_txf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_stat0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_stat0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_stat1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_19_19
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle0_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle0_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_51
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rxf_mem0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_mem1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_mem2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_pmap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_x2p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_x2p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xx
struct|;
struct|struct
name|cvmx_ilk_bist_sum_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
name|uint64_t
name|rxf_x2p1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.x2p_fif_mem1 */
name|uint64_t
name|rxf_x2p0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.x2p_fif_mem0 */
name|uint64_t
name|rxf_pmap
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_map_mem */
name|uint64_t
name|rxf_mem2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem2 */
name|uint64_t
name|rxf_mem1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem1 */
name|uint64_t
name|rxf_mem0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rxf.rx_fif_mem0 */
name|uint64_t
name|reserved_36_51
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rle7_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle7.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle7_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle7.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle6_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle6.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle6_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle6.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle5_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle5.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle5_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle5.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle4_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle4.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle4_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle4.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle3_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle3.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle3_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle3.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle2_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle2.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle2_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle2.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle1_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle1.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle1_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle1.dsk.dsk_fif_mem0 */
name|uint64_t
name|rle0_dsk1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle0.dsk.dsk_fif_mem1 */
name|uint64_t
name|rle0_dsk0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of lne.rle0.dsk.dsk_fif_mem0 */
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rlk1_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.fwc.cal_chan_ram */
name|uint64_t
name|rlk1_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk1.csr.stat_mem */
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rlk0_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.fwc.cal_chan_ram */
name|uint64_t
name|rlk0_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of rlk0.csr.stat_mem */
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.fwc.cal_chan_ram */
name|uint64_t
name|tlk1_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.csr.stat_mem */
name|uint64_t
name|tlk1_txf2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_map_mem */
name|uint64_t
name|tlk1_txf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_fif_mem1 */
name|uint64_t
name|tlk1_txf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk1.txf.tx_fif_mem0 */
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_fwc
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.fwc.cal_chan_ram */
name|uint64_t
name|tlk0_stat
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.csr.stat_mem */
name|uint64_t
name|tlk0_txf2
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_map_mem */
name|uint64_t
name|tlk0_txf1
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_fif_mem1 */
name|uint64_t
name|tlk0_txf0
range|:
literal|1
decl_stmt|;
comment|/**< Bist status of tlk0.txf.tx_fif_mem0 */
else|#
directive|else
name|uint64_t
name|tlk0_txf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_txf2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_5
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_txf2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_11_11
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_14_15
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rlk1_stat
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_fwc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_18_19
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rle0_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle0_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_dsk0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_dsk1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_36_51
range|:
literal|16
decl_stmt|;
name|uint64_t
name|rxf_mem0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_mem1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_mem2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_pmap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_x2p0
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_x2p1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_58_63
range|:
literal|6
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_bist_sum
name|cvmx_ilk_bist_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_gbl_cfg  */
end_comment

begin_union
union|union
name|cvmx_ilk_gbl_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_gbl_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|rid_rstdis
range|:
literal|1
decl_stmt|;
comment|/**< Disable automatic reassembly-id error recovery. For diagnostic                                                          use only.                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
comment|/**< Reset ILK.  For diagnostic use only.                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|cclk_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable ILK conditional clocking.   For diagnostic use only. */
name|uint64_t
name|rxf_xlink
range|:
literal|1
decl_stmt|;
comment|/**< Causes external loopback traffic to switch links.  Enabling                                                          this allow simultaneous use of external and internal loopback. */
else|#
directive|else
name|uint64_t
name|rxf_xlink
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cclk_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reset
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rid_rstdis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_gbl_cfg_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_gbl_cfg_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
name|uint64_t
name|cclk_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable ILK conditional clocking.   For diagnostic use only. */
name|uint64_t
name|rxf_xlink
range|:
literal|1
decl_stmt|;
comment|/**< Causes external loopback traffic to switch links.  Enabling                                                          this allow simultaneous use of external and internal loopback. */
else|#
directive|else
name|uint64_t
name|rxf_xlink
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cclk_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_2_63
range|:
literal|62
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_gbl_cfg
name|cvmx_ilk_gbl_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_gbl_int  */
end_comment

begin_union
union|union
name|cvmx_ilk_gbl_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_gbl_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|rxf_push_full
range|:
literal|1
decl_stmt|;
comment|/**< RXF overflow */
name|uint64_t
name|rxf_pop_empty
range|:
literal|1
decl_stmt|;
comment|/**< RXF underflow */
name|uint64_t
name|rxf_ctl_perr
range|:
literal|1
decl_stmt|;
comment|/**< RXF parity error occurred on sideband control signals.  Data                                                          cycle will be dropped. */
name|uint64_t
name|rxf_lnk1_perr
range|:
literal|1
decl_stmt|;
comment|/**< RXF parity error occurred on RxLink1 packet data                                                          Packet will be marked with error at eop */
name|uint64_t
name|rxf_lnk0_perr
range|:
literal|1
decl_stmt|;
comment|/**< RXF parity error occurred on RxLink0 packet data.  Packet will                                                          be marked with error at eop */
else|#
directive|else
name|uint64_t
name|rxf_lnk0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_lnk1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_ctl_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_pop_empty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_push_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_gbl_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_gbl_int_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_gbl_int
name|cvmx_ilk_gbl_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_gbl_int_en  */
end_comment

begin_union
union|union
name|cvmx_ilk_gbl_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_gbl_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|rxf_push_full
range|:
literal|1
decl_stmt|;
comment|/**< RXF overflow */
name|uint64_t
name|rxf_pop_empty
range|:
literal|1
decl_stmt|;
comment|/**< RXF underflow */
name|uint64_t
name|rxf_ctl_perr
range|:
literal|1
decl_stmt|;
comment|/**< RXF parity error occurred on sideband control signals.  Data                                                          cycle will be dropped. */
name|uint64_t
name|rxf_lnk1_perr
range|:
literal|1
decl_stmt|;
comment|/**< RXF parity error occurred on RxLink1 packet data                                                          Packet will be marked with error at eop */
name|uint64_t
name|rxf_lnk0_perr
range|:
literal|1
decl_stmt|;
comment|/**< RXF parity error occurred on RxLink0 packet data                                                          Packet will be marked with error at eop */
else|#
directive|else
name|uint64_t
name|rxf_lnk0_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_lnk1_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_ctl_perr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_pop_empty
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rxf_push_full
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_gbl_int_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_gbl_int_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_gbl_int_en
name|cvmx_ilk_gbl_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_int_sum  */
end_comment

begin_union
union|union
name|cvmx_ilk_int_sum
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_int_sum_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
name|uint64_t
name|rle7_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane7 interrupt status. See ILK_RX_LNE7_INT */
name|uint64_t
name|rle6_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane6 interrupt status. See ILK_RX_LNE6_INT */
name|uint64_t
name|rle5_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane5 interrupt status. See ILK_RX_LNE5_INT */
name|uint64_t
name|rle4_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane4 interrupt status. See ILK_RX_LNE4_INT */
name|uint64_t
name|rle3_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane3 interrupt status. See ILK_RX_LNE3_INT */
name|uint64_t
name|rle2_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane2 interrupt status. See ILK_RX_LNE2_INT */
name|uint64_t
name|rle1_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane1 interrupt status. See ILK_RX_LNE1_INT */
name|uint64_t
name|rle0_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLane0 interrupt status. See ILK_RX_LNE0_INT */
name|uint64_t
name|rlk1_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLink1 interrupt status. See ILK_RX1_INT */
name|uint64_t
name|rlk0_int
range|:
literal|1
decl_stmt|;
comment|/**< RxLink0 interrupt status. See ILK_RX0_INT */
name|uint64_t
name|tlk1_int
range|:
literal|1
decl_stmt|;
comment|/**< TxLink1 interrupt status. See ILK_TX1_INT */
name|uint64_t
name|tlk0_int
range|:
literal|1
decl_stmt|;
comment|/**< TxLink0 interrupt status. See ILK_TX0_INT */
name|uint64_t
name|gbl_int
range|:
literal|1
decl_stmt|;
comment|/**< Global interrupt status. See ILK_GBL_INT */
else|#
directive|else
name|uint64_t
name|gbl_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tlk1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rlk1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle0_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle1_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle2_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle3_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle4_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle5_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle6_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rle7_int
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_13_63
range|:
literal|51
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_int_sum_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_int_sum_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_int_sum
name|cvmx_ilk_int_sum_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_lne_dbg  */
end_comment

begin_union
union|union
name|cvmx_ilk_lne_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_lne_dbg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
name|uint64_t
name|tx_bad_crc32
range|:
literal|1
decl_stmt|;
comment|/**< Send 1 diagnostic word with bad CRC32 to the selected lane.                                                          Note: injects just once */
name|uint64_t
name|tx_bad_6467_cnt
range|:
literal|5
decl_stmt|;
comment|/**< Send N bad 64B/67B codewords on selected lane */
name|uint64_t
name|tx_bad_sync_cnt
range|:
literal|3
decl_stmt|;
comment|/**< Send N bad sync words on selected lane */
name|uint64_t
name|tx_bad_scram_cnt
range|:
literal|3
decl_stmt|;
comment|/**< Send N bad scram state on selected lane */
name|uint64_t
name|reserved_40_47
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_bad_lane_sel
range|:
literal|8
decl_stmt|;
comment|/**< Select lane to apply error injection counts */
name|uint64_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_dis_dispr
range|:
literal|8
decl_stmt|;
comment|/**< Per-lane disparity disable */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_dis_scram
range|:
literal|8
decl_stmt|;
comment|/**< Per-lane scrambler disable */
else|#
directive|else
name|uint64_t
name|tx_dis_scram
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_dis_dispr
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_bad_lane_sel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_40_47
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_bad_scram_cnt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tx_bad_sync_cnt
range|:
literal|3
decl_stmt|;
name|uint64_t
name|tx_bad_6467_cnt
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tx_bad_crc32
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_60_63
range|:
literal|4
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_lne_dbg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_lne_dbg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_lne_dbg
name|cvmx_ilk_lne_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_lne_sts_msg  */
end_comment

begin_union
union|union
name|cvmx_ilk_lne_sts_msg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_lne_sts_msg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rx_lnk_stat
range|:
literal|8
decl_stmt|;
comment|/**< Link status received in the diagnostic word (per-lane) */
name|uint64_t
name|reserved_40_47
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rx_lne_stat
range|:
literal|8
decl_stmt|;
comment|/**< Lane status received in the diagnostic word (per-lane) */
name|uint64_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_lnk_stat
range|:
literal|8
decl_stmt|;
comment|/**< Link status transmitted in the diagnostic word (per-lane) */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_lne_stat
range|:
literal|8
decl_stmt|;
comment|/**< Lane status transmitted in the diagnostic word (per-lane) */
else|#
directive|else
name|uint64_t
name|tx_lne_stat
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|tx_lnk_stat
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_31
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rx_lne_stat
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_40_47
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rx_lnk_stat
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_56_63
range|:
literal|8
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_lne_sts_msg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_lne_sts_msg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_lne_sts_msg
name|cvmx_ilk_lne_sts_msg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_cfg0  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_cfg0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_cfg0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|ext_lpbk_fc
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx-Tx flowcontrol loopback (external) */
name|uint64_t
name|ext_lpbk
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx-Tx data loopback (external). Note that with differing                                                          transmit& receive clocks, skip word are  inserted/deleted */
name|uint64_t
name|reserved_60_61
range|:
literal|2
decl_stmt|;
name|uint64_t
name|lnk_stats_wrap
range|:
literal|1
decl_stmt|;
comment|/**< Upon overflow, a statistics counter should wrap instead of                                                          saturating.                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|bcw_push
range|:
literal|1
decl_stmt|;
comment|/**< The 8 byte burst control word containing the SOP will be                                                          prepended to the corresponding packet.                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|mproto_ign
range|:
literal|1
decl_stmt|;
comment|/**< When LA_MODE=1 and MPROTO_IGN=0, the multi-protocol bit of the                                                          LA control word is used to determine if the burst is an LA or                                                          non-LA burst.   When LA_MODE=1 and MPROTO_IGN=1, all bursts                                                          are treated LA.   When LA_MODE=0, this field is ignored                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|ptrn_mode
range|:
literal|1
decl_stmt|;
comment|/**< Enable programmable test pattern mode */
name|uint64_t
name|lnk_stats_rdclr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_RXx_STAT* clears the counter after returning                                                          its current value. */
name|uint64_t
name|lnk_stats_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable link statistics counters */
name|uint64_t
name|mltuse_fc_ena
range|:
literal|1
decl_stmt|;
comment|/**< Use multi-use field for calendar */
name|uint64_t
name|cal_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx calendar.  When the calendar table is disabled, all                                                          port-pipes receive XON. */
name|uint64_t
name|mfrm_len
range|:
literal|13
decl_stmt|;
comment|/**< The quantity of data sent on each lane including one sync word,                                                          scrambler state, diag word, zero or more skip words, and the                                                          data  payload.  Must be large than ILK_RXX_CFG1[SKIP_CNT]+9.                                                          Supported range:ILK_RXX_CFG1[SKIP_CNT]+9< MFRM_LEN<= 4096) */
name|uint64_t
name|brst_shrt
range|:
literal|7
decl_stmt|;
comment|/**< Minimum interval between burst control words, as a multiple of                                                          8 bytes.  Supported range from 8 bytes to 512 (ie. 0<                                                          BRST_SHRT<= 64)                                                          This field affects the ILK_RX*_STAT4[BRST_SHRT_ERR_CNT]                                                          counter. It does not affect correct operation of the link. */
name|uint64_t
name|lane_rev
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal.   When enabled, lane de-striping is performed                                                          from most significant lane enabled to least significant lane                                                          enabled.  LANE_ENA must be zero before changing LANE_REV. */
name|uint64_t
name|brst_max
range|:
literal|5
decl_stmt|;
comment|/**< Maximum size of a data burst, as a multiple of 64 byte blocks.                                                          Supported range is from 64 bytes to  1024 bytes. (ie. 0<                                                          BRST_MAX<= 16)                                                          This field affects the ILK_RX*_STAT2[BRST_NOT_FULL_CNT] and                                                          ILK_RX*_STAT3[BRST_MAX_ERR_CNT] counters. It does not affect                                                          correct operation of the link. */
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cal_depth
range|:
literal|9
decl_stmt|;
comment|/**< Number of valid entries in the calendar.   Supported range from                                                          1 to 288. */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|lane_ena
range|:
literal|8
decl_stmt|;
comment|/**< Lane enable mask.  Link is enabled if any lane is enabled.  The                                                          same lane should not be enabled in multiple ILK_RXx_CFG0.  Each                                                          bit of LANE_ENA maps to a RX lane (RLE) and a QLM lane.  NOTE:                                                          LANE_REV has no effect on this mapping.                                                                 LANE_ENA[0] = RLE0 = QLM1 lane 0                                                                LANE_ENA[1] = RLE1 = QLM1 lane 1                                                                LANE_ENA[2] = RLE2 = QLM1 lane 2                                                                LANE_ENA[3] = RLE3 = QLM1 lane 3                                                                LANE_ENA[4] = RLE4 = QLM2 lane 0                                                                LANE_ENA[5] = RLE5 = QLM2 lane 1                                                                LANE_ENA[6] = RLE6 = QLM2 lane 2                                                                LANE_ENA[7] = RLE7 = QLM2 lane 3 */
else|#
directive|else
name|uint64_t
name|lane_ena
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cal_depth
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brst_max
range|:
literal|5
decl_stmt|;
name|uint64_t
name|lane_rev
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brst_shrt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|mfrm_len
range|:
literal|13
decl_stmt|;
name|uint64_t
name|cal_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mltuse_fc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptrn_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mproto_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bcw_push
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_wrap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_60_61
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ext_lpbk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_lpbk_fc
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_cfg0_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_cfg0_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|ext_lpbk_fc
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx-Tx flowcontrol loopback (external) */
name|uint64_t
name|ext_lpbk
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx-Tx data loopback (external). Note that with differing                                                          transmit& receive clocks, skip word are  inserted/deleted */
name|uint64_t
name|reserved_57_61
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ptrn_mode
range|:
literal|1
decl_stmt|;
comment|/**< Enable programmable test pattern mode */
name|uint64_t
name|lnk_stats_rdclr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_RXx_STAT* clears the counter after returning                                                          its current value. */
name|uint64_t
name|lnk_stats_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable link statistics counters */
name|uint64_t
name|mltuse_fc_ena
range|:
literal|1
decl_stmt|;
comment|/**< Use multi-use field for calendar */
name|uint64_t
name|cal_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx calendar.  When the calendar table is disabled, all                                                          port-pipes receive XON. */
name|uint64_t
name|mfrm_len
range|:
literal|13
decl_stmt|;
comment|/**< The quantity of data sent on each lane including one sync word,                                                          scrambler state, diag word, zero or more skip words, and the                                                          data  payload.  Must be large than ILK_RXX_CFG1[SKIP_CNT]+9.                                                          Supported range:ILK_RXX_CFG1[SKIP_CNT]+9< MFRM_LEN<= 4096) */
name|uint64_t
name|brst_shrt
range|:
literal|7
decl_stmt|;
comment|/**< Minimum interval between burst control words, as a multiple of                                                          8 bytes.  Supported range from 8 bytes to 512 (ie. 0<                                                          BRST_SHRT<= 64)                                                          This field affects the ILK_RX*_STAT4[BRST_SHRT_ERR_CNT]                                                          counter. It does not affect correct operation of the link. */
name|uint64_t
name|lane_rev
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal.   When enabled, lane de-striping is performed                                                          from most significant lane enabled to least significant lane                                                          enabled.  LANE_ENA must be zero before changing LANE_REV. */
name|uint64_t
name|brst_max
range|:
literal|5
decl_stmt|;
comment|/**< Maximum size of a data burst, as a multiple of 64 byte blocks.                                                          Supported range is from 64 bytes to  1024 bytes. (ie. 0<                                                          BRST_MAX<= 16)                                                          This field affects the ILK_RX*_STAT2[BRST_NOT_FULL_CNT] and                                                          ILK_RX*_STAT3[BRST_MAX_ERR_CNT] counters. It does not affect                                                          correct operation of the link. */
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cal_depth
range|:
literal|9
decl_stmt|;
comment|/**< Number of valid entries in the calendar.   Supported range from                                                          1 to 288. */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|lane_ena
range|:
literal|8
decl_stmt|;
comment|/**< Lane enable mask.  Link is enabled if any lane is enabled.  The                                                          same lane should not be enabled in multiple ILK_RXx_CFG0.  Each                                                          bit of LANE_ENA maps to a RX lane (RLE) and a QLM lane.  NOTE:                                                          LANE_REV has no effect on this mapping.                                                                 LANE_ENA[0] = RLE0 = QLM1 lane 0                                                                LANE_ENA[1] = RLE1 = QLM1 lane 1                                                                LANE_ENA[2] = RLE2 = QLM1 lane 2                                                                LANE_ENA[3] = RLE3 = QLM1 lane 3                                                                LANE_ENA[4] = RLE4 = QLM2 lane 0                                                                LANE_ENA[5] = RLE5 = QLM2 lane 1                                                                LANE_ENA[6] = RLE6 = QLM2 lane 2                                                                LANE_ENA[7] = RLE7 = QLM2 lane 3 */
else|#
directive|else
name|uint64_t
name|lane_ena
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cal_depth
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brst_max
range|:
literal|5
decl_stmt|;
name|uint64_t
name|lane_rev
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brst_shrt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|mfrm_len
range|:
literal|13
decl_stmt|;
name|uint64_t
name|cal_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mltuse_fc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptrn_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_57_61
range|:
literal|5
decl_stmt|;
name|uint64_t
name|ext_lpbk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_lpbk_fc
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_cfg0
name|cvmx_ilk_rxx_cfg0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_cfg1  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_cfg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_cfg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_fifo_cnt
range|:
literal|12
decl_stmt|;
comment|/**< Number of 64-bit words currently consumed by this link in the                                                          RX fifo. */
name|uint64_t
name|reserved_48_49
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_fifo_hwm
range|:
literal|12
decl_stmt|;
comment|/**< Number of 64-bit words consumed by this link before switch                                                          transmitted link flow control status from XON to XOFF.                                                           XON  = RX_FIFO_CNT< RX_FIFO_HWM                                                          XOFF = RX_FIFO_CNT>= RX_FIFO_HWM. */
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_fifo_max
range|:
literal|12
decl_stmt|;
comment|/**< Maximum number of 64-bit words consumed by this link in the RX                                                          fifo.  The sum of all links should be equal to 2048 (16KB) */
name|uint64_t
name|pkt_flush
range|:
literal|1
decl_stmt|;
comment|/**< Packet receive flush.  Writing PKT_FLUSH=1 will cause all open                                                          packets to be error-out, just as though the link went down. */
name|uint64_t
name|pkt_ena
range|:
literal|1
decl_stmt|;
comment|/**< Packet receive enable.  When PKT_ENA=0, any received SOP causes                                                          the entire packet to be dropped. */
name|uint64_t
name|la_mode
range|:
literal|1
decl_stmt|;
comment|/**< 0 = Interlaken                                                          1 = Interlaken Look-Aside */
name|uint64_t
name|tx_link_fc
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control status transmitted by the Tx-Link                                                          XON when RX_FIFO_CNT<= RX_FIFO_HWM and lane alignment is done */
name|uint64_t
name|rx_link_fc
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control status received in burst/idle control words.                                                          XOFF will cause Tx-Link to stop transmitting on all channels. */
name|uint64_t
name|rx_align_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable the lane alignment.  This should only be done after all                                                          enabled lanes have achieved word boundary lock and scrambler                                                          synchronization.  Note: Hardware will clear this when any                                                          participating lane loses either word boundary lock or scrambler                                                          synchronization */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rx_bdry_lock_ena
range|:
literal|8
decl_stmt|;
comment|/**< Enable word boundary lock.  While disabled, received data is                                                          tossed.  Once enabled,  received data is searched for legal                                                          2bit patterns.  Automatically cleared for disabled lanes. */
else|#
directive|else
name|uint64_t
name|rx_bdry_lock_ena
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rx_align_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_link_fc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_link_fc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|la_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_flush
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_fifo_max
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_34_35
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_fifo_hwm
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_48_49
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_fifo_cnt
range|:
literal|12
decl_stmt|;
name|uint64_t
name|reserved_62_63
range|:
literal|2
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_cfg1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_cfg1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_cfg1
name|cvmx_ilk_rxx_cfg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_flow_ctl0  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_flow_ctl0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_flow_ctl0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|status
range|:
literal|64
decl_stmt|;
comment|/**< Flow control status for port-pipes 63-0, where a 1 indicates                                                          the presence of backpressure (ie. XOFF) and 0 indicates the                                                          absence of backpressure (ie. XON) */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_flow_ctl0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_flow_ctl0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_flow_ctl0
name|cvmx_ilk_rxx_flow_ctl0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_flow_ctl1  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_flow_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_flow_ctl1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|status
range|:
literal|64
decl_stmt|;
comment|/**< Flow control status for port-pipes 127-64, where a 1 indicates                                                          the presence of backpressure (ie. XOFF) and 0 indicates the                                                          absence of backpressure (ie. XON) */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_flow_ctl1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_flow_ctl1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_flow_ctl1
name|cvmx_ilk_rxx_flow_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_idx_cal  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_idx_cal
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_idx_cal_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|6
decl_stmt|;
comment|/**< Increment to add to current index for next index. NOTE:                                                          Increment performed after access to   ILK_RXx_MEM_CAL1 */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|index
range|:
literal|6
decl_stmt|;
comment|/**< Specify the group of 8 entries accessed by the next CSR                                                          read/write to calendar table memory.  Software must never write                                                          IDX>= 36 */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_idx_cal_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_idx_cal_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_idx_cal
name|cvmx_ilk_rxx_idx_cal_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_idx_stat0  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_idx_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_idx_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_RXx_MEM_STAT0 clears the selected counter after                                                          returning its current value. */
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Specify the channel accessed during the next CSR read to the                                                          ILK_RXx_MEM_STAT0 */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_idx_stat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_idx_stat0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_idx_stat0
name|cvmx_ilk_rxx_idx_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_idx_stat1  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_idx_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_idx_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_RXx_MEM_STAT1 clears the selected counter after                                                          returning its current value. */
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Specify the channel accessed during the next CSR read to the                                                          ILK_RXx_MEM_STAT1 */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_idx_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_idx_stat1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_idx_stat1
name|cvmx_ilk_rxx_idx_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_int  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|pkt_drop_sop
range|:
literal|1
decl_stmt|;
comment|/**< Entire packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX,                                                          lack of reassembly-ids or because ILK_RXX_CFG1[PKT_ENA]=0      | $RW                                                          because ILK_RXX_CFG1[PKT_ENA]=0                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
comment|/**< Entire packet dropped due to the lack of reassembly-ids or                                                          because ILK_RXX_CFG1[PKT_ENA]=0 */
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
comment|/**< Some/all of a packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX */
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
comment|/**< A lane encountered either a bad 64B/67B codeword or an unknown                                                          control word type. */
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Statistics counter overflow */
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
comment|/**< Lane alignment successful */
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
comment|/**< All enabled lanes have achieved word boundary lock and                                                          scrambler synchronization.  Lane alignment may now be enabled. */
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
comment|/**< Burst CRC24 error.  All open packets will be receive an error. */
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
comment|/**< Lane Alignment fails (4 tries).  Hardware will repeat lane                                                          alignment until is succeeds or until ILK_RXx_CFG1[RX_ALIGN_ENA]                                                          is cleared. */
else|#
directive|else
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_int_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_int_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
comment|/**< Entire packet dropped due to the lack of reassembly-ids or                                                          because ILK_RXX_CFG1[PKT_ENA]=0 */
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
comment|/**< Some/all of a packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX */
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
comment|/**< A lane encountered either a bad 64B/67B codeword or an unknown                                                          control word type. */
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Statistics counter overflow */
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
comment|/**< Lane alignment successful */
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
comment|/**< All enabled lanes have achieved word boundary lock and                                                          scrambler synchronization.  Lane alignment may now be enabled. */
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
comment|/**< Burst CRC24 error.  All open packets will be receive an error. */
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
comment|/**< Lane Alignment fails (4 tries).  Hardware will repeat lane                                                          alignment until is succeeds or until ILK_RXx_CFG1[RX_ALIGN_ENA]                                                          is cleared. */
else|#
directive|else
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_int
name|cvmx_ilk_rxx_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_int_en  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|pkt_drop_sop
range|:
literal|1
decl_stmt|;
comment|/**< Entire packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX,                                                          lack of reassembly-ids or because ILK_RXX_CFG1[PKT_ENA]=0      | $PRW                                                          because ILK_RXX_CFG1[PKT_ENA]=0                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
comment|/**< Entire packet dropped due to the lack of reassembly-ids or                                                          because ILK_RXX_CFG1[PKT_ENA]=0 */
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
comment|/**< Some/all of a packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX */
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
comment|/**< A lane encountered either a bad 64B/67B codeword or an unknown                                                          control word type. */
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Statistics counter overflow */
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
comment|/**< Lane alignment successful */
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
comment|/**< All enabled lanes have achieved word boundary lock and                                                          scrambler synchronization.  Lane alignment may now be enabled. */
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
comment|/**< Burst CRC24 error.  All open packets will be receive an error. */
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
comment|/**< Lane Alignment fails (4 tries) */
else|#
directive|else
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_sop
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_int_en_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_int_en_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
comment|/**< Entire packet dropped due to the lack of reassembly-ids or                                                          because ILK_RXX_CFG1[PKT_ENA]=0 */
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
comment|/**< Some/all of a packet dropped due to RX_FIFO_CNT == RX_FIFO_MAX */
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
comment|/**< A lane encountered either a bad 64B/67B codeword or an unknown                                                          control word type. */
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Statistics counter overflow */
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
comment|/**< Lane alignment successful */
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
comment|/**< All enabled lanes have achieved word boundary lock and                                                          scrambler synchronization.  Lane alignment may now be enabled. */
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
comment|/**< Burst CRC24 error.  All open packets will be receive an error. */
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
comment|/**< Lane Alignment fails (4 tries) */
else|#
directive|else
name|uint64_t
name|lane_align_fail
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc24_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|word_sync_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_align_done
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lane_bad_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rxf
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_drop_rid
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_int_en
name|cvmx_ilk_rxx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_jabber  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_jabber
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_jabber_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
comment|/**< Byte count for jabber check.   Failing packets will be                                                          truncated to CNT bytes.                                                           NOTE: Hardware tracks the size of up to two concurrent packet                                                          per link.  If using segment mode with more than 2 channels,                                                          some large packets may not be flagged or truncated.                                                           NOTE: CNT must be 8-byte aligned such that CNT[2:0] == 0 */
else|#
directive|else
name|uint64_t
name|cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_jabber_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_jabber_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_jabber
name|cvmx_ilk_rxx_jabber_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_mem_cal0  *  * Notes:  * Software must program the calendar table prior to enabling the  * link.  *  * Software must always write ILK_RXx_MEM_CAL0 then ILK_RXx_MEM_CAL1.  * Software must never write them in reverse order or write one without  * writing the other.  *  * A given calendar table entry has no effect on PKO pipe  * backpressure when either:  *  - ENTRY_CTLx=Link (1), or  *  - ENTRY_CTLx=XON (3) and PORT_PIPEx is outside the range of ILK_TXx_PIPE[BASE/NUMP].  *  * Within the 8 calendar table entries of one IDX value, if more  * than one affects the same PKO pipe, XOFF always wins over XON,  * regardless of the calendar table order.  *  * Software must always read ILK_RXx_MEM_CAL0 then ILK_RXx_MEM_CAL1.  Software  * must never read them in reverse order or read one without reading the  * other.  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_mem_cal0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_mem_cal0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|entry_ctl3
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+3                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE3.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE3 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE3.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE3. The calendar table entry is                                                                             effectively unused if PORT_PIPE3 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe3
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+3                                                           PORT_PIPE3 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL3 is "XOFF" (2) or "PKO port-pipe" (0). */
name|uint64_t
name|entry_ctl2
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+2                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE2.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE2 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE2.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE2. The calendar table entry is                                                                             effectively unused if PORT_PIPE2 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe2
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+2                                                           PORT_PIPE2 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL2 is "XOFF" (2) or "PKO port-pipe" (0). */
name|uint64_t
name|entry_ctl1
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+1                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE1.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE1 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE1.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE1. The calendar table entry is                                                                             effectively unused if PORT_PIPE1 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe1
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+1                                                           PORT_PIPE1 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL1 is "XOFF" (2) or "PKO port-pipe" (0). */
name|uint64_t
name|entry_ctl0
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+0                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE0.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE0 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE0.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE0. The calendar table entry is                                                                             effectively unused if PORT_PIPEx is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe0
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+0                                                           PORT_PIPE0 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL0 is "XOFF" (2) or "PKO port-pipe" (0). */
else|#
directive|else
name|uint64_t
name|port_pipe0
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|port_pipe1
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|port_pipe2
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|port_pipe3
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_mem_cal0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_mem_cal0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_mem_cal0
name|cvmx_ilk_rxx_mem_cal0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_mem_cal1  *  * Notes:  * Software must program the calendar table prior to enabling the  * link.  *  * Software must always write ILK_RXx_MEM_CAL0 then ILK_RXx_MEM_CAL1.  * Software must never write them in reverse order or write one without  * writing the other.  *  * A given calendar table entry has no effect on PKO pipe  * backpressure when either:  *  - ENTRY_CTLx=Link (1), or  *  - ENTRY_CTLx=XON (3) and PORT_PIPEx is outside the range of ILK_TXx_PIPE[BASE/NUMP].  *  * Within the 8 calendar table entries of one IDX value, if more  * than one affects the same PKO pipe, XOFF always wins over XON,  * regardless of the calendar table order.  *  * Software must always read ILK_RXx_MEM_CAL0 then ILK_Rx_MEM_CAL1.  Software  * must never read them in reverse order or read one without reading the  * other.  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_mem_cal1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_mem_cal1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|entry_ctl7
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+7                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE7.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE7 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE7.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE7. The calendar table entry is                                                                             effectively unused if PORT_PIPE3 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe7
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+7                                                           PORT_PIPE7 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL7 is "XOFF" (2) or "PKO port-pipe" (0). */
name|uint64_t
name|entry_ctl6
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+6                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE6.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE6 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE6.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE6. The calendar table entry is                                                                             effectively unused if PORT_PIPE6 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe6
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+6                                                           PORT_PIPE6 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL6 is "XOFF" (2) or "PKO port-pipe" (0). */
name|uint64_t
name|entry_ctl5
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+5                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE5.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE5 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE5.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE5. The calendar table entry is                                                                             effectively unused if PORT_PIPE5 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe5
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+5                                                           PORT_PIPE5 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL5 is "XOFF" (2) or "PKO port-pipe" (0). */
name|uint64_t
name|entry_ctl4
range|:
literal|2
decl_stmt|;
comment|/**< XON/XOFF destination for entry (IDX*8)+4                                                           - 0: PKO port-pipe  Apply backpressure received from the                                                                             remote tranmitter to the PKO pipe selected                                                                             by PORT_PIPE4.                                                           - 1: Link           Apply the backpressure received from the                                                                             remote transmitter to link backpressure.                                                                             PORT_PIPE4 is unused.                                                           - 2: XOFF           Apply XOFF to the PKO pipe selected by                                                                             PORT_PIPE4.                                                           - 3: XON            Apply XON to the PKO pipe selected by                                                                             PORT_PIPE4. The calendar table entry is                                                                             effectively unused if PORT_PIPE4 is out of                                                                             range of ILK_TXx_PIPE[BASE/NUMP]. */
name|uint64_t
name|port_pipe4
range|:
literal|7
decl_stmt|;
comment|/**< Select PKO port-pipe for calendar table entry (IDX*8)+4                                                           PORT_PIPE4 must reside in the range of ILK_TXx_PIPE[BASE/NUMP]                                                          when ENTRY_CTL4 is "XOFF" (2) or "PKO port-pipe" (0). */
else|#
directive|else
name|uint64_t
name|port_pipe4
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl4
range|:
literal|2
decl_stmt|;
name|uint64_t
name|port_pipe5
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|port_pipe6
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|port_pipe7
range|:
literal|7
decl_stmt|;
name|uint64_t
name|entry_ctl7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_mem_cal1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_mem_cal1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_mem_cal1
name|cvmx_ilk_rxx_mem_cal1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_mem_stat0  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_mem_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_mem_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|rx_pkt
range|:
literal|28
decl_stmt|;
comment|/**< Number of packets received (256M)                                                          Channel selected by ILK_RXx_IDX_STAT0[IDX].  Saturates.                                                          Interrupt on saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|rx_pkt
range|:
literal|28
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_mem_stat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_mem_stat0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_mem_stat0
name|cvmx_ilk_rxx_mem_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_mem_stat1  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_mem_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_mem_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|rx_bytes
range|:
literal|36
decl_stmt|;
comment|/**< Number of bytes received (64GB)                                                          Channel selected by ILK_RXx_IDX_STAT1[IDX].    Saturates.                                                          Interrupt on saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|rx_bytes
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_mem_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_mem_stat1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_mem_stat1
name|cvmx_ilk_rxx_mem_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_rid  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_rid
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_rid_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|max_cnt
range|:
literal|6
decl_stmt|;
comment|/**< Maximum number of reassembly-ids allowed for a given link.  If                                                          an SOP arrives and the link has already allocated at least                                                          MAX_CNT reassembly-ids, the packet will be dropped.                                                           Note: An an SOP allocates a reassembly-ids.                                                          Note: An an EOP frees a reassembly-ids.                                                           ***NOTE: Added in pass 2.0 */
else|#
directive|else
name|uint64_t
name|max_cnt
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_rid_s
name|cn68xx
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_rid
name|cvmx_ilk_rxx_rid_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat0  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|crc24_match_cnt
range|:
literal|33
decl_stmt|;
comment|/**< Number of CRC24 matches received.  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|crc24_match_cnt
range|:
literal|33
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat0_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat0_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
name|uint64_t
name|crc24_match_cnt
range|:
literal|27
decl_stmt|;
comment|/**< Number of CRC24 matches received.  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|crc24_match_cnt
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_27_63
range|:
literal|37
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat0
name|cvmx_ilk_rxx_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat1  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|crc24_err_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of bursts with a detected CRC error.  Saturates.                                                          Interrupt on saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|crc24_err_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat1
name|cvmx_ilk_rxx_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat2  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|brst_not_full_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of bursts received which terminated without an eop and                                                          contained fewer than BurstMax words.  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|brst_cnt
range|:
literal|28
decl_stmt|;
comment|/**< Number of bursts correctly received. (ie. good CRC24, not in                                                          violation of BurstMax or BurstShort) */
else|#
directive|else
name|uint64_t
name|brst_cnt
range|:
literal|28
decl_stmt|;
name|uint64_t
name|reserved_28_31
range|:
literal|4
decl_stmt|;
name|uint64_t
name|brst_not_full_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat2_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat2_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
name|uint64_t
name|brst_not_full_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of bursts received which terminated without an eop and                                                          contained fewer than BurstMax words.  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
name|uint64_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint64_t
name|brst_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of bursts correctly received. (ie. good CRC24, not in                                                          violation of BurstMax or BurstShort) */
else|#
directive|else
name|uint64_t
name|brst_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_31
range|:
literal|16
decl_stmt|;
name|uint64_t
name|brst_not_full_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_48_63
range|:
literal|16
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat2
name|cvmx_ilk_rxx_stat2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat3  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|brst_max_err_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of bursts received longer than the BurstMax parameter */
else|#
directive|else
name|uint64_t
name|brst_max_err_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat3_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat3
name|cvmx_ilk_rxx_stat3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat4  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|brst_shrt_err_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of bursts received that violate the BurstShort                                                          parameter.  Saturates.  Interrupt on saturation if                                                          ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|brst_shrt_err_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat4_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat4_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat4
name|cvmx_ilk_rxx_stat4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat5  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat5_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|align_cnt
range|:
literal|23
decl_stmt|;
comment|/**< Number of alignment sequences received  (ie. those that do not                                                          violate the current alignment).  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|align_cnt
range|:
literal|23
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat5_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat5_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|align_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of alignment sequences received  (ie. those that do not                                                          violate the current alignment).  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|align_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat5
name|cvmx_ilk_rxx_stat5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat6  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat6_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|align_err_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of alignment sequences received in error (ie. those that                                                          violate the current alignment).  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|align_err_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat6_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat6_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat6
name|cvmx_ilk_rxx_stat6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat7  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat7_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
name|uint64_t
name|bad_64b67b_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of bad 64B/67B codewords.  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|bad_64b67b_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_16_63
range|:
literal|48
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat7_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat7_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat7
name|cvmx_ilk_rxx_stat7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat8  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat8
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat8_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pkt_drop_rid_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of packets dropped due to the lack of reassembly-ids or                                                          because ILK_RXX_CFG1[PKT_ENA]=0.  Saturates.  Interrupt on                                                          saturation if ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
name|uint64_t
name|pkt_drop_rxf_cnt
range|:
literal|16
decl_stmt|;
comment|/**< Number of packets dropped due to RX_FIFO_CNT>= RX_FIFO_MAX.                                                          Saturates.  Interrupt on saturation if                                                          ILK_RXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|pkt_drop_rxf_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|pkt_drop_rid_cnt
range|:
literal|16
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat8_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat8_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat8
name|cvmx_ilk_rxx_stat8_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx#_stat9  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxx_stat9
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxx_stat9_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxx_stat9_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxx_stat9_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxx_stat9
name|cvmx_ilk_rxx_stat9_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_cfg  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|rx_dis_psh_skip
range|:
literal|1
decl_stmt|;
comment|/**< When RX_DIS_PSH_SKIP=0, skip words are de-stripped.                                                          When RX_DIS_PSH_SKIP=1, skip words are discarded in the lane                                                          logic.                                                           If the lane is in internal loopback mode, RX_DIS_PSH_SKIP                                                          is ignored and skip words are always discarded in the lane                                                          logic.                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_scrm_sync
range|:
literal|1
decl_stmt|;
comment|/**< Rx scrambler synchronization status                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|rx_bdry_sync
range|:
literal|1
decl_stmt|;
comment|/**< Rx word boundary sync status */
name|uint64_t
name|rx_dis_ukwn
range|:
literal|1
decl_stmt|;
comment|/**< Disable normal response to unknown words.  They are still                                                          logged but do not cause an error to all open channels */
name|uint64_t
name|rx_dis_scram
range|:
literal|1
decl_stmt|;
comment|/**< Disable lane scrambler (debug) */
name|uint64_t
name|stat_rdclr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_RX_LNEx_STAT* clears the selected counter after                                                          returning its current value. */
name|uint64_t
name|stat_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable RX lane statistics counters */
else|#
directive|else
name|uint64_t
name|stat_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_dis_scram
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_dis_ukwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_bdry_sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_scrm_sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|rx_dis_psh_skip
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_cfg_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_cfg_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
name|uint64_t
name|rx_bdry_sync
range|:
literal|1
decl_stmt|;
comment|/**< Rx word boundary sync status */
name|uint64_t
name|rx_dis_ukwn
range|:
literal|1
decl_stmt|;
comment|/**< Disable normal response to unknown words.  They are still                                                          logged but do not cause an error to all open channels */
name|uint64_t
name|rx_dis_scram
range|:
literal|1
decl_stmt|;
comment|/**< Disable lane scrambler (debug) */
name|uint64_t
name|stat_rdclr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_RX_LNEx_STAT* clears the selected counter after                                                          returning its current value. */
name|uint64_t
name|stat_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable RX lane statistics counters */
else|#
directive|else
name|uint64_t
name|stat_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_rdclr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_dis_scram
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_dis_ukwn
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_bdry_sync
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_5_63
range|:
literal|59
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_cfg
name|cvmx_ilk_rx_lnex_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_int  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|bad_64b67b
range|:
literal|1
decl_stmt|;
comment|/**< Bad 64B/67B codeword encountered.  Once the bad word reaches                                                          the burst control unit (as deonted by                                                          ILK_RXx_INT[LANE_BAD_WORD]) it will be tossed and all open                                                          packets will receive an error. */
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Rx lane statistic counter overflow */
name|uint64_t
name|stat_msg
range|:
literal|1
decl_stmt|;
comment|/**< Status bits for the link or a lane transitioned from a '1'                                                          (healthy) to a '0' (problem) */
name|uint64_t
name|dskew_fifo_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Rx deskew fifo overflow occurred. */
name|uint64_t
name|scrm_sync_loss
range|:
literal|1
decl_stmt|;
comment|/**< 4 consecutive bad sync words or 3 consecutive scramble state                                                          mismatches */
name|uint64_t
name|ukwn_cntl_word
range|:
literal|1
decl_stmt|;
comment|/**< Unknown framing control word. Block type does not match any of                                                          (SYNC,SCRAM,SKIP,DIAG) */
name|uint64_t
name|crc32_err
range|:
literal|1
decl_stmt|;
comment|/**< Diagnostic CRC32 errors */
name|uint64_t
name|bdry_sync_loss
range|:
literal|1
decl_stmt|;
comment|/**< Rx logic loses word boundary sync (16 tries).  Hardware will                                                          automatically attempt to regain word boundary sync */
name|uint64_t
name|serdes_lock_loss
range|:
literal|1
decl_stmt|;
comment|/**< Rx SERDES loses lock */
else|#
directive|else
name|uint64_t
name|serdes_lock_loss
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bdry_sync_loss
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc32_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ukwn_cntl_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|scrm_sync_loss
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dskew_fifo_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_64b67b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_int_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_int
name|cvmx_ilk_rx_lnex_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_int_en  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
name|uint64_t
name|bad_64b67b
range|:
literal|1
decl_stmt|;
comment|/**< Bad 64B/67B codeword encountered.  Once the bad word reaches                                                          the burst control unit (as deonted by                                                          ILK_RXx_INT[LANE_BAD_WORD]) it will be tossed and all open                                                          packets will receive an error. */
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Rx lane statistic counter overflow */
name|uint64_t
name|stat_msg
range|:
literal|1
decl_stmt|;
comment|/**< Status bits for the link or a lane transitioned from a '1'                                                          (healthy) to a '0' (problem) */
name|uint64_t
name|dskew_fifo_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Rx deskew fifo overflow occurred. */
name|uint64_t
name|scrm_sync_loss
range|:
literal|1
decl_stmt|;
comment|/**< 4 consecutive bad sync words or 3 consecutive scramble state                                                          mismatches */
name|uint64_t
name|ukwn_cntl_word
range|:
literal|1
decl_stmt|;
comment|/**< Unknown framing control word. Block type does not match any of                                                          (SYNC,SCRAM,SKIP,DIAG) */
name|uint64_t
name|crc32_err
range|:
literal|1
decl_stmt|;
comment|/**< Diagnostic CRC32 error */
name|uint64_t
name|bdry_sync_loss
range|:
literal|1
decl_stmt|;
comment|/**< Rx logic loses word boundary sync (16 tries).  Hardware will                                                          automatically attempt to regain word boundary sync */
name|uint64_t
name|serdes_lock_loss
range|:
literal|1
decl_stmt|;
comment|/**< Rx SERDES loses lock */
else|#
directive|else
name|uint64_t
name|serdes_lock_loss
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bdry_sync_loss
range|:
literal|1
decl_stmt|;
name|uint64_t
name|crc32_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ukwn_cntl_word
range|:
literal|1
decl_stmt|;
name|uint64_t
name|scrm_sync_loss
range|:
literal|1
decl_stmt|;
name|uint64_t
name|dskew_fifo_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_msg
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_64b67b
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_9_63
range|:
literal|55
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_int_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_int_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_int_en
name|cvmx_ilk_rx_lnex_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat0  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|ser_lock_loss_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of times the lane lost clock-data-recovery.                                                          Saturates.  Interrupt on saturation if                                                          ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|ser_lock_loss_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat0
name|cvmx_ilk_rx_lnex_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat1  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|bdry_sync_loss_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of times a lane lost word boundary synchronization.                                                          Saturates.  Interrupt on saturation if                                                          ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|bdry_sync_loss_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat1
name|cvmx_ilk_rx_lnex_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat2  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat2
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat2_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|syncw_good_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of good synchronization words.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
name|uint64_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint64_t
name|syncw_bad_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of bad synchronization words.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|syncw_bad_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_31
range|:
literal|14
decl_stmt|;
name|uint64_t
name|syncw_good_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat2_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat2_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat2
name|cvmx_ilk_rx_lnex_stat2_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat3  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat3
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat3_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|bad_64b67b_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of bad 64B/67B words, meaning bit 65 or 64 has been                                                          corrupted.  Saturates.  Interrupt on saturation if                                                          ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|bad_64b67b_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat3_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat3_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat3
name|cvmx_ilk_rx_lnex_stat3_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat4  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat4
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat4_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
name|uint64_t
name|cntl_word_cnt
range|:
literal|27
decl_stmt|;
comment|/**< Number of control words received.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|data_word_cnt
range|:
literal|27
decl_stmt|;
comment|/**< Number of data words received.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|data_word_cnt
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|cntl_word_cnt
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_59_63
range|:
literal|5
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat4_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat4_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat4
name|cvmx_ilk_rx_lnex_stat4_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat5  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat5
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat5_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|unkwn_word_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of unknown control words.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|unkwn_word_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat5_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat5_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat5
name|cvmx_ilk_rx_lnex_stat5_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat6  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat6
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat6_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|scrm_sync_loss_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of times scrambler synchronization was lost (due to                                                          either 4 consecutive bad sync words or 3 consecutive scrambler                                                          state mismatches).  Saturates.  Interrupt on saturation if                                                          ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|scrm_sync_loss_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat6_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat6_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat6
name|cvmx_ilk_rx_lnex_stat6_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat7  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat7
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat7_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|scrm_match_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of scrambler state matches received.  Saturates.                                                          Interrupt on saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|scrm_match_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat7_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat7_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat7
name|cvmx_ilk_rx_lnex_stat7_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat8  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat8
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat8_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
name|uint64_t
name|skipw_good_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of good skip words.  Saturates.  Interrupt on saturation                                                          if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|skipw_good_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_18_63
range|:
literal|46
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat8_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat8_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat8
name|cvmx_ilk_rx_lnex_stat8_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rx_lne#_stat9  */
end_comment

begin_union
union|union
name|cvmx_ilk_rx_lnex_stat9
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rx_lnex_stat9_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|crc32_err_cnt
range|:
literal|18
decl_stmt|;
comment|/**< Number of errors in the lane CRC.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|crc32_match_cnt
range|:
literal|27
decl_stmt|;
comment|/**< Number of CRC32 matches received.  Saturates.  Interrupt on                                                          saturation if ILK_RX_LNEX_INT_EN[STAT_CNT_OVFL]=1 */
else|#
directive|else
name|uint64_t
name|crc32_match_cnt
range|:
literal|27
decl_stmt|;
name|uint64_t
name|reserved_27_31
range|:
literal|5
decl_stmt|;
name|uint64_t
name|crc32_err_cnt
range|:
literal|18
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rx_lnex_stat9_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rx_lnex_stat9_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rx_lnex_stat9
name|cvmx_ilk_rx_lnex_stat9_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rxf_idx_pmap  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxf_idx_pmap
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxf_idx_pmap_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|9
decl_stmt|;
comment|/**< Increment to add to current index for next index. */
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|index
range|:
literal|9
decl_stmt|;
comment|/**< Specify the link/channel accessed by the next CSR read/write to                                                          port map memory.   IDX[8]=link, IDX[7:0]=channel */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_9_15
range|:
literal|7
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_25_63
range|:
literal|39
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxf_idx_pmap_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxf_idx_pmap_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxf_idx_pmap
name|cvmx_ilk_rxf_idx_pmap_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_rxf_mem_pmap  */
end_comment

begin_union
union|union
name|cvmx_ilk_rxf_mem_pmap
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_rxf_mem_pmap_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
name|uint64_t
name|port_kind
range|:
literal|6
decl_stmt|;
comment|/**< Specify the port-kind for the link/channel selected by                                                          ILK_IDX_PMAP[IDX] */
else|#
directive|else
name|uint64_t
name|port_kind
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_63
range|:
literal|58
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_rxf_mem_pmap_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_rxf_mem_pmap_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_rxf_mem_pmap
name|cvmx_ilk_rxf_mem_pmap_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_ser_cfg  */
end_comment

begin_union
union|union
name|cvmx_ilk_ser_cfg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_ser_cfg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
name|uint64_t
name|ser_rxpol_auto
range|:
literal|1
decl_stmt|;
comment|/**< Serdes lane receive polarity auto detection mode */
name|uint64_t
name|reserved_48_55
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ser_rxpol
range|:
literal|8
decl_stmt|;
comment|/**< Serdes lane receive polarity                                                          - 0: rx without inversion                                                          - 1: rx with inversion */
name|uint64_t
name|reserved_32_39
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ser_txpol
range|:
literal|8
decl_stmt|;
comment|/**< Serdes lane transmit polarity                                                          - 0: tx without inversion                                                          - 1: tx with inversion */
name|uint64_t
name|reserved_16_23
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ser_reset_n
range|:
literal|8
decl_stmt|;
comment|/**< Serdes lane reset */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ser_pwrup
range|:
literal|2
decl_stmt|;
comment|/**< Serdes modules (QLM) power up. */
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ser_haul
range|:
literal|2
decl_stmt|;
comment|/**< Serdes module (QLM) haul mode */
else|#
directive|else
name|uint64_t
name|ser_haul
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_2_3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ser_pwrup
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|ser_reset_n
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_16_23
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ser_txpol
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_32_39
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ser_rxpol
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_48_55
range|:
literal|8
decl_stmt|;
name|uint64_t
name|ser_rxpol_auto
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_57_63
range|:
literal|7
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_ser_cfg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_ser_cfg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_ser_cfg
name|cvmx_ilk_ser_cfg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_cfg0  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_cfg0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_cfg0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|ext_lpbk_fc
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx-Tx flowcontrol loopback (external) */
name|uint64_t
name|ext_lpbk
range|:
literal|1
decl_stmt|;
comment|/**< Enable Rx-Tx data loopback (external). Note that with differing                                                          transmit& receive clocks, skip word are  inserted/deleted */
name|uint64_t
name|int_lpbk
range|:
literal|1
decl_stmt|;
comment|/**< Enable Tx-Rx loopback (internal) */
name|uint64_t
name|reserved_57_60
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptrn_mode
range|:
literal|1
decl_stmt|;
comment|/**< Enable programmable test pattern mode.  This mode allows                                                          software to send a packet containing a programmable pattern.                                                          While in this mode, the scramblers and disparity inversion will                                                          be disabled.  In addition, no framing layer control words will                                                          be transmitted (ie. no SYNC, scrambler state, skip, or                                                          diagnostic words will be transmitted).                                                           NOTE: Software must first write ILK_TXX_CFG0[LANE_ENA]=0 before                                                          enabling/disabling this mode. */
name|uint64_t
name|reserved_55_55
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable link statistics counters */
name|uint64_t
name|mltuse_fc_ena
range|:
literal|1
decl_stmt|;
comment|/**< When set, the multi-use field of control words will contain                                                          flow control status.  Otherwise, the multi-use field will                                                          contain ILK_TXX_CFG1[TX_MLTUSE] */
name|uint64_t
name|cal_ena
range|:
literal|1
decl_stmt|;
comment|/**< Enable Tx calendar, else default calendar used:                                                               First control word:                                                                Entry 0  = link                                                                Entry 1  = backpressue id 0                                                                Entry 2  = backpressue id 1                                                                ...etc.                                                             Second control word:                                                                Entry 15 = link                                                                Entry 16 = backpressue id 15                                                                Entry 17 = backpressue id 16                                                                ...etc.                                                          This continues until the status for all 64 backpressue ids gets                                                          transmitted (ie. 0-68 calendar table entries).  The remaining 3                                                          calendar table entries (ie. 69-71) will always transmit XOFF.                                                           To disable backpressure completely, enable the calendar table                                                          and program each calendar table entry to transmit XON */
name|uint64_t
name|mfrm_len
range|:
literal|13
decl_stmt|;
comment|/**< The quantity of data sent on each lane including one sync word,                                                          scrambler state, diag word, zero or more skip words, and the                                                          data  payload.  Must be large than ILK_TXX_CFG1[SKIP_CNT]+9.                                                          Supported range:ILK_TXX_CFG1[SKIP_CNT]+9< MFRM_LEN<= 4096) */
name|uint64_t
name|brst_shrt
range|:
literal|7
decl_stmt|;
comment|/**< Minimum interval between burst control words, as a multiple of                                                          8 bytes.  Supported range from 8 bytes to 512 (ie. 0<                                                          BRST_SHRT<= 64) */
name|uint64_t
name|lane_rev
range|:
literal|1
decl_stmt|;
comment|/**< Lane reversal.   When enabled, lane striping is performed from                                                          most significant lane enabled to least significant lane                                                          enabled.  LANE_ENA must be zero before changing LANE_REV. */
name|uint64_t
name|brst_max
range|:
literal|5
decl_stmt|;
comment|/**< Maximum size of a data burst, as a multiple of 64 byte blocks.                                                          Supported range is from 64 bytes to 1024 bytes. (ie. 0<                                                          BRST_MAX<= 16) */
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|cal_depth
range|:
literal|9
decl_stmt|;
comment|/**< Number of valid entries in the calendar.  CAL_DEPTH[2:0] must                                                          be zero.  Supported range from 8 to 288.  If CAL_ENA is 0,                                                          this field has no effect and the calendar depth is 72 entries. */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|lane_ena
range|:
literal|8
decl_stmt|;
comment|/**< Lane enable mask.  Link is enabled if any lane is enabled.  The                                                          same lane should not be enabled in multiple ILK_TXx_CFG0.  Each                                                          bit of LANE_ENA maps to a TX lane (TLE) and a QLM lane.  NOTE:                                                          LANE_REV has no effect on this mapping.                                                                 LANE_ENA[0] = TLE0 = QLM1 lane 0                                                                LANE_ENA[1] = TLE1 = QLM1 lane 1                                                                LANE_ENA[2] = TLE2 = QLM1 lane 2                                                                LANE_ENA[3] = TLE3 = QLM1 lane 3                                                                LANE_ENA[4] = TLE4 = QLM2 lane 0                                                                LANE_ENA[5] = TLE5 = QLM2 lane 1                                                                LANE_ENA[6] = TLE6 = QLM2 lane 2                                                                LANE_ENA[7] = TLE7 = QLM2 lane 3 */
else|#
directive|else
name|uint64_t
name|lane_ena
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|cal_depth
range|:
literal|9
decl_stmt|;
name|uint64_t
name|reserved_25_25
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brst_max
range|:
literal|5
decl_stmt|;
name|uint64_t
name|lane_rev
range|:
literal|1
decl_stmt|;
name|uint64_t
name|brst_shrt
range|:
literal|7
decl_stmt|;
name|uint64_t
name|mfrm_len
range|:
literal|13
decl_stmt|;
name|uint64_t
name|cal_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|mltuse_fc_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|lnk_stats_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_55_55
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ptrn_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_57_60
range|:
literal|4
decl_stmt|;
name|uint64_t
name|int_lpbk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_lpbk
range|:
literal|1
decl_stmt|;
name|uint64_t
name|ext_lpbk_fc
range|:
literal|1
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_cfg0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_cfg0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_cfg0
name|cvmx_ilk_txx_cfg0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_cfg1  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_cfg1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_cfg1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
name|uint64_t
name|pkt_busy
range|:
literal|1
decl_stmt|;
comment|/**< Tx-Link is transmitting data. */
name|uint64_t
name|pipe_crd_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable pipe credits.   Should be set when PKO is configure to                                                          ignore pipe credits. */
name|uint64_t
name|ptp_delay
range|:
literal|5
decl_stmt|;
comment|/**< Timestamp commit delay.  Must not be zero. */
name|uint64_t
name|skip_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of skip words to insert after the scrambler state */
name|uint64_t
name|pkt_flush
range|:
literal|1
decl_stmt|;
comment|/**< Packet transmit flush.  While PKT_FLUSH=1, the TxFifo will                                                          continuously drain; all data will be dropped.  Software should                                                          first write PKT_ENA=0 and wait packet transmission to stop. */
name|uint64_t
name|pkt_ena
range|:
literal|1
decl_stmt|;
comment|/**< Packet transmit enable.  When PKT_ENA=0, the Tx-Link will stop                                                          transmitting packets, as per RX_LINK_FC_PKT */
name|uint64_t
name|la_mode
range|:
literal|1
decl_stmt|;
comment|/**< 0 = Interlaken                                                          1 = Interlaken Look-Aside */
name|uint64_t
name|tx_link_fc
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control status transmitted by the Tx-Link                                                          XON when RX_FIFO_CNT<= RX_FIFO_HWM and lane alignment is done */
name|uint64_t
name|rx_link_fc
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control status received in burst/idle control words.                                                          When RX_LINK_FC_IGN=0, XOFF will cause Tx-Link to stop                                                          transmitting on all channels. */
name|uint64_t
name|reserved_12_16
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tx_link_fc_jam
range|:
literal|1
decl_stmt|;
comment|/**< All flow control transmitted in burst/idle control words will                                                          be XOFF whenever TX_LINK_FC is XOFF.   Enable this to allow                                                          link XOFF to automatically XOFF all channels. */
name|uint64_t
name|rx_link_fc_pkt
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control received in burst/idle control words causes                                                          Tx-Link to stop transmitting at the end of a packet instead of                                                          the end of a burst */
name|uint64_t
name|rx_link_fc_ign
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the link flow control status received in burst/idle                                                          control words */
name|uint64_t
name|rmatch
range|:
literal|1
decl_stmt|;
comment|/**< Enable rate matching circuitry */
name|uint64_t
name|tx_mltuse
range|:
literal|8
decl_stmt|;
comment|/**< Multiple Use bits used when ILKx_TX_CFG[LA_MODE=0] and                                                          ILKx_TX_CFG[MLTUSE_FC_ENA] is zero */
else|#
directive|else
name|uint64_t
name|tx_mltuse
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rmatch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_link_fc_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_link_fc_pkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_link_fc_jam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_16
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rx_link_fc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_link_fc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|la_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_flush
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_delay
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pipe_crd_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_busy
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_33_63
range|:
literal|31
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_cfg1_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_cfg1_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|pipe_crd_dis
range|:
literal|1
decl_stmt|;
comment|/**< Disable pipe credits.   Should be set when PKO is configure to                                                          ignore pipe credits. */
name|uint64_t
name|ptp_delay
range|:
literal|5
decl_stmt|;
comment|/**< Timestamp commit delay.  Must not be zero. */
name|uint64_t
name|skip_cnt
range|:
literal|4
decl_stmt|;
comment|/**< Number of skip words to insert after the scrambler state */
name|uint64_t
name|pkt_flush
range|:
literal|1
decl_stmt|;
comment|/**< Packet transmit flush.  While PKT_FLUSH=1, the TxFifo will                                                          continuously drain; all data will be dropped.  Software should                                                          first write PKT_ENA=0 and wait packet transmission to stop. */
name|uint64_t
name|pkt_ena
range|:
literal|1
decl_stmt|;
comment|/**< Packet transmit enable.  When PKT_ENA=0, the Tx-Link will stop                                                          transmitting packets, as per RX_LINK_FC_PKT */
name|uint64_t
name|la_mode
range|:
literal|1
decl_stmt|;
comment|/**< 0 = Interlaken                                                          1 = Interlaken Look-Aside */
name|uint64_t
name|tx_link_fc
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control status transmitted by the Tx-Link                                                          XON when RX_FIFO_CNT<= RX_FIFO_HWM and lane alignment is done */
name|uint64_t
name|rx_link_fc
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control status received in burst/idle control words.                                                          When RX_LINK_FC_IGN=0, XOFF will cause Tx-Link to stop                                                          transmitting on all channels. */
name|uint64_t
name|reserved_12_16
range|:
literal|5
decl_stmt|;
name|uint64_t
name|tx_link_fc_jam
range|:
literal|1
decl_stmt|;
comment|/**< All flow control transmitted in burst/idle control words will                                                          be XOFF whenever TX_LINK_FC is XOFF.   Enable this to allow                                                          link XOFF to automatically XOFF all channels. */
name|uint64_t
name|rx_link_fc_pkt
range|:
literal|1
decl_stmt|;
comment|/**< Link flow control received in burst/idle control words causes                                                          Tx-Link to stop transmitting at the end of a packet instead of                                                          the end of a burst */
name|uint64_t
name|rx_link_fc_ign
range|:
literal|1
decl_stmt|;
comment|/**< Ignore the link flow control status received in burst/idle                                                          control words */
name|uint64_t
name|rmatch
range|:
literal|1
decl_stmt|;
comment|/**< Enable rate matching circuitry */
name|uint64_t
name|tx_mltuse
range|:
literal|8
decl_stmt|;
comment|/**< Multiple Use bits used when ILKx_TX_CFG[LA_MODE=0] and                                                          ILKx_TX_CFG[MLTUSE_FC_ENA] is zero */
else|#
directive|else
name|uint64_t
name|tx_mltuse
range|:
literal|8
decl_stmt|;
name|uint64_t
name|rmatch
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_link_fc_ign
range|:
literal|1
decl_stmt|;
name|uint64_t
name|rx_link_fc_pkt
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_link_fc_jam
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_12_16
range|:
literal|5
decl_stmt|;
name|uint64_t
name|rx_link_fc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_link_fc
range|:
literal|1
decl_stmt|;
name|uint64_t
name|la_mode
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_ena
range|:
literal|1
decl_stmt|;
name|uint64_t
name|pkt_flush
range|:
literal|1
decl_stmt|;
name|uint64_t
name|skip_cnt
range|:
literal|4
decl_stmt|;
name|uint64_t
name|ptp_delay
range|:
literal|5
decl_stmt|;
name|uint64_t
name|pipe_crd_dis
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_cfg1
name|cvmx_ilk_txx_cfg1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_dbg  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_dbg
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_dbg_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
name|uint64_t
name|tx_bad_crc24
range|:
literal|1
decl_stmt|;
comment|/**< Send a control word with bad CRC24.  Hardware will clear this                                                          field once the injection is performed. */
name|uint64_t
name|tx_bad_ctlw2
range|:
literal|1
decl_stmt|;
comment|/**< Send a control word without the control bit set */
name|uint64_t
name|tx_bad_ctlw1
range|:
literal|1
decl_stmt|;
comment|/**< Send a data word with the control bit set */
else|#
directive|else
name|uint64_t
name|tx_bad_ctlw1
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bad_ctlw2
range|:
literal|1
decl_stmt|;
name|uint64_t
name|tx_bad_crc24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_3_63
range|:
literal|61
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_dbg_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_dbg_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_dbg
name|cvmx_ilk_txx_dbg_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_flow_ctl0  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_flow_ctl0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_flow_ctl0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|status
range|:
literal|64
decl_stmt|;
comment|/**< IPD flow control status for backpressue id 63-0, where a 0                                                          indicates the presence of backpressure (ie. XOFF) and 1                                                          indicates the absence of backpressure (ie. XON) */
else|#
directive|else
name|uint64_t
name|status
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_flow_ctl0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_flow_ctl0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_flow_ctl0
name|cvmx_ilk_txx_flow_ctl0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_flow_ctl1  *  * Notes:  * Do not publish.  *  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_flow_ctl1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_flow_ctl1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
else|#
directive|else
name|uint64_t
name|reserved_0_63
range|:
literal|64
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_flow_ctl1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_flow_ctl1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_flow_ctl1
name|cvmx_ilk_txx_flow_ctl1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_idx_cal  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_idx_cal
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_idx_cal_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|6
decl_stmt|;
comment|/**< Increment to add to current index for next index. NOTE:                                                          Increment only performed after *MEM_CAL1 access (ie. not                                                          *MEM_CAL0) */
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|index
range|:
literal|6
decl_stmt|;
comment|/**< Specify the group of 8 entries accessed by the next CSR                                                          read/write to calendar table memory.  Software must ensure IDX                                                          is<36 whenever writing to *MEM_CAL1 */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_14_63
range|:
literal|50
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_idx_cal_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_idx_cal_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_idx_cal
name|cvmx_ilk_txx_idx_cal_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_idx_pmap  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_idx_pmap
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_idx_pmap_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|7
decl_stmt|;
comment|/**< Increment to add to current index for next index. */
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|index
range|:
literal|7
decl_stmt|;
comment|/**< Specify the port-pipe accessed by the next CSR read/write to                                                          ILK_TXx_MEM_PMAP.   Note that IDX=n is always port-pipe n,                                                          regardless of ILK_TXx_PIPE[BASE] */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_23_63
range|:
literal|41
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_idx_pmap_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_idx_pmap_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_idx_pmap
name|cvmx_ilk_txx_idx_pmap_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_idx_stat0  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_idx_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_idx_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_TXx_MEM_STAT0 clears the selected counter after                                                          returning its current value. */
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Specify the channel accessed during the next CSR read to the                                                          ILK_TXx_MEM_STAT0 */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_idx_stat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_idx_stat0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_idx_stat0
name|cvmx_ilk_txx_idx_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_idx_stat1  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_idx_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_idx_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
comment|/**< CSR read to ILK_TXx_MEM_STAT1 clears the selected counter after                                                          returning its current value. */
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
comment|/**< Increment to add to current index for next index */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
comment|/**< Specify the channel accessed during the next CSR read to the                                                          ILK_TXx_MEM_STAT1 */
else|#
directive|else
name|uint64_t
name|index
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|inc
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_30
range|:
literal|7
decl_stmt|;
name|uint64_t
name|clr
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_32_63
range|:
literal|32
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_idx_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_idx_stat1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_idx_stat1
name|cvmx_ilk_txx_idx_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_int  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_int
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_int_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Statistics counter overflow */
name|uint64_t
name|bad_pipe
range|:
literal|1
decl_stmt|;
comment|/**< Received a PKO port-pipe out of the range specified by                                                          ILK_TXX_PIPE */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Received sequence is not SOP followed by 0 or more data cycles                                                          followed by EOP.  PKO config assigned multiple engines to the                                                          same ILK Tx Link. */
name|uint64_t
name|txf_err
range|:
literal|1
decl_stmt|;
comment|/**< TX fifo parity error occurred.  At EOP time, EOP_Format will                                                          reflect the error. */
else|#
directive|else
name|uint64_t
name|txf_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_pipe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_int_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_int_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_int
name|cvmx_ilk_txx_int_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_int_en  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_int_en
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_int_en_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
comment|/**< Statistics counter overflow */
name|uint64_t
name|bad_pipe
range|:
literal|1
decl_stmt|;
comment|/**< Received a PKO port-pipe out of the range specified by                                                          ILK_TXX_PIPE. */
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
comment|/**< Received sequence is not SOP followed by 0 or more data cycles                                                          followed by EOP.  PKO config assigned multiple engines to the                                                          same ILK Tx Link. */
name|uint64_t
name|txf_err
range|:
literal|1
decl_stmt|;
comment|/**< TX fifo parity error occurred.  At EOP time, EOP_Format will                                                          reflect the error. */
else|#
directive|else
name|uint64_t
name|txf_err
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_seq
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bad_pipe
range|:
literal|1
decl_stmt|;
name|uint64_t
name|stat_cnt_ovfl
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_4_63
range|:
literal|60
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_int_en_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_int_en_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_int_en
name|cvmx_ilk_txx_int_en_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_mem_cal0  *  * Notes:  * Software must always read ILK_TXx_MEM_CAL0 then ILK_TXx_MEM_CAL1.  Software  * must never read them in reverse order or read one without reading the  * other.  *  * Software must always write ILK_TXx_MEM_CAL0 then ILK_TXx_MEM_CAL1.  * Software must never write them in reverse order or write one without  * writing the other.  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_mem_cal0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_mem_cal0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|entry_ctl3
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+3                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_33_33
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid3
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+3                                                          (unused if ENTRY_CTL3 != 0) */
name|uint64_t
name|entry_ctl2
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+2                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_24_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid2
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+2                                                          (unused if ENTRY_CTL2 != 0) */
name|uint64_t
name|entry_ctl1
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+1                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid1
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+1                                                          (unused if ENTRY_CTL1 != 0) */
name|uint64_t
name|entry_ctl0
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+0                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid0
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+0                                                          (unused if ENTRY_CTL0 != 0) */
else|#
directive|else
name|uint64_t
name|bpid0
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl0
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid1
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl1
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid2
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl2
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid3
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_33_33
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl3
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_mem_cal0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_mem_cal0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_mem_cal0
name|cvmx_ilk_txx_mem_cal0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_mem_cal1  *  * Notes:  * Software must always read ILK_TXx_MEM_CAL0 then ILK_TXx_MEM_CAL1.  Software  * must never read them in reverse order or read one without reading the  * other.  *  * Software must always write ILK_TXx_MEM_CAL0 then ILK_TXx_MEM_CAL1.  * Software must never write them in reverse order or write one without  * writing the other.  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_mem_cal1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_mem_cal1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|entry_ctl7
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+7                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_33_33
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid7
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+7                                                          (unused if ENTRY_CTL7 != 0) */
name|uint64_t
name|entry_ctl6
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+6                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_24_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid6
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+6                                                          (unused if ENTRY_CTL6 != 0) */
name|uint64_t
name|entry_ctl5
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+5                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid5
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+5                                                          (unused if ENTRY_CTL5 != 0) */
name|uint64_t
name|entry_ctl4
range|:
literal|2
decl_stmt|;
comment|/**< Select source of XON/XOFF for entry (IDX*8)+4                                                          - 0: IPD backpressue id                                                          - 1: Link                                                          - 2: XOFF                                                          - 3: XON */
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|bpid4
range|:
literal|6
decl_stmt|;
comment|/**< Select IPD backpressue id for calendar table entry (IDX*8)+4                                                          (unused if ENTRY_CTL4 != 0) */
else|#
directive|else
name|uint64_t
name|bpid4
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_6_6
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl4
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid5
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_15_15
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl5
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid6
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_24_24
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl6
range|:
literal|2
decl_stmt|;
name|uint64_t
name|bpid7
range|:
literal|6
decl_stmt|;
name|uint64_t
name|reserved_33_33
range|:
literal|1
decl_stmt|;
name|uint64_t
name|entry_ctl7
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_mem_cal1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_mem_cal1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_mem_cal1
name|cvmx_ilk_txx_mem_cal1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_mem_pmap  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_mem_pmap
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_mem_pmap_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
name|uint64_t
name|remap
range|:
literal|1
decl_stmt|;
comment|/**< Dynamically select channel using bits[39:32] of an 8-byte                                                          header prepended to any packet transmitted on the port-pipe                                                          selected by ILK_TXx_IDX_PMAP[IDX].                                                           ***NOTE: Added in pass 2.0 */
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|channel
range|:
literal|8
decl_stmt|;
comment|/**< Specify the channel for the port-pipe selected by                                                          ILK_TXx_IDX_PMAP[IDX] */
else|#
directive|else
name|uint64_t
name|channel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_15
range|:
literal|8
decl_stmt|;
name|uint64_t
name|remap
range|:
literal|1
decl_stmt|;
name|uint64_t
name|reserved_17_63
range|:
literal|47
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_mem_pmap_s
name|cn68xx
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_mem_pmap_cn68xxp1
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
name|uint64_t
name|channel
range|:
literal|8
decl_stmt|;
comment|/**< Specify the channel for the port-pipe selected by                                                          ILK_TXx_IDX_PMAP[IDX] */
else|#
directive|else
name|uint64_t
name|channel
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_8_63
range|:
literal|56
decl_stmt|;
endif|#
directive|endif
block|}
name|cn68xxp1
struct|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_mem_pmap
name|cvmx_ilk_txx_mem_pmap_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_mem_stat0  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_mem_stat0
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_mem_stat0_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
name|uint64_t
name|tx_pkt
range|:
literal|28
decl_stmt|;
comment|/**< Number of packets transmitted per channel (256M)                                                          Channel selected by ILK_TXx_IDX_STAT0[IDX].  Interrupt on                                                          saturation if ILK_TXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|tx_pkt
range|:
literal|28
decl_stmt|;
name|uint64_t
name|reserved_28_63
range|:
literal|36
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_mem_stat0_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_mem_stat0_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_mem_stat0
name|cvmx_ilk_txx_mem_stat0_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_mem_stat1  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_mem_stat1
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_mem_stat1_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
name|uint64_t
name|tx_bytes
range|:
literal|36
decl_stmt|;
comment|/**< Number of bytes transmitted per channel (64GB) Channel selected                                                          by ILK_TXx_IDX_STAT1[IDX].    Saturates.  Interrupt on                                                          saturation if ILK_TXX_INT_EN[STAT_CNT_OVFL]=1. */
else|#
directive|else
name|uint64_t
name|tx_bytes
range|:
literal|36
decl_stmt|;
name|uint64_t
name|reserved_36_63
range|:
literal|28
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_mem_stat1_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_mem_stat1_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_mem_stat1
name|cvmx_ilk_txx_mem_stat1_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_pipe  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_pipe
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_pipe_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
name|uint64_t
name|nump
range|:
literal|8
decl_stmt|;
comment|/**< Number of pipes assigned to this Tx Link */
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|base
range|:
literal|7
decl_stmt|;
comment|/**< When NUMP is non-zero, indicates the base pipe number this                                                          Tx link will accept.  This Tx will accept PKO packets from                                                          pipes in the range of:  BASE .. (BASE+(NUMP-1))                                                             BASE and NUMP must be constrained such that                                                            1) BASE+(NUMP-1)< 127                                                            2) Each used PKO pipe must map to exactly                                                               one port|channel                                                            3) The pipe ranges must be consistent with                                                               the PKO configuration. */
else|#
directive|else
name|uint64_t
name|base
range|:
literal|7
decl_stmt|;
name|uint64_t
name|reserved_7_15
range|:
literal|9
decl_stmt|;
name|uint64_t
name|nump
range|:
literal|8
decl_stmt|;
name|uint64_t
name|reserved_24_63
range|:
literal|40
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_pipe_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_pipe_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_pipe
name|cvmx_ilk_txx_pipe_t
typedef|;
end_typedef

begin_comment
comment|/**  * cvmx_ilk_tx#_rmatch  */
end_comment

begin_union
union|union
name|cvmx_ilk_txx_rmatch
block|{
name|uint64_t
name|u64
decl_stmt|;
struct|struct
name|cvmx_ilk_txx_rmatch_s
block|{
ifdef|#
directive|ifdef
name|__BIG_ENDIAN_BITFIELD
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
name|uint64_t
name|grnlrty
range|:
literal|2
decl_stmt|;
comment|/**< Granularity of a token, where 1 token equal (1<<GRNLRTY) bytes. */
name|uint64_t
name|brst_limit
range|:
literal|16
decl_stmt|;
comment|/**< Size of token bucket, also the maximum quantity of data that                                                          may be burst across the interface before invoking rate limiting                                                          logic. */
name|uint64_t
name|time_limit
range|:
literal|16
decl_stmt|;
comment|/**< Number of cycles per time interval. (Must be>= 4) */
name|uint64_t
name|rate_limit
range|:
literal|16
decl_stmt|;
comment|/**< Number of tokens added to the bucket when the interval timer                                                          expires. */
else|#
directive|else
name|uint64_t
name|rate_limit
range|:
literal|16
decl_stmt|;
name|uint64_t
name|time_limit
range|:
literal|16
decl_stmt|;
name|uint64_t
name|brst_limit
range|:
literal|16
decl_stmt|;
name|uint64_t
name|grnlrty
range|:
literal|2
decl_stmt|;
name|uint64_t
name|reserved_50_63
range|:
literal|14
decl_stmt|;
endif|#
directive|endif
block|}
name|s
struct|;
name|struct
name|cvmx_ilk_txx_rmatch_s
name|cn68xx
decl_stmt|;
name|struct
name|cvmx_ilk_txx_rmatch_s
name|cn68xxp1
decl_stmt|;
block|}
union|;
end_union

begin_typedef
typedef|typedef
name|union
name|cvmx_ilk_txx_rmatch
name|cvmx_ilk_txx_rmatch_t
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

end_unit

