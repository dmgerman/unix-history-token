begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  *  Copyright (c) 2003-2008 Cavium Networks (support@cavium.com). All rights  *  reserved.  *  *  *  Redistribution and use in source and binary forms, with or without  *  modification, are permitted provided that the following conditions are  *  met:  *  *      * Redistributions of source code must retain the above copyright  *        notice, this list of conditions and the following disclaimer.  *  *      * Redistributions in binary form must reproduce the above  *        copyright notice, this list of conditions and the following  *        disclaimer in the documentation and/or other materials provided  *        with the distribution.  *  *      * Neither the name of Cavium Networks nor the names of  *        its contributors may be used to endorse or promote products  *        derived from this software without specific prior written  *        permission.  *  *  TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  *  AND WITH ALL FAULTS AND CAVIUM NETWORKS MAKES NO PROMISES, REPRESENTATIONS  *  OR WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH  *  RESPECT TO THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY  *  REPRESENTATION OR DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT  *  DEFECTS, AND CAVIUM SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES  *  OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR  *  PURPOSE, LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET  *  POSSESSION OR CORRESPONDENCE TO DESCRIPTION.  THE ENTIRE RISK ARISING OUT  *  OF USE OR PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  *  *  *  For any questions regarding licensing please contact marketing@caviumnetworks.com  *  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  * Simple allocate only memory allocator.  Used to allocate memory at application  * start time.  *  *<hr>$Revision: 41586 $<hr>  *  */
end_comment

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-spinlock.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_comment
comment|//#define DEBUG
end_comment

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|ALIGN_ADDR_UP
parameter_list|(
name|addr
parameter_list|,
name|align
parameter_list|)
value|(((addr) + (~(align)))& (align))
end_define

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|cvmx_bootmem_desc_t
modifier|*
name|cvmx_bootmem_desc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* See header file for descriptions of functions */
end_comment

begin_comment
comment|/* Wrapper functions are provided for reading/writing the size and next block ** values as these may not be directly addressible (in 32 bit applications, for instance.) */
end_comment

begin_comment
comment|/* Offsets of data elements in bootmem list, must match cvmx_bootmem_block_header_t */
end_comment

begin_define
define|#
directive|define
name|NEXT_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|SIZE_OFFSET
value|8
end_define

begin_function
specifier|static
name|void
name|cvmx_bootmem_phy_set_size
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|cvmx_write64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|SIZE_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_bootmem_phy_set_next
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|next
parameter_list|)
block|{
name|cvmx_write64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|NEXT_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|cvmx_bootmem_phy_get_size
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
return|return
operator|(
name|cvmx_read64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|SIZE_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|cvmx_bootmem_phy_get_next
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
return|return
operator|(
name|cvmx_read64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|NEXT_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This functions takes an address range and adjusts it as necessary to ** match the ABI that is currently being used.  This is required to ensure ** that bootmem_alloc* functions only return valid pointers for 32 bit ABIs */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_validate_mem_range
parameter_list|(
name|uint64_t
modifier|*
name|min_addr_ptr
parameter_list|,
name|uint64_t
modifier|*
name|max_addr_ptr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
block|{
specifier|extern
name|uint64_t
name|linux_mem32_min
decl_stmt|;
specifier|extern
name|uint64_t
name|linux_mem32_max
decl_stmt|;
comment|/* For 32 bit Linux apps, we need to restrict the allocations to the range         ** of memory configured for access from userspace.  Also, we need to add mappings         ** for the data structures that we access.*/
comment|/* Narrow range requests to be bounded by the 32 bit limits.  octeon_phy_mem_block_alloc()         ** will reject inconsistent req_size/range requests, so we don't repeat those checks here.         ** If max unspecified, set to 32 bit maximum. */
operator|*
name|min_addr_ptr
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
operator|*
name|min_addr_ptr
argument_list|,
name|linux_mem32_min
argument_list|)
argument_list|,
name|linux_mem32_max
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|max_addr_ptr
condition|)
operator|*
name|max_addr_ptr
operator|=
name|linux_mem32_max
expr_stmt|;
else|else
operator|*
name|max_addr_ptr
operator|=
name|MAX
argument_list|(
name|MIN
argument_list|(
operator|*
name|max_addr_ptr
argument_list|,
name|linux_mem32_max
argument_list|)
argument_list|,
name|linux_mem32_min
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
block|{
name|uint32_t
name|max_phys
init|=
literal|0x0FFFFFFF
decl_stmt|;
comment|/* Max physical address when 1-1 mappings not used */
if|#
directive|if
name|CVMX_USE_1_TO_1_TLB_MAPPINGS
name|max_phys
operator|=
literal|0x7FFFFFFF
expr_stmt|;
endif|#
directive|endif
comment|/* We are are running standalone simple executive, so we need to limit the range         ** that we allocate from */
comment|/* Narrow range requests to be bounded by the 32 bit limits.  octeon_phy_mem_block_alloc()         ** will reject inconsistent req_size/range requests, so we don't repeat those checks here.         ** If max unspecified, set to 32 bit maximum. */
operator|*
name|min_addr_ptr
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
operator|*
name|min_addr_ptr
argument_list|,
literal|0x0
argument_list|)
argument_list|,
name|max_phys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|max_addr_ptr
condition|)
operator|*
name|max_addr_ptr
operator|=
name|max_phys
expr_stmt|;
else|else
operator|*
name|max_addr_ptr
operator|=
name|MAX
argument_list|(
name|MIN
argument_list|(
operator|*
name|max_addr_ptr
argument_list|,
name|max_phys
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_range
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|uint64_t
name|min_addr
parameter_list|,
name|uint64_t
name|max_addr
parameter_list|)
block|{
name|int64_t
name|address
decl_stmt|;
name|__cvmx_validate_mem_range
argument_list|(
operator|&
name|min_addr
argument_list|,
operator|&
name|max_addr
argument_list|)
expr_stmt|;
name|address
operator|=
name|cvmx_bootmem_phy_alloc
argument_list|(
name|size
argument_list|,
name|min_addr
argument_list|,
name|max_addr
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|>
literal|0
condition|)
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|address
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_address
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|alignment
parameter_list|)
block|{
return|return
name|cvmx_bootmem_alloc_range
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|,
name|address
argument_list|,
name|address
operator|+
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|)
block|{
return|return
name|cvmx_bootmem_alloc_range
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_named_range
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|min_addr
parameter_list|,
name|uint64_t
name|max_addr
parameter_list|,
name|uint64_t
name|align
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int64_t
name|addr
decl_stmt|;
name|__cvmx_validate_mem_range
argument_list|(
operator|&
name|min_addr
argument_list|,
operator|&
name|max_addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_phy_named_block_alloc
argument_list|(
name|size
argument_list|,
name|min_addr
argument_list|,
name|max_addr
argument_list|,
name|align
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0
condition|)
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|addr
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_named_address
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_alloc_named_range
argument_list|(
name|size
argument_list|,
name|address
argument_list|,
name|address
operator|+
name|size
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_named
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_alloc_named_range
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|alignment
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_bootmem_free_named
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_phy_named_block_free
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|cvmx_bootmem_find_named_block
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_print_named
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_bootmem_phy_named_block_print
argument_list|()
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
end_if

begin_decl_stmt
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|linux32_named_block_array_ptr
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|cvmx_bootmem_init
parameter_list|(
name|void
modifier|*
name|mem_desc_ptr
parameter_list|)
block|{
comment|/* Verify that the size of cvmx_spinlock_t meets our assumptions */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cvmx_spinlock_t
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unexpected size of cvmx_spinlock_t\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Here we set the global pointer to the bootmem descriptor block.  This pointer will     ** be used directly, so we will set it up to be directly usable by the application.     ** It is set up as follows for the various runtime/ABI combinations:     ** Linux 64 bit: Set XKPHYS bit     ** Linux 32 bit: use mmap to create mapping, use virtual address     ** CVMX 64 bit:  use physical address directly     ** CVMX 32 bit:  use physical address directly     ** Note that the CVMX environment assumes the use of 1-1 TLB mappings so that the physical addresses     ** can be used directly     */
if|if
condition|(
operator|!
name|cvmx_bootmem_desc
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_USER
argument_list|)
operator|&&
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
name|void
modifier|*
name|base_ptr
decl_stmt|;
comment|/* For 32 bit, we need to use mmap to create a mapping for the bootmem descriptor */
name|int
name|dm_fd
init|=
name|open
argument_list|(
literal|"/dev/mem"
argument_list|,
name|O_RDWR
argument_list|)
decl_stmt|;
if|if
condition|(
name|dm_fd
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR opening /dev/mem for boot descriptor mapping\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|base_ptr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_desc_t
argument_list|)
operator|+
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|dm_fd
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|mem_desc_ptr
operator|)
operator|&
operator|~
operator|(
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAP_FAILED
operator|==
name|base_ptr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Error mapping bootmem descriptor!\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dm_fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Adjust pointer to point to bootmem_descriptor, rather than start of page it is in */
name|cvmx_bootmem_desc
operator|=
operator|(
name|cvmx_bootmem_desc_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|base_ptr
operator|+
operator|(
operator|(
operator|(
name|off_t
operator|)
name|mem_desc_ptr
operator|)
operator|&
operator|(
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* Also setup mapping for named memory block desc. while we are at it.  Here we must keep another         ** pointer around, as the value in the bootmem descriptor is shared with other applications. */
name|base_ptr
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
operator|*
name|cvmx_bootmem_desc
operator|->
name|named_block_num_blocks
operator|+
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_SHARED
argument_list|,
name|dm_fd
argument_list|,
operator|(
operator|(
name|off_t
operator|)
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
operator|)
operator|&
operator|~
operator|(
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|dm_fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAP_FAILED
operator|==
name|base_ptr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Error mapping named block descriptor!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Adjust pointer to point to named block array, rather than start of page it is in */
name|linux32_named_block_array_ptr
operator|=
operator|(
name|cvmx_bootmem_named_block_desc_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|base_ptr
operator|+
operator|(
operator|(
operator|(
name|off_t
operator|)
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
operator|)
operator|&
operator|(
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
operator|-
literal|1
operator|)
operator|)
operator|)
expr_stmt|;
elif|#
directive|elif
operator|(
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|||
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_USER
argument_list|)
operator|)
operator|&&
name|defined
argument_list|(
name|CVMX_ABI_64
argument_list|)
comment|/* Set XKPHYS bit */
name|cvmx_bootmem_desc
operator|=
name|cvmx_phys_to_ptr
argument_list|(
name|CAST64
argument_list|(
name|mem_desc_ptr
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cvmx_bootmem_desc
operator|=
operator|(
name|cvmx_bootmem_desc_t
operator|*
operator|)
name|mem_desc_ptr
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_bootmem_available_mem
parameter_list|(
name|uint64_t
name|min_block_size
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_phy_available_mem
argument_list|(
name|min_block_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************* ** The cvmx_bootmem_phy* functions below return 64 bit physical addresses, ** and expose more features that the cvmx_bootmem_functions above.  These are ** required for full memory space access in 32 bit applications, as well as for ** using some advance features. ** Most applications should not need to use these. ** **/
end_comment

begin_function
name|int64_t
name|cvmx_bootmem_phy_alloc
parameter_list|(
name|uint64_t
name|req_size
parameter_list|,
name|uint64_t
name|address_min
parameter_list|,
name|uint64_t
name|address_max
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|head_addr
decl_stmt|;
name|uint64_t
name|ent_addr
decl_stmt|;
name|uint64_t
name|prev_addr
init|=
literal|0
decl_stmt|;
comment|/* points to previous list entry, NULL current entry is head of list */
name|uint64_t
name|new_ent_addr
init|=
literal|0
decl_stmt|;
name|uint64_t
name|desired_min_addr
decl_stmt|;
name|uint64_t
name|alignment_mask
init|=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_alloc: req_size: 0x%llx, min_addr: 0x%llx, max_addr: 0x%llx, align: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|req_size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|address_min
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|address_max
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|>
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
comment|/* Do a variety of checks to validate the arguments.  The allocator code will later assume     ** that these checks have been made.  We validate that the requested constraints are not     ** self-contradictory before we look through the list of available memory     */
comment|/* 0 is not a valid req_size for this allocator */
if|if
condition|(
operator|!
name|req_size
condition|)
goto|goto
name|error_out
goto|;
comment|/* Round req_size up to mult of minimum alignment bytes */
name|req_size
operator|=
operator|(
name|req_size
operator|+
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Convert !0 address_min and 0 address_max to special case of range that specifies an exact     ** memory block to allocate.  Do this before other checks and adjustments so that this tranformation will be validated */
if|if
condition|(
name|address_min
operator|&&
operator|!
name|address_max
condition|)
name|address_max
operator|=
name|address_min
operator|+
name|req_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|address_min
operator|&&
operator|!
name|address_max
condition|)
name|address_max
operator|=
operator|~
literal|0ull
expr_stmt|;
comment|/* If no limits given, use max limits */
comment|/* Enforce minimum alignment (this also keeps the minimum free block     ** req_size the same as the alignment req_size */
if|if
condition|(
name|alignment
operator|<
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
condition|)
block|{
name|alignment
operator|=
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
expr_stmt|;
block|}
name|alignment_mask
operator|=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Adjust address minimum based on requested alignment (round up to meet alignment).  Do this here so we can     ** reject impossible requests up front. (NOP for address_min == 0) */
if|if
condition|(
name|alignment
condition|)
name|address_min
operator|=
operator|(
name|address_min
operator|+
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Reject inconsistent args.  We have adjusted these, so this may fail due to our internal changes     ** even if this check would pass for the values the user supplied. */
if|if
condition|(
name|req_size
operator|>
name|address_max
operator|-
name|address_min
condition|)
goto|goto
name|error_out
goto|;
comment|/* Walk through the list entries - first fit found is returned */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
name|head_addr
operator|=
name|cvmx_bootmem_desc
operator|->
name|head_addr
expr_stmt|;
name|ent_addr
operator|=
name|head_addr
expr_stmt|;
while|while
condition|(
name|ent_addr
condition|)
block|{
name|uint64_t
name|usable_base
decl_stmt|,
name|usable_max
decl_stmt|;
name|uint64_t
name|ent_size
init|=
name|cvmx_bootmem_phy_get_size
argument_list|(
name|ent_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
operator|&&
name|ent_addr
operator|>
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Internal bootmem_alloc() error: ent: 0x%llx, next: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|ent_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
comment|/* Determine if this is an entry that can satisify the request */
comment|/* Check to make sure entry is large enough to satisfy request */
name|usable_base
operator|=
name|ALIGN_ADDR_UP
argument_list|(
name|MAX
argument_list|(
name|address_min
argument_list|,
name|ent_addr
argument_list|)
argument_list|,
name|alignment_mask
argument_list|)
expr_stmt|;
name|usable_max
operator|=
name|MIN
argument_list|(
name|address_max
argument_list|,
name|ent_addr
operator|+
name|ent_size
argument_list|)
expr_stmt|;
comment|/* We should be able to allocate block at address usable_base */
name|desired_min_addr
operator|=
name|usable_base
expr_stmt|;
comment|/* Determine if request can be satisfied from the current entry */
if|if
condition|(
operator|(
operator|(
operator|(
name|ent_addr
operator|+
name|ent_size
operator|)
operator|>
name|usable_base
operator|&&
name|ent_addr
operator|<
name|address_max
operator|)
operator|)
operator|&&
name|req_size
operator|<=
name|usable_max
operator|-
name|usable_base
condition|)
block|{
comment|/* We have found an entry that has room to satisfy the request, so allocate it from this entry */
comment|/* If end CVMX_BOOTMEM_FLAG_END_ALLOC set, then allocate from the end of this block             ** rather than the beginning */
if|if
condition|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_END_ALLOC
condition|)
block|{
name|desired_min_addr
operator|=
name|usable_max
operator|-
name|req_size
expr_stmt|;
comment|/* Align desired address down to required alignment */
name|desired_min_addr
operator|&=
name|alignment_mask
expr_stmt|;
block|}
comment|/* Match at start of entry */
if|if
condition|(
name|desired_min_addr
operator|==
name|ent_addr
condition|)
block|{
if|if
condition|(
name|req_size
operator|<
name|ent_size
condition|)
block|{
comment|/* big enough to create a new block from top portion of block */
name|new_ent_addr
operator|=
name|ent_addr
operator|+
name|req_size
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|new_ent_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|new_ent_addr
argument_list|,
name|ent_size
operator|-
name|req_size
argument_list|)
expr_stmt|;
comment|/* Adjust next pointer as following code uses this */
name|cvmx_bootmem_phy_set_next
argument_list|(
name|ent_addr
argument_list|,
name|new_ent_addr
argument_list|)
expr_stmt|;
block|}
comment|/* adjust prev ptr or head to remove this entry from list */
if|if
condition|(
name|prev_addr
condition|)
block|{
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* head of list being returned, so update head ptr */
name|cvmx_bootmem_desc
operator|->
name|head_addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|desired_min_addr
operator|)
return|;
block|}
comment|/* block returned doesn't start at beginning of entry, so we know             ** that we will be splitting a block off the front of this one.  Create a new block             ** from the beginning, add to list, and go to top of loop again.             **             ** create new block from high portion of block, so that top block             ** starts at desired addr             **/
name|new_ent_addr
operator|=
name|desired_min_addr
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|new_ent_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|new_ent_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|ent_addr
argument_list|)
operator|-
operator|(
name|desired_min_addr
operator|-
name|ent_addr
operator|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|ent_addr
argument_list|,
name|desired_min_addr
operator|-
name|ent_addr
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|ent_addr
argument_list|,
name|new_ent_addr
argument_list|)
expr_stmt|;
comment|/* Loop again to handle actual alloc from new block */
block|}
name|prev_addr
operator|=
name|ent_addr
expr_stmt|;
name|ent_addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
expr_stmt|;
block|}
name|error_out
label|:
comment|/* We didn't find anything, so return error */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__cvmx_bootmem_phy_free
parameter_list|(
name|uint64_t
name|phy_addr
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|cur_addr
decl_stmt|;
name|uint64_t
name|prev_addr
init|=
literal|0
decl_stmt|;
comment|/* zero is invalid */
name|int
name|retval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"__cvmx_bootmem_phy_free addr: 0x%llx, size: 0x%llx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|phy_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|>
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 0 is not a valid size for this allocator */
if|if
condition|(
operator|!
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
name|cur_addr
operator|=
name|cvmx_bootmem_desc
operator|->
name|head_addr
expr_stmt|;
if|if
condition|(
name|cur_addr
operator|==
literal|0
operator|||
name|phy_addr
operator|<
name|cur_addr
condition|)
block|{
comment|/* add at front of list - special case with changing head ptr */
if|if
condition|(
name|cur_addr
operator|&&
name|phy_addr
operator|+
name|size
operator|>
name|cur_addr
condition|)
goto|goto
name|bootmem_free_done
goto|;
comment|/* error, overlapping section */
elseif|else
if|if
condition|(
name|phy_addr
operator|+
name|size
operator|==
name|cur_addr
condition|)
block|{
comment|/* Add to front of existing first block */
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|cur_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_desc
operator|->
name|head_addr
operator|=
name|phy_addr
expr_stmt|;
block|}
else|else
block|{
comment|/* New block before first block */
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
comment|/* OK if cur_addr is 0 */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_desc
operator|->
name|head_addr
operator|=
name|phy_addr
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
comment|/* Find place in list to add block */
while|while
condition|(
name|cur_addr
operator|&&
name|phy_addr
operator|>
name|cur_addr
condition|)
block|{
name|prev_addr
operator|=
name|cur_addr
expr_stmt|;
name|cur_addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cur_addr
condition|)
block|{
comment|/* We have reached the end of the list, add on to end, checking         ** to see if we need to combine with last block         **/
if|if
condition|(
name|prev_addr
operator|+
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|==
name|phy_addr
condition|)
block|{
name|cvmx_bootmem_phy_set_size
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
else|else
block|{
comment|/* insert between prev and cur nodes, checking for merge with either/both */
if|if
condition|(
name|prev_addr
operator|+
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|==
name|phy_addr
condition|)
block|{
comment|/* Merge with previous */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_addr
operator|+
name|size
operator|==
name|cur_addr
condition|)
block|{
comment|/* Also merge with current */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|cur_addr
argument_list|)
operator|+
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
elseif|else
if|if
condition|(
name|phy_addr
operator|+
name|size
operator|==
name|cur_addr
condition|)
block|{
comment|/* Merge with current */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|cur_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
comment|/* It is a standalone block, add in between prev and cur */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
name|bootmem_free_done
label|:
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_phy_list_print
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|addr
operator|=
name|cvmx_bootmem_desc
operator|->
name|head_addr
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\n\n\nPrinting bootmem block list, descriptor: %p,  head is 0x%llx\n"
argument_list|,
name|cvmx_bootmem_desc
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Descriptor version: %d.%d\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|>
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Warning: Bootmem descriptor version is newer than expected\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"mem list is empty!\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Block address: 0x%08qx, size: 0x%08qx, next: 0x%08qx\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cvmx_bootmem_phy_get_size
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cvmx_bootmem_phy_get_next
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_bootmem_phy_available_mem
parameter_list|(
name|uint64_t
name|min_block_size
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|uint64_t
name|available_mem
init|=
literal|0
decl_stmt|;
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_desc
operator|->
name|head_addr
expr_stmt|;
while|while
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|cvmx_bootmem_phy_get_size
argument_list|(
name|addr
argument_list|)
operator|>=
name|min_block_size
condition|)
name|available_mem
operator|+=
name|cvmx_bootmem_phy_get_size
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|available_mem
operator|)
return|;
block|}
end_function

begin_function
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|cvmx_bootmem_phy_named_block_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|named_block_array_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_find: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Lock the structure to make sure that it is not being changed while we are     ** examining it.     */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
ifdef|#
directive|ifdef
name|CVMX_ABI_N32
comment|/* Need to use mmapped named block pointer in 32 bit linux apps */
specifier|extern
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|linux32_named_block_array_ptr
decl_stmt|;
name|named_block_array_ptr
operator|=
name|linux32_named_block_array_ptr
expr_stmt|;
else|#
directive|else
comment|/* Use XKPHYS for 64 bit linux */
name|named_block_array_ptr
operator|=
operator|(
name|cvmx_bootmem_named_block_desc_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Simple executive case. (and u-boot)     ** This could be in the low 1 meg of memory that is not 1-1 mapped, so we need use XKPHYS/KSEG0 addressing for it */
name|named_block_array_ptr
operator|=
name|CASTPTR
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_find: named_block_array_ptr: %p\n"
argument_list|,
name|named_block_array_ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|==
literal|3
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cvmx_bootmem_desc
operator|->
name|named_block_num_blocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|name
operator|&&
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|size
operator|&&
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|cvmx_bootmem_desc
operator|->
name|named_block_name_len
operator|-
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|name
operator|&&
operator|!
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|size
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
operator|(
name|named_block_array_ptr
index|[
name|i
index|]
operator|)
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_bootmem_phy_named_block_free
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|named_block_ptr
decl_stmt|;
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|!=
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_free: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Take lock here, as name lookup/block free/name free need to be atomic */
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
name|named_block_ptr
operator|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|name
argument_list|,
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|named_block_ptr
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_free: %s, base: 0x%llx, size: 0x%llx\n"
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|named_block_ptr
operator|->
name|base_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|named_block_ptr
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|__cvmx_bootmem_phy_free
argument_list|(
name|named_block_ptr
operator|->
name|base_addr
argument_list|,
name|named_block_ptr
operator|->
name|size
argument_list|,
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
name|named_block_ptr
operator|->
name|size
operator|=
literal|0
expr_stmt|;
comment|/* Set size to zero to indicate block not used. */
block|}
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|!
name|named_block_ptr
operator|)
return|;
comment|/* 0 on failure, 1 on success */
block|}
end_function

begin_function
name|int64_t
name|cvmx_bootmem_phy_named_block_alloc
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|min_addr
parameter_list|,
name|uint64_t
name|max_addr
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int64_t
name|addr_allocated
decl_stmt|;
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|named_block_desc_ptr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_alloc: size: 0x%llx, min: 0x%llx, max: 0x%llx, align: 0x%llx, name: %s\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|size
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|min_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|max_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|alignment
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|!=
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Take lock here, as name lookup/block alloc/name add need to be atomic */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
comment|/* Get pointer to first available named block descriptor */
name|named_block_desc_ptr
operator|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|NULL
argument_list|,
name|flags
operator||
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
comment|/* Check to see if name already in use, return error if name     ** not available or no more room for blocks.     */
if|if
condition|(
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|name
argument_list|,
name|flags
operator||
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
operator|||
operator|!
name|named_block_desc_ptr
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Round size up to mult of minimum alignment bytes     ** We need the actual size allocated to allow for blocks to be coallesced     ** when they are freed.  The alloc routine does the same rounding up     ** on all allocations. */
name|size
operator|=
operator|(
name|size
operator|+
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|addr_allocated
operator|=
name|cvmx_bootmem_phy_alloc
argument_list|(
name|size
argument_list|,
name|min_addr
argument_list|,
name|max_addr
argument_list|,
name|alignment
argument_list|,
name|flags
operator||
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_allocated
operator|>=
literal|0
condition|)
block|{
name|named_block_desc_ptr
operator|->
name|base_addr
operator|=
name|addr_allocated
expr_stmt|;
name|named_block_desc_ptr
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|strncpy
argument_list|(
name|named_block_desc_ptr
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|cvmx_bootmem_desc
operator|->
name|named_block_name_len
argument_list|)
expr_stmt|;
name|named_block_desc_ptr
operator|->
name|name
index|[
name|cvmx_bootmem_desc
operator|->
name|named_block_name_len
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr_allocated
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_phy_named_block_print
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|CONFIG_OCTEON_U_BOOT
argument_list|)
ifdef|#
directive|ifdef
name|CVMX_ABI_N32
comment|/* Need to use mmapped named block pointer in 32 bit linux apps */
specifier|extern
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|linux32_named_block_array_ptr
decl_stmt|;
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|named_block_array_ptr
init|=
name|linux32_named_block_array_ptr
decl_stmt|;
else|#
directive|else
comment|/* Use XKPHYS for 64 bit linux */
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|named_block_array_ptr
init|=
operator|(
name|cvmx_bootmem_named_block_desc_t
operator|*
operator|)
name|cvmx_phys_to_ptr
argument_list|(
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
argument_list|)
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* Simple executive case. (and u-boot)     ** This could be in the low 1 meg of memory that is not 1-1 mapped, so we need use XKPHYS/KSEG0 addressing for it */
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|named_block_array_ptr
init|=
name|CASTPTR
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|,
name|CVMX_ADD_SEG32
argument_list|(
name|CVMX_MIPS32_SPACE_KSEG0
argument_list|,
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
argument_list|)
argument_list|)
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_print, desc addr: %p\n"
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|!=
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: %p\n"
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|cvmx_bootmem_desc
operator|->
name|minor_version
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
return|return;
block|}
name|cvmx_dprintf
argument_list|(
literal|"List of currently allocated named bootmem blocks:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cvmx_bootmem_desc
operator|->
name|named_block_num_blocks
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
name|printed
operator|++
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Name: %s, address: 0x%08qx, size: 0x%08qx, index: %d\n"
argument_list|,
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|base_addr
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|named_block_array_ptr
index|[
name|i
index|]
operator|.
name|size
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|printed
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"No named bootmem blocks exist.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Real physical addresses of memory regions */
end_comment

begin_define
define|#
directive|define
name|OCTEON_DDR0_BASE
value|(0x0ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR0_SIZE
value|(0x010000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR1_BASE
value|(0x410000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR1_SIZE
value|(0x010000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR2_BASE
value|(0x020000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR2_SIZE
value|(0x3e0000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_MAX_PHY_MEM_SIZE
value|(16*1024*1024*1024ULL)
end_define

begin_function
name|int64_t
name|cvmx_bootmem_phy_mem_list_init
parameter_list|(
name|uint64_t
name|mem_size
parameter_list|,
name|uint32_t
name|low_reserved_bytes
parameter_list|,
name|cvmx_bootmem_desc_t
modifier|*
name|desc_buffer
parameter_list|)
block|{
name|uint64_t
name|cur_block_addr
decl_stmt|;
name|int64_t
name|addr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_mem_list_init (arg desc ptr: %p, cvmx_bootmem_desc: %p)\n"
argument_list|,
name|desc_buffer
argument_list|,
name|cvmx_bootmem_desc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Descriptor buffer needs to be in 32 bit addressable space to be compatible with     ** 32 bit applications */
if|if
condition|(
operator|!
name|desc_buffer
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: no memory for cvmx_bootmem descriptor provided\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mem_size
operator|>
name|OCTEON_MAX_PHY_MEM_SIZE
condition|)
block|{
name|mem_size
operator|=
name|OCTEON_MAX_PHY_MEM_SIZE
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: requested memory size too large, truncating to maximum size\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_bootmem_desc
condition|)
return|return
literal|1
return|;
comment|/* Initialize cvmx pointer to descriptor */
name|cvmx_bootmem_init
argument_list|(
name|desc_buffer
argument_list|)
expr_stmt|;
comment|/* Set up global pointer to start of list, exclude low 64k for exception vectors, space for global descriptor */
name|memset
argument_list|(
name|cvmx_bootmem_desc
argument_list|,
literal|0x0
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_desc_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set version of bootmem descriptor */
name|cvmx_bootmem_desc
operator|->
name|major_version
operator|=
name|CVMX_BOOTMEM_DESC_MAJ_VER
expr_stmt|;
name|cvmx_bootmem_desc
operator|->
name|minor_version
operator|=
name|CVMX_BOOTMEM_DESC_MIN_VER
expr_stmt|;
name|cur_block_addr
operator|=
name|cvmx_bootmem_desc
operator|->
name|head_addr
operator|=
operator|(
name|OCTEON_DDR0_BASE
operator|+
name|low_reserved_bytes
operator|)
expr_stmt|;
name|cvmx_bootmem_desc
operator|->
name|head_addr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|mem_size
operator|<=
name|OCTEON_DDR0_SIZE
condition|)
block|{
name|__cvmx_bootmem_phy_free
argument_list|(
name|cur_block_addr
argument_list|,
name|mem_size
operator|-
name|low_reserved_bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|frees_done
goto|;
block|}
name|__cvmx_bootmem_phy_free
argument_list|(
name|cur_block_addr
argument_list|,
name|OCTEON_DDR0_SIZE
operator|-
name|low_reserved_bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_size
operator|-=
name|OCTEON_DDR0_SIZE
expr_stmt|;
comment|/* Add DDR2 block next if present */
if|if
condition|(
name|mem_size
operator|>
name|OCTEON_DDR1_SIZE
condition|)
block|{
name|__cvmx_bootmem_phy_free
argument_list|(
name|OCTEON_DDR1_BASE
argument_list|,
name|OCTEON_DDR1_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_bootmem_phy_free
argument_list|(
name|OCTEON_DDR2_BASE
argument_list|,
name|mem_size
operator|-
name|OCTEON_DDR1_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__cvmx_bootmem_phy_free
argument_list|(
name|OCTEON_DDR1_BASE
argument_list|,
name|mem_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|frees_done
label|:
comment|/* Initialize the named block structure */
name|cvmx_bootmem_desc
operator|->
name|named_block_name_len
operator|=
name|CVMX_BOOTMEM_NAME_LEN
expr_stmt|;
name|cvmx_bootmem_desc
operator|->
name|named_block_num_blocks
operator|=
name|CVMX_BOOTMEM_NUM_NAMED_BLOCKS
expr_stmt|;
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
operator|=
literal|0
expr_stmt|;
comment|/* Allocate this near the top of the low 256 MBytes of memory */
name|addr
operator|=
name|cvmx_bootmem_phy_alloc
argument_list|(
name|CVMX_BOOTMEM_NUM_NAMED_BLOCKS
operator|*
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0x10000000
argument_list|,
literal|0
argument_list|,
name|CVMX_BOOTMEM_FLAG_END_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0
condition|)
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
operator|=
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_mem_list_init: named_block_array_addr: 0x%llx)\n"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"FATAL ERROR: unable to allocate memory for bootmem descriptor!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|unsigned
name|long
operator|)
name|cvmx_bootmem_desc
operator|->
name|named_block_array_addr
argument_list|,
literal|0x0
argument_list|,
name|CVMX_BOOTMEM_NUM_NAMED_BLOCKS
operator|*
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_spinlock_lock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_spinlock_unlock
argument_list|(
operator|(
name|cvmx_spinlock_t
operator|*
operator|)
operator|&
operator|(
name|cvmx_bootmem_desc
operator|->
name|lock
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|__cvmx_bootmem_internal_get_desc_ptr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_desc
operator|)
return|;
block|}
end_function

end_unit

