begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  * Simple allocate only memory allocator.  Used to allocate memory at application  * start time.  *  *<hr>$Revision: 52119 $<hr>  *  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootmem.h>
end_include

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"executive-config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-bootmem.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
name|uint32_t
name|cvmx_spinlock_t
typedef|;
end_typedef

begin_comment
comment|//#define DEBUG
end_comment

begin_define
define|#
directive|define
name|ULL
value|unsigned long long
end_define

begin_undef
undef|#
directive|undef
name|MAX
end_undef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)> (b)) ? (a) : (b))
end_define

begin_undef
undef|#
directive|undef
name|MIN
end_undef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((a)< (b)) ? (a) : (b))
end_define

begin_define
define|#
directive|define
name|ALIGN_ADDR_UP
parameter_list|(
name|addr
parameter_list|,
name|align
parameter_list|)
value|(((addr) + (~(align)))& (align))
end_define

begin_comment
comment|/**  * This is the physical location of a cvmx_bootmem_desc_t  * structure in Octeon's memory. Note that dues to addressing  * limits or runtime environment it might not be possible to  * create a C pointer to this structure.  */
end_comment

begin_decl_stmt
specifier|static
name|CVMX_SHARED
name|uint64_t
name|cvmx_bootmem_desc_addr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * This macro returns the size of a member of a structure.  * Logically it is the same as "sizeof(s::field)" in C++, but  * C lacks the "::" operator.  */
end_comment

begin_define
define|#
directive|define
name|SIZEOF_FIELD
parameter_list|(
name|s
parameter_list|,
name|field
parameter_list|)
value|sizeof(((s*)NULL)->field)
end_define

begin_comment
comment|/**  * This macro returns a member of the cvmx_bootmem_desc_t  * structure. These members can't be directly addressed as  * they might be in memory not directly reachable. In the case  * where bootmem is compiled with LINUX_HOST, the structure  * itself might be located on a remote Octeon. The argument  * "field" is the member name of the cvmx_bootmem_desc_t to read.  * Regardless of the type of the field, the return type is always  * a uint64_t.  */
end_comment

begin_define
define|#
directive|define
name|CVMX_BOOTMEM_DESC_GET_FIELD
parameter_list|(
name|field
parameter_list|)
define|\
value|__cvmx_bootmem_desc_get(cvmx_bootmem_desc_addr,                 \         offsetof(cvmx_bootmem_desc_t, field),                       \         SIZEOF_FIELD(cvmx_bootmem_desc_t, field))
end_define

begin_comment
comment|/**  * This macro writes a member of the cvmx_bootmem_desc_t  * structure. These members can't be directly addressed as  * they might be in memory not directly reachable. In the case  * where bootmem is compiled with LINUX_HOST, the structure  * itself might be located on a remote Octeon. The argument  * "field" is the member name of the cvmx_bootmem_desc_t to write.  */
end_comment

begin_define
define|#
directive|define
name|CVMX_BOOTMEM_DESC_SET_FIELD
parameter_list|(
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|__cvmx_bootmem_desc_set(cvmx_bootmem_desc_addr,                 \         offsetof(cvmx_bootmem_desc_t, field),                       \         SIZEOF_FIELD(cvmx_bootmem_desc_t, field), value)
end_define

begin_comment
comment|/**  * This macro returns a member of the  * cvmx_bootmem_named_block_desc_t structure. These members can't  * be directly addressed as they might be in memory not directly  * reachable. In the case where bootmem is compiled with  * LINUX_HOST, the structure itself might be located on a remote  * Octeon. The argument "field" is the member name of the  * cvmx_bootmem_named_block_desc_t to read. Regardless of the type  * of the field, the return type is always a uint64_t. The "addr"  * parameter is the physical address of the structure.  */
end_comment

begin_define
define|#
directive|define
name|CVMX_BOOTMEM_NAMED_GET_FIELD
parameter_list|(
name|addr
parameter_list|,
name|field
parameter_list|)
define|\
value|__cvmx_bootmem_desc_get(addr,                                   \         offsetof(cvmx_bootmem_named_block_desc_t, field),           \         SIZEOF_FIELD(cvmx_bootmem_named_block_desc_t, field))
end_define

begin_comment
comment|/**  * This macro writes a member of the cvmx_bootmem_named_block_desc_t  * structure. These members can't be directly addressed as  * they might be in memory not directly reachable. In the case  * where bootmem is compiled with LINUX_HOST, the structure  * itself might be located on a remote Octeon. The argument  * "field" is the member name of the  * cvmx_bootmem_named_block_desc_t to write. The "addr" parameter  * is the physical address of the structure.  */
end_comment

begin_define
define|#
directive|define
name|CVMX_BOOTMEM_NAMED_SET_FIELD
parameter_list|(
name|addr
parameter_list|,
name|field
parameter_list|,
name|value
parameter_list|)
define|\
value|__cvmx_bootmem_desc_set(addr,                                   \         offsetof(cvmx_bootmem_named_block_desc_t, field),           \         SIZEOF_FIELD(cvmx_bootmem_named_block_desc_t, field), value)
end_define

begin_comment
comment|/**  * This function is the implementation of the get macros defined  * for individual structure members. The argument are generated  * by the macros inorder to read only the needed memory.  *  * @param base   64bit physical address of the complete structure  * @param offset Offset from the beginning of the structure to the member being  *               accessed.  * @param size   Size of the structure member.  *  * @return Value of the structure member promoted into a uint64_t.  */
end_comment

begin_function
specifier|static
specifier|inline
name|uint64_t
name|__cvmx_bootmem_desc_get
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|base
operator|=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator||
operator|(
name|base
operator|+
name|offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
return|return
name|cvmx_read64_uint32
argument_list|(
name|base
argument_list|)
return|;
case|case
literal|8
case|:
return|return
name|cvmx_read64_uint64
argument_list|(
name|base
argument_list|)
return|;
default|default:
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/**  * This function is the implementation of the set macros defined  * for individual structure members. The argument are generated  * by the macros in order to write only the needed memory.  *  * @param base   64bit physical address of the complete structure  * @param offset Offset from the beginning of the structure to the member being  *               accessed.  * @param size   Size of the structure member.  * @param value  Value to write into the structure  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_bootmem_desc_set
parameter_list|(
name|uint64_t
name|base
parameter_list|,
name|int
name|offset
parameter_list|,
name|int
name|size
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|base
operator|=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator||
operator|(
name|base
operator|+
name|offset
operator|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|4
case|:
name|cvmx_write64_uint32
argument_list|(
name|base
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|cvmx_write64_uint64
argument_list|(
name|base
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
end_function

begin_comment
comment|/**  * This function retrieves the string name of a named block. It is  * more complicated than a simple memcpy() since the named block  * descriptor may not be directly accessable.  *  * @param addr   Physical address of the named block descriptor  * @param str    String to receive the named block string name  * @param len    Length of the string buffer, which must match the length  *               stored in the bootmem descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|CVMX_BOOTMEM_NAMED_GET_NAME
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
name|int
name|l
init|=
name|len
decl_stmt|;
name|char
modifier|*
name|ptr
init|=
name|str
decl_stmt|;
name|addr
operator||=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
expr_stmt|;
name|addr
operator|+=
name|offsetof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
operator|*
name|ptr
operator|++
operator|=
name|cvmx_read64_uint8
argument_list|(
name|addr
operator|++
argument_list|)
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
else|#
directive|else
specifier|extern
name|void
name|octeon_remote_read_mem
argument_list|(
name|void
operator|*
name|buffer
argument_list|,
name|uint64_t
name|physical_address
argument_list|,
name|int
name|length
argument_list|)
decl_stmt|;
name|addr
operator|+=
name|offsetof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|octeon_remote_read_mem
argument_list|(
name|str
argument_list|,
name|addr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|str
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/**  * This function stores the string name of a named block. It is  * more complicated than a simple memcpy() since the named block  * descriptor may not be directly accessable.  *  * @param addr   Physical address of the named block descriptor  * @param str    String to store into the named block string name  * @param len    Length of the string buffer, which must match the length  *               stored in the bootmem descriptor.  */
end_comment

begin_function
specifier|static
name|void
name|CVMX_BOOTMEM_NAMED_SET_NAME
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
name|int
name|l
init|=
name|len
decl_stmt|;
name|addr
operator||=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
expr_stmt|;
name|addr
operator|+=
name|offsetof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|,
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|--
condition|)
block|{
if|if
condition|(
name|l
condition|)
name|cvmx_write64_uint8
argument_list|(
name|addr
operator|++
argument_list|,
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
else|else
name|cvmx_write64_uint8
argument_list|(
name|addr
operator|++
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
specifier|extern
name|void
name|octeon_remote_write_mem
argument_list|(
name|uint64_t
name|physical_address
argument_list|,
specifier|const
name|void
operator|*
name|buffer
argument_list|,
name|int
name|length
argument_list|)
decl_stmt|;
name|char
name|zero
init|=
literal|0
decl_stmt|;
name|addr
operator|+=
name|offsetof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|octeon_remote_write_mem
argument_list|(
name|addr
argument_list|,
name|str
argument_list|,
name|len
operator|-
literal|1
argument_list|)
expr_stmt|;
name|octeon_remote_write_mem
argument_list|(
name|addr
operator|+
name|len
operator|-
literal|1
argument_list|,
operator|&
name|zero
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* See header file for descriptions of functions */
end_comment

begin_comment
comment|/* Wrapper functions are provided for reading/writing the size and next block ** values as these may not be directly addressible (in 32 bit applications, for instance.) */
end_comment

begin_comment
comment|/* Offsets of data elements in bootmem list, must match cvmx_bootmem_block_header_t */
end_comment

begin_define
define|#
directive|define
name|NEXT_OFFSET
value|0
end_define

begin_define
define|#
directive|define
name|SIZE_OFFSET
value|8
end_define

begin_function
specifier|static
name|void
name|cvmx_bootmem_phy_set_size
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|cvmx_write64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|SIZE_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_bootmem_phy_set_next
parameter_list|(
name|uint64_t
name|addr
parameter_list|,
name|uint64_t
name|next
parameter_list|)
block|{
name|cvmx_write64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|NEXT_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|cvmx_bootmem_phy_get_size
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
return|return
operator|(
name|cvmx_read64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|SIZE_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|cvmx_bootmem_phy_get_next
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
return|return
operator|(
name|cvmx_read64_uint64
argument_list|(
operator|(
name|addr
operator|+
name|NEXT_OFFSET
operator|)
operator||
operator|(
literal|1ull
operator|<<
literal|63
operator|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/**  * Check the version information on the bootmem descriptor  *  * @param exact_match  *               Exact major version to check against. A zero means  *               check that the version supports named blocks.  *  * @return Zero if the version is correct. Negative if the version is  *         incorrect. Failures also cause a message to be displayed.  */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_bootmem_check_version
parameter_list|(
name|int
name|exact_match
parameter_list|)
block|{
name|int
name|major_version
decl_stmt|;
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_HOST
if|if
condition|(
operator|!
name|cvmx_bootmem_desc_addr
condition|)
name|cvmx_bootmem_desc_addr
operator|=
name|cvmx_read64_uint64
argument_list|(
literal|0x24100
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|major_version
operator|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|major_version
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|major_version
operator|>
literal|3
operator|)
operator|||
operator|(
name|exact_match
operator|&&
name|major_version
operator|!=
name|exact_match
operator|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Incompatible bootmem descriptor version: %d.%d at addr: 0x%llx\n"
argument_list|,
name|major_version
argument_list|,
operator|(
name|int
operator|)
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|minor_version
argument_list|)
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_desc_addr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Get the low level bootmem descriptor lock. If no locking  * is specified in the flags, then nothing is done.  *  * @param flags  CVMX_BOOTMEM_FLAG_NO_LOCKING means this functions should do  *               nothing. This is used to support nested bootmem calls.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_bootmem_lock
parameter_list|(
name|uint32_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
comment|/* Unfortunately we can't use the normal cvmx-spinlock code as the             memory for the bootmem descriptor may be not accessable by a C             pointer. We use a 64bit XKPHYS address to access the memory             directly */
name|uint64_t
name|lock_addr
init|=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator||
operator|(
name|cvmx_bootmem_desc_addr
operator|+
name|offsetof
argument_list|(
name|cvmx_bootmem_desc_t
argument_list|,
name|lock
argument_list|)
operator|)
decl_stmt|;
name|unsigned
name|int
name|tmp
decl_stmt|;
asm|__asm__
specifier|__volatile__
asm|(         ".set noreorder         \n"         "1: ll   %[tmp], 0(%[addr])\n"         "   bnez %[tmp], 1b     \n"         "   li   %[tmp], 1      \n"         "   sc   %[tmp], 0(%[addr])\n"         "   beqz %[tmp], 1b     \n"         "   nop                \n"         ".set reorder           \n"         : [tmp] "=&r" (tmp)         : [addr] "r" (lock_addr)         : "memory");
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/**  * Release the low level bootmem descriptor lock. If no locking  * is specified in the flags, then nothing is done.  *  * @param flags  CVMX_BOOTMEM_FLAG_NO_LOCKING means this functions should do  *               nothing. This is used to support nested bootmem calls.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|__cvmx_bootmem_unlock
parameter_list|(
name|uint32_t
name|flags
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
comment|/* Unfortunately we can't use the normal cvmx-spinlock code as the             memory for the bootmem descriptor may be not accessable by a C             pointer. We use a 64bit XKPHYS address to access the memory             directly */
name|uint64_t
name|lock_addr
init|=
operator|(
literal|1ull
operator|<<
literal|63
operator|)
operator||
operator|(
name|cvmx_bootmem_desc_addr
operator|+
name|offsetof
argument_list|(
name|cvmx_bootmem_desc_t
argument_list|,
name|lock
argument_list|)
operator|)
decl_stmt|;
name|CVMX_SYNCW
expr_stmt|;
asm|__asm__
specifier|__volatile__
asm|("sw $0, 0(%[addr])\n"         :: [addr] "r" (lock_addr)         : "memory");
name|CVMX_SYNCW
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Some of the cvmx-bootmem functions dealing with C pointers are not supported     when we are compiling for CVMX_BUILD_FOR_LINUX_HOST. This ifndef removes     these functions when they aren't needed */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_comment
comment|/* This functions takes an address range and adjusts it as necessary to ** match the ABI that is currently being used.  This is required to ensure ** that bootmem_alloc* functions only return valid pointers for 32 bit ABIs */
end_comment

begin_function
specifier|static
name|int
name|__cvmx_validate_mem_range
parameter_list|(
name|uint64_t
modifier|*
name|min_addr_ptr
parameter_list|,
name|uint64_t
modifier|*
name|max_addr_ptr
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__linux__
argument_list|)
operator|&&
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
block|{
specifier|extern
name|uint64_t
name|linux_mem32_min
decl_stmt|;
specifier|extern
name|uint64_t
name|linux_mem32_max
decl_stmt|;
comment|/* For 32 bit Linux apps, we need to restrict the allocations to the range         ** of memory configured for access from userspace.  Also, we need to add mappings         ** for the data structures that we access.*/
comment|/* Narrow range requests to be bounded by the 32 bit limits.  octeon_phy_mem_block_alloc()         ** will reject inconsistent req_size/range requests, so we don't repeat those checks here.         ** If max unspecified, set to 32 bit maximum. */
operator|*
name|min_addr_ptr
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
operator|*
name|min_addr_ptr
argument_list|,
name|linux_mem32_min
argument_list|)
argument_list|,
name|linux_mem32_max
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|max_addr_ptr
condition|)
operator|*
name|max_addr_ptr
operator|=
name|linux_mem32_max
expr_stmt|;
else|else
operator|*
name|max_addr_ptr
operator|=
name|MAX
argument_list|(
name|MIN
argument_list|(
operator|*
name|max_addr_ptr
argument_list|,
name|linux_mem32_max
argument_list|)
argument_list|,
name|linux_mem32_min
argument_list|)
expr_stmt|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|CVMX_ABI_N32
argument_list|)
block|{
name|uint32_t
name|max_phys
init|=
literal|0x0FFFFFFF
decl_stmt|;
comment|/* Max physical address when 1-1 mappings not used */
if|#
directive|if
name|CVMX_USE_1_TO_1_TLB_MAPPINGS
name|max_phys
operator|=
literal|0x7FFFFFFF
expr_stmt|;
endif|#
directive|endif
comment|/* We are are running standalone simple executive, so we need to limit the range         ** that we allocate from */
comment|/* Narrow range requests to be bounded by the 32 bit limits.  octeon_phy_mem_block_alloc()         ** will reject inconsistent req_size/range requests, so we don't repeat those checks here.         ** If max unspecified, set to 32 bit maximum. */
operator|*
name|min_addr_ptr
operator|=
name|MIN
argument_list|(
name|MAX
argument_list|(
operator|*
name|min_addr_ptr
argument_list|,
literal|0x0
argument_list|)
argument_list|,
name|max_phys
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|max_addr_ptr
condition|)
operator|*
name|max_addr_ptr
operator|=
name|max_phys
expr_stmt|;
else|else
operator|*
name|max_addr_ptr
operator|=
name|MAX
argument_list|(
name|MIN
argument_list|(
operator|*
name|max_addr_ptr
argument_list|,
name|max_phys
argument_list|)
argument_list|,
literal|0x0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_range
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|uint64_t
name|min_addr
parameter_list|,
name|uint64_t
name|max_addr
parameter_list|)
block|{
name|int64_t
name|address
decl_stmt|;
name|__cvmx_validate_mem_range
argument_list|(
operator|&
name|min_addr
argument_list|,
operator|&
name|max_addr
argument_list|)
expr_stmt|;
name|address
operator|=
name|cvmx_bootmem_phy_alloc
argument_list|(
name|size
argument_list|,
name|min_addr
argument_list|,
name|max_addr
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|>
literal|0
condition|)
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|address
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_bootmem_alloc_range
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_address
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|address
parameter_list|,
name|uint64_t
name|alignment
parameter_list|)
block|{
return|return
name|cvmx_bootmem_alloc_range
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|,
name|address
argument_list|,
name|address
operator|+
name|size
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|)
block|{
return|return
name|cvmx_bootmem_alloc_range
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_bootmem_alloc
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_named_range
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|min_addr
parameter_list|,
name|uint64_t
name|max_addr
parameter_list|,
name|uint64_t
name|align
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int64_t
name|addr
decl_stmt|;
name|__cvmx_validate_mem_range
argument_list|(
operator|&
name|min_addr
argument_list|,
operator|&
name|max_addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_phy_named_block_alloc
argument_list|(
name|size
argument_list|,
name|min_addr
argument_list|,
name|max_addr
argument_list|,
name|align
argument_list|,
name|name
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0
condition|)
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|addr
argument_list|)
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_named_address
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|address
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_alloc_named_range
argument_list|(
name|size
argument_list|,
name|address
argument_list|,
name|address
operator|+
name|size
argument_list|,
literal|0
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|cvmx_bootmem_alloc_named
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_alloc_named_range
argument_list|(
name|size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|alignment
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|cvmx_bootmem_free_named
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_phy_named_block_free
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|const
name|cvmx_bootmem_named_block_desc_t
modifier|*
name|cvmx_bootmem_find_named_block
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* FIXME: Returning a single static object is probably a bad thing */
specifier|static
name|cvmx_bootmem_named_block_desc_t
name|desc
decl_stmt|;
name|uint64_t
name|named_addr
init|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|name
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|named_addr
condition|)
block|{
name|desc
operator|.
name|base_addr
operator|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_addr
argument_list|,
name|base_addr
argument_list|)
expr_stmt|;
name|desc
operator|.
name|size
operator|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|desc
operator|.
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|desc
operator|.
name|name
index|[
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|&
name|desc
return|;
block|}
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_print_named
parameter_list|(
name|void
parameter_list|)
block|{
name|cvmx_bootmem_phy_named_block_print
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|cvmx_bootmem_init
parameter_list|(
name|uint64_t
name|mem_desc_addr
parameter_list|)
block|{
comment|/* Verify that the size of cvmx_spinlock_t meets our assumptions */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|cvmx_spinlock_t
argument_list|)
operator|!=
literal|4
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Unexpected size of cvmx_spinlock_t\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|cvmx_bootmem_desc_addr
condition|)
name|cvmx_bootmem_desc_addr
operator|=
name|mem_desc_addr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_bootmem_available_mem
parameter_list|(
name|uint64_t
name|min_block_size
parameter_list|)
block|{
return|return
operator|(
name|cvmx_bootmem_phy_available_mem
argument_list|(
name|min_block_size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************************************************************* ** The cvmx_bootmem_phy* functions below return 64 bit physical addresses, ** and expose more features that the cvmx_bootmem_functions above.  These are ** required for full memory space access in 32 bit applications, as well as for ** using some advance features. ** Most applications should not need to use these. ** **/
end_comment

begin_function
name|int64_t
name|cvmx_bootmem_phy_alloc
parameter_list|(
name|uint64_t
name|req_size
parameter_list|,
name|uint64_t
name|address_min
parameter_list|,
name|uint64_t
name|address_max
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|head_addr
decl_stmt|;
name|uint64_t
name|ent_addr
decl_stmt|;
name|uint64_t
name|prev_addr
init|=
literal|0
decl_stmt|;
comment|/* points to previous list entry, NULL current entry is head of list */
name|uint64_t
name|new_ent_addr
init|=
literal|0
decl_stmt|;
name|uint64_t
name|desired_min_addr
decl_stmt|;
name|uint64_t
name|alignment_mask
init|=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_alloc: req_size: 0x%llx, min_addr: 0x%llx, max_addr: 0x%llx, align: 0x%llx\n"
argument_list|,
operator|(
name|ULL
operator|)
name|req_size
argument_list|,
operator|(
name|ULL
operator|)
name|address_min
argument_list|,
operator|(
name|ULL
operator|)
name|address_max
argument_list|,
operator|(
name|ULL
operator|)
name|alignment
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__cvmx_bootmem_check_version
argument_list|(
literal|0
argument_list|)
condition|)
goto|goto
name|error_out
goto|;
comment|/* Do a variety of checks to validate the arguments.  The allocator code will later assume     ** that these checks have been made.  We validate that the requested constraints are not     ** self-contradictory before we look through the list of available memory     */
comment|/* 0 is not a valid req_size for this allocator */
if|if
condition|(
operator|!
name|req_size
condition|)
goto|goto
name|error_out
goto|;
comment|/* Round req_size up to mult of minimum alignment bytes */
name|req_size
operator|=
operator|(
name|req_size
operator|+
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Convert !0 address_min and 0 address_max to special case of range that specifies an exact     ** memory block to allocate.  Do this before other checks and adjustments so that this tranformation will be validated */
if|if
condition|(
name|address_min
operator|&&
operator|!
name|address_max
condition|)
name|address_max
operator|=
name|address_min
operator|+
name|req_size
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|address_min
operator|&&
operator|!
name|address_max
condition|)
name|address_max
operator|=
operator|~
literal|0ull
expr_stmt|;
comment|/* If no limits given, use max limits */
comment|/* Enforce minimum alignment (this also keeps the minimum free block     ** req_size the same as the alignment req_size */
if|if
condition|(
name|alignment
operator|<
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
condition|)
block|{
name|alignment
operator|=
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
expr_stmt|;
block|}
name|alignment_mask
operator|=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Adjust address minimum based on requested alignment (round up to meet alignment).  Do this here so we can     ** reject impossible requests up front. (NOP for address_min == 0) */
if|if
condition|(
name|alignment
condition|)
name|address_min
operator|=
operator|(
name|address_min
operator|+
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Reject inconsistent args.  We have adjusted these, so this may fail due to our internal changes     ** even if this check would pass for the values the user supplied. */
if|if
condition|(
name|req_size
operator|>
name|address_max
operator|-
name|address_min
condition|)
goto|goto
name|error_out
goto|;
comment|/* Walk through the list entries - first fit found is returned */
name|__cvmx_bootmem_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|head_addr
operator|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|head_addr
argument_list|)
expr_stmt|;
name|ent_addr
operator|=
name|head_addr
expr_stmt|;
while|while
condition|(
name|ent_addr
condition|)
block|{
name|uint64_t
name|usable_base
decl_stmt|,
name|usable_max
decl_stmt|;
name|uint64_t
name|ent_size
init|=
name|cvmx_bootmem_phy_get_size
argument_list|(
name|ent_addr
argument_list|)
decl_stmt|;
if|if
condition|(
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
operator|&&
name|ent_addr
operator|>
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Internal bootmem_alloc() error: ent: 0x%llx, next: 0x%llx\n"
argument_list|,
operator|(
name|ULL
operator|)
name|ent_addr
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error_out
goto|;
block|}
comment|/* Determine if this is an entry that can satisify the request */
comment|/* Check to make sure entry is large enough to satisfy request */
name|usable_base
operator|=
name|ALIGN_ADDR_UP
argument_list|(
name|MAX
argument_list|(
name|address_min
argument_list|,
name|ent_addr
argument_list|)
argument_list|,
name|alignment_mask
argument_list|)
expr_stmt|;
name|usable_max
operator|=
name|MIN
argument_list|(
name|address_max
argument_list|,
name|ent_addr
operator|+
name|ent_size
argument_list|)
expr_stmt|;
comment|/* We should be able to allocate block at address usable_base */
name|desired_min_addr
operator|=
name|usable_base
expr_stmt|;
comment|/* Determine if request can be satisfied from the current entry */
if|if
condition|(
operator|(
operator|(
operator|(
name|ent_addr
operator|+
name|ent_size
operator|)
operator|>
name|usable_base
operator|&&
name|ent_addr
operator|<
name|address_max
operator|)
operator|)
operator|&&
name|req_size
operator|<=
name|usable_max
operator|-
name|usable_base
condition|)
block|{
comment|/* We have found an entry that has room to satisfy the request, so allocate it from this entry */
comment|/* If end CVMX_BOOTMEM_FLAG_END_ALLOC set, then allocate from the end of this block             ** rather than the beginning */
if|if
condition|(
name|flags
operator|&
name|CVMX_BOOTMEM_FLAG_END_ALLOC
condition|)
block|{
name|desired_min_addr
operator|=
name|usable_max
operator|-
name|req_size
expr_stmt|;
comment|/* Align desired address down to required alignment */
name|desired_min_addr
operator|&=
name|alignment_mask
expr_stmt|;
block|}
comment|/* Match at start of entry */
if|if
condition|(
name|desired_min_addr
operator|==
name|ent_addr
condition|)
block|{
if|if
condition|(
name|req_size
operator|<
name|ent_size
condition|)
block|{
comment|/* big enough to create a new block from top portion of block */
name|new_ent_addr
operator|=
name|ent_addr
operator|+
name|req_size
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|new_ent_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|new_ent_addr
argument_list|,
name|ent_size
operator|-
name|req_size
argument_list|)
expr_stmt|;
comment|/* Adjust next pointer as following code uses this */
name|cvmx_bootmem_phy_set_next
argument_list|(
name|ent_addr
argument_list|,
name|new_ent_addr
argument_list|)
expr_stmt|;
block|}
comment|/* adjust prev ptr or head to remove this entry from list */
if|if
condition|(
name|prev_addr
condition|)
block|{
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* head of list being returned, so update head ptr */
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|head_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|desired_min_addr
operator|)
return|;
block|}
comment|/* block returned doesn't start at beginning of entry, so we know             ** that we will be splitting a block off the front of this one.  Create a new block             ** from the beginning, add to list, and go to top of loop again.             **             ** create new block from high portion of block, so that top block             ** starts at desired addr             **/
name|new_ent_addr
operator|=
name|desired_min_addr
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|new_ent_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|new_ent_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|ent_addr
argument_list|)
operator|-
operator|(
name|desired_min_addr
operator|-
name|ent_addr
operator|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|ent_addr
argument_list|,
name|desired_min_addr
operator|-
name|ent_addr
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|ent_addr
argument_list|,
name|new_ent_addr
argument_list|)
expr_stmt|;
comment|/* Loop again to handle actual alloc from new block */
block|}
name|prev_addr
operator|=
name|ent_addr
expr_stmt|;
name|ent_addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|ent_addr
argument_list|)
expr_stmt|;
block|}
name|error_out
label|:
comment|/* We didn't find anything, so return error */
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__cvmx_bootmem_phy_free
parameter_list|(
name|uint64_t
name|phy_addr
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|cur_addr
decl_stmt|;
name|uint64_t
name|prev_addr
init|=
literal|0
decl_stmt|;
comment|/* zero is invalid */
name|int
name|retval
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"__cvmx_bootmem_phy_free addr: 0x%llx, size: 0x%llx\n"
argument_list|,
operator|(
name|ULL
operator|)
name|phy_addr
argument_list|,
operator|(
name|ULL
operator|)
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__cvmx_bootmem_check_version
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 0 is not a valid size for this allocator */
if|if
condition|(
operator|!
name|size
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|__cvmx_bootmem_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|cur_addr
operator|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|head_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur_addr
operator|==
literal|0
operator|||
name|phy_addr
operator|<
name|cur_addr
condition|)
block|{
comment|/* add at front of list - special case with changing head ptr */
if|if
condition|(
name|cur_addr
operator|&&
name|phy_addr
operator|+
name|size
operator|>
name|cur_addr
condition|)
goto|goto
name|bootmem_free_done
goto|;
comment|/* error, overlapping section */
elseif|else
if|if
condition|(
name|phy_addr
operator|+
name|size
operator|==
name|cur_addr
condition|)
block|{
comment|/* Add to front of existing first block */
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|cur_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|head_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* New block before first block */
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
comment|/* OK if cur_addr is 0 */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|head_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
comment|/* Find place in list to add block */
while|while
condition|(
name|cur_addr
operator|&&
name|phy_addr
operator|>
name|cur_addr
condition|)
block|{
name|prev_addr
operator|=
name|cur_addr
expr_stmt|;
name|cur_addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|cur_addr
condition|)
block|{
comment|/* We have reached the end of the list, add on to end, checking         ** to see if we need to combine with last block         **/
if|if
condition|(
name|prev_addr
operator|+
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|==
name|phy_addr
condition|)
block|{
name|cvmx_bootmem_phy_set_size
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
else|else
block|{
comment|/* insert between prev and cur nodes, checking for merge with either/both */
if|if
condition|(
name|prev_addr
operator|+
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|==
name|phy_addr
condition|)
block|{
comment|/* Merge with previous */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_addr
operator|+
name|size
operator|==
name|cur_addr
condition|)
block|{
comment|/* Also merge with current */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|cur_addr
argument_list|)
operator|+
name|cvmx_bootmem_phy_get_size
argument_list|(
name|prev_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
elseif|else
if|if
condition|(
name|phy_addr
operator|+
name|size
operator|==
name|cur_addr
condition|)
block|{
comment|/* Merge with current */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_size
argument_list|(
name|cur_addr
argument_list|)
operator|+
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cvmx_bootmem_phy_get_next
argument_list|(
name|cur_addr
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|1
expr_stmt|;
goto|goto
name|bootmem_free_done
goto|;
block|}
comment|/* It is a standalone block, add in between prev and cur */
name|cvmx_bootmem_phy_set_size
argument_list|(
name|phy_addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|phy_addr
argument_list|,
name|cur_addr
argument_list|)
expr_stmt|;
name|cvmx_bootmem_phy_set_next
argument_list|(
name|prev_addr
argument_list|,
name|phy_addr
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
name|bootmem_free_done
label|:
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_phy_list_print
parameter_list|(
name|void
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|addr
operator|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|head_addr
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\n\n\nPrinting bootmem block list, descriptor: 0x%llx,  head is 0x%llx\n"
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_desc_addr
argument_list|,
operator|(
name|ULL
operator|)
name|addr
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Descriptor version: %d.%d\n"
argument_list|,
operator|(
name|int
operator|)
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|major_version
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|minor_version
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|major_version
argument_list|)
operator|>
literal|3
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Warning: Bootmem descriptor version is newer than expected\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"mem list is empty!\n"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Block address: 0x%08qx, size: 0x%08qx, next: 0x%08qx\n"
argument_list|,
operator|(
name|ULL
operator|)
name|addr
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_phy_get_size
argument_list|(
name|addr
argument_list|)
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_phy_get_next
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|cvmx_dprintf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_bootmem_phy_available_mem
parameter_list|(
name|uint64_t
name|min_block_size
parameter_list|)
block|{
name|uint64_t
name|addr
decl_stmt|;
name|uint64_t
name|available_mem
init|=
literal|0
decl_stmt|;
name|__cvmx_bootmem_lock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|head_addr
argument_list|)
expr_stmt|;
while|while
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|cvmx_bootmem_phy_get_size
argument_list|(
name|addr
argument_list|)
operator|>=
name|min_block_size
condition|)
name|available_mem
operator|+=
name|cvmx_bootmem_phy_get_size
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|addr
operator|=
name|cvmx_bootmem_phy_get_next
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
name|__cvmx_bootmem_unlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|available_mem
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|cvmx_bootmem_phy_named_block_find
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|result
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_find: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|__cvmx_bootmem_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__cvmx_bootmem_check_version
argument_list|(
literal|3
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|named_block_array_addr
init|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_array_addr
argument_list|)
decl_stmt|;
name|int
name|num_blocks
init|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_num_blocks
argument_list|)
decl_stmt|;
name|int
name|name_length
init|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_name_len
argument_list|)
decl_stmt|;
name|uint64_t
name|named_addr
init|=
name|named_block_array_addr
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|named_size
init|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_addr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|name
operator|&&
name|named_size
condition|)
block|{
name|char
name|name_tmp
index|[
name|name_length
index|]
decl_stmt|;
name|CVMX_BOOTMEM_NAMED_GET_NAME
argument_list|(
name|named_addr
argument_list|,
name|name_tmp
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|name
argument_list|,
name|name_tmp
argument_list|,
name|name_length
operator|-
literal|1
argument_list|)
condition|)
block|{
name|result
operator|=
name|named_addr
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|name
operator|&&
operator|!
name|named_size
condition|)
block|{
name|result
operator|=
name|named_addr
expr_stmt|;
break|break;
block|}
name|named_addr
operator|+=
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
expr_stmt|;
block|}
block|}
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|int
name|cvmx_bootmem_phy_named_block_free
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|uint64_t
name|named_block_addr
decl_stmt|;
if|if
condition|(
name|__cvmx_bootmem_check_version
argument_list|(
literal|3
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_free: %s\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Take lock here, as name lookup/block free/name free need to be atomic */
name|__cvmx_bootmem_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|named_block_addr
operator|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|name
argument_list|,
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|named_block_addr
condition|)
block|{
name|uint64_t
name|named_addr
init|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_block_addr
argument_list|,
name|base_addr
argument_list|)
decl_stmt|;
name|uint64_t
name|named_size
init|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_block_addr
argument_list|,
name|size
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_free: %s, base: 0x%llx, size: 0x%llx\n"
argument_list|,
name|name
argument_list|,
operator|(
name|ULL
operator|)
name|named_addr
argument_list|,
operator|(
name|ULL
operator|)
name|named_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|__cvmx_bootmem_phy_free
argument_list|(
name|named_addr
argument_list|,
name|named_size
argument_list|,
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
comment|/* Set size to zero to indicate block not used. */
name|CVMX_BOOTMEM_NAMED_SET_FIELD
argument_list|(
name|named_block_addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|!
operator|!
name|named_block_addr
operator|)
return|;
comment|/* 0 on failure, 1 on success */
block|}
end_function

begin_function
name|int64_t
name|cvmx_bootmem_phy_named_block_alloc
parameter_list|(
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|min_addr
parameter_list|,
name|uint64_t
name|max_addr
parameter_list|,
name|uint64_t
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
block|{
name|int64_t
name|addr_allocated
decl_stmt|;
name|uint64_t
name|named_block_desc_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_alloc: size: 0x%llx, min: 0x%llx, max: 0x%llx, align: 0x%llx, name: %s\n"
argument_list|,
operator|(
name|ULL
operator|)
name|size
argument_list|,
operator|(
name|ULL
operator|)
name|min_addr
argument_list|,
operator|(
name|ULL
operator|)
name|max_addr
argument_list|,
operator|(
name|ULL
operator|)
name|alignment
argument_list|,
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__cvmx_bootmem_check_version
argument_list|(
literal|3
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Take lock here, as name lookup/block alloc/name add need to be atomic */
name|__cvmx_bootmem_lock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
name|named_block_desc_addr
operator|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|name
argument_list|,
name|flags
operator||
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|named_block_desc_addr
condition|)
block|{
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Get pointer to first available named block descriptor */
name|named_block_desc_addr
operator|=
name|cvmx_bootmem_phy_named_block_find
argument_list|(
name|NULL
argument_list|,
name|flags
operator||
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|named_block_desc_addr
condition|)
block|{
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Round size up to mult of minimum alignment bytes     ** We need the actual size allocated to allow for blocks to be coallesced     ** when they are freed.  The alloc routine does the same rounding up     ** on all allocations. */
name|size
operator|=
operator|(
name|size
operator|+
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
operator|)
operator|&
operator|~
operator|(
name|CVMX_BOOTMEM_ALIGNMENT_SIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|addr_allocated
operator|=
name|cvmx_bootmem_phy_alloc
argument_list|(
name|size
argument_list|,
name|min_addr
argument_list|,
name|max_addr
argument_list|,
name|alignment
argument_list|,
name|flags
operator||
name|CVMX_BOOTMEM_FLAG_NO_LOCKING
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr_allocated
operator|>=
literal|0
condition|)
block|{
name|CVMX_BOOTMEM_NAMED_SET_FIELD
argument_list|(
name|named_block_desc_addr
argument_list|,
name|base_addr
argument_list|,
name|addr_allocated
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_NAMED_SET_FIELD
argument_list|(
name|named_block_desc_addr
argument_list|,
name|size
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_NAMED_SET_NAME
argument_list|(
name|named_block_desc_addr
argument_list|,
name|name
argument_list|,
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_name_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|__cvmx_bootmem_unlock
argument_list|(
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|addr_allocated
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_phy_named_block_print
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|printed
init|=
literal|0
decl_stmt|;
name|uint64_t
name|named_block_array_addr
init|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_array_addr
argument_list|)
decl_stmt|;
name|int
name|num_blocks
init|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_num_blocks
argument_list|)
decl_stmt|;
name|int
name|name_length
init|=
name|CVMX_BOOTMEM_DESC_GET_FIELD
argument_list|(
name|named_block_name_len
argument_list|)
decl_stmt|;
name|uint64_t
name|named_block_addr
init|=
name|named_block_array_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_named_block_print, desc addr: 0x%llx\n"
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_desc_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|__cvmx_bootmem_check_version
argument_list|(
literal|3
argument_list|)
condition|)
return|return;
name|cvmx_dprintf
argument_list|(
literal|"List of currently allocated named bootmem blocks:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_blocks
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|named_size
init|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_block_addr
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|named_size
condition|)
block|{
name|char
name|name_tmp
index|[
name|name_length
index|]
decl_stmt|;
name|uint64_t
name|named_addr
init|=
name|CVMX_BOOTMEM_NAMED_GET_FIELD
argument_list|(
name|named_block_addr
argument_list|,
name|base_addr
argument_list|)
decl_stmt|;
name|CVMX_BOOTMEM_NAMED_GET_NAME
argument_list|(
name|named_block_addr
argument_list|,
name|name_tmp
argument_list|,
name|name_length
argument_list|)
expr_stmt|;
name|printed
operator|++
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"Name: %s, address: 0x%08qx, size: 0x%08qx, index: %d\n"
argument_list|,
name|name_tmp
argument_list|,
operator|(
name|ULL
operator|)
name|named_addr
argument_list|,
operator|(
name|ULL
operator|)
name|named_size
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|named_block_addr
operator|+=
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|printed
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"No named bootmem blocks exist.\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Real physical addresses of memory regions */
end_comment

begin_define
define|#
directive|define
name|OCTEON_DDR0_BASE
value|(0x0ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR0_SIZE
value|(0x010000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR1_BASE
value|(OCTEON_IS_MODEL(OCTEON_CN6XXX) ? 0x20000000ULL : 0x410000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR1_SIZE
value|(0x010000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR2_BASE
value|(OCTEON_IS_MODEL(OCTEON_CN6XXX) ? 0x30000000ULL : 0x20000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_DDR2_SIZE
value|(OCTEON_IS_MODEL(OCTEON_CN6XXX) ? 0x7d0000000ULL : 0x3e0000000ULL)
end_define

begin_define
define|#
directive|define
name|OCTEON_MAX_PHY_MEM_SIZE
value|(OCTEON_IS_MODEL(OCTEON_CN63XX) ? 32*1024*1024*1024ULL : 16*1024*1024*1024ULL)
end_define

begin_function
name|int64_t
name|cvmx_bootmem_phy_mem_list_init
parameter_list|(
name|uint64_t
name|mem_size
parameter_list|,
name|uint32_t
name|low_reserved_bytes
parameter_list|,
name|cvmx_bootmem_desc_t
modifier|*
name|desc_buffer
parameter_list|)
block|{
name|uint64_t
name|cur_block_addr
decl_stmt|;
name|int64_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_mem_list_init (arg desc ptr: %p, cvmx_bootmem_desc: 0x%llx)\n"
argument_list|,
name|desc_buffer
argument_list|,
operator|(
name|ULL
operator|)
name|cvmx_bootmem_desc_addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Descriptor buffer needs to be in 32 bit addressable space to be compatible with     ** 32 bit applications */
if|if
condition|(
operator|!
name|desc_buffer
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: no memory for cvmx_bootmem descriptor provided\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mem_size
operator|>
name|OCTEON_MAX_PHY_MEM_SIZE
condition|)
block|{
name|mem_size
operator|=
name|OCTEON_MAX_PHY_MEM_SIZE
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: requested memory size too large, truncating to maximum size\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cvmx_bootmem_desc_addr
condition|)
return|return
literal|1
return|;
comment|/* Initialize cvmx pointer to descriptor */
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
name|cvmx_bootmem_init
argument_list|(
name|cvmx_ptr_to_phys
argument_list|(
name|desc_buffer
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|cvmx_bootmem_init
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|desc_buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Fill the bootmem descriptor */
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|lock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|head_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|major_version
argument_list|,
name|CVMX_BOOTMEM_DESC_MAJ_VER
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|minor_version
argument_list|,
name|CVMX_BOOTMEM_DESC_MIN_VER
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|app_data_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|app_data_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Set up global pointer to start of list, exclude low 64k for exception vectors, space for global descriptor */
name|cur_block_addr
operator|=
operator|(
name|OCTEON_DDR0_BASE
operator|+
name|low_reserved_bytes
operator|)
expr_stmt|;
if|if
condition|(
name|mem_size
operator|<=
name|OCTEON_DDR0_SIZE
condition|)
block|{
name|__cvmx_bootmem_phy_free
argument_list|(
name|cur_block_addr
argument_list|,
name|mem_size
operator|-
name|low_reserved_bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|frees_done
goto|;
block|}
name|__cvmx_bootmem_phy_free
argument_list|(
name|cur_block_addr
argument_list|,
name|OCTEON_DDR0_SIZE
operator|-
name|low_reserved_bytes
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mem_size
operator|-=
name|OCTEON_DDR0_SIZE
expr_stmt|;
comment|/* Add DDR2 block next if present */
if|if
condition|(
name|mem_size
operator|>
name|OCTEON_DDR1_SIZE
condition|)
block|{
name|__cvmx_bootmem_phy_free
argument_list|(
name|OCTEON_DDR1_BASE
argument_list|,
name|OCTEON_DDR1_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__cvmx_bootmem_phy_free
argument_list|(
name|OCTEON_DDR2_BASE
argument_list|,
name|mem_size
operator|-
name|OCTEON_DDR1_SIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|__cvmx_bootmem_phy_free
argument_list|(
name|OCTEON_DDR1_BASE
argument_list|,
name|mem_size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|frees_done
label|:
comment|/* Initialize the named block structure */
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|named_block_name_len
argument_list|,
name|CVMX_BOOTMEM_NAME_LEN
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|named_block_num_blocks
argument_list|,
name|CVMX_BOOTMEM_NUM_NAMED_BLOCKS
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|named_block_array_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Allocate this near the top of the low 256 MBytes of memory */
name|addr
operator|=
name|cvmx_bootmem_phy_alloc
argument_list|(
name|CVMX_BOOTMEM_NUM_NAMED_BLOCKS
operator|*
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0x10000000
argument_list|,
literal|0
argument_list|,
name|CVMX_BOOTMEM_FLAG_END_ALLOC
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|>=
literal|0
condition|)
name|CVMX_BOOTMEM_DESC_SET_FIELD
argument_list|(
name|named_block_array_addr
argument_list|,
name|addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|cvmx_dprintf
argument_list|(
literal|"cvmx_bootmem_phy_mem_list_init: named_block_array_addr: 0x%llx)\n"
argument_list|,
operator|(
name|ULL
operator|)
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"FATAL ERROR: unable to allocate memory for bootmem descriptor!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CVMX_BOOTMEM_NUM_NAMED_BLOCKS
condition|;
name|i
operator|++
control|)
block|{
name|CVMX_BOOTMEM_NAMED_SET_FIELD
argument_list|(
name|addr
argument_list|,
name|base_addr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CVMX_BOOTMEM_NAMED_SET_FIELD
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addr
operator|+=
sizeof|sizeof
argument_list|(
name|cvmx_bootmem_named_block_desc_t
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_lock
parameter_list|(
name|void
parameter_list|)
block|{
name|__cvmx_bootmem_lock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cvmx_bootmem_unlock
parameter_list|(
name|void
parameter_list|)
block|{
name|__cvmx_bootmem_unlock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CVMX_BUILD_FOR_LINUX_HOST
end_ifndef

begin_function
name|void
modifier|*
name|__cvmx_bootmem_internal_get_desc_ptr
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|cvmx_phys_to_ptr
argument_list|(
name|cvmx_bootmem_desc_addr
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

