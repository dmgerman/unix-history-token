begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2011  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Helper functions to abstract board specific data about  * network ports from the rest of the cvmx-helper files.  *  *<hr>$Revision: 70030 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-smix-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-asxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-mdio.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-util.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-twsi.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-app-init.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-twsi.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-mdio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-util.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-gpio.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__U_BOOT__
end_ifdef

begin_include
include|#
directive|include
file|<libfdt.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"libfdt/libfdt.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"cvmx-swap.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_override_board_link_get(int ipd_port) is a function  * pointer. It is meant to allow customization of the process of  * talking to a PHY to determine link speed. It is called every  * time a PHY must be polled for link status. Users should set  * this pointer to a function before calling any cvmx-helper  * operations.  */
end_comment

begin_function_decl
name|CVMX_SHARED
name|cvmx_helper_link_info_t
function_decl|(
modifier|*
name|cvmx_override_board_link_get
function_decl|)
parameter_list|(
name|int
name|ipd_port
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
end_if

begin_function
specifier|static
name|void
name|cvmx_retry_i2c_write
parameter_list|(
name|int
name|twsi_id
parameter_list|,
name|uint8_t
name|dev_addr
parameter_list|,
name|uint16_t
name|internal_addr
parameter_list|,
name|int
name|num_bytes
parameter_list|,
name|int
name|ia_width_bytes
parameter_list|,
name|uint64_t
name|data
parameter_list|)
block|{
name|int
name|tries
init|=
literal|3
decl_stmt|;
name|int
name|r
decl_stmt|;
do|do
block|{
name|r
operator|=
name|cvmx_twsix_write_ia
argument_list|(
name|twsi_id
argument_list|,
name|dev_addr
argument_list|,
name|internal_addr
argument_list|,
name|num_bytes
argument_list|,
name|ia_width_bytes
argument_list|,
name|data
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tries
operator|--
operator|>
literal|0
operator|&&
name|r
operator|<
literal|0
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|__pip_eth_node
parameter_list|(
specifier|const
name|void
modifier|*
name|fdt_addr
parameter_list|,
name|int
name|aliases
parameter_list|,
name|int
name|ipd_port
parameter_list|)
block|{
name|char
name|name_buffer
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pip_path
decl_stmt|;
name|int
name|pip
decl_stmt|,
name|iface
decl_stmt|,
name|eth
decl_stmt|;
name|int
name|interface_num
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|interface_index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|pip_path
operator|=
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|aliases
argument_list|,
literal|"pip"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pip_path
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: pip path not found in device tree\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|pip
operator|=
name|fdt_path_offset
argument_list|(
name|fdt_addr
argument_list|,
name|pip_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|pip
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: pip not found in device tree\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|__U_BOOT__
name|sprintf
argument_list|(
name|name_buffer
argument_list|,
literal|"interface@%d"
argument_list|,
name|interface_num
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|name_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|name_buffer
argument_list|)
argument_list|,
literal|"interface@%d"
argument_list|,
name|interface_num
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|iface
operator|=
name|fdt_subnode_offset
argument_list|(
name|fdt_addr
argument_list|,
name|pip
argument_list|,
name|name_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|iface
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : pip intf %d not found in device tree \n"
argument_list|,
name|interface_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
ifdef|#
directive|ifdef
name|__U_BOOT__
name|sprintf
argument_list|(
name|name_buffer
argument_list|,
literal|"ethernet@%x"
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|name_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|name_buffer
argument_list|)
argument_list|,
literal|"ethernet@%x"
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|eth
operator|=
name|fdt_subnode_offset
argument_list|(
name|fdt_addr
argument_list|,
name|iface
argument_list|,
name|name_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|eth
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : pip interface@%d ethernet@%d not found in device "
literal|"tree\n"
argument_list|,
name|interface_num
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|eth
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__mix_eth_node
parameter_list|(
specifier|const
name|void
modifier|*
name|fdt_addr
parameter_list|,
name|int
name|aliases
parameter_list|,
name|int
name|interface_index
parameter_list|)
block|{
name|char
name|name_buffer
index|[
literal|20
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|mix_path
decl_stmt|;
name|int
name|mix
decl_stmt|;
ifdef|#
directive|ifdef
name|__U_BOOT__
name|sprintf
argument_list|(
name|name_buffer
argument_list|,
literal|"mix%d"
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
else|#
directive|else
name|snprintf
argument_list|(
name|name_buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|name_buffer
argument_list|)
argument_list|,
literal|"mix%d"
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mix_path
operator|=
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|aliases
argument_list|,
name|name_buffer
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mix_path
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: mix%d path not found in device tree\n"
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
block|}
name|mix
operator|=
name|fdt_path_offset
argument_list|(
name|fdt_addr
argument_list|,
name|mix_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mix
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR: %s not found in device tree\n"
argument_list|,
name|mix_path
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
name|mix
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|cvmx_phy_info
block|{
name|int
name|phy_addr
decl_stmt|;
name|int
name|direct_connect
decl_stmt|;
name|cvmx_phy_type_t
name|phy_type
decl_stmt|;
block|}
name|cvmx_phy_info_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|__mdiobus_addr_to_unit
parameter_list|(
name|uint32_t
name|addr
parameter_list|)
block|{
name|int
name|unit
init|=
operator|(
name|addr
operator|>>
literal|7
operator|)
operator|&
literal|3
decl_stmt|;
if|if
condition|(
operator|!
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
condition|)
name|unit
operator|>>=
literal|1
expr_stmt|;
return|return
name|unit
return|;
block|}
end_function

begin_comment
comment|/**  * Return the MII PHY address associated with the given IPD  * port. The phy address is obtained from the device tree.  *  * @param ipd_port Octeon IPD port to get the MII address for.  *  * @return MII PHY address and bus number or -1.  */
end_comment

begin_function
specifier|static
name|cvmx_phy_info_t
name|__get_phy_info_from_dt
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|fdt_addr
init|=
name|CASTPTR
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|fdt_addr
argument_list|)
decl_stmt|;
name|uint32_t
modifier|*
name|phy_handle
decl_stmt|;
name|int
name|aliases
decl_stmt|,
name|eth
decl_stmt|,
name|phy
decl_stmt|,
name|phy_parent
decl_stmt|,
name|phandle
decl_stmt|,
name|ret
decl_stmt|;
name|cvmx_phy_info_t
name|phy_info
decl_stmt|;
name|int
name|mdio_unit
init|=
operator|-
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|phy_comaptible_str
decl_stmt|;
name|uint32_t
modifier|*
name|phy_addr_ptr
decl_stmt|;
name|phy_info
operator|.
name|phy_addr
operator|=
operator|-
literal|1
expr_stmt|;
name|phy_info
operator|.
name|direct_connect
operator|=
operator|-
literal|1
expr_stmt|;
name|phy_info
operator|.
name|phy_type
operator|=
operator|(
name|cvmx_phy_type_t
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|fdt_addr
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"No device tree found.\n"
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
name|aliases
operator|=
name|fdt_path_offset
argument_list|(
name|fdt_addr
argument_list|,
literal|"/aliases"
argument_list|)
expr_stmt|;
if|if
condition|(
name|aliases
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"Error: No /aliases node in device tree.\n"
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
if|if
condition|(
name|ipd_port
operator|<
literal|0
condition|)
block|{
name|int
name|interface_index
init|=
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
decl_stmt|;
name|eth
operator|=
name|__mix_eth_node
argument_list|(
name|fdt_addr
argument_list|,
name|aliases
argument_list|,
name|interface_index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eth
operator|=
name|__pip_eth_node
argument_list|(
name|fdt_addr
argument_list|,
name|aliases
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eth
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : cannot find interface for ipd_port=%d\n"
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
comment|/* Get handle to phy */
name|phy_handle
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|eth
argument_list|,
literal|"phy-handle"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phy_handle
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : phy handle not found in device tree ipd_port=%d"
literal|"\n"
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
name|phandle
operator|=
name|cvmx_be32_to_cpu
argument_list|(
operator|*
name|phy_handle
argument_list|)
expr_stmt|;
name|phy
operator|=
name|fdt_node_offset_by_phandle
argument_list|(
name|fdt_addr
argument_list|,
name|phandle
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : cannot find phy for ipd_port=%d ret=%d\n"
argument_list|,
name|ipd_port
argument_list|,
name|phy
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
name|phy_comaptible_str
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|phy
argument_list|,
literal|"compatible"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|phy_comaptible_str
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : no compatible prop in phy\n"
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
if|if
condition|(
name|memcmp
argument_list|(
literal|"marvell"
argument_list|,
name|phy_comaptible_str
argument_list|,
name|strlen
argument_list|(
literal|"marvell"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|phy_info
operator|.
name|phy_type
operator|=
name|MARVELL_GENERIC_PHY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
literal|"broadcom"
argument_list|,
name|phy_comaptible_str
argument_list|,
name|strlen
argument_list|(
literal|"broadcom"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|phy_info
operator|.
name|phy_type
operator|=
name|BROADCOM_GENERIC_PHY
expr_stmt|;
block|}
else|else
block|{
name|phy_info
operator|.
name|phy_type
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Check if PHY parent is the octeon MDIO bus. Some boards are connected        though a MUX and for them direct_connect_to_phy will be 0 */
name|phy_parent
operator|=
name|fdt_parent_offset
argument_list|(
name|fdt_addr
argument_list|,
name|phy
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_parent
operator|<
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : cannot find phy parent for ipd_port=%d ret=%d\n"
argument_list|,
name|ipd_port
argument_list|,
name|phy_parent
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
name|ret
operator|=
name|fdt_node_check_compatible
argument_list|(
name|fdt_addr
argument_list|,
name|phy_parent
argument_list|,
literal|"cavium,octeon-3860-mdio"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|phy_info
operator|.
name|direct_connect
operator|=
literal|1
expr_stmt|;
name|uint32_t
modifier|*
name|mdio_reg_base
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|phy_parent
argument_list|,
literal|"reg"
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mdio_reg_base
operator|==
literal|0
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : unable to get reg property in phy mdio\n"
argument_list|)
expr_stmt|;
return|return
name|phy_info
return|;
block|}
name|mdio_unit
operator|=
name|__mdiobus_addr_to_unit
argument_list|(
name|mdio_reg_base
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|//cvmx_dprintf("phy parent=%s reg_base=%08x unit=%d \n",
comment|//             fdt_get_name(fdt_addr,phy_parent, NULL), mdio_reg_base[1], mdio_unit);
block|}
else|else
block|{
name|phy_info
operator|.
name|direct_connect
operator|=
literal|0
expr_stmt|;
comment|/* The PHY is not directly connected to the Octeon MDIO bus.            SE doesn't  have abstractions for MDIO MUX or MDIO MUX drivers and            hence for the non direct cases code will be needed which is            board specific.            For now the the MDIO Unit is defaulted to 1.         */
name|mdio_unit
operator|=
literal|1
expr_stmt|;
block|}
name|phy_addr_ptr
operator|=
operator|(
name|uint32_t
operator|*
operator|)
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|phy
argument_list|,
literal|"reg"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|phy_info
operator|.
name|phy_addr
operator|=
name|cvmx_be32_to_cpu
argument_list|(
operator|*
name|phy_addr_ptr
argument_list|)
operator||
name|mdio_unit
operator|<<
literal|8
expr_stmt|;
return|return
name|phy_info
return|;
block|}
end_function

begin_comment
comment|/**  * Return the MII PHY address associated with the given IPD  * port. The phy address is obtained from the device tree.  *  * @param ipd_port Octeon IPD port to get the MII address for.  *  * @return MII PHY address and bus number or -1.  */
end_comment

begin_function
name|int
name|cvmx_helper_board_get_mii_address_from_dt
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_phy_info_t
name|phy_info
init|=
name|__get_phy_info_from_dt
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
return|return
name|phy_info
operator|.
name|phy_addr
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * Return the MII PHY address associated with the given IPD  * port. A result of -1 means there isn't a MII capable PHY  * connected to this port. On chips supporting multiple MII  * busses the bus number is encoded in bits<15:8>.  *  * This function must be modified for every new Octeon board.  * Internally it uses switch statements based on the cvmx_sysinfo  * data to determine board types and revisions. It replies on the  * fact that every Octeon board receives a unique board type  * enumeration from the bootloader.  *  * @param ipd_port Octeon IPD port to get the MII address for.  *  * @return MII PHY address and bus number or -1.  */
end_comment

begin_function
name|int
name|cvmx_helper_board_get_mii_address
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
comment|/*      * Board types we have to know at compile-time.      */
ifdef|#
directive|ifdef
name|OCTEON_BOARD_CAPK_0100ND
switch|switch
condition|(
name|ipd_port
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|2
return|;
case|case
literal|1
case|:
return|return
literal|3
return|;
case|case
literal|2
case|:
comment|/* XXX Switch PHY?  */
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/*      * For board types we can determine at runtime.      */
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
return|return
operator|-
literal|1
return|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|fdt_addr
condition|)
block|{
name|cvmx_phy_info_t
name|phy_info
init|=
name|__get_phy_info_from_dt
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
comment|//cvmx_dprintf("ipd_port=%d phy_addr=%d\n", ipd_port, phy_info.phy_addr);
if|if
condition|(
name|phy_info
operator|.
name|phy_addr
operator|>=
literal|0
condition|)
return|return
name|phy_info
operator|.
name|phy_addr
return|;
block|}
endif|#
directive|endif
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_SIM
case|:
comment|/* Simulator doesn't have MII */
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBT3000
case|:
case|case
name|CVMX_BOARD_TYPE_EBT5800
case|:
case|case
name|CVMX_BOARD_TYPE_THUNDER
case|:
case|case
name|CVMX_BOARD_TYPE_NICPRO2
case|:
comment|/* Interface 0 is SPI4, interface 1 is RGMII */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
return|return
literal|0x1c
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_KODAMA
case|:
case|case
name|CVMX_BOARD_TYPE_EBH3100
case|:
case|case
name|CVMX_BOARD_TYPE_HIKARI
case|:
case|case
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3020_EVB_HS5
case|:
comment|/* Port 0 is WAN connected to a PHY, Port 1 is GMII connected to a                 switch */
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|==
literal|1
condition|)
return|return
literal|9
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBH3000
case|:
comment|/* Board has dual SPI4 and no PHYs */
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBT5810
case|:
comment|/* Board has 10g PHYs hooked up to the MII controller on the             ** IXF18201 MAC.  The 10G PHYS use clause 45 MDIO which the CN58XX             ** does not support. All MII accesses go through the IXF part. */
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBH5200
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5201
case|:
case|case
name|CVMX_BOARD_TYPE_EBT5200
case|:
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
return|;
comment|/* Board has 4 SGMII ports. The PHYs start right after the MII                 ports MII0 = 0, MII1 = 1, SGMII = 2-5 */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|2
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBH5600
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5601
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5610
case|:
comment|/* Board has 1 management port */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|0
return|;
comment|/* Board has 8 SGMII ports. 4 connect out, two connect to a switch,                 and 2 loop to each other */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBB5600
case|:
block|{
specifier|static
name|unsigned
name|char
name|qlm_switch_addr
init|=
literal|0
decl_stmt|;
comment|/* Board has 1 management port */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|0
return|;
comment|/* Board has 8 SGMII ports. 4 connected QLM1, 4 connected QLM3 */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|0x3
condition|)
block|{
name|qlm_switch_addr
operator|=
literal|0x3
expr_stmt|;
comment|/* QLM1 */
name|cvmx_twsix_write_ia
argument_list|(
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qlm_switch_addr
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|11000
argument_list|)
expr_stmt|;
comment|/* Let the write complete */
block|}
return|return
name|ipd_port
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|0xC
condition|)
block|{
name|qlm_switch_addr
operator|=
literal|0xC
expr_stmt|;
comment|/* QLM3 */
name|cvmx_twsix_write_ia
argument_list|(
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qlm_switch_addr
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|11000
argument_list|)
expr_stmt|;
comment|/* Let the write complete */
block|}
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
case|case
name|CVMX_BOARD_TYPE_EBB6300
case|:
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|4
return|;
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBB6800
case|:
comment|/* Board has 1 management ports */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|6
return|;
if|if
condition|(
name|ipd_port
operator|>=
literal|0x800
operator|&&
name|ipd_port
operator|<
literal|0x900
condition|)
comment|/* QLM 0*/
return|return
literal|0x101
operator|+
operator|(
operator|(
name|ipd_port
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
return|;
comment|/* SMI 1*/
if|if
condition|(
name|ipd_port
operator|>=
literal|0xa00
operator|&&
name|ipd_port
operator|<
literal|0xb00
condition|)
comment|/* QLM 2*/
return|return
literal|0x201
operator|+
operator|(
operator|(
name|ipd_port
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
return|;
comment|/* SMI 2*/
if|if
condition|(
name|ipd_port
operator|>=
literal|0xb00
operator|&&
name|ipd_port
operator|<
literal|0xc00
condition|)
comment|/* QLM 3*/
return|return
literal|0x301
operator|+
operator|(
operator|(
name|ipd_port
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
return|;
comment|/* SMI 3*/
if|if
condition|(
name|ipd_port
operator|>=
literal|0xc00
operator|&&
name|ipd_port
operator|<
literal|0xd00
condition|)
comment|/* QLM 4*/
return|return
literal|0x001
operator|+
operator|(
operator|(
name|ipd_port
operator|>>
literal|4
operator|)
operator|&
literal|3
operator|)
return|;
comment|/* SMI 0*/
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EP6300C
case|:
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|0x01
return|;
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|1
condition|)
return|return
literal|0x02
return|;
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
block|{
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|mode
init|=
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|CVMX_HELPER_INTERFACE_MODE_XAUI
condition|)
return|return
name|ipd_port
return|;
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|3
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
break|break;
case|case
name|CVMX_BOARD_TYPE_CUST_NB5
case|:
if|if
condition|(
name|ipd_port
operator|==
literal|2
condition|)
return|return
literal|4
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_4G
case|:
comment|/* Board has 4 SGMII ports. connected QLM3(interface 1) */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_10G
case|:
case|case
name|CVMX_BOARD_TYPE_NIC10E
case|:
return|return
operator|-
literal|1
return|;
comment|/* We don't use clause 45 MDIO for anything */
case|case
name|CVMX_BOARD_TYPE_NIC4E
case|:
if|if
condition|(
name|ipd_port
operator|>=
literal|0
operator|&&
name|ipd_port
operator|<=
literal|3
condition|)
return|return
operator|(
name|ipd_port
operator|+
literal|0x1f
operator|)
operator|&
literal|0x1f
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_NIC2E
case|:
if|if
condition|(
name|ipd_port
operator|>=
literal|0
operator|&&
name|ipd_port
operator|<=
literal|1
condition|)
return|return
operator|(
name|ipd_port
operator|+
literal|1
operator|)
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_REDWING
case|:
return|return
operator|-
literal|1
return|;
comment|/* No PHYs connected to Octeon */
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
return|return
operator|-
literal|1
return|;
comment|/* No PHYs are connected to Octeon, everything is through switch */
case|case
name|CVMX_BOARD_TYPE_CUST_WSX16
case|:
if|if
condition|(
name|ipd_port
operator|>=
literal|0
operator|&&
name|ipd_port
operator|<=
literal|3
condition|)
return|return
name|ipd_port
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|16
operator|&&
name|ipd_port
operator|<=
literal|19
condition|)
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|4
return|;
else|else
return|return
operator|-
literal|1
return|;
comment|/* Private vendor-defined boards.  */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR955
case|:
comment|/* Interface 1 is 12 BCM5482S PHYs.  */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|28
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
return|;
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR730
case|:
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
operator|(
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|+
literal|0x81
return|;
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
return|;
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR321X
case|:
comment|/* Port 0 is a Marvell 88E6161 switch, ports 1 and 2 are Marvell 	       88E1111 interfaces.  */
switch|switch
condition|(
name|ipd_port
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|16
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|2
case|:
return|return
literal|2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
block|}
comment|/* Some unknown board. Somebody forgot to update this function... */
name|cvmx_dprintf
argument_list|(
literal|"%s: Unknown board type %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_board_get_mii_address
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * Get link state of marvell PHY  */
end_comment

begin_function
specifier|static
name|cvmx_helper_link_info_t
name|__get_marvell_phy_link_state
parameter_list|(
name|int
name|phy_addr
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|int
name|phy_status
decl_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/*All the speed information can be read from register 17 in one go.*/
name|phy_status
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|17
argument_list|)
expr_stmt|;
comment|/* If the resolve bit 11 isn't set, see if autoneg is turned off        (bit 12, reg 0). The resolve bit doesn't get set properly when        autoneg is off, so force it */
if|if
condition|(
operator|(
name|phy_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|auto_status
init|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|auto_status
operator|&
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|)
operator|==
literal|0
condition|)
name|phy_status
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
block|}
comment|/* Only return a link if the PHY has finished auto negotiation        and set the resolved bit (bit 11) */
if|if
condition|(
name|phy_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
operator|(
operator|(
name|phy_status
operator|>>
literal|13
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|phy_status
operator|>>
literal|14
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* 10 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 100 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1 Gbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Illegal */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Get link state of broadcom PHY  */
end_comment

begin_function
specifier|static
name|cvmx_helper_link_info_t
name|__get_broadcom_phy_link_state
parameter_list|(
name|int
name|phy_addr
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|int
name|phy_status
decl_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
comment|/* Below we are going to read SMI/MDIO register 0x19 which works        on Broadcom parts */
name|phy_status
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|0x19
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|phy_status
operator|>>
literal|8
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Get link state using inband status  */
end_comment

begin_function
specifier|static
name|cvmx_helper_link_info_t
name|__get_inband_link_state
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|cvmx_gmxx_rxx_rx_inbnd_t
name|inband_status
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|inband_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_RX_INBND
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
name|inband_status
operator|.
name|s
operator|.
name|status
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
name|inband_status
operator|.
name|s
operator|.
name|duplex
expr_stmt|;
switch|switch
condition|(
name|inband_status
operator|.
name|s
operator|.
name|speed
condition|)
block|{
case|case
literal|0
case|:
comment|/* 10 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 100 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1 Gbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Illegal */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
name|result
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
end_if

begin_comment
comment|/**  * @INTERNAL  * Switch MDIO mux to the specified port.  */
end_comment

begin_function
specifier|static
name|int
name|__switch_mdio_mux
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
comment|/* This method is board specific and doesn't use the device tree        information as SE doesn't implement MDIO MUX abstration */
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_EBB5600
case|:
block|{
specifier|static
name|unsigned
name|char
name|qlm_switch_addr
init|=
literal|0
decl_stmt|;
comment|/* Board has 1 management port */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|0
return|;
comment|/* Board has 8 SGMII ports. 4 connected QLM1, 4 connected QLM3 */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|0x3
condition|)
block|{
name|qlm_switch_addr
operator|=
literal|0x3
expr_stmt|;
comment|/* QLM1 */
name|cvmx_twsix_write_ia
argument_list|(
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qlm_switch_addr
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|11000
argument_list|)
expr_stmt|;
comment|/* Let the write complete */
block|}
return|return
name|ipd_port
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|0xC
condition|)
block|{
name|qlm_switch_addr
operator|=
literal|0xC
expr_stmt|;
comment|/* QLM3 */
name|cvmx_twsix_write_ia
argument_list|(
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qlm_switch_addr
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|11000
argument_list|)
expr_stmt|;
comment|/* Let the write complete */
block|}
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
case|case
name|CVMX_BOARD_TYPE_EBB6600
case|:
block|{
specifier|static
name|unsigned
name|char
name|qlm_switch_addr
init|=
literal|0
decl_stmt|;
name|int
name|old_twsi_switch_reg
decl_stmt|;
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|4
return|;
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
comment|/* QLM 2 */
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|2
condition|)
block|{
name|int
name|tries
decl_stmt|;
name|qlm_switch_addr
operator|=
literal|2
expr_stmt|;
name|tries
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|old_twsi_switch_reg
operator|=
name|cvmx_twsix_read8
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tries
operator|--
operator|>
literal|0
operator|&&
name|old_twsi_switch_reg
operator|<
literal|0
condition|)
do|;
comment|/* Set I2C MUX to enable port expander */
name|cvmx_retry_i2c_write
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Set selecter to QLM 1 */
name|cvmx_retry_i2c_write
argument_list|(
literal|0
argument_list|,
literal|0x38
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0xff
argument_list|)
expr_stmt|;
comment|/* disable port expander */
name|cvmx_retry_i2c_write
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|old_twsi_switch_reg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0x101
operator|+
name|ipd_port
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
comment|/* QLM 1 */
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|1
condition|)
block|{
name|int
name|tries
decl_stmt|;
name|qlm_switch_addr
operator|=
literal|1
expr_stmt|;
name|tries
operator|=
literal|3
expr_stmt|;
do|do
block|{
name|old_twsi_switch_reg
operator|=
name|cvmx_twsix_read8
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tries
operator|--
operator|>
literal|0
operator|&&
name|old_twsi_switch_reg
operator|<
literal|0
condition|)
do|;
comment|/* Set I2C MUX to enable port expander */
name|cvmx_retry_i2c_write
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* Set selecter to QLM 2 */
name|cvmx_retry_i2c_write
argument_list|(
literal|0
argument_list|,
literal|0x38
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0xf7
argument_list|)
expr_stmt|;
comment|/* disable port expander */
name|cvmx_retry_i2c_write
argument_list|(
literal|0
argument_list|,
literal|0x70
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|old_twsi_switch_reg
argument_list|)
expr_stmt|;
block|}
return|return
literal|0x101
operator|+
operator|(
name|ipd_port
operator|-
literal|16
operator|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
case|case
name|CVMX_BOARD_TYPE_EBB6100
case|:
block|{
specifier|static
name|char
name|gpio_configured
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|gpio_configured
condition|)
block|{
name|cvmx_gpio_cfg
argument_list|(
literal|3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|gpio_configured
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|4
return|;
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
comment|/* QLM 2 */
block|{
name|cvmx_gpio_set
argument_list|(
literal|1ull
operator|<<
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0x101
operator|+
name|ipd_port
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
comment|/* QLM 0 */
block|{
name|cvmx_gpio_clear
argument_list|(
literal|1ull
operator|<<
literal|3
argument_list|)
expr_stmt|;
return|return
literal|0x101
operator|+
operator|(
name|ipd_port
operator|-
literal|16
operator|)
return|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s: Unknown ipd port 0x%x\n"
argument_list|,
name|__func__
argument_list|,
name|ipd_port
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
default|default:
block|{
name|cvmx_dprintf
argument_list|(
literal|"ERROR : unexpected mdio switch for board=%08x\n"
argument_list|,
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* should never get here */
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * This function is used ethernet ports link speed. This functions uses the  * device tree information to determine the phy address and type of PHY.  * The only supproted PHYs are Marvell and Broadcom.  *  * @param ipd_port IPD input port associated with the port we want to get link  *                 status for.  *  * @return The ports link status. If the link isn't fully resolved, this must  *         return zero.  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_board_link_get_from_dt
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|cvmx_phy_info_t
name|phy_info
decl_stmt|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_SIM
condition|)
block|{
comment|/* The simulator gives you a simulated 1Gbps full duplex link */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
name|phy_info
operator|=
name|__get_phy_info_from_dt
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
comment|//cvmx_dprintf("ipd_port=%d phy_addr=%d dc=%d type=%d \n", ipd_port,
comment|//             phy_info.phy_addr, phy_info.direct_connect, phy_info.phy_type);
if|if
condition|(
name|phy_info
operator|.
name|phy_addr
operator|<
literal|0
condition|)
return|return
name|result
return|;
if|if
condition|(
name|phy_info
operator|.
name|direct_connect
operator|==
literal|0
condition|)
name|__switch_mdio_mux
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|phy_info
operator|.
name|phy_type
condition|)
block|{
case|case
name|BROADCOM_GENERIC_PHY
case|:
name|result
operator|=
name|__get_broadcom_phy_link_state
argument_list|(
name|phy_info
operator|.
name|phy_addr
argument_list|)
expr_stmt|;
break|break;
case|case
name|MARVELL_GENERIC_PHY
case|:
name|result
operator|=
name|__get_marvell_phy_link_state
argument_list|(
name|phy_info
operator|.
name|phy_addr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|result
operator|=
name|__get_inband_link_state
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * This function invokes  __cvmx_helper_board_link_get_from_dt when device tree  * info is available. When the device tree information is not available then  * this function is the board specific method of determining an  * ethernet ports link speed. Most Octeon boards have Marvell PHYs  * and are handled by the fall through case. This function must be  * updated for boards that don't have the normal Marvell PHYs.  *  * This function must be modified for every new Octeon board.  * Internally it uses switch statements based on the cvmx_sysinfo  * data to determine board types and revisions. It relies on the  * fact that every Octeon board receives a unique board type  * enumeration from the bootloader.  *  * @param ipd_port IPD input port associated with the port we want to get link  *                 status for.  *  * @return The ports link status. If the link isn't fully resolved, this must  *         return zero.  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_board_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|int
name|phy_addr
decl_stmt|;
name|int
name|is_broadcom_phy
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|fdt_addr
condition|)
block|{
return|return
name|__cvmx_helper_board_link_get_from_dt
argument_list|(
name|ipd_port
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* Give the user a chance to override the processing of this function */
if|if
condition|(
name|cvmx_override_board_link_get
condition|)
return|return
name|cvmx_override_board_link_get
argument_list|(
name|ipd_port
argument_list|)
return|;
comment|/* Unless we fix it later, all links are defaulted to down */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OCTEON_BOARD_CAPK_0100ND
argument_list|)
comment|/* This switch statement should handle all ports that either don't use         Marvell PHYS, or don't support in-band status */
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_SIM
case|:
comment|/* The simulator gives you a simulated 1Gbps full duplex link */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
break|break;
case|case
name|CVMX_BOARD_TYPE_EBH3100
case|:
case|case
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3020_EVB_HS5
case|:
comment|/* Port 1 on these boards is always Gigabit */
if|if
condition|(
name|ipd_port
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Fall through to the generic code below */
break|break;
case|case
name|CVMX_BOARD_TYPE_EBH5600
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5601
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5610
case|:
comment|/* Board has 1 management ports */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EBH5200
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5201
case|:
case|case
name|CVMX_BOARD_TYPE_EBT5200
case|:
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EBB6100
case|:
case|case
name|CVMX_BOARD_TYPE_EBB6300
case|:
comment|/* Only for MII mode, with PHY addresses 0/1. Default is RGMII*/
case|case
name|CVMX_BOARD_TYPE_EBB6600
case|:
comment|/* Only for MII mode, with PHY addresses 0/1. Default is RGMII*/
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
operator|&&
name|cvmx_helper_board_get_mii_address
argument_list|(
name|ipd_port
argument_list|)
operator|>=
literal|0
operator|&&
name|cvmx_helper_board_get_mii_address
argument_list|(
name|ipd_port
argument_list|)
operator|<=
literal|1
condition|)
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EP6300C
case|:
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_CUST_NB5
case|:
comment|/* Port 1 on these boards is always Gigabit */
if|if
condition|(
name|ipd_port
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
comment|/* The other port uses a broadcom PHY */
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
comment|/* Port 1 on these boards is always Gigabit */
if|if
condition|(
name|ipd_port
operator|==
literal|2
condition|)
block|{
comment|/* Port 2 is not hooked up */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
comment|/* Ports 0 and 1 connect to the switch */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
case|case
name|CVMX_BOARD_TYPE_NIC4E
case|:
case|case
name|CVMX_BOARD_TYPE_NIC2E
case|:
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Private vendor-defined boards.  */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR730
case|:
comment|/* Ports are BCM5482S */
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR321X
case|:
comment|/* Port 0 connects to the switch */
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|phy_addr
operator|=
name|cvmx_helper_board_get_mii_address
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
comment|//cvmx_dprintf("ipd_port=%d phy_addr=%d broadcom=%d\n",
comment|//             ipd_port, phy_addr, is_broadcom_phy);
if|if
condition|(
name|phy_addr
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|is_broadcom_phy
condition|)
block|{
name|result
operator|=
name|__get_broadcom_phy_link_state
argument_list|(
name|phy_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This code assumes we are using a Marvell Gigabit PHY. */
name|result
operator|=
name|__get_marvell_phy_link_state
argument_list|(
name|phy_addr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
comment|/* We don't have a PHY address, so attempt to use in-band status. It is             really important that boards not supporting in-band status never get             here. Reading broken in-band status tends to do bad things */
name|result
operator|=
name|__get_inband_link_state
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We don't have a PHY address and we don't have in-band status. There             is no way to determine the link speed. Return down assuming this             port isn't wired */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If link is down, return all fields as zero. */
if|if
condition|(
operator|!
name|result
operator|.
name|s
operator|.
name|link_up
condition|)
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * This function as a board specific method of changing the PHY  * speed, duplex, and autonegotiation. This programs the PHY and  * not Octeon. This can be used to force Octeon's links to  * specific settings.  *  * @param phy_addr  The address of the PHY to program  * @param link_flags  *                  Flags to control autonegotiation.  Bit 0 is autonegotiation  *                  enable/disable to maintain backward compatibility.  * @param link_info Link speed to program. If the speed is zero and autonegotiation  *                  is enabled, all possible negotiation speeds are advertised.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_board_link_set_phy
parameter_list|(
name|int
name|phy_addr
parameter_list|,
name|cvmx_helper_board_set_phy_link_flags_types_t
name|link_flags
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
comment|/* Set the flow control settings based on link_flags */
if|if
condition|(
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_flow_control_mask
operator|)
operator|!=
name|set_phy_link_flags_flow_control_dont_touch
condition|)
block|{
name|cvmx_mdio_phy_reg_autoneg_adver_t
name|reg_autoneg_adver
decl_stmt|;
name|reg_autoneg_adver
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|asymmetric_pause
operator|=
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_flow_control_mask
operator|)
operator|==
name|set_phy_link_flags_flow_control_enable
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|pause
operator|=
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_flow_control_mask
operator|)
operator|==
name|set_phy_link_flags_flow_control_enable
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|,
name|reg_autoneg_adver
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
comment|/* If speed isn't set and autoneg is on advertise all supported modes */
if|if
condition|(
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_autoneg
operator|)
operator|&&
operator|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|0
operator|)
condition|)
block|{
name|cvmx_mdio_phy_reg_control_t
name|reg_control
decl_stmt|;
name|cvmx_mdio_phy_reg_status_t
name|reg_status
decl_stmt|;
name|cvmx_mdio_phy_reg_autoneg_adver_t
name|reg_autoneg_adver
decl_stmt|;
name|cvmx_mdio_phy_reg_extended_status_t
name|reg_extended_status
decl_stmt|;
name|cvmx_mdio_phy_reg_control_1000_t
name|reg_control_1000
decl_stmt|;
name|reg_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_STATUS
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_t4
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_100base_t4
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_full
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_10_full
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_half
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_10_half
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_full
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_100base_x_full
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_half
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_100base_x_half
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|,
name|reg_autoneg_adver
operator|.
name|u16
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_status
operator|.
name|s
operator|.
name|capable_extended_status
condition|)
block|{
name|reg_extended_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_EXTENDED_STATUS
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_full
operator|=
name|reg_extended_status
operator|.
name|s
operator|.
name|capable_1000base_t_full
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_half
operator|=
name|reg_extended_status
operator|.
name|s
operator|.
name|capable_1000base_t_half
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|,
name|reg_control_1000
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
name|reg_control
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|autoneg_enable
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|restart_autoneg
operator|=
literal|1
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|,
name|reg_control
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_autoneg
operator|)
condition|)
block|{
name|cvmx_mdio_phy_reg_control_t
name|reg_control
decl_stmt|;
name|cvmx_mdio_phy_reg_status_t
name|reg_status
decl_stmt|;
name|cvmx_mdio_phy_reg_autoneg_adver_t
name|reg_autoneg_adver
decl_stmt|;
name|cvmx_mdio_phy_reg_control_1000_t
name|reg_control_1000
decl_stmt|;
name|reg_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_STATUS
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_t4
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_full
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_half
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_full
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_half
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_status
operator|.
name|s
operator|.
name|capable_extended_status
condition|)
block|{
name|reg_control_1000
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_full
operator|=
literal|0
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_half
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
condition|)
block|{
case|case
literal|10
case|:
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_full
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_half
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_full
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_half
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_full
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_half
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
break|break;
block|}
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|,
name|reg_autoneg_adver
operator|.
name|u16
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_status
operator|.
name|s
operator|.
name|capable_extended_status
condition|)
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|,
name|reg_control_1000
operator|.
name|u16
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|autoneg_enable
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|restart_autoneg
operator|=
literal|1
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|,
name|reg_control
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_mdio_phy_reg_control_t
name|reg_control
decl_stmt|;
name|reg_control
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|autoneg_enable
operator|=
literal|0
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|restart_autoneg
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|duplex
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|1000
condition|)
block|{
name|reg_control
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|speed_lsb
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|100
condition|)
block|{
name|reg_control
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|speed_lsb
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|10
condition|)
block|{
name|reg_control
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|speed_lsb
operator|=
literal|0
expr_stmt|;
block|}
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|,
name|reg_control
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * This function is called by cvmx_helper_interface_probe() after it  * determines the number of ports Octeon can support on a specific  * interface. This function is the per board location to override  * this value. It is called with the number of ports Octeon might  * support and should return the number of actual ports on the  * board.  *  * This function must be modified for every new Octeon board.  * Internally it uses switch statements based on the cvmx_sysinfo  * data to determine board types and revisions. It relies on the  * fact that every Octeon board receives a unique board type  * enumeration from the bootloader.  *  * @param interface Interface to probe  * @param supported_ports  *                  Number of ports Octeon supports.  *  * @return Number of ports the actual board supports. Many times this will  *         simple be "support_ports".  */
end_comment

begin_function
name|int
name|__cvmx_helper_board_interface_probe
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|supported_ports
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|2
return|;
break|break;
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|2
return|;
break|break;
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_4G
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
comment|/* The 2nd interface on the EBH5600 is connected to the Marvel switch,             which we don't support. Disable ports connected to it */
case|case
name|CVMX_BOARD_TYPE_EBH5600
case|:
if|if
condition|(
name|interface
operator|==
literal|1
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EBB5600
case|:
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
if|if
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_PICMG
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
break|break;
case|case
name|CVMX_BOARD_TYPE_EBT5810
case|:
return|return
literal|1
return|;
comment|/* Two ports on each SPI: 1 hooked to MAC, 1 loopback                        ** Loopback disabled by default. */
case|case
name|CVMX_BOARD_TYPE_NIC2E
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|2
return|;
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR955
case|:
if|if
condition|(
name|interface
operator|==
literal|1
condition|)
return|return
literal|12
return|;
break|break;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_UBOOT
if|if
condition|(
name|CVMX_HELPER_INTERFACE_MODE_SPI
operator|==
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|&&
name|getenv
argument_list|(
literal|"disable_spi"
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|supported_ports
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Enable packet input/output from the hardware. This function is  * called after by cvmx_helper_packet_hardware_enable() to  * perform board specific initialization. For most boards  * nothing is needed.  *  * @param interface Interface to enable  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_board_hardware_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
condition|)
block|{
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
comment|/* Different config for switch port */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|1
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|1
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Boards with gigabit WAN ports need a different setting that is                 compatible with 100 Mbit settings */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_LANAI2_U
condition|)
block|{
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
condition|)
block|{
comment|/* Broadcom PHYs require different ASX clocks. Unfortunately             many customer don't define a new board Id and simply             mangle the CN3010_EVB_HS5 */
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
comment|/* Some customers boards use a hacked up bootloader that identifies them as             ** CN3010_EVB_HS5 evaluation boards.  This leads to all kinds of configuration             ** problems.  Detect one case, and print warning, while trying to do the right thing.             */
name|int
name|phy_addr
init|=
name|cvmx_helper_board_get_mii_address
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|phy_addr
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|phy_identifier
init|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|0x2
argument_list|)
decl_stmt|;
comment|/* Is it a Broadcom PHY? */
if|if
condition|(
name|phy_identifier
operator|==
literal|0x0143
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR:\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: The board type is mis-configured, and software malfunctions are likely.\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: All boards require a unique board type to identify them.\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR:\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|1000000000
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Gets the clock type used for the USB block based on board type.  * Used by the USB code for auto configuration of clock type.  *  * @return USB clock type enumeration  */
end_comment

begin_function
name|cvmx_helper_board_usb_clock_types_t
name|__cvmx_helper_board_usb_get_clock_type
parameter_list|(
name|void
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|CVMX_BUILD_FOR_LINUX_KERNEL
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|_KERNEL
argument_list|)
operator|)
specifier|const
name|void
modifier|*
name|fdt_addr
init|=
name|CASTPTR
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|fdt_addr
argument_list|)
decl_stmt|;
name|int
name|nodeoffset
decl_stmt|;
specifier|const
name|void
modifier|*
name|nodep
decl_stmt|;
name|int
name|len
decl_stmt|;
name|uint32_t
name|speed
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fdt_addr
condition|)
block|{
name|nodeoffset
operator|=
name|fdt_path_offset
argument_list|(
name|fdt_addr
argument_list|,
literal|"/soc/uctl"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeoffset
operator|<
literal|0
condition|)
name|nodeoffset
operator|=
name|fdt_path_offset
argument_list|(
name|fdt_addr
argument_list|,
literal|"/soc/usbn"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodeoffset
operator|>=
literal|0
condition|)
block|{
name|nodep
operator|=
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|nodeoffset
argument_list|,
literal|"refclk-type"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodep
operator|!=
name|NULL
operator|&&
name|len
operator|>
literal|0
condition|)
name|type
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|nodep
expr_stmt|;
else|else
name|type
operator|=
literal|"unknown"
expr_stmt|;
name|nodep
operator|=
name|fdt_getprop
argument_list|(
name|fdt_addr
argument_list|,
name|nodeoffset
argument_list|,
literal|"refclk-frequency"
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|nodep
operator|!=
name|NULL
operator|&&
name|len
operator|==
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
condition|)
name|speed
operator|=
name|fdt32_to_cpu
argument_list|(
operator|*
operator|(
name|int
operator|*
operator|)
name|nodep
argument_list|)
expr_stmt|;
else|else
name|speed
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"crystal"
argument_list|)
condition|)
block|{
if|if
condition|(
name|speed
operator|==
literal|0
operator|||
name|speed
operator|==
literal|12000000
condition|)
return|return
name|USB_CLOCK_TYPE_CRYSTAL_12
return|;
else|else
name|printf
argument_list|(
literal|"Warning: invalid crystal speed for USB clock type in FDT\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|type
argument_list|,
literal|"external"
argument_list|)
condition|)
block|{
switch|switch
condition|(
name|speed
condition|)
block|{
case|case
literal|12000000
case|:
return|return
name|USB_CLOCK_TYPE_REF_12
return|;
case|case
literal|24000000
case|:
return|return
name|USB_CLOCK_TYPE_REF_24
return|;
case|case
literal|0
case|:
case|case
literal|48000000
case|:
return|return
name|USB_CLOCK_TYPE_REF_48
return|;
default|default:
name|printf
argument_list|(
literal|"Warning: invalid USB clock speed of %u hz in FDT\n"
argument_list|,
name|speed
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|printf
argument_list|(
literal|"Warning: invalid USB reference clock type \"%s\" in FDT\n"
argument_list|,
name|type
condition|?
name|type
else|:
literal|"NULL"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR321X
case|:
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_BOARD_CAPK_0100ND
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
case|:
endif|#
directive|endif
case|case
name|CVMX_BOARD_TYPE_NIC10E_66
case|:
return|return
name|USB_CLOCK_TYPE_CRYSTAL_12
return|;
case|case
name|CVMX_BOARD_TYPE_NIC10E
case|:
return|return
name|USB_CLOCK_TYPE_REF_12
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN6XXX
argument_list|)
comment|/* Most boards except NIC10e use a 12MHz crystal */
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CNF7XXX
argument_list|)
condition|)
return|return
name|USB_CLOCK_TYPE_CRYSTAL_12
return|;
return|return
name|USB_CLOCK_TYPE_REF_48
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Adjusts the number of available USB ports on Octeon based on board  * specifics.  *  * @param supported_ports expected number of ports based on chip type;  *  *  * @return number of available usb ports, based on board specifics.  *         Return value is supported_ports if function does not  *         override.  */
end_comment

begin_function
name|int
name|__cvmx_helper_board_usb_get_num_ports
parameter_list|(
name|int
name|supported_ports
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_4G
case|:
case|case
name|CVMX_BOARD_TYPE_NIC2E
case|:
return|return
literal|0
return|;
block|}
return|return
name|supported_ports
return|;
block|}
end_function

end_unit

