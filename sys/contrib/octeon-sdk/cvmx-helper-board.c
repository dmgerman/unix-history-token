begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Networks (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Networks nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM  NETWORKS MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Helper functions to abstract board specific data about  * network ports from the rest of the cvmx-helper files.  *  *<hr>$Revision: 49627 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-bootinfo.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-smix-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-gmxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-asxx-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-mdio.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-util.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-board.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-twsi.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-app-init.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-twsi.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-mdio.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-util.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-board.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * cvmx_override_board_link_get(int ipd_port) is a function  * pointer. It is meant to allow customization of the process of  * talking to a PHY to determine link speed. It is called every  * time a PHY must be polled for link status. Users should set  * this pointer to a function before calling any cvmx-helper  * operations.  */
end_comment

begin_function_decl
name|CVMX_SHARED
name|cvmx_helper_link_info_t
function_decl|(
modifier|*
name|cvmx_override_board_link_get
function_decl|)
parameter_list|(
name|int
name|ipd_port
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_comment
comment|/**  * Return the MII PHY address associated with the given IPD  * port. A result of -1 means there isn't a MII capable PHY  * connected to this port. On chips supporting multiple MII  * busses the bus number is encoded in bits<15:8>.  *  * This function must be modified for every new Octeon board.  * Internally it uses switch statements based on the cvmx_sysinfo  * data to determine board types and revisions. It replies on the  * fact that every Octeon board receives a unique board type  * enumeration from the bootloader.  *  * @param ipd_port Octeon IPD port to get the MII address for.  *  * @return MII PHY address and bus number or -1.  */
end_comment

begin_function
name|int
name|cvmx_helper_board_get_mii_address
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
comment|/*      * Board types we have to know at compile-time.      */
ifdef|#
directive|ifdef
name|OCTEON_BOARD_CAPK_0100ND
switch|switch
condition|(
name|ipd_port
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|2
return|;
case|case
literal|1
case|:
return|return
literal|3
return|;
case|case
literal|2
case|:
comment|/* XXX Switch PHY?  */
return|return
operator|-
literal|1
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
comment|/*      * For board types we can determine at runtime.      */
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_SIM
case|:
comment|/* Simulator doesn't have MII */
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBT3000
case|:
case|case
name|CVMX_BOARD_TYPE_EBT5800
case|:
case|case
name|CVMX_BOARD_TYPE_THUNDER
case|:
case|case
name|CVMX_BOARD_TYPE_NICPRO2
case|:
comment|/* Interface 0 is SPI4, interface 1 is RGMII */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
return|return
literal|0x1c
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_KODAMA
case|:
case|case
name|CVMX_BOARD_TYPE_EBH3100
case|:
case|case
name|CVMX_BOARD_TYPE_HIKARI
case|:
case|case
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3020_EVB_HS5
case|:
comment|/* Port 0 is WAN connected to a PHY, Port 1 is GMII connected to a                 switch */
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
return|return
literal|4
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|==
literal|1
condition|)
return|return
literal|9
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_NAC38
case|:
comment|/* Board has 8 RGMII ports PHYs are 0-7 */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
return|;
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|4
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBH3000
case|:
comment|/* Board has dual SPI4 and no PHYs */
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBT5810
case|:
comment|/* Board has 10g PHYs hooked up to the MII controller on the             ** IXF18201 MAC.  The 10G PHYS use clause 45 MDIO which the CN58XX             ** does not support. All MII accesses go through the IXF part. */
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBH5200
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5201
case|:
case|case
name|CVMX_BOARD_TYPE_EBT5200
case|:
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
return|;
comment|/* Board has 4 SGMII ports. The PHYs start right after the MII                 ports MII0 = 0, MII1 = 1, SGMII = 2-5 */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|2
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBH5600
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5601
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5610
case|:
comment|/* Board has 1 management port */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|0
return|;
comment|/* Board has 8 SGMII ports. 4 connect out, two connect to a switch,                 and 2 loop to each other */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_EBB5600
case|:
block|{
specifier|static
name|unsigned
name|char
name|qlm_switch_addr
init|=
literal|0
decl_stmt|;
comment|/* Board has 1 management port */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
return|return
literal|0
return|;
comment|/* Board has 8 SGMII ports. 4 connected QLM1, 4 connected QLM3 */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|0x3
condition|)
block|{
name|qlm_switch_addr
operator|=
literal|0x3
expr_stmt|;
comment|/* QLM1 */
name|cvmx_twsix_write_ia
argument_list|(
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qlm_switch_addr
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|11000
argument_list|)
expr_stmt|;
comment|/* Let the write complete */
block|}
return|return
name|ipd_port
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
block|{
if|if
condition|(
name|qlm_switch_addr
operator|!=
literal|0xC
condition|)
block|{
name|qlm_switch_addr
operator|=
literal|0xC
expr_stmt|;
comment|/* QLM3 */
name|cvmx_twsix_write_ia
argument_list|(
literal|0
argument_list|,
literal|0x71
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|qlm_switch_addr
argument_list|)
expr_stmt|;
name|cvmx_wait_usec
argument_list|(
literal|11000
argument_list|)
expr_stmt|;
comment|/* Let the write complete */
block|}
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
case|case
name|CVMX_BOARD_TYPE_EBB6300
case|:
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
return|return
name|ipd_port
operator|-
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|4
return|;
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
operator|+
literal|1
operator|+
operator|(
literal|1
operator|<<
literal|8
operator|)
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_NB5
case|:
if|if
condition|(
name|ipd_port
operator|==
literal|2
condition|)
return|return
literal|4
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_4G
case|:
comment|/* Board has 4 SGMII ports. connected QLM3(interface 1) */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|20
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_10G
case|:
return|return
operator|-
literal|1
return|;
comment|/* We don't use clause 45 MDIO for anything */
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
return|return
operator|-
literal|1
return|;
comment|/* No PHYs are connected to Octeon, everything is through switch */
case|case
name|CVMX_BOARD_TYPE_CUST_WSX16
case|:
if|if
condition|(
name|ipd_port
operator|>=
literal|0
operator|&&
name|ipd_port
operator|<=
literal|3
condition|)
return|return
name|ipd_port
return|;
elseif|else
if|if
condition|(
name|ipd_port
operator|>=
literal|16
operator|&&
name|ipd_port
operator|<=
literal|19
condition|)
return|return
name|ipd_port
operator|-
literal|16
operator|+
literal|4
return|;
else|else
return|return
operator|-
literal|1
return|;
comment|/* Private vendor-defined boards.  */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR955
case|:
comment|/* Interface 1 is 12 BCM5482S PHYs.  */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|16
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|28
operator|)
condition|)
return|return
name|ipd_port
operator|-
literal|16
return|;
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR730
case|:
if|if
condition|(
operator|(
name|ipd_port
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
literal|4
operator|)
condition|)
return|return
name|ipd_port
return|;
return|return
operator|-
literal|1
return|;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
comment|/* Port 0 is a Marvell 88E6161 switch, ports 1 and 2 are Marvell 	       88E1111 interfaces.  */
switch|switch
condition|(
name|ipd_port
condition|)
block|{
case|case
literal|0
case|:
return|return
literal|16
return|;
case|case
literal|1
case|:
return|return
literal|1
return|;
case|case
literal|2
case|:
return|return
literal|2
return|;
default|default:
return|return
operator|-
literal|1
return|;
block|}
endif|#
directive|endif
block|}
comment|/* Some unknown board. Somebody forgot to update this function... */
name|cvmx_dprintf
argument_list|(
literal|"%s: Unknown board type %d\n"
argument_list|,
name|__FUNCTION__
argument_list|,
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_helper_board_get_mii_address
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * @INTERNAL  * This function is the board specific method of determining an  * ethernet ports link speed. Most Octeon boards have Marvell PHYs  * and are handled by the fall through case. This function must be  * updated for boards that don't have the normal Marvell PHYs.  *  * This function must be modified for every new Octeon board.  * Internally it uses switch statements based on the cvmx_sysinfo  * data to determine board types and revisions. It relies on the  * fact that every Octeon board receives a unique board type  * enumeration from the bootloader.  *  * @param ipd_port IPD input port associated with the port we want to get link  *                 status for.  *  * @return The ports link status. If the link isn't fully resolved, this must  *         return zero.  */
end_comment

begin_function
name|cvmx_helper_link_info_t
name|__cvmx_helper_board_link_get
parameter_list|(
name|int
name|ipd_port
parameter_list|)
block|{
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|int
name|phy_addr
decl_stmt|;
name|int
name|is_broadcom_phy
init|=
literal|0
decl_stmt|;
comment|/* Give the user a chance to override the processing of this function */
if|if
condition|(
name|cvmx_override_board_link_get
condition|)
return|return
name|cvmx_override_board_link_get
argument_list|(
name|ipd_port
argument_list|)
return|;
comment|/* Unless we fix it later, all links are defaulted to down */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|OCTEON_BOARD_CAPK_0100ND
argument_list|)
comment|/* This switch statement should handle all ports that either don't use         Marvell PHYS, or don't support in-band status */
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_SIM
case|:
comment|/* The simulator gives you a simulated 1Gbps full duplex link */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
break|break;
case|case
name|CVMX_BOARD_TYPE_EBH3100
case|:
case|case
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_CN3020_EVB_HS5
case|:
comment|/* Port 1 on these boards is always Gigabit */
if|if
condition|(
name|ipd_port
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* Fall through to the generic code below */
break|break;
case|case
name|CVMX_BOARD_TYPE_EBH5600
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5601
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5610
case|:
comment|/* Board has 1 management ports */
if|if
condition|(
name|ipd_port
operator|==
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
condition|)
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EBH5200
case|:
case|case
name|CVMX_BOARD_TYPE_EBH5201
case|:
case|case
name|CVMX_BOARD_TYPE_EBT5200
case|:
comment|/* Board has 2 management ports */
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
condition|)
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EBB6300
case|:
comment|/* Only for MII mode, with PHY addresses 0/1. Default is RGMII*/
if|if
condition|(
operator|(
name|ipd_port
operator|>=
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|)
operator|&&
operator|(
name|ipd_port
operator|<
operator|(
name|CVMX_HELPER_BOARD_MGMT_IPD_PORT
operator|+
literal|2
operator|)
operator|)
operator|&&
name|cvmx_helper_board_get_mii_address
argument_list|(
name|ipd_port
argument_list|)
operator|>=
literal|0
operator|&&
name|cvmx_helper_board_get_mii_address
argument_list|(
name|ipd_port
argument_list|)
operator|<=
literal|1
condition|)
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_CUST_NB5
case|:
comment|/* Port 1 on these boards is always Gigabit */
if|if
condition|(
name|ipd_port
operator|==
literal|1
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
comment|/* The other port uses a broadcom PHY */
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
comment|/* Port 1 on these boards is always Gigabit */
if|if
condition|(
name|ipd_port
operator|==
literal|2
condition|)
block|{
comment|/* Port 2 is not hooked up */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
else|else
block|{
comment|/* Ports 0 and 1 connect to the switch */
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
comment|/* Private vendor-defined boards.  */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR730
case|:
comment|/* Ports are BCM5482S */
name|is_broadcom_phy
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
comment|/* Port 0 connects to the switch */
if|if
condition|(
name|ipd_port
operator|==
literal|0
condition|)
block|{
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
return|return
name|result
return|;
block|}
break|break;
endif|#
directive|endif
block|}
endif|#
directive|endif
name|phy_addr
operator|=
name|cvmx_helper_board_get_mii_address
argument_list|(
name|ipd_port
argument_list|)
expr_stmt|;
if|if
condition|(
name|phy_addr
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|is_broadcom_phy
condition|)
block|{
comment|/* Below we are going to read SMI/MDIO register 0x19 which works                 on Broadcom parts */
name|int
name|phy_status
init|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|0x19
argument_list|)
decl_stmt|;
switch|switch
condition|(
operator|(
name|phy_status
operator|>>
literal|8
operator|)
operator|&
literal|0x7
condition|)
block|{
case|case
literal|0
case|:
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|5
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|6
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|7
case|:
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
literal|1
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* This code assumes we are using a Marvell Gigabit PHY. All the                 speed information can be read from register 17 in one go. Somebody                 using a different PHY will need to handle it above in the board                 specific area */
name|int
name|phy_status
init|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|17
argument_list|)
decl_stmt|;
comment|/* If the resolve bit 11 isn't set, see if autoneg is turned off                 (bit 12, reg 0). The resolve bit doesn't get set properly when                 autoneg is off, so force it */
if|if
condition|(
operator|(
name|phy_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|auto_status
init|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|auto_status
operator|&
operator|(
literal|1
operator|<<
literal|12
operator|)
operator|)
operator|==
literal|0
condition|)
name|phy_status
operator||=
literal|1
operator|<<
literal|11
expr_stmt|;
block|}
comment|/* Only return a link if the PHY has finished auto negotiation                 and set the resolved bit (bit 11) */
if|if
condition|(
name|phy_status
operator|&
operator|(
literal|1
operator|<<
literal|11
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_BOARD_CAPK_0100ND
argument_list|)
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
operator|(
name|phy_status
operator|>>
literal|10
operator|)
operator|&
literal|1
expr_stmt|;
else|#
directive|else
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
operator|(
operator|(
name|phy_status
operator|>>
literal|13
operator|)
operator|&
literal|1
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|phy_status
operator|>>
literal|14
operator|)
operator|&
literal|3
condition|)
block|{
case|case
literal|0
case|:
comment|/* 10 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 100 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1 Gbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Illegal */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN3XXX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN58XX
argument_list|)
operator|||
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN50XX
argument_list|)
condition|)
block|{
comment|/* We don't have a PHY address, so attempt to use in-band status. It is             really important that boards not supporting in-band status never get             here. Reading broken in-band status tends to do bad things */
name|cvmx_gmxx_rxx_rx_inbnd_t
name|inband_status
decl_stmt|;
name|int
name|interface
init|=
name|cvmx_helper_get_interface_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|int
name|index
init|=
name|cvmx_helper_get_interface_index_num
argument_list|(
name|ipd_port
argument_list|)
decl_stmt|;
name|inband_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_GMXX_RXX_RX_INBND
argument_list|(
name|index
argument_list|,
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|link_up
operator|=
name|inband_status
operator|.
name|s
operator|.
name|status
expr_stmt|;
name|result
operator|.
name|s
operator|.
name|full_duplex
operator|=
name|inband_status
operator|.
name|s
operator|.
name|duplex
expr_stmt|;
switch|switch
condition|(
name|inband_status
operator|.
name|s
operator|.
name|speed
condition|)
block|{
case|case
literal|0
case|:
comment|/* 10 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|10
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* 100 Mbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|100
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* 1 Gbps */
name|result
operator|.
name|s
operator|.
name|speed
operator|=
literal|1000
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* Illegal */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* We don't have a PHY address and we don't have in-band status. There             is no way to determine the link speed. Return down assuming this             port isn't wired */
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If link is down, return all fields as zero. */
if|if
condition|(
operator|!
name|result
operator|.
name|s
operator|.
name|link_up
condition|)
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/**  * This function as a board specific method of changing the PHY  * speed, duplex, and autonegotiation. This programs the PHY and  * not Octeon. This can be used to force Octeon's links to  * specific settings.  *  * @param phy_addr  The address of the PHY to program  * @param link_flags  *                  Flags to control autonegotiation.  Bit 0 is autonegotiation  *                  enable/disable to maintain backward compatibility.  * @param link_info Link speed to program. If the speed is zero and autonegotiation  *                  is enabled, all possible negotiation speeds are advertised.  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|cvmx_helper_board_link_set_phy
parameter_list|(
name|int
name|phy_addr
parameter_list|,
name|cvmx_helper_board_set_phy_link_flags_types_t
name|link_flags
parameter_list|,
name|cvmx_helper_link_info_t
name|link_info
parameter_list|)
block|{
comment|/* Set the flow control settings based on link_flags */
if|if
condition|(
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_flow_control_mask
operator|)
operator|!=
name|set_phy_link_flags_flow_control_dont_touch
condition|)
block|{
name|cvmx_mdio_phy_reg_autoneg_adver_t
name|reg_autoneg_adver
decl_stmt|;
name|reg_autoneg_adver
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|asymmetric_pause
operator|=
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_flow_control_mask
operator|)
operator|==
name|set_phy_link_flags_flow_control_enable
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|pause
operator|=
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_flow_control_mask
operator|)
operator|==
name|set_phy_link_flags_flow_control_enable
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|,
name|reg_autoneg_adver
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
comment|/* If speed isn't set and autoneg is on advertise all supported modes */
if|if
condition|(
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_autoneg
operator|)
operator|&&
operator|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|0
operator|)
condition|)
block|{
name|cvmx_mdio_phy_reg_control_t
name|reg_control
decl_stmt|;
name|cvmx_mdio_phy_reg_status_t
name|reg_status
decl_stmt|;
name|cvmx_mdio_phy_reg_autoneg_adver_t
name|reg_autoneg_adver
decl_stmt|;
name|cvmx_mdio_phy_reg_extended_status_t
name|reg_extended_status
decl_stmt|;
name|cvmx_mdio_phy_reg_control_1000_t
name|reg_control_1000
decl_stmt|;
name|reg_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_STATUS
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_t4
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_100base_t4
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_full
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_10_full
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_half
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_10_half
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_full
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_100base_x_full
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_half
operator|=
name|reg_status
operator|.
name|s
operator|.
name|capable_100base_x_half
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|,
name|reg_autoneg_adver
operator|.
name|u16
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_status
operator|.
name|s
operator|.
name|capable_extended_status
condition|)
block|{
name|reg_extended_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_EXTENDED_STATUS
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_full
operator|=
name|reg_extended_status
operator|.
name|s
operator|.
name|capable_1000base_t_full
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_half
operator|=
name|reg_extended_status
operator|.
name|s
operator|.
name|capable_1000base_t_half
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|,
name|reg_control_1000
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
name|reg_control
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|autoneg_enable
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|restart_autoneg
operator|=
literal|1
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|,
name|reg_control
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|link_flags
operator|&
name|set_phy_link_flags_autoneg
operator|)
condition|)
block|{
name|cvmx_mdio_phy_reg_control_t
name|reg_control
decl_stmt|;
name|cvmx_mdio_phy_reg_status_t
name|reg_status
decl_stmt|;
name|cvmx_mdio_phy_reg_autoneg_adver_t
name|reg_autoneg_adver
decl_stmt|;
name|cvmx_mdio_phy_reg_extended_status_t
name|reg_extended_status
decl_stmt|;
name|cvmx_mdio_phy_reg_control_1000_t
name|reg_control_1000
decl_stmt|;
name|reg_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_STATUS
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|)
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_t4
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_full
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_half
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_full
operator|=
literal|0
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_half
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|reg_status
operator|.
name|s
operator|.
name|capable_extended_status
condition|)
block|{
name|reg_extended_status
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_EXTENDED_STATUS
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|)
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_full
operator|=
literal|0
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_half
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
condition|)
block|{
case|case
literal|10
case|:
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_full
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_10base_tx_half
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
break|break;
case|case
literal|100
case|:
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_full
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
name|reg_autoneg_adver
operator|.
name|s
operator|.
name|advert_100base_tx_half
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
break|break;
case|case
literal|1000
case|:
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_full
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
name|reg_control_1000
operator|.
name|s
operator|.
name|advert_1000base_t_half
operator|=
operator|!
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
break|break;
block|}
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_AUTONEG_ADVER
argument_list|,
name|reg_autoneg_adver
operator|.
name|u16
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_status
operator|.
name|s
operator|.
name|capable_extended_status
condition|)
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL_1000
argument_list|,
name|reg_control_1000
operator|.
name|u16
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|autoneg_enable
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|restart_autoneg
operator|=
literal|1
expr_stmt|;
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|,
name|reg_control
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cvmx_mdio_phy_reg_control_t
name|reg_control
decl_stmt|;
name|reg_control
operator|.
name|u16
operator|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|)
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|autoneg_enable
operator|=
literal|0
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|restart_autoneg
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|duplex
operator|=
name|link_info
operator|.
name|s
operator|.
name|full_duplex
expr_stmt|;
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|1000
condition|)
block|{
name|reg_control
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|1
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|speed_lsb
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|100
condition|)
block|{
name|reg_control
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|speed_lsb
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|link_info
operator|.
name|s
operator|.
name|speed
operator|==
literal|10
condition|)
block|{
name|reg_control
operator|.
name|s
operator|.
name|speed_msb
operator|=
literal|0
expr_stmt|;
name|reg_control
operator|.
name|s
operator|.
name|speed_lsb
operator|=
literal|0
expr_stmt|;
block|}
name|cvmx_mdio_write
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
name|CVMX_MDIO_PHY_REG_CONTROL
argument_list|,
name|reg_control
operator|.
name|u16
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * This function is called by cvmx_helper_interface_probe() after it  * determines the number of ports Octeon can support on a specific  * interface. This function is the per board location to override  * this value. It is called with the number of ports Octeon might  * support and should return the number of actual ports on the  * board.  *  * This function must be modified for every new Octeon board.  * Internally it uses switch statements based on the cvmx_sysinfo  * data to determine board types and revisions. It relies on the  * fact that every Octeon board receives a unique board type  * enumeration from the bootloader.  *  * @param interface Interface to probe  * @param supported_ports  *                  Number of ports Octeon supports.  *  * @return Number of ports the actual board supports. Many times this will  *         simple be "support_ports".  */
end_comment

begin_function
name|int
name|__cvmx_helper_board_interface_probe
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|supported_ports
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|2
return|;
break|break;
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|2
return|;
break|break;
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_4G
case|:
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
return|return
literal|0
return|;
break|break;
comment|/* The 2nd interface on the EBH5600 is connected to the Marvel switch,             which we don't support. Disable ports connected to it */
case|case
name|CVMX_BOARD_TYPE_EBH5600
case|:
if|if
condition|(
name|interface
operator|==
literal|1
condition|)
return|return
literal|0
return|;
break|break;
case|case
name|CVMX_BOARD_TYPE_EBB5600
case|:
ifdef|#
directive|ifdef
name|CVMX_ENABLE_PKO_FUNCTIONS
if|if
condition|(
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|==
name|CVMX_HELPER_INTERFACE_MODE_PICMG
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
break|break;
case|case
name|CVMX_BOARD_TYPE_EBT5810
case|:
return|return
literal|1
return|;
comment|/* Two ports on each SPI: 1 hooked to MAC, 1 loopback                        ** Loopback disabled by default. */
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR955
case|:
if|if
condition|(
name|interface
operator|==
literal|1
condition|)
return|return
literal|12
return|;
break|break;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_UBOOT
if|if
condition|(
name|CVMX_HELPER_INTERFACE_MODE_SPI
operator|==
name|cvmx_helper_interface_get_mode
argument_list|(
name|interface
argument_list|)
operator|&&
name|getenv
argument_list|(
literal|"disable_spi"
argument_list|)
condition|)
return|return
literal|0
return|;
endif|#
directive|endif
return|return
name|supported_ports
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Enable packet input/output from the hardware. This function is  * called after by cvmx_helper_packet_hardware_enable() to  * perform board specific initialization. For most boards  * nothing is needed.  *  * @param interface Interface to enable  *  * @return Zero on success, negative on failure  */
end_comment

begin_function
name|int
name|__cvmx_helper_board_hardware_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CN3005_EVB_HS5
condition|)
block|{
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
comment|/* Different config for switch port */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|1
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|1
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Boards with gigabit WAN ports need a different setting that is                 compatible with 100 Mbit settings */
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|0xc
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_LANAI2_U
condition|)
block|{
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
operator|==
name|CVMX_BOARD_TYPE_CN3010_EVB_HS5
condition|)
block|{
comment|/* Broadcom PHYs require different ASX clocks. Unfortunately             many customer don't define a new board Id and simply             mangle the CN3010_EVB_HS5 */
if|if
condition|(
name|interface
operator|==
literal|0
condition|)
block|{
comment|/* Some customers boards use a hacked up bootloader that identifies them as             ** CN3010_EVB_HS5 evaluation boards.  This leads to all kinds of configuration             ** problems.  Detect one case, and print warning, while trying to do the right thing.             */
name|int
name|phy_addr
init|=
name|cvmx_helper_board_get_mii_address
argument_list|(
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|phy_addr
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|phy_identifier
init|=
name|cvmx_mdio_read
argument_list|(
name|phy_addr
operator|>>
literal|8
argument_list|,
name|phy_addr
operator|&
literal|0xff
argument_list|,
literal|0x2
argument_list|)
decl_stmt|;
comment|/* Is it a Broadcom PHY? */
if|if
condition|(
name|phy_identifier
operator|==
literal|0x0143
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR:\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: Board type is CVMX_BOARD_TYPE_CN3010_EVB_HS5, but Broadcom PHY found.\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: The board type is mis-configured, and software malfunctions are likely.\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR: All boards require a unique board type to identify them.\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ERROR:\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cvmx_wait
argument_list|(
literal|1000000000
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_RX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ASXX_TX_CLK_SETX
argument_list|(
literal|0
argument_list|,
name|interface
argument_list|)
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Gets the clock type used for the USB block based on board type.  * Used by the USB code for auto configuration of clock type.  *  * @return USB clock type enumeration  */
end_comment

begin_function
name|cvmx_helper_board_usb_clock_types_t
name|__cvmx_helper_board_usb_get_clock_type
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_BBGW_REF
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_A
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_U
case|:
case|case
name|CVMX_BOARD_TYPE_LANAI2_G
case|:
if|#
directive|if
name|defined
argument_list|(
name|OCTEON_VENDOR_LANNER
argument_list|)
case|case
name|CVMX_BOARD_TYPE_CUST_LANNER_MR320
case|:
endif|#
directive|endif
return|return
name|USB_CLOCK_TYPE_CRYSTAL_12
return|;
block|}
return|return
name|USB_CLOCK_TYPE_REF_48
return|;
block|}
end_function

begin_comment
comment|/**  * @INTERNAL  * Adjusts the number of available USB ports on Octeon based on board  * specifics.  *  * @param supported_ports expected number of ports based on chip type;  *  *  * @return number of available usb ports, based on board specifics.  *         Return value is supported_ports if function does not  *         override.  */
end_comment

begin_function
name|int
name|__cvmx_helper_board_usb_get_num_ports
parameter_list|(
name|int
name|supported_ports
parameter_list|)
block|{
switch|switch
condition|(
name|cvmx_sysinfo_get
argument_list|()
operator|->
name|board_type
condition|)
block|{
case|case
name|CVMX_BOARD_TYPE_NIC_XLE_4G
case|:
return|return
literal|0
return|;
block|}
return|return
name|supported_ports
return|;
block|}
end_function

end_unit

